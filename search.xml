<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅解析Containerd</title>
      <link href="/2024/08/07/Containerd/"/>
      <url>/2024/08/07/Containerd/</url>
      
        <content type="html"><![CDATA[<h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>最近在集群中遇到了很多containerd的问题，所以不禁思考我真的懂containerd吗？？?</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>本文假设你熟悉了</p><ol><li>CRI的概念 &amp;&amp; gRPC &amp;&amp; socket 参考：<a href="https://blog.kalyan.life/2024/07/04/CRI/">https://blog.kalyan.life/2024/07/04/CRI/</a></li><li>shim垫片概念</li></ol><h3 id="containerd是什么就不说啦"><a href="#containerd是什么就不说啦" class="headerlink" title="containerd是什么就不说啦"></a>containerd是什么就不说啦</h3><h3 id="架构（理解就好，主要在于如何使用，想要研究可以去看源码）"><a href="#架构（理解就好，主要在于如何使用，想要研究可以去看源码）" class="headerlink" title="架构（理解就好，主要在于如何使用，想要研究可以去看源码）"></a>架构（理解就好，主要在于如何使用，想要研究可以去看源码）</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240808100725408.png" alt="image-20240808100725408"></p><h4 id="1-API-层"><a href="#1-API-层" class="headerlink" title="1. API 层"></a>1. API 层</h4><ul><li><strong>gRPC API</strong>: 提供给客户端的 gRPC API，支持包括容器管理、镜像管理、存储管理等操作。</li><li><strong>CRI</strong>: 容器运行时接口，允许 Kubernetes 通过 gRPC API 与 containerd 交互。</li><li><strong>Prometheus</strong>: 用于监控的指标接口，收集和暴露 containerd 的运行时数据。</li></ul><h4 id="2-核心层-Core"><a href="#2-核心层-Core" class="headerlink" title="2. 核心层 (Core)"></a>2. 核心层 (Core)</h4><ul><li><p>Services</p><p>: 包含多种服务，每种服务负责不同的功能模块。</p><ul><li><strong>Containers Service</strong>: 管理容器的生命周期。</li><li><strong>Content Service</strong>: 负责内容管理，处理镜像层的数据。</li><li><strong>Diff Service</strong>: 负责镜像层之间的差异计算。</li><li><strong>Images Service</strong>: 负责镜像的管理。</li><li><strong>Leases Service</strong>: 管理临时资源。</li><li><strong>Namespaces Service</strong>: 提供命名空间支持，隔离不同的容器组。</li><li><strong>Snapshots Service</strong>: 管理快照。</li><li><strong>Tasks Service</strong>: 管理任务的运行。</li></ul></li><li><p>Metadata</p><p>: 提供命名空间支持和元数据管理。</p><ul><li><strong>Containers, Content, Images, Leases, Namespaces, Snapshots</strong>: 各种元数据的管理模块。</li></ul></li></ul><h4 id="3-后端层-Backend"><a href="#3-后端层-Backend" class="headerlink" title="3. 后端层 (Backend)"></a>3. 后端层 (Backend)</h4><ul><li><p><strong>Content Store</strong>: 负责存储内容，可以通过插件和本地存储实现。</p></li><li><p>Snapshotter</p><p>: 管理文件系统的快照。</p><ul><li><strong>overlay, btrfs, devmapper, native, windows, plugin</strong>: 支持多种文件系统和快照技术。</li></ul></li><li><p>Runtime</p><p>: 支持容器运行时。</p><ul><li><strong>runc, runhcs, kata, Firecracker, gVisor, shim</strong>: 支持多种运行时，包括 runc、runhcs、kata containers、Firecracker 和 gVisor。</li><li><strong>v2 shim client</strong>: 每个容器都有一个 shim 进程，隔离容器的生命周期管理，确保容器的独立运行。</li></ul></li></ul><h4 id="4-系统层-System"><a href="#4-系统层-System" class="headerlink" title="4. 系统层 (System)"></a>4. 系统层 (System)</h4><ul><li>支持多种硬件架构和操作系统，包括 ARM、Intel、Windows、Linux。</li></ul><h3 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h3><ul><li>分为三⼤块：Storage 管理镜像⽂件的存储；Metadata 管理镜像和容器的元数据；另外由 Task<br>触发运⾏时。对外提供 GRPC ⽅式的 API 以及 Metrics 接⼝。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240808102354598.png" alt="image-20240808102354598"></p><h3 id="然后我们讲一下重要的配置文件"><a href="#然后我们讲一下重要的配置文件" class="headerlink" title="然后我们讲一下重要的配置文件"></a>然后我们讲一下重要的配置文件</h3><h4 id="config-toml"><a href="#config-toml" class="headerlink" title="config.toml"></a>config.toml</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240808103459459.png" alt="image-20240808103459459"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">version</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="comment"># 配置文件版本</span></span><br><span class="line"></span><br><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="string">&quot;/var/lib/containerd&quot;</span></span><br><span class="line"><span class="comment"># containerd 数据存储的根目录</span></span><br><span class="line"></span><br><span class="line"><span class="string">state</span> <span class="string">=</span> <span class="string">&quot;/run/containerd&quot;</span></span><br><span class="line"><span class="comment"># containerd 状态信息存储目录</span></span><br><span class="line"></span><br><span class="line"><span class="string">oom_score</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># OOM（Out of Memory）分数调整值，用于内存不足时的优先级</span></span><br><span class="line"></span><br><span class="line">[<span class="string">grpc</span>]</span><br><span class="line"><span class="comment"># gRPC 配置部分</span></span><br><span class="line"></span><br><span class="line">  <span class="string">max_recv_message_size</span> <span class="string">=</span> <span class="number">16777216</span></span><br><span class="line">  <span class="comment"># gRPC 最大接收消息大小</span></span><br><span class="line"></span><br><span class="line">  <span class="string">max_send_message_size</span> <span class="string">=</span> <span class="number">16777216</span></span><br><span class="line">  <span class="comment"># gRPC 最大发送消息大小</span></span><br><span class="line"></span><br><span class="line">[<span class="string">debug</span>]</span><br><span class="line"><span class="comment"># 调试配置部分</span></span><br><span class="line"></span><br><span class="line">  <span class="string">level</span> <span class="string">=</span> <span class="string">&quot;info&quot;</span></span><br><span class="line">  <span class="comment"># 日志级别，info 表示信息级别日志</span></span><br><span class="line"></span><br><span class="line">[<span class="string">metrics</span>]</span><br><span class="line"><span class="comment"># 指标配置部分</span></span><br><span class="line"></span><br><span class="line">  <span class="string">address</span> <span class="string">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="comment"># 指标服务监听地址，空表示不启用</span></span><br><span class="line"></span><br><span class="line">  <span class="string">grpc_histogram</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 是否启用 gRPC 直方图</span></span><br><span class="line"></span><br><span class="line">[<span class="string">plugins</span>]</span><br><span class="line"><span class="comment"># 插件配置部分</span></span><br><span class="line"></span><br><span class="line">  [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;</span>]</span><br><span class="line">  <span class="comment"># CRI 插件配置部分</span></span><br><span class="line"></span><br><span class="line">    <span class="string">sandbox_image</span> <span class="string">=</span> <span class="string">&quot;192.168.154.2/registry.k8s.io/pause:3.9&quot;</span></span><br><span class="line">    <span class="comment"># 沙箱镜像，用于 Pod 的基础镜像</span></span><br><span class="line"></span><br><span class="line">    <span class="string">max_container_log_line_size</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 容器日志行的最大长度，-1 表示不限制</span></span><br><span class="line"></span><br><span class="line">    <span class="string">enable_unprivileged_ports</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否启用非特权端口</span></span><br><span class="line"></span><br><span class="line">    <span class="string">enable_unprivileged_icmp</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否启用非特权 ICMP</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd</span>]</span><br><span class="line">    <span class="comment"># containerd 相关配置</span></span><br><span class="line"></span><br><span class="line">      <span class="string">default_runtime_name</span> <span class="string">=</span> <span class="string">&quot;runc&quot;</span></span><br><span class="line">      <span class="comment"># 默认运行时名称</span></span><br><span class="line"></span><br><span class="line">      <span class="string">snapshotter</span> <span class="string">=</span> <span class="string">&quot;overlayfs&quot;</span></span><br><span class="line">      <span class="comment"># 默认使用的快照器类型</span></span><br><span class="line"></span><br><span class="line">      <span class="string">discard_unpacked_layers</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 是否丢弃解包的层</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes</span>]</span><br><span class="line">    <span class="comment"># 容器运行时配置部分</span></span><br><span class="line"></span><br><span class="line">      [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc</span>]</span><br><span class="line">      <span class="comment"># runc 运行时配置部分</span></span><br><span class="line"></span><br><span class="line">        <span class="string">runtime_type</span> <span class="string">=</span> <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line">        <span class="comment"># 运行时类型</span></span><br><span class="line"></span><br><span class="line">        <span class="string">runtime_engine</span> <span class="string">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 运行时引擎</span></span><br><span class="line"></span><br><span class="line">        <span class="string">runtime_root</span> <span class="string">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 运行时根目录</span></span><br><span class="line"></span><br><span class="line">        <span class="string">base_runtime_spec</span> <span class="string">=</span> <span class="string">&quot;/etc/containerd/cri-base.json&quot;</span></span><br><span class="line">        <span class="comment"># 基础运行时规格文件</span></span><br><span class="line"></span><br><span class="line">      [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options</span>]</span><br><span class="line">      <span class="comment"># runc 运行时选项配置部分</span></span><br><span class="line"></span><br><span class="line">        <span class="string">SystemdCgroup</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 是否启用 systemd cgroup</span></span><br><span class="line"></span><br><span class="line">        <span class="string">BinaryName</span> <span class="string">=</span> <span class="string">&quot;/usr/local/bin/runc&quot;</span></span><br><span class="line">        <span class="comment"># runc 二进制文件路径</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry</span>]</span><br><span class="line">    <span class="comment"># 镜像仓库配置部分</span></span><br><span class="line"></span><br><span class="line">      [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors</span>]</span><br><span class="line">      <span class="comment"># 镜像仓库镜像配置部分</span></span><br><span class="line"></span><br><span class="line">        [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;192.168.154.2&quot;</span>]</span><br><span class="line">        <span class="comment"># 指定的镜像仓库</span></span><br><span class="line">          <span class="string">endpoint</span> <span class="string">=</span> [<span class="string">&quot;https://192.168.154.2&quot;</span>]</span><br><span class="line">          <span class="comment"># 镜像仓库的端点 URL</span></span><br><span class="line"></span><br><span class="line">      [<span class="string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs.&quot;192.168.154.2&quot;.tls</span>]</span><br><span class="line">      <span class="comment"># 镜像仓库 TLS 配置部分</span></span><br><span class="line"></span><br><span class="line">        <span class="string">insecure_skip_verify</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 是否跳过 TLS 证书验证</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="值得注意的是这里的镜像仓库有两种加载方式-到了2-0版本就可以用"><a href="#值得注意的是这里的镜像仓库有两种加载方式-到了2-0版本就可以用" class="headerlink" title="值得注意的是这里的镜像仓库有两种加载方式,到了2.0版本就可以用"></a>值得注意的是这里的镜像仓库有两种加载方式,到了2.0版本就可以用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry]</span><br><span class="line">config_path= <span class="string">&quot;/etc/containerd/certs.d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再certs.d目录下面添加你的镜像仓库就好了.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="run-containerd-里面的是什么"><a href="#run-containerd-里面的是什么" class="headerlink" title="/run/containerd/里面的是什么"></a>/run/containerd/里面的是什么</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240808111628400.png" alt="image-20240808111628400"></p><ol><li><strong>containerd.sock</strong>:</li></ol><ul><li>这是 containerd 的主 Unix socket 文件，用于与 containerd 守护进程进行通信。客户端（例如 Docker 或 Kubernetes）通过这个 socket 文件发送管理指令。</li></ul><ol start="2"><li><strong>containerd.sock.ttrpc</strong>:</li></ol><ul><li>这是 containerd 用于 ttrpc（Tiny Transport RPC）通信的 socket 文件。ttrpc 是一种轻量级的 RPC 框架，用于在性能敏感的环境中提供高效的进程间通信。</li></ul><ol start="3"><li><strong>io.containerd.grpc.v1.cri</strong>:</li></ol><ul><li>这个目录包含与 Kubernetes CRI（Container Runtime Interface）集成相关的 socket 文件和配置。containerd 支持 CRI，使得 Kubernetes 可以直接通过 containerd 来管理容器。</li></ul><ol start="4"><li><strong>io.containerd.runtime.v1.linux</strong>:</li></ol><ul><li>这个目录包含与 v1 版本的 containerd 运行时相关的文件和配置，主要用于 Linux 系统上的容器管理。</li></ul><ol start="5"><li><strong>io.containerd.runtime.v2.task</strong>:</li></ol><ul><li>这个目录包含与 v2 版本的 containerd 任务管理相关的文件和配置。v2 版本引入了一些新的特性和改进，用于更高效地管理容器任务。</li></ul><ol start="6"><li><strong>runc</strong>:</li></ol><ul><li>这是 runc 运行时的目录。runc 是一个 CLI 工具，用于根据 OCI（Open Container Initiative）规范创建和运行容器。containerd 使用 runc 作为默认的容器运行时。</li></ul><ol start="7"><li><strong>s</strong>:</li></ol><ul><li>这个目录的具体用途可能需要根据系统的实际配置来确定。它可能是用于存储临时文件、状态文件或特定插件的目录。</li></ul><h3 id="var-lib-containerd-里面的是什么"><a href="#var-lib-containerd-里面的是什么" class="headerlink" title="/var/lib/containerd 里面的是什么"></a>/var/lib/containerd 里面的是什么</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240808113725285.png" alt="image-20240808113725285"></p><ol><li><strong>io.containerd.content.v1.content:</strong></li></ol><ul><li>存储镜像和容器层的内容，包括所有下载的镜像数据。这里的文件通常以内容地址（例如 SHA256 哈希）进行命名和存储。</li></ul><ol start="2"><li><strong>io.containerd.snapshotter.v1.overlayfs:</strong></li></ol><ul><li>这是一个与文件系统快照相关的目录，特别是使用 OverlayFS 作为存储后端时。这个目录包含快照和层的数据，用于构建和管理容器的文件系统层。</li></ul><ol start="3"><li><strong>io.containerd.snapshotter.v1.btrfs:</strong></li></ol><ul><li>类似于 overlayfs 目录，但用于 Btrfs 文件系统。它存储使用 Btrfs 作为存储后端时的快照和层的数据。</li></ul><ol start="4"><li><strong>io.containerd.snapshotter.v1.devmapper:</strong> </li></ol><ul><li>用于 Device Mapper 存储后端的快照数据，存储容器层的信息。</li></ul><ol start="5"><li><strong>io.containerd.grpc.v1.cri:</strong></li></ol><ul><li>包含与 Kubernetes CRI 集成相关的数据和配置。Kubernetes 通过这个目录与 containerd 进行通信和数据交换。</li></ul><ol start="6"><li><strong>tmpmounts:</strong></li></ol><ul><li>临时挂载点目录，用于存储容器运行时的临时文件和挂载点信息。</li></ul><h3 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>描述</th><th>docker</th><th>ctr</th><th>crictl</th><th>nerdctl</th></tr></thead><tbody><tr><td>显示镜像列表</td><td>显示本地主机上的镜像列表</td><td>docker images</td><td>ctr images list</td><td>crictl images</td><td>nerdctl images list</td></tr><tr><td>下载镜像</td><td>从 registry 中下载指定的镜像</td><td>docker pull</td><td>ctr images pull</td><td>crictl pull</td><td>nerdctl pull</td></tr><tr><td>上传镜像</td><td>将本地的镜像上传到 registry</td><td>docker push</td><td>ctr images push</td><td>不支持</td><td>nerdctl images push</td></tr></tbody></table><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><table><thead><tr><th>命令</th><th>描述</th><th>docker</th><th>ctr</th><th>crictl</th><th>nerdctl</th></tr></thead><tbody><tr><td>删除镜像</td><td>删除指定的镜像</td><td>docker rmi</td><td>ctr images remove/delete</td><td>crictl rmi</td><td>nerdctl rmi</td></tr><tr><td>启动容器</td><td>创建并启动容器</td><td>docker run</td><td>ctr run</td><td>crictl run</td><td>nerdctl run</td></tr><tr><td>显示容器列表</td><td>显示本地主机上的容器列表</td><td>docker ps</td><td>ctr tasks ls</td><td>crictl ps</td><td>nerdctl ps</td></tr><tr><td>显示容器详情</td><td>显示容器的详细信息</td><td>docker inspect</td><td>ctr task info</td><td>crictl inspect</td><td>nerdctl inspect</td></tr><tr><td>停止容器</td><td>停止容器的运行</td><td>docker stop</td><td>ctr task kill</td><td>crictl stop</td><td>nerdctl stop</td></tr><tr><td>删除容器</td><td>删除指定的容器</td><td>docker rm</td><td>ctr task delete</td><td>crictl rm</td><td>nerdctl delete</td></tr><tr><td>进入容器</td><td>进入正在运行的容器</td><td>docker exec</td><td>ctr task exec</td><td>crictl exec</td><td>nerdctl exec</td></tr><tr><td>查看容器日志</td><td>显示容器的日志输出</td><td>docker logs</td><td>ctr task logs</td><td>crictl logs</td><td>nerdctl logs</td></tr><tr><td>导出容器</td><td>导出容器文件系统为 tar 包</td><td>docker export</td><td>ctr task export</td><td>不支持</td><td>nerdctl export</td></tr><tr><td>导入容器</td><td>从导出的 tar 包创建一个新的容器</td><td>docker import</td><td>ctr image import</td><td>不支持</td><td>nerdctl import</td></tr><tr><td>构建镜像</td><td>从 Dockerfile 构建镜像</td><td>docker build</td><td>不支持</td><td>不支持</td><td>nerdctl build</td></tr><tr><td>显示网络列表</td><td>显示本地主机上的网络列表</td><td>docker network ls</td><td>ctr network list</td><td>不支持</td><td>nerdctl network ls</td></tr><tr><td>创建网络</td><td>创建一个新的网络</td><td>docker network create</td><td>ctr network create</td><td>不支持</td><td>nerdctl network create</td></tr><tr><td>删除网络</td><td>删除指定的网络</td><td>docker network rm</td><td>ctr network remove</td><td>不支持</td><td>nerdctl network rm</td></tr></tbody></table><h4 id="Containerd-如何存储镜像和容器。⽬录结构是什么样的。是否⽀持-容量限制"><a href="#Containerd-如何存储镜像和容器。⽬录结构是什么样的。是否⽀持-容量限制" class="headerlink" title="Containerd 如何存储镜像和容器。⽬录结构是什么样的。是否⽀持 容量限制"></a>Containerd 如何存储镜像和容器。⽬录结构是什么样的。是否⽀持 容量限制</h4><p>  Containerd 是⼀个容器运⾏时管理程序，它使⽤ OCI（Open Container Initiative）标准来定义容器和镜像。镜像通常被存储在⼀个容器镜像存储库（Container Image Store）中，例如 Docker Hub，或者本地的 OCI 镜像存储库。Containerd 会从存储库中下载镜像，并在本地存储。容器则是使⽤镜像创建的运⾏实例。Containerd 将容器的元数据存储在称为 “snapshots” 的⽬录中。每个容器都有⼀个独⽴的快照⽬录，其中包含容器的根⽂件系统和元数据。Containerd 还⽀持将容器存储在可移动的磁盘上，这种⽅式称为 “offline snapshots”。Containerd ⽀持容器资源限制，可以设置 CPU 和内存的限制，也可以设置 I/O 和⽹络带宽等限制。这些限制是通过使⽤ Linux 内核的 cgroup 和 namespace 功能来实现的。</p><h4 id="Containerd-如何处理⽇志，是否⽀持轮滚"><a href="#Containerd-如何处理⽇志，是否⽀持轮滚" class="headerlink" title="Containerd 如何处理⽇志，是否⽀持轮滚"></a>Containerd 如何处理⽇志，是否⽀持轮滚</h4><p>  Containerd 本身并不负责处理容器的⽇志，⽽是将⽇志处理交给容器运⾏时，如 runc 或 CRI- O。这些容器运⾏时⽀持使⽤各种不同的⽅式来处理容器的⽇志，如直接输出到控制台、将⽇志写⼊⽂件或使⽤⽇志聚合⼯具，如 Fluentd 或ELK Stack。对于容器的⽇志轮滚，⼀般是由容器运⾏时负责实现。例如，runc 可以通过指定 –log-opt max-size 和 –log-opt max-file 参数来控制容器⽇志的⼤⼩和轮滚。当容器⽇志⽂件⼤⼩达到指定的⼤⼩时，runc 会⾃动创建⼀个新的⽇志⽂件，并将旧的⽇志⽂件压缩和删除。类似地，CRI- O 也⽀持使⽤ –log-max-file 和 –log-max-size 参数来控制容器⽇志的轮滚。</p><h4 id="Containerd-重启，是否会导致容器重启"><a href="#Containerd-重启，是否会导致容器重启" class="headerlink" title="Containerd 重启，是否会导致容器重启"></a>Containerd 重启，是否会导致容器重启</h4><p>  当 Containerd 重启时，已经在运⾏的容器不会⽴即停⽌或重启。这是因为容器本身是由容器运⾏时（例如 runc 或CRI- O）管理的，⽽不是由 Containerd 直接控制。因此，Containerd 重启不会直接影响容器的运⾏状态。当 Containerd 重启后，容器运⾏时会重新连接到新的 Containerd 进程，以便继续管理容器。在此过程中，容器运⾏时可能会暂停⼀段时间，导致容器内的应⽤程序暂时⽆法访问，但通常这个时间⾮常短暂，只会影响到容器内正在进⾏的临时操作。需要注意的是，如果 Containerd 重启导致容器存储被破坏或不可⽤，那么容器本身可能会受到影响，因为容器的根⽂<br>件系统和元数据存储在 Containerd 的快照⽬录中。在这种情况下，容器运⾏时可能会⽆法连接到 Containerd，导致容器⽆法正常运⾏。因此，在重启 Containerd 之前，需要确保容器存储的完整性和可⽤性。</p><h4 id="Containerd-的⽹络命名空间是什么样的，⽆-CNI-下的容器，是否⽀持⽹络"><a href="#Containerd-的⽹络命名空间是什么样的，⽆-CNI-下的容器，是否⽀持⽹络" class="headerlink" title="Containerd 的⽹络命名空间是什么样的，⽆ CNI 下的容器，是否⽀持⽹络"></a>Containerd 的⽹络命名空间是什么样的，⽆ CNI 下的容器，是否⽀持⽹络</h4><p>  Containerd 使⽤ Linux 内核的⽹络命名空间（network namespace）来隔离容器的⽹络栈和⽹络配置，以便容器可以拥有⾃⼰独⽴的⽹络栈和⽹络环境。每个容器都有⾃⼰的⽹络命名空间，并且容器之间默认是隔离的，不能相互访问。在没有 CNI（Container Networking Interface）插件的情况下，Containerd 本身并不提供⽹络功能，需要⼿动配置容器的⽹络。可以使⽤ Linux 的⽹络⼯具，如 ip 和 iptables，来⼿动配置容器的⽹络，例如分配 IP 地址、设置路由和防⽕墙规则等。这种⽅式需要⼿动配置和管理，⽐较繁琐。不过，Containerd 可以与 CNI 插件配合使⽤，以便⾃动化配置容器的⽹络。CNI 插件可以在容器创建时⾃动配置⽹络，例如分配 IP 地址、设置⽹络接⼝和路由等。常⻅的 CNI 插件包括 Flannel、Calico、Weave Net 等，它们可以与Containerd 集成，以提供⾃动化的⽹络配置和管理。</p><h4 id="Containerd-有没有-KMEM-泄露-的问题"><a href="#Containerd-有没有-KMEM-泄露-的问题" class="headerlink" title="Containerd 有没有 KMEM 泄露 的问题"></a>Containerd 有没有 KMEM 泄露 的问题</h4><p>  在早期版本的 Containerd 中曾经存在⼀些 KMEM 泄漏的问题。具体来说，这些问题通常与 Containerd 在处理⾼负载情况下使⽤了⼤量的内核内存（KMEM），导致内存泄漏和系统不稳定。不过，Containerd 的开发团队已经在后续版本中修复了这些问题，并采取了⼀些措施来避免 KMEM 泄漏。例如，Containerd 1.4.0 版本中引⼊了 KMEM 限制和监控功能，以便在 Containerd 使⽤⼤量 KMEM 时⾃动降低容器的资源配额，从⽽避免 KMEM 泄漏和系统不稳定。总的来说，如果您使⽤的是较新版本的 Containerd，并且在运⾏期间遇到了 KMEM 泄漏的问题，建议升级到最新版本并检查您的系统配置，以确保已经正确配置了 KMEM 限制和监控。同时，如果您的系统遇到了 KMEM 泄漏等其他问题，也可以向 Containerd 的开发团队报告问题并寻求技术⽀持。</p><h4 id="Containerd-shim-runc-v1与v2的区别"><a href="#Containerd-shim-runc-v1与v2的区别" class="headerlink" title="Containerd-shim-runc-v1与v2的区别"></a>Containerd-shim-runc-v1与v2的区别</h4><p>  containerd-shim-runc-v1 和 containerd-shim-runc-v2 是 containerd 中使⽤的两个 shim 实现。这两个 shim 实现都是使⽤ runc 来启动和管理容器的。containerd-shim-runc-v1 是 containerd 中旧的 shim 实现，它使⽤进程间通信 (IPC) 来与 containerd 守护进程进⾏通信，通常会使⽤ UNIX 域套接字或 FIFO 进⾏通信。它是在 containerd 1.0 中引⼊的，主要⽤于运⾏ Docker 容器，但现在已经被 containerd-shim-runc-v2 替代。containerd-shim-runc-v2 是 containerd 中新的 shim 实现，它使⽤ gRPC 来与 containerd 守护进程进⾏通信。它是在 containerd 1.1 中引⼊的，其⽬标是提供更好的性能和可靠性，并为后续的扩展提供更好的基础设施。与containerd-shim-runc-v1 相⽐，它更加轻量级，并且可以通过 API 配置各种容器和执⾏参数。总的来说，containerd-shim-runc-v2 是 containerd 中更加现代和⾼效的 shim 实现，它⽐ containerd-shimrunc-v1 更具扩展性和可维护性，因此在使⽤ containerd 时应该尽可能地使⽤ containerd-shim-runc-v2。</p><h4 id="Containerd的grpc⽅法是如何注册的？"><a href="#Containerd的grpc⽅法是如何注册的？" class="headerlink" title="Containerd的grpc⽅法是如何注册的？"></a>Containerd的grpc⽅法是如何注册的？</h4><p>   containerd 的 gRPC ⽅法是通过⽣成的 protobuf ⽂件和相应的代码实现的。protobuf ⽂件描述了 containerd ⽀持的API ⽅法和数据结构，然后使⽤这个⽂件⽣成对应的代码（包括客户端和服务器端代码）。这些⾃动⽣成的代码提供了实现⽅法的框架，开发⼈员可以在其中添加⾃⼰的代码以实现具体功能。在 containerd 中，服务器端的 gRPC ⽅法是在 services ⽬录下实现的。每个服务都实现了⼀个接⼝（在 protobuf⽂件中定义），并提供了⼀些⽅法来处理请求。这些⽅法通常采⽤ context 参数来获取请求上下⽂和取消信号，然后使⽤⾃动⽣成的代码处理 protobuf 消息。在这些⽅法中，使⽤的核⼼实现代码通常在 containers、images 或content 等核⼼ package 中实现。服务注册是通过 init 函数实现的，每个服务都在其对应的包中实现了⼀个名为 Register 的函数，该函数在包被导⼊时⾃动运⾏，将⾃⼰注册到 containerd 的 gRPC 服务器上。在 Register 函数中，使⽤<br>server.RegisterService 函数将⾃⼰的服务实现注册到 containerd 的 gRPC 服务器上，以便客户端可以调⽤。</p><h4 id="Containerd与containerd-shim是如何交互的？"><a href="#Containerd与containerd-shim是如何交互的？" class="headerlink" title="Containerd与containerd-shim是如何交互的？"></a>Containerd与containerd-shim是如何交互的？</h4><p>  在 Containerd 中，containerd-shim 是负责启动容器进程并与 Containerd API 通信的组件。Containerd 通过 gRPC接⼝与 containerd-shim 通信，以便进⾏容器的创建、启动、停⽌、删除等操作。具体⽽⾔，Containerd 与containerd-shim 之间的交互过程如下：</p><ol><li>Containerd 使⽤ gRPC 接⼝向 containerd-shim 发送创建容器的请求，包括容器的 ID、镜像、⽂件系统等参数。</li><li>containerd-shim 接收到创建容器的请求后，会根据请求中的参数启动⼀个新的容器进程，并创建⼀个对应的Linux namespace。</li><li>containerd-shim 将容器的 PID、Stdin、Stdout 和 Stderr 等信息发送回给 Containerd，以便后者能够管理和监控容器的运⾏状态。</li><li>在容器运⾏过程中，Containerd 可以通过 gRPC 接⼝向 containerd-shim 发送信号以启动、停⽌、暂停或恢复容器的运⾏。</li><li>当容器进程退出后，containerd-shim 会向 Containerd 发送容器的退出状态和退出码，Containerd 在接收到这些信息后，会更新容器的状态并删除对应的容器对象。需要注意的是，Containerd 和 containerd-shim 都是独⽴的进程，它们之间通过 gRPC 接⼝通信，因此 Containerd和 containerd-shim 可以在不同的计算机上运⾏，这也为 Containerd 的分布式部署提供了便利。</li></ol><h4 id="Containerd-shim与runc是如何交互的？"><a href="#Containerd-shim与runc是如何交互的？" class="headerlink" title="Containerd-shim与runc是如何交互的？"></a>Containerd-shim与runc是如何交互的？</h4><p>  在容器技术中，runc 是⼀个⽤于启动和管理容器的轻量级⼯具，⽽ containerd-shim 是 containerd ⽤于管理容器⽣命周期的代理。在容器启动的过程中，runc 和 containerd-shim 之间会进⾏以下交互：</p><ol><li>Containerd-shim 通过 Containerd API 向 Containerd 发送创建容器的请求。</li><li>Containerd 接收到请求后，将请求转发给 runc 来创建容器。runc 将通过 system call 创建新的容器进程，并设置容器的隔离环境（⽐如 namespace、cgroups、rootfs）等参数。</li><li>runc 启动新的容器进程并返回 PID 给 Containerd-shim。</li><li>Containerd-shim 接收到容器进程的 PID 后，会将 PID 发送回给 Containerd。Containerd 会继续管理和监控容器的⽣命周期。</li><li>在容器运⾏期间，Containerd 可以通过 Containerd API 向 Containerd-shim 发送命令，⽐如停⽌、暂停、恢复、删除容器等操作。</li><li>当容器进程退出后，runc 将容器的退出状态和退出码发送给 Containerd-shim。Containerd-shim 将这些信息发送回给 Containerd，Containerd 将更新容器的状态并删除对应的容器对象。需要注意的是，runc 是⼀个独⽴的⼯具，它与 containerd-shim 的交互是在容器启动时发⽣的。在容器启动成功后，runc 将直接与容器进程交互，⽽ containerd-shim 的作⽤将逐渐变⼩。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-StorageClass实践1</title>
      <link href="/2024/08/01/Kubernetes%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2024/08/01/Kubernetes%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>该实战基于假设了解并清楚，<strong>ServiceAccount</strong>，<strong>ClusterRole</strong>，<strong>ClusterRoleBinding</strong>等<br>以下是简要介绍：</p><ol><li>ServiceAccount：为Pod提供了一个身份，允许Pod与Kubernetes API进行安全交互。Local Path Provisioner需要访问和管理PV、PVC、Nodes等资源</li><li>ClusterRole：定义了一组权限，允许某个身份（如ServiceAccount）对Kubernetes集群中的资源执行特定操作。</li><li>ClusterRoleBinding：ClusterRoleBinding将ClusterRole与一个或多个主体（如ServiceAccount）绑定，以便这些主体获得ClusterRole定义的权限<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3>手撕StorageClass用rancher的local-path的方式进行PVC申领动态制备PV</li></ol><h3 id="简要步骤"><a href="#简要步骤" class="headerlink" title="简要步骤"></a>简要步骤</h3><ol><li>建立命名空间进行资源隔离</li><li>创建ServiceAccount、ClusterRole和ClusterRoleBinding（前提解释）</li><li>创建deploy，控制pod副本数量</li><li>创建configMap，存储不含机密信息的配置数据。（参考：存储基础）</li><li>创建StorageClass（参考第4条）</li></ol><h3 id="废话不多说-￥-……-amp-实战开始"><a href="#废话不多说-￥-……-amp-实战开始" class="headerlink" title="废话不多说@#￥%……&amp;*实战开始"></a>废话不多说@#￥%……&amp;*实战开始</h3><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 好的，已经成功一半了</span></span><br><span class="line">kubectl create namespace(ns) local-path-storage</span><br></pre></td></tr></table></figure><h4 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-service-account</span><br><span class="line">  namespace: local-path-storage </span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801104527213.png" alt="image-20240801104527213"></p><h4 id="ClusterRole，直接拿官方的"><a href="#ClusterRole，直接拿官方的" class="headerlink" title="ClusterRole，直接拿官方的"></a>ClusterRole，直接拿官方的</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1 <span class="comment"># 指定API版本，这里是rbac.authorization.k8s.io/v1</span></span><br><span class="line">kind: ClusterRole <span class="comment"># 资源类型，这里是ClusterRole，表示集群级别的权限定义</span></span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-role <span class="comment"># ClusterRole的名称，这里是local-path-provisioner-role</span></span><br><span class="line">rules: <span class="comment"># 定义该角色的权限规则列表</span></span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>] <span class="comment"># 指定API组，空字符串表示核心API组</span></span><br><span class="line">  resources: [<span class="string">&quot;nodes&quot;</span>, <span class="string">&quot;persistentvolumeclaims&quot;</span>, <span class="string">&quot;persistentvolumes&quot;</span>] <span class="comment"># 资源类型列表，包括nodes、persistentvolumeclaims和persistentvolumes</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>] <span class="comment"># 允许的操作，包括获取、列出、监视、创建和删除</span></span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>] <span class="comment"># 再次指定核心API组</span></span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 资源类型是pods</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>] <span class="comment"># 允许的操作，包括获取、列出和监视</span></span><br><span class="line">- apiGroups: [<span class="string">&quot;storage.k8s.io&quot;</span>] <span class="comment"># 指定API组storage.k8s.io</span></span><br><span class="line">  resources: [<span class="string">&quot;storageclasses&quot;</span>] <span class="comment"># 资源类型是storageclasses</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>] <span class="comment"># 允许的操作，包括获取、列出和监视</span></span><br><span class="line">- apiGroups: [<span class="string">&quot;batch&quot;</span>, <span class="string">&quot;extensions&quot;</span>] <span class="comment"># 指定API组batch和extensions</span></span><br><span class="line">  resources: [<span class="string">&quot;jobs&quot;</span>] <span class="comment"># 资源类型是jobs</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>] <span class="comment"># 允许的操作，包括获取、列出、监视、创建和删除</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801105301424.png" alt="image-20240801105301424"></p><h4 id="ClusterRoleBinding"><a href="#ClusterRoleBinding" class="headerlink" title="ClusterRoleBinding"></a>ClusterRoleBinding</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1 <span class="comment"># 指定API版本，这里是rbac.authorization.k8s.io/v1</span></span><br><span class="line">kind: ClusterRoleBinding <span class="comment"># 资源类型，这里是ClusterRoleBinding，表示集群级别的角色绑定</span></span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-bindings <span class="comment"># ClusterRoleBinding的名称，这里是local-path-provisioner-bindings</span></span><br><span class="line">roleRef: <span class="comment"># 指定要绑定的角色</span></span><br><span class="line">  apiGroup: rbac.authorization.k8s.io <span class="comment"># 角色所属的API组，这里是rbac.authorization.k8s.io</span></span><br><span class="line">  kind: ClusterRole <span class="comment"># 角色类型，这里是ClusterRole</span></span><br><span class="line">  name: local-path-provisioner-role <span class="comment"># 角色名称，这里是local-path-provisioner-role</span></span><br><span class="line">subjects: <span class="comment"># 定义该角色绑定的主体列表</span></span><br><span class="line">- kind: ServiceAccount <span class="comment"># 主体类型，这里是ServiceAccount（服务账户）</span></span><br><span class="line">  name: local-path-provisioner-service-account <span class="comment"># 服务账户的名称，这里是local-path-provisioner-service-account</span></span><br><span class="line">  namespace: local-path-storage <span class="comment"># 服务账户所属的命名空间，这里是local-path-storage</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801105734783.png" alt="image-20240801105734783"></p><h4 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1 <span class="comment"># 指定API版本，这里是apps/v1</span></span><br><span class="line">kind: Deployment <span class="comment"># 资源类型，这里是Deployment，表示部署一个应用</span></span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner <span class="comment"># Deployment的名称，这里是local-path-provisioner</span></span><br><span class="line">  namespace: local-path-storage <span class="comment"># Deployment所属的命名空间，这里是local-path-storage</span></span><br><span class="line">spec: <span class="comment"># Deployment的规格定义</span></span><br><span class="line">  replicas: 1 <span class="comment"># 副本数，这里是1，表示只部署一个副本</span></span><br><span class="line">  selector: <span class="comment"># 用于选择要部署的Pod</span></span><br><span class="line">    matchLabels:</span><br><span class="line">    <span class="comment"># 标签选择器，选择标签为app: local-path-provisioner的Pod</span></span><br><span class="line">      app: local-path-provisioner </span><br><span class="line">  template: <span class="comment"># Pod模板定义</span></span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: local-path-provisioner <span class="comment"># 为Pod设置的标签，这里是app: local-path-provisioner</span></span><br><span class="line">    spec: <span class="comment"># Pod的规格定义</span></span><br><span class="line">    <span class="comment"># 使用的服务账户名称，这里是local-path-provisioner-service-account</span></span><br><span class="line">      serviceAccountName: local-path-provisioner-service-account </span><br><span class="line">      containers: <span class="comment"># 容器列表</span></span><br><span class="line">      - name: provisioner <span class="comment"># 容器名称，这里是provisioner</span></span><br><span class="line">      <span class="comment"># 容器镜像，这里是rancher/local-path-provisioner:latest</span></span><br><span class="line">        image: rancher/local-path-provisioner:master-head <span class="comment"># 换加速啊啊啊啊啊啊啊啊叼毛</span></span><br><span class="line">        imagePullPolicy: Always <span class="comment"># 镜像拉取策略，总是拉取最新的镜像</span></span><br><span class="line">        volumeMounts: <span class="comment"># 挂载的卷列表</span></span><br><span class="line">        - name: config-volume <span class="comment"># 卷名称，这里是config-volume</span></span><br><span class="line">          mountPath: /etc/config <span class="comment"># 挂载路径，这里是/etc/config</span></span><br><span class="line">        - name: local-path-storage <span class="comment"># 卷名称，这里是local-path-storage</span></span><br><span class="line">          mountPath: /opt/local-path-storage <span class="comment"># 挂载路径，这里是/opt/local-path-storage</span></span><br><span class="line">      volumes: <span class="comment"># 定义Pod中使用的卷</span></span><br><span class="line">      - name: config-volume <span class="comment"># 卷名称，这里是config-volume</span></span><br><span class="line">        configMap: <span class="comment"># 使用ConfigMap作为卷</span></span><br><span class="line">          name: local-path-config <span class="comment"># ConfigMap的名称，这里是local-path-config</span></span><br><span class="line">      - name: local-path-storage <span class="comment"># 卷名称，这里是local-path-storage</span></span><br><span class="line">        hostPath: <span class="comment"># 使用主机路径作为卷</span></span><br><span class="line">          path: /opt/local-path-storage <span class="comment"># 主机路径，这里是/opt/local-path-storage</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801110044796.png" alt="image-20240801110044796"></p><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1 <span class="comment"># 指定API版本，这里是v1</span></span><br><span class="line">kind: ConfigMap <span class="comment"># 资源类型，这里是ConfigMap，用于存储配置信息</span></span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-config <span class="comment"># ConfigMap的名称，这里是local-path-config</span></span><br><span class="line">  namespace: local-path-storage <span class="comment"># ConfigMap所属的命名空间，这里是local-path-storage</span></span><br><span class="line">data: <span class="comment"># 配置数据</span></span><br><span class="line">  config.json: | <span class="comment"># 配置文件的名称，这里是config.json，使用多行字符串格式</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;nodePathMap&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;node&quot;</span>:<span class="string">&quot;DEFAULT_PATH_FOR_NON_LISTED_NODES&quot;</span>, <span class="comment"># 节点名称，表示未列出的节点的默认路径</span></span><br><span class="line">          <span class="string">&quot;paths&quot;</span>:[<span class="string">&quot;/opt/local-path-storage&quot;</span>] <span class="comment"># 路径列表，这里是/opt/local-path-storage</span></span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801110611178.png" alt="image-20240801110611178"></p><h4 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1 <span class="comment"># 指定API版本，这里是storage.k8s.io/v1</span></span><br><span class="line">kind: StorageClass <span class="comment"># 资源类型，这里是StorageClass，表示存储类</span></span><br><span class="line">metadata:</span><br><span class="line">  name: local-path <span class="comment"># StorageClass的名称，这里是local-path</span></span><br><span class="line">provisioner: rancher.io/local-path <span class="comment"># 指定的provisioner，这里是rancher.io/local-path</span></span><br><span class="line">reclaimPolicy: Delete <span class="comment"># 回收策略，这里是Delete，表示当持久卷被释放时删除它</span></span><br><span class="line"><span class="comment"># 卷绑定模式，这里是WaitForFirstConsumer，表示延迟绑定，直到Pod被调度到节点上</span></span><br><span class="line">volumeBindingMode: WaitForFirstConsumer </span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801110811688.png" alt="image-20240801110811688"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><h5 id="创建pvc-yaml"><a href="#创建pvc-yaml" class="headerlink" title="创建pvc yaml"></a>创建pvc yaml</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: my-local-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br><span class="line">  storageClassName: local-path</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801142550578.png" alt="image-20240801142550578"></p><p>因为设计的是WaitForFirstConsumer，所以需要设计一个pod</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp-container</span><br><span class="line">    image: m.daocloud.io/docker.io/library/nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">      name: my-local-storage</span><br><span class="line">  volumes:</span><br><span class="line">  - name: my-local-storage</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: my-local-pvc</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240801145710135.png" alt="image-20240801145710135"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上的配置文件只是一个参考，实际的可以用官方的配置文件,需要注意的是换加速镜像地址时候要换全哦，带image的都换。配置不正确多半进入cashloopbackoff的问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-storage</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-service-account</span><br><span class="line">  namespace: local-path-storage</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-role</span><br><span class="line">  namespace: local-path-storage</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-role</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;nodes&quot;</span>, <span class="string">&quot;persistentvolumeclaims&quot;</span>, <span class="string">&quot;configmaps&quot;</span>, <span class="string">&quot;pods&quot;</span>, <span class="string">&quot;pods/log&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;events&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line">  - apiGroups: [<span class="string">&quot;storage.k8s.io&quot;</span>]</span><br><span class="line">    resources: [<span class="string">&quot;storageclasses&quot;</span>]</span><br><span class="line">    verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-bind</span><br><span class="line">  namespace: local-path-storage</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Role</span><br><span class="line">  name: local-path-provisioner-role</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: local-path-provisioner-service-account</span><br><span class="line">    namespace: local-path-storage</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner-bind</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: local-path-provisioner-role</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: local-path-provisioner-service-account</span><br><span class="line">    namespace: local-path-storage</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-provisioner</span><br><span class="line">  namespace: local-path-storage</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">app: local-path-provisioner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: local-path-provisioner</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: local-path-provisioner-service-account</span><br><span class="line">      containers:</span><br><span class="line">        - name: local-path-provisioner</span><br><span class="line">          image: docker.m.daocloud.io/rancher/local-path-provisioner:master-head  <span class="comment"># ps：换</span></span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          <span class="built_in">command</span>:</span><br><span class="line">            - local-path-provisioner</span><br><span class="line">            - --debug</span><br><span class="line">            - start</span><br><span class="line">            - --config</span><br><span class="line">            - /etc/config/config.json</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: config-volume</span><br><span class="line">              mountPath: /etc/config/</span><br><span class="line">          <span class="built_in">env</span>:</span><br><span class="line">            - name: POD_NAMESPACE</span><br><span class="line">              valueFrom:</span><br><span class="line">                fieldRef:</span><br><span class="line">                  fieldPath: metadata.namespace</span><br><span class="line">            - name: CONFIG_MOUNT_PATH</span><br><span class="line">              value: /etc/config/</span><br><span class="line">      volumes:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          configMap:</span><br><span class="line">            name: local-path-config</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path</span><br><span class="line">provisioner: rancher.io/local-path</span><br><span class="line">volumeBindingMode: Immediate</span><br><span class="line">reclaimPolicy: Delete</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: local-path-config</span><br><span class="line">  namespace: local-path-storage</span><br><span class="line">data:</span><br><span class="line">  config.json: |-</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="string">&quot;nodePathMap&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="string">&quot;node&quot;</span>:<span class="string">&quot;DEFAULT_PATH_FOR_NON_LISTED_NODES&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;paths&quot;</span>:[<span class="string">&quot;/opt/local-path-provisioner&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">  setup: |-</span><br><span class="line">    <span class="comment">#!/bin/sh</span></span><br><span class="line">    <span class="built_in">set</span> -eu</span><br><span class="line">    <span class="built_in">mkdir</span> -m 0777 -p <span class="string">&quot;<span class="variable">$VOL_DIR</span>&quot;</span></span><br><span class="line">  teardown: |-</span><br><span class="line">    <span class="comment">#!/bin/sh</span></span><br><span class="line">    <span class="built_in">set</span> -eu</span><br><span class="line">    <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$VOL_DIR</span>&quot;</span></span><br><span class="line">  helperPod.yaml: |-</span><br><span class="line">    apiVersion: v1</span><br><span class="line">    kind: Pod</span><br><span class="line">    metadata:</span><br><span class="line">      name: helper-pod</span><br><span class="line">    spec:</span><br><span class="line">      priorityClassName: system-node-critical</span><br><span class="line">      tolerations:</span><br><span class="line">        - key: node.kubernetes.io/disk-pressure</span><br><span class="line">          operator: Exists</span><br><span class="line">          effect: NoSchedule</span><br><span class="line">      containers:</span><br><span class="line">      - name: helper-pod</span><br><span class="line">        image: m.daocloud.io/docker.io/library/busybox <span class="comment"># ps：换</span></span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernentes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 证书</title>
      <link href="/2024/07/31/Kubernetes_pki/"/>
      <url>/2024/07/31/Kubernetes_pki/</url>
      
        <content type="html"><![CDATA[<h3 id="PKI证书"><a href="#PKI证书" class="headerlink" title="PKI证书"></a>PKI证书</h3><p>kubernetes是需要PKI才能执行多数操作:</p><ol><li>kubelet的客户端证书:用于API服务器身份验证</li><li>kubelet服务证书:用于API服务器与Kubelet的会话</li><li>API服务器端点证书:用于HTTPS加密，确保通信加密</li><li>集群管理员的客户端证书：管理员（我）的工作证明</li><li>API 服务器的客户端证书：用于和 Kubelet 的会话</li><li>API 服务器的客户端证书：用于和 etcd 的会话</li><li>控制器管理器的客户端证书或 kubeconfig：用于和 API 服务器的会话</li><li>调度器的客户端证书或 kubeconfig：用于和 API 服务器的会话</li><li>前端代理的客户端及服务端证书</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240731153548422.png" alt="image-20240731153548422"></p><h3 id="自定义证书"><a href="#自定义证书" class="headerlink" title="自定义证书"></a>自定义证书</h3><ul><li>首先用kubeadm创建的kubernetes会生成集群所需地全部证书。</li><li>其次你可以自定义，通过<code>--cert-dir</code>来指定不同的目录</li><li>默认位置/etc/kubernetes/pki里面</li><li><code>kubeadm init --cert-dir /自定义目录/</code>或者在kubeadm自定义的config的<code>certificatesDir</code>字段进行目录指定</li></ul><h3 id="外部CA"><a href="#外部CA" class="headerlink" title="外部CA"></a>外部CA</h3><p>指在 Kubernetes 集群中使用由外部证书颁发机构（CA）签发的证书，而不是由 kubeadm 自行生成和管理 CA 证书。这种模式下，所有的证书和密钥都是由外部的 CA 签发的，提供更高的安全性和信任度，尤其在有严格合规性要求的环境中。</p><h4 id="使用外部-CA-模式配置-Kubernetes-集群"><a href="#使用外部-CA-模式配置-Kubernetes-集群" class="headerlink" title="使用外部 CA 模式配置 Kubernetes 集群"></a>使用外部 CA 模式配置 Kubernetes 集群</h4><ol><li><p><strong>准备外部 CA 签发的证书和密钥</strong></p><ul><li>你需要从外部 CA 获取以下证书和密钥：<ul><li>CA 证书 (<code>ca.crt</code>)</li><li>kube-apiserver 证书及其密钥 (<code>apiserver.crt</code> 和 <code>apiserver.key</code>)</li><li>kube-controller-manager 证书及其密钥（可选，如果需要）</li><li>kube-scheduler 证书及其密钥（可选，如果需要）</li><li>其他组件所需的证书及其密钥（如 etcd 等）</li></ul></li></ul></li><li><p><strong>创建并配置 Kubernetes 配置文件</strong></p><ul><li>创建一个 kubeadm 配置文件，如 <code>kubeadm-config.yaml</code>，并在其中指定 <code>certificatesDir</code> 和 <code>ClusterConfiguration</code>。示例如下：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">stable-1.21</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">certSANs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;your.domain.com&quot;</span></span><br><span class="line">   <span class="attr">extraArgs:</span></span><br><span class="line">      <span class="attr">&quot;tls-cert-file&quot;:</span> <span class="string">&quot;/etc/kubernetes/pki/apiserver.crt&quot;</span></span><br><span class="line">      <span class="attr">&quot;tls-private-key-file&quot;:</span> <span class="string">&quot;/etc/kubernetes/pki/apiserver.key&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>将外部 CA 签发的证书和密钥放置在指定目录</strong></p><ul><li>复制外部 CA 签发的证书和密钥到 <code>/etc/kubernetes/pki</code> 目录或你在配置文件中指定</li></ul></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /path/to/ca.crt /etc/kubernetes/pki/ca.crt</span><br><span class="line">sudo <span class="built_in">cp</span> /path/to/apiserver.crt /etc/kubernetes/pki/apiserver.crt</span><br><span class="line">sudo <span class="built_in">cp</span> /path/to/apiserver.key /etc/kubernetes/pki/apiserver.key</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>运行 kubeadm 初始化命令</strong></li></ol><ul><li>使用 kubeadm 初始化命令并指定配置文件来初始化 Kubernetes 集群：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --config kubeadm-config.yaml</span><br></pre></td></tr></table></figure></li></ul><h3 id="检查证书"><a href="#检查证书" class="headerlink" title="检查证书"></a>检查证书</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm certs check-expiration</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240731161509499.png" alt="image-20240731161509499"></p><p>ps:</p><ol><li><p>kubeadm不能管理外部ca</p></li><li><p>没有kubelet.conf的原因是kubeadm会将kubelet配置为自动更新证书，轮换在<code>/var/lib/kubelet/pki</code></p></li></ol><ul><li>轮询失败暂时参考：<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert">https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert</a></li></ul><h3 id="自动更新证书"><a href="#自动更新证书" class="headerlink" title="自动更新证书"></a>自动更新证书</h3><p><code>kubeadm</code> 提供了一种机制，在集群控制面（control plane）升级时自动更新所有证书。这种方式简化了证书管理，并确保在定期升级 Kubernetes 版本时保持集群的安全性。下面是详细的操作步骤和相关说明。</p><h4 id="自动更新证书的机制"><a href="#自动更新证书的机制" class="headerlink" title="自动更新证书的机制"></a>自动更新证书的机制</h4><p>当你使用 <code>kubeadm upgrade apply</code> 命令升级控制面节点时，<code>kubeadm</code> 会自动更新所有的证书。</p><p>进。</p><h4 id="禁用自动证书更新"><a href="#禁用自动证书更新" class="headerlink" title="禁用自动证书更新"></a>禁用自动证书更新</h4><p>如果你有更复杂的证书管理需求，可以选择在升级时禁用自动证书更新。可以通过传递 <code>--certificate-renewal=false</code> 参数来实现。</p><ol><li><p><strong>升级控制面节点时禁用证书更新</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade apply v1.xx.x --certificate-renewal=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>其中 <code>v1.xx.x</code> 为目标 Kubernetes 版本。</p></li><li><p><strong>升级 worker 节点时禁用证书更新</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade node --certificate-renewal=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="手动启用证书更新"><a href="#手动启用证书更新" class="headerlink" title="手动启用证书更新"></a>手动启用证书更新</h4><p>在 Kubernetes 1.17 版本之前，<code>kubeadm upgrade node</code> 命令的 <code>--certificate-renewal</code> 参数默认值为 <code>false</code>，需要显式地设置为 <code>true</code>。</p><h5 id="显式启用证书更新的操作步骤"><a href="#显式启用证书更新的操作步骤" class="headerlink" title="显式启用证书更新的操作步骤"></a>显式启用证书更新的操作步骤</h5><ol><li><p><strong>升级控制面节点时显式启用证书更新</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade apply v1.xx.x --certificate-renewal=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>升级 worker 节点时显式启用证书更新</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade node --certificate-renewal=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="手动更新证书"><a href="#手动更新证书" class="headerlink" title="手动更新证书"></a>手动更新证书</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行完此命令之后你需要重启控制面 Pod,运行了一个 HA 集群，这个命令需要在所有控制面板节点上执行。</span></span><br><span class="line">kubeadm certs renew (all)</span><br></pre></td></tr></table></figure><p>ps:kubeadm通常会把<code>admin.conf</code> 证书复制到 <code>$HOME/.kube/config</code> 中，在这样的系统中，为了在更新 <code>admin.conf</code> 后更新 <code>$HOME/.kube/config</code> 的内容， 你必须运行以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes存储基础</title>
      <link href="/2024/07/30/Kubernetes%E5%AD%98%E5%82%A8/"/>
      <url>/2024/07/30/Kubernetes%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h2><h3 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h3><ul><li>用于请求和绑定持久化存储卷pv,PVC 独立于具体的存储实现，可以通过存储类（StorageClass）来动态配置和管理存储资源。</li></ul><h4 id="yaml参考"><a href="#yaml参考" class="headerlink" title="yaml参考"></a>yaml参考</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gih</span> </span><br></pre></td></tr></table></figure><h4 id="K-os"><a href="#K-os" class="headerlink" title="K.os"></a>K.os</h4><ul><li>应该是可以理解为通过pvc进行申请后，StorageClass会根据pvc来动态创建pv<h3 id="configMap"><a href="#configMap" class="headerlink" title="configMap"></a>configMap</h3></li><li>于在集群中管理非机密数据配置，将配置信息从代码中分离出来，注入配置数据的方法，便于管理和更新。</li></ul><h4 id="K-os-1"><a href="#K-os-1" class="headerlink" title="K.os"></a>K.os</h4><ul><li>可以用键值得形式存储重要数据</li></ul><h3 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h3><p>可以参考： </p><h2 id="持久卷"><a href="#持久卷" class="headerlink" title="持久卷"></a>持久卷</h2><p>为Pod提供独立于Pod生命周期的持久存储。</p><h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><ul><li>一块存储资源。它是集群级别的资源，与Pod的生命周期分离。PV可以由管理员预先创建，也可以通过存储类动态创建。</li></ul><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><ul><li>写完直接apply<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br></pre></td></tr></table></figure><h4 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h4></li><li>需要一个存储类StorageClass进行动态申领，就是想定义好StorageClass，再进行pvc进行获取</li></ul><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><ul><li>Kubernetes会根据PVC的需求自动寻找和绑定合适的PV。</li></ul><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ul><li>当PVC被删除后，PV的回收策略决定了PV的处理方式。回收策略有三种：Retain、Recycle和Delete。</li></ul><ol><li>Retain：保留数据，管理员可以手动处理数据。</li><li>Recycle：清空数据后重新供PVC使用（已弃用）。</li><li>Delete：删除PV和存储数据。</li></ol><h4 id="K-os-2"><a href="#K-os-2" class="headerlink" title="K.os"></a>K.os</h4><ul><li>可以理解成物理卷一样，都是可以当作一块存储。但是后续的操作不一样，this.pv是能够通过StorageClass动态创建。</li></ul><h3 id="投射卷"><a href="#投射卷" class="headerlink" title="投射卷"></a>投射卷</h3><ul><li>将多种不同类型的数据源投射到 Pod 内的单个卷中。这些数据源包括 Secret、ConfigMap、Downward API 和 ServiceAccount Token 等。投射卷的一个主要优势是，它可以将多个来源的数据整合到一个挂载点，从而简化了数据管理和使用。</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">projected-volume-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-projected-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/projected-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-projected-volume</span></span><br><span class="line"><span class="comment"># 这里11111</span></span><br><span class="line">    <span class="attr">projected:</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">downwardAPI:</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;labels&quot;</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.labels</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">serviceAccountToken:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">&quot;token&quot;</span></span><br><span class="line">          <span class="attr">expirationSeconds:</span> <span class="number">3600</span></span><br><span class="line">          <span class="attr">audience:</span> <span class="string">&quot;api&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a><strong>存储类</strong></h3><p>用来定义PV的资源对象</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Provisioner：定义由谁负责提供存储资源。不同的 Provisioner 对应不同的存储系统，如 kubernetes.io/aws-ebs 对应 AWS 的 EBS 存储，kubernetes.io/gce-pd 对应 Google Cloud 的 Persistent Disk，等等。</p><p>Parameters：提供给存储系统的参数。例如，对于 AWS EBS，可以指定卷类型（如 gp2、io1 等）、IOPS 等参数。</p><p>ReclaimPolicy：定义 PV 被释放后如何处理。有两种策略：</p><p>Retain：保留存储资源供管理员手动回收。<br>Delete：自动删除存储资源。<br>AllowVolumeExpansion：指示是否允许动态扩展存储卷大小。</p><p>MountOptions：提供给挂载卷的选项，这些选项会应用于挂载存储卷时。</p><p>VolumeBindingMode：定义 PV 的绑定模式，主要有两种：</p><p>Immediate：PV 会立即绑定到 PVC。<br>WaitForFirstConsumer：PV 会等待第一个消费者（Pod）出现后再绑定，以便更好地优化存储资源分配。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span>  <span class="comment"># 指定API版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span>            <span class="comment"># 声明资源类型为StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fast</span>                  <span class="comment"># StorageClass的名称，用户定义的标识</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/aws-ebs</span>  <span class="comment"># 指定Provisioner类型，这里使用AWS EBS作为存储提供者</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">io1</span>                   <span class="comment"># 指定AWS EBS卷的类型，这里使用io1类型</span></span><br><span class="line">  <span class="attr">iopsPerGB:</span> <span class="string">&quot;10&quot;</span>             <span class="comment"># 指定每GB卷的IOPS（仅对io1类型有效）</span></span><br><span class="line">  <span class="attr">fsType:</span> <span class="string">ext4</span>                <span class="comment"># 指定文件系统类型，默认为ext4</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Retain</span>         <span class="comment"># 设置回收策略，Retain表示保留PV供管理员手动回收</span></span><br><span class="line"><span class="attr">allowVolumeExpansion:</span> <span class="literal">true</span>    <span class="comment"># 允许动态扩展存储卷大小</span></span><br><span class="line"><span class="attr">mountOptions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">debug</span>                     <span class="comment"># 挂载卷时的选项，这里使用debug模式</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span>  <span class="comment"># 设置卷绑定模式，WaitForFirstConsumer表示等待第一个消费者出现再绑定</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于containerd的kubernetes集群建设</title>
      <link href="/2024/07/26/%E5%9F%BA%E4%BA%8Econtainerd%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4%E5%BB%BA%E8%AE%BE/"/>
      <url>/2024/07/26/%E5%9F%BA%E4%BA%8Econtainerd%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4%E5%BB%BA%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="节点资源规划（仅学习）"><a href="#节点资源规划（仅学习）" class="headerlink" title="节点资源规划（仅学习）"></a>节点资源规划（仅学习）</h3><p>资源规划：一个master，两个work（非测试不建议这种模式，无高可用）<br>master： 16c,32g,200G,200G(空)<br>work : 16c,32g,200G,200G(空)</p><h3 id="选择安装工具"><a href="#选择安装工具" class="headerlink" title="选择安装工具"></a>选择安装工具</h3><ol><li>首先DNS更正223.5.5.5，223.6.6.6</li><li>选择后国内清华源的K8s软件库：</li></ol><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/kubernetes/">https://mirrors.tuna.tsinghua.edu.cn/help/kubernetes/</a></li></ul><ol start="3"><li>选择containerd运行时</li><li>安装ipvs</li></ol><p>个人理解：环境主要在三节点上有kubelet，kubectl，主节点多一个初始化的kubeadm。然后主节点用kubeadm进行初始化主节点，然后进行containerd运行时进行组件的拉取和运行。组成一个集群。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>各种安装过程我们跳过哈,然后我们深度聊一聊一些环境的设置</p><h4 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h4><h5 id="内核参数调整"><a href="#内核参数调整" class="headerlink" title="内核参数调整"></a>内核参数调整</h5><h6 id="什么是内核参数呢，会影响什么"><a href="#什么是内核参数呢，会影响什么" class="headerlink" title="什么是内核参数呢，会影响什么"></a>什么是内核参数呢，会影响什么</h6><p>内核参数是配置Linux内核行为的设置。这些参数控制系统的各种功能，如内存管理、网络设置、文件系统行为等。内核参数通常通过/etc/sysctl.conf文件进行配置，并通过sysctl命令加载和应用。常用的内核参数请看<br><a href="https://blog.zitiu.top/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/">Linux从核心到边缘 | Kalyan的小书房 (zitiu.top)</a></p><h6 id="需要调整的内核参数"><a href="#需要调整的内核参数" class="headerlink" title="需要调整的内核参数"></a>需要调整的内核参数</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">0</span>  <span class="comment"># 减少swap分区使用</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward</span> <span class="string">=</span> <span class="number">1</span> <span class="comment"># 允许linux内核将网络流量从一个网络接口转发到另一个网络接口</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables=1</span> <span class="comment"># 启用 bridge-nf-call-iptables</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span> <span class="comment"># 启用 IP 转发</span></span><br></pre></td></tr></table></figure><p>这里通常会有一个问题，当你sysctl -p采用的时候可能会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl: cannot <span class="built_in">stat</span> /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory</span><br><span class="line">sysctl: cannot <span class="built_in">stat</span> /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</span><br></pre></td></tr></table></figure><p>这个时候你可以</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用 bridge-nf-call-iptables</span></span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"><span class="built_in">echo</span> 1 | sudo <span class="built_in">tee</span> /proc/sys/net/bridge/bridge-nf-call-iptables</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-iptables=1&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 IP 转发</span></span><br><span class="line"><span class="built_in">echo</span> 1 | sudo <span class="built_in">tee</span> /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward=1&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p>最后进行微调</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个文件，将需要的内核模块写入其中，以便在系统启动时自动加载这些模块</span></span><br><span class="line"><span class="built_in">tee</span> /etc/modules-load.d/k8s.conf &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># netfilter 模块，允许 iptables 检查桥接流量</span></span><br><span class="line">br_netfilter</span><br><span class="line"><span class="comment"># containerd 文件系统支持</span></span><br><span class="line">overlay</span><br><span class="line"><span class="comment"># IPVS (IP Virtual Server) 模块，用于负载均衡</span></span><br><span class="line">ip_vs</span><br><span class="line"><span class="comment"># 轮叫调度算法</span></span><br><span class="line">ip_vs_rr</span><br><span class="line"><span class="comment"># 加权轮叫调度算法</span></span><br><span class="line">ip_vs_wrr</span><br><span class="line"><span class="comment"># 源地址散列调度算法</span></span><br><span class="line">ip_vs_sh</span><br><span class="line"><span class="comment"># 连接跟踪模块，用于跟踪网络连接状态</span></span><br><span class="line">nf_conntrack</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录以存放模块加载脚本</span></span><br><span class="line"><span class="built_in">mkdir</span> -vp /etc/modules.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个脚本文件，立即加载所需的内核模块</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/modules.d/k8s.modules &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string"># 允许 iptables 检查桥接流量</span></span><br><span class="line"><span class="string">modprobe -- br_netfilter</span></span><br><span class="line"><span class="string"># containerd 文件系统支持</span></span><br><span class="line"><span class="string">modprobe -- overlay</span></span><br><span class="line"><span class="string"># IPVS 模块，用于负载均衡</span></span><br><span class="line"><span class="string">modprobe -- ip_vs</span></span><br><span class="line"><span class="string"># 轮叫调度算法</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_rr</span></span><br><span class="line"><span class="string"># 加权轮叫调度算法</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_wrr</span></span><br><span class="line"><span class="string"># 源地址散列调度算法</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_sh</span></span><br><span class="line"><span class="string"># 连接跟踪模块，用于跟踪网络连接状态</span></span><br><span class="line"><span class="string">modprobe -- nf_conntrack</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给脚本文件赋予执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> 755 /etc/modules.d/k8s.modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本，立即加载所需的内核模块</span></span><br><span class="line">bash /etc/modules.d/k8s.modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证内核模块是否加载成功，查看加载的模块列表中是否包含 ip_vs 和 nf_conntrack 模块</span></span><br><span class="line">lsmod | grep -e ip_vs -e nf_conntrack</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用 sysctl 配置，确保所有内核参数设置立即生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启系统，确保所有配置在系统重启后自动生效</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h5 id="什么是swap分区-为什么要删除"><a href="#什么是swap分区-为什么要删除" class="headerlink" title="什么是swap分区,为什么要删除."></a>什么是swap分区,为什么要删除.</h5><ul><li>你可以把swap分区简单理解成是为了分担RAM的负担的这么一个作用,你可以想象一下你有一个书桌,你工作的时候,为了快速获取资料,你会在书桌上堆满书本,这个时候swap就像书架一样,在书架取书会有点慢,但是你起码有位置放书.</li></ul><ul><li><p>那么为什么我们要在kubernetes中要删除呢,继续刚刚的比喻,现在一个研究馆内,有很多书桌(节点),管理人员(k8s调度器)会根据每个人的书桌的容量进行任务的合理分配.如果启动了书架(swap),管理人员可能不知道,你书桌上的实际容量,要是书桌(RAM)把大量资源放到了书架(swap)上,管理人员(调度器)看你的书桌(RAM)空闲,把大量的资源工作丢给你,可能会导致书桌(RAM)的坍塌</p></li><li><p>一句话:k8s调度器无法知道swap分区里面的情况.</p></li></ul><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><p>这个就不说了,主要是为了更好的后续node以及pod会有自己的网络体系,为了适配关掉最好.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">disable</span> &amp;&amp; systemctl <span class="built_in">disable</span> ufw</span><br><span class="line">swapoff -a &amp;&amp; sed -i <span class="string">&#x27;s|^/swap.img|#/swap.ing|g&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><h5 id="containerd设置-配置runtime-endpoint"><a href="#containerd设置-配置runtime-endpoint" class="headerlink" title="containerd设置-配置runtime-endpoint"></a>containerd设置-配置runtime-endpoint</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># containerd - 运行时设置,这一步不能出错</span></span><br><span class="line">crictl config runtime-endpoint /run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>要是出现无法连接的情况就检查三个地方</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否有/etc/containerd/config.toml 用于配置管理containerd容器运行时守护进程的行为。</span></span><br><span class="line"><span class="built_in">mkdir</span> -vp /etc/containerd/</span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 将配置文件中所有出现的 k8s.gcr.io 替换为 registry.cn-hangzhou.aliyuncs.com/google_containers</span></span><br><span class="line">sed -i <span class="string">&quot;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g&quot;</span>  /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 这里有点问题，需要提前把SystemdCgroup = false删除掉，否则会有重复定义的错误。</span></span><br><span class="line">sed -i <span class="string">&#x27;/containerd.runtimes.runc.options/a\ \ \ \ \ \ \ \ \ \ \ \ SystemdCgroup = true&#x27;</span> /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 修改版</span></span><br><span class="line">CONFIG_FILE=<span class="string">&quot;/etc/containerd/config.toml&quot;</span>; grep -q <span class="string">&#x27;SystemdCgroup&#x27;</span> <span class="string">&quot;<span class="variable">$CONFIG_FILE</span>&quot;</span> &amp;&amp; sed -i <span class="string">&#x27;s/SystemdCgroup =.*/SystemdCgroup = true/&#x27;</span> <span class="string">&quot;<span class="variable">$CONFIG_FILE</span>&quot;</span> || sed -i <span class="string">&#x27;/containerd.runtimes.runc.options/a\ \ \ \ \ \ \ \ \ \ \ \ SystemdCgroup = true&#x27;</span> <span class="string">&quot;<span class="variable">$CONFIG_FILE</span>&quot;</span></span><br><span class="line"><span class="comment"># 将配置文件中所有出现的 https://registry-1.docker.io 替换为 https://xlx9erfu.mirror.aliyuncs.com。</span></span><br><span class="line">sed -i <span class="string">&quot;s#https://registry-1.docker.io#https://xlx9erfu.mirror.aliyuncs.com#g&quot;</span>  /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 是否有/etc/crictl.yaml</span></span><br><span class="line">runtime-endpoint: <span class="string">&quot;unix:///run/containerd/containerd.sock&quot;</span></span><br><span class="line">image-endpoint: <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">timeout</span>: 0</span><br><span class="line">debug: <span class="literal">false</span></span><br><span class="line">pull-image-on-create: <span class="literal">false</span></span><br><span class="line">disable-pull-on-run: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否有/run/containerd/containerd.sock</span></span><br></pre></td></tr></table></figure><h3 id="初始化主节点"><a href="#初始化主节点" class="headerlink" title="初始化主节点"></a>初始化主节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产配置模板，自己把imageRepository改成自己加速的镜像源。</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm.yaml</span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line">kubeadm init --config=kubeadm.yaml --v=5</span><br><span class="line"><span class="comment"># 查看镜像列表</span></span><br><span class="line">kubeadm config images list</span><br><span class="line"><span class="comment"># 然后进行拉取</span></span><br><span class="line">crictl pull</span><br></pre></td></tr></table></figure><p>ps:一定要仔细配置kubeadm。</p><p>要是containerd有问题的话，修改过config.toml，记得restart一下然后记得</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm reset -f --cri-socket unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>ps:修改镜像源后记得修改一下containerd里面的pause的镜像源。</p><p>给个样板在这里：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- <span class="built_in">groups</span>:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 10.70.49.131 <span class="comment"># 必填</span></span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///run/containerd/containerd.sock <span class="comment">#最好加上unix://</span></span><br><span class="line">  imagePullPolicy: IfNotPresent <span class="comment"># 可以忽略镜像拉取，后续可以手动拉</span></span><br><span class="line">  name: masternode-1 <span class="comment"># 必填</span></span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: <span class="comment"># dns有点ex，注意镜像源</span></span><br><span class="line">  <span class="built_in">type</span>: CoreDNS</span><br><span class="line">  imageRepository: k8s.m.daocloud.io/coredns</span><br><span class="line">  imageTag: v1.10.1</span><br><span class="line">etcd:</span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: k8s.m.daocloud.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs <span class="comment"># 开启ipvs模式</span></span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://docs.projectcalico.org/v3.18/manifests/calico.yaml</span><br></pre></td></tr></table></figure><p>然后自己配置一下</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240730105948262.png" alt="image-20240730105948262"></p><p>然后apply一下。等待跑起来</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240730143740906.png" alt="image-20240730143740906"></p><p>哪个拉不起来就去对应的controlby，或者直接deploy上修改image。然后正常来说的话就基本node全部ready</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240730143852876.png" alt="image-20240730143852876"></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排错杂记（pod error）</title>
      <link href="/2024/07/24/%E6%8E%92%E9%9A%9C%E6%97%A5%E5%BF%97%EF%BC%88updating%EF%BC%89/"/>
      <url>/2024/07/24/%E6%8E%92%E9%9A%9C%E6%97%A5%E5%BF%97%EF%BC%88updating%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="尝试排错"><a href="#尝试排错" class="headerlink" title="尝试排错"></a>尝试排错</h3><p>起因是拉起某个pod的时候持续不断的错误边拉边寄，显示的不是image问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104653156.png" alt="image-20240724104653156"></p><p>尝试describe一下，发现调度，拉取，创建，启动似乎都正常</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104802500.png" alt="image-20240724104802500"></p><p>这个时候就得去看日志kubectl log一下，</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104835975.png" alt="image-20240724104835975"></p><p>？？？timeout？？？kubectl 正常能get不至于访问不到api，api是包正常的。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104918625.png" alt="image-20240724104918625"></p><p>那就是网络问题，先看一下插件，插件也正常。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105000612.png" alt="image-20240724105000612"></p><p>再看DNS，似乎有点问题，丢了master3的conredns？？？</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105033529.png" alt="image-20240724105033529"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105351232.png" alt="image-20240724105351232"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105355465.png" alt="image-20240724105355465"></p><p>但是查询后这个pod的是属于master1的pod所以不是dns的问题，缺一个的问题后面再解决。<br>按着尝试手动再吃连接api服务器,草pod fail了，所以用不了，先标记</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it kcollie-pre-hook-install-crds-bdb4g -n kcollie-system -- /bin/sh</span><br><span class="line">curl -k https://10.233.0.1:433</span><br></pre></td></tr></table></figure><p>再check一下kube-system的pod</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724110135451.png" alt="image-20240724110135451"></p><p>md草了，有屎啊，节点二怎么就timeout了，相继的节点一三也爆屎了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724111053894.png" alt="image-20240724111053894"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724111922571.png" alt="image-20240724111922571"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724112010432.png" alt="image-20240724112010432"></p><p>看一下节点情况，感觉可以rollout整个kube-system，完蛋，怎么查个pod状态，查到整个kube崩了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724112656575.png" alt="image-20240724112656575"></p><p>直接rollout所有</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启所有 Deployments</span></span><br><span class="line"><span class="keyword">for</span> deployment <span class="keyword">in</span> $(kubectl get deployments -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart deployment <span class="variable">$deployment</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 StatefulSets</span></span><br><span class="line"><span class="keyword">for</span> statefulset <span class="keyword">in</span> $(kubectl get statefulsets -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart statefulset <span class="variable">$statefulset</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 DaemonSets</span></span><br><span class="line"><span class="keyword">for</span> daemonset <span class="keyword">in</span> $(kubectl get daemonsets -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart daemonset <span class="variable">$daemonset</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总算是起来了，然后有一个node还是not ready，估计是node3的某些pod还没好，但是报错还是</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724125055556.png" alt="image-20240724125055556"></p><p>不懂，node1的apiserver明明好好的，coredns也没问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724130355768.png" alt="image-20240724130355768"></p><p>又死了，草啊啊啊啊啊啊啊啊啊啊。节点不知道为什么十分的不稳定，似乎不断崩溃重启，直接停机加内存。</p><p>估计上面的Error是不怎么影响的。。。。。。。。重启然后就没事了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kind基础</title>
      <link href="/2024/07/24/Kind/"/>
      <url>/2024/07/24/Kind/</url>
      
        <content type="html"><![CDATA[<h2 id="KIND（Kubernetes-IN-Docker）"><a href="#KIND（Kubernetes-IN-Docker）" class="headerlink" title="KIND（Kubernetes IN Docker）"></a>KIND（Kubernetes IN Docker）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>KIND，全称“Kubernetes IN Docker”，是一个开源工具，用于在本地开发和测试 Kubernetes 集群。KIND 允许在 Docker 容器中运行 Kubernetes 集群，从而便于开发者快速创建和销毁 Kubernetes 集群，提升开发效率。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>在使用 KIND 之前，你需要确保以下软件已经正确安装：<br>Docker<br>kubectl<br>确保 Docker 已经启动，并且你的用户在 docker 组中，以便能够运行 Docker 命令而无需 sudo。</p><h4 id="安装-KIND"><a href="#安装-KIND" class="headerlink" title="安装 KIND"></a>安装 KIND</h4><p>在 Linux 环境中，可以通过以下命令获取和安装 KIND：</p><p>curl -Lo ./kind <a href="https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64">https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64</a><br>chmod +x ./kind<br>sudo mv ./kind /usr/local/bin/kind</p><h4 id="检查安装"><a href="#检查安装" class="headerlink" title="检查安装"></a>检查安装</h4><p>验证 KIND 是否安装成功：</p><p>kind –version<br>你应该看到类似 kind v0.11.1 的输出。</p><h3 id="创建-Kubernetes-集群"><a href="#创建-Kubernetes-集群" class="headerlink" title="创建 Kubernetes 集群"></a>创建 Kubernetes 集群</h3><h4 id="简单创建一个集群"><a href="#简单创建一个集群" class="headerlink" title="简单创建一个集群"></a>简单创建一个集群</h4><p>使用以下命令创建一个默认的 Kubernetes 集群：</p><p>kind create cluster<br>成功创建后，你会看到与集群相关的信息输出。</p><h4 id="自定义配置创建集群"><a href="#自定义配置创建集群" class="headerlink" title="自定义配置创建集群"></a>自定义配置创建集群</h4><p>为了更具定制化，可以使用 YAML 文件：</p><p>创建 kind-config.yaml 文件：</p><p>kind: Cluster<br>apiVersion: kind.x-k8s.io/v1alpha4<br>nodes:</p><ul><li>role: control-plane</li><li>role: worker</li><li>role: worker<br>使用以下命令创建集群：</li></ul><p>kind create cluster –config kind-config.yaml</p><h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><p>验证集群状态：</p><p>kubectl cluster-info –context kind-kind</p><h3 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h3><h4 id="部署应用到-KIND-集群"><a href="#部署应用到-KIND-集群" class="headerlink" title="部署应用到 KIND 集群"></a>部署应用到 KIND 集群</h4><p>创建一个名为 nginx-deployment.yaml 的文件：</p><p>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nginx-deployment<br>spec:<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx:1.14.2<br>        ports:<br>        - containerPort: 80<br>使用 kubectl 部署：</p><p>kubectl apply -f nginx-deployment.yaml</p><h4 id="验证部署"><a href="#验证部署" class="headerlink" title="验证部署"></a>验证部署</h4><p>查看部署的状态：</p><p>kubectl get deployments<br>查看 Pods 状态：</p><p>kubectl get pods</p><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><p>创建一个名为 nginx-service.yaml 的文件：</p><p>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: nginx-service<br>spec:<br>  selector:<br>    app: nginx<br>  ports:</p><ul><li>protocol: TCP<br>port: 80<br>targetPort: 80<br>type: LoadBalancer<br>使用 kubectl 暴露服务：</li></ul><p>kubectl apply -f nginx-service.yaml</p><h3 id="KIND的应用场景和作用"><a href="#KIND的应用场景和作用" class="headerlink" title="KIND的应用场景和作用"></a>KIND的应用场景和作用</h3><h4 id="开发和测试环境"><a href="#开发和测试环境" class="headerlink" title="开发和测试环境"></a>开发和测试环境</h4><p>在本地开发和测试 Kubernetes 应用，KIND 的特性让开发者可以快速创建和删除集群，大大提高了开发效率。</p><h4 id="CI-CD管道"><a href="#CI-CD管道" class="headerlink" title="CI/CD管道"></a>CI/CD管道</h4><p>在 CI/CD 管道中，KIND 可以在每次代码变更时快速创建一个新的 Kubernetes 集群用于测试，确保代码的稳定性和一致性。</p><h4 id="学习和培训"><a href="#学习和培训" class="headerlink" title="学习和培训"></a>学习和培训</h4><p>KIND 非常适合用于学习和培训，可以在本地快速搭建 Kubernetes 环境，使学习者掌握 Kubernetes 基本操作和概念。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>KIND 是基于 Docker 容器的，因此某些 Kubernetes 高级功能可能不完全支持。<br>偶尔你可能需要手动清理 Docker 容器和网络设置，特别是在多次创建和删除集群后。<br>不建议在生产环境中使用 KIND，它更适用于开发和测试用途。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>KIND 是一个非常方便的工具，可以帮助我们在本地快速搭建和管理 Kubernetes 集群。无论是开发测试、CI/CD 还是学习培训，KIND 都能发挥其巨大的作用。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus基础</title>
      <link href="/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>一个开源的监控和告警系统</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="多维数据模型"><a href="#多维数据模型" class="headerlink" title="多维数据模型"></a>多维数据模型</h4><ul><li>使用时间序列数据，每个序列有一个度量指标（metricname）和一组键值对（labels）标识，这样可以灵活对同一类进行细分。<h5 id="度量指标"><a href="#度量指标" class="headerlink" title="度量指标"></a>度量指标</h5></li><li>counter：计数器，用于记录累计值，例如请求次数。</li><li>gauge：测量值，可增可减，例如当前内存使用量。</li><li>histogram：直方图，用于记录值分布，例如请求延迟。</li><li>summary：摘要，用于统计分位数和总和，例如响应时间的分位数。</li></ul><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ul><li>一组键值对，用于对时间序列进行细分和区分。例如，监控一个 HTTP 请求的计数器可以通过标签区分不同的请求路径和状态码</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;200&quot;</span>&#125;</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;500&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们有一个 Web 服务，它记录了每个请求的数量和响应时间。我们可以定义以下指标：</p><ol><li>记录请求数量的计数器：<ul><li>Metric Name: <code>http_requests_total</code></li><li>Labels: <code>method</code>, <code>handler</code>, <code>status</code></li></ul></li><li>记录响应时间的直方图：<ul><li>Metric Name: <code>http_request_duration_seconds</code></li><li>Labels: <code>method</code>, <code>handler</code></li></ul></li></ol><p>每次有新的请求进来，计数器和直方图都会更新。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;200&quot;</span>&#125; 1234</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;500&quot;</span>&#125; 56</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.1&quot;</span>&#125; 5</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.5&quot;</span>&#125; 50</span><br></pre></td></tr></table></figure><h4 id="支持PromQL"><a href="#支持PromQL" class="headerlink" title="支持PromQL"></a>支持PromQL</h4><p>查询所有 POST 请求的数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;method=&quot;POST&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询 <code>/api/v1</code> 接口的所有请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;handler=&quot;/api/v1&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询状态码为 200 的请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;status=&quot;200&quot;&#125;)</span><br></pre></td></tr></table></figure><h5 id="优化使用标签"><a href="#优化使用标签" class="headerlink" title="优化使用标签"></a>优化使用标签</h5><ul><li><strong>标签数目不要过多</strong>：过多的标签会导致时间序列爆炸，影响性能。</li><li><strong>标签值尽量稳定</strong>：标签值变化太频繁会增加存储和查询负担。</li><li><strong>合理设计标签</strong>：确保标签的选择能够满足查询需求，同时不过度细化。</li></ul><h4 id="时间序列数据库"><a href="#时间序列数据库" class="headerlink" title="时间序列数据库"></a>时间序列数据库</h4><h5 id="TSDB-Prometheus自带时序数据库"><a href="#TSDB-Prometheus自带时序数据库" class="headerlink" title="TSDB Prometheus自带时序数据库"></a>TSDB Prometheus自带时序数据库</h5><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><p>高效写入：Prometheus 的 TSDB 能够每秒写入数百万个样本，适合高频数据采集。<br>高效查询：针对时间序列数据优化的查询性能。<br>数据压缩：使用差分编码和 Gorilla 压缩算法减少存储空间。<br>局部存储：数据默认存储在本地磁盘上，可以通过远程存储扩展。</p><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>样本 (Sample)：包含一个时间戳和一个值。<br>时间序列 (Time Series)：由一个度量名和一组标签唯一标识的一组样本。<br>块 (Block)：TSDB 中的数据以块的形式存储，每个块通常覆盖 2 小时的数据。<br>WAL (Write-Ahead Log)：在写入到块之前，数据先写入 WAL，以确保数据持久化。</p><h6 id="数据存储和管理"><a href="#数据存储和管理" class="headerlink" title="数据存储和管理"></a>数据存储和管理</h6><ol><li>数据存储路径：默认存储路径为 /var/lib/prometheus，可以在 Prometheus 配置文件中通过 storage.tsdb.path 参数修改。</li><li>数据保留策略：默认保留 15 天的数据，可以通过 –storage.tsdb.retention.time 参数设置。</li><li>数据压缩和删除：Prometheus 会自动压缩和删除过期数据。<h4 id="独立抓取模型："><a href="#独立抓取模型：" class="headerlink" title="独立抓取模型："></a>独立抓取模型：</h4></li></ol><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol><li><strong>Scrape</strong>：Prometheus 从目标处获取监控数据的过程。</li><li><strong>Target</strong>：被监控的对象，可以是服务器、应用程序、数据库等。</li><li><strong>Job</strong>：一组相似目标的集合。</li><li><strong>Exporter</strong>：用于将目标的数据暴露给 Prometheus 的组件，通常是 HTTP 端点</li></ol><h5 id="配置文件’prometheus-yml’"><a href="#配置文件’prometheus-yml’" class="headerlink" title="配置文件’prometheus.yml’"></a>配置文件’prometheus.yml’</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s     <span class="comment"># 每15秒抓取一次数据</span></span><br><span class="line">  evaluation_interval: 15s <span class="comment"># 每15秒评估一次规则</span></span><br></pre></td></tr></table></figure><h6 id="抓取配置"><a href="#抓取配置" class="headerlink" title="抓取配置"></a>抓取配置</h6><p>抓取配置定义了 Prometheus 如何发现和抓取目标数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br></pre></td></tr></table></figure><h6 id="动态服务发现"><a href="#动态服务发现" class="headerlink" title="动态服务发现"></a>动态服务发现</h6><p>Prometheus 支持多种服务发现机制，允许动态发现目标。例如，可以使用 Kubernetes、Consul、Etcd 等进行服务发现。</p><p>####### Exporter<br>Exporter 是将监控数据暴露给 Prometheus 的组件，不同的应用和系统有不同的 Exporter。例如：</p><ul><li>Node Exporter：用于监控操作系统的资源使用情况。</li><li>Blackbox Exporter：用于进行探测和检查（如 HTTP、HTTPS、TCP）。</li><li>MySQL Exporter：用于监控 MySQL 数据库。</li></ul><h4 id="多种数据支持："><a href="#多种数据支持：" class="headerlink" title="多种数据支持："></a>多种数据支持：</h4><p>支持包括通过导出器（exporters）收集第三方系统的数据，支持服务发现（Service Discovery），如 Kubernetes、Consul、Etcd 等</p><h4 id="告警："><a href="#告警：" class="headerlink" title="告警："></a>告警：</h4><p>内置了 Alertmanager，用于处理告警通知和管理告警规则。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol><li>Prometheus Server：<br>存储：使用基于时间序列数据库（TSDB）的本地存储来存储监控数据。<br>抓取（Scrape）：定期从目标端点（如应用程序、数据库等）拉取指标数据。<br>PromQL 查询引擎：允许用户通过 PromQL 查询存储的数据。</li><li>数据导出器（Exporters）：<br>节点导出器（Node Exporter）：收集系统级别的指标，如 CPU、内存、磁盘使用等。<br>应用程序导出器：如 MySQL Exporter、Redis Exporter，专门用于从特定应用中收集指标。</li><li>服务发现（Service Discovery）：<br>支持多种服务发现机制，如 Kubernetes、Consul、DNS 等，自动发现并监控动态变化的服务和主机。</li><li>Alertmanager：<br>告警规则：定义告警规则，当满足条件时触发告警。<br>告警通知：管理告警的路由和发送，支持多种通知方式，如电子邮件、Slack、PagerDuty 等。<br>告警抑制和分组：可以配置告警抑制规则和告警分组，避免告警风暴。</li><li>Pushgateway：<br>用于接收临时性任务（如批处理任务）的指标数据，这些任务无法被 Prometheus 定期拉取。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>配置和服务发现：通过配置文件或服务发现机制，Prometheus 确定需要监控的目标。</li><li>抓取数据：Prometheus 定期从目标端点拉取指标数据。</li><li>存储数据：将拉取到的指标数据存储在本地的时间序列数据库中。</li><li>查询和可视化：通过 PromQL 查询数据，结合 Grafana 等可视化工具展示监控结果。</li><li>告警处理：根据定义的告警规则，Prometheus 触发告警并通过 Alertmanager 发送通知。</li></ol>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单ansible操作</title>
      <link href="/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><p>用于配置管理、应用程序部署、任务自动化</p><h3 id="ansible主机清单"><a href="#ansible主机清单" class="headerlink" title="ansible主机清单"></a>ansible主机清单</h3><h4 id="定义组"><a href="#定义组" class="headerlink" title="定义组"></a>定义组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[webservers] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dbserver] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dce5_nodes]</span><br><span class="line">10.70.49.17[2:4]</span><br><span class="line"></span><br><span class="line">[all:vars] <span class="comment"># 定义全局变量适用于全部主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 用户名，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_user: guest2admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 密码，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_pass: @<span class="built_in">users</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible 使用的 Python 解释器路径</span></span><br><span class="line">ansible_python_interpreter: /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接的通用参数，这里指定了加密算法为 AES-256-CBC</span></span><br><span class="line">ansible_ssh_common_args: -c aes256-cbc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Ansible 连接到主机的方式，这里使用 SSH</span></span><br><span class="line">ansible_connection: ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权操作时使用的密码（例如切换到 root 用户时的密码）</span></span><br><span class="line">ansible_become_password: root@root@su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权方法，这里使用 su 命令切换用户</span></span><br><span class="line">ansible_become_method: su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权执行命令，这里指定了使用 sudo su - 命令来切换到超级用户</span></span><br><span class="line">ansible_become_exe: sudo su -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以组别变量</span></span><br><span class="line">[webserver:vars]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h3><ol><li><p><strong>Ping 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><p>通过 Ping 模块测试所有主机是否可达。</p></li><li><p><strong>Shell 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;uptime&#x27;</span></span><br></pre></td></tr></table></figure><p>在所有主机上执行 <code>uptime</code> 命令。</p></li><li><p><strong>Command 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&#x27;ls /tmp&#x27;</span></span><br></pre></td></tr></table></figure><p>使用 <code>command</code> 模块列出 <code>/tmp</code> 目录下的文件。</p></li><li><p><strong>Copy 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">&#x27;src=/path/to/source dest=/path/to/destination&#x27;</span></span><br></pre></td></tr></table></figure><p>将本地文件复制到远程主机。</p></li><li><p><strong>File 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m file -a <span class="string">&#x27;path=/tmp/testfile state=touch&#x27;</span></span><br></pre></td></tr></table></figure><p>在远程主机上创建一个空文件。</p></li><li><p><strong>Service 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m service -a <span class="string">&#x27;name=httpd state=started&#x27;</span></span><br></pre></td></tr></table></figure><p>启动所有主机上的 httpd 服务。</p></li><li><p><strong>User 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m user -a <span class="string">&#x27;name=johndoe state=present&#x27;</span></span><br></pre></td></tr></table></figure><p>创建一个名为 <code>johndoe</code> 的用户。</p></li></ol><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-i &lt;inventory&gt;</code>：指定主机清单文件。例如 <code>-i hosts</code>。</li><li><code>--list-hosts</code>：列出将运行任务的主机。</li><li><code>-l &lt;subset&gt;</code>：指定要执行任务的主机子集。例如 <code>-l webservers</code>。</li><li><code>-u &lt;user&gt;</code>：指定远程主机用户。例如 <code>-u root</code>。</li><li><code>-k</code>：提示输入 SSH 密码。</li><li><code>--ask-become-pass</code>：提示输入 sudo 密码。</li><li><code>-e &lt;extra_vars&gt;</code>：传递额外变量。例如 <code>-e &quot;var1=value1 var2=value2&quot;</code>。</li></ul><h3 id="示例详解"><a href="#示例详解" class="headerlink" title="示例详解"></a>示例详解</h3><ol><li><p><strong>列出主机</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all --list-hosts</span><br></pre></td></tr></table></figure><p>列出所有在清单中的主机。</p></li><li><p><strong>指定用户和密码执行命令</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;df -h&#x27;</span> -u root -k</span><br></pre></td></tr></table></figure><p>使用 root 用户执行 <code>df -h</code> 命令，并提示输入密码。</p></li><li><p><strong>传递额外变量</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;echo &#123;&#123; var_name &#125;&#125;&#x27;</span> -e <span class="string">&#x27;var_name=HelloWorld&#x27;</span></span><br></pre></td></tr></table></figure><p>传递变量 <code>var_name</code>，并在命令中使用。</p></li></ol><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ol><li><p><strong>使用标签</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;systemctl restart httpd&#x27;</span> --tags <span class="string">&quot;restart&quot;</span></span><br></pre></td></tr></table></figure><p>使用标签来组织和执行特定的任务。</p></li><li><p><strong>检查主机连通性</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping -i inventory/hosts</span><br></pre></td></tr></table></figure><p>使用指定的主机清单文件检查连通性。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes服务网格</title>
      <link href="/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
      <url>/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="kubernetes服务网格"><a href="#kubernetes服务网格" class="headerlink" title="kubernetes服务网格"></a>kubernetes服务网格</h2><p>是一种架构，为了解决服务和服务之间的通信。</p><h3 id="服务网格接口（打算理解）"><a href="#服务网格接口（打算理解）" class="headerlink" title="服务网格接口（打算理解）"></a>服务网格接口（打算理解）</h3><h4 id="SMI"><a href="#SMI" class="headerlink" title="SMI"></a>SMI</h4><p>  用于定义服务网格标准化接口的规范，旨在提供一个通用的接口，让不同的服务网格实现可以互操作。SMI的主要目的是简化服务网格的使用和集成，使用户可以使用统一的API管理不同的服务网格实现，如Istio、Linkerd、Consul Connect等。</p><h4 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h4><p>  是Kubernetes中的一种机制，用于扩展Kubernetes API，使用户可以定义自己的资源类型。通过CRD，用户可以创建自定义资源（CR），这些资源可以与Kubernetes内置资源（如Pod、Service）一样进行管理和操作。</p><h3 id="数据平面代理"><a href="#数据平面代理" class="headerlink" title="数据平面代理"></a>数据平面代理</h3><p>负责处理和管理服务间流量的代理组件。</p><p>核心职责:<br>流量转发：代理组件负责接收、转发和负载均衡服务之间的流量。这包括 HTTP、gRPC、TCP 等多种协议。<br>服务发现：代理可以自动发现 Kubernetes 中的服务，根据服务的配置进行相应的流量路由。<br>流量管理：包括流量控制、重试策略、断路器、故障注入等功能，以保证服务间通信的可靠性和稳定性。<br>安全：提供 mTLS（双向 TLS）加密来确保服务间通信的安全性，支持认证和授权策略。<br>监控和可观测性：代理会收集并上报各种流量指标和日志，帮助管理员监控和诊断服务间的通信问题。</p><h4 id="数据平面架构"><a href="#数据平面架构" class="headerlink" title="数据平面架构"></a>数据平面架构</h4><h5 id="代理附件"><a href="#代理附件" class="headerlink" title="代理附件"></a>代理附件</h5><p>一般部署在工作负载的pod上，后续会拦截进出服务的所有通信，但是在一些升级上，代理附件不能保证在不重建Pod的条件下进行升级</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112524609.png" alt="image-20240722112524609"></p><h5 id="代理节点"><a href="#代理节点" class="headerlink" title="代理节点"></a>代理节点</h5><p>由代理节点来处理运行服务的所有流量。但是会存在很大的网络瓶颈。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112926402.png" alt="image-20240722112926402"></p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>  一个高性能的开源边缘和服务代理，主要用于微服务架构中的通信管理</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722102428515.png" alt="image-20240722102428515"></p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><h6 id="API网关："><a href="#API网关：" class="headerlink" title="API网关："></a>API网关：</h6><p>Envoy可以作为API网关，处理外部请求并将其路由到内部服务，同时提供认证、限流、缓存等功能。</p><h6 id="边车代理："><a href="#边车代理：" class="headerlink" title="边车代理："></a>边车代理：</h6><ul><li>是一种设计模式，在这种模式下，一个代理程序（如Envoy）被部署在每个服务实例的旁边，这样每个服务实例都有一个独立的代理来处理进出流量。</li><li>在服务网格架构中，Envoy通常以边车代理的形式部署在每个服务实例旁，拦截和处理所有入站和出站流量。</li><li>边车注入是将边车代理自动注入到服务实例的Pod中，以便在微服务架构中实现服务网格功能的过程。分为手动与自动，自动注入似乎能够用istio来进行自动注入。</li><li>Sidecar 模式：Envoy 通常以 sidecar 容器的形式部署在每个微服务 Pod 内，与应用容器共享网络命名空间。所有进出微服务的流量都会通过 Envoy 代理。</li></ul><h6 id="中介层代理："><a href="#中介层代理：" class="headerlink" title="中介层代理："></a>中介层代理：</h6><p>Envoy可以部署在不同的服务层之间，作为中介层代理，处理跨服务的流量和策略管理。</p><h5 id="模块化架构"><a href="#模块化架构" class="headerlink" title="模块化架构"></a>模块化架构</h5><p>Listener：<br>作用：Listener是Envoy用于监听网络端口的组件，负责接受客户端的连接请求。每个Listener都绑定到一个特定的IP地址和端口，并根据配置将流量传递给相应的处理模块。<br>配置：Listener的配置包括监听的地址和端口、使用的协议（如HTTP、TCP）、以及关联的过滤器链。</p><p>Filter：<br>作用：Filter是Envoy用于处理请求和响应的中间处理模块。Filter可以用于修改请求、添加日志、执行身份验证、路由选择等。Envoy的Filter分为多种类型，包括网络过滤器、HTTP过滤器和TCP过滤器。<br>类型：<br>网络过滤器：处理TCP连接层面的流量，如TLS终止、连接限速等。<br>HTTP过滤器：处理HTTP请求和响应，如修改头部信息、执行认证和授权、负载均衡等。<br>TCP过滤器：处理TCP层流量，如TCP代理、流量镜像等。</p><p>Cluster：<br>作用：Cluster是Envoy用于表示一组上游服务实例的组件。Cluster负责服务发现、负载均衡、健康检查等。每个Cluster包含多个主机（即上游服务实例），并定义了如何将流量分配到这些主机上。<br>配置：Cluster的配置包括服务发现类型（静态、DNS、EDS等）、负载均衡策略（如轮询、随机、加权轮询等）、健康检查配置等。</p><p>Route：<br>作用：Route组件定义了Envoy如何将请求路由到不同的Cluster。Route规则基于请求的属性（如路径、头部信息、方法等）来决定具体的路由目标。<br>配置：Route的配置包括匹配规则、路由目标Cluster、重试策略、超时设置等。</p><p>Admin：<br>作用：Admin组件提供了管理和监控Envoy的接口。通过Admin接口，用户可以查看Envoy的运行状态、统计信息、配置详情，并进行管理操作。<br>配置：Admin接口通常通过HTTP API暴露，可以在Envoy配置中指定Admin的监听地址和端口。</p><h5 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h5><p>配置管理<br>Envoy的配置管理可以通过静态文件配置，也可以通过动态配置API（xDS）实现。xDS（Envoy Dynamic Configuration API）包括以下几个部分：<br>ADS（Aggregated Discovery Service）：聚合配置服务，统一管理其他xDS服务。<br>CDS（Cluster Discovery Service）：动态管理Cluster的配置。<br>EDS（Endpoint Discovery Service）：动态管理Cluster中上游服务实例的配置。<br>LDS（Listener Discovery Service）：动态管理Listener的配置。<br>RDS（Route Discovery Service）：动态管理路由配置。<br>SDS（Secret Discovery Service）：动态管理密钥和证书。</p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>负责管理和协调数据平面代理</p><p>配置管理：提供统一的配置接口，管理服务网格中所有代理的配置，包括路由规则、负载均衡策略、故障恢复策略等。<br>服务发现：集成服务发现机制，实时感知集群中服务的变化，并通知数据平面代理更新其配置。<br>安全管理：实现服务间的认证和授权，管理 TLS 证书的分发和轮换，确保服务间通信的安全性。<br>流量管理：提供流量路由、灰度发布、A/B 测试等高级流量控制功能，帮助开发和运维人员灵活管理服务间的流量。<br>可观测性：收集和聚合数据平面代理的监控指标、日志和分布式追踪数据，提供全局的可观测性视图，帮助排查和诊断问题。</p><h4 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h4><p>istiod为基于envoy的服务网络提供控制平面，他包括三个核心组件，Galley，Pilot，Citidel</p><p>Pilot：一个Envoy的配置服务器，实现 xDS API，并将配置流向与应用程序一起运行的Envoy代理。</p><p>Citadel：负责网格内的证书管理，建立服务器身份和相互TLS。</p><p>Galley：与外部系统互动，Kubernetes等。</p><h4 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h4><p>用于在 Kubernetes 集群中实现动态配置和策略控制的关键组件。 Istio 中的主要用途包括服务网格控制、资源变更管理和策略执行等。</p><ul><li>自动注入 Sidecar 容器:Istio 使用一个变异（Mutating）Webhook 自动将 Envoy 代理（Sidecar）注入到新创建的 Kubernetes Pod 中。这个过程确保每个服务都能被 Istio 管理和监控。当你为集群启用了自动注入，Webhook 会拦截 Pod 创建请求，在 Pod 完成调度之前往其定义中添加 Envoy 容器以及必要的配置信息。</li><li>配置验证（Validating Webhook）:验证（Validating）Webhook 用于在新的 Istio 配置资源（如 VirtualService、DestinationRule 等）创建或更新时执行验证过程，确保这些配置符合要求，避免因错误配置导致服务故障。这个 Webhook 会在配置提交到 etcd 之前进行执行，起到一个“守门人”的作用，阻止不符合标准的配置生效。</li><li>动态配置和策略控制:Webhook 还可以用于执行动态配置和策略决策。例如，通过 Webhook，可以向运行时注入配置参数或更新策略以应对瞬时需求或安全要求。</li></ul><h4 id="通过iptable达到工作负载通过Envoy发送流量。"><a href="#通过iptable达到工作负载通过Envoy发送流量。" class="headerlink" title="通过iptable达到工作负载通过Envoy发送流量。"></a>通过iptable达到工作负载通过Envoy发送流量。</h4><p>Istio的iptables规则是通过init-containner来进行安装，拦截pod网络流量路由到Envoy。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722111557580.png" alt="image-20240722111557580"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="string">”argS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">istio-iptables</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--envoy-port</span> <span class="comment">#捕获出站的所有流量，并且发送到Envoy这个端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15001&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--inbound-capture-port</span> <span class="comment">#捕获入站的所有流量，并且发送Envoy这个端口1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15006&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--proxy-uid</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;1337”</span></span><br><span class="line"><span class="string">- --istio-inbound-interception-mode</span></span><br><span class="line"><span class="string">- REDIRECT</span></span><br><span class="line"><span class="string">--istio-service-cidr </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">--istio-inbound-ports </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">- --istio-local-exclude-ports</span></span><br><span class="line"><span class="string">- 15090,15021,15020</span></span><br><span class="line"><span class="string">image: docker.io/istio/proxyv2:1.6.7</span></span><br><span class="line"><span class="string">imagePullPolicy: Always</span></span><br><span class="line"><span class="string">name: istio-init</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes ingress基础</title>
      <link href="/2024/07/19/Kubernetes_ingress/"/>
      <url>/2024/07/19/Kubernetes_ingress/</url>
      
        <content type="html"><![CDATA[<h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><p>  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，可以简单的理解为一个外包，现在在互联网上很多的流量都使用了TLS/SSL协议继续加密，但是这也会增加服务器的负担，因此SSL终止可以理解成<code>外包</code>一个机器处理这个问题。一般这个外包工作会给到负载均衡器和反向代理。</p><h3 id="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"><a href="#为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？" class="headerlink" title="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"></a>为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？</h3><ul><li>好像就是因为service不够用:dog:所以才有了ingress的存在，而且似乎ingress在处理HTTP和HTTPS流量的能力上十分出色。</li><li>除此之外ingress跳脱到应用层进行负载和流量路由的功能，大大减少统一访问策略和路由规则:boom:</li><li>而且ingress似乎为每一个集群提供了单一入口，流量能够精准投送。:fish:</li></ul><h3 id="ingress-配置冲突"><a href="#ingress-配置冲突" class="headerlink" title="ingress 配置冲突"></a>ingress 配置冲突</h3><p>不同团队或租户尝试使用相同的域名来暴露他们的应用程序时，可能会发生的问题。简单来说，就是两个团队都想用同一个域名，比如<code>app.bearcanoe.com</code>，来让外界访问他们的应用程序。这会导致冲突，因为Ingress控制器（管理这些网络流量的组件）不明确如何处理这种情况</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>准入控制器：在配置被应用到集群之前，验证并确保域名的唯一性。可以使用开放策略代理（OPA）来实现这个功能。</li><li>Contour Ingress 控制器：使用HTTPProxy自定义资源，创建一个根HTTPProxy资源，分配给特定团队。这种方法将域名管理集中化，避免冲突。</li></ol><h3 id="Ingress控制器"><a href="#Ingress控制器" class="headerlink" title="Ingress控制器"></a>Ingress控制器</h3><p>是用来实现Ingress资源定义的路由规则和流量管理的组件，以Pod的形式存在运行，负责解析Ingress资源，配置底层反向代理或负载均衡以处理HTTP和HTTPS流量 。</p><ol><li>解析 Ingress 资源：Ingress 控制器会监视 :eye: Kubernetes API，解析和处理定义在 Ingress 资源中的路由规则和配置。</li><li>配置反向代理/负载均衡器：根据解析到的 Ingress 规则，Ingress 控制器会动态配置底层的反向代理（如 NGINX、HAProxy）或云 :cloud: 提供商的负载均衡器（如 AWS ELB、GCP Load Balancer）。</li><li>管理外部访问：Ingress 控制器 :control_knobs: 负责将外部请求路由到集群内相应的服务，管理 HTTP/HTTPS 流量的转发、负载均衡以及 SSL/TLS 终止等功能。</li><li>支持高级特性：许多 Ingress 控制器支持高级功能，如基于 Cookie 的会话保持、限速、访问控制和基于 IP 的访问限制等。</li></ol><h3 id="流量模式"><a href="#流量模式" class="headerlink" title="流量模式"></a>流量模式</h3><h4 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h4><p>:question:什么是HTTP代理呢，想象一下你需要借一本书，但是这本书在一个封闭的空间内，你不能够直接自己拿到，这个时候你就需要一个中间人来帮你去借。这个时候这个中间人就可以理解成代理人。就是当客户进行一个HTTP请求，这个请求会通过代理服务器转发到目标服务器。反向代理也是这么理解，目标服务器的资源通过代理服务器传输出去。</p><p>:boy:ingress处理HTTP流量很简单，就是通过host头进行路由转发</p><h4 id="HTTPS代理"><a href="#HTTPS代理" class="headerlink" title="HTTPS代理"></a>HTTPS代理</h4><p>:question:HTTPS流量处理的有些特别，ingress在获取流量的时候进行SSL终止，然后建立新的HTTP请求进行转发。</p><p>但是特殊情况为了安全起见。ingress也会进行SSL终止之后再进行TLS加密与后端pod建立连接。</p><h4 id="OCI-3-4层代理"><a href="#OCI-3-4层代理" class="headerlink" title="OCI 3/4层代理"></a>OCI 3/4层代理</h4><p>:calendar:不懂往后点再研究…….</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="control-knobs-nginx-ingress-controller"><a href="#control-knobs-nginx-ingress-controller" class="headerlink" title=":control_knobs:nginx ingress controller"></a>:control_knobs:nginx ingress controller</h4><p>常用于HTTP和反向代理</p><ul><li>支持SSL/TLS终止</li><li>基于主机名和路径的路由</li><li>支持URL重写和重定向</li></ul><h4 id="control-knobs-Istio-ingress-Gateway"><a href="#control-knobs-Istio-ingress-Gateway" class="headerlink" title=":control_knobs:Istio ingress Gateway"></a>:control_knobs:Istio ingress Gateway</h4><p>Istio Ingress Gateway 是 Istio 服务网格中的一个组件，专门用于管理进入服务网格的外部 HTTP 和 HTTPS 流量。与传统的 Kubernetes Ingress 不同，Istio Ingress Gateway 提供了更多的高级流量管理和安全功能，如细粒度的流量控制、策略管理和监控。</p><h5 id="Istio-Ingress-Gateway-组件"><a href="#Istio-Ingress-Gateway-组件" class="headerlink" title="Istio Ingress Gateway 组件"></a>Istio Ingress Gateway 组件</h5><ol><li>:door: Gateway：定义哪些外部流量可以进入服务网格，以及如何路由这些流量。</li><li>VirtualService：定义流量的具体路由规则，可以包含多种匹配条件和路由行为。</li></ol><h4 id="control-knobs-HAProxy-Ingress"><a href="#control-knobs-HAProxy-Ingress" class="headerlink" title=":control_knobs: HAProxy Ingress"></a>:control_knobs: HAProxy Ingress</h4><p>高性能和高级路由功能，路由灵活，低延迟，负载均衡算法</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes服务基础</title>
      <link href="/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes服务基础"><a href="#Kubernetes服务基础" class="headerlink" title="Kubernetes服务基础"></a>Kubernetes服务基础</h1><h2 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl get svc &lt;svc-name&gt;</span><br><span class="line">kubectl describe svc &lt;svc-name&gt;</span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">kubectl expose deployment &lt;d-name&gt; --port&lt;port&gt; --target-port=&lt;target-port&gt;</span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">kubectl get endpoints &lt;svc-name&gt;：查看服务端点</span><br><span class="line">kubectl port-forward svc/&lt;svc-name&gt;&lt;local-port&gt;:&lt;svc-port&gt;:本地端口转发服务端口</span><br></pre></td></tr></table></figure><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h3><ul><li>ClusterIP: 分配一个集群内部的ip地址，使得服务只能集群内部访问</li><li>NodePort: 在每个节点上分配一个端口，是的可以外部访问服务</li><li>LoadBalancer: 使用负载均衡来暴露服务，让服务加入后端池</li><li>ExternalName: 通过返回的CNAME记录来映射另一个外部的DNS名称</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717132825010.png" alt="image-20240717132825010"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717145241179.png" alt="image-20240717145241179"></p><h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>用于定义一组Pod的逻辑集合，并且可以通过一个稳定的IP地址和端口进行访问。<code>ClusterIP</code>服务类型会在集群内部分配一个虚拟IP地址，这个IP地址只能在集群内部访问，不能从外部直接访问。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ClusterIP</code>类型的Service时，Kubernetes会为这个Service分配一个虚拟IP地址（Cluster IP）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>内部负载均衡</strong>: 当集群内的其他Pod或服务通过Cluster IP访问这个Service时，Kubernetes会自动将请求负载均衡到后端的Pod上。</li></ol><h5 id="yaml参考"><a href="#yaml参考" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: 855d96b0-c9e8-4ef2-afe5-bdb86e21adc3</span><br><span class="line">  resourceVersion: <span class="string">&#x27;194&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-12T07:36:07Z&#x27;</span></span><br><span class="line">  labels:</span><br><span class="line">    component: apiserver</span><br><span class="line">    provider: kubernetes</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: https</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 6443</span><br><span class="line">  clusterIP: 10.233.0.1</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.0.1</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>NodePort</code>类型的Service时，Kubernetes会在每个节点上分配一个端口（范围通常是30000-32767）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>节点端口（NodePort）</strong>: Kubernetes会在每个节点上开放一个指定的端口，并将这个端口的流量转发到Service的Cluster IP，然后再负载均衡到后端的Pod上。</li></ol><h4 id="yaml参考-1"><a href="#yaml参考-1" class="headerlink" title="yaml参考"></a>yaml参考</h4><h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>ps：这里的LoadBalancer和云上的不同，是为了解决nodeport不清晰问题。</p><h5 id="外部流量策略"><a href="#外部流量策略" class="headerlink" title="外部流量策略"></a>外部流量策略</h5><ol><li>cluster</li></ol><ul><li>把流量分配给所有集群中所有节点的可用实例上</li><li>能够做到全局分配和高利用，但是可能会造成比较高的延迟</li><li>场景：适合需要整体稳定可用的</li></ul><ol start="2"><li>local</li></ol><ul><li>优先把流量分给同一节点或同一区域的可用实例上</li><li>能够低延迟访问服务，本地优先</li><li>场景：适合游戏或者视频流媒体</li></ul><h5 id="yaml参考-2"><a href="#yaml参考-2" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: loadbalancer-01</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: c4093644-e423-4737-94e1-8fd92606933d</span><br><span class="line">  resourceVersion: <span class="string">&#x27;3774606&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-16T03:04:31Z&#x27;</span></span><br><span class="line">  annotations:</span><br><span class="line">    kpanda.io/alias-name: loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: tcp-loadbalaner</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 8081</span><br><span class="line">      targetPort: 8081</span><br><span class="line">      nodePort: 30683</span><br><span class="line">  selector:</span><br><span class="line">    app: baize-notebook-ssh</span><br><span class="line">  clusterIP: 10.233.59.228</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.59.228</span><br><span class="line">  <span class="built_in">type</span>: LoadBalancer</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  allocateLoadBalancerNodePorts: <span class="literal">true</span></span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h4><h5 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ExternalName</code>类型的Service时，你需要指定一个外部的DNS名称。</li><li><strong>DNS解析</strong>: Kubernetes的DNS服务会为这个Service创建一个CNAME记录，将Service名称解析为指定的外部DNS名称。</li><li><strong>访问外部服务</strong>: 集群内的Pod可以通过Service名称访问外部的服务，Kubernetes的DNS服务会将这个名称解析为外部的DNS名称</li></ol><h5 id="yaml参考-3"><a href="#yaml参考-3" class="headerlink" title="yaml参考"></a>yaml参考</h5><p>不许参考，懒得cv了都基本一样就其他字段和type不同。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Linux文件</title>
      <link href="/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/"/>
      <url>/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h3><h4 id="1-lsof-List-Open-Files"><a href="#1-lsof-List-Open-Files" class="headerlink" title="1. lsof (List Open Files)"></a>1. lsof (List Open Files)</h4><p><code>lsof</code>命令用于列出当前系统中已打开的文件。它可以显示哪个进程正在使用哪个文件，并提供有关这些文件的详细信息。这个命令在排查文件占用、删除不成功或挂载卸载问题时非常有用。</p><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof [选项] [文件]</span><br></pre></td></tr></table></figure><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-u</code>：显示指定用户打开的文件。</li><li><code>-p</code>：显示指定进程ID打开的文件。</li><li><code>+D</code>：递归显示指定目录下的所有打开文件。</li><li><code>-i</code>：显示与网络相关的文件（例如端口使用情况）。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>列出所有打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>查看用户<code>user</code>打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u user</span><br></pre></td></tr></table></figure><p>显示进程ID为1234的进程打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure><h4 id="2-cp-Copy-Files"><a href="#2-cp-Copy-Files" class="headerlink" title="2. cp (Copy Files)"></a>2. cp (Copy Files)</h4><p><code>cp</code>命令用于复制文件和目录。</p><h5 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-r</code>：递归复制目录及其内容。</li><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时复制。</li><li><code>-p</code>：保留源文件的属性。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>复制文件<code>file1</code>到<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> file1 file2</span><br></pre></td></tr></table></figure><p>递归复制目录<code>dir1</code>到<code>dir2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r dir1 dir2</span><br></pre></td></tr></table></figure><h4 id="3-mv-Move-Rename-Files"><a href="#3-mv-Move-Rename-Files" class="headerlink" title="3. mv (Move/Rename Files)"></a>3. mv (Move/Rename Files)</h4><p><code>mv</code>命令用于移动或重命名文件和目录。</p><h5 id="基本语法：-2"><a href="#基本语法：-2" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时移动。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>重命名文件<code>file1</code>为<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 file2</span><br></pre></td></tr></table></figure><p>移动文件<code>file1</code>到目录<code>dir1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 dir1/</span><br></pre></td></tr></table></figure><h4 id="4-ln-Link-Files"><a href="#4-ln-Link-Files" class="headerlink" title="4. ln (Link Files)"></a>4. ln (Link Files)</h4><p><code>ln</code>命令用于创建硬链接或符号链接（软链接）。</p><h5 id="基本语法：-3"><a href="#基本语法：-3" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [选项] 目标文件 链接文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-s</code>：创建符号链接。</li><li><code>-f</code>：覆盖已有的链接文件。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><p>创建文件<code>file1</code>的硬链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><p>创建文件<code>file1</code>的符号链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file1 link1</span><br></pre></td></tr></table></figure><p>在Linux系统中，建立文件链接（Link）是非常有用的，它提供了多种文件管理和使用的灵活性。文件链接主要分为两种类型：硬链接（Hard Link）和符号链接（Symbolic Link，也称为软链接）。以下是建立链接的原因和它们的用途：</p><h5 id="硬链接（Hard-Link）"><a href="#硬链接（Hard-Link）" class="headerlink" title="硬链接（Hard Link）"></a>硬链接（Hard Link）</h5><p>硬链接是对文件的直接引用。每个硬链接都指向文件的相同物理数据块，因此它们是完全等价的。</p><h6 id="建立硬链接的原因："><a href="#建立硬链接的原因：" class="headerlink" title="建立硬链接的原因："></a>建立硬链接的原因：</h6><ol><li><strong>冗余与备份</strong>：硬链接允许在不同位置访问同一文件内容，可以在不同目录中保持文件的多个访问点，从而提高冗余度，避免文件意外删除。</li><li><strong>节省空间</strong>：硬链接不会占用额外的存储空间，因为它们只是指向同一个物理数据块。</li><li><strong>一致性</strong>：硬链接确保文件的多个实例始终保持同步。对其中一个硬链接的修改会影响所有其他硬链接，因为它们指向相同的数据块。</li></ol><h6 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><h5 id="符号链接（Symbolic-Link-Soft-Link）"><a href="#符号链接（Symbolic-Link-Soft-Link）" class="headerlink" title="符号链接（Symbolic Link / Soft Link）"></a>符号链接（Symbolic Link / Soft Link）</h5><p>符号链接是指向另一个文件路径的引用。它们类似于快捷方式，包含了目标文件或目录的路径。</p><h6 id="建立符号链接的原因："><a href="#建立符号链接的原因：" class="headerlink" title="建立符号链接的原因："></a>建立符号链接的原因：</h6><ol><li><strong>灵活性</strong>：符号链接可以跨文件系统边界创建，而硬链接只能在同一文件系统内使用。它们可以指向目录或文件。</li><li><strong>便捷访问</strong>：通过符号链接，用户可以创建对常用文件或目录的快捷访问点，简化路径的输入和操作。</li><li><strong>组织结构</strong>：符号链接可以帮助组织文件系统，使某些文件或目录在多个位置都能方便地访问，而不需要复制实际数据。</li><li><strong>共享资源</strong>：在多用户环境中，符号链接可以用于共享公共资源，例如库文件、配置文件等，而不必在每个用户目录中复制一份。</li></ol><h6 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/original /path/to/symlink</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Linux网络</title>
      <link href="/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-tcpdump"><a href="#1-tcpdump" class="headerlink" title="1. tcpdump"></a>1. <code>tcpdump</code></h3><p><code>tcpdump</code> 是一个网络抓包工具，可以捕获并分析网络流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上的所有数据包。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.1</span><br></pre></td></tr></table></figure><p>捕获与特定主机 <code>192.168.1.1</code> 相关的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上所有通过端口 <code>80</code> 的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -w capture.pcap</span><br></pre></td></tr></table></figure><p>将捕获的数据包保存到文件 <code>capture.pcap</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r capture.pcap</span><br></pre></td></tr></table></figure><p>读取并分析 <code>capture.pcap</code> 文件中的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#x27;</span></span><br></pre></td></tr></table></figure><p>捕获所有带有 SYN 或 ACK 标志的 TCP 包。</p><h3 id="2-lsof"><a href="#2-lsof" class="headerlink" title="2. lsof"></a>2. <code>lsof</code></h3><p><code>lsof</code> 显示系统中打开的文件，常用于查看打开的网络连接。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p>显示所有打开的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><p>显示所有使用端口 <code>80</code> 的网络连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>显示特定进程 <code>&lt;PID&gt;</code> 打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u &lt;username&gt;</span><br></pre></td></tr></table></figure><p>显示特定用户打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof /path/to/file</span><br></pre></td></tr></table></figure><p>显示哪个进程打开了指定文件。</p><h3 id="3-net-tools"><a href="#3-net-tools" class="headerlink" title="3. net-tools"></a>3. <code>net-tools</code></h3><p><code>net-tools</code> 包含 <code>ifconfig</code>、<code>netstat</code> 等工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure><p>显示接口 <code>eth0</code> 的配置信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p>显示所有活动的网络连接及其状态。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.100 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>配置接口 <code>eth0</code> 的 IP 地址和子网掩码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p>显示路由表信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><p>显示网络接口统计信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -plnt</span><br></pre></td></tr></table></figure><p>显示所有监听的 TCP 端口及其关联的进程。</p><h3 id="4-iproute2"><a href="#4-iproute2" class="headerlink" title="4. iproute2"></a>4. <code>iproute2</code></h3><p><code>iproute2</code> 是 <code>net-tools</code> 的替代品，提供 <code>ip</code> 命令。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure><p>显示所有网络接口。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>显示所有接口的 IP 地址信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add 192.168.1.100/24 dev eth0</span><br></pre></td></tr></table></figure><p>为接口 <code>eth0</code> 添加 IP 地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure><p>启用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add default via 192.168.1.1</span><br></pre></td></tr></table></figure><p>设置默认网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down</span><br></pre></td></tr></table></figure><p>禁用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 1</span><br></pre></td></tr></table></figure><p>添加路由规则，使来自 <code>192.168.1.0/24</code> 的流量使用路由表 <code>1</code>。</p><h3 id="5-NetworkManager"><a href="#5-NetworkManager" class="headerlink" title="5. NetworkManager"></a>5. <code>NetworkManager</code></h3><p><code>NetworkManager</code> 是管理网络配置的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>交互命令窗口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device status</span><br></pre></td></tr></table></figure><p>查看当前设备的连接状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure><p>列出所有已保存的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>列出可用的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi connect SSID password PASSWORD</span><br></pre></td></tr></table></figure><p>连接到指定的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add <span class="built_in">type</span> ethernet ifname eth0 con-name my-eth0</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>my-eth0</code> 的以太网连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con modify my-eth0 ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1</span><br></pre></td></tr></table></figure><p>修改连接 <code>my-eth0</code> 的 IP 地址和网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con up my-eth0</span><br></pre></td></tr></table></figure><p>启用连接 <code>my-eth0</code>。</p><h3 id="6-firewalld"><a href="#6-firewalld" class="headerlink" title="6. firewalld"></a>6. <code>firewalld</code></h3><p><code>firewalld</code> 提供动态的防火墙管理工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p>启动 <code>firewalld</code> 服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><p>查看当前活动的区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>列出当前区域的所有规则。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久打开端口 <code>80</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>重新加载防火墙配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br></pre></td></tr></table></figure><p>将 <code>http</code> 服务添加到 <code>public</code> 区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久关闭端口 <code>80</code>。</p><h3 id="7-iptables"><a href="#7-iptables" class="headerlink" title="7. iptables"></a>7. <code>iptables</code></h3><p><code>iptables</code> 是 Linux 内核中的包过滤工具。</p><h4 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/1343683-20190523094912972-1910501182.png" alt="img"></p><p>iptables 是 Linux 系统中用于配置网络地址转换（NAT）、包过滤和包修改规则的工具。iptables 使用四个表和五个链来处理数据包。以下是对四个表和五个链的详细解释：</p><h5 id="四个表（Tables）"><a href="#四个表（Tables）" class="headerlink" title="四个表（Tables）"></a>四个表（Tables）</h5><ol><li><p><strong>filter 表</strong>：</p><ul><li><strong>用途</strong>：这是默认的表，用于网络包过滤。</li><li><strong>链</strong>：包含 INPUT、FORWARD 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有进入本地网络接口的流量</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许所有从本地网络接口发出的流量</span></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝所有从外部到达本机的流量</span></span><br><span class="line">iptables -A INPUT -i eth0 -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>nat 表</strong>：</p><ul><li><strong>用途</strong>：用于网络地址转换（NAT），比如源 NAT（SNAT）和目标 NAT（DNAT）。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将外部访问的80端口重定向到内部服务器的8080端口</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将发往外部的流量的源IP地址更改为指定的IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mangle 表</strong>：</p><ul><li><strong>用途</strong>：用于修改 IP 包头信息，如 TOS、TTL 等。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT、INPUT、FORWARD 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改流经本机的包的TTL值</span></span><br><span class="line">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 128</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>raw 表</strong>：</p><ul><li><strong>用途</strong>：用于在连接跟踪（conntrack）机制之前对数据包进行处理。</li><li><strong>链</strong>：包含 PREROUTING 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标记流经本机的包，以不进行连接跟踪</span></span><br><span class="line">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="五个链（Chains）"><a href="#五个链（Chains）" class="headerlink" title="五个链（Chains）"></a>五个链（Chains）</h5><ol><li><p><strong>INPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理入站流量，即目标为本机的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拒绝所有到达本机的入站流量</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>FORWARD 链</strong>：</p><ul><li><strong>用途</strong>：处理转发流量，即通过本机路由的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有通过本机的转发流量</span></span><br><span class="line">iptables -A FORWARD -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>OUTPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理出站流量，即从本机发出的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有从本机发出的出站流量</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>PREROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之前处理入站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之前修改入站包的目的IP地址</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>POSTROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之后处理出站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之后修改出站包的源IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure><p>列出所有当前规则。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有进入的 TCP 连接通过端口 <code>80</code>。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p icmp -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有 ICMP 出站流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>保存当前规则到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-restore &lt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>从文件恢复规则。</p><h3 id="8-nftables"><a href="#8-nftables" class="headerlink" title="8. nftables"></a>8. <code>nftables</code></h3><p>NFTables 是一个用于包过滤、网络地址转换 (NAT) 和流量控制的框架。它替代了 iptables、ip6tables、arptables 和 ebtables。NFTables 的配置文件通常使用简单的脚本语言来定义规则。以下是 NFTables 的表、链和规则的基本结构和语法。</p><h4 id="一、基础结构"><a href="#一、基础结构" class="headerlink" title="一、基础结构"></a>一、基础结构</h4><ol><li><p><strong>表（table）</strong></p><ul><li>表是规则集的容器。每张表可以包含多个链。</li></ul></li><li><p><strong>链（chain）</strong></p><ul><li>链是规则的有序列表。链可以是内置的（如 <code>input</code>、<code>output</code>、<code>forward</code>）或用户定义的。</li></ul></li><li><p><strong>规则（rule）</strong></p><ul><li>规则定义了特定条件下应执行的动作。</li></ul></li></ol><h4 id="二、表、链和规则的语法"><a href="#二、表、链和规则的语法" class="headerlink" title="二、表、链和规则的语法"></a>二、表、链和规则的语法</h4><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;family&gt;</code>: 地址族，常见的有 <code>ip</code>（IPv4）、<code>ip6</code>（IPv6）、<code>inet</code>（支持 IPv4 和 IPv6）、<code>arp</code>（ARP）、<code>bridge</code>（网桥）。</li><li><code>&lt;table_name&gt;</code>: 表的名称。</li></ul></li><li><p><strong>删除表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出现有表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list tables</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &#123; type &lt;type&gt; hook &lt;hook&gt; priority &lt;priority&gt;; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;type&gt;</code>: 链的类型，可以是 <code>filter</code>、<code>nat</code> 等。</li><li><code>&lt;hook&gt;</code>: 钩子点，可以是 <code>input</code>、<code>output</code>、<code>forward</code>、<code>prerouting</code>、<code>postrouting</code> 等。</li><li><code>&lt;priority&gt;</code>: 优先级。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; type filter hook input priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &lt;expression&gt; &lt;action&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;expression&gt;</code>: 匹配条件，例如 <code>ip saddr 192.168.1.1</code>。</li><li><code>&lt;action&gt;</code>: 动作，例如 <code>accept</code>、<code>drop</code>、<code>reject</code>、<code>log</code> 等。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure></li><li><p><strong>删除规则</strong><br> 可以通过规则句柄删除：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; handle &lt;handle_number&gt;</span><br></pre></td></tr></table></figure><p> 首先列出链中的规则以找到句柄：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h4><p>假设我们要创建一个简单的防火墙配置，允许入站 SSH 连接并拒绝所有其他入站流量。</p><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table ip filter</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip filter input &#123; type filter hook input priority 0\; &#125;</span><br><span class="line">nft add chain ip filter forward &#123; type filter hook forward priority 0\; &#125;</span><br><span class="line">nft add chain ip filter output &#123; type filter hook output priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip protocol tcp tcp dport 22 accept</span><br><span class="line">nft add rule ip filter input drop</span><br></pre></td></tr></table></figure></li><li><p><strong>查看配置</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><p>这样，我们就配置了一个简单的防火墙，允许入站 SSH 连接并拒绝所有其他入站流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>列出当前规则集。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>添加规则，允许通过端口 <code>80</code> 的 TCP 连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft delete rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add table ip mytable</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>mytable</code> 的表。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; <span class="built_in">type</span> filter hook input priority 0 \; &#125;</span><br></pre></td></tr></table></figure><p>在 <code>mytable</code> 表中添加一个名为 <code>mychain</code> 的链。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain counter</span><br></pre></td></tr></table></figure><p>在 <code>mychain</code> 链中添加一个计数规则。</p><h3 id="9-curl"><a href="#9-curl" class="headerlink" title="9. curl"></a>9. <code>curl</code></h3><p><code>curl</code> 是用于传输数据的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I http://example.com</span><br></pre></td></tr></table></figure><p>获取 HTTP 响应头信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/api</span><br></pre></td></tr></table></figure><p>发送 POST 请求。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password http://example.com</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://example.com</span><br></pre></td></tr></table></figure><p>忽略 SSL 证书错误。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://example.com</span><br></pre></td></tr></table></figure><p>跟随重定向。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -C - -O http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><h3 id="10-wget"><a href="#10-wget" class="headerlink" title="10. wget"></a>10. <code>wget</code></h3><p><code>wget</code> 是另一个下载文件的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q http://example.com/file</span><br></pre></td></tr></table></figure><p>静默模式下载文件，不输出任何信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./local http://example.com</span><br></pre></td></tr></table></figure><p>递归下载整个网站，并将文件保存到 <code>./local</code> 目录中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=100k http://example.com/file</span><br></pre></td></tr></table></figure><p>限制下载速度为 <code>100kB/s</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --user=username --password=password http://example.com/file</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><h3 id="11-iptop"><a href="#11-iptop" class="headerlink" title="11. iptop"></a>11. <code>iptop</code></h3><p><code>iptop</code> 是一个实时显示网络流量的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop</span><br></pre></td></tr></table></figure><p>启动 <code>iptop</code>，显示实时网络流量。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -i eth0</span><br></pre></td></tr></table></figure><p>显示特定接口 <code>eth0</code> 的网络流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f src net 192.168.1.0/24</span><br></pre></td></tr></table></figure><p>显示来自特定子网 <code>192.168.1.0/24</code> 的流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f dst port 80</span><br></pre></td></tr></table></figure><p>显示发送到端口 <code>80</code> 的流量。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Linux磁盘</title>
      <link href="/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/"/>
      <url>/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="磁盘方面"><a href="#磁盘方面" class="headerlink" title="磁盘方面"></a>磁盘方面</h3><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><h5 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h5><p>在linux系统中，磁盘分区是一种物理硬盘分割成多个逻辑部分的方法，每个分区可以独立地进行管理和使用通常会分为</p><ul><li>主分区：每个磁盘最多可以有四个主分区。需要更多地分区可以使用扩展分区。</li><li>扩展分区： 扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li><li>逻辑分区： 位于扩展分区内地分区，可以超过四个限制。</li></ul><h5 id="分区职责"><a href="#分区职责" class="headerlink" title="分区职责"></a>分区职责</h5><ul><li>主分区：用于安装操作系统，存储数据，以及引导系统</li><li>扩展分区：是用于包含逻辑分区的一个容器，解决主分区的限制，创建多个逻辑分区</li><li>逻辑分区：可以用来存储操作系统，应用程序和数据。</li></ul><h5 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h5><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，包含系统中所有文件和目录的起点。</td></tr><tr><td><code>/bin</code></td><td>基本命令的二进制文件，如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等。</td></tr><tr><td><code>/boot</code></td><td>存放启动加载器相关的文件和内核文件。</td></tr><tr><td><code>/dev</code></td><td>设备文件目录，包含所有设备的接口文件（如硬盘、终端）。</td></tr><tr><td><code>/etc</code></td><td>配置文件目录，包含系统和应用程序的所有配置文件。</td></tr><tr><td><code>/home</code></td><td>用户家目录，每个用户都有一个单独的子目录，用于存放个人文件和配置。</td></tr><tr><td><code>/lib</code></td><td>系统库文件目录，包含基本系统库和内核模块。</td></tr><tr><td><code>/media</code></td><td>自动挂载的可移动媒体设备（如CD-ROM、USB驱动器）。</td></tr><tr><td><code>/mnt</code></td><td>临时挂载文件系统的挂载点。</td></tr><tr><td><code>/opt</code></td><td>可选软件包目录，用于安装附加的第三方应用程序。</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，提供系统和进程信息。</td></tr><tr><td><code>/root</code></td><td>超级用户（root）家目录。</td></tr><tr><td><code>/run</code></td><td>运行时数据，存放系统启动后产生的临时文件（如进程ID文件）。</td></tr><tr><td><code>/sbin</code></td><td>系统管理员命令的二进制文件，如 <code>fdisk</code>、<code>ifconfig</code> 等。</td></tr><tr><td><code>/srv</code></td><td>服务数据目录，存放特定服务的数据（如Web服务器文件）。</td></tr><tr><td><code>/sys</code></td><td>虚拟文件系统，提供内核设备和驱动程序信息。</td></tr><tr><td><code>/tmp</code></td><td>临时文件目录，存放临时文件，系统重启后可能会清空。</td></tr><tr><td><code>/usr</code></td><td>用户程序目录，包含二进制文件、库文件、文档等（如 <code>/usr/bin</code>、<code>/usr/lib</code>）。</td></tr><tr><td><code>/var</code></td><td>可变数据文件目录，存放日志文件、邮件、临时文件等（如 <code>/var/log</code>、<code>/var/mail</code>）。</td></tr></tbody></table><h4 id="MBR-Master-Boot-Record"><a href="#MBR-Master-Boot-Record" class="headerlink" title="MBR (Master Boot Record)"></a>MBR (Master Boot Record)</h4><ul><li>MBR是一种传统的磁盘分区表格式，它位于磁盘的第一个扇区。</li><li>MBR分区表最多支持4个主分区，如果需要更多分区，必须将其中一个主分区转换为扩展分区，再在扩展分区内创建逻辑分区。</li><li>由于使用32位地址，MBR最多支持2TB的磁盘。</li></ul><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>主引导记录 (Master Boot Record)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0）。</li><li>大小为512字节。</li></ul></li><li><p><strong>主引导代码 (Boot Code)</strong></p><ul><li>前446字节存储主引导代码，用于启动操作系统。</li></ul></li><li><p><strong>分区表 (Partition Table)</strong></p><ul><li>紧随其后64字节（每个分区条目16字节，共4个条目）。</li><li>描述最多四个主分区或一个扩展分区的起始位置和大小。</li></ul></li><li><p><strong>签名 (Signature)</strong></p><ul><li>最后2字节为磁盘签名（0x55AA），标志主引导记录的结束。</li></ul></li><li><p><strong>扩展分区</strong></p><ul><li>如果需要超过四个分区，可以创建一个扩展分区（Extended Partition）。</li><li>扩展分区包含一个扩展引导记录 (EBR)，每个逻辑分区包含一个EBR。</li></ul></li></ol><h4 id="GPT-GUID-Partition-Table"><a href="#GPT-GUID-Partition-Table" class="headerlink" title="GPT (GUID Partition Table)"></a>GPT (GUID Partition Table)</h4><ul><li>GPT是一种现代的磁盘分区表格式，取代了传统的MBR。</li><li>GPT使用64位地址，可以支持超过8ZB的磁盘容量。</li><li>GPT最多可以支持128个主分区，没有扩展分区的限制。</li><li>GPT分区表有冗余备份和CRC校验，提高了数据的安全性和可靠性。</li></ul><h5 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>保护性MBR (Protective MBR)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0），防止旧版工具误读GPT磁盘。</li></ul></li><li><p><strong>主GPT头 (Primary GPT Header)</strong></p><ul><li>位于LBA 1，描述GPT分区表的总体信息。</li><li>包含GPT版本、头部大小、CRC32校验和等。</li></ul></li><li><p><strong>主分区表 (Primary Partition Table)</strong></p><ul><li>紧随其后，从LBA 2开始，一般占用32个扇区。</li><li>每个分区条目128字节，通常最多支持128个分区条目。</li></ul></li><li><p><strong>分区条目 (Partition Entries)</strong></p><ul><li>每个条目描述一个分区的GUID、类型GUID、起始LBA、结束LBA、属性标志等。</li></ul></li><li><p><strong>用户分区</strong></p><ul><li>从主分区表结束位置开始，存储实际的数据和文件系统。</li></ul></li><li><p><strong>备份分区表 (Backup Partition Table)</strong></p><ul><li>位于磁盘末尾，用于恢复主GPT头和分区表。</li></ul></li><li><p><strong>备份GPT头 (Backup GPT Header)</strong></p><ul><li>位于磁盘倒数第二个扇区，记录备份分区表的信息。</li></ul></li></ol><h4 id="Legacy-BIOS-引导"><a href="#Legacy-BIOS-引导" class="headerlink" title="Legacy / BIOS 引导"></a>Legacy / BIOS 引导</h4><p>Legacy/BIOS（Basic Input/Output System）引导是一种传统的计算机启动模式。它是PC兼容系统的早期固件接口，负责初始化硬件并引导操作系统。以下是详细的说明：</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><p><strong>电源自检（POST）</strong>:</p><ul><li>计算机启动时，BIOS首先进行电源自检（Power-On Self-Test），检查和初始化系统硬件，如内存、CPU、硬盘和外设。</li><li>如果POST过程中检测到错误，BIOS会通过蜂鸣声或屏幕错误信息提示用户。</li></ul></li><li><p><strong>查找引导设备</strong>:</p><ul><li>POST完成后，BIOS会根据预设的引导顺序查找可启动设备（如硬盘、光盘、U盘等）。</li><li>引导顺序通常可以在BIOS设置界面中配置。</li></ul></li><li><p><strong>加载引导扇区</strong>:</p><ul><li>一旦找到一个可引导的设备，BIOS会读取该设备的主引导记录（MBR，Master Boot Record），这通常是设备的第一个扇区（512字节）。</li><li>MBR包含了启动加载程序的初始部分以及分区表信息。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>BIOS将控制权交给MBR中的引导加载程序。这个程序进一步加载操作系统或更多的引导代码（例如，GRUB、LILO等引导加载程序）。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序最终加载操作系统内核，并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="特点和限制"><a href="#特点和限制" class="headerlink" title="特点和限制"></a>特点和限制</h5><ul><li><strong>地址空间限制</strong>: BIOS模式只能使用传统的32位地址模式，无法利用超过4GB的内存空间。</li><li><strong>MBR分区限制</strong>: MBR分区表限制最大支持4个主分区，每个分区最大只能是2TB。</li><li><strong>兼容性</strong>: 由于其长期存在，BIOS模式具有广泛的硬件和软件兼容性。</li></ul><h5 id="设置和配置"><a href="#设置和配置" class="headerlink" title="设置和配置"></a>设置和配置</h5><ul><li><strong>进入BIOS设置</strong>: 通常通过在启动时按下特定的键（如F2、Del、Esc）进入BIOS设置界面。</li><li><strong>配置引导顺序</strong>: 在BIOS设置界面中，用户可以配置引导设备的优先级。</li><li><strong>启用/禁用设备</strong>: 可以在BIOS中启用或禁用某些硬件设备，以优化系统性能或解决兼容性问题。</li></ul><h4 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h4><p>UEFI（统一可扩展固件接口）是一种现代固件接口，用于替代传统的BIOS。它提供更强大的功能和更灵活的引导方式。以下是详细的UEFI启动流程和相关设置的教学：</p><h5 id="UEFI-启动流程"><a href="#UEFI-启动流程" class="headerlink" title="UEFI 启动流程"></a>UEFI 启动流程</h5><ol><li><p><strong>电源开启和硬件初始化</strong>:</p><ul><li>计算机启动时，UEFI固件首先进行硬件初始化和电源自检（POST，Power-On Self-Test）。</li><li>检查CPU、内存、存储设备和外设，确保它们工作正常。</li></ul></li><li><p><strong>进入UEFI固件界面</strong>:</p><ul><li>在启动过程中，用户可以按特定的键（如F2、Del、Esc）进入UEFI固件设置界面。</li></ul></li><li><p><strong>查找EFI系统分区（ESP）</strong>:</p><ul><li>UEFI固件会查找包含EFI系统分区（ESP）的存储设备。ESP是一个特殊的分区，用于存储EFI引导加载程序和相关文件。</li><li>ESP通常格式化为FAT32文件系统，并且标记为“EFI System Partition”。</li></ul></li><li><p><strong>加载EFI引导加载程序</strong>:</p><ul><li>在ESP中，UEFI固件查找引导加载程序文件，通常位于 <code>\EFI\Boot\bootx64.efi</code>（对于64位系统）。</li><li>用户可以在UEFI设置中指定特定的引导加载程序路径或更改引导顺序。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>UEFI将控制权交给引导加载程序。这个程序进一步加载操作系统的引导程序或内核。</li><li>常见的引导加载程序包括Windows Boot Manager、GRUB、Clover等。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序加载操作系统内核并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="设置和配置UEFI"><a href="#设置和配置UEFI" class="headerlink" title="设置和配置UEFI"></a>设置和配置UEFI</h5><ol><li><p><strong>进入UEFI设置界面</strong>:</p><ul><li>重启计算机，在启动过程中按下特定的键（如F2、Del、Esc）进入UEFI设置界面。</li><li>不同品牌的主板可能有不同的按键，具体请参考主板或计算机手册。</li></ul></li><li><p><strong>配置引导顺序</strong>:</p><ul><li>在UEFI设置界面中，找到“Boot”或“启动”选项卡。</li><li>配置引导设备的优先级，将希望首先引导的设备设置为第一优先级。</li><li>如果需要从特定的EFI引导文件启动，可以手动指定路径。</li></ul></li><li><p><strong>启用/禁用设备</strong>:</p><ul><li>在“Advanced”或“高级”选项卡中，可以启用或禁用某些硬件设备。</li><li>例如，启用/禁用USB端口、网卡、SATA接口等。</li></ul></li><li><p><strong>安全启动（Secure Boot）</strong>:</p><ul><li>安全启动是一项UEFI功能，用于防止加载未签名或未经授权的操作系统引导程序。</li><li>在“Security”或“安全”选项卡中，可以启用或禁用安全启动。</li><li>如果需要安装非官方签名的操作系统，可能需要暂时禁用安全启动。</li></ul></li><li><p><strong>保存和退出</strong>:</p><ul><li>完成设置后，选择“Save &amp; Exit”或“保存并退出”选项。</li><li>保存设置后，系统将重新启动并应用新的设置。</li></ul></li></ol><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p><code>sar</code>（System Activity Reporter）是一个强大的工具，用于在Linux系统上收集、报告和保存系统活动信息。它可以提供有关系统性能的详细数据，包括CPU、内存、网络、磁盘I/O等多个方面。<code>sar</code>命令通常与<code>sysstat</code>软件包一起使用。下面是如何使用<code>sar</code>命令来监控磁盘活动的步骤：</p><h5 id="安装sysstat包"><a href="#安装sysstat包" class="headerlink" title="安装sysstat包"></a>安装sysstat包</h5><p>在大多数Linux发行版中，可以通过包管理器安装<code>sysstat</code>包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于基于Debian的系统（如Ubuntu）</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于基于RHEL的系统（如CentOS）</span></span><br><span class="line">sudo yum install sysstat</span><br></pre></td></tr></table></figure><h5 id="启用和配置sysstat"><a href="#启用和配置sysstat" class="headerlink" title="启用和配置sysstat"></a>启用和配置sysstat</h5><p>安装完成后，确保<code>sysstat</code>服务已启用并正在运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用sysstat服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sysstat</span><br><span class="line">sudo systemctl start sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置sysstat以启用数据收集</span></span><br><span class="line">sudo nano /etc/default/sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ENABLED=&quot;false&quot;修改为ENABLED=&quot;true&quot;</span></span><br><span class="line">ENABLED=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存并退出编辑器</span></span><br></pre></td></tr></table></figure><h5 id="使用sar监控磁盘I-O"><a href="#使用sar监控磁盘I-O" class="headerlink" title="使用sar监控磁盘I/O"></a>使用sar监控磁盘I/O</h5><p><code>sar</code>可以通过<code>-d</code>选项来监控磁盘I/O活动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实时监控磁盘I/O，每1秒报告一次，共报告10次</span></span><br><span class="line">sar -d 1 10</span><br></pre></td></tr></table></figure><h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><ul><li><code>-d</code>：报告磁盘I/O统计信息。</li><li><code>-p</code>：将设备名称从设备编号翻译为设备名称。</li><li><code>-r</code>：报告内存和交换空间使用情况。</li><li><code>-n</code>：报告网络统计信息（如<code>-n DEV</code>报告网络接口统计信息）。</li><li><code>-u</code>：报告CPU使用情况。</li></ul><h5 id="查看历史数据"><a href="#查看历史数据" class="headerlink" title="查看历史数据"></a>查看历史数据</h5><p><code>sar</code>命令可以查看过去的系统性能数据，这些数据通常保存在<code>/var/log/sa/</code>目录中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定日期的磁盘I/O活动（例如2024年7月5日）</span></span><br><span class="line">sar -d -f /var/log/sa/sa05</span><br></pre></td></tr></table></figure><h5 id="示例输出解读"><a href="#示例输出解读" class="headerlink" title="示例输出解读"></a>示例输出解读</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709151241420.png" alt="image-20240709151241420"></p><p>以下是<code>sar -d</code>命令的示例输出及其含义：</p><ul><li><code>tps</code>：每秒传输数（读+写）。</li><li><code>rd_sec/s</code>：每秒读取的扇区数。</li><li><code>wr_sec/s</code>：每秒写入的扇区数。</li><li><code>avgrq-sz</code>：平均请求大小（扇区）。</li><li><code>avgqu-sz</code>：平均请求队列长度。</li><li><code>await</code>：每个I/O操作的平均等待时间（毫秒）。</li><li><code>svctm</code>：每个I/O操作的平均服务时间（毫秒）。</li><li><code>%util</code>：设备的I/O使用百分比。</li></ul><p>使用<code>sar</code>工具可以帮助系统管理员深入了解系统性能瓶颈并进行相应的优化。</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID（Redundant Array of Independent Disks，即独立磁盘冗余阵列）是一种将多个物理硬盘驱动器组合成一个逻辑单元的存储技术。其主要目的是提高数据存储的性能、容量和可靠性。RAID技术通过不同的配置（称为RAID级别）来实现这些目标。以下是几种常见的RAID级别：</p><ol><li><p><strong>RAID 0</strong>：</p><ul><li><strong>条带化（Striping）</strong>：数据在多个磁盘上分割并并行写入。</li><li><strong>优点</strong>：提高读写速度。</li><li><strong>缺点</strong>：没有冗余，任何一个磁盘故障都会导致数据丢失。</li></ul></li><li><p><strong>RAID 1</strong>：</p><ul><li><strong>镜像（Mirroring）</strong>：每个数据块都在两个或多个磁盘上复制。</li><li><strong>优点</strong>：提供高冗余，数据安全性高。</li><li><strong>缺点</strong>：磁盘利用率低（50%），只使用了一半的存储容量。</li></ul></li><li><p><strong>RAID 5</strong>：</p><ul><li><strong>分布式奇偶校验（Distributed Parity）</strong>：数据和奇偶校验信息分布在所有磁盘上。</li><li><strong>优点</strong>：平衡了性能、容量和数据安全性，至少需要3个磁盘。</li><li><strong>缺点</strong>：写操作较慢，因为需要计算和写入奇偶校验数据。</li></ul></li><li><p><strong>RAID 6</strong>：</p><ul><li><strong>双奇偶校验（Double Parity）</strong>：类似RAID 5，但有两组奇偶校验数据，容忍两块磁盘同时故障。</li><li><strong>优点</strong>：更高的数据安全性。</li><li><strong>缺点</strong>：写操作更慢，磁盘利用率较低。</li></ul></li><li><p><strong>RAID 10（或1+0）</strong>：</p><ul><li><strong>条带化和镜像结合</strong>：先进行镜像，再进行条带化。</li><li><strong>优点</strong>：结合了RAID 0和RAID 1的优点，高性能和高冗余。</li><li><strong>缺点</strong>：需要较多的磁盘，成本较高。</li></ul></li><li><p><strong>RAID 50（或5+0）</strong>：</p><ul><li><strong>条带化和分布式奇偶校验结合</strong>：将RAID 5阵列条带化。</li><li><strong>优点</strong>：提高了性能和冗余，适合大规模存储需求。</li><li><strong>缺点</strong>：复杂度增加，需要更多磁盘。</li></ul></li></ol><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 MBR 分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>m</td><td>显示帮助菜单</td><td>显示所有可用命令的列表和简要说明。</td></tr><tr><td>p</td><td>显示当前分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>n</td><td>添加一个新分区</td><td>根据提示选择主分区或逻辑分区，并设置分区的开始和结束位置。</td></tr><tr><td>d</td><td>删除一个分区</td><td>选择要删除的分区编号。</td></tr><tr><td>l</td><td>列出已知分区类型</td><td>显示支持的所有分区类型代码和说明。</td></tr><tr><td>t</td><td>更改一个分区的系统ID</td><td>选择分区后，输入新的类型代码。</td></tr><tr><td>a</td><td>切换启动标志</td><td>设置或取消某个分区的启动标志（使其可引导）。</td></tr><tr><td>w</td><td>写入分区表并退出</td><td>将对分区所做的更改写入磁盘，并退出fdisk。</td></tr><tr><td>q</td><td>不保存更改并退出</td><td>退出fdisk而不保存对分区表的任何更改。</td></tr></tbody></table><h5 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h5><ol><li>输入<code>n</code>创建新分区。</li><li>选择分区类型（主分区<code>p</code>或逻辑分区<code>e</code>）。</li><li>指定分区号（例如<code>1</code>）。</li><li>指定分区的起始扇区和结束扇区。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h5><ol><li>输入<code>p</code>查看当前分区表。</li><li>输入<code>d</code>删除分区。</li><li>输入要删除的分区编号（例如<code>1</code>）。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="更改分区类型"><a href="#更改分区类型" class="headerlink" title="更改分区类型"></a>更改分区类型</h5><ol><li>输入<code>t</code>更改分区类型。</li><li>输入分区编号（例如<code>1</code>）。</li><li>输入新的类型代码（例如<code>83</code>用于Linux分区）。</li><li>输入<code>w</code>保存并退出。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709125834777.png" alt="image-20240709125834777"></p><h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 GPT分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>mklabel</td><td>创建新的磁盘标签（分区表）</td><td>格式：<code>mklabel &lt;label&gt;</code>，其中<code>label</code>可以是<code>gpt</code>、<code>msdos</code>等。</td></tr><tr><td>mkpart</td><td>创建新分区</td><td>格式：<code>mkpart &lt;part-type&gt; &lt;fs-type&gt; &lt;start&gt; &lt;end&gt;</code>，例如<code>mkpart primary ext4 1MiB 500MiB</code>。</td></tr><tr><td>rm</td><td>删除分区</td><td>格式：<code>rm &lt;number&gt;</code>，其中<code>number</code>是分区编号。</td></tr><tr><td>print</td><td>显示分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>name</td><td>给分区命名</td><td>格式：<code>name &lt;number&gt; &lt;name&gt;</code>，给指定编号的分区命名。</td></tr><tr><td>set</td><td>设置分区标志</td><td>格式：`set <number> <flag> &lt;on</td></tr><tr><td>resizepart</td><td>调整分区大小</td><td>格式：<code>resizepart &lt;number&gt; &lt;end&gt;</code>，将分区调整到新的结束位置。</td></tr><tr><td>move</td><td>移动分区</td><td>格式：<code>move &lt;number&gt; &lt;start&gt; &lt;end&gt;</code>，移动分区到新的位置。</td></tr><tr><td>mkfs</td><td>创建文件系统</td><td>格式：<code>mkfs &lt;number&gt; &lt;fs-type&gt;</code>，例如<code>mkfs 1 ext4</code>。</td></tr><tr><td>align-check</td><td>检查分区对齐</td><td>格式：<code>align-check &lt;opt&gt; &lt;number&gt;</code>，例如<code>align-check optimal 1</code>。</td></tr><tr><td>rescue</td><td>尝试恢复丢失的分区</td><td>格式：<code>rescue &lt;start&gt; &lt;end&gt;</code>，尝试在指定范围内恢复分区。</td></tr><tr><td>quit</td><td>退出parted</td><td>退出parted交互模式。</td></tr><tr><td>unit</td><td>设置显示单位</td><td>格式：<code>unit &lt;unit&gt;</code>，其中<code>unit</code>可以是<code>s</code>(扇区)、<code>MB</code>、<code>GB</code>等。</td></tr></tbody></table><h5 id="启动parted"><a href="#启动parted" class="headerlink" title="启动parted"></a>启动parted</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo parted /dev/sdb</span><br></pre></td></tr></table></figure><h5 id="创建新的分区表（GPT）"><a href="#创建新的分区表（GPT）" class="headerlink" title="创建新的分区表（GPT）"></a>创建新的分区表（GPT）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br></pre></td></tr></table></figure><h5 id="创建新分区-1"><a href="#创建新分区-1" class="headerlink" title="创建新分区"></a>创建新分区</h5><p>创建一个从1MiB开始，500MiB结束的主分区，文件系统类型为ext4：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br></pre></td></tr></table></figure><h5 id="删除分区-1"><a href="#删除分区-1" class="headerlink" title="删除分区"></a>删除分区</h5><p>删除刚才创建的第一个分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">rm</span> 1</span><br></pre></td></tr></table></figure><h5 id="调整分区大小"><a href="#调整分区大小" class="headerlink" title="调整分区大小"></a>调整分区大小</h5><p>假设重新创建了一个分区，现在调整其大小到1000MiB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br><span class="line">(parted) resizepart 1 1000MiB</span><br></pre></td></tr></table></figure><h5 id="设置分区标志"><a href="#设置分区标志" class="headerlink" title="设置分区标志"></a>设置分区标志</h5><p>设置第一个分区的启动标志：</p><p>可设置的标识有：</p><p><code>boot</code>：引导分区</p><p><code>esp</code>：EFI系统分区（通常用于UEFI引导）</p><p><code>lvm</code>：逻辑卷管理</p><p><code>raid</code>：RAID分区</p><p><code>swap</code>：交换分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">set</span> &lt;分区编号&gt; &lt;标识&gt; on</span><br></pre></td></tr></table></figure><h5 id="显示分区表"><a href="#显示分区表" class="headerlink" title="显示分区表"></a>显示分区表</h5><p>显示当前的分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h5 id="给分区命名"><a href="#给分区命名" class="headerlink" title="给分区命名"></a>给分区命名</h5><p>给第一个分区命名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) name 1 my_partition</span><br></pre></td></tr></table></figure><h5 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h5><p>在第一个分区上创建ext4文件系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkfs 1 ext4</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><ol><li><p><strong>ext4</strong>：</p><ul><li>目前最广泛使用的Linux文件系统，ext4具有良好的性能、稳定性和兼容性，支持大文件和大容量存储，适用于大多数应用场景。</li></ul></li><li><p><strong>XFS</strong>：</p><ul><li>XFS是一个高性能的日志文件系统，擅长处理大文件和高并发环境，常用于需要高性能和可扩展性的服务器和存储系统。</li></ul></li><li><p><strong>Btrfs</strong>：</p><ul><li>Btrfs（B-tree FS）支持快照、压缩、多设备存储池、在线文件系统检查和修复等高级功能，适用于需要高级数据管理和灵活性的环境。</li></ul></li><li><p>**ZFS on Linux (ZoL)**：</p><ul><li>ZFS具有高度的数据完整性、快照和复制等高级特性，适用于高存储要求的环境，如服务器和大型存储系统。</li></ul></li></ol><h5 id="检查分区对齐"><a href="#检查分区对齐" class="headerlink" title="检查分区对齐"></a>检查分区对齐</h5><p>检查第一个分区的对齐情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) align-check optimal 1</span><br></pre></td></tr></table></figure><h5 id="尝试恢复丢失的分区"><a href="#尝试恢复丢失的分区" class="headerlink" title="尝试恢复丢失的分区"></a>尝试恢复丢失的分区</h5><p>假设分区丢失，尝试在指定范围内恢复分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) rescue 1MiB 1000MiB</span><br></pre></td></tr></table></figure><h5 id="退出parted"><a href="#退出parted" class="headerlink" title="退出parted"></a>退出parted</h5><p>退出parted：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) quit</span><br></pre></td></tr></table></figure><h5 id="验证操作"><a href="#验证操作" class="headerlink" title="验证操作"></a>验证操作</h5><p>为了验证这些操作，可以使用<code>lsblk</code>或<code>fdisk -l</code>来查看分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsblk</span><br><span class="line">sudo fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure><p>系统中没有parted工具，可以通过以下命令安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install parted  <span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo yum install parted      <span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo dnf install parted      <span class="comment"># Fedora</span></span><br></pre></td></tr></table></figure><h4 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h4><p>LVM 是一种逻辑卷管理器，允许对硬盘和其他存储设备进行灵活的分区管理。</p><p>ps: 逻辑卷是由LVM创建和管理的虚拟存储单元，可以跨越多个物理磁盘或分区。逻辑卷是建立在物理卷之上，物理卷可以是整个磁盘分区或RAID设备。</p><h5 id="为什么要用到LVM"><a href="#为什么要用到LVM" class="headerlink" title="为什么要用到LVM"></a>为什么要用到LVM</h5><p>有工具就是因为有需求，传统的分区因为固定分区大小，需要停机调整分区，影响服务可用。所以需要用到LVM，在线扩展逻辑卷的大小无需停机，只需要添加新的物理硬盘到卷组（VG）中，然后扩展逻辑卷（LV）大小。除此之外，还能够快速创建备份，不需要传统的长时间锁定数据库，还能够整合多个磁盘设备成为一个存储池，能够在数据迁移阶段，避免长时间停机。</p><h5 id="怎么查看逻辑卷"><a href="#怎么查看逻辑卷" class="headerlink" title="怎么查看逻辑卷"></a>怎么查看逻辑卷</h5><h6 id="了解大概的可用块设备"><a href="#了解大概的可用块设备" class="headerlink" title="了解大概的可用块设备"></a>了解大概的可用块设备</h6><p>这张图片显示了<code>lsblk</code>命令的输出，列出了系统中的所有块设备及其挂载点。以下是对这张图片的详细描述：</p><ol><li><p><strong>loop设备</strong>：</p><ul><li><strong>loop0</strong>: 111.9M, 类型为loop，挂载在<code>/snap/lxd/24322</code></li><li><strong>loop1</strong>: 87M, 类型为loop，挂载在<code>/snap/lxd/28373</code></li><li><strong>loop2</strong>: 53.3M, 类型为loop，挂载在<code>/snap/snapd/19457</code></li><li><strong>loop3</strong>: 38.8M, 类型为loop，挂载在<code>/snap/core20/1974</code></li><li><strong>loop4</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2318</code></li><li><strong>loop5</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2456</code></li></ul></li><li><p><strong>物理磁盘</strong>：</p><ul><li><p>sda</p><p>: 25G, 类型为disk</p><ul><li><strong>sda1</strong>: 1M, 类型为part，没有挂载点（这可能是BIOS引导分区或其他用途的特殊分区）</li><li><strong>sda2</strong>: 2G, 类型为part，挂载在<code>/boot</code></li><li><strong>sda3</strong>: 23G, 类型为part，没有挂载点（这可能是LVM物理卷）</li></ul></li></ul></li><li><p><strong>逻辑卷管理器（LVM）</strong>：</p><ul><li><strong>ubuntu–vg-ubuntu–lv</strong>: 12.5G, 类型为lvm，挂载在<code>/</code></li></ul></li><li><p><strong>光驱设备</strong>：</p><ul><li><strong>sr0</strong>: 2G, 类型为rom，没有挂载点</li></ul></li><li></li></ol><ul><li><p><strong>loop设备</strong>：这些是虚拟设备，通常用于挂载磁盘映像文件。</p></li><li><p>sda</p><p>：这是系统中的一个物理磁盘，包含三个分区（sda1, sda2, sda3）。</p><ul><li><strong>sda1</strong>：非常小，只有1M，通常用于系统引导或其他特殊用途。</li><li><strong>sda2</strong>：挂载在<code>/boot</code>，通常用于存放启动加载程序和内核。</li><li><strong>sda3</strong>：较大，为23G，可能用于LVM管理。</li></ul></li><li><p><strong>LVM逻辑卷</strong>：<code>ubuntu--vg-ubuntu--lv</code>是一个逻辑卷，挂载在根目录<code>/</code>。这表示LVM在管理这个分区的存储。</p></li><li><p><strong>光驱设备（sr0）</strong>：显示为2G，未挂载。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709110545123.png" alt="image-20240709110545123"></p><h6 id="扩展逻辑卷大概步骤"><a href="#扩展逻辑卷大概步骤" class="headerlink" title="扩展逻辑卷大概步骤"></a>扩展逻辑卷大概步骤</h6><ol><li>添加新物理硬盘</li><li>将新的物理硬盘初始化为物理卷(PV)</li><li>将PV添加到现在的卷组VG</li><li>扩展逻辑卷LV的大小</li></ol><ul><li><strong>示例</strong>: 创建一个逻辑卷</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建物理卷</span></span><br><span class="line">pvcreate /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建卷组</span></span><br><span class="line">vgcreate myvg /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建逻辑卷</span></span><br><span class="line">lvcreate -L 10G -n mylv myvg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化逻辑卷</span></span><br><span class="line">mkfs.ext4 /dev/myvg/mylv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载点</span></span><br><span class="line">mkdir /mnt/kalyantest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载载目录上（ps：一个逻辑卷只能挂载一个目录）</span></span><br><span class="line">mount /mnt/kalyantest</span><br></pre></td></tr></table></figure><h6 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h6><p>创建lvm分区以及扩容</p><ol><li>首先增加物理盘<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114035255.png" alt="image-20240709114035255"></li><li>然后查询存储块</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114244596.png" alt="image-20240709114244596"></p><ol start="3"><li>为物理盘建立分区</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114615916.png" alt="image-20240709114615916"></p><ol start="4"><li>创建PV，VG，LV</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115109564.png" alt="image-20240709115109564"></p><ol start="5"><li>格式化lv<pre><code>![image-20240709115309348](https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115309348.png)</code></pre></li><li>创建挂载目录（也可挂载在你想挂载的地方），并进行挂载(ps:记得修改etc/fstab文件，不然重启会丢失mount点)</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115612877.png" alt="image-20240709115612877"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog脚本编写</title>
      <link href="/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺好的，公司的前辈们挺有趣的，而且感觉在这里努力下去会有收获的感觉。回到正题，因为运维实习的原因，在正式上岗工作之前都会有一段培训，所以写博客的机会就变多了，因为我的博客框架原因，我每次写博客都需要处理一下页头的一些参数，而且需要用git进行仓库上传，这些重复的工作有点繁琐，所以打算写两个脚本来处理一下。</p><h2 id="页头处理"><a href="#页头处理" class="headerlink" title="页头处理"></a>页头处理</h2><p> 我的页头格式是这样的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707111114634.png" alt="image-20240707111114634"></p><h3 id="模块确定"><a href="#模块确定" class="headerlink" title="模块确定"></a>模块确定</h3><p>基本涉及到一些题目，时间，分类，标签，图片，作者之类的，有时候还会涉及到是否加密等。所以第一时间需要考虑的是，这个脚本需要能够获取时间，其次要能够快捷输入题目，标签以及分类和用的图片序号，所以需要GUI，然后还需要能够处理文件系统。故基本能够确定三个模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime  <span class="comment"># 导入datetime模块，用于处理日期和时间</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  <span class="comment"># 从pathlib导入Path，用于处理文件系统路径</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 导入tkinter，用于创建GUI应用程序</span></span><br></pre></td></tr></table></figure><h3 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h3><p>然后就可以开始写专门用来生成头部的函数，根据一些页头的结构和格式，进行编写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_markdown_header</span>(<span class="params">title, categories, tags, wallpaper_index</span>):</span><br><span class="line">    now = datetime.datetime.now()  <span class="comment"># 获取当前日期和时间</span></span><br><span class="line">    date_str = now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="comment"># 将日期和时间格式化为字符串</span></span><br><span class="line">    author = <span class="string">&quot;Kalyan&quot;</span>  <span class="comment"># 作者名称</span></span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的类别项字符串</span></span><br><span class="line">    categories_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;cat.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> cat <span class="keyword">in</span> categories.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的标签项字符串</span></span><br><span class="line">    tags_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;tag.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> tag <span class="keyword">in</span> tags.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 使用提供的信息构建完整的Markdown头部</span></span><br><span class="line">    markdown_header = <span class="string">f&quot;&quot;&quot;---</span></span><br><span class="line"><span class="string">title: <span class="subst">&#123;title&#125;</span></span></span><br><span class="line"><span class="string">date: <span class="subst">&#123;date_str&#125;</span></span></span><br><span class="line"><span class="string">categories:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;categories_str&#125;</span></span></span><br><span class="line"><span class="string">tags:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;tags_str&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">description: </span></span><br><span class="line"><span class="string">top_img: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">cover: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">copyright_author: <span class="subst">&#123;author&#125;</span></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> markdown_header  <span class="comment"># 返回构建的Markdown头部</span></span><br></pre></td></tr></table></figure><h3 id="GUI事件处理"><a href="#GUI事件处理" class="headerlink" title="GUI事件处理"></a>GUI事件处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理GUI中提交按钮点击的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_submit</span>():</span><br><span class="line">    title = title_entry.get()  <span class="comment"># 从文本输入小部件获取标题</span></span><br><span class="line">    categories = categories_entry.get()  <span class="comment"># 从文本输入小部件获取类别</span></span><br><span class="line">    tags = tags_entry.get()  <span class="comment"># 从文本输入小部件获取标签</span></span><br><span class="line">    wallpaper_index = wallpaper_entry.get()  <span class="comment"># 从文本输入小部件获取壁纸序号</span></span><br><span class="line">    header = generate_markdown_header(title, categories, tags, wallpaper_index)  <span class="comment"># 生成Markdown头部</span></span><br><span class="line">    desktop = Path.home() / <span class="string">&#x27;Desktop&#x27;</span>  <span class="comment"># 获取桌面路径</span></span><br><span class="line">    file_name = title.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.md&quot;</span>  <span class="comment"># 创建文件名</span></span><br><span class="line">    full_path = desktop / file_name  <span class="comment"># 完整的文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(full_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 打开文件进行写入</span></span><br><span class="line">        f.write(header)  <span class="comment"># 写入Markdown头部</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件已保存在桌面: <span class="subst">&#123;full_path&#125;</span>&quot;</span>)  <span class="comment"># 打印文件保存位置</span></span><br><span class="line"></span><br><span class="line">    root.destroy()  <span class="comment"># 关闭GUI</span></span><br></pre></td></tr></table></figure><h3 id="窗口UI调整"><a href="#窗口UI调整" class="headerlink" title="窗口UI调整"></a>窗口UI调整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = tk.Tk()</span><br><span class="line">root.title(<span class="string">&quot;文章信息输入&quot;</span>)  <span class="comment"># 设置窗口标题</span></span><br><span class="line">root.geometry(<span class="string">&quot;400x200&quot;</span>)  <span class="comment"># 设置窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并放置各种标签和输入框</span></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;文章标题:&quot;</span>).pack()</span><br><span class="line">title_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">title_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;分类（用逗号分隔）-&quot;</span>).pack()</span><br><span class="line">categories_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">categories_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;标签（用逗号分隔）:&quot;</span>).pack()</span><br><span class="line">tags_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">tags_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;壁纸序号:&quot;</span>).pack()</span><br><span class="line">wallpaper_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">wallpaper_entry.pack()</span><br><span class="line"></span><br><span class="line">submit_button = tk.Button(root, text=<span class="string">&quot;提交&quot;</span>, command=on_submit)  <span class="comment"># 创建提交按钮</span></span><br><span class="line">submit_button.pack()</span><br><span class="line"></span><br><span class="line">root.mainloop()  <span class="comment"># 启动GUI事件循环</span></span><br></pre></td></tr></table></figure><p>以上搞定，然后就是打包创建可执行文件就好了。感觉还不错。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112220421.png" alt="image-20240707112220421"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112235909.png" alt="image-20240707112235909"></p><h2 id="上传处理"><a href="#上传处理" class="headerlink" title="上传处理"></a>上传处理</h2><p>这次并用不上写python脚本，只需要用批处理就好了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112640400.png" alt="image-20240707112640400"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware vSphere</title>
      <link href="/2024/07/07/VMware%20vSphere/"/>
      <url>/2024/07/07/VMware%20vSphere/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是vmware官方开发的一套虚拟化平台</p><h2 id="能够干什么"><a href="#能够干什么" class="headerlink" title="能够干什么"></a>能够干什么</h2><ol><li>虚拟化：将物理服务器的资源分配给多个VM，提高硬件资源利用率，减少硬件成本。</li><li>集中管理：统一管理监控整个虚拟化环境，包括虚拟机，主机，网络和存储</li><li>高可用提供：能够自动重启故障的物理服务器，保持业务连续。</li><li>资源优化：提供分布式资源调度DRS功能，动态调整VM资源，性能和负载</li><li>安全：能够网络隔离，访问控制，数据加密</li><li>数据保护：提供快照和备份，支持快速恢复</li><li>自动化和编排，通过脚本和工具实现虚拟机的快速部署。</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="ESXi"><a href="#ESXi" class="headerlink" title="ESXi"></a>ESXi</h3><p>是VMware vSphere虚拟化平台的核心组件。它是一种小型的、专用的操作系统，直接安装在物理服务器上，用于运行和管理虚拟机（VM）。可以说有ESXi的OS的物理服务器就是宿主机Host。</p><h3 id="vSwitch"><a href="#vSwitch" class="headerlink" title="vSwitch"></a>vSwitch</h3><p>运行在VMware ESXi主机上的软件交换机，用于管理虚拟网络。它类似于物理交换机，但功能更灵活，能够在虚拟化环境中提供网络连接和管理。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>网络连接：提供VM之间的网络连接，以及虚拟机与外部物理网络的连接。</p></li><li><p>流量隔离和管理：通过VLAN（虚拟局域网）标签，vSwitch可以隔离和管理不同虚拟机的网络流量，提高网络安全性和性能。</p></li><li><p>网络适配器绑定：vSwitch支持将多个物理网络适配器（NIC）绑定在一起，提供冗余和负载均衡，提高网络的可用性和带宽。</p></li></ol><p>ps: NIC即网络接口卡，是计算机硬件组件，用于计算机与网络的连接。它通常以插卡形式存在，插入计算机主板的扩展槽中，也有集成在主板上的形式。</p><ol start="4"><li><p>流量整形：vSwitch能够对进出网络流量进行整形（Traffic Shaping），控制流量速率，确保网络性能的稳定性。</p></li><li><p>安全特性：vSwitch具备安全特性，如防止MAC地址欺骗和IP地址欺骗，提升虚拟网络的安全性。 </p></li></ol><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="标准虚拟交换机（vSS）"><a href="#标准虚拟交换机（vSS）" class="headerlink" title="标准虚拟交换机（vSS）"></a>标准虚拟交换机（vSS）</h5><ul><li>独立管理：每台ESXi主机上的vSS独立管理，不同主机上的vSS配置相互独立</li><li>本地主机管理：配置和管理通过ESXi主机的Host Client或vSphere Clinet进行。</li><li>手动配置：手动为每个ESXi主机上分别配置，配置工作量大。</li><li>适用小型环境：适合规模较小或独立的环境，网络配置相对简单<br>ps：缺乏跨主机的集中管理和高级网络功能。</li></ul><h5 id="分布式虚拟交换机（vDS）"><a href="#分布式虚拟交换机（vDS）" class="headerlink" title="分布式虚拟交换机（vDS）"></a>分布式虚拟交换机（vDS）</h5><ul><li>集中管理：能够跨多个ESXi主机统一配置管理</li><li>视图统一：提供网络配置视图，简化大规模环境中的网络管理。</li><li>集中配置：可以在vCenter Server中一次性配置和管理所有相关ESXi主机上的网络设备</li><li>适用于大环境：适合规模大，复杂的，网络配置需求高的。</li></ul><p>ps：拥有比较高级的功能，入Private VLAN，网络IO控制（NetIOC），分布式端口镜像（Port Mirroring）/简化迁移能够网络配置一起迁移，无需重新配置。</p><h5 id="VLAN-和Private-VALN"><a href="#VLAN-和Private-VALN" class="headerlink" title="VLAN 和Private VALN"></a>VLAN 和Private VALN</h5><ol><li>VLAN: </li></ol><ul><li>主要通过交换机端口配置，将交换机端口分到不同的VLAN中。每个VLAN都有唯一的VLAN ID</li><li>设备之间通信得在同一VLAN进行，不同VLAN之间通信需要通过三层设备（如路由器，三层交换机）</li></ul><ol start="2"><li>Private VLAN</li></ol><ul><li>进一步细分VLAN内部的子VLAN，从而提供更精细的流量隔离和控制。</li><li>避免VLAN ID的浪费，适合大规模网络环境。</li></ul><h6 id="Private实现"><a href="#Private实现" class="headerlink" title="Private实现"></a>Private实现</h6><ol><li>Private VLAN将一个VLAN划分为主VLAN（Primary VLAN）和子VLAN（Secondary VLAN）。子VLAN又分为两种类型：Isolated VLAN和Community VLAN。</li></ol><ul><li>Primary VLAN：主VLAN，包含所有的Secondary VLAN。</li><li>Isolated VLAN：隔离VLAN，主机只能与Promiscuous端口通信，不能与其他任何端口通信。</li><li>Community VLAN：社区VLAN，主机可以与同一个Community VLAN内的其他主机和Promiscuous端口通信，但不能与其他Community VLAN或Isolated VLAN内的主机通信。</li><li>Promiscuous端口：可以与所有子VLAN内的端口通信，通常用于连接网关或路由器等设备。</li></ul><h5 id="vDS和vSS的区别"><a href="#vDS和vSS的区别" class="headerlink" title="vDS和vSS的区别"></a>vDS和vSS的区别</h5><p>管理上，vSS独立管理（每个ESXi独立配置），vDS集中管理（跨多个ESXi主机统一配置）<br>功能上，vSS网络配置简单，vDS提供高级网络功能。</p><h3 id="Datastore"><a href="#Datastore" class="headerlink" title="Datastore"></a>Datastore</h3><ul><li>Datastore是一个逻辑存储单元，由ESXi主机创建和管理。</li><li>它可以基于不同类型的物理存储，如本地硬盘、NFS共享、iSCSI目标和SAN存储。</li><li>Datastore用于存储虚拟机的虚拟磁盘文件（.vmdk）、配置文件（.vmx）、ISO映像文件以及其他虚拟机相关的数据。</li></ul><h4 id="数据存储类型及其特点"><a href="#数据存储类型及其特点" class="headerlink" title="数据存储类型及其特点"></a>数据存储类型及其特点</h4><ol><li>本地</li></ol><ul><li>直接连接单个ESXi主机的存储设备，SATA，SAS，SSD硬盘</li></ul><ol start="2"><li>SAN（Storage Area Network）</li></ol><ul><li>高性能，低延迟的存储网络，通常使用光纤通道或iSCSI协议连接</li><li>提供集中管理和共享存储</li></ul><ol start="3"><li>NAS（Network Attached Storage）</li></ol><ul><li>通过标准网络协议（IFS或SMB）访问存储设备</li><li>适用于文件级存储需求</li></ul><ol start="4"><li>vSAN（Virtual SAN）</li></ol><ul><li>VM的分布式存储解决方案，集群中所有ESXi主机的本地存储集合成一个逻辑数据存储。</li><li>提供高性能，可扩展共享存储，支持高可用性。</li></ul><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><ul><li>VMFS： 块存储，如SAN和本地存储。</li><li>NFS：网络附加存储如NAS。</li><li>vSAN:分布式存储解决方案。</li></ul><h3 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h3><p>用于管理和分配计算资源（如CPU和内存）。</p><h4 id="资源池的关键特性"><a href="#资源池的关键特性" class="headerlink" title="资源池的关键特性"></a>资源池的关键特性</h4><ol><li><strong>资源分配</strong>：<ul><li><strong>预留（Reservation）</strong>：确保虚拟机或资源池可以使用的最小资源量。预留的资源保证在所有者需要时始终可用。</li><li><strong>限制（Limit）</strong>：资源池或虚拟机可以使用的最大资源量。限制防止单个实体使用过多资源，影响其他实体的性能。</li><li><strong>份额（Shares）</strong>：定义资源争用时的相对优先级。份额是一个权重，用于确定在资源紧张时各个虚拟机或资源池的优先级。</li></ul></li><li><strong>灵活的资源管理</strong>：<ul><li>动态调整资源：管理员可以在不影响虚拟机运行的情况下动态调整资源池的配置。</li><li>自动化资源分配：配合VMware的DRS（分布式资源调度），可以自动平衡资源池之间的负载。</li></ul></li><li><strong>资源池的层次结构</strong>：<ul><li><strong>根资源池（Root Resource Pool）</strong>：默认存在于每个主机或集群中，是最顶层的资源池。</li><li><strong>子资源池（Child Resource Pool）</strong>：创建在根资源池或其他资源池下，形成树状结构。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> VMware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNI</title>
      <link href="/2024/07/05/CNI/"/>
      <url>/2024/07/05/CNI/</url>
      
        <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>定义容器运行时，如何配置网络接口，以便容器可以网络通信。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ul><li>关注网络连接和网络解除连接</li><li>支持各种不同的网络配置要求</li><li>通过各种不同的网络解决方案解决网络配置。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>当一个Pod被创建时，k8s调用CNI插件来为pod配置网络，通常包括分配IP地址，设置网络路由和创建网络接口等任务。CNI插件负责把pod连接到一个预先的环境，保证pod之间的网络通信。</p><h2 id="常见的-CNI-插件："><a href="#常见的-CNI-插件：" class="headerlink" title="常见的 CNI 插件："></a>常见的 CNI 插件：</h2><ul><li><strong>Calico</strong>：提供高性能的网络和网络策略，支持跨主机的网络隔离。</li><li><strong>Flannel</strong>：简单易用，主要用于创建一个覆盖网络，允许 Pod 跨节点通信。</li><li><strong>Weave Net</strong>：提供一个强大的网络和网络策略，支持自动发现和网络隔离。</li><li><strong>Cilium</strong>：使用 BPF（Berkeley Packet Filter）来提供网络安全、策略执行和负载均衡功能。</li></ul><h3 id="1-Calico"><a href="#1-Calico" class="headerlink" title="1. Calico"></a>1. <strong>Calico</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>高性能</strong>：Calico 使用 BGP（边界网关协议）进行路由，避免了封装和解封装的开销，从而提供高性能的网络连接。</li><li><strong>网络策略</strong>：Calico 提供强大的网络策略功能，允许用户定义细粒度的访问控制规则。</li><li><strong>可扩展性</strong>：适用于大规模集群，能够处理成千上万的节点和 Pod。</li><li><strong>安全性</strong>：支持网络隔离和加密，确保数据在传输过程中安全。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>大规模生产环境</strong>：由于其高性能和可扩展性，Calico 非常适合大规模生产环境。</li><li><strong>需要严格网络策略的环境</strong>：如果需要细粒度的网络访问控制和安全策略，Calico 是一个理想的选择。</li></ul><h3 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. <strong>Flannel</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>简单易用</strong>：Flannel 设计简单，易于部署和管理。</li><li><strong>覆盖网络</strong>：主要提供覆盖网络，使用 UDP、VXLAN 或 host-gw 模式来封装跨主机的容器流量。</li><li><strong>轻量级</strong>：适合中小规模的集群，不需要复杂的配置。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>中小规模集群</strong>：由于其简单性和轻量级特性，Flannel 适用于中小规模的 Kubernetes 集群。</li><li><strong>快速部署</strong>：如果需要快速部署一个 Kubernetes 集群，Flannel 是一个不错的选择。</li></ul><h3 id="3-Weave-Net"><a href="#3-Weave-Net" class="headerlink" title="3. Weave Net"></a>3. <strong>Weave Net</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>自发现网络</strong>：Weave Net 能够自动发现和管理网络配置，简化了网络管理。</li><li><strong>网络加密</strong>：支持网络流量加密，确保数据在传输过程中的安全性。</li><li><strong>多云支持</strong>：能够跨多个云提供商和本地数据中心创建统一的网络。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>多云环境</strong>：Weave Net 非常适合需要跨多个云提供商和本地数据中心的环境。</li><li><strong>需要网络加密的环境</strong>：如果需要确保网络流量的安全性，Weave Net 是一个理想的选择。</li></ul><h3 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. <strong>Cilium</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>基于 BPF</strong>：Cilium 使用 Linux 内核的 BPF 技术来实现高性能和可扩展的网络功能。</li><li><strong>Layer 7 支持</strong>：支持 HTTP/HTTPS、gRPC 等 Layer 7 协议的负载均衡和安全策略。</li><li><strong>可见性和监控</strong>：提供丰富的网络可见性和监控功能，帮助用户了解网络流量和性能。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要高级网络功能的环境</strong>：Cilium 非常适合需要高级网络功能和安全策略的环境。</li><li><strong>微服务架构</strong>：由于其对 Layer 7 协议的支持，Cilium 非常适合微服务架构。</li></ul><h3 id="5-Canal"><a href="#5-Canal" class="headerlink" title="5. Canal"></a>5. <strong>Canal</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>结合了 Flannel 和 Calico</strong>：Canal 将 Flannel 的简单性和 Calico 的网络策略功能结合在一起。</li><li><strong>灵活性</strong>：提供了 Flannel 的覆盖网络和 Calico 的网络策略，适用于多种场景。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要简单网络和策略控制的环境</strong>：Canal 适用于需要简单网络配置和基本网络策略控制的环境。</li><li><strong>中小规模集群</strong>：由于其灵活性和简单性，Canal 适用于中小规模的 Kubernetes 集群。</li></ul><h3 id="6-Kube-Router"><a href="#6-Kube-Router" class="headerlink" title="6. Kube-Router"></a>6. <strong>Kube-Router</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>综合功能</strong>：Kube-Router 提供网络路由、网络策略和服务代理功能。</li><li><strong>高性能</strong>：使用 BGP 进行路由，提供高性能的网络连接。</li><li><strong>易于部署</strong>：集成了多个网络功能，简化了部署和管理。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要综合网络功能的环境</strong>：Kube-Router 适用于需要综合网络功能（如路由、策略和服务代理）的环境。</li><li><strong>高性能需求</strong>：由于其高性能特性，Kube-Router 适用于对网络性能有较高要求的环境。</li></ul><h3 id="7-Multus"><a href="#7-Multus" class="headerlink" title="7. Multus"></a>7. <strong>Multus</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>多网络支持</strong>：Multus 允许一个 Pod 连接到多个网络，支持多种 CNI 插件的组合使用。</li><li><strong>灵活性</strong>：提供了极大的灵活性，适用于复杂的网络需求。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>复杂网络需求</strong>：Multus 适用于需要多个网络接口和复杂网络配置的环境。</li><li><strong>多 CNI 插件组合</strong>：如果需要同时使用多个 CNI 插件，Multus 是一个理想的选择。</li></ul>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
          <category> CNI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRI容器运行时接口</title>
      <link href="/2024/07/04/CRI/"/>
      <url>/2024/07/04/CRI/</url>
      
        <content type="html"><![CDATA[<h1 id="CRI-容器运行时接口"><a href="#CRI-容器运行时接口" class="headerlink" title="CRI (容器运行时接口)"></a>CRI (容器运行时接口)</h1><p>了解CRI之前，我们先了解一下什么是RPC</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  一种常用的通信机制，运行程序调用位于远程计算机上的行数或方法，就像调用本地对象一眼。RPC抽象了底层的网络通信细节，使得开发者可以更加专注与业务逻辑的开发，不必过多担心网络相关性的复杂性。</p><h3 id="RPC工作原理"><a href="#RPC工作原理" class="headerlink" title="RPC工作原理"></a>RPC工作原理</h3><h4 id="客户端调用过程"><a href="#客户端调用过程" class="headerlink" title="客户端调用过程"></a>客户端调用过程</h4><ol><li>客户端程序调用一个本地的存根（stub）函数，这个存根代表远程函数</li><li>存根将函数调用的参数打包成一个消息，通过网络发送给服务端</li><li>客户端等待服务端响应</li></ol><h4 id="服务端处理过程"><a href="#服务端处理过程" class="headerlink" title="服务端处理过程"></a>服务端处理过程</h4><ol><li>服务器收到消息，解包得到调用参数。</li><li>服务端调用本地实际函数，执行必要的处理。</li><li>处理完毕后，服务端将结果打包并发送回客户端。<h4 id="客户端接收过程"><a href="#客户端接收过程" class="headerlink" title="客户端接收过程"></a>客户端接收过程</h4></li><li>客户端存根收到响应消息，解包得到结果</li><li>客户端的调用像本地执行一样，得到从远程服务器返回的结果。</li></ol><h3 id="RPC特点"><a href="#RPC特点" class="headerlink" title="RPC特点"></a>RPC特点</h3><ul><li>封装:隐藏网络通信细节，开发者无需直接处理socket编程或其他通信协议细节</li><li>同步:默认同步，即客户端调用一个远程方法时候，回阻塞知道得到结果，尽管如此，许多现代RPC框架支持异步调用。</li><li>透明:</li></ul><h3 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h3><ul><li><p>Finagle：一个构建高并发，分布式系统的异步RPC库，用Scala语言编写，但可以与其他JVM语言一起使用，适合用于高扩展，弹性和容错（异步编程模型，有效地处理大量并发请求，不会阻塞线程，支持多种协议，内置负载均衡）</p></li><li><p>gRPC：由Google开发，基于HTTP/2协议，支持多种语言，能够提供高性能的通信。gRPC使用Protocol Buffers作为其接口定义语言和消息序列化格式。</p></li><li><p>Apache Thrift：由Facebook开发，支持跨语言服务的开发，使用自定义的IDL (Interface Definition Language) 来定义数据类型和服务接口。</p></li><li><p>JSON-RPC和XML-RPC：这些是较轻量级的RPC实现，使用JSON和XML格式分别进行数据序列化，易于与Web技术集成。</p></li></ul><h3 id="RPC应用场景"><a href="#RPC应用场景" class="headerlink" title="RPC应用场景"></a>RPC应用场景</h3><ul><li><p>微服务架构：在微服务架构中，各个服务组件常常需要进行网络通信，RPC提供了一种高效的方式来实现服务间的调用。</p></li><li><p>分布式计算：在需要多个节点共同完成计算任务的场景中，RPC可以用来协调各个节点之间的工作。</p></li></ul><p>让我再在了解CRI之前，先清楚什么是容器的执行以及生命周期</p><h2 id="容器执行和生命周期"><a href="#容器执行和生命周期" class="headerlink" title="容器执行和生命周期"></a>容器执行和生命周期</h2><p>容器的执行和生命周期是指容器从创建到终止的整个过程，涉及到创建，启动，运行，停止和删除。</p><ul><li>创建（Pre-production/Planning）：<br>就像电影制作前的筹备阶段，需要确定剧本、演员、场地等。在 Kubernetes 中，创建容器涉及配置容器的环境，如定义容器的镜像、资源限制（CPU、内存）、网络设置等。</li><li>启动（Production/Shooting）：<br>类似于电影开始拍摄。容器的启动阶段是指实际上将容器镜像运行起来。在这个阶段，容器内部的应用开始执行其预定任务，比如启动一个 Web 服务器、数据库服务等。</li><li>运行（Release/Screening）：<br>就像电影的放映过程。容器成功启动后，它会进入运行状态。在这个阶段，容器内的应用对外提供服务，如处理网络请求、执行数据处理等。</li><li>停止（Ending）：<br>类似于电影放映结束。当容器需要更新或不再需要时，它会被停止。停止容器通常意味着停止容器内部的应用进程。</li><li>删除（Post-production/Cleanup）：<br>就像电影拍摄后的清理阶段。在容器的生命周期的最后阶段，容器会被彻底删除，包括其在节点上的所有数据。这确保了不会留下无用的资源或数据。</li></ul><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>允许用户在容器的特殊阶段进行自定义操作。</p><h4 id="PostStart"><a href="#PostStart" class="headerlink" title="PostStart"></a>PostStart</h4><p><code>PostSrart</code>是在容器创建并启动后立即执行的钩子，这个钩子的执行时间是容器入口命令开始执行之后，但是并不保证是容器的应用程序完全启动之后再再执行。</p><p>ps：若是PostStart钩子启动失败，那么容器不会被杀死或者重启，钩子启动失败的记录会写入日志中。</p><h4 id="PreStop"><a href="#PreStop" class="headerlink" title="PreStop"></a>PreStop</h4><p><code>PreStop</code>是容器被终止钱执行的钩子。当k8s需要停止容器时，首先调用PreStop钩子，然后才会执行容器的终止过程。经常用于优雅的关闭应用程序，保存状态，执行清理任务。</p><p>ps：钩子是会延迟容器的终止过程的，因为k8s会等待钩子执行完成后才会发送SIGTERM信号停止容器。</p><h2 id="CRI是什么"><a href="#CRI是什么" class="headerlink" title="CRI是什么"></a>CRI是什么</h2><p>简单理解的话可以理解成一个适配器，就是为了管理不同容器运行时进行交互的一套标准接口。主要的作用是为了解决k8s直接依赖特定容器运行时的问题。主要是启动停止容器，拉取容器镜像，查询容器状态，管理容器生命周期。</p><ol><li>统一接口是通过RPC内gRPC框架实现的。</li><li>解耦合，完成了k8s与docker直接集成的紧密耦合关系。</li><li>可以让开发者通过自我需求或喜爱来选择合适的容器进行时。</li></ol><h3 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h3><ul><li>首先是使用了能够适应高并发低延迟的通信的HTTP/2，再头部压缩和多路复用请求等高效传输机制。</li><li>gRPC支持双向流，允许服务器和客户端再长连接中实时发送和接受消息。</li></ul><p>只有了解这么多了，gRPC还有很多有用的功能，适用场景也比较广，可能日后碰上这种场景后再继续了解。</p>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
          <category> CRI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux从核心到边缘</title>
      <link href="/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux从核心到边缘"><a href="#Linux从核心到边缘" class="headerlink" title="Linux从核心到边缘"></a>Linux从核心到边缘</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>  今天有面试一家专注云原生产品的企业，有问到一个问题，就是你还有用过其他的Linux发行版吗，突然顿时觉得很惭愧，而且有一些基础的Linux问题居然发现我忘记了没有回答出来。而且仔细思考了一下，确实在大学期间仅仅只了解过Ubuntu偏向新手和私人开发的linux发行版，而且在命令上似乎只是停留在一些基础的操作（甚至有一些基础命令还忘记了），并没有深入的了解过Linux的内核。而且今天面试官说了一句话，就是从需求出发的科技探索更有利于我们进步。有的时候确实会把某些技术当作工具，但事实上确实是工具，作为一名希望在IT行业继续深耕的我，似乎越来越缺乏对技术美的欣赏，在大学没有多少生活压力的时期最应该体验这种美感的时候，却好像被一些<strong>保姆级</strong>教学一步步蒙蔽了眼睛。结果虽然出来了，但是可能对过程保留不多的记忆或者理解。只能说有时候学习的结果并不重要，重要的是一些有容错的过程。</p><h2 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h2><ul><li>内核类似一个资源的管理程序，负载资源调度到需要的系统进程，我看有些理解可以把内核理解成一个库，有了一组面向系统命令，系统调用应用程序来说，就像调用普通函数一样。其实内核也可以理解成一个桥梁，能够练习硬件和上层应用点的桥梁。一涉及到底层的东西就越来越抽象，还是能够用一些比喻理解比较好。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/3435502-20240507214431792-1257148225.png" alt="img"></li></ul><h2 id="内核的角色"><a href="#内核的角色" class="headerlink" title="内核的角色"></a>内核的角色</h2><ul><li>内核是管理计算机的硬件资源的重要角色，就比如CPU，内存，存储设备和输入输出的设别。</li><li>内核主要威威上层提供了抽象的操作接口，让我们不需要关心硬件的细节。</li><li>内核维护不同程序和用户之间的安全界限，确保学习通的稳定和安全。</li></ul><h2 id="常见的内核参数"><a href="#常见的内核参数" class="headerlink" title="常见的内核参数"></a>常见的内核参数</h2><table><thead><tr><th>参数</th><th>说明</th><th>示例值</th></tr></thead><tbody><tr><td><strong>内存管理相关参数</strong></td><td></td><td></td></tr><tr><td>vm.swappiness</td><td>控制内核将进程内存交换到交换分区的倾向</td><td>10</td></tr><tr><td>vm.dirty_ratio</td><td>系统内存中可写缓存占总内存的百分比，超过该值将触发写回磁盘</td><td>20</td></tr><tr><td>vm.overcommit_memory</td><td>控制内存分配策略，0表示启用内存过量使用检查，1表示允许过量使用，2表示严格模式</td><td>1</td></tr><tr><td>vm.min_free_kbytes</td><td>系统保持的最小空闲内存量，防止内存完全用完导致系统崩溃</td><td></td></tr><tr><td><strong>网络相关参数</strong></td><td></td><td></td></tr><tr><td>net.ipv4.ip_forward</td><td>启用或禁用IP转发</td><td>1</td></tr><tr><td>net.ipv4.conf.all.rp_filter</td><td>启用反向路径过滤，防止IP欺骗攻击</td><td></td></tr><tr><td>net.ipv4.tcp_syncookies</td><td>启用SYN cookies，防止SYN泛洪攻击</td><td>1</td></tr><tr><td>net.core.somaxconn</td><td>定义系统中每个端口最大的监听队列长度</td><td>1024</td></tr><tr><td>net.ipv4.tcp_max_syn_backlog</td><td>控制TCP协议栈中SYN请求的最大队列长度</td><td></td></tr><tr><td><strong>文件系统相关参数</strong></td><td></td><td></td></tr><tr><td>fs.file-max</td><td>系统级别的文件句柄数量限制</td><td>100000</td></tr><tr><td>fs.inotify.max_user_watches</td><td>单个用户可以创建的inotify监视数量</td><td>524288</td></tr><tr><td>fs.aio-max-nr</td><td>系统级别的异步I/O请求最大数量</td><td></td></tr><tr><td><strong>安全相关参数</strong></td><td></td><td></td></tr><tr><td>kernel.randomize_va_space</td><td>控制地址空间布局随机化（ASLR），提高系统安全性</td><td>2</td></tr><tr><td>kernel.sysrq</td><td>控制SysRq键的功能，提供低级别的系统控制和调试功能</td><td>0</td></tr><tr><td>kernel.panic</td><td>设置内核崩溃后重新启动系统的时间（秒）</td><td>10</td></tr><tr><td><strong>调度器相关参数</strong></td><td></td><td></td></tr><tr><td>kernel.sched_migration_cost_ns</td><td>定义任务迁移的代价，用于调度器的决策</td><td>500000</td></tr><tr><td>kernel.sched_min_granularity_ns</td><td>定义调度器分配时间片的最小粒度</td><td>1000000</td></tr></tbody></table><h2 id="内核的主要组成部分"><a href="#内核的主要组成部分" class="headerlink" title="内核的主要组成部分"></a>内核的主要组成部分</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程调度："><a href="#进程调度：" class="headerlink" title="进程调度："></a>进程调度：</h4><ul><li>Linux内核使用多种调度算法，决定那个进程获得CPU时间，确保各个进程公平使用CPU资源。<h4 id="进程同步："><a href="#进程同步：" class="headerlink" title="进程同步："></a>进程同步：</h4></li><li>内核提供了多种机制，处理进程或线程之间的同步，防止数据争抢，确保线程安全。</li></ul><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul><li>支持多种进程间通信IPC方法，包括信号，管道，消息队列，共享内存和套接字。</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>虚拟内存：程序使用比实际物理内存更多的地址空间，通过使用分页/分段来实现</li><li>内存分配：内核提供多级分配框架，包括页分配器，slab分配器（说实话有够抽象的。）</li><li>交换空间：当物理内存不足时，内核可以将内存页移动到磁盘上的交换控件，以来释放内存。<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3></li><li>支持ext4，XFS，Btrfs，NFS和更多，以适应不同的存储需求和性能特点。</li><li>虚拟文件系统，VFS提供一个统一接口来访问不同文件系统</li><li>文件操作，内核提供系统调用，open，read，write，close。<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3></li><li>字符设备和块设备：Linux区分字符设备，键盘鼠标和块设备硬盘驱动器。</li><li>模块化驱动：Linux支持动态加载和卸载设备驱动模块，这允许不重启系统的情况下添加或更新驱动程序。<h3 id="网络栈"><a href="#网络栈" class="headerlink" title="网络栈"></a>网络栈</h3></li><li>协议实现：内核实现了各种网络协议，IP，TCP，UDP和ICMP</li><li>网络接口：通过网络接口与各种网络硬件进行交互，如以太网卡，无限适配</li><li>网络数据处理：内核处理数据包路由，转发，过滤，支持高级网络功能，如虚拟网络，网络安全规则等。</li></ul><h2 id="linux防火墙"><a href="#linux防火墙" class="headerlink" title="linux防火墙"></a>linux防火墙</h2><ul><li>防火墙系统主要基于iptable，以及比较新的nftables系统，运行管理员配置规则，控制进出网络接口的数据包。</li></ul><ol><li>iptables是一个广泛使用防火墙工具，使用一组表来组织规则，每个表包含多个链，链中包含具体规则，主要有 filter默认表，nat网络地址转换（处理进出接口的地址和端口转换），mangle用来修改数据包的内容，raw配置免除连接跟踪机制的数据包。</li></ol><h2 id="APT包管理"><a href="#APT包管理" class="headerlink" title="APT包管理"></a>APT包管理</h2><ul><li>使用的是.deb包格式，通过apt源来管理和安装软件包。</li><li>一般是使用的linux发行版有Ubuntu，Debian，Linux Mint等</li></ul><h3 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h3><p>  一般可以通过编辑/etc/apt/sourcer.list文件或者在sources.list.d目录下面，创建一个新的源。然后通过更新apt索引的方式。deb标识这是一个二进制的源，一般都会需要导入公钥，验证软件包的真实性，APT使用的是PGP签名，如果你源头是签名的，你需要的导入并信任该公钥，通常，源提供者会提供公钥和相应的导入命令。一般都是会直接把源echo进去，比较快捷。</p><h4 id="sources-list文件结构"><a href="#sources-list文件结构" class="headerlink" title="sources.list文件结构"></a>sources.list文件结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type uri suite &#123;component&#125;</span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted</span><br></pre></td></tr></table></figure><ul><li>type:源的类型，通常是 <code>deb</code> 用于二进制包，或 <code>deb-src</code> 用于源代码包</li><li>uri:源的URI</li><li>suite:发行版的代号,buster,bullseye,focal,bionic</li><li>component:可选，指定源中的区域或分区 </li></ul><h2 id="YUM-DNF包管理"><a href="#YUM-DNF包管理" class="headerlink" title="YUM,DNF包管理"></a>YUM,DNF包管理</h2><ul><li>基于RPM的Linux发行版，使用.repo文件来定义软件仓库。</li><li>一般是使用的linux发行版有Fedora，CentOS和RHEL等</li></ul><h3 id="添加源-1"><a href="#添加源-1" class="headerlink" title="添加源"></a>添加源</h3><p>一般添加源可以创建一个新的文件或者编辑指定现有文件，这个和apt包管理的添源方式类似。但是他们的文件结构格式大不相同</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仓库的唯一标识符。这个ID在 .repo 文件中必须是唯一的</span></span><br><span class="line"><span class="section">[docker-ce-stable]</span></span><br><span class="line"><span class="comment"># 仓库的描述性名称</span></span><br><span class="line"><span class="attr">name</span>=Docker CE Stable - <span class="variable">$basearch</span> </span><br><span class="line"><span class="comment"># 仓库的基本URL，指向包含RPM包的目录</span></span><br><span class="line"><span class="attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="number">7</span>/<span class="variable">$basearch</span>/stable</span><br><span class="line"><span class="comment"># 定是否启用该仓库。设置为 1 表示启用，0 表示禁用</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指定是否检查GPG签名。设置为 1 表示启用GPG签名检查</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指向GPG公钥文件的路径，用于验证包的签名。</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br></pre></td></tr></table></figure><h3 id="更新方式也和apt管理不同"><a href="#更新方式也和apt管理不同" class="headerlink" title="更新方式也和apt管理不同"></a>更新方式也和apt管理不同</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum(dnf) makecache fast</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里为止，我依然觉得我还是不够了解Linux内核，总感觉没有想象的那么简单。可能过几天忙过了可以开始了解和学习一下KVM可能那里会给我一些答案。希望自己也能开始重新拾取对知识的渴望和动力吧。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易高弹性B/S架构</title>
      <link href="/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/"/>
      <url>/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="VPC架构设计"><a href="#VPC架构设计" class="headerlink" title="VPC架构设计"></a><strong>VPC架构设计</strong></h3><p>一个虚拟私有云（VPC）的结构，名称为“MyVPC”。该VPC包含4个子网，分布在两个可用区（us-east-1a和us-east-1b）中。其中，us-east-1a包含PublicSubnet1和PrivateSubnet1，us-east-1b包含PublicSubnet2和PrivateSubnet2。此外，该VPC还配置了两个路由表：PrivateRouteTable和PublicRouteTable，其中一个路由表的ID为“rtb-08c231d3d0fbbf2c2”。最后，图中显示了两个网络设备：MyInternetGateway和MyNatGateway。这些组件共同构成了一个典型的VPC架构，用于管理和控制网络流量的路由和访问。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154008942.png" alt="image-20240624154008942"></p><h3 id="B-S架构设计"><a href="#B-S架构设计" class="headerlink" title="B/S架构设计"></a><strong>B/S架构设计</strong></h3><p>这幅图展示了一个详细的虚拟私有云（VPC）架构，包含多个AWS组件和服务。该架构包括一个名为”MyVPC”的VPC，内部包含多个子网（如PublicSubnetA、PublicSubnetB、PrivateSubnetA、PrivateSubnetB）和路由表（如PublicRouteTable、PrivateRouteTable）。此外，还配置了网络ACL（如PublicNetworkACL、PrivateNetworkACL）来控制子网的入站和出站流量。网络设备方面，包含一个InternetGateway用于公共子网的互联网访问，以及一个NATGateway和其对应的弹性IP用于私有子网的互联网访问。安全组（如PublicInstanceSecurityGroup、PrivateInstanceSecurityGroup）用于实例的流量控制。实例部分，包括PublicInstanceA、PublicInstanceB、PrivateInstanceA、PrivateInstanceB等。</p><p>该架构使用堡垒机来登录实例，VPC通过CloudFormation模板构建，并基于CloudWatch指标实现自动扩展（AutoScaling）。会话状态保存在DynamoDB中，数据库缓存使用Amazon<br>ElastiCache for<br>Redis。此外，还使用消息队列SQS来处理消息。这些组件通过复杂的连接关系，构成了一个集成的、高度可扩展和可靠的网络架构，用于管理和控制流量的路由、访问和安全性，适用于在云环境中部署和管理各种应用和服务。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154015927.png" alt="image-20240624154015927"></p><h3 id="Auto-Scaling组配置"><a href="#Auto-Scaling组配置" class="headerlink" title="Auto Scaling组配置"></a><strong>Auto Scaling组配置</strong></h3><p>定义了一个自动扩展启动配置（Launch<br>Configuration），指定了使用的AMI镜像、实例类型、安全组、用户数据等信息，确保新实例能够按照指定的配置启动并运行。接着创建了一个自动扩展组（Auto<br>Scaling<br>Group），设置了VPC子网、启动配置、最小和最大实例数量、目标组等参数，以便根据负载情况自动调整实例数量。同时，配置了CloudWatch告警监控CPU利用率高低，当CPU利用率超过或低于阈值时，会触发相应的扩展或缩容策略。具体而言，定义了两个告警，分别用于CPU利用率超过70%和低于30%时的自动扩展和缩容操作。此外，还设置了扩展和缩容策略，包括调整实例数量、冷却时间等参数，以确保系统能够根据负载情况自动调整实例数量，实现自动化弹性扩展和收缩。整体而言，这个配置文件实现了一个基于CPU利用率的自动扩展机制，能够根据实际负载情况动态调整实例数量，提高系统的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154021722.png" alt="image-20240624154021722"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154027789.png" alt="image-20240624154027789"></p><h3 id="ALB配置"><a href="#ALB配置" class="headerlink" title="ALB配置"></a><strong>ALB配置</strong></h3><p>这个应用负载均衡器（ALB）在你的架构中担任了至关重要的角色，确保了应用的高效运行和用户体验的优化。具体来说，ALB将进入的应用程序流量智能地分配到多个目标（如EC2实例），平衡了负载并防止了单点故障，从而保证了系统的高可用性和可扩展性。通过定期进行健康检查，ALB确保只有健康的实例接收流量，如果某个实例出现故障，它会自动将流量重定向到其他健康的实例，提高了应用的可靠性。</p><p>此外，ALB支持基于内容的路由功能，可以根据请求的URL路径、HTTP头、查询字符串等，将流量路由到不同的目标组，使得你可以更灵活地管理流量，比如将静态内容和动态内容分开处理，从而优化资源使用。ALB还可以与AWS的安全服务（如AWS<br>WAF和ACM）集成，提供强大的安全防护，支持SSL/TLS终止，确保传输层的安全，同时简化了证书管理。通过与Auto<br>Scaling集成，ALB可以根据流量负载自动增加或减少目标实例的数量，确保了应用能够应对流量高峰，同时优化了成本。ALB还与CloudWatch无缝集成，提供详细的监控和日志记录功能，让你可以实时监控流量模式、请求响应时间等关键指标，快速识别和解决潜在问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154059526.png" alt="image-20240624154059526"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154041177.png" alt="image-20240624154035908"></p><h3 id="通过CloudFormation进行快速实施过程"><a href="#通过CloudFormation进行快速实施过程" class="headerlink" title="通过CloudFormation进行快速实施过程"></a><strong>通过CloudFormation进行快速实施过程</strong></h3><p>首先，通过CloudFormation创建一个VPC和多个子网，配置Internet网关和NAT网关以实现公共和私有网络的连接。然后设置安全组并启动Bastion主机作为跳板机。接着，配置目标组和创建应用负载均衡器，设置监听器以将流量引导到后端实例。定义启动配置并基于此配置创建自动伸缩组，实现根据负载情况动态调整实例数量。继续创建RDS子网组和部署RDS实例，确保数据库服务的高可用性和持久性。创建DynamoDB表以存储非结构化数据，实现快速读写和扩展性。配置ElastiCache子网组并部署ElastiCache集群，提供高性能的缓存服务，加速数据访问。最后，创建SQS队列用于处理消息队列，确保应用程序之间的异步通信。在完成上述步骤后，获取关键资源的信息，包括Bastion主机的公有IP地址用于远程访问，负载均衡器的DNS名称用于访问应用程序，RDS实例的终端节点用于数据库连接，DynamoDB表名用于数据存储，Redis缓存的终端节点用于快速数据缓存，以及SQS队列的URL用于消息处理。这样可以确保整个架构的部署和运行顺利进行。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154107810.png" alt="image-20240624154107810"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154125600.png" alt="image-20240624154125600"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154118431.png" alt="image-20240624154114091"></p><h3 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a><strong>遇到的问题与解决方案</strong></h3><p>权限问题：如果遇到权限不足的问题，确保使用的IAM用户或角色具有必要的权限，比如创建VPC、子网、EC2实例、RDS实例等权限。</p><p>资源限制问题：如果遇到资源限制（如EC2实例配额不足），可以通过联系AWS支持来提升配额。</p><p>网络配置问题：确保VPC和子网的CIDR块配置正确，避免重叠。确保安全组规则配置正确，允许所需的入站和出站流量。</p><p>模板语法错误：使用AWS<br>CloudFormation的模板验证工具来检查模板语法是否正确。</p><h3 id="测试方案与结果"><a href="#测试方案与结果" class="headerlink" title="测试方案与结果"></a><strong>测试方案与结果</strong></h3><h4 id="基于CloudWatch的AutoScaling"><a href="#基于CloudWatch的AutoScaling" class="headerlink" title="基于CloudWatch的AutoScaling"></a><strong>基于CloudWatch的AutoScaling</strong></h4><p>CloudWatch的Auto<br>Scaling是一种动态调整计算资源以匹配应用需求的机制，通过监控关键指标（如CPU利用率）来触发扩展或缩减操作。CloudWatch会收集和监控这些指标，并基于设定的阈值触发警报。当警报触发时，Auto<br>Scaling组会根据预定义的策略自动增加或减少EC2实例的数量。例如，当CPU利用率超过某个阈值时，Auto<br>Scaling会增加实例数量以处理高负载；当CPU利用率低于阈值时，Auto<br>Scaling会减少实例数量以节约成本。通过这种方式，Auto<br>Scaling确保了应用程序的高可用性和性能，同时优化了资源使用和成本效益。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154158215.png" alt="image-20240624154158215"></p><h4 id="DynamoDB保存会话状态"><a href="#DynamoDB保存会话状态" class="headerlink" title="DynamoDB保存会话状态"></a><strong>DynamoDB保存会话状态</strong></h4><p>在Web应用中，会话（Session） 是在用户与服务器之间的交互过程中维持状态的一种方式。HTTP协议本身是无状态的，这意味着每个请求都是独立的，服务器默认不会记住前一个请求的信息。会话状态技术允许服务器记住用户的状态信息（如用户是否已登录、用户的偏好设置等），这对于创建交互式Web应用是必要的。DynamoDB作为会话存储的后端，帮助Web应用维护用户的状态，提供连贯的用户体验，并且能够在用户数量激增时保持高性能和可靠性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154209751.png" alt="image-20240624154209751"></p><h4 id="使用消息队列SQS"><a href="#使用消息队列SQS" class="headerlink" title="使用消息队列SQS"></a><strong>使用消息队列SQS</strong></h4><p>使用AWS<br>SDK（例如Python的Boto3）向队列发送消息。首先，确保你已安装Boto3并配置了AWS凭证。接收消息也很简单。使用同样的SQS客户端，你可以从队列中拉取消息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154216362.png" alt="image-20240624154216362"></p><h4 id="使用ElastiCache-for-Redis数据库缓存"><a href="#使用ElastiCache-for-Redis数据库缓存" class="headerlink" title="使用ElastiCache for Redis数据库缓存"></a><strong>使用ElastiCache for Redis数据库缓存</strong></h4><p>ElastiCache for Redis 是一种由 AWS<br>托管的内存缓存服务，通过在内存中存储数据，提供极低的延迟和高吞吐量的数据访问能力，适用于实时分析、会话存储和排行榜等应用场景。它支持水平和垂直扩展，可以根据应用需求动态调整节点数量和实例规格，确保在流量高峰期依然高效运行。通过多可用区部署和自动故障转移功能，ElastiCache<br>for Redis<br>提供了高可用性和数据持久性，确保在节点故障时数据不丢失并迅速恢复。此外，ElastiCache<br>for Redis 是完全托管的服务，AWS<br>负责基础设施管理、软件更新、安全补丁和备份恢复，简化了管理工作，使开发者可以专注于应用开发。它还支持VPC、子网、安全组和加密功能，确保数据传输和存储的安全性。总之，ElastiCache<br>for Redis<br>提供了一个高效、可靠和安全的缓存解决方案，显著提升了数据访问速度和系统响应能力，简化了缓存管理和运维工作，使开发者能够专注于核心业务逻辑的开发。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154224745.png" alt="image-20240624154224745"></p><h4 id="实例与数据库连接"><a href="#实例与数据库连接" class="headerlink" title="实例与数据库连接"></a><strong>实例与数据库连接</strong></h4><p>为了使EC2实例与RDS实例互联，需要创建并配置两个安全组，一个用于EC2实例，另一个用于RDS实例。然后在RDS实例的安全组中添加入站规则，允许从EC2实例的安全组IP地址范围通过数据库端口（如3306）进行访问。最后，在EC2实例中配置数据库客户端，使用RDS实例的端点和端口号进行连接，从而实现网络通信与数据库操作。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154229517.png" alt="image-20240624154229517"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154234077.png" alt="image-20240624154234077"></p><h4 id="用CloudFormation进行VPC内容创建"><a href="#用CloudFormation进行VPC内容创建" class="headerlink" title="用CloudFormation进行VPC内容创建"></a><strong>用CloudFormation进行VPC内容创建</strong></h4><p>使用CloudFormation进行VPC创建可以自动化管理和部署完整网络架构。通过编写CloudFormation模板，可以创建一个VPC，设置其CIDR块，配置公共和私有子网，创建并连接Internet网关和NAT网关，并配置路由表和关联。这样不仅提高了部署效率，还减少了人为配置错误，确保网络架构的可重复性和一致性。例如，模板中配置了一个CIDR为10.0.0.0/16的VPC，包含两个公共子网和两个私有子网，并分别配置了路由表和NAT网关，以保证私有子网具有访问外部网络的能力。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="string">&#x27;2010-09-09&#x27;</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">AWS</span> <span class="string">CloudFormation</span> <span class="string">Template</span> <span class="string">for</span> <span class="string">B/S</span> <span class="string">Architecture</span> <span class="string">with</span> <span class="string">VPC,</span> <span class="string">Subnets,</span> <span class="string">RDS,</span> <span class="string">EC2,</span> <span class="string">Auto</span> <span class="string">Scaling,</span> <span class="string">DynamoDB,</span> <span class="string">ElastiCache,</span> <span class="string">and</span> <span class="string">SQS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">MyVPC:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPC</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">EnableDnsSupport:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">EnableDnsHostnames:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyVPC</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.3</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">InternetGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::InternetGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyInternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">GatewayAttachment:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPCGatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">InternetGatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGatewayEIP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::EIP</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Domain:</span> <span class="string">vpc</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGatewayEIP</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::NatGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">AllocationId:</span> <span class="type">!GetAtt</span> <span class="string">NatGatewayEIP.AllocationId</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPublicRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">DependsOn:</span> <span class="string">GatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">GatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPrivateRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">NatGatewayId:</span> <span class="type">!Ref</span> <span class="string">NatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">WebServerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">HTTP,</span> <span class="string">RDP,</span> <span class="string">and</span> <span class="string">SSH</span> <span class="string">access</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">bastion</span> <span class="string">host</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Instance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostInstance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Load Balancer Security Group</span></span><br><span class="line">  <span class="attr">LoadBalancerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">access</span> <span class="string">to</span> <span class="string">Load</span> <span class="string">Balancer</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Application Load Balancer</span></span><br><span class="line">  <span class="attr">ApplicationLoadBalancer:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::LoadBalancer</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Name:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Subnets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line">      <span class="attr">Scheme:</span> <span class="string">internet-facing</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Target Group for Load Balancer</span></span><br><span class="line">  <span class="attr">TargetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">TargetGroupTwo:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Listener for Load Balancer</span></span><br><span class="line">  <span class="attr">LoadBalancerListenerHTTP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">LoadBalancerListenerCustomPort:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Auto Scaling Launch Configuration</span></span><br><span class="line">  <span class="attr">LaunchConfiguration:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::LaunchConfiguration</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">UserData:</span></span><br><span class="line">        <span class="attr">Fn::Base64:</span> <span class="type">!Sub</span> <span class="string">|</span></span><br><span class="line"><span class="string">          #!/bin/bash</span></span><br><span class="line"><span class="string">          yum update -y</span></span><br><span class="line"><span class="string">          yum install -y httpd nodejs unzip</span></span><br><span class="line"><span class="string">          systemctl start httpd</span></span><br><span class="line"><span class="string">          systemctl enable httpd</span></span><br><span class="line"><span class="string">          cd /var/www/html</span></span><br><span class="line"><span class="string">          aws s3 cp s3://myawsbucketkalyanzitiu/mysqlViewer.zip</span></span><br><span class="line"><span class="string">          unzip mysqlViewer.zip</span></span><br><span class="line"><span class="string">          rm mysqlViewer.zip</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          node /var/www/html/start.js &amp;</span></span><br><span class="line"><span class="string">          /opt/aws/bin/cfn-signal -e $? --stack $&#123;AWS::StackName&#125; --resource AutoScalingGroup --region $&#123;AWS::Region&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="comment"># Auto Scaling Group</span></span><br><span class="line">  <span class="attr">AutoScalingGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::AutoScalingGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VPCZoneIdentifier:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">LaunchConfigurationName:</span> <span class="type">!Ref</span> <span class="string">LaunchConfiguration</span></span><br><span class="line">      <span class="attr">MinSize:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">MaxSize:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">DesiredCapacity:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">TargetGroupARNs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyAutoScalingGroup</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Environment</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">Production</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># CloudWatch Alarm for Auto Scaling</span></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmHigh:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale up if CPU &gt; 70% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">70</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">GreaterThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleUpPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmLow:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale down if CPU &lt; 30% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">LessThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleDownPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scaling Policies</span></span><br><span class="line">  <span class="attr">ScaleUpPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ScaleDownPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">-1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DynamoDB Table</span></span><br><span class="line">  <span class="attr">DynamoDBTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::DynamoDB::Table</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TableName:</span> <span class="string">SessionTable</span></span><br><span class="line">      <span class="attr">AttributeDefinitions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">AttributeType:</span> <span class="string">S</span></span><br><span class="line">      <span class="attr">KeySchema:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">KeyType:</span> <span class="string">HASH</span></span><br><span class="line">      <span class="attr">ProvisionedThroughput:</span></span><br><span class="line">        <span class="attr">ReadCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">WriteCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">SessionTable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ElastiCache for Redis</span></span><br><span class="line">  <span class="attr">RedisCacheCluster:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::CacheCluster</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CacheNodeType:</span> <span class="string">cache.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">NumCacheNodes:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">VpcSecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">RedisCacheCluster</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">RedisSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::SubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Description:</span> <span class="string">&quot;Subnet group for Redis cache&quot;</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># SQS Queue</span></span><br><span class="line">  <span class="attr">SQSQueue:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::SQS::Queue</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">QueueName:</span> <span class="string">MyQueue</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MySQSQueue</span></span><br><span class="line">          </span><br><span class="line">  <span class="attr">MyDBSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBSubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBSubnetGroupDescription:</span> <span class="string">My</span> <span class="string">DB</span> <span class="string">Subnet</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RDS Instance for Multi-AZ Deployment</span></span><br><span class="line">  <span class="attr">DBInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBInstance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBName:</span> <span class="string">MyDatabase</span></span><br><span class="line">      <span class="attr">AllocatedStorage:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">DBInstanceClass:</span> <span class="string">db.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MasterUsername:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">MasterUserPassword:</span> <span class="string">admin123</span></span><br><span class="line">      <span class="attr">VPCSecurityGroups:</span> []</span><br><span class="line">      <span class="attr">DBSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line">      <span class="attr">MultiAZ:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyRDSInstance</span></span><br><span class="line">    <span class="attr">DeletionPolicy:</span> <span class="string">Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Outputs:</span></span><br><span class="line">  <span class="attr">DBInstanceEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the RDS instance&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">DBInstance.Endpoint.Address</span></span><br><span class="line">  <span class="attr">BastionHostPublicIp:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The public IP address of the bastion host&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">BastionHostInstance.PublicIp</span></span><br><span class="line">  <span class="attr">LoadBalancerDNSName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The DNS name of the Application Load Balancer&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">ApplicationLoadBalancer.DNSName</span></span><br><span class="line">  <span class="attr">DynamoDBTableName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The name of the DynamoDB table&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">DynamoDBTable</span> </span><br><span class="line">  <span class="attr">RedisCacheEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the Redis cache cluster&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">RedisCacheCluster.RedisEndpoint.Address</span></span><br><span class="line">  <span class="attr">SQSQueueURL:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The URL of the SQS queue&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">SQSQueue</span></span><br></pre></td></tr></table></figure><h4 id="使用堡垒机登录实例"><a href="#使用堡垒机登录实例" class="headerlink" title="使用堡垒机登录实例"></a><strong>使用堡垒机登录实例</strong></h4><p>首先，通过SSH连接到堡垒机，以便安全地访问私有子网内的Web实例。登录堡垒机后，利用存储在堡垒机上的SSH密钥登录私有子网内的Web实例进行部署操作。有时使用密钥登录可能会显示“权限被拒绝”的错误，这通常是由于密钥文件权限设置不正确导致的。此时，可以通过运行chmod<br>400<br>path_to_your_private_key命令重新设置密钥文件权限，确保只有当前用户可以读取该文件，从而解决登录被拒绝的问题。通过这种方式，能够安全有效地管理和部署私有子网内的实例。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154256449.png" alt="image-20240624154256449"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154303065.png" alt="image-20240624154303065"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154308929.png" alt="image-20240624154308929"></p><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a><strong>性能评估</strong></h3><h4 id="负载均衡测试"><a href="#负载均衡测试" class="headerlink" title="负载均衡测试"></a><strong>负载均衡测试</strong></h4><p>通过性能监控对实例进行分流，显示不同ip型号的实例</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154334381.png" alt="image-20240624154334381"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154338428.png" alt="image-20240624154338428"></p><h4 id="数据库性能测试"><a href="#数据库性能测试" class="headerlink" title="数据库性能测试"></a><strong>数据库性能测试</strong></h4><p>显示了数据库性能测试中的几个关键指标，包括剩余存储空间、读写操作次数（IOPS）、网络接收与发送吞吐量等。图中显示在测试初期读写操作和网络传输活动较高，随后逐渐趋于平稳，表明数据库在高负载初期经过密集活动后恢复到稳定状态。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154345250.png" alt="image-20240624154345250"></p><h4 id="自动伸缩功能测试"><a href="#自动伸缩功能测试" class="headerlink" title="自动伸缩功能测试"></a><strong>自动伸缩功能测试</strong></h4><p>进行自动伸缩功能测试时，首先配置一个Auto<br>Scaling组，并设置其最小实例数为2，最大实例数为3。此外，创建缩放策略，当CPU利用率低于30%时减少实例数量，当CPU利用率高于70%时增加实例数量。启动测试后，可以观察到，当负载增加时，Auto<br>Scaling组中的实例数量从2个自动扩展到3个，而在负载减小时，实例数量则会减少回2个。这种自动调整实例数量的功能确保了应用在高负载时有足够的资源，同时在低负载时节省资源成本。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154404728.png" alt="image-20240624154404728"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154356696.png" alt="image-20240624154351414"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154414919.png" alt="image-20240624154414919"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154424766.png" alt="image-20240624154424766"></p><h4 id="项目部署效果测试"><a href="#项目部署效果测试" class="headerlink" title="项目部署效果测试"></a><strong>项目部署效果测试</strong></h4><p>项目架构部署在AWS云平台上，使用包含两个可用区的VPC，配置有公有和私有子网，互联网网关和NAT网关。核心部分是通过配置在互联网网关内的应用程序负载均衡器和Auto<br>Scaling组，实现Web实例的自动扩展，并将这些实例分布在两个可用区内。同时，RDS数据库配置了主备实例，确保数据的高可用性和可靠性。安全组进一步管理网络安全，确保系统的高可用性和灵活扩展性。</p><p>当负载均衡器正常运行时，提示项目成功启动。您可以通过访问以下URL连接到数据库并查看Web项目：</p><p><a href="http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/">http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/</a></p><p>这将能够直接访问部署在AWS上的Web应用，并与底层的数据库实例交互，确保应用的可靠运行和性能优化。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154510878.png" alt="image-20240624154510878"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154514651.png" alt="image-20240624154514651"></p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EKS概述</title>
      <link href="/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/"/>
      <url>/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/</url>
      
        <content type="html"><![CDATA[<h1 id="EKS"><a href="#EKS" class="headerlink" title="EKS"></a>EKS</h1><p>学校给的AWS沙盒快过期了，剩下几十🔪也不想浪费，突然发现居然有给EKS的权限，想到前几天自建K8S集群的经历，虽然可以熟悉集群流程，但是倘若在生产环境下，还是有安全高可用的托管平台舒服。</p><h2 id="架构结构"><a href="#架构结构" class="headerlink" title="架构结构"></a>架构结构</h2><p>学习一个东西，肯定是先了解概念以及大概的结构，由大入微，最重要的是要不断实践和尝试，通过实际操作来加深对该工具或技术的理解。</p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>首先是k8s，一个开源容器编排平台，源于Google的Borg。主要就是能够多平台进行自动化调度，修复，扩展，服务发现和负载，存储编排等重要功能。</p><p><img src="https://github.com/ben1234560/k8s_PaaS/raw/master/assets/1582188308711.png" alt="1582188308711"></p><h4 id="经典七大件"><a href="#经典七大件" class="headerlink" title="经典七大件"></a>经典七大件</h4><ol><li><p><strong>kube-apiserver</strong>：Kubernetes API服务器，提供了Kubernetes集群的API接口，负责接收和处理来自用户、控制器和其他组件的请求。</p></li><li><p><strong>kube-controller-manager</strong>：Kubernetes控制器管理器，包含多个控制器，负责监控集群状态并根据预定义的控制器逻辑进行调整，确保集群中的资源达到预期状态。</p></li><li><p><strong>kube-scheduler</strong>：Kubernetes调度器，负责根据Pod的调度策略（如资源需求、亲和性、反亲和性等）选择合适的Node节点来运行Pod。</p></li><li><p><strong>kubelet</strong>：每个Node节点上运行的Kubernetes代理，负责管理Node节点上的Pod和容器，与kube-apiserver通信，执行Pod的生命周期管理和监控。</p></li><li><p><strong>kube-proxy</strong>：Kubernetes网络代理，负责为Pod提供网络代理和负载均衡功能，实现Pod之间和Pod与外部网络的通信。</p></li><li><p><strong>etcd</strong>：分布式键值存储系统，用于存储Kubernetes集群的所有配置数据、状态信息和元数据，保证集群的一致性和可靠性。</p></li><li><p><strong>Container Runtime</strong>：容器运行时，负责在Node节点上创建和管理容器，常见的容器运行时包括Docker、containerd、CRI-O等。</p></li></ol><h3 id="EKS-1"><a href="#EKS-1" class="headerlink" title="EKS"></a>EKS</h3><p>EKS能够简化云上K8S的复杂性，提供一个高可用安全的控制平台，主要还可以集成其他服务，比如IAM、VPC、CloudWatch、ELB等。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630155419294.png" alt="image-20240630155419294"></p><p>上面的一个架构图，也是能够很清晰的看出来EKS Conrtol Plane成为了管理k8集群的核心组件，然后通过网络负载均衡余kubectl通信。咋一看好像中间少了API Server，scheduler，controller-manager这些组件，但是估计是由在集成在EKS Control里面的，而且相比于自建k8s集群的一个vpc内，这里却分为了两个VPC一个是管理的VPC，另一个是节点的VPC。这应该是属于一种网络隔离方法。可能是为了集群的稳定。其次就是责任分离了。然后工作节点的服务通过ELB来进行负载均衡给用户。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>首先配置eks集群</li><li>创建一个或多个工作节点</li><li>选择工具。并且连接到EKS</li><li>在pod上部署应用程序</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630165310994.png" alt="image-20240630165310994"></p><h2 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h2><p>不得不说是真的方便，还能够同时集成多个插件和统一的管理。可惜了，后面有一些操作，权限不够用不了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630183047481.png" alt="image-20240630183047481"></p>]]></content>
      
      
      <categories>
          
          <category> EKS </category>
          
          <category> K8S </category>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Academy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Docker部署Kubernetes</title>
      <link href="/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/"/>
      <url>/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Docker部署Kubernetes"><a href="#基于Docker部署Kubernetes" class="headerlink" title="基于Docker部署Kubernetes"></a>基于Docker部署Kubernetes</h1><h2 id="学习环境架构搭建"><a href="#学习环境架构搭建" class="headerlink" title="学习环境架构搭建"></a>学习环境架构搭建</h2><h3 id="创建VPC"><a href="#创建VPC" class="headerlink" title="创建VPC"></a>创建VPC</h3><p>在AWS创建一个拥有一个子网的VPC</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629213836702.png" alt="image-20240629213836702"></p><h3 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h3><p>安全组为了方便最好把ssh的22端口以及Kubernetes API服务的端口6443设置为入站规则。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214700104.png" alt="image-20240629214700104"></p><h3 id="启动模板创建"><a href="#启动模板创建" class="headerlink" title="启动模板创建"></a>启动模板创建</h3><p>根据最小配置。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214828795.png" alt="image-20240629214828795"></p><p>编写用户数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Docker</span></span><br><span class="line">apt-get install -y docker.io</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Kubernetes官方APT软件仓库的密钥和仓库</span></span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新APT索引并安装kubelet, kubeadm和kubectl</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swap（Kubernetes不支持运行在启用了Swap的机器上）</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>问题来了，当我试图用用户数据来做启动后的自动安装配置，由于Ubuntu版本命令已经不用apt-key了，所以在实例启动后并没有得到相应的环境，不过没有问题。</p><h2 id="Master主节点"><a href="#Master主节点" class="headerlink" title="Master主节点"></a>Master主节点</h2><h3 id="配置主节点环境以及准备初始化主节点"><a href="#配置主节点环境以及准备初始化主节点" class="headerlink" title="配置主节点环境以及准备初始化主节点"></a>配置主节点环境以及准备初始化主节点</h3><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. <strong>安装docker</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新本地的包索引数据库，这样在安装新软件时能获取到最新的软件包。</span></span><br><span class="line">sudo apt-get update </span><br><span class="line"><span class="comment"># 安装Docker。docker.io是Ubuntu官方仓库中Docker的软件包名称，-y参数表示自动同意安装过程中的询问。</span></span><br><span class="line">sudo apt-get install docker.io -y</span><br><span class="line"><span class="comment"># 启动Docker服务，并设置为开机自启动。</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><h3 id="2-关闭Swap"><a href="#2-关闭Swap" class="headerlink" title="2.关闭Swap"></a><strong>2.关闭Swap</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用swap（交换空间）。Kubernetes要求禁用swap，因为需要严格的资源控制和隔离，swap存在可能会影响性能和调度决策。</span></span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><h3 id="3-安装-cri-dockerd"><a href="#3-安装-cri-dockerd" class="headerlink" title="3.安装 cri-dockerd"></a>3.安装 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br><span class="line"><span class="comment"># cri-dockerd是一个桥接组件，允许Kubernetes通过CRI（容器运行时接口）与Docker交互。</span></span><br><span class="line">dpkg -i cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br></pre></td></tr></table></figure><ul><li></li></ul><h3 id="4-启动并配置开机启动-cri-dockerd"><a href="#4-启动并配置开机启动-cri-dockerd" class="headerlink" title="4.启动并配置开机启动 cri-dockerd"></a>4.启动并配置开机启动 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.socket</span><br></pre></td></tr></table></figure><ul><li>这些命令设置<code>cri-docker</code>服务和socket的启动和开机自启动，确保Kubernetes可以正确与Docker通信。</li></ul><h3 id="5-安装-kubeadm、kubelet、kubectl"><a href="#5-安装-kubeadm、kubelet、kubectl" class="headerlink" title="5.安装 kubeadm、kubelet、kubectl"></a>5.安装 kubeadm、kubelet、kubectl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装网络传输和证书相关的工具，为后续下载和验证Kubernetes包做准备。</span></span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并安装Kubernetes的GPG密钥，用于验证后续安装包的完整性。</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加Kubernetes的软件源，以便安装kubeadm、kubelet和kubectl。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] http://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><ul><li>测试拉取，然后查看需要的images</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630104435917.png" alt="image-20240630104435917"></p><ul><li>拉取镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/etcd:3.5.7-0</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630111103161.png" alt="image-20240630111103161"></p><h4 id="第一次尝试初始化"><a href="#第一次尝试初始化" class="headerlink" title="第一次尝试初始化"></a>第一次尝试初始化</h4><p>粗心大意,podSubnet没有注意大小写</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630113034682.png" alt="image-20240630113034682"></p><h4 id="第二次尝试初始化"><a href="#第二次尝试初始化" class="headerlink" title="第二次尝试初始化"></a>第二次尝试初始化</h4><p>需要reset一下kubeeadm</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们用的是docker</span></span><br><span class="line">sudo kubeadm reset -f --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630114542529.png" alt="image-20240630114542529"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>出现了两个问题,总的来说就是权限问题和连接问题.</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115125908.png" alt="image-20240630115125908"></p><h5 id="权限问题解决"><a href="#权限问题解决" class="headerlink" title="权限问题解决"></a>权限问题解决</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> ubuntu:ubuntu /etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>解决完权限问题后,连接问题也解决了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115354437.png" alt="image-20240630115354437"></p><p> 经过一定的搜寻和思考,</p><ul><li>运行上述命令后，你实际上是在改变 <code>/etc/kubernetes/admin.conf</code> 文件的所有权，将其从 <code>root</code> 用户和组更改为 <code>ubuntu</code> 用户和组。这样做的直接结果是，普通用户 <code>ubuntu</code> 现在有权限读取这个文件。</li><li>在k8s中集群中,<code>admin.conf</code> 文件包含了连接到集群的 K8s API 服务器的必要凭证和连接信息。这包括 API 服务器的地址、端口、使用的证书等。当你以 <code>ubuntu</code> 用户身份运行 <code>kubectl</code> 命令时，<code>kubectl</code> 会尝试读取这个配置文件来获取连接到 K8s 集群的必要信息。</li></ul><h4 id="先观察一下kubelet日志"><a href="#先观察一下kubelet日志" class="headerlink" title="先观察一下kubelet日志"></a>先观察一下kubelet日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl -u kubelet -f</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630120005623.png" alt="image-20240630120005623"></p><h4 id="再看一眼pod的日志"><a href="#再看一眼pod的日志" class="headerlink" title="再看一眼pod的日志"></a>再看一眼pod的日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定namespace;</span></span><br><span class="line">sudo kubectl logs coredns-5dd5756b68-jd25s --namespace=kube-system</span><br></pre></td></tr></table></figure><p>这种情况,大概率是网络上的,问题,经过查找需要安装一些网络插件</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630121445618.png" alt="image-20240630121445618"></p><h4 id="安装部署-Calico-网络插件"><a href="#安装部署-Calico-网络插件" class="headerlink" title="安装部署 Calico 网络插件"></a>安装部署 Calico 网络插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure><h2 id="Node-节点加入集群"><a href="#Node-节点加入集群" class="headerlink" title="Node 节点加入集群"></a>Node 节点加入集群</h2><h3 id="先在master节点查看加入命令"><a href="#先在master节点查看加入命令" class="headerlink" title="先在master节点查看加入命令"></a>先在master节点查看加入命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入命令,并指定cri-socket</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.0.1.237:6443 --token a69ewm.uvje3ei8zhox3xar --discovery-token-ca-cert-hash sha256:64db0e4e2ddc13e1a06390ac6b90b4f38a965fdc7cbfd2e3baa80a668e7cd74d --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><h3 id="为了node节点加入必备组件"><a href="#为了node节点加入必备组件" class="headerlink" title="为了node节点加入必备组件"></a>为了node节点加入必备组件</h3><p>成功后会显示</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630124600952.png" alt="image-20240630124600952"></p><p>然后主节点查看加入集群的节点</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630125420559.png" alt="image-20240630125420559"></p><p>ps:如果报couldn’t get current server API group list: Get “<a href="http://localhost:8080/api?timeout=32s&quot;">http://localhost:8080/api?timeout=32s&quot;</a>: dial tcp 127.0.0.1:8080: connect: connection refused的话，大概率是终端断连导致之前export的环境变量失效了，可以在/etc/environment文件中加入KUBECONFIG=”/etc/kubernetes/admin.conf”以使环境变量永久生效</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaEE</title>
      <link href="/2024/04/02/javaEE/"/>
      <url>/2024/04/02/javaEE/</url>
      
        <content type="html"><![CDATA[<h2 id="代码连接"><a href="#代码连接" class="headerlink" title="代码连接"></a>代码连接</h2><p><a href="https://github.com/Kalyan-zitiu/Studyroomreservationsystem">https://github.com/Kalyan-zitiu/Studyroomreservationsystem</a></p><h2 id="需求说明以及功能分析"><a href="#需求说明以及功能分析" class="headerlink" title="需求说明以及功能分析"></a>需求说明以及功能分析</h2><h3 id="用户用例需求分析及其功能"><a href="#用户用例需求分析及其功能" class="headerlink" title="用户用例需求分析及其功能"></a>用户用例需求分析及其功能</h3><p>  如下图，普通用户：1.查看自习室情况：普通用户可以查看自习室的预约情况。2.预约自习室：普通用户可以预约自习室。3.取消预约：普通用户可以取消已预约的自习室。4.查看预约情况：普通用户可以查看自己的预约情况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630190654093.png" alt="image-20240630190654093"></p><p>如下图管理员用例图，1.删除自习室：管理员可以删除系统中的自习室。2.添加自习室：管理员可以在系统中新增自习室。3.修改自习室：管理员可以对现有的自习室信息进行修改。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191300868.png" alt="image-20240630191300868"></p><p>如下图超级管理员用例图，1.添加自习室：超级管理员可以在系统中新增自习室。2.删除自习室：超级管理员可以删除系统中的自习室。3.修改自习室：超级管理员可以对现有的自习室信息进行修改。4.查看使用统计：超级管理员可以查看自习室的使用统计数据。5.管理用户：超级管理员可以管理系统中的用户，包括添加删除修改用户信息。6.搜索普通用户：超级管理员可以搜索普通用户的信息。</p><p>​                                                                      <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps3.jpg" alt="img"> </p><h3 id="系统总操作流程分析"><a href="#系统总操作流程分析" class="headerlink" title="系统总操作流程分析"></a>系统总操作流程分析</h3><p>如下图，操作流程图展示了一个自习室预约系统的总操作流程。用户首先进行登录，输入用户名和密码后，系统会检查输入是否为空。如果为空，系统会提示信息不为空并要求重新输入。如果不为空，系统继续检查用户名和密码是否正确。如果不正确，系统会提示信息不正确并返回重新输入步骤。如果正确，系统会进行身份权限判断，根据用户权限执行相应的功能处理。整个过程在执行完相关功能处理后结束。这个流程图主要描述了登录验证和权限判断的过程，但缺少注册、找回密码、不同权限的具体功能分支及错误处理等环节。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191401981.png" alt="image-20240630191401981"></p><h2 id="系统概要设计"><a href="#系统概要设计" class="headerlink" title="系统概要设计"></a>系统概要设计</h2><h3 id="系统概述以及设计"><a href="#系统概述以及设计" class="headerlink" title="系统概述以及设计"></a>系统概述以及设计</h3><p>自习室预约系统是一种在线平台，旨在为学生和教职员工提供便捷、高效的自习室预订服务。该系统通过采用先进的数字化管理手段，实现了自习室资源的合理分配和高效利用，用户可以随时随地进行自习室的查看、预订、取消和管理，以满足其个性化学习需求。如下图系统工作原理图，展示了自习室预约系统的执行过程：客户端向Web服务器发送请求，Web服务器对请求进行验证后，向数据库检索相关数据或更新信息。数据库完成操作后，将结果传送回Web服务器，Web服务器再将最终结果回发给客户端。整个流程确保数据的实时性和准确性</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191517073.png" alt="image-20240630191517073"></p><h3 id="系统结构设计"><a href="#系统结构设计" class="headerlink" title="系统结构设计"></a>系统结构设计</h3><p>如下图系统结构图，展示自习室预约系统的功能结构图，包含普通用户、管理员和超级管理员三个角色。普通用户可以查看自习室情况、进行预约和取消预约；管理员可以管理预约情况、添加、修改和删除自习室信息；超级管理员则具有更高级别的权限，不仅可以管理用户，还能查看使用统计，以及添加、修改和删除自习室信息。图中用方框和连接线清晰地展示了各角色的功能模块和操作权限。</p><p>​                                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps6.jpg" alt="img"> </p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><ol><li>数据存储</li></ol><p>数据库包含以下主要实体：用户、角色、自习室、自习室详情、预约信息、用户角色。各实体表的设计如下：</p><p>用户表存储用户ID、用户名、密码、手机号和邮箱。</p><p>角色表存储角色ID、角色名称、角色标识和角色状态。</p><p>自习室表存储自习室ID、自习室编号、容量、设施和类型。</p><p>自习室详情表存储自习室地址、预约次数和使用次数。</p><p>预约信息表记录预约ID、用户ID、自习室详情ID、预约时间、状态原因和结束时间。</p><ol start="2"><li>数据管理</li></ol><p>数据库通过标准的SQL命令行管理工具以及数据库管理软件进行管理，包括数据的插入、更新、删除和查询。此外，视图、存储过程和触发器简化了数据管理操作和维护数据完整性。</p><ol start="3"><li>数据检索</li></ol><p>通过SQL查询语句进行数据检索。例如：</p><p>查询用户的预约记录。</p><p>查询某段时间内某自习室的使用情况。</p><p>在重要字段（如用户ID、自习室ID、预约时间）上建立索引，以提高检索效率。</p><ol start="4"><li>数据安全</li></ol><p>数据安全包括：</p><p>用户认证：使用加密和散列技术保护用户密码。</p><p>权限控制：通过角色和权限管理控制不同用户对数据库的访问权限。</p><p>数据传输：使用SSL/TLS保护数据传输安全。</p><p>日志记录：记录数据库访问和修改行为，以便审计。</p><ol start="5"><li>数据一致性</li></ol><p>数据库通过以下策略确保数据一致性：</p><p>主键约束：保证每个表的主键唯一且非空。</p><p>外键约束：确保引用完整性（如预约记录的用户ID必须在用户表中存在）。</p><p>触发器：自动检查和修正数据的一致性。</p><ol start="6"><li>数据完整性</li></ol><p>数据库使用以下方法保证数据完整性：</p><p>实体完整性：确保每个表的主键唯一且非空。</p><p>参照完整性：通过外键约束保持表间关系一致。</p><p>业务规则：使用存储过程和触发器实现业务逻辑，防止数据失效。</p><p>如下图用户信息实体图，用户信息实体包含以下属性：用户ID、用户名、密码、手机号和邮箱。用户实体与预约信息（reservation）实体之间存在一对多的关系，即每个用户可以有多个预约记录。用户实体还与用户角色（user_role）实体存在一对多的关系，表示每个用户可以对应多个角色，从而实现不同的权限和功能。该设计保证了用户的基本信息与其预约和角色信息的有效关联。</p><p>如下图角色信息实体图，角色信息实体（role）包含以下属性：角色ID、角色名字、角色标识和角色状态。角色信息实体与用户角色（user_role）实体之间存在一对多的关系，即每个角色可以对应多个用户角色记录。这个设计确保了每个角色的信息能够与多个用户相关联，从而在系统中实现多用户角色的管理和权限分配。</p><p>​                                                                          <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps8.jpg" alt="img"> </p><p>如下图自习室详情信息实体图，自习室详情信息实体包含以下属性：自习室详情ID、自习室地址、自习室ID、自习室预约次数和自习室使用次数。自习室详情信息实体与自习室信息实体之间存在一对一的关系，即每个自习室对应唯一的自习室详情记录。这个设计确保了每个自习室都有独立且详细的预订和使用情况描述，从而可以有效管理和监控每个自习室的使用状态。</p><p>​                                                                         <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps9.jpg" alt="img"> </p><p>如下图预约系统实体图，预约信息实体包含以下属性：预约ID、用户ID、自习室详情ID、预约开始时间、预约状态、取消或拒绝理由以及预约结束时间。预约信息实体与用户信息实体之间存在多对一关系，即多个预约记录可以对应同一个用户。同时，预约信息实体与自习室详情实体之间也存在多对一关系，即多个预约记录可以对应同一个自习室详情。这种设计确保了预约信息能够准确关联到具体的用户和自习室详情，从而实现全面的预约管理。</p><p>​                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192344417.png" alt="image-20240630192344417"></p><p>如下图，自习室实体图，自习室信息实体包含以下属性：自习室ID、自习室编号、总容量、可用设备和自习室类型。自习室信息实体与自习室详情信息实体之间存在一对一的关系，即每个自习室对应唯一的自习室详情记录。这个设计确保了每个自习室在系统中都有详细且独立的描述，从而可以准确记录和管理自习室的使用情况、容量和设备等信息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192355875.png" alt="image-20240630192355875"></p><p>如下表3-1，自习室表存储每个自习室的基本信息，包括自习室ID、自习室编号、容量、设施和类型。在系统内，自习室表用于记录和管理所有自习室的基础信息，并与自习室详情表存在一对一关系。这种关系确保每个自习室都有唯一的详细信息记录，用于详细描述自习室的位置和使用情况。</p><p>表3-1 自习室表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>study_room_id</td><td>int</td><td>11</td><td>主键非空</td><td>Id</td></tr><tr><td>study_room_num</td><td>varchar</td><td>50</td><td>无</td><td>自习室可用数量</td></tr><tr><td>capacity</td><td>int</td><td>50</td><td>无</td><td>总容量</td></tr><tr><td>Type</td><td>varchar</td><td>50</td><td>无</td><td>自习室类型</td></tr><tr><td>facilities</td><td>varchar</td><td>50</td><td>无</td><td>自习室设备</td></tr></tbody></table><p>如下表3-2，自习室详情表包含自习室的详细信息，包括位置、自习室ID、预约频率和使用频率。在系统内，自习室详情用于进一步描述自习室的具体信息，如地理位置和使用统计信息。它与自习室表存在一对一关系，确保每个自习室都有唯一的详细信息记录。</p><p>表3-2 自习室详情表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>自习室Id</td></tr><tr><td>Location</td><td>varchar</td><td>50</td><td>无</td><td>自习室地址</td></tr><tr><td>study_room_id</td><td>int</td><td>11</td><td>无</td><td>自习室归属Id</td></tr><tr><td>reservation_frequency</td><td>int</td><td>11</td><td>无</td><td>自习室预约状态</td></tr><tr><td>usage_frequency</td><td>int</td><td>11</td><td>无</td><td>自习室使用次数</td></tr><tr><td>capecity</td><td>int</td><td>11</td><td>无</td><td>容量</td></tr></tbody></table><p>  如下表3-3，用户表包含用户的基本信息，包括用户ID、用户名、密码、手机号和邮箱。系统内，用户表用于存储和管理所有用户的信息，并通过多对一关系与预约记录和用户角色关联，以便管理用户的预约活动和角色分配。</p><p>表3-3 用户表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>User_id</td><td>int</td><td>11</td><td>主键非空</td><td>用户Id</td></tr><tr><td>password</td><td>varchar</td><td>50</td><td>无</td><td>密码</td></tr><tr><td>phone</td><td>mediumtext</td><td>11</td><td>无</td><td>用户手机号码</td></tr><tr><td>email</td><td>varchar</td><td>11</td><td>无</td><td>用户邮箱</td></tr><tr><td>User_name</td><td>varchar</td><td>50</td><td>无</td><td>用户姓名</td></tr></tbody></table><p>  如下表3-4，预约表记录每个预约的详细信息，包括预约ID、用户ID、自习室详情ID、预约时间、状态、取消或拒绝的原因和结束时间。在系统内，预约表用于跟踪和管理所有的自习室预约记录。它通过多对一关系与用户表和自习室详情表关联，确保每个预约记录都与特定的用户和自习室关联。</p><p>表3-4 预约信息表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>reservation_id</td><td>int</td><td>11</td><td>主键非空</td><td>预约Id</td></tr><tr><td>User_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>Study_details_id</td><td>int</td><td>11</td><td>无</td><td>自习室详情Id</td></tr><tr><td>time_start</td><td>datetime</td><td>50</td><td>无</td><td>预约开始时间</td></tr><tr><td>time_end</td><td>datetime</td><td>50</td><td>无</td><td>预约结束时间</td></tr><tr><td>status</td><td>tinyint</td><td>11</td><td>无</td><td>预约状态</td></tr><tr><td>reason</td><td>varchar</td><td>50</td><td>无</td><td>申请原因</td></tr></tbody></table><p>  如下表3-5，角色表包含每个角色的信息，包括角色ID、角色名称、角色标识和状态。在系统内，角色表用于定义和存储不同的角色，并与用户角色表存在多对一关系。这样，每个角色可以分配给多个用户，方便进行权限管理和角色分配。</p><p>表3-5 角色表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色Id</td></tr><tr><td>role_name</td><td>varchar</td><td>255</td><td>无</td><td>角色名字</td></tr><tr><td>role_sign</td><td>varchar</td><td>30</td><td>无</td><td>角色标识</td></tr><tr><td>status</td><td>tinyint</td><td>11</td><td>无</td><td>角色状态</td></tr></tbody></table><p>  如下表3-6，用户角色表记录用户与其分配角色之间的关系，包括用户角色ID、用户ID和角色ID。在系统内，用户角色表用来管理和存储用户与角色的映射关系。它通过多对一关系与用户表和角色表关联，确保用户可以拥有相应的角色和权限。</p><p>表3-6 用户角色表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>user_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>role_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr></tbody></table><p>  如下表3-7，自习室管理员表包含管理员的信息，包括管理员ID、用户ID和自习室ID。在系统内，自习室管理员表用于指定和管理自习室的管理员。它通过多对一关系与用户表和自习室表关联，确保每个自习室有特定的管理员进行管理和维护。</p><p>表3-7 自习室管理表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>admin_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>user_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>study_room_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr></tbody></table><p>  如下表3-8，角色权限表存储角色与权限之间的关系，包括角色权限ID、角色ID和权限ID。在系统内，角色权限表用于管理和记录每个角色与其权限之间的映射关系。它通过多对一关系与角色表和权限表关联。</p><p>表3-8 角色权限表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>角色权限Id</td></tr><tr><td>role_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr><tr><td>permission_id</td><td>int</td><td>11</td><td>无</td><td>权限Id</td></tr></tbody></table><p>如下表3-9，权限表存储权限的信息，包括权限ID、权限名称和权限简化表示。在系统内，权限表用于定义和存储不同的权限，并通过多对一关系与角色权限表关联。这样，每个权限可以分配给多个角色，实现灵活的权限管理。</p><p>表3-9 权限表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>permsission_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>permission_simplify</td><td>varchar</td><td>20</td><td>无</td><td>权限简化标识</td></tr><tr><td>permsission_name</td><td>varchar</td><td>255</td><td>无</td><td>权限名称</td></tr></tbody></table><h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><p>用户认证：采用安全认证机制，如密码哈希存储用户密码，使用令牌或会话管理用户登录状态。</p><p>权限控制：根据用户角色进行权限控制，确保只有具有相应权限的用户才能执行特定操作。</p><p>数据保护：对敏感数据进行加密存储和传输，确保数据的机密性和完整性。</p><h2 id="系统详细设计"><a href="#系统详细设计" class="headerlink" title="系统详细设计"></a>系统详细设计</h2><h3 id="登录功能模块"><a href="#登录功能模块" class="headerlink" title="登录功能模块"></a>登录功能模块</h3><p>如下图，在自习室预约系统的登录时序图中，用户首先在浏览器中输入用户名和密码并点击登录。接着，浏览器通过HTTP请求将表单数据发送到服务器，服务器查询数据库以验证用户名和密码。如验证成功，服务器生成会话令牌，如JWT或Session ID，并将其发送回浏览器，同时浏览器将令牌保存在CookieLocalStorage中。最后，服务器发送登录成功的信息，并可能重定向用户到主页面或个人主页。这一过程清晰展示了用户登录流程的各个关键步骤及各组件间的交互</p><p>​                               <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191841675.png" alt="image-20240630191841675"></p><p>如下图3,用户首先在浏览器中打开自习室预约系统的登录页面，并在页面的表单中输入用户名和密码。然后，用户点击“登录”按钮，表单数据通过HTTP请求发送到服务器。服务器接收到请求后，提取用户名和密码，并查询数据库以验证用户名是否存在。如果用户名存在，服务器会对比存储的哈希密码和用户输入的密码。如果用户名或密码不匹配，服务器向用户返回登录失败的信息。如果用户名密码匹配，服务器生成会话令牌，并将令牌发送给用户的浏览器。随后，浏览器收到会话令牌（如JWT或Session ID）并将其保存到Cookie或LocalStorage中。最后，服务器向用户浏览器返回登录成功的信息，并重定向到系统的主页面或用户的个人主页。把这部分的时序图的从上面内容提取出来。</p><p>​                                                   <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps13.jpg" alt="img"> </p><h3 id="管理员功能模块"><a href="#管理员功能模块" class="headerlink" title="管理员功能模块"></a>管理员功能模块</h3><p>添加自习室：</p><p>如下图，浏览器将这些信息通过HTTP请求发送到服务器。服务器接收到请求后，首先对数据进行完整性和合法性检查，确保所有必填字段都有值且数据格式正确。然后，服务器将验证通过的自习室信息存入数据库。如果存储成功，服务器返回成功信息给浏览器；如果失败，则返回错误信息。最后，浏览器接收到服务器的响应并更新页面，根据返回的信息显示添加成功或失败的结果提示。</p><p>​                               <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192418134.png" alt="image-20240630192418134"></p><p>如下图所示，管理员访问自习室预约系统的添加自习室页面，在表单中输入自习室的详细信息并点击“添加”按钮</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192428678.png" alt="image-20240630192428678"></p><p>删除自习室：</p><p>如下图，该请求通过HTTP发送到服务器。服务器接收到请求后，会进行权限检查和请求有效性验证，确保管理员具有相应的操作权限。一旦验证通过，服务器指示数据库删除相关的自习室记录。数据库执行删除操作，服务器将结果返回给浏览器，显示该自习室已被成功删除或删除失败的信息。</p><p>​                                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps16.jpg" alt="img"> </p><p>如下图所示，管理员首先登录到自习室预约系统，并访问自习室管理页面，该页面列出了所有注册的自习室信息。管理员找到并选择他们想要删除的自习室，并点击该自习室旁的“删除”按钮以发起删除请求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192435966.png" alt="image-20240630192435966"></p><p>修改自习室：</p><p>如下图，编辑完成后，管理员点击“提交”按钮，浏览器会将修改后的信息以HTTP请求的形式发送到服务器。服务器接收这些信息后进行权限验证和数据合法性检查，一旦确认无误，服务器会指示数据库更新这些自习室信息。数据库完成更新操作后，服务器根据操作结果向管理员返回一个成功或失败的响应。浏览器接收到响应后，将页面更新以显现修改成功或失败的通知。这个过程不仅确保了数据的准确性和操作的安全性，还通过即时反馈帮助管理员确认修改操作的最终结果。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192447410.png" alt="image-20240630192447410"></p><p>如下图所示，在自习室预约系统中，管理员首先登录并导航到自习室管理页面，这里列出了所有自习室的详细信息。管理员选择需要修改的自习室，并点击相对应的“编辑”按钮，这将打开一个带有当前自习室信息的表单。管理员在此表单中可以更新自习室的各类信息，如名称、容量、地点及开放时间等。</p><p>​                                                                    <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps19.jpg" alt="img"> </p><h3 id="用户功能模块"><a href="#用户功能模块" class="headerlink" title="用户功能模块"></a>用户功能模块</h3><p>预约自习室：</p><p>如下图，编辑完成后，管理员点击“提交”按钮，浏览器会将修改后的信息以HTTP请求的形式发送到服务器。服务器接收这些信息后进行权限验证和数据合法性检查，一旦确认无误，服务器会指示数据库更新这些自习室信息。数据库完成更新操作后，服务器根据操作结果向管理员返回一个成功或失败的响应。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192457889.png" alt="image-20240630192457889"></p><p>如下图，3-22所示，在自习室预约系统中，管理员首先登录并导航到自习室管理页面，这里列出了所有自习室的详细信息。管理员选择需要修改的自习室，并点击相对应的“编辑”按钮，这将打开一个带有当前自习室信息的表单。管理员在此表单中可以更新自习室的各类信息，如名称、容量、地点及开放时间等。</p><p>​                                                         <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps21.jpg" alt="img"> </p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192512225.png" alt="image-20240630192512225"></p><p>取消预约：</p><p>如下图所示，用户首先登录到系统并导航到自己的预约历史或当前预约页面。在这里，所有的活跃预约都会被列出，包括每个预约的时间、自习室编号以及取消预约的选项。用户选择需要取消的预约后，点击“取消预约”按钮，系统会提示用户确认是否要取消。一旦用户确认取消，系统将自动发送取消请求到服务器，服务器验证请求的有效性后，更新数据库以反映预约被取消的状态。完成后，系统会通知用户预约已成功取消，并更新页面以显示最新的预约状态。用户首先登录到系统并导航到自己的预约历史或当前预约</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192521588.png" alt="image-20240630192521588"></p><p>查看自习室情况：</p><p>如下图所示，用户可以通过系统提供的自习室状态页面来查看各自习室的当前状态和预约情况。用户访问该页面后，系统展示所有自习室的列表，包括每间自习室的位置、容量和当前的占用情况。用户可以查看每个自习室的详细信息，如开放时间和特定时间段内的预约状况，这有助于用户在预约前做出更明智的选择。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192525619.png" alt="image-20240630192525619"></p><p>查看预约情况：</p><p>如下图所示，用户需要了解自己的预约历史，以便于管理和规划个人时间。系统允许用户访问一个专门的页面，列出他们过去和即将进行的所有预约详情。这包括预约的日期、时间、自习室号码以及预约的状态。用户可以通过这一功能轻松跟踪自己的预约状况，并进行相应的规划和调整。</p><p>​                                                           <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps25.jpg" alt="img"> </p><h3 id="超级管理员功能模块"><a href="#超级管理员功能模块" class="headerlink" title="超级管理员功能模块"></a>超级管理员功能模块</h3><p>搜索用户：</p><p>如下图，服务器接收到请求后，解析其中的搜索关键字，并基于这些关键字对数据库进行查询操作，以找到符合条件的用户信息。一旦数据库查询完成，服务器会根据查询结果生成相应的响应信息。如果查询成功并找到了匹配的用户，服务器会将这些用户数据作为响应发送回浏览器；如果没有找到匹配的用户，则会发送一个表示无结果的提示信息。浏览器接收到这些信息后，便会更新用户管理页面，显示出搜索结果或者是没有找到任何用户的提示。整个过程不仅保证了超级管理员能够快速准确地获取用户信息，还优化了用户管理的效率。</p><p>​                                                             <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps26.jpg" alt="img"> </p><p>如下图所示，超级管理员首先需要登录到自习室预约系统，并导船到用户管理页面。这个页面包括一个搜索框，允许超级管理员输入特定的搜索条件，如用户的用户名、邮箱或其他相关属性。输入完成后，超级管理员点击“搜索”按钮，此时浏览器会将这些搜索条件通过HTTP请求形式发送给服务器。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192544783.png" alt="image-20240630192544783"></p><p>管理用户：</p><p>如下图，此时系统会将这一角色更改请求通过HTTP请求发送到服务器。服务器接收到请求后，首先进行权限验证，确保当前操作员有权执行这一角色修改操作。若权限验证通过，服务器则指令数据库更新该用户的角色信息。数据库更新完成后，服务器会根据操作的结果生成响应，并将其发送回浏览器。浏览器接收到这一信息后，会更新用户管理页面，并向超级管理员显示角色更新成功或失败的提示。这个完整的流程不仅保证了用户角色管理的灵活性和系统的权限控制，还通过实时反馈使得超级管理员能够即刻知晓操作结果，从而提升了用户管理的效率和准确性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192553947.png" alt="image-20240630192553947"></p><p>如下图所示，在自习室预约系统中，超级管理员首先需要通过浏览器登录系统，并导航至用户管理页面。此页面详细展示了系统中所有用户的列表，包括他们的基本信息和当前分配的角色。超级管理员浏览这个列表，并选择想要修改角色的特定用户。选择用户后，超级管理员可以通过一个界面元素（通常是下拉菜单）来指定新的用户角色，比如将用户从普通用户改为管理员或其他角色。一旦选择了新的角色，超级管理员会点击“更新”或“提交”按钮。</p><p>​                                                                <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192605509.png" alt="image-20240630192605509"></p><p>​                                                                                  <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps30.jpg" alt="img"> </p><p>查看使用统计：</p><p>如下图所示，通过合法的认证流程登录系统。登录后，超级管理员可以导航到系统提供的“统计”或“报表”页面，这里集中展示了自习室使用的各种统计数据。这些统计数据通常包括但不限于用户预约次数、自习室使用频率、高峰使用时段、取消预约的次数以及任何特定时间段内的用户活动情况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192613060.png" alt="image-20240630192613060"></p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="系统测试综述"><a href="#系统测试综述" class="headerlink" title="系统测试综述"></a>系统测试综述</h3><p>综述：</p><p>在自习室预约系统中，我们聚焦于测试查看自习室情况、预约和取消预约功能以确认普通用户的交互正确性；同时，管理员的添加、删除和修改自习室信息功能进行深入测试以保证系统信息的准确更新；对于超级管理员功能，特别测试了查看使用统计、管理用户以及搜索用户信息的准确性和效率。这些测试是为了确保系统各功能模块不仅符合设计要求，同时也提供了用户友好、安全和高效的操作体验，从而在系统投入实际使用前，能够识别并修正潜在问题，进一步提升服务的质量和用户满意度。通过全面的测试策略，我们的目标是确保自习室预约系统在提供必需服务的同时，保护用户信息的安全，同时确保系统跨平台的兼容性和高效性。测试覆盖了从基本功能到用户最终接受的每个阶段，确保发现并修复潜在的问题，从而提供一个既易于使用也高度可靠的系统，满足最终用户的期望和需求。这些测试不仅提高了系统的整体质量，也提升了用户信任。</p><p>测试类型及其目的：</p><p>功能测试：主要验证系统中的核心功能，如预约准确性、用户管理、通知系统以及时间选择功能。这项测试确保所有功能按预期工作，没有逻辑错误或缺陷，从而保证系统操作的正确性和预期行为。</p><p>性能测试：着重检查系统在高负载或高压力条件下的表现。该测试评估系统的响应速度和稳定性，确保在大量用户同时使用时系统能够有效地处理请求，从而提供持续的服务质量。</p><p>安全性测试：保证用户数据的安全性和隐私。通过这项测试，我们评估系统防止未授权访问以及数据泄露的能力，关注保护用户信息和转输安全。</p><p>兼容性测试：验证软件在不同的设备、操作系统和浏览器上的运行稳定性。这确保所有用户无论使用何种技术平台都能获得一致的体验。</p><p>用户接受测试：通过实际用户的操作反馈来评估系统的实用性和满意度。这项测试帮助我们了解用户在日常使用中遇到的问题和不便，以便进行调整和优化，提升用户体验。</p><h3 id="关键测试"><a href="#关键测试" class="headerlink" title="关键测试"></a>关键测试</h3><p>接口测试：</p><p>如下图所示，登录接口测试用Postman进行用户登录测试的过程。其中，发送了一个包含用户名和密码的POST请求到本地服务器，并成功接收到JSON格式响应数据。这表明登录操作被成功处理，用户被验证为“普通用户”。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192633876.png" alt="image-20240630192633876"></p><p>如下图所示，预约查询接口测试使用Postman来获取预约信息的过程。在图中，执行了一个GET请求至<a href="http://localhost:8989/reservations%E4%BB%A5%E6%9F%A5%E8%AF%A2%E9%A2%84%E7%BA%A6%E6%95%B0%E6%8D%AE%E3%80%82%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81200%E8%A1%A8%E6%98%8E%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E9%A1%BA%E5%88%A9%E3%80%82%E8%BF%94%E5%9B%9E%E7%9A%84JSON%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%90%AB%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E9%A2%84%E7%BA%A6%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%BF%99%E9%87%8C%E6%98%BE%E7%A4%BA%E4%BA%86%E4%B8%80%E6%9D%A1%E9%A2%84%E7%BA%A6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E3%80%82%E8%AF%A5%E9%A2%84%E7%BA%A6%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9A%E9%A2%84%E7%BA%A6ID%E4%B8%BA1%EF%BC%8C%E9%A2%84%E7%BA%A6%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%BA2%EF%BC%88%E5%8F%AF%E8%83%BD%E8%A1%A8%E7%A4%BA%E6%9F%90%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%94%E5%A6%82&quot;%E5%B7%B2%E7%A1%AE%E8%AE%A4&quot;%EF%BC%89%EF%BC%8C%E7%94%A8%E6%88%B7%E5%A7%93%E5%90%8D%E4%B8%BA%E7%A9%BA%EF%BC%8C%E9%A2%84%E7%BA%A6%E7%B1%BB%E5%9E%8B%E4%B8%BA&quot;%E8%AE%BE%E6%96%BD%E9%A2%84%E7%BA%A6&quot;%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BD%8D%E7%BD%AE%E4%B8%BA&quot;A2-209&quot;%EF%BC%8C%E9%A2%84%E7%BA%A6%E5%8E%9F%E5%9B%A0%E6%98%AF&quot;%E5%AD%A6%E4%B9%A0%E8%AE%A8%E8%AE%BA&quot;%E3%80%82%E9%A2%84%E7%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E6%96%BD%E5%8C%85%E6%8B%AC&quot;%E7%94%B5%E8%84%91%E5%92%8C%E6%8A%95%E5%BD%B1%E4%BB%AA&quot;%E3%80%82%E8%BF%99%E5%9B%BE%E6%9C%89%E6%95%88%E6%BC%94%E7%A4%BA%E4%BA%86%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87API%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BA%A6%E8%AF%A6%E6%83%85%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%91%E7%9D%A3%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E5%B0%A4%E4%B8%BA%E9%87%8D%E8%A6%81%E3%80%82">http://localhost:8989/reservations以查询预约数据。请求成功，状态码200表明查询过程顺利。返回的JSON响应数据包含一系列的预约信息，这里显示了一条预约的详细信息。该预约包含多个字段：预约ID为1，预约状态码为2（可能表示某种状态，比如&quot;已确认&quot;），用户姓名为空，预约类型为&quot;设施预约&quot;，具体位置为&quot;A2-209&quot;，预约原因是&quot;学习讨论&quot;。预约相关的设施包括&quot;电脑和投影仪&quot;。这图有效演示了如何通过API接口获取系统中的预约详情，这对于管理和监督预约系统尤为重要。</a></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192639167.png" alt="image-20240630192639167"></p><p>如下图所示，审核接口测试使用Postman执行PUT请求以修改预约信息的操作。请求成功执行，返回表明预约信息已经被成功更新。这表明API已经正确处理了修改预约信息的请求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps34.jpg" alt="img"> </p><p>如下图所示，获取用户列表接口测试使用Postman执行GET请求从服务器获取用户角色信息的过程。请求成功返回，展示了包括用户名、角色、电邮、电话和用户ID在内的详细信息，用于描绘系统中某个用户的权限和角色概况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps35.jpg" alt="img"> </p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>如下表3-10，这组测试用例关注于验证系统管理用户的功能，包括添加新用户，修改现有用户信息，以及删除用户。各个用例检验系统是否能够成功执行用户管理任务并给出适当的反馈消息。</p><p>表3-10 管理用户测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>添加新用户</td><td>检验添加用户功能的执行</td><td>成功添加用户，系统显示添加成功消息</td><td>成功添加，消息正确显示</td></tr><tr><td>修改现有用户信息</td><td>检验修改用户信息的正确性</td><td>成功修改用户信息，系统显示更新成功消息</td><td>修改成功，消息正确显示</td></tr><tr><td>删除用户</td><td>检验删除用户的功能</td><td>成功删除用户，系统显示删除成功消息</td><td>用户成功删除，确认消息显示</td></tr></tbody></table><p>如下表3-11，测试用例集中于系统的用户搜索功能，包括对存在的用户的精确搜索，对不存在用户的搜索处理，以及使用模糊匹配进行的多用户搜索，确认系统能否在这些情况下准确显示用户信息或相关提示。</p><p>表3-11 搜索用户测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>搜索存在的用户</td><td>检验搜索功能的准确性</td><td>系统正确显示匹配的用户信息</td><td>搜索成功，用户信息准确显示</td></tr><tr><td>搜索不存在的用户</td><td>测试系统的搜索容错能力</td><td>系统显示无结果，提示用户找不到匹配信息</td><td>搜索结果为空，系统正确显示无匹配信息提示</td></tr><tr><td>使用模糊匹配搜索多个用户</td><td>检验模糊搜索功能的效果</td><td>系统显示所有相关匹配的用户信息</td><td>模糊搜索成功，相关用户信息被展示</td></tr></tbody></table><p>如下表3-12，这些测试用例旨在评估系统在显示自习室使用统计信息上的表现，无论是在没有使用记录的情况下还是有使用记录时，系统都应正确显示相关统计信息。</p><p>表3-12 查看使用统计测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>没有任何自习室使用记录时查看统计</td><td>检验统计功能正常情况下的显示</td><td>统计结果显示无使用记录</td><td>系统正确显示无使用记录</td></tr><tr><td>自习室有使用记录时查看统计</td><td>检验统计功能反映实际使用情况</td><td>统计结果详细反映每个自习室的使用情况</td><td>统计正确，详细展示每个自习室的使用记录</td></tr></tbody></table><p>如下表3-13，这一组测试用例检查系统在不同情况下（全部空闲、部分预约、全部预约满）展示自习室状态的准确性。</p><p>表3-13 查看自习室情况测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>自习室全部空闲时进行查看</td><td>检查系统显示所有自习室空闲情况</td><td>系统显示所有自习室处于空闲状态</td><td>系统正确显示所有自习室空闲状态</td></tr><tr><td>自习室部分被预约时进行查看</td><td>检查系统显示部分自习室预约情况</td><td>系统显示部分自习室被预约，其余空闲</td><td>系统正确反映部分自习室被预约，其余空闲</td></tr><tr><td>自习室全部被预约满时查看</td><td>检查系统显示所有自习室被预约情况</td><td>系统显示所有自习室处于被预约状态</td><td>系统正确显示所有自习室被预约状态</td></tr></tbody></table><p>如下表3-14，用例专注于系统处理自习室预约的能力，包括成功预约空闲的自习室、处理预约冲突以及连续预约多间自习室的情况，确保系统在这些场景下能正确执行并提供反馈。</p><p>表3-14 预约自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>预约一间未被预约的自习室</td><td>测试能否成功预约自习室</td><td>成功预约，系统显示预约成功信息</td><td>预约成功，系统显示预约成功信息</td></tr><tr><td>尝试预约已被他人预约满的自习室</td><td>测试系统处理冲突预约的能力</td><td>系统显示错误信息，指出自习室已被预约</td><td>尝试失败，系统正确显示错误信息</td></tr><tr><td>连续预约多间自习室</td><td>测试系统处理多项预约的能力</td><td>成功预约多间自习室，显示预约成功信息</td><td>成功预约多间，系统正确显示预约成功信息</td></tr></tbody></table><p>如下表3-15，测试集包括检验用户取消自己之前成功的自习室预约，并测试系统防止用户撤销他人预约的安全性和权限管理。目的是确保系统在处理取消操作时既符合预期又维护了适当的访问控制。</p><p>表3-15 取消预约测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>取消自己之前成功预约的自习室</td><td>测试能否取消自己的预约</td><td>成功取消预约，系统显示取消成功信息</td><td>预约取消成功，实际结果与预期相符</td></tr><tr><td>尝试取消他人的预约</td><td>测试系统的安全性和权限管理</td><td>系统显示错误信息，不允许取消他人预约</td><td>系统正确显示错</td></tr></tbody></table><p>如下表3-16，这些用例测试系统如何处理自习室的删除请求，包括已安排和未安排预约的自习室，以及尝试删除不存在的自习室。这一系列测试旨在确保删除操作在不同状况下被正确处理，提供适当的反馈和错误处理。</p><p>表3-16 删除自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>删除系统中未被预约的自习室</td><td>检验删除功能的正常逻辑</td><td>成功删除，系统更新状态表示自习室已删除</td><td>成功删除自习室，系统正确显示删除状态</td></tr><tr><td>删除系统中已被预约的自习室</td><td>检验系统如何处理预约中的删除请求</td><td>系统阻止删除或需特殊处理</td><td>系统成功阻止删除，提示自习室正在被预约中</td></tr><tr><td>尝试删除不存在的自习室</td><td>测试系统的错误处理能力</td><td>系统显示错误信息，删除失败</td><td>系统正确显示错误信息，指出自习室不存在</td></tr></tbody></table><p>如下表3-17，此部分测试用例关注于系统添加新自习室的功能，验证系统如何处理新自习室的添加，包括重复自习室编号的错误处理和在信息输入不完整时的系统反馈。</p><p>表3-17 添加自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>成功在系统中添加一个新的自习室</td><td>检验添加功能的正常逻辑</td><td>系统显示添加成功并更新自习室列表</td><td>添加成功，系统正确显示自习室列表更新</td></tr><tr><td>尝试添加已存在的自习室编号</td><td>测试系统处理重复添加的能力</td><td>系统显示错误，指出自习室编号重复</td><td>系统成功显示错误信息，防止重复添加</td></tr><tr><td>添加自习室时未填写完整信息</td><td>测试系统的输入验证功能</td><td>系统显示错误并要求必要信息完整</td><td>系统正确显示错误，要求填写必要信息</td></tr></tbody></table><p>如下表3-18，这组测试用例评估了修改自习室信息的功能，测试了合法和非法修改案例，包括尝试修改不存在的自习室以及输入非法数据时的系统响应。目标是验证系统在更新自习室信息时的可靠性和错误处理能力。</p><p>表3-18 修改自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>修改自习室的信息</td><td>检验修改功能的正常逻辑</td><td>成功修改，系统显示更新成功消息</td><td>修改成功，系统正确显示更新成功消息</td></tr><tr><td>尝试修改不存在的自习室信息</td><td>测试系统的错误处理能力</td><td>系统显示错误信息，修改失败</td><td>系统正确显示错误信息，指出自习室不存在</td></tr><tr><td>修改自习室信息时输入非法数据</td><td>测试系统的输入验证功能</td><td>系统显示错误信息，阻止修改</td><td>系统正确显示错误，防止了无效的修改</td></tr></tbody></table><h3 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h3><p>在对自习室预约系统进行细致的测试后，我们发现系统在多数关键功能上运作正常且符合预设需求。通过模拟普通用户的各种情境，如查看自习室预约状态、预约和取消自习室，系统显示了良好的反馈和正确管理冲突的能力。管理员功能测试表明，添加、删除和修改自习室的操作均得以准确执行，系统妥善处理了包括预约中的自习室不能被删除的逻辑。超级管理员的权限测试也验证了其对整个系统用户和统计信息的完全控制能力。模拟的实际结果与预期结果大致一致，验证了系统的可靠性和用户界面的友好性。然而，存在的一些预期外情况建议我们在未来增强输入验证、错误提示和系统的异常处理机制，特别是在处理重复数据和非法输入时。总体来说，自习室预约系统表现出了良好的稳定性和功能完整性，适合进行下一阶段的用户验收测试和进一步开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个项目中，我使用Spring Boot作为后端框架，并结合Element Plus和Vue作为前端框架，构建了一个功能齐全的应用程序。Spring Boot提供了快速搭建后端服务的方式，支持依赖注入、自动配置和开发工具，极大地提升了开发效率，并能轻松集成各种第三方库。前端方面，Element Plus提供了一套漂亮易用的UI组件，而Vue则简化了数据绑定和组件开发，使前端代码更易维护和扩展。通过将后端和前端分离开发和部署，利用RESTful API进行通信，系统保持了松散耦合和易扩展性。我实现了用户管理功能，如登录、注册、获取和修改个人信息、搜索用户和查看所有用户等，并使用Spring Security进行权限控制，确保只有特定权限的用户能访问相应接口。项目中，用户管理功能包括注册、登录、获取和修改个人信息，这些操作通过Spring Boot的RESTful API实现，前端通过Axios进行请求处理。为了确保系统的安全性，我使用Spring Security进行权限控制，确保只有特定权限的用户可以访问相应的接口。这个项目集成了Spring Boot、Element Plus和Vue等技术，增强了我对这些技术的理解，并为今后的开发工作提供了良好的基础和参考。通过这个项目，我深刻体会到合适的技术栈能够极大地提升开发效率和系统质量，前后端分离开发的优势使得开发过程更加高效，细粒度的权限控制确保了系统的安全性，而组件化开发使得代码更加模块化和可维护。总之，这个项目不仅提升了我的技术能力，也让我对系统架构设计、用户体验和安全性有了更深刻的理解。</p>]]></content>
      
      
      <categories>
          
          <category> javaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Server Details</title>
      <link href="/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/"/>
      <url>/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/</url>
      
        <content type="html"><![CDATA[<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><ul><li>是AWS Elastic Block Store(EBS)提供了用于EC2实例的<strong>块存储卷</strong></li><li>设计用来提供高可靠性和高性能的存储<h2 id="块存储卷"><a href="#块存储卷" class="headerlink" title="块存储卷"></a>块存储卷</h2></li><li>是一种数据存储技术，将存储空间分割成固定大小的“块”，每个块可以像独立硬盘一样被单独管理和操作</li><li>低级别数据处理（能够在较低的操作系统级别进行数据处理），高性能（块存储可以与操作系统直接交互），独立性（在没有文件系统的情况下存在，不会存储任何文件结构或元数据），灵活性（轻松扩展或调整大小），可访问性（能够通过存储区域网络（san），互联网协议（ip）网络或本地连接进行访问。）</li></ul><h2 id="持久性存储"><a href="#持久性存储" class="headerlink" title="持久性存储"></a>持久性存储</h2><p>EBS卷在EC2实例终后仍然存在，可以在创建EC3实例时候将其删除。</p><h2 id="多种卷类型"><a href="#多种卷类型" class="headerlink" title="多种卷类型"></a>多种卷类型</h2><h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><ul><li>是一个衡量计算存储设备性能的指标，表示每秒可以完成的输入/输出操作次数。这个指标通常用于评估硬盘驱动器（HDD）、固态硬盘（SSD）、存储区域网络（SAN）和网络附加存储（NAS）等存储设备的性能。</li></ul><p>IOPS高低的因素：</p><ol><li>存储介质：SSD通常提供比HDD更高的IOPS，因为SSD没有移动部件，数据访问速度更快。</li><li>数据块大小：通常较小的数据块会产生更高的IOPS数，每个操作处理的数据量更少。</li><li>读写模式：IOPS性能可能会根据读写操作的比例而变化。一般来说，读写操作的IOPS高于写操作</li><li>并发和队列深度：多个并发操作和更深的队列深度可以提高IOPS，但也可能增加延迟。</li><li>随机与顺序访问：随机I/O操作通常比顺序I/O操作有更低的IOPS，存储设备需要在不同位置寻找数据，尤其是在使用传统的机械硬盘时。</li></ol><h4 id="硬盘驱动器（HDD）"><a href="#硬盘驱动器（HDD）" class="headerlink" title="硬盘驱动器（HDD）"></a>硬盘驱动器（HDD）</h4><ul><li>一种创痛的机械存储设备，具有较大的存储容量和较低的成本</li></ul><h4 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h4><ul><li>是一种基于闪存存储技术的存储设备，具有更快的数据访问速度，更多的访问延迟和更高的可靠性，但是SSD的加个通常比HDD高，存储容量也很较小</li></ul><h4 id="存储区域网络（SAN）"><a href="#存储区域网络（SAN）" class="headerlink" title="存储区域网络（SAN）"></a>存储区域网络（SAN）</h4><ul><li>是一种专用网络，用于连接存储设备和计算设备。SAN通过高速网络连接将存储资源提供给计算设备，使其能够访问和共享存储数据，SAN通常用于大规模企业环境中，提供高性能，高可靠性和可扩展性的存储解决方案。</li></ul><h4 id="网络附加存储（NAS）"><a href="#网络附加存储（NAS）" class="headerlink" title="网络附加存储（NAS）"></a>网络附加存储（NAS）</h4><ul><li>通过网络连接提供文件级别存储服务的设备，NAS设备通常是独立的存储服务器，可以通过网络协议（NFS或SMB）共享文件，使多个计算设备能够访问和共享存储数据。NAS适用与小型办公环境或家庭用户，提供简单的文件共享和备份功能。</li></ul><h3 id="通用型SSD（gp2和gp3）"><a href="#通用型SSD（gp2和gp3）" class="headerlink" title="通用型SSD（gp2和gp3）"></a>通用型SSD（gp2和gp3）</h3><ul><li>提供平衡的性能和成本，适用与广泛的应用。gp2卷提供基于卷大小的IOPS，而gp3则允许用户独立选择和调整IOPS和吞吐量，与卷大小没有关系</li><li><strong>应用场景：</strong> gp2适用于大多数工作负载，如虚拟桌面，中小型数据库，开发和测试环境。gp3是更新的版本，适用于需要可预测的性能和价格的应用程序</li></ul><h3 id="预置IOPS-SSD（io1和io2）"><a href="#预置IOPS-SSD（io1和io2）" class="headerlink" title="预置IOPS SSD（io1和io2）"></a>预置IOPS SSD（io1和io2）</h3><ul><li>提供高性能的IOPS，适用于I/O密集型的数据库和应用程序，io2提供更高的耐久性和IOPS效率</li><li><strong>应用场景：</strong>高性能数据库，如大型关系型数据库或NoSQL数据库，以及需要高吞吐量和低延迟的关键业务应用程序。</li></ul><h3 id="吞吐量优化HDD（st1）"><a href="#吞吐量优化HDD（st1）" class="headerlink" title="吞吐量优化HDD（st1）"></a>吞吐量优化HDD（st1）</h3><ul><li>低成本HDD卷。适用于频繁访问的，吞吐量密集型工作负载。</li><li><strong>应用场景：</strong>大数据，数据仓库，日志处理等需要大量顺序读写操作的应用程序。</li></ul><h3 id="Cold-HDD（st1）"><a href="#Cold-HDD（st1）" class="headerlink" title="Cold HDD（st1）"></a>Cold HDD（st1）</h3><ul><li>最低成本的HDD卷，适用于较少访问的工作负载。</li><li><strong>应用场景：</strong>适合用于冷数据存储，如备份和灾难恢复。</li></ul><h3 id="磁带（standard）"><a href="#磁带（standard）" class="headerlink" title="磁带（standard）"></a>磁带（standard）</h3><ul><li>之前的基础性能HDD卷，现在以及不推荐使用，因为AWS提供更高性能和成本效益更高的选项。</li></ul><h3 id="选择EBS卷类型，考虑因素"><a href="#选择EBS卷类型，考虑因素" class="headerlink" title="选择EBS卷类型，考虑因素"></a>选择EBS卷类型，考虑因素</h3><ul><li>性能：IOPS，吞吐，延迟</li><li>数据访问频率，频繁访问的数据适合SSD，偶尔访问的数据适合HDD。</li><li>成本：预算和成本效益</li><li>耐久性和可用性：重要应用程序可能需要更高的耐久性和可用性</li></ul><h2 id="快照功能"><a href="#快照功能" class="headerlink" title="快照功能"></a>快照功能</h2><ul><li>创建EBS卷的快照，并存储在S3中，用于数据备份和恢复</li><li>快照捕获了某一时刻卷上的数据状态，并将这些数据存储在S3中<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3>对一个EBS卷进行快照备份时，仅仅是新的或者被修改过的块会被保存在S3。如果创建了多个快照，S3不会为未更改的块进行重复存储，而是自上次快照以来变化的块。</li></ul><h3 id="持久性和可靠性"><a href="#持久性和可靠性" class="headerlink" title="持久性和可靠性"></a>持久性和可靠性</h3><p>快照在S3上，是一个高持久性的存储服务，数据会自动复制到多个设施，确保其耐久性。</p><h3 id="点对点复制"><a href="#点对点复制" class="headerlink" title="点对点复制"></a>点对点复制</h3><p>可以跨AWS区域复制，对于灾难恢复和数据中心迁移非常有用。</p><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>原始EBS卷加密，快照也会自动加密。同样，从加密快照创建任何新的EBS卷也会自动假面。</p><h3 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h3><p>快照是增量的，所以它们通常比完整卷备份更加经济。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>允许自动创建和删除快照，便于用户按照自定义的策略维护快照</p><h3 id="共享或私有"><a href="#共享或私有" class="headerlink" title="共享或私有"></a>共享或私有</h3><p>快照可以与特定的AWS账户共享，或者公开共享给所有AWS用户。允许数据和配置的共享，同时支持软件供应商分发产品。</p><h1 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h1><ul><li>是Amazon Simple Storage Service一个对象存储服务</li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><ul><li>无限存储：S3提供几乎无限的存储空间，可以在需要时随时存储和检索任意数量数据</li><li>自动扩展：其实没有s3自动扩展这说法，只是他会适应存储数据量，无需手动去干预</li></ul><h2 id="数据可用性和持久性"><a href="#数据可用性和持久性" class="headerlink" title="数据可用性和持久性"></a>数据可用性和持久性</h2><ul><li>高持久性：S3提供99.999999999%的持久性，确保数据不会因为硬件问题而丢失<h3 id="多区域复制"><a href="#多区域复制" class="headerlink" title="多区域复制"></a>多区域复制</h3></li><li>多区域复制是一项功能，允许自动复制S3存储桶中对象到一个或者多个不同AWS区域的目标存储桶中<h4 id="数据复制策略"><a href="#数据复制策略" class="headerlink" title="数据复制策略"></a>数据复制策略</h4></li><li>可以设置复制策略来指定哪些数据需要被复制，可以是存储桶中的所有数据，也可以是符合特定前缀或标签的数据</li></ul><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><ul><li>多区域复制要求源存储桶启动版本控制，确保每个版本对象都会被复制到目标存储桶</li></ul><h4 id="延迟和一致性"><a href="#延迟和一致性" class="headerlink" title="延迟和一致性"></a>延迟和一致性</h4><p>复制操作通常是异步的，到目标区域会有延迟</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><p>多区域复制会产生额外的成本，包括数据传输费用和目标区域存储的费用</p><h4 id="数据加密-1"><a href="#数据加密-1" class="headerlink" title="数据加密"></a>数据加密</h4><p>支持复制过程中，用AWS提供的加密键（SSE-S3或SSE-KMS）或自己的加密键位（SSE-C）</p><h5 id="SSE-S3"><a href="#SSE-S3" class="headerlink" title="SSE-S3"></a>SSE-S3</h5><ul><li>是Amazon S3提供的服务端加密的一种方式，会自动使用多租户硬件安全模块HSM管理的密钥进行数据加密<br>如何工作：</li><li>当上传文件到S3时，可以指定使用SSE-S3进行加密</li><li>S3会为每个保存的对象生成一个唯一的密钥，使用该密钥对数据进行加密，把加密的数据保存的存储中</li><li>将每个对象的密钥进一步使用一个主密钥进行加密，这个主密钥是定期轮换的</li><li>访问数据时，会自动处理解密过程，可以像访问未加密的数据一样访问加密数据</li></ul><p>特点：<br>简单易用：SSE-S3 的操作非常简单，只需要在上传对象时指定使用 SSE-S3 加密即可，其余的加密和解密过程都由 Amazon S3 自动管理。<br>透明：对于使用 SSE-S3 加密的数据，用户在访问时不会感觉到任何不同，因为加密和解密都是透明进行的。<br>安全性：使用 SSE-S3 加密的数据，其密钥管理和保护是由 AWS 的硬件安全模块（HSM）来完成的，这提供了很高的安全保障。<br>自动加密：默认情况下，所有新的 S3 存储桶都会自动使用 SSE-S3 加密新上传的对象，除非您指定了其他加密方式。</p><p>注意事项：<br>性能影响：使用 SSE-S3 加密可能会对性能产生微小的影响，因为每次读取和写入操作都需要进行加密和解密操作。<br>成本：虽然 AWS 不额外收费用于 SSE-S3 加密，但是如果您使用了 S3 提供的额外密钥管理功能，如 AWS Key Management Service (KMS)，则可能会产生额外费用。<br>权限：如果您的 AWS Identity and Access Management (IAM) 策略不允许使用 SSE-S3，那么尝试上传文件时可能会遇到权限问题。</p><h5 id="SSE-KMS"><a href="#SSE-KMS" class="headerlink" title="SSE-KMS"></a>SSE-KMS</h5><ul><li>是Amazon S3的另一种服务端加密选项，提供更多的用户控制权和审计跟踪</li><li>如何工作：<br>当您启用 SSE-KMS 时，您可以选择使用由 KMS 管理的默认服务密钥，也可以在 KMS 中创建自己的客户主密钥（CMK）。<br>当您上传数据到 S3 时，您需要指定使用 KMS 密钥进行加密。<br>S3 将与 KMS 通信，使用指定的 CMK 对数据进行加密，并将加密的数据保存到存储中。<br>当您需要读取数据时，S3 将请求 KMS 解密数据，然后将解密后的数据返回给您。</li></ul><p>特点：<br>用户控制的密钥：您可以创建、管理和使用您自己的加密密钥，也可以使用由 AWS 管理的默认密钥。<br>密钥轮换：KMS 支持自动轮换密钥，提高了安全性。<br>审计日志：与 KMS 集成的 AWS CloudTrail 提供了密钥使用情况的审计日志，方便审计和合规。<br>细粒度权限：您可以使用 IAM 策略精确控制谁可以使用哪些密钥来加密和解密数据。</p><p>注意事项：<br>性能影响：与 SSE-S3 类似，使用 SSE-KMS 也可能会对性能产生微小的影响，尤其是在加密和解密操作时。<br>成本：使用 KMS 管理的密钥可能会产生额外的费用，包括密钥存储费用和密钥使用费用。<br>权限管理：需要确保适当的 IAM 策略和权限设置，以便用户可以正确地使用 KMS 密钥。</p><h4 id="权限和角色"><a href="#权限和角色" class="headerlink" title="权限和角色"></a>权限和角色</h4><p>适当IAM角色和权限来设置和管理多区域复制</p><h2 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h2><ul><li>数据加密：S3支持服务端加密数据，以及在传输过程中使用SSL/TLS加密数据</li></ul><h3 id="过程中SSL-TLS加密"><a href="#过程中SSL-TLS加密" class="headerlink" title="过程中SSL/TLS加密"></a>过程中SSL/TLS加密</h3><ul><li>机密协议：AWS S3使用的是SSL/TLS协议在加密传输中的数据，确保互联网安全</li><li>自动加密： 通过HTTPS向S3上传或从S3下载数据时候，SSL/TLS加密是自动应用的，以为这无需进行额外的配置</li><li>端点安全：使用HTTPS连接可以确保您的数据在从客户端到S3端点的整个路径上都是加密的。</li><li>与存储中加密的区别：需要注意的是，传输中加密与存储中加密（例如S3的服务器端加密）是不同的。存储中加密关注的是数据在S3存储桶中处于静止状态时的加密，而传输中加密关注的是数据移动时的安全性。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>优化的性能：S3 提供了优化的性能，尤其是对于分布式应用和大数据工作负载。<br>并行传输：S3 支持多部分上传和下载，使得大文件可以分成小块并行处理，提高数据传输速度。</p><h2 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h2><p>生命周期管理：S3 提供了生命周期管理策略，允许你自动转移或删除在一定时间后不再需要的数据。<br>存储类别：S3 提供多种存储类别，如 S3 Standard、S3 Intelligent-Tiering、S3 Standard-IA（低频访问）、S3 One Zone-IA（单可用区低频访问）和 S3 Glacier（用于长期存档），以适应不同的成本和访问频率需求。<br>监控和日志记录：S3 提供了监控工具，如 S3 访问日志和 AWS CloudTrail，以及与 Amazon CloudWatch 的集成，以便于监控和记录存储操作。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>存储在S3的数据可以用各种AWS的分析服务</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>数据分析服务可以有<a href="#amazon-athena">Amazon Athena</a>,<a href="#amozon-redshift">Amozon Redshift</a>,<a href="#amazon-emr">Amazon EMR</a></p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>数据转换服务可以有<a href="#aws-glue">AWS Glue</a> ，<a href="#aws-data-pipeline">AWS Data Pipeline</a> ，<a href="#aws-lambda">AWS Lambda</a></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>AWS提供了一系列机器学习服务，如<a href="#amazon-sagemaker">Amazon SageMaker</a>、<a href="#amazon-rekognition">Amazon Rekognition</a>、<a href="#amazon-comprehend">Amazon Comprehend</a>等，可以在S3上的数据上构建和训练机器学习模型。</p><h2 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h2><h3 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h3><ul><li>检索速度必然是比S3存储要长的，主要是因为大数量和低频访问</li><li>S3 Glacier的检索会产生额外的检索费用，取决于数据大小和检索速度</li><li>可指定检索选项</li></ul><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>可以用生命周期策略自动将数据从S3标准存储转移到S3 Glacier</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一般都是在需要存储大量数据但又不经常访问的场景</p><h1 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h1><h2 id="DNS功能"><a href="#DNS功能" class="headerlink" title="DNS功能"></a>DNS功能</h2><p>域名注册与转移：Route 53 允许用户注册新的域名或将现有域名从其他注册商转移到 AWS。</p><p>托管区域（Hosted Zones）：在 Route 53 中，托管区域是一个容器，它包含了处理一个域名及其子域名的 DNS 记录。托管区域分为公有托管区域和私有托管区域。</p><p>DNS 记录类型：Route 53 支持多种 DNS 记录类型，包括 A (地址记录)，AAAA (IPv6 地址记录)，CNAME (规范名称记录)，MX (邮件交换记录)，TXT (文本记录)，NS (名称服务器记录) 和 SOA (起始授权机构记录) 等。</p><p>路由策略：Route 53 提供多种路由策略，如简单路由、加权路由、延迟路由、故障转移路由和地理位置路由等，允许用户根据不同的条件来路由流量。</p><p>别名记录：Route 53 的别名记录允许将一个域名映射到 AWS 资源，例如 Amazon S3 存储桶、Elastic Load Balancing (ELB) 负载均衡器或另一个 Route 53 托管区域中的域名。与 CNAME 记录不同，别名记录可以用于域名的根节点（例如 example.com）。</p><p>DNS 查询日志：用户可以配置 Route 53 以记录所有对托管区域的 DNS 查询，这有助于调试和监控 DNS 活动。</p><p>DNSSEC：Route 53 支持 DNS 安全扩展 (DNSSEC)，这是一种增强 DNS 安全性的协议，可以保护域名解析过程不被篡改。</p><p>全球分布的 DNS 服务器：Route 53 使用全球分布的 DNS 服务器和 Anycast 路由技术，确保 DNS 查询响应迅速且可靠。</p><h3 id="DNSSEC安全扩展"><a href="#DNSSEC安全扩展" class="headerlink" title="DNSSEC安全扩展"></a>DNSSEC安全扩展</h3><p>保护互联网用户免受伪造DNS数据（缓存投毒）的攻击，通过对DNS响应进行数字签名</p><p>主要步骤：<br>生成密钥：为每一个DNS区域生成一次公钥和私钥。</p><p>签名记录：使用私钥对DNS区域中RRsets进行签名，签名存储再DNS作为性的记录类型，称为DNSSEC签名（RRSIG）记录。</p><p>分发公钥：将公钥作为DNSKEY记录分发再DNS中，以便任何人都可以用它来验证签名</p><p>链式信任：DNSSEC 使用一种链式信任模型，其中每个级别的 DNS 区域都会签署其下一级别的区域的密钥。这个链条一直延伸到根域名服务器，它的密钥被称为根密钥，是整个信任链的基础。</p><p>验证：当客户端（如 DNS 解析器）收到 DNSSEC 保护的响应时，它会使用存储在 DNS 中的公钥来验证响应的签名。如果验证成功，客户端可以确信该响应是未被篡改的。</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><h4 id="简单路由："><a href="#简单路由：" class="headerlink" title="简单路由："></a>简单路由：</h4><p>到单个资源，域名指向一个IP地址或一个Amazon S3 存储桶</p><h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><ul><li>单一资源服务，单个web服务器或单个Amazon S3存储桶</li><li>不需要复杂的路由决策的简单域名分析</li></ul><h4 id="加权路由："><a href="#加权路由：" class="headerlink" title="加权路由："></a>加权路由：</h4><p>允许你分配不同的权重给相同域名下的多个资源，从而控制流量的分配比例。这对于流量切换和 A/B 测试非常有用。</p><h5 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h5><ul><li>A/B 测试，将流量按照一定比例分配给不同的应用版本。</li><li>平滑的流量迁移，逐渐增加指向新资源的流量比例。</li><li>负载分配，根据服务器能力分配不同的权重。</li></ul><h4 id="延迟路由"><a href="#延迟路由" class="headerlink" title="延迟路由"></a>延迟路由</h4><p>根据用户到 AWS 区域的网络延迟自动路由用户请求。这有助于向用户提供最低延迟的响应。</p><h5 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h5><ul><li>多区域部署，根据用户到 AWS 区域的延迟选择最佳路由。</li><li>性能优化，确保用户获得最快的响应时间。</li></ul><h4 id="故障转移路由"><a href="#故障转移路由" class="headerlink" title="故障转移路由"></a>故障转移路由</h4><p>在主要资源发生故障时，自动将流量切换到备份资源。这对于实现高可用性和灾难恢复非常关键。</p><h5 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h5><ul><li>灾难恢复，当主要资源发生故障时自动切换到备用资源。</li><li>高可用性配置，配合健康检查确保服务不间断<h4 id="地理位置路由"><a href="#地理位置路由" class="headerlink" title="地理位置路由"></a>地理位置路由</h4>根据用户的地理位置将流量路由到特定的资源。这可以用于内容本地化或遵守地理位置相关的法律法规。</li></ul><h5 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h5><ul><li>地理目标定位，向特定地理区域的用户提供定制化内容。</li><li>法规遵从，确保数据存储和处理遵守特定地区的法律法规。</li><li>负载分散，将用户流量分散到不同的区域以减轻特定服务器的负载。<h4 id="地理位置优先路由"><a href="#地理位置优先路由" class="headerlink" title="地理位置优先路由"></a>地理位置优先路由</h4>根据用户和资源之间的地理位置距离来路由流量。可以通过使用“偏置值”来调整流量的分配<h5 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h5></li><li>地理位置敏感的负载均衡，更精细地控制基于用户位置的流量分配。</li><li>业务扩展，根据业务需求和用户位置动态调整流量。<h4 id="多值答案路由"><a href="#多值答案路由" class="headerlink" title="多值答案路由"></a>多值答案路由</h4>当你想要 Route 53 返回多个资源的 IP 地址，并且希望 Route 53 对这些资源进行健康检查时，可以使用这种策略。</li></ul><h5 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h5><ul><li>提供了内置健康检查的简单负载均衡。</li><li>当有多个资源可以提供服务时，增加系统的容错能力。</li><li>需要从多个资源中返回单个或多个健康资源的 IP 地址。</li></ul><h2 id="Route-53-的Best-Match"><a href="#Route-53-的Best-Match" class="headerlink" title="Route 53 的Best Match"></a>Route 53 的Best Match</h2><h3 id="与EC2配合实现静态网站托管"><a href="#与EC2配合实现静态网站托管" class="headerlink" title="与EC2配合实现静态网站托管"></a>与EC2配合实现静态网站托管</h3><ul><li>Route 53 可以将流量路由运行在Amazon EC2实例上的应用程序</li><li>使用故障转移路由来监控EC2实例的健康状况，在需要时将流量自动切换到备用实例</li></ul><h3 id="与ELB配合实现高可用性和负载均衡"><a href="#与ELB配合实现高可用性和负载均衡" class="headerlink" title="与ELB配合实现高可用性和负载均衡"></a>与ELB配合实现高可用性和负载均衡</h3><ul><li>ELB自动分配进来的应用流量到多个EC2实例，以提高容错能力和可伸缩性</li><li>Route 53可以直接与ELB集成，将域名解析到ELB的DNS名称，而不是特定的IP地址</li></ul><h3 id="与S3配合实现静态网站托管"><a href="#与S3配合实现静态网站托管" class="headerlink" title="与S3配合实现静态网站托管"></a>与S3配合实现静态网站托管</h3><ul><li>可以以将域名解析到一个Amazon存储桶，这个存储桶配置为静态网站</li></ul><h3 id="与Lambda和API-Gateway配合实现无服务器架构"><a href="#与Lambda和API-Gateway配合实现无服务器架构" class="headerlink" title="与Lambda和API Gateway配合实现无服务器架构"></a>与Lambda和API Gateway配合实现无服务器架构</h3><ul><li>Route 53 可以将流量路由到一个API Gateway，后者触发Lambda函数来处理请求</li><li>架构可以构建完全无服务器的应用，轻松扩展且成本效益高</li></ul><h3 id="与CloudFront配合实现全球内容分发"><a href="#与CloudFront配合实现全球内容分发" class="headerlink" title="与CloudFront配合实现全球内容分发"></a>与CloudFront配合实现全球内容分发</h3><ul><li>将用户请求解析到最近的CloudFront边缘位置，加速内容的分发</li></ul><h3 id="与shield配合实现防御分布式拒绝服务DDOS攻击"><a href="#与shield配合实现防御分布式拒绝服务DDOS攻击" class="headerlink" title="与shield配合实现防御分布式拒绝服务DDOS攻击"></a>与shield配合实现防御分布式拒绝服务DDOS攻击</h3><ul><li>托管型DDos防护服务，可以保护在AWS上运行的应用不受DDos攻击</li></ul><h3 id="与WAF配合实现应用层防护"><a href="#与WAF配合实现应用层防护" class="headerlink" title="与WAF配合实现应用层防护"></a>与WAF配合实现应用层防护</h3><ul><li>是一种Web应用防火墙，保护Web应用免受常见的网络和应用层攻击。</li><li>为域名提供基于规则的控制，防止恶意流量到达应用</li></ul><h3 id="与RDS实现数据库故障转移"><a href="#与RDS实现数据库故障转移" class="headerlink" title="与RDS实现数据库故障转移"></a>与RDS实现数据库故障转移</h3><ul><li>Route 53 可以与Amazon RDS配合实现数据库的故障转移和读取复制</li></ul><h3 id="与VPC配合使用构建私有云解析和内部域名服务"><a href="#与VPC配合使用构建私有云解析和内部域名服务" class="headerlink" title="与VPC配合使用构建私有云解析和内部域名服务"></a>与VPC配合使用构建私有云解析和内部域名服务</h3><ul><li>通过私有托管区域，企业可以管理内部域名，而这些域名不会被路由到公共互联网上</li></ul><h3 id="与Transit-Gateway实现多区域网络连接"><a href="#与Transit-Gateway实现多区域网络连接" class="headerlink" title="与Transit Gateway实现多区域网络连接"></a>与Transit Gateway实现多区域网络连接</h3><ul><li>AWS Transit Gateway 允许连接多个 VPC 和本地网络，形成一个中心式的网络枢纽。</li><li>Route 53 可以用来解析跨这些连接的 VPCs 内部的服务名称。</li></ul><h3 id="与-AWS-Direct-Connect-配合混合云环境"><a href="#与-AWS-Direct-Connect-配合混合云环境" class="headerlink" title="与 AWS Direct Connect 配合混合云环境"></a>与 AWS Direct Connect 配合混合云环境</h3><ul><li>AWS Direct Connect 通过私有连接将企业数据中心连接到 AWS，绕过公共互联网，提高安全性和带宽。</li><li>Route 53 可以用来解析通过 Direct Connect 连接的资源，保证内部和外部解析的一致性。</li></ul><h3 id="与ACM构建SSL-TLS证书管理"><a href="#与ACM构建SSL-TLS证书管理" class="headerlink" title="与ACM构建SSL/TLS证书管理"></a>与ACM构建SSL/TLS证书管理</h3><ul><li>简化了SSL/TLS证书的获取，管理和部署过程</li><li>自动使用DNS验证来验证域名的所有权并且自动续签证书</li></ul><h3 id="与EC2和EKS构建容器化应用和微服务"><a href="#与EC2和EKS构建容器化应用和微服务" class="headerlink" title="与EC2和EKS构建容器化应用和微服务"></a>与EC2和EKS构建容器化应用和微服务</h3><ul><li>ECS和EKS提供容器服务</li><li>Route 53可以与ECS和EKS集成，通过服务发现机制自动注册和解除注册容器实例，使微服务架构中的服务能够相互发现和通信</li></ul><h1 id="稍微理解"><a href="#稍微理解" class="headerlink" title="稍微理解"></a>稍微理解</h1><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend +"></a>Amazon Comprehend +</h2><ul><li>一项自然语言（NLP）服务，使用机器学习技术赖解析文本中的洞察和关系</li></ul><ol><li><strong>实体识别（Entity Recognition）</strong>：能够识别文本中的具体实体，如人名、地点、品牌或其他专有名词。</li><li><strong>情感分析（Sentiment Analysis）</strong>：分析文本的情感倾向，判断它是正面的、负面的、中性的还是复合情感的。</li><li><strong>关键词提取（Key Phrase Extraction）</strong>：从文本中提取重要的或者有意义的短语。</li><li><strong>语言识别（Language Detection）</strong>：自动识别文本所使用的语言。</li><li><strong>句法分析（Syntax Analysis）</strong>：分析文本中的语言构成，比如词性标注和句子成分分析。</li><li><strong>主题建模（Topic Modeling）</strong>：识别文档集合中的主题模式。</li></ol><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p><strong>Amazon Rekognition</strong> 是一项基于深度学习的图像和视频分析服务。它可以识别图像和视频中的对象、场景、文字以及人脸。Rekognition 提供了多种功能，包括：</p><ul><li><strong>人脸分析</strong>：识别人脸、检测面部特征、评估情绪等。</li><li><strong>人脸比对</strong>：比对两张人脸图像，判断它们是否属于同一个人。</li><li><strong>人脸搜索</strong>：在大型图像库中搜索特定人脸。</li><li><strong>文本识别</strong>：检测和识别图像中的文字。</li><li><strong>场景分析</strong>：识别图像中的场景和对象。</li></ul><p>开发者可以通过简单的 API 调用来使用这些功能，从而构建各种视觉分析应用。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p><strong>Amazon SageMaker</strong> 是一项全面的机器学习平台，旨在简化机器学习模型的构建、训练和部署过程。SageMaker 提供了以下功能：</p><ul><li><strong>数据标注</strong>：帮助准备训练数据。</li><li><strong>模型训练</strong>：使用各种机器学习算法训练模型。</li><li><strong>模型调优</strong>：优化模型性能。</li><li><strong>模型部署</strong>：将训练好的模型部署到生产环境中。</li></ul><p>SageMaker 支持多种常见的机器学习算法和框架，同时提供了一个交互式的开发环境，方便开发者快速迭代和部署模型。</p><h2 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h2><p><strong>AWS Lambda</strong> 是一项无服务器计算服务，开发者可以在 Lambda 上运行代码而无需管理服务器。Lambda 可以根据各种事件（如 API 调用、文件上传等）触发执行代码，支持多种编程语言，包括 Python、Node.js、Java 等。Lambda 的特点包括：</p><ul><li><strong>弹性扩展</strong>：根据请求量自动扩展计算资源。</li><li><strong>按需计费</strong>：只需为实际使用的计算资源付费。</li><li><strong>事件驱动</strong>：可以与多种 AWS 服务集成，响应各种事件。</li></ul><p>Lambda 适用于构建无服务器应用、自动化任务、数据处理等场景。</p><h2 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h2><p><strong>AWS Data Pipeline</strong> 是一项数据处理服务，用于自动化和调度数据处理工作流程。开发者可以使用 Data Pipeline 来定义数据处理流程、调度任务执行、跟踪任务状态等。Data Pipeline 提供了以下功能：</p><ul><li><strong>数据源连接</strong>：支持多种数据源，包括 AWS 服务和外部数据存储。</li><li><strong>灵活调度</strong>：可以根据时间表、事件触发等条件调度任务。</li><li><strong>任务监控</strong>：提供任务状态监控和报警功能。</li></ul><p>Data Pipeline 可以帮助简化数据处理流程，提高数据处理的效率和可靠性。</p><h2 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h2><p><strong>AWS Glue</strong> 是一项全托管的数据集成服务，用于抽取、转换和加载数据。Glue 可以自动发现数据源、推断数据模式、执行数据转换操作，并将数据加载到目标数据存储中。Glue 的主要功能包括：</p><ul><li><strong>数据目录</strong>：自动创建和维护数据目录。</li><li><strong>ETL 转换</strong>：支持数据抽取、转换和加载。</li><li><strong>数据目录版本控制</strong>：管理数据目录版本。</li></ul><p>AWS Glue 可以帮助用户简化数据集成和数据准备的过程，加速数据处理和分析的流程。</p><h2 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h2><p><strong>Amazon EMR</strong> 是一项大数据处理服务，基于开源的 Apache Hadoop 和 Apache Spark 构建。EMR 可以帮助用户快速搭建、扩展和管理大数据处理集群，用于分析、处理大规模数据集。EMR 提供了以下特点：</p><ul><li><strong>弹性扩展</strong>：根据需求自动扩展集群规模。</li><li><strong>多种框架支持</strong>：支持 Hadoop、Spark、Presto 等多种大数据处理框架。</li><li><strong>安全性和可靠性</strong>：提供数据加密、访问控制等安全特性。</li></ul><p>EMR 可以帮助用户快速搭建大数据处理环境，进行数据分析和处理。</p><h2 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p><strong>Amazon Redshift</strong> 是一种云数据仓库服务，用于分析大规模数据集。Redshift 提供了高性能的数据查询和分析能力，支持列式存储、压缩和并行查询等特性。Redshift 的特点包括：</p><ul><li><strong>高性能</strong>：支持大规模数据并行处理，提供快速的查询性能。</li><li><strong>可扩展性</strong>：可以根据需求扩展集群规模。</li><li><strong>SQL 兼容</strong>：支持标准 SQL 查询语言。</li></ul><p>Redshift 可以帮助用户构建数据仓库和商业智能应用，进行复杂的数据分析和查询。</p><h2 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h2><p><strong>Amazon Athena</strong> 是一项交互式查询服务，用于在亚马逊 S3 存储中执行 SQL 查询。Athena 可以帮助用户快速分析存储在 S3 中的数据，无需预先加载数据到数据库中。Athena 的特点包括：</p><ul><li><strong>无服务器</strong>：无需管理基础设施，按需执行查询。</li><li><strong>标准 SQL</strong>：支持标准 SQL 查询语言。</li><li><strong>数据格式支持</strong>：支持多种数据格式，如 CSV、JSON 等。</li></ul><p>Athena 可以帮助用户快速进行数据查询和分析，适用于需要快速查询大规模数据集的场景。</p><h1 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h1><h2 id="无服务器集成"><a href="#无服务器集成" class="headerlink" title="无服务器集成"></a>无服务器集成</h2><p>无服务器集成是能够将API端点直接连接到无服务器后端服务，如Lambda和DynamoDB，不需要运行或管理任何服务器，这种集成方式简化了API部署和管理，因为AWS负责所有的基础设置管理。</p><h3 id="Lambda集成"><a href="#Lambda集成" class="headerlink" title="Lambda集成"></a>Lambda集成</h3><p>API Gateway可以将请求直接路由到Lambda函数，当API被调用时，触发一个Lambda函数，该函数执行业务逻辑然后返回响应，允许你构建强大的后端逻辑，无需担心服务器的运行和维护</p><h3 id="DynamoDB集成"><a href="#DynamoDB集成" class="headerlink" title="DynamoDB集成"></a>DynamoDB集成</h3><p>API Gateway可以直接与DynamoDB集成，运行API直接执行DynamoDB表上的操作，如获取项目，写入项目等。API Gateway，创建一个完全无服务的后端，用于存储和检索数据。</p><h3 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h3><p>创建Lambda函数或DynamoDB表，设置API Gateway资源，创建新的API，配置集成请求和响应，部署，用CloudWatch监控API调用和Lambda函数执行，确保性能和可靠性</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>API Gateway 提供了几种流量控制机制，帮助开发者防止过载后端服务</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>默认节流：对每个账户提供默认的节流限制，这些限制是以每秒请求数TPS和并发限制来定义的，如果超过限制则会返回429错误</li><li>自定义节流</li></ul><h3 id="使用计划"><a href="#使用计划" class="headerlink" title="使用计划"></a>使用计划</h3><ul><li>允许用户创建使用计划，并与API密钥关联，可定义API密钥允许请求频率的限制和配额限制</li></ul><h3 id="突发限制"><a href="#突发限制" class="headerlink" title="突发限制"></a>突发限制</h3><ul><li>突发限制是指在短时间内允许的最大请求数。这对于处理短时间内的突然流量增加很有用，同时确保后端服务不会因为大量并发请求而过载。</li></ul><h3 id="客户端限流"><a href="#客户端限流" class="headerlink" title="客户端限流"></a>客户端限流</h3><ul><li>开发者可以在客户端实施限流措施，这通常是通过重试逻辑和指数退避策略来实现的。这有助于在客户端自动处理和平滑处理 429 错误。</li></ul><h2 id="数据转换-1"><a href="#数据转换-1" class="headerlink" title="数据转换"></a>数据转换</h2><p>API Gateway 中实现数据转换的主要工具是模板和模型：</p><h3 id="模板（Mapping-Templates）"><a href="#模板（Mapping-Templates）" class="headerlink" title="模板（Mapping Templates）"></a>模板（Mapping Templates）</h3><p>API Gateway 允许你使用 Velocity Template Language (VTL) 和 JSONPath 表达式来创建映射模板。这些模板定义了如何将客户端请求转换为后端服务所期望的格式，以及如何将后端服务的响应转换为客户端所期望的格式。</p><p>请求模板：在请求模板中，你可以添加逻辑来定制请求有效载荷，例如添加或删除 JSON 字段，修改头部信息，或者根据请求参数构建一个全新的请求体。<br>响应模板：响应模板允许你修改从后端服务返回的数据。你可以转换数据格式，只返回客户端需要的部分数据，或者处理错误响应。</p><h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>模型是 API Gateway 中定义的数据结构，它们使用 JSON Schema 描述了 API 的请求和响应数据。模型可以帮助你标准化数据结构，并为你的 API 用户提供清晰的数据格式文档。<br>请求模型：定义了 API 接收的数据结构，可以用来校验请求数据。<br>响应模型：定义了 API 返回的数据结构，可以用来校验响应数据。<br>利用这些数据转换功能，开发者可以确保 API 的前端和后端之间的通信是平滑和一致的，即使它们可能使用不同的数据格式或标准。这也使得 API Gateway 成为一个强大的工具，用于在不修改后端服务的情况下，快速适应前端应用程序的变化需求。</p><h2 id="RESTful-API-和-WebSocket-API"><a href="#RESTful-API-和-WebSocket-API" class="headerlink" title="RESTful API 和 WebSocket API"></a>RESTful API 和 WebSocket API</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>RESTful API 是一种基于 HTTP 协议的 Web API。它遵循 REST 架构原则，通常使用标准的 HTTP 方法，如 GET、POST、PUT、DELETE 等。API Gateway 中的 RESTful API 提供以下特性：</p><p>无服务器集成：可以直接与 AWS Lambda 函数或其他 AWS 服务集成，无需运行或管理服务器。<br>数据转换：通过映射模板对请求和响应进行转换和重写。<br>流量控制：包括节流、使用计划和配额管理。<br>安全性：支持 API 密钥、AWS IAM 角色和权限以及 Cognito 用户池进行身份验证和授权。<br>版本管理和生命周期管理：支持多个发布阶段和版本控制。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控API调用和记录日志。<br>缓存：可以配置 API 缓存以减少延迟和后端负载。<br>RESTful API 适用于大多数标准的 Web 应用程序场景，特别是那些需要严格的状态无关和资源导向架构的场景。</p><h3 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h3><p>WebSocket API 提供了全双工通信通道，允许服务器和客户端之间进行实时、双向的通信。API Gateway 中的 WebSocket API 具有以下特性：</p><p>连接管理：API Gateway 负责连接的建立和维护。<br>规模扩展：可以根据连接数自动扩展，支持大量并发WebSocket连接。<br>路由选择：基于传入的消息内容，将不同的消息路由到不同的后端服务，如 AWS Lambda 或 HTTP 终端节点。<br>集成后端服务：与 AWS Lambda 和 HTTP API 直接集成，无需管理服务器。<br>安全性：可以使用 AWS IAM、Lambda 授权器或自定义授权器来管理连接和消息的授权。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控连接和消息传递。<br>WebSocket API 适用于需要实时通信的应用程序，如聊天应用、实时游戏、实时通知和协作工具。</p><h2 id="SDK集成"><a href="#SDK集成" class="headerlink" title="SDK集成"></a>SDK集成</h2><p>Amazon API Gateway 提供了与各种编程语言的 SDK 集成支持，这样开发者可以在他们选择的编程语言中更容易地调用由 API Gateway 托管的 API。这些 SDKs，通常称为客户端 SDKs，是自动生成的，并且可以针对已经部署的 API 生成。</p><p>以下是 API Gateway 与 SDK 集成的一些关键点：</p><h3 id="SDK-生成"><a href="#SDK-生成" class="headerlink" title="SDK 生成"></a>SDK 生成</h3><p>对于 RESTful API，API Gateway 允许开发者生成客户端 SDK 来调用 API。这些 SDK 可以针对以下平台生成：</p><ul><li>Android</li><li>iOS (Objective-C 和 Swift)</li><li>JavaScript (适用于浏览器和 Node.js)</li></ul><p>生成 SDK 的过程通常涉及到在 API Gateway 控制台中选择你的 API 阶段，然后选择你想要生成的 SDK 的类型。API Gateway 会为你生成一个包含所有必要调用逻辑和数据结构的压缩文件。</p><h3 id="SDK-的使用"><a href="#SDK-的使用" class="headerlink" title="SDK 的使用"></a>SDK 的使用</h3><p>生成的 SDK 会包含对应语言的库和工具，使得客户端应用程序可以轻松地与 API Gateway 进行通信。例如，生成的 JavaScript SDK 会包含 API 调用的 AJAX 请求代码，而 iOS SDK 会包含构建网络请求的代码。</p><p>使用这些 SDK，开发者可以快速地在他们的应用程序中实现以下功能：</p><ul><li>调用 API Gateway 托管的 API。</li><li>处理请求和响应，包括错误处理。</li><li>传递身份验证和授权信息，如果 API 使用了 API 密钥、AWS IAM 或 Amazon Cognito 用户池。</li></ul><h3 id="SDK-定制和优化"><a href="#SDK-定制和优化" class="headerlink" title="SDK 定制和优化"></a>SDK 定制和优化</h3><p>尽管 SDK 是自动生成的，但开发者仍然可以根据需要对其进行定制。例如，他们可以添加额外的逻辑来处理特定的应用程序场景，或者改进错误处理和重试策略。</p><p>此外，开发者可能需要考虑 SDK 如何影响应用程序的性能和大小，特别是在移动应用程序中。他们可能需要优化网络请求，或者去除未使用的 SDK 部分以减小应用程序的体积。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>使用 SDK 时，安全性是一个重要考虑因素。开发者需要确保他们的应用程序安全地存储和传递任何敏感信息，如 API 密钥或用户凭证。此外，他们可能需要实施额外的安全措施，如使用 HTTPS 来保护数据在传输过程中的安全，或者使用 OAuth 和 Amazon Cognito 来为用户提供安全的身份验证和授权。</p><p>总的来说，API Gateway 的 SDK 集成简化了客户端应用程序与后端服务的交互，允许开发者专注于构建应用程序的核心功能，而不是编写重复的代码来处理 API 调用。通过自动化的 SDK 生成和简单的集成过程，API Gateway 使得从客户端应用程序到云端服务的开发变得更加快捷和高效。</p><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>AWS Lambda 是亚马逊网络服务（Amazon Web Services, 简称AWS）提供的一项无服务器计算服务。它允许你运行代码，而无需预置或管理服务器。</p><h2 id="事件驱动执行"><a href="#事件驱动执行" class="headerlink" title="事件驱动执行"></a>事件驱动执行</h2><ul><li>通过事件触发执行，也可以来自于应用程序的自定义事件</li></ul><h3 id="举例场景：Lambda处理在S3上传新文件时触发"><a href="#举例场景：Lambda处理在S3上传新文件时触发" class="headerlink" title="举例场景：Lambda处理在S3上传新文件时触发"></a>举例场景：Lambda处理在S3上传新文件时触发</h3><p>1.需要创建一个新的Lambda函数，选为某编程语言运行<br>2.把函数分配一个执行角色，这里就是有权读取S3的对象，写入CloudWatch日志<br>3.在S3中设置事件通知，在上传时触发Lambda函数，可以在S3存储属性中找到，把Lambda函数作为目标。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例代码</span></span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote_plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志记录</span></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 S3 客户端</span></span><br><span class="line">s3_client = boto3.client(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># 获取存储桶名称和文件键值</span></span><br><span class="line">    bucket_name = event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;bucket&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    file_key = unquote_plus(event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;object&#x27;</span>][<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录到 CloudWatch 日志中</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;New file uploaded: <span class="subst">&#123;file_key&#125;</span> in bucket: <span class="subst">&#123;bucket_name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里可以添加更多处理逻辑，例如读取文件内容、转换文件格式等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;File processed successfully!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="无服务器架构"><a href="#无服务器架构" class="headerlink" title="无服务器架构"></a>无服务器架构</h2><p>不需要服务器和任何环境，Lambda负责运行你的代码并自动管理底层计算资源</p><h2 id="自动扩展"><a href="#自动扩展" class="headerlink" title="自动扩展"></a>自动扩展</h2><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>一个事件触发器激活一个Lambda函数，如果有多个事件几乎同时到达，Lambda会自动启动多个实例来处理事件</p><h3 id="冷启动与热启动"><a href="#冷启动与热启动" class="headerlink" title="冷启动与热启动"></a>冷启动与热启动</h3><ul><li><p>冷启动：当一个函数被触发而当前没有可用的运行实例时，Lambda会进行一个“冷启动”，即创建一个新的函数实例。过程基本涉及到加载代码，初始化运行时，运行初始化代码（如全局变量声明）等步骤。冷启动通常需要更长启动时间。</p></li><li><p>热启动：如果一个函数实例在执行完一个时间后仍然处于空闲状态，可以被用来快速响应新的时间，这称为热启动，热启动跳过了实例创建过程比冷启动快</p></li></ul><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>Lambda在账户级别有并发执行限制。这个限制是指任何时刻，一个AWS账户可以同时运行的Lambda函数实例的数量。这个限制既保护了用户免受意外的高费用，确保资源的合理分配</p><h3 id="预热行为"><a href="#预热行为" class="headerlink" title="预热行为"></a>预热行为</h3><p>避免冷启动延迟，用户可以实现预热策略，通过定期触发Lambda函数来保持一定数量的热实例。</p><h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><h3 id="IAM角色和策略"><a href="#IAM角色和策略" class="headerlink" title="IAM角色和策略"></a>IAM角色和策略</h3><ul><li><p>创建一个 Lambda 函数时，您需要指定一个执行角色（IAM 角色）。Lambda 函数将使用这个角色的权限来访问 AWS 服务和资源。</p><h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><p>资源策略包含以下部分：</p></li><li><p>Statement：资源策略由一个或多个语句（Statement）组成，每个语句都是一个权限声明，指定了一个允许或拒绝的权限。</p></li><li><p>Effect：每个语句的 Effect 决定了这个语句是允许（Allow）还是拒绝（Deny）某项操作。</p></li><li><p>Action：Action 定义了可以在 Lambda 函数上执行的操作，例如 lambda:InvokeFunction。</p></li><li><p>Resource：Resource 指定了策略适用的资源，对于 Lambda 函数策略来说，这通常是函数的 ARN（Amazon Resource Name）。</p></li><li><p>Principal：Principal 定义了哪些 AWS 账户、用户、角色或服务可以执行在 Action 中定义的操作。</p></li><li><p>Condition：条件（Condition）用于指定策略的有效性取决于一系列预定义的条件是否满足。</p></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>下面是一个资源策略的示例，它允许另一个 AWS 账户的用户调用 Lambda 函数：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Version&quot;:</span> <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Statement&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;Effect&quot;:</span> <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Principal&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;AWS&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;Action&quot;:</span> <span class="string">&quot;lambda:InvokeFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Resource&quot;:</span> <span class="string">&quot;arn:aws:lambda:us-west-2:111122223333:function:MyFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Condition&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;StringEquals&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceAccount&quot;:</span> <span class="string">&quot;123456789012&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ArnLike&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceArn&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，只有在条件满足时（即请求来自特定账户和用户），指定的用户才能调用 MyFunction。通过使用资源策略，您可以跨账户共享 Lambda 函数，或者允许来自 AWS 服务（如 Amazon S3 事件、Amazon SNS 主题、Amazon DynamoDB 更新流等）的触发器调用您的函数。这是实现跨账户功能和集成 AWS 服务的一种强大方式。</p><h3 id="环境变量加密"><a href="#环境变量加密" class="headerlink" title="环境变量加密"></a>环境变量加密</h3><ul><li> 允许您为函数设置环境变量，用于存储配置信息。您可以使用 AWS Key Management Service (KMS) 加密这些环境变量，以保护敏感信息。<h3 id="VPC集成"><a href="#VPC集成" class="headerlink" title="VPC集成"></a>VPC集成</h3></li><li>Lambda函数可配置在VPC内运行</li></ul><h3 id="网络隔离和防火墙"><a href="#网络隔离和防火墙" class="headerlink" title="网络隔离和防火墙"></a>网络隔离和防火墙</h3><ul><li>配置 Lambda 函数在 VPC 中运行，您可以使用网络 ACL 和安全组作为网络层的防火墙，来控制流入和流出资源的流量。<h3 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h3></li><li>调用和执行情况可以通过 Amazon CloudWatch 进行监控和记录日志。您可以配置日志记录，以便在函数执行时捕获调用请求和响应数据。</li></ul><h2 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h2><p>一个经典的多服务场景，使用 AWS Lambda 的例子是一个自动化的图像处理平台。在这个场景中，用户上传图片到 Amazon S3，这会触发一个 Lambda 函数来处理这些图片（例如，压缩、转换格式、添加水印等），然后结果可以被存储在另一个 S3 桶中，或者被发送到其他服务进行进一步处理或分析。</p><p>以下是服务之间的作用和交互：</p><ol><li><p><strong>Amazon S3 (Simple Storage Service)</strong>:</p><ul><li>作为图像和处理后文件的存储位置。</li><li>触发 Lambda 函数以响应新上传的图像。</li></ul></li><li><p><strong>AWS Lambda</strong>:</p><ul><li>执行图像处理逻辑，如调整大小、格式转换或应用水印。</li><li>读取和写入 S3 桶中的文件。</li><li>可以调用其他 AWS 服务，如 Amazon Rekognition 进行图像分析。</li></ul></li><li><p><strong>Amazon Rekognition</strong>:</p><ul><li>提供图像和视频分析，如识别对象、场景和名人。</li><li>Lambda 函数可以将图像发送到 Rekognition 以获取元数据，并根据这些信息进一步处理或分类图像。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>:</p><ul><li>用于存储图像的元数据，如文件名、大小、图像类型、处理状态和 Rekognition 提供的任何分析数据。</li><li>Lambda 函数可以更新 DynamoDB 表以反映处理状态或存储分析结果。</li></ul></li><li><p><strong>Amazon SNS (Simple Notification Service)</strong> 或 <strong>Amazon SQS (Simple Queue Service)</strong>:</p><ul><li>用于通知系统的其他部分，例如，当图像处理完成时。</li><li>Lambda 函数可以发布消息到 SNS 主题或 SQS 队列，以触发其他处理流程或通知用户。</li></ul></li><li><p><strong>AWS Step Functions</strong>:</p><ul><li>管理和协调复杂的多步骤 Lambda 函数工作流。</li><li>Lambda 函数可以作为步骤函数状态机中的一个步骤，以确保处理逻辑按照预定顺序执行。</li></ul></li><li><p><strong>Amazon CloudWatch</strong>:</p><ul><li>监控 Lambda 函数的性能和日志。</li><li>Lambda 函数执行时会自动记录日志和各种指标，以供分析和调试。</li></ul></li></ol><p>在这个场景中，用户上传图片到 S3 桶，这个上传操作自动触发一个 Lambda 函数。Lambda 函数读取新上传的图片，进行必要的处理，然后将处理后的图片存储到另一个 S3 桶中。如果启用了图像分析，Lambda 函数还会调用 Amazon Rekognition。处理结果（包括图像元数据和分析数据）可以被存储到 DynamoDB。Lambda 函数还可以将处理完成的事件通过 SNS 或 SQS 发布出去，以便其他应用组件可以响应这些事件。整个处理流程可以用 AWS Step Functions 来协调。最后，Amazon CloudWatch 被用来监控整个过程，包括 Lambda 函数的性能和日志记录。</p><h1 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h1><h2 id="Classic-Load-Balancer（CLB）"><a href="#Classic-Load-Balancer（CLB）" class="headerlink" title="Classic Load Balancer（CLB）"></a>Classic Load Balancer（CLB）</h2><ul><li>支持基于TCP和HTTP/HTTPS的负载均衡</li><li>提供固定性能，但没有ALB和NLB那样灵活</li><li>支持一个简单的健康检查<h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3></li></ul><ul><li>旧的或遗留的应用程序，这些应用程序不需要复杂的路由规则，只需简单地在多个服务器之间分发流量。</li><li>示例：一个简单的网站或应用程序，客户端通过HTTP/HTTPS请求服务，CLB将请求均匀地分配给后端的多个EC2实例。</li></ul><h2 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h2><ul><li>ALB是为HTTP/HTTPS流量设计的，提供高级的请求路由功能，比如基于内容的路由。</li><li>支持路径、主机、HTTP头部、HTTP方法和查询参数等多种路由条件。</li><li>可以直接与容器化服务和微服务架构进行集成。</li><li>提供了更细粒度的健康检查。</li><li>支持WebSocket和HTTP/2。</li></ul><h3 id="场景举例-1"><a href="#场景举例-1" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>面向现代应用程序，特别是在微服务架构中，需要根据URL的不同路径将流量路由到不同的服务。</li><li>示例：一个电子商务网站，其中/catalog路径指向商品目录服务，而/cart路径指向购物车服务。ALB可以根据路径将流量路由到不同的服务或容器。</li></ul><h2 id="3-Network-Load-Balancer-NLB"><a href="#3-Network-Load-Balancer-NLB" class="headerlink" title="3. Network Load Balancer (NLB)"></a>3. Network Load Balancer (NLB)</h2><ul><li>NLB是在第4层（传输层）工作的负载均衡器，专门设计用于处理极高的性能和低延迟需求。</li><li>支持静态IP地址或Elastic IP地址。</li><li>适用于处理TCP、UDP和TLS流量。</li><li>能够处理数百万请求每秒，同时保持极低的延迟。</li><li>支持长连接，适合需要保持TCP连接的应用程序。</li></ul><h3 id="场景举例-2"><a href="#场景举例-2" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>高性能的实时游戏、股票交易平台或需要处理大量TCP连接的任何其他类型的应用程序。</li><li>示例：实时多人在线游戏服务器，玩家的连接需要低延迟和高吞吐量，NLB可以有效地在多个游戏服务器实例之间分配TCP流量。</li></ul><h2 id="其他服务集成"><a href="#其他服务集成" class="headerlink" title="其他服务集成"></a>其他服务集成</h2><p>AWS的Elastic Load Balancing (ELB)服务可以与许多其他AWS服务集成，以提供更完整、更强大的解决方案。以下是一些常与ELB集成使用的AWS服务：</p><h3 id="1-Amazon-EC2-Elastic-Compute-Cloud"><a href="#1-Amazon-EC2-Elastic-Compute-Cloud" class="headerlink" title="1. Amazon EC2 (Elastic Compute Cloud)"></a>1. Amazon EC2 (Elastic Compute Cloud)</h3><ul><li>ELB通常用来分配流量给后端的EC2实例。当实例的健康检查通过时，它们会被加入负载均衡器的目标池中。</li></ul><h3 id="2-Amazon-ECS-Elastic-Container-Service"><a href="#2-Amazon-ECS-Elastic-Container-Service" class="headerlink" title="2. Amazon ECS (Elastic Container Service)"></a>2. Amazon ECS (Elastic Container Service)</h3><ul><li>对于容器化的应用程序，ALB可以直接与ECS服务集成，自动注册容器实例作为负载均衡器的目标。</li></ul><h3 id="3-AWS-Fargate"><a href="#3-AWS-Fargate" class="headerlink" title="3. AWS Fargate"></a>3. AWS Fargate</h3><ul><li>Fargate提供了无服务器的容器执行环境，与ELB（特别是ALB）集成时，可以动态地负载均衡到Fargate任务。</li></ul><h3 id="4-Amazon-EKS-Elastic-Kubernetes-Service"><a href="#4-Amazon-EKS-Elastic-Kubernetes-Service" class="headerlink" title="4. Amazon EKS (Elastic Kubernetes Service)"></a>4. Amazon EKS (Elastic Kubernetes Service)</h3><ul><li>对于Kubernetes管理的容器应用程序，ELB可以用来平滑地分配流量到EKS集群中的Pods。</li></ul><h3 id="5-AWS-Lambda"><a href="#5-AWS-Lambda" class="headerlink" title="5. AWS Lambda"></a>5. AWS Lambda</h3><ul><li>ALB可以直接触发Lambda函数，允许无服务器架构的应用程序响应HTTP/HTTPS请求。</li></ul><h3 id="6-AWS-Auto-Scaling"><a href="#6-AWS-Auto-Scaling" class="headerlink" title="6. AWS Auto Scaling"></a>6. AWS Auto Scaling</h3><ul><li>ELB与Auto Scaling紧密集成，可以根据流量增减自动调整EC2实例的数量。</li></ul><h3 id="7-Amazon-RDS-Relational-Database-Service"><a href="#7-Amazon-RDS-Relational-Database-Service" class="headerlink" title="7. Amazon RDS (Relational Database Service)"></a>7. Amazon RDS (Relational Database Service)</h3><ul><li>虽然ELB不直接与RDS集成，但是可以配置应用程序在ELB后面连接到RDS数据库，从而使数据库层与应用层分离，提高可扩展性。</li></ul><h3 id="8-Amazon-S3-Simple-Storage-Service"><a href="#8-Amazon-S3-Simple-Storage-Service" class="headerlink" title="8. Amazon S3 (Simple Storage Service)"></a>8. Amazon S3 (Simple Storage Service)</h3><ul><li>对于静态内容，可以配置ALB通过HTTP(S)重定向到S3存储桶，以便高效地提供静态资源。</li></ul><h3 id="9-AWS-WAF-Web-Application-Firewall"><a href="#9-AWS-WAF-Web-Application-Firewall" class="headerlink" title="9. AWS WAF (Web Application Firewall)"></a>9. AWS WAF (Web Application Firewall)</h3><ul><li>可以将AWS WAF与ALB和NLB集成，为应用程序提供基于规则的防护，以防止常见的网络攻击。</li></ul><h3 id="10-AWS-Certificate-Manager-ACM"><a href="#10-AWS-Certificate-Manager-ACM" class="headerlink" title="10. AWS Certificate Manager (ACM)"></a>10. AWS Certificate Manager (ACM)</h3><ul><li>与ACM集成可以轻松地在ELB上部署SSL/TLS证书，以实现安全的数据传输。</li></ul><h3 id="11-Amazon-CloudWatch"><a href="#11-Amazon-CloudWatch" class="headerlink" title="11. Amazon CloudWatch"></a>11. Amazon CloudWatch</h3><ul><li>ELB与CloudWatch集成，提供了监控和日志记录功能，以跟踪和分析负载均衡器的性能。</li></ul><h3 id="12-AWS-CloudTrail"><a href="#12-AWS-CloudTrail" class="headerlink" title="12. AWS CloudTrail"></a>12. AWS CloudTrail</h3><ul><li>CloudTrail与ELB集成，可以记录所有ELB事件，帮助用户进行安全分析和操作审计。</li></ul><h3 id="13-AWS-Global-Accelerator"><a href="#13-AWS-Global-Accelerator" class="headerlink" title="13. AWS Global Accelerator"></a>13. AWS Global Accelerator</h3><ul><li>对于全球分布的应用程序，可以使用Global Accelerator提高用户到ELB的连接速度和可靠性。</li></ul><h3 id="14-AWS-Shield"><a href="#14-AWS-Shield" class="headerlink" title="14. AWS Shield"></a>14. AWS Shield</h3><ul><li>与ELB集成的AWS Shield提供了DDoS保护，以保护应用程序免受分布式拒绝服务攻击。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic for SAA</title>
      <link href="/2023/12/24/SAA%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/12/24/SAA%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="SAA"><a href="#SAA" class="headerlink" title="SAA"></a>SAA</h1><h3 id="领域-1：-设计安全的架构"><a href="#领域-1：-设计安全的架构" class="headerlink" title="领域 1： 设计安全的架构"></a><strong>领域</strong> <strong>1</strong>： 设计安全的架构</h3><h3 id="跨多个账户的访问控制和管理："><a href="#跨多个账户的访问控制和管理：" class="headerlink" title="跨多个账户的访问控制和管理："></a>跨多个账户的访问控制和管理：</h3><p>跨多个AWS账户的访问控制和管理是一项复杂任务，它涉及到使用AWS的服务和功能来创建一个安全、高效且易于管理的多账户环境。以下是详细介绍如何实现这一目标的步骤：</p><h4 id="1-使用AWS-Organizations："><a href="#1-使用AWS-Organizations：" class="headerlink" title="1. 使用AWS Organizations："></a>1. 使用AWS Organizations：</h4><p>AWS Organizations是一个服务，允许您集中管理和治理您的多个AWS账户。使用AWS Organizations，您可以：</p><ul><li><strong>创建组织</strong>：将所有账户集合成一个组织，方便管理。</li><li><strong>创建组织单位（OUs）</strong>：将账户分组，以便对一组账户执行策略。</li><li><strong>服务控制策略（SCPs）</strong>：为OUs或单个账户设置策略，限制可执行的AWS服务和操作。</li></ul><h5 id="实践步骤："><a href="#实践步骤：" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>登录到AWS Management Console。</li><li>寻找并选择AWS Organizations服务。</li><li>创建一个新组织，邀请现有账户或创建新账户。</li><li>创建OUs，按功能、部门或其他逻辑方式组织账户。</li><li>应用SCPs以限制OU或账户级别的权限。</li></ol><h4 id="2-使用IAM进行用户管理："><a href="#2-使用IAM进行用户管理：" class="headerlink" title="2. 使用IAM进行用户管理："></a>2. 使用IAM进行用户管理：</h4><p>在AWS中，IAM允许您创建和管理用户、组、角色和权限策略。在多账户环境中，您应该：</p><ul><li><strong>创建IAM用户</strong>：为每个需要访问AWS服务的人员创建IAM用户。</li><li><strong>创建IAM组</strong>：根据用户的角色和职责，将用户分组，并将权限策略附加到组上。</li><li><strong>使用IAM角色跨账户访问</strong>：为需要在多个账户间进行操作的用户创建IAM角色。</li></ul><h5 id="实践步骤：-1"><a href="#实践步骤：-1" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在每个AWS账户中设置IAM用户和组。</li><li>定义IAM权限策略，明确用户和组可以执行的操作。</li><li>创建IAM角色以供跨账户访问，并定义信任关系以允许其他账户的用户扮演角色。</li></ol><h4 id="3-使用AWS-IAM-Identity-Center-SSO-："><a href="#3-使用AWS-IAM-Identity-Center-SSO-：" class="headerlink" title="3. 使用AWS IAM Identity Center (SSO)："></a>3. 使用AWS IAM Identity Center (SSO)：</h4><p>AWS IAM Identity Center (SSO)允许用户使用单一凭据登录到多个AWS账户和第三方应用程序。</p><h5 id="实践步骤：-2"><a href="#实践步骤：-2" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>设置AWS IAM Identity Center (SSO)。</li><li>配置身份源，例如Microsoft Active Directory。</li><li>设置SSO集成以连接到您的AWS账户。</li><li>为用户分配SSO访问权限，允许他们访问指定的账户和资源。</li></ol><h4 id="4-监控和审计："><a href="#4-监控和审计：" class="headerlink" title="4. 监控和审计："></a>4. 监控和审计：</h4><p>使用AWS CloudTrail和Amazon CloudWatch等服务来监控和记录所有账户的活动。</p><h5 id="实践步骤：-3"><a href="#实践步骤：-3" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在所有账户中启用AWS CloudTrail。</li><li>使用Amazon CloudWatch创建警报，监控关键活动和性能指标。</li><li>定期审计账户活动，确保遵守策略和最佳实践。</li></ol><h4 id="5-定期审查和优化："><a href="#5-定期审查和优化：" class="headerlink" title="5. 定期审查和优化："></a>5. 定期审查和优化：</h4><p>定期审查账户使用情况、权限策略和安全设置，以确保它们仍然适用于您的业务需求，并遵循最低权限原则。</p><h5 id="实践步骤：-4"><a href="#实践步骤：-4" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>使用IAM Access Advisor查看用户和角色的服务使用情况。</li><li>使用IAM Policy Simulator测试权限策略。</li><li>定期进行权限和安全设置的审计。</li></ol><h3 id="AWS-联合访问和身份服务（例如，AWS-Identity-and-Access-Management-IAM-、AWS-IAM-Identity-Center-AWS-Single-Sign-On-）"><a href="#AWS-联合访问和身份服务（例如，AWS-Identity-and-Access-Management-IAM-、AWS-IAM-Identity-Center-AWS-Single-Sign-On-）" class="headerlink" title="AWS 联合访问和身份服务（例如，AWS Identity and Access Management[IAM]、AWS IAM Identity Center [AWS Single Sign-On]）"></a>AWS 联合访问和身份服务（例如，AWS Identity and Access Management[IAM]、AWS IAM Identity Center [AWS Single Sign-On]）</h3><p>AWS提供了一系列服务来帮助您管理访问和身份验证，确保只有经过授权的用户才能访问您的资源。以下是对AWS联合访问和身份服务的详细指导，重点介绍AWS Identity and Access Management (IAM)和AWS IAM Identity Center（以前称为AWS Single Sign-On或AWS SSO）。</p><h4 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h4><p>IAM是AWS的核心服务之一，它允许您安全地控制对AWS服务和资源的访问。以下是如何使用IAM的步骤：</p><h5 id="1-创建IAM用户和组"><a href="#1-创建IAM用户和组" class="headerlink" title="1. 创建IAM用户和组"></a>1. 创建IAM用户和组</h5><ul><li><strong>IAM用户</strong>：代表个人或服务的身份，可以是一个人或一个系统/应用程序。</li><li><strong>IAM组</strong>：是一组IAM用户，可以让您更容易地管理多个用户的权限。</li></ul><h5 id="实践步骤：-5"><a href="#实践步骤：-5" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>登录到AWS管理控制台。</li><li>导航到IAM控制台。</li><li>创建新用户：<ul><li>选择“用户”然后点击“添加用户”。</li><li>输入用户名，选择“程序访问”和/或“AWS管理控制台访问”。</li><li>设置密码和密码策略（如果选择了控制台访问）。</li></ul></li><li>创建新组：<ul><li>选择“用户组”然后点击“创建新组”。</li><li>输入组名，选择适当的权限策略。</li><li>将用户添加到组。</li></ul></li></ol><h5 id="2-创建和管理访问密钥"><a href="#2-创建和管理访问密钥" class="headerlink" title="2. 创建和管理访问密钥"></a>2. 创建和管理访问密钥</h5><ul><li>对于需要通过API、CLI或SDK访问AWS服务的用户，您需要创建访问密钥。</li></ul><h4 id="实践步骤：-6"><a href="#实践步骤：-6" class="headerlink" title="实践步骤："></a>实践步骤：</h4><ol><li>在IAM用户的“安全凭证”选项卡下创建新的访问密钥。</li><li>安全地保存访问密钥ID和秘密访问密钥。</li></ol><h5 id="3-使用IAM角色和策略"><a href="#3-使用IAM角色和策略" class="headerlink" title="3. 使用IAM角色和策略"></a>3. 使用IAM角色和策略</h5><ul><li><strong>IAM角色</strong>：是一种权限集合，可以被分配给任何一个用户、服务或其他角色。</li><li><strong>IAM策略</strong>：定义了具体的权限，描述了可以对哪些资源执行哪些操作。</li></ul><h5 id="实践步骤：-7"><a href="#实践步骤：-7" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>创建新角色并选择信任关系（例如，EC2、Lambda等）。</li><li>附加策略到角色以定义权限。</li><li>将角色分配给AWS资源或服务。</li></ol><h4 id="4-使用条件和细粒度的权限控制"><a href="#4-使用条件和细粒度的权限控制" class="headerlink" title="4. 使用条件和细粒度的权限控制"></a>4. 使用条件和细粒度的权限控制</h4><ul><li>通过使用条件和细粒度的权限控制，您可以定义更精确的访问规则。</li></ul><h5 id="实践步骤：-8"><a href="#实践步骤：-8" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在IAM策略中定义条件。</li><li>使用策略模拟器测试策略。</li></ol><h4 id="AWS-IAM-Identity-Center-AWS-SSO"><a href="#AWS-IAM-Identity-Center-AWS-SSO" class="headerlink" title="AWS IAM Identity Center (AWS SSO)"></a>AWS IAM Identity Center (AWS SSO)</h4><p>AWS IAM Identity Center允许您中心化管理用户对多个AWS账户和业务应用程序的访问。以下是如何使用AWS IAM Identity Center的步骤：</p><h5 id="1-设置AWS-IAM-Identity-Center"><a href="#1-设置AWS-IAM-Identity-Center" class="headerlink" title="1. 设置AWS IAM Identity Center"></a>1. 设置AWS IAM Identity Center</h5><ul><li>通过AWS IAM Identity Center，您可以连接到现有的身份源，如Microsoft Active Directory，或者使用AWS SSO内置的身份存储。</li></ul><h5 id="实践步骤：-9"><a href="#实践步骤：-9" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>打开AWS IAM Identity Center控制台。</li><li>配置您的身份源。</li><li>启用AWS SSO。</li></ol><h5 id="2-配置AWS账户和应用程序"><a href="#2-配置AWS账户和应用程序" class="headerlink" title="2. 配置AWS账户和应用程序"></a>2. 配置AWS账户和应用程序</h5><ul><li>将AWS账户集成到AWS IAM Identity Center，并配置任何内部或第三方应用程序以使用AWS SSO。</li></ul><h5 id="实践步骤：-10"><a href="#实践步骤：-10" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在AWS IAM Identity Center控制台中，选择“AWS组织”来管理账户访问。</li><li>为每个账户分配用户或组。</li><li>配置单个应用程序访问。</li></ol><h5 id="3-分配用户权限"><a href="#3-分配用户权限" class="headerlink" title="3. 分配用户权限"></a>3. 分配用户权限</h5><ul><li>为用户分配在AWS账户和应用程序中的权限。</li></ul><h5 id="实践步骤：-11"><a href="#实践步骤：-11" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在AWS IAM Identity Center中，选择“用户”或“组”。</li><li>分配访问权限到AWS账户或应用程序。</li></ol><h5 id="4-用户登录和访问管理"><a href="#4-用户登录和访问管理" class="headerlink" title="4. 用户登录和访问管理"></a>4. 用户登录和访问管理</h5><ul><li>用户可以使用单一登录访问他们有权访问的AWS账户和应用程序。</li></ul><h5 id="实践步骤：-12"><a href="#实践步骤：-12" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>用户访问AWS IAM Identity Center的用户门户。</li><li>用户使用他们的单一凭证登录。</li><li>用户选择他们有权访问的账户或应用程序。</li></ol><h3 id="AWS-全球基础设施（例如，可用区、AWS-区域）"><a href="#AWS-全球基础设施（例如，可用区、AWS-区域）" class="headerlink" title="AWS 全球基础设施（例如，可用区、AWS 区域）"></a>AWS 全球基础设施（例如，可用区、AWS 区域）</h3><h4 id="AWS-全球基础设施概述"><a href="#AWS-全球基础设施概述" class="headerlink" title="AWS 全球基础设施概述"></a>AWS 全球基础设施概述</h4><p>AWS 全球基础设施是由数据中心组成的广泛网络，这些数据中心分布在世界各地的多个地理区域中。这个基础设施支持运行亚马逊网络服务（Amazon Web Services，简称AWS）的所有服务，为用户提供了高可用性、高可靠性和高扩展性的云计算资源。</p><h4 id="AWS-区域"><a href="#AWS-区域" class="headerlink" title="AWS 区域"></a>AWS 区域</h4><p>AWS 区域是物理位置的集合，每个区域都包含多个独立的可用区。每个AWS区域都是一个独立的地理区域，比如美国东部（北弗吉尼亚）、欧洲（爱尔兰）、亚太（孟买）等。</p><h5 id="设计原则和优势"><a href="#设计原则和优势" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>隔离性</strong>：每个区域都是独立运行的，故障不会传播到其他区域。</li><li><strong>低延迟</strong>：用户可以选择离他们的客户或用户最近的区域，以减少延迟。</li><li><strong>合规性</strong>：用户可以选择将数据存储在特定的法律或合规性要求的区域。</li></ul><h5 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>登录AWS管理控制台。</li><li>在控制台顶部，选择您希望部署资源的区域。</li><li>部署AWS服务（例如EC2实例、S3存储桶等）时，确保您在正确的区域操作。</li></ol><h4 id="AWS-可用区"><a href="#AWS-可用区" class="headerlink" title="AWS 可用区"></a>AWS 可用区</h4><p>AWS 可用区是指在单个区域内的一个或多个离散的数据中心，每个数据中心都有独立的电源、冷却和网络连接，以降低单点故障的风险。</p><h5 id="设计原则和优势-1"><a href="#设计原则和优势-1" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>高可用性</strong>：通过在多个可用区中部署应用程序和数据，可以提高容错能力和业务持续性。</li><li><strong>独立性</strong>：每个可用区都设计为与其他可用区隔离，即使在极端情况下也能保持运行。</li></ul><h5 id="实践步骤-1"><a href="#实践步骤-1" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设计应用程序架构时，确保使用多个可用区以实现高可用性。</li><li>在创建资源（如EC2实例）时，选择多个可用区进行部署。</li><li>配置负载均衡器和数据库服务以跨多个可用区分布。</li></ol><h4 id="AWS-边缘位置"><a href="#AWS-边缘位置" class="headerlink" title="AWS 边缘位置"></a>AWS 边缘位置</h4><p>AWS 边缘位置是位于世界各地的站点，用于缓存数据，从而减少对用户的响应时间。这些边缘位置是由Amazon CloudFront（AWS的内容分发网络服务）和AWS Lambda@Edge使用的。</p><h5 id="设计原则和优势-2"><a href="#设计原则和优势-2" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>性能优化</strong>：边缘位置可以减少数据传输的延迟，加快内容的交付速度。</li><li><strong>可扩展性</strong>：AWS的全球网络可以轻松处理大量请求，满足不断增长的需求。</li></ul><h5 id="实践步骤-2"><a href="#实践步骤-2" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>通过Amazon CloudFront创建分发，选择一个或多个原始位置。</li><li>为常用内容配置缓存行为和TTL（生存时间）设置。</li><li>使用Lambda@Edge来运行自定义代码，它会响应CloudFront事件。</li></ol><h4 id="结合使用区域和可用区"><a href="#结合使用区域和可用区" class="headerlink" title="结合使用区域和可用区"></a>结合使用区域和可用区</h4><p>在AWS中，最佳实践是结合使用区域和可用区来设计和部署应用程序和服务。这样可以优化性能，同时确保业务连续性和灾难恢复。</p><h5 id="实践步骤-3"><a href="#实践步骤-3" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>根据用户群体选择合适的区域部署服务。</li><li>在该区域的多个可用区中创建和配置资源，以实现高可用性。</li><li>使用AWS服务，如Amazon RDS和Amazon EC2 Auto Scaling，跨多个可用区自动管理资源。</li></ol><h3 id="AWS-安全最佳实践（例如，最低权限原则）"><a href="#AWS-安全最佳实践（例如，最低权限原则）" class="headerlink" title="AWS 安全最佳实践（例如，最低权限原则）"></a>AWS 安全最佳实践（例如，最低权限原则）</h3><h4 id="AWS-安全最佳实践概述"><a href="#AWS-安全最佳实践概述" class="headerlink" title="AWS 安全最佳实践概述"></a>AWS 安全最佳实践概述</h4><p>在使用AWS时，遵循安全最佳实践是至关重要的，因为它有助于保护您的云资源免受未经授权的访问和潜在的安全威胁。AWS提供了强大的工具和服务来帮助用户实现这些最佳实践。</p><h4 id="遵循最低权限原则"><a href="#遵循最低权限原则" class="headerlink" title="遵循最低权限原则"></a>遵循最低权限原则</h4><p>最低权限原则是指仅授予必要的权限，以执行特定任务的最小权限集。在AWS中，这通常涉及IAM（Identity and Access Management）的精细权限管理。</p><h5 id="设计原则和优势-3"><a href="#设计原则和优势-3" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>风险降低</strong>：限制权限可以减少安全风险和潜在的数据泄露。</li><li><strong>易于管理</strong>：精确的权限使得权限管理更加清晰和容易维护。</li></ul><h5 id="实践步骤-4"><a href="#实践步骤-4" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个IAM用户创建唯一的身份，而不是共享凭证。</li><li>为每个用户分配最小的必要权限，以完成其工作。</li><li>使用IAM策略来精细控制访问权限。</li><li>定期审查和调整权限，确保它们仍然符合需要。</li></ol><h4 id="使用IAM角色和策略"><a href="#使用IAM角色和策略" class="headerlink" title="使用IAM角色和策略"></a>使用IAM角色和策略</h4><p>IAM角色允许您在不共享安全凭证的情况下，将权限委托给用户、应用程序或服务。</p><h5 id="设计原则和优势-4"><a href="#设计原则和优势-4" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>安全性</strong>：角色不需要永久性凭证，使用时会临时提供安全令牌。</li><li><strong>灵活性</strong>：可以轻松地向用户或服务分配和撤销角色。</li></ul><h5 id="实践步骤-5"><a href="#实践步骤-5" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建IAM角色并定义其权限策略。</li><li>将角色分配给需要特定权限的AWS服务或用户。</li><li>当任务完成或角色不再需要时，撤销对该角色的访问权限。</li></ol><h4 id="保护数据"><a href="#保护数据" class="headerlink" title="保护数据"></a>保护数据</h4><p>在AWS中，保护存储和传输中的数据是保证安全的关键组成部分。</p><h5 id="设计原则和优势-5"><a href="#设计原则和优势-5" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>数据加密</strong>：确保数据在传输和静态时都是加密的。</li><li><strong>数据备份</strong>：定期备份数据以防止丢失或损坏。</li></ul><h5 id="实践步骤-6"><a href="#实践步骤-6" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS服务（如S3、EBS、RDS）时，启用加密功能。</li><li>对敏感数据实施端到端加密。</li><li>定期备份数据，并测试恢复过程。</li></ol><h4 id="监控和日志记录"><a href="#监控和日志记录" class="headerlink" title="监控和日志记录"></a>监控和日志记录</h4><p>使用AWS提供的监控和日志记录工具可以帮助您检测和响应安全事件。</p><h5 id="设计原则和优势-6"><a href="#设计原则和优势-6" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>可见性</strong>：日志提供了对环境中发生的活动的洞察。</li><li><strong>审计</strong>：监控和日志记录有助于满足合规性要求。</li></ul><h5 id="实践步骤-7"><a href="#实践步骤-7" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS CloudTrail来记录用户活动和API使用情况。</li><li>配置Amazon CloudWatch来监控资源和应用程序。</li><li>定期审查日志文件，并设置警报以监控可疑活动。</li></ol><h4 id="定期审计和合规性检查"><a href="#定期审计和合规性检查" class="headerlink" title="定期审计和合规性检查"></a>定期审计和合规性检查</h4><p>定期进行安全审计和合规性检查，以确保持续遵守安全最佳实践。</p><h5 id="设计原则和优势-7"><a href="#设计原则和优势-7" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>持续改进</strong>：审计有助于识别和修复潜在的安全问题。</li><li><strong>合规性</strong>：检查有助于确保符合法律和行业标准。</li></ul><h5 id="实践步骤-8"><a href="#实践步骤-8" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Config来跟踪资源配置的变化和合规性。</li><li>利用AWS Trusted Advisor来获取安全优化建议。</li><li>定期进行安全评估，如使用AWS Inspector。</li></ol><h3 id="AWS-责任共担模式"><a href="#AWS-责任共担模式" class="headerlink" title="AWS 责任共担模式"></a>AWS 责任共担模式</h3><h4 id="AWS-责任共担模式概述"><a href="#AWS-责任共担模式概述" class="headerlink" title="AWS 责任共担模式概述"></a>AWS 责任共担模式概述</h4><p>AWS 责任共担模式是一个安全和合规性框架，其中AWS和客户共同承担确保云环境安全的责任。在这个模型中，AWS负责保护云计算基础设施的安全，而客户则负责在AWS云中运行的内容、平台、应用程序和数据的安全。</p><h4 id="AWS-的责任"><a href="#AWS-的责任" class="headerlink" title="AWS 的责任"></a>AWS 的责任</h4><p>在责任共担模式中，AWS负责“云的安全”，这涉及到保护其基础设施的安全，包括硬件、软件、网络和设施。</p><h5 id="设计原则和优势-8"><a href="#设计原则和优势-8" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>基础设施安全</strong>：AWS负责保护全球数据中心的物理安全。</li><li><strong>服务安全</strong>：AWS负责其服务的底层软件和硬件的安全性。</li></ul><h5 id="实践步骤-9"><a href="#实践步骤-9" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>AWS定期维护其数据中心的物理安全措施。</li><li>AWS管理云服务的底层操作系统和虚拟化层。</li><li>AWS实施网络基础设施的安全性和弹性。</li></ol><h4 id="客户的责任"><a href="#客户的责任" class="headerlink" title="客户的责任"></a>客户的责任</h4><p>客户负责“云中的安全”，这包括客户设置和管理的数据、应用程序以及其他资源的安全性。</p><h5 id="设计原则和优势-9"><a href="#设计原则和优势-9" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>数据保护</strong>：客户负责管理自己的数据加密和访问控制。</li><li><strong>身份管理</strong>：客户负责使用IAM工具管理用户访问权限。</li><li><strong>操作安全</strong>：客户负责操作系统、网络配置和应用程序的安全性。</li></ul><h5 id="实践步骤-10"><a href="#实践步骤-10" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>客户应加密敏感数据，并管理加密密钥。</li><li>客户应配置IAM策略，实施最低权限原则。</li><li>客户应定期更新和打补丁自己的应用程序和操作系统。</li></ol><h4 id="共同责任的例子"><a href="#共同责任的例子" class="headerlink" title="共同责任的例子"></a>共同责任的例子</h4><p>在责任共担模式下，某些安全责任是由AWS和客户共同承担的。</p><h5 id="设计原则和优势-10"><a href="#设计原则和优势-10" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>合作防御</strong>：通过AWS和客户的共同努力，可以建立更强大的安全防线。</li><li><strong>明确职责</strong>：清晰地划分责任有助于避免安全漏洞和责任模糊。</li></ul><h5 id="实践步骤-11"><a href="#实践步骤-11" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>AWS提供网络防火墙和DDoS保护服务，客户负责配置这些服务。</li><li>AWS提供身份和访问管理服务，客户负责使用这些服务来控制对资源的访问。</li><li>AWS提供日志服务，客户负责监控和分析日志数据。</li></ol><h4 id="理解责任共担模式的重要性"><a href="#理解责任共担模式的重要性" class="headerlink" title="理解责任共担模式的重要性"></a>理解责任共担模式的重要性</h4><p>理解并执行责任共担模式对于在AWS上运营的任何组织都是至关重要的，因为它有助于确保整个IT环境的安全性。</p><h5 id="设计原则和优势-11"><a href="#设计原则和优势-11" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>安全合作</strong>：确保所有安全层面都得到适当的关注和资源。</li><li><strong>风险管理</strong>：帮助组织更好地理解和管理其在云中的风险。</li></ul><h5 id="实践步骤-12"><a href="#实践步骤-12" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>客户应该了解和评估其在云中的责任。</li><li>客户应该实施必要的策略和控制措施来管理其资源。</li><li>客户应该定期进行安全评估和合规性审查。</li></ol><h3 id="将AWS安全最佳实践应用于IAM用户和根用户"><a href="#将AWS安全最佳实践应用于IAM用户和根用户" class="headerlink" title="将AWS安全最佳实践应用于IAM用户和根用户"></a>将AWS安全最佳实践应用于IAM用户和根用户</h3><ol><li><p><strong>为根用户和IAM用户启用多重验证（MFA）</strong>：</p><ul><li>根用户：AWS账户的根用户拥有完全的访问权限，因此保护它至关重要。应启用MFA，以添加一层额外的安全性。</li><li>IAM用户：对于具有重要权限的IAM用户，也应启用MFA。这可以减少因密码泄露导致的安全风险。</li></ul></li><li><p><strong>最小权限原则</strong>：</p><ul><li>仅授予必要的权限。每个IAM用户和角色都应只拥有完成其任务所需的最少权限。</li></ul></li><li><p><strong>定期审核和更新权限</strong>：</p><ul><li>定期审查IAM用户和根用户的权限，确保它们仍符合当前的业务需求。</li></ul></li><li><p><strong>使用强密码策略</strong>：</p><ul><li>为IAM用户实施强密码策略，包括密码复杂度、更换频率和历史密码的限制。</li></ul></li></ol><h3 id="设计包含IAM用户、组、角色和策略的灵活授权模型"><a href="#设计包含IAM用户、组、角色和策略的灵活授权模型" class="headerlink" title="设计包含IAM用户、组、角色和策略的灵活授权模型"></a>设计包含IAM用户、组、角色和策略的灵活授权模型</h3><ol><li><p><strong>使用IAM组管理用户权限</strong>：</p><ul><li>将具有相似权限需求的IAM用户组合到组中，这样可以更容易地管理它们的权限。</li></ul></li><li><p><strong>创建和管理IAM策略</strong>：</p><ul><li>使用IAM策略精确控制用户、组和角色的权限。可以使用AWS管理的策略或创建自定义策略。</li></ul></li><li><p><strong>利用条件语句提高安全性</strong>：</p><ul><li>在IAM策略中使用条件语句，根据需求对权限进行细粒度控制，如基于IP地址限制访问。</li></ul></li></ol><h3 id="设计基于角色的访问控制策略"><a href="#设计基于角色的访问控制策略" class="headerlink" title="设计基于角色的访问控制策略"></a>设计基于角色的访问控制策略</h3><ol><li><p><strong>使用AWS Security Token Service (AWS STS) 临时凭证</strong>：</p><ul><li>使用AWS STS生成临时安全凭证，使用户可以在有限的时间内访问AWS资源，这提高了安全性并降低了长期凭证泄露的风险。</li></ul></li><li><p><strong>角色切换</strong>：</p><ul><li>允许用户切换到具有不同权限的IAM角色，这样可以避免创建具有广泛权限的单个用户。</li></ul></li><li><p><strong>跨账户访问</strong>：</p><ul><li>通过创建IAM角色并定义信任关系，允许从一个AWS账户访问另一个账户中的资源。</li></ul></li></ol><h3 id="为多个AWS账户设计安全策略"><a href="#为多个AWS账户设计安全策略" class="headerlink" title="为多个AWS账户设计安全策略"></a>为多个AWS账户设计安全策略</h3><ol><li><p><strong>使用AWS Control Tower</strong>：</p><ul><li>AWS Control Tower提供了一种简单的方法来设置和管理多个AWS账户的安全性和合规性。</li></ul></li><li><p><strong>服务控制策略（SCP）</strong>：</p><ul><li>SCPs用于管理AWS组织中的账户权限。它们可以限制账户中可以执行的操作，从而提高整体安全性。</li></ul></li></ol><h3 id="确定AWS服务的资源策略的正确用法"><a href="#确定AWS服务的资源策略的正确用法" class="headerlink" title="确定AWS服务的资源策略的正确用法"></a>确定AWS服务的资源策略的正确用法</h3><ol><li><p><strong>利用资源策略控制访问</strong>：</p><ul><li>资源策略（如S3桶策略、Lambda函数策略）允许定义哪些实体可以执行哪些操作。</li></ul></li><li><p><strong>与IAM策略结合使用</strong>：</p><ul><li>结合使用IAM和资源策略，以实现更精细的访问控制。</li></ul></li></ol><h3 id="确定何时将Directory-Service与IAM角色联合"><a href="#确定何时将Directory-Service与IAM角色联合" class="headerlink" title="确定何时将Directory Service与IAM角色联合"></a>确定何时将Directory Service与IAM角色联合</h3><ol><li><p><strong>联合身份管理</strong>：</p><ul><li>当需要与企业目录服务（如Active Directory）集成时，可以使用联合身份管理。这允许企业用户使用其现有的身份凭证来访问AWS资源。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>当企业需要将其用户身份管理集中在现有的目录服务中时，或者需要对</li></ul></li></ol><p>访问AWS服务的用户进行详细审计时，应考虑使用联合身份管理。</p><p>以上是应用AWS安全最佳实践的一些关键方面。通过合理的设计和持续的管理，可以显著提高AWS环境的安全性。</p><h3 id="应用程序配置和凭证安全"><a href="#应用程序配置和凭证安全" class="headerlink" title="应用程序配置和凭证安全"></a>应用程序配置和凭证安全</h3><h4 id="应用程序配置和凭证安全-1"><a href="#应用程序配置和凭证安全-1" class="headerlink" title="应用程序配置和凭证安全"></a>应用程序配置和凭证安全</h4><p>在现代云基础设施中，确保应用程序配置和凭证的安全是至关重要的。不当的凭证管理和配置错误是导致安全漏洞的常见原因。以下是一些关键的最佳实践，可以帮助确保应用程序配置和凭证的安全性。</p><h4 id="管理和保护凭证"><a href="#管理和保护凭证" class="headerlink" title="管理和保护凭证"></a>管理和保护凭证</h4><p>凭证，如密码、密钥和令牌，是访问资源的关键。不正确的管理可能导致安全风险。</p><h5 id="最佳实践原则"><a href="#最佳实践原则" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>集中管理</strong>：使用集中的身份管理系统来存储和管理凭证。</li><li><strong>定期轮换</strong>：定期更换凭证，以减少被泄露的风险。</li></ul><h5 id="实践步骤-13"><a href="#实践步骤-13" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Secrets Manager或类似服务存储敏感凭证。</li><li>定期自动更换数据库和服务的密码。</li><li>实施凭证轮换策略，确保旧凭证在一定时间后失效。</li></ol><h4 id="使用环境变量存储配置"><a href="#使用环境变量存储配置" class="headerlink" title="使用环境变量存储配置"></a>使用环境变量存储配置</h4><p>将应用程序配置存储在环境变量中，而不是硬编码在应用程序代码中，可以提高灵活性和安全性。</p><h5 id="最佳实践原则-1"><a href="#最佳实践原则-1" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>分离配置</strong>：将配置与代码分离，使之可以在不同环境中重复使用。</li><li><strong>避免硬编码</strong>：不要在代码中硬编码敏感信息。</li></ul><h5 id="实践步骤-14"><a href="#实践步骤-14" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序的启动脚本中设置环境变量。</li><li>使用AWS Elastic Beanstalk、AWS Lambda或其他服务的配置选项来管理环境变量。</li><li>确保不在源代码仓库中暴露环境变量的值。</li></ol><h4 id="实施应用层加密"><a href="#实施应用层加密" class="headerlink" title="实施应用层加密"></a>实施应用层加密</h4><p>对敏感数据进行应用层加密可以保护数据，即使在传输过程中或在数据存储时被截获也能保持其安全性。</p><h5 id="最佳实践原则-2"><a href="#最佳实践原则-2" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>端到端加密</strong>：加密数据传输和存储过程中的所有敏感信息。</li><li><strong>使用强加密标准</strong>：使用行业标准的加密算法和协议。</li></ul><h5 id="实践步骤-15"><a href="#实践步骤-15" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用TLS/SSL协议加密数据在传输中的敏感信息。</li><li>在数据库或存储层加密敏感数据。</li><li>使用AWS KMS或类似服务管理加密密钥。</li></ol><h4 id="定期审计和监控"><a href="#定期审计和监控" class="headerlink" title="定期审计和监控"></a>定期审计和监控</h4><p>通过定期审计和监控，可以发现潜在的安全问题，并确保凭证和配置的安全性。</p><h5 id="最佳实践原则-3"><a href="#最佳实践原则-3" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>持续监控</strong>：实时监控配置和凭证的使用情况。</li><li><strong>定期审计</strong>：定期审查配置和凭证的安全性。</li></ul><h5 id="实践步骤-16"><a href="#实践步骤-16" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>利用AWS CloudTrail监控对敏感凭证的访问。</li><li>定期检查IAM权限和凭证的使用情况。</li><li>使用自动化工具检测配置的不一致性和潜在的安全问题。</li></ol><h4 id="敏感数据的访问控制"><a href="#敏感数据的访问控制" class="headerlink" title="敏感数据的访问控制"></a>敏感数据的访问控制</h4><p>确保只有授权用户和系统能够访问敏感数据。</p><h5 id="最佳实践原则-4"><a href="#最佳实践原则-4" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>最小权限</strong>：遵循最小权限原则，仅授予必要的访问权限。</li><li><strong>细粒度控制</strong>：实施细粒度的访问控制策略。</li></ul><h5 id="实践步骤-17"><a href="#实践步骤-17" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用IAM角色和策略来限制对敏感数据的访问。</li><li>在数据库和文件存储级别实现访问控制。</li><li>审查和更新访问权限，以反映组织变化或人员变动。</li></ol><h3 id="AWS-服务终端节点"><a href="#AWS-服务终端节点" class="headerlink" title="AWS 服务终端节点"></a>AWS 服务终端节点</h3><h4 id="AWS-服务终端节点（VPC-Endpoints）"><a href="#AWS-服务终端节点（VPC-Endpoints）" class="headerlink" title="AWS 服务终端节点（VPC Endpoints）"></a>AWS 服务终端节点（VPC Endpoints）</h4><p>AWS服务终端节点允许你在Amazon Virtual Private Cloud (VPC)内部安全地连接到AWS服务，而无需通过公共互联网。这样可以减少数据被截获的风险，并可能提高连接速度。</p><h4 id="理解服务终端节点"><a href="#理解服务终端节点" class="headerlink" title="理解服务终端节点"></a>理解服务终端节点</h4><p>服务终端节点是AWS为了提高网络安全和效率而设计的一种机制，它们与传统的通过公网访问AWS服务的方式不同。</p><h5 id="最佳实践原则-5"><a href="#最佳实践原则-5" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：通过私有网络访问AWS服务，减少对公共互联网的依赖。</li><li><strong>性能</strong>：可能提高访问速度，因为数据不必离开Amazon网络。</li></ul><h5 id="实践步骤-18"><a href="#实践步骤-18" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在VPC控制台中创建终端节点。</li><li>选择你需要连接的AWS服务（例如S3或DynamoDB）。</li><li>指定VPC和子网，以及要关联的路由表。</li><li>设置安全组，以控制流向服务的流量。</li></ol><h4 id="配置服务终端节点"><a href="#配置服务终端节点" class="headerlink" title="配置服务终端节点"></a>配置服务终端节点</h4><p>配置服务终端节点时，需要确定哪些资源需要通过终端节点进行通信，并相应地配置网络。</p><h5 id="最佳实践原则-6"><a href="#最佳实践原则-6" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>精确配置</strong>：确保仅允许必要的流量通过终端节点。</li><li><strong>细粒度访问控制</strong>：使用IAM策略来控制对服务的访问。</li></ul><h5 id="实践步骤-19"><a href="#实践步骤-19" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为需要访问AWS服务的资源创建终端节点。</li><li>配置路由表，以确保流量定向到终端节点。</li><li>设定安全组规则，限制通过终端节点的流量类型。</li><li>如果可能，使用IAM策略进一步限制对服务的访问。</li></ol><h4 id="监控服务终端节点"><a href="#监控服务终端节点" class="headerlink" title="监控服务终端节点"></a>监控服务终端节点</h4><p>监控是确保服务终端节点安全和高效运行的关键环节。AWS提供了多种工具来帮助监控这些终端节点。</p><h5 id="最佳实践原则-7"><a href="#最佳实践原则-7" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>可见性</strong>：确保你可以监控和记录通过终端节点的所有流量。</li><li><strong>报告</strong>：定期查看终端节点的性能和安全性报告。</li></ul><h5 id="实践步骤-20"><a href="#实践步骤-20" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用VPC流日志来捕获有关网络流量的信息。</li><li>利用AWS CloudWatch监控终端节点的性能指标。</li><li>定期审查安全日志，以检测异常或未授权的访问尝试。</li></ol><h4 id="故障排除服务终端节点"><a href="#故障排除服务终端节点" class="headerlink" title="故障排除服务终端节点"></a>故障排除服务终端节点</h4><p>当服务终端节点出现问题时，需要能够快速诊断和解决问题。</p><h5 id="最佳实践原则-8"><a href="#最佳实践原则-8" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>响应性</strong>：迅速识别和响应终端节点的问题。</li><li><strong>详细日志</strong>：保持详细的日志记录，以便于故障排除。</li></ul><h5 id="实践步骤-21"><a href="#实践步骤-21" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>验证路由表和网络ACLs配置是否正确。</li><li>检查安全组规则，确保它们没有阻止预期的流量。</li><li>查看VPC流日志和CloudWatch指标，寻找任何异常。</li><li>如果使用了IAM策略，确认策略允许预期的访问。</li></ol><h3 id="控制-AWS-上的端口、协议和网络流量"><a href="#控制-AWS-上的端口、协议和网络流量" class="headerlink" title="控制 AWS 上的端口、协议和网络流量"></a>控制 AWS 上的端口、协议和网络流量</h3><h4 id="控制-AWS-上的端口、协议和网络流量-1"><a href="#控制-AWS-上的端口、协议和网络流量-1" class="headerlink" title="控制 AWS 上的端口、协议和网络流量"></a>控制 AWS 上的端口、协议和网络流量</h4><p>在AWS中，对端口、协议和网络流量的控制是通过网络访问控制列表（Network Access Control Lists, NACLs）、安全组（Security Groups）和路由表来实现的。这些工具共同作用于AWS的虚拟私有云（VPC）中，确保了网络流量的安全和合规。</p><h4 id="理解端口和协议"><a href="#理解端口和协议" class="headerlink" title="理解端口和协议"></a>理解端口和协议</h4><p>在网络通信中，端口和协议是数据传输的基础。端口是网络连接的逻辑端点，而协议则定义了数据如何在网络中传输。</p><h5 id="最佳实践原则-9"><a href="#最佳实践原则-9" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>明确定义</strong>：清晰定义哪些端口和协议对业务是必需的。</li><li><strong>最小暴露</strong>：仅开放必要的端口和协议，以减少潜在的攻击面。</li></ul><h5 id="实践步骤-22"><a href="#实践步骤-22" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>识别应用程序和服务所需的端口和协议。</li><li>确定哪些端口需要对外开放，哪些可以仅在内部网络中访问。</li><li>规划公共和私有子网中的资源布局，以控制端口和协议的暴露。</li></ol><h4 id="使用安全组控制访问"><a href="#使用安全组控制访问" class="headerlink" title="使用安全组控制访问"></a>使用安全组控制访问</h4><p>安全组是AWS中控制实例访问的主要工具。它们允许或拒绝到达实例的流量，并且是状态性的，这意味着返回流量自动允许。</p><h5 id="最佳实践原则-10"><a href="#最佳实践原则-10" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>实例级别保护</strong>：为每个实例配置安全组，以提供精细的访问控制。</li><li><strong>默认拒绝所有</strong>：默认情况下拒绝所有入站流量，仅按需开放。</li></ul><h5 id="实践步骤-23"><a href="#实践步骤-23" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建安全组并定义入站和出站规则。</li><li>为每个服务和应用程序配置专用的安全组。</li><li>定期审查和更新安全组规则，以保持最新的安全状态。</li></ol><h4 id="利用-NACLs-控制子网流量"><a href="#利用-NACLs-控制子网流量" class="headerlink" title="利用 NACLs 控制子网流量"></a>利用 NACLs 控制子网流量</h4><p>NACLs提供了一种在子网级别控制流量的方法。与安全组不同，NACLs是无状态的，需要为入站和出站流量分别定义规则。</p><h5 id="最佳实践原则-11"><a href="#最佳实践原则-11" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>子网级别保护</strong>：使用NACLs为整个子网提供一层额外的安全。</li><li><strong>明确规则</strong>：明确地定义允许和拒绝的规则，以防止未授权的访问。</li></ul><h5 id="实践步骤-24"><a href="#实践步骤-24" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个子网创建NACL。</li><li>配置入站和出站规则，以控制流量。</li><li>定期检查和维护NACL规则，确保它们符合当前的安全策略。</li></ol><h4 id="管理路由表"><a href="#管理路由表" class="headerlink" title="管理路由表"></a>管理路由表</h4><p>路由表决定了网络包在VPC内以及VPC外的目的地。通过管理路由表，可以控制网络流量的方向。</p><h5 id="最佳实践原则-12"><a href="#最佳实践原则-12" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>明确路由</strong>：确保路由表中的路由清晰，且正确地反映了网络设计。</li><li><strong>安全路由</strong>：避免创建可能导致数据泄露的不安全路由。</li></ul><h5 id="实践步骤-25"><a href="#实践步骤-25" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为VPC和每个子网创建和配置路由表。</li><li>确保路由表中的条目正确地指向网络流量的预期目的地。</li><li>定期审查路由表，确保它们没有过时的或不必要的路由。</li></ol><h4 id="监控和审计网络流量"><a href="#监控和审计网络流量" class="headerlink" title="监控和审计网络流量"></a>监控和审计网络流量</h4><p>要确保网络安全，需要对网络流量进行持续的监控和审计。</p><h5 id="最佳实践原则-13"><a href="#最佳实践原则-13" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>持续监控</strong>：实时监控网络流量，以便快速发现异常。</li><li><strong>审计日志</strong>：保留审计日志，以便在需要时回溯和分析。</li></ul><h5 id="实践步骤-26"><a href="#实践步骤-26" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS CloudTrail和VPC流日志进行网络流量监控。</li><li>定期审查日志文件，寻找异常或不符合策略的流量模式。</li><li>利用AWS服务和第三方工具自动化异常检测和报警。</li></ol><h3 id="安全应用程序访问"><a href="#安全应用程序访问" class="headerlink" title="安全应用程序访问"></a>安全应用程序访问</h3><h4 id="安全应用程序访问-1"><a href="#安全应用程序访问-1" class="headerlink" title="安全应用程序访问"></a>安全应用程序访问</h4><p>在云环境中，安全地控制对应用程序的访问是至关重要的。这涉及到确保只有授权用户能够访问应用程序，并且应用程序的数据传输是安全的。以下是如何在AWS环境中实现安全应用程序访问的指导。</p><h4 id="实施身份和访问管理-IAM"><a href="#实施身份和访问管理-IAM" class="headerlink" title="实施身份和访问管理 (IAM)"></a>实施身份和访问管理 (IAM)</h4><p>AWS的身份和访问管理（IAM）允许你精确控制谁可以在AWS中做什么。它是保证应用程序访问安全的基础。</p><h5 id="最佳实践原则-14"><a href="#最佳实践原则-14" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>最小权限</strong>：确保用户和服务仅具有执行其任务所必需的权限。</li><li><strong>角色分离</strong>：为不同的任务和责任创建不同的角色。</li></ul><h5 id="实践步骤-27"><a href="#实践步骤-27" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个用户和应用程序创建IAM用户和角色。</li><li>为每个角色分配最小的权限集。</li><li>定期审计IAM策略和权限，确保它们仍然符合业务需求。</li></ol><h4 id="启用多因素认证-MFA"><a href="#启用多因素认证-MFA" class="headerlink" title="启用多因素认证 (MFA)"></a>启用多因素认证 (MFA)</h4><p>多因素认证（MFA）为AWS账户添加了一个额外的安全层，要求用户在登录时提供两个或更多的验证因素。</p><h5 id="最佳实践原则-15"><a href="#最佳实践原则-15" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>强制MFA</strong>：对所有用户，特别是具有高权限的用户，强制使用MFA。</li><li><strong>多样化认证方式</strong>：使用不同类型的认证因素，如密码、手机应用或硬件令牌。</li></ul><h5 id="实践步骤-28"><a href="#实践步骤-28" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在IAM设置中为用户启用MFA。</li><li>教育用户如何正确设置和使用MFA设备。</li><li>定期检查确保所有用户都启用了MFA。</li></ol><h4 id="配置网络安全"><a href="#配置网络安全" class="headerlink" title="配置网络安全"></a>配置网络安全</h4><p>网络安全设置是保护应用程序不受恶意访问的关键组成部分。</p><h5 id="最佳实践原则-16"><a href="#最佳实践原则-16" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全组和NACLs</strong>：正确配置安全组和NACLs来控制进出网络流量。</li><li><strong>私有链接</strong>：使用VPC私有链接确保内部应用程序之间的安全通信。</li></ul><h5 id="实践步骤-29"><a href="#实践步骤-29" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>根据需要创建和配置安全组和NACLs。</li><li>使用VPC Endpoints连接到AWS服务，避免流量经过公共互联网。</li><li>对于不应公开访问的内部应用程序，确保它们部署在私有子网中。</li></ol><h4 id="加密数据传输"><a href="#加密数据传输" class="headerlink" title="加密数据传输"></a>加密数据传输</h4><p>确保数据在传输过程中被加密，以防止数据在途中被截获或篡改。</p><h5 id="最佳实践原则-17"><a href="#最佳实践原则-17" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>强制TLS</strong>：对所有传入和传出的通信使用传输层安全性（TLS）加密。</li><li><strong>证书管理</strong>：使用AWS Certificate Manager或其他工具来管理和自动更新TLS证书。</li></ul><h5 id="实践步骤-30"><a href="#实践步骤-30" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>配置应用程序使用HTTPS进行所有通信。</li><li>使用AWS Certificate Manager为应用程序获取和管理SSL/TLS证书。</li><li>确保所有的API和服务端点都强制使用加密连接。</li></ol><h4 id="实施应用程序层防火墙"><a href="#实施应用程序层防火墙" class="headerlink" title="实施应用程序层防火墙"></a>实施应用程序层防火墙</h4><p>AWS Web Application Firewall (WAF) 可以帮助保护你的应用程序不受网络攻击。</p><h5 id="最佳实践原则-18"><a href="#最佳实践原则-18" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定制规则</strong>：根据应用程序的具体需求定制WAF规则。</li><li><strong>实时监控</strong>：监控应用程序的流量，并根据需要调整WAF规则。</li></ul><h5 id="实践步骤-31"><a href="#实践步骤-31" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序的入口点配置AWS WAF。</li><li>创建和实施包含SQL注入和跨站脚本保护的规则集。</li><li>定期审查和更新WAF规则，以应对新出现的威胁。</li></ol><h4 id="审计日志和持续监控"><a href="#审计日志和持续监控" class="headerlink" title="审计日志和持续监控"></a>审计日志和持续监控</h4><p>持续监控和记录审计日志是发现和响应安全事件的关键。</p><h5 id="最佳实践原则-19"><a href="#最佳实践原则-19" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>日志记录</strong>：启用AWS CloudTrail和其他日志服务来记录所有操作。</li><li><strong>监控系统</strong>：使用Amazon CloudWatch等工具实时监控系统性能和安全事件。</li></ul><h5 id="实践步骤-32"><a href="#实践步骤-32" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>配置CloudTrail来记录所有AWS API调用。</li><li>使用CloudWatch来监控和报警异常行为。</li><li>利用AWS Lambda等服务自动化响应策略。</li></ol><h3 id="AWS-外部的威胁向量（例如，DDoS、SQL-注入）"><a href="#AWS-外部的威胁向量（例如，DDoS、SQL-注入）" class="headerlink" title="AWS 外部的威胁向量（例如，DDoS、SQL 注入）"></a>AWS 外部的威胁向量（例如，DDoS、SQL 注入）</h3><h4 id="AWS-外部威胁向量介绍"><a href="#AWS-外部威胁向量介绍" class="headerlink" title="AWS 外部威胁向量介绍"></a>AWS 外部威胁向量介绍</h4><p>在AWS环境中，外部威胁向量指的是那些源自互联网的攻击和风险，它们可能会对运行在AWS上的服务和数据造成损害。理解这些威胁向量及其防御措施对于确保AWS资源的安全至关重要。</p><h4 id="防御分布式拒绝服务-DDoS-攻击"><a href="#防御分布式拒绝服务-DDoS-攻击" class="headerlink" title="防御分布式拒绝服务(DDoS)攻击"></a>防御分布式拒绝服务(DDoS)攻击</h4><p>分布式拒绝服务(DDoS)攻击是一种常见的网络攻击，旨在通过超载目标的网络或服务器资源来使其不可用。</p><h5 id="最佳实践原则-20"><a href="#最佳实践原则-20" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>缓解和吸收</strong>：使用AWS Shield等服务来缓解和吸收DDoS攻击。</li><li><strong>弹性架构</strong>：设计弹性架构以分散流量和减轻攻击影响。</li></ul><h5 id="实践步骤-33"><a href="#实践步骤-33" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS Shield Standard或AWS Shield Advanced来提供自动化的DDoS防护。</li><li>利用Amazon CloudFront和Amazon Route 53来分散流量和提高可用性。</li><li>实施自动缩放策略，以便在流量激增时增加资源。</li></ol><h4 id="防护SQL注入攻击"><a href="#防护SQL注入攻击" class="headerlink" title="防护SQL注入攻击"></a>防护SQL注入攻击</h4><p>SQL注入攻击是一种代码注入技术，攻击者试图通过在应用程序的输入中注入恶意SQL语句来操纵后端数据库。</p><h5 id="最佳实践原则-21"><a href="#最佳实践原则-21" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>输入验证</strong>：对所有用户输入进行严格的验证。</li><li><strong>使用参数化查询</strong>：避免直接在SQL语句中拼接用户输入。</li></ul><h5 id="实践步骤-34"><a href="#实践步骤-34" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用预编译的SQL语句或数据库存储过程来避免注入风险。</li><li>在应用程序层面实现输入验证和清理措施。</li><li>对数据库访问权限进行最小化，限制数据库用户的权限。</li></ol><h4 id="防御跨站脚本-XSS-攻击"><a href="#防御跨站脚本-XSS-攻击" class="headerlink" title="防御跨站脚本(XSS)攻击"></a>防御跨站脚本(XSS)攻击</h4><p>跨站脚本(XSS)攻击允许攻击者在用户浏览器中执行恶意脚本，通常是通过注入未经过滤的用户输入到网页中。</p><h5 id="最佳实践原则-22"><a href="#最佳实践原则-22" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>内容安全策略</strong>：实施内容安全策略(CSP)来限制可以执行的脚本。</li><li><strong>输出编码</strong>：对所有用户生成的输出进行编码。</li></ul><h5 id="实践步骤-35"><a href="#实践步骤-35" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>对所有用户输入进行过滤和转义，尤其是在输出到HTML页面时。</li><li>实施CSP，并将其设置为只允许信任的脚本来源。</li><li>使用Web应用程序防火墙(WAF)来识别和阻止XSS攻击。</li></ol><h4 id="防御钓鱼攻击"><a href="#防御钓鱼攻击" class="headerlink" title="防御钓鱼攻击"></a>防御钓鱼攻击</h4><p>钓鱼攻击通常通过伪装成可信实体来诱骗用户提供敏感信息，如用户名、密码和信用卡详情。</p><h5 id="最佳实践原则-23"><a href="#最佳实践原则-23" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>用户教育</strong>：教育用户识别钓鱼邮件和链接。</li><li><strong>安全协议</strong>：使用HTTPS和电子邮件安全协议如SPF、DKIM和DMARC。</li></ul><h5 id="实践步骤-36"><a href="#实践步骤-36" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为所有网站和在线服务启用SSL/TLS加密。</li><li>教育员工关于钓鱼攻击的识别和响应方法。</li><li>配置SPF、DKIM和DMARC来验证发出的电子邮件并减少钓鱼邮件。</li></ol><h4 id="防御恶意软件和病毒"><a href="#防御恶意软件和病毒" class="headerlink" title="防御恶意软件和病毒"></a>防御恶意软件和病毒</h4><p>恶意软件和病毒可以通过多种途径感染AWS资源，包括通过电子邮件附件、下载链接或通过感染的设备。</p><h5 id="最佳实践原则-24"><a href="#最佳实践原则-24" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期扫描</strong>：定期进行恶意软件和病毒扫描。</li><li><strong>访问控制</strong>：限制对敏感系统的访问，仅限必要的服务和用户。</li></ul><h5 id="实践步骤-37"><a href="#实践步骤-37" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Marketplace中的安全解决方案来扫描和监控AWS环境。</li><li>实施强大的端点保护策略，包括反病毒软件和入侵检测系统。</li><li>定期更新操作系统和应用程序，以修补已知的安全漏洞。</li></ol><h3 id="设计带安全组件的VPC架构"><a href="#设计带安全组件的VPC架构" class="headerlink" title="设计带安全组件的VPC架构"></a>设计带安全组件的VPC架构</h3><h4 id="安全组和网络ACL"><a href="#安全组和网络ACL" class="headerlink" title="安全组和网络ACL"></a>安全组和网络ACL</h4><ul><li><strong>安全组（SG）</strong>：作为虚拟防火墙，控制着对EC2实例的访问。为每个EC2实例配置合适的入站和出站规则，确保只允许必要的流量。</li><li><strong>网络访问控制列表（ACL）</strong>：作为VPC内各子网的附加安全层，用于控制进出子网的流量。配置网络ACL以允许或拒绝特定类型的流量。</li></ul><h4 id="路由表和NAT网关"><a href="#路由表和NAT网关" class="headerlink" title="路由表和NAT网关"></a>路由表和NAT网关</h4><ul><li><strong>路由表</strong>：确定网络流量如何从VPC的一个子网路由到另一个子网或外部网络。为每个子网分配合适的路由表。</li><li><strong>NAT网关</strong>：在私有子网中的实例需要访问互联网时使用NAT网关。它使私有子网中的实例能够发起向外部互联网的连接，同时阻止来自互联网的直接访问。</li></ul><h3 id="确定网络分段策略"><a href="#确定网络分段策略" class="headerlink" title="确定网络分段策略"></a>确定网络分段策略</h3><h4 id="公有子网和私有子网"><a href="#公有子网和私有子网" class="headerlink" title="公有子网和私有子网"></a>公有子网和私有子网</h4><ul><li><strong>公有子网</strong>：包含需要从互联网直接访问的资源（如Web服务器）。公有子网中的实例通常配置有公网IP地址。</li><li><strong>私有子网</strong>：用于不需要直接从互联网访问的资源（如数据库）。私有子网中的实例无法直接从互联网访问，提供了更高的安全性。</li></ul><h3 id="将AWS服务集成到安全应用程序"><a href="#将AWS服务集成到安全应用程序" class="headerlink" title="将AWS服务集成到安全应用程序"></a>将AWS服务集成到安全应用程序</h3><h4 id="AWS-Shield、AWS-WAF和IAM-Identity-Center"><a href="#AWS-Shield、AWS-WAF和IAM-Identity-Center" class="headerlink" title="AWS Shield、AWS WAF和IAM Identity Center"></a>AWS Shield、AWS WAF和IAM Identity Center</h4><ul><li><strong>AWS Shield</strong>：提供DDoS保护，保护AWS资源（如EC2、Elastic Load Balancing等）免受DDoS攻击。</li><li><strong>AWS WAF（Web Application Firewall）</strong>：保护应用程序免受Web攻击，可以创建自定义的Web安全规则。</li><li><strong>IAM Identity Center（原AWS SSO）</strong>：提供单点登录（SSO），管理对AWS账户和应用程序的访问。</li></ul><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li><strong>AWS Secrets Manager</strong>：保护访问密钥和其他敏感信息，可以轻松地在应用中管理和检索机密。</li></ul><h3 id="保护与AWS云的外部网络连接"><a href="#保护与AWS云的外部网络连接" class="headerlink" title="保护与AWS云的外部网络连接"></a>保护与AWS云的外部网络连接</h3><h4 id="VPN和AWS-Direct-Connect"><a href="#VPN和AWS-Direct-Connect" class="headerlink" title="VPN和AWS Direct Connect"></a>VPN和AWS Direct Connect</h4><ul><li><strong>VPN（虚拟私人网络）</strong>：安全地将本地网络连接到AWS VPC。利用IPSec VPN连接，可以建立加密的通道，保护数据传输。</li><li><strong>AWS Direct Connect</strong>：通过私有网络连接来访问AWS服务，提供更可靠、更高带宽的连接选项，同时降低网络成本。</li></ul><p>以上是构建安全AWS VPC架构的关键组件和策略。通过结合使用这些服务和配置，可以创建一个既安全又高效的网络环境。</p><h3 id="数据访问和监管"><a href="#数据访问和监管" class="headerlink" title="数据访问和监管"></a>数据访问和监管</h3><h4 id="数据访问和监管概述"><a href="#数据访问和监管概述" class="headerlink" title="数据访问和监管概述"></a>数据访问和监管概述</h4><p>在AWS云环境中，数据访问和监管涉及确保数据的安全性和合规性，以及控制和监视数据的访问。这包括实施策略和技术措施来保护数据，确保只有授权用户才能访问敏感信息，并遵守相关的法律和行业标准。</p><h4 id="实施数据访问控制"><a href="#实施数据访问控制" class="headerlink" title="实施数据访问控制"></a>实施数据访问控制</h4><p>数据访问控制是确保数据安全性的关键部分，它涉及到限制对数据的访问和操作。</p><h5 id="最佳实践原则-25"><a href="#最佳实践原则-25" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>基于角色的访问控制</strong> (RBAC): 为不同的用户分配基于角色的权限。</li><li><strong>最小权限原则</strong>: 限制用户只能访问他们执行职责所必需的数据。</li></ul><h5 id="实践步骤-38"><a href="#实践步骤-38" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义数据访问角色，并为每个角色分配适当的权限。</li><li>使用AWS IAM来创建和管理用户、组、角色和权限策略。</li><li>定期审查和调整IAM策略，确保它们符合最小权限原则。</li></ol><h4 id="监管数据访问"><a href="#监管数据访问" class="headerlink" title="监管数据访问"></a>监管数据访问</h4><p>监管数据访问是指监控和记录对数据的所有访问尝试，无论是成功还是失败的。</p><h5 id="最佳实践原则-26"><a href="#最佳实践原则-26" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>全面的审计日志</strong>: 记录所有数据访问尝试的详细日志。</li><li><strong>实时监控</strong>: 使用工具实时监控数据访问模式和潜在的异常活动。</li></ul><h5 id="实践步骤-39"><a href="#实践步骤-39" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS CloudTrail来记录和监控API调用。</li><li>配置Amazon S3存储桶访问日志记录所有请求。</li><li>利用Amazon CloudWatch或AWS Config来创建自定义监控和警报。</li></ol><h4 id="数据保护和加密"><a href="#数据保护和加密" class="headerlink" title="数据保护和加密"></a>数据保护和加密</h4><p>保护数据的完整性和保密性需要在传输和静态时对数据进行加密。</p><h5 id="最佳实践原则-27"><a href="#最佳实践原则-27" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>传输中加密</strong>: 使用SSL/TLS等协议在传输过程中加密数据。</li><li><strong>静态数据加密</strong>: 存储数据时使用服务器端加密。</li></ul><h5 id="实践步骤-40"><a href="#实践步骤-40" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>对所有传输中的数据使用HTTPS和其他安全协议。</li><li>在Amazon S3等服务中启用服务器端加密（如SSE-S3、SSE-KMS）。</li><li>管理加密密钥，使用AWS Key Management Service (KMS)来创建和控制加密密钥。</li></ol><h4 id="遵守合规性要求"><a href="#遵守合规性要求" class="headerlink" title="遵守合规性要求"></a>遵守合规性要求</h4><p>合规性要求可能来自行业标准、法律法规或公司政策，需要确保数据访问和处理符合这些要求。</p><h5 id="最佳实践原则-28"><a href="#最佳实践原则-28" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>了解合规性框架</strong>: 熟悉适用于组织的合规性框架，如GDPR、HIPAA。</li><li><strong>实施合规性控制</strong>: 根据合规性要求实施相应的控制措施。</li></ul><h5 id="实践步骤-41"><a href="#实践步骤-41" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>评估适用的合规性要求，并将其整合到数据访问策略中。</li><li>利用AWS的合规性报告和认证，如AWS Artifact提供的文档。</li><li>实施定期的合规性审计和自我评估，确保持续合规。</li></ol><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="数据恢复概述"><a href="#数据恢复概述" class="headerlink" title="数据恢复概述"></a>数据恢复概述</h4><p>数据恢复是指在数据丢失或损坏后恢复数据的过程。在AWS云中，数据恢复策略是确保业务连续性和灾难恢复计划的重要组成部分。这包括备份数据、确保备份的完整性以及在必要时迅速有效地恢复数据。</p><h4 id="设计数据备份策略"><a href="#设计数据备份策略" class="headerlink" title="设计数据备份策略"></a>设计数据备份策略</h4><p>有效的数据备份策略是数据恢复计划的核心。它应该包括定期备份的计划和确保备份数据的安全性和可用性。</p><h5 id="最佳实践原则-29"><a href="#最佳实践原则-29" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期自动备份</strong>：自动定期备份数据以减少人为错误和遗漏。</li><li><strong>多地域冗余存储</strong>：在多个地理位置存储备份，以防止单点故障。</li></ul><h5 id="实践步骤-42"><a href="#实践步骤-42" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Backup服务来集中管理和自动化备份任务。</li><li>利用Amazon S3的跨区域复制功能来存储备份数据的副本。</li><li>确保备份数据的加密，以保护数据在传输和存储中的安全。</li></ol><h4 id="测试和验证备份"><a href="#测试和验证备份" class="headerlink" title="测试和验证备份"></a>测试和验证备份</h4><p>备份数据的存在并不足以确保数据恢复的成功。定期测试和验证备份是必要的步骤。</p><h5 id="最佳实践原则-30"><a href="#最佳实践原则-30" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期恢复测试</strong>：定期进行恢复测试以验证备份数据的完整性。</li><li><strong>监控备份活动</strong>：监控备份过程，确保没有失败或遗漏。</li></ul><h5 id="实践步骤-43"><a href="#实践步骤-43" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定期执行恢复测试，以验证备份的完整性和可用性。</li><li>使用AWS CloudTrail和Amazon CloudWatch来监控备份和恢复活动。</li><li>记录和分析测试结果，确保符合恢复时间目标(RTO)和恢复点目标(RPO)。</li></ol><h4 id="实施灾难恢复计划"><a href="#实施灾难恢复计划" class="headerlink" title="实施灾难恢复计划"></a>实施灾难恢复计划</h4><p>灾难恢复(DR)计划是确保在发生灾难时能够快速恢复操作的详细指南。</p><h5 id="最佳实践原则-31"><a href="#最佳实践原则-31" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>多层次备份策略</strong>：实施多层次的备份策略，包括快照、复制和归档。</li><li><strong>自动化恢复流程</strong>：自动化恢复流程以减少恢复时间。</li></ul><h5 id="实践步骤-44"><a href="#实践步骤-44" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义业务影响分析(BIA)并建立恢复优先级。</li><li>设计并实施灾难恢复方案，如AWS的Pilot Light、Warm Standby或Multi-Site方案。</li><li>编写和维护详细的灾难恢复文档，并定期进行演练。</li></ol><h3 id="数据留存和分类"><a href="#数据留存和分类" class="headerlink" title="数据留存和分类"></a>数据留存和分类</h3><h4 id="数据留存和分类概述"><a href="#数据留存和分类概述" class="headerlink" title="数据留存和分类概述"></a>数据留存和分类概述</h4><p>数据留存和分类是数据管理策略的关键组成部分，涉及保留数据的时间长度以及如何组织数据以便于访问和合规性。在AWS云中，这意味着使用合适的服务和工具来存储、分类和管理数据的生命周期。</p><h4 id="确定数据留存策略"><a href="#确定数据留存策略" class="headerlink" title="确定数据留存策略"></a>确定数据留存策略</h4><p>数据留存策略决定了数据应该保留多久，以及何时应该删除或归档数据。</p><h5 id="最佳实践原则-32"><a href="#最佳实践原则-32" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>合规性和业务需求</strong>：根据法律法规和业务需求确定数据留存期限。</li><li><strong>成本效益分析</strong>：考虑数据留存的成本和价值，进行成本效益分析。</li></ul><h5 id="实践步骤-45"><a href="#实践步骤-45" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>审查法律法规和业务政策，确定数据留存的最小和最大期限。</li><li>使用AWS的数据生命周期管理策略来自动删除过期的数据。</li><li>配置Amazon S3生命周期策略，自动将数据转移到更低成本的存储类别或归档服务。</li></ol><h4 id="实施数据分类"><a href="#实施数据分类" class="headerlink" title="实施数据分类"></a>实施数据分类</h4><p>数据分类是对数据进行标记和分组的过程，以便于管理和检索。</p><h5 id="最佳实践原则-33"><a href="#最佳实践原则-33" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>数据敏感性和重要性</strong>：根据数据的敏感性和业务重要性进行分类。</li><li><strong>一致的标签系统</strong>：使用一致的标签系统来简化数据分类和检索。</li></ul><h5 id="实践步骤-46"><a href="#实践步骤-46" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为数据定义分类标准，如公开、机密、高度机密等。</li><li>使用AWS资源标签来分类和管理数据和其他AWS资源。</li><li>利用Amazon Macie等服务自动发现和分类敏感数据。</li></ol><h4 id="管理数据留存和分类"><a href="#管理数据留存和分类" class="headerlink" title="管理数据留存和分类"></a>管理数据留存和分类</h4><p>有效的数据留存和分类管理不仅要设置策略，还需要持续监控和调整这些策略。</p><h5 id="最佳实践原则-34"><a href="#最佳实践原则-34" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期审查</strong>：定期审查数据留存和分类策略，确保它们仍然适用。</li><li><strong>自动化流程</strong>：尽可能自动化数据留存和分类的流程。</li></ul><h5 id="实践步骤-47"><a href="#实践步骤-47" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定期进行内部或外部审计，以确保遵守数据留存政策。</li><li>利用AWS的自动化工具，如AWS Lambda，来自动执行数据分类和留存策略的更新。</li><li>教育员工关于数据留存和分类的最佳实践，确保组织内部的一致性。</li></ol><h4 id="数据留存和分类的监控与报告"><a href="#数据留存和分类的监控与报告" class="headerlink" title="数据留存和分类的监控与报告"></a>数据留存和分类的监控与报告</h4><p>监控和报告是确保数据留存和分类策略有效执行的重要组成部分。</p><h5 id="最佳实践原则-35"><a href="#最佳实践原则-35" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>透明度</strong>：确保数据留存和分类的过程具有高度透明度。</li><li><strong>可审计性</strong>：保持记录，确保数据留存和分类的过程可审计。</li></ul><h5 id="实践步骤-48"><a href="#实践步骤-48" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用Amazon CloudWatch来监控数据留存和分类相关的指标和警报。</li><li>利用AWS CloudTrail来记录和审计数据相关的操作。</li><li>生成定期报告，以向管理层展示数据留存和分类的状态和活动。</li></ol><p>要调整AWS技术以满足合规性要求并实现数据的安全保护，可以遵循以下步骤：</p><h3 id="对数据进行静态加密"><a href="#对数据进行静态加密" class="headerlink" title="对数据进行静态加密"></a>对数据进行静态加密</h3><ol><li><strong>使用AWS Key Management Service (AWS KMS)</strong>: AWS KMS允许您创建和管理加密密钥，并通过使用硬件安全模块控制它们的使用。这些密钥可以用来加密存储在AWS服务中的数据。</li><li><strong>创建密钥</strong>: 在AWS KMS中创建一个新的客户主键（CMK）。可以选择密钥用途和自动轮换设置。</li><li><strong>加密数据</strong>: 使用创建的CMK对需要静态加密的数据进行加密。这可以通过集成的AWS服务（如S3、EBS等）或直接通过KMS API实现。</li></ol><h3 id="对数据进行传输中加密"><a href="#对数据进行传输中加密" class="headerlink" title="对数据进行传输中加密"></a>对数据进行传输中加密</h3><ol><li><strong>使用AWS Certificate Manager (ACM)</strong>: ACM允许您轻松地部署、管理和自动续订SSL/TLS证书。</li><li><strong>创建和部署证书</strong>: 在ACM中创建一个SSL/TLS证书，并将其部署到支持HTTPS的AWS服务（如ELB、CloudFront）。</li><li><strong>配置TLS加密</strong>: 确保所有的数据传输都通过TLS加密通道进行，以保证数据在传输过程中的安全。</li></ol><h3 id="对加密密钥实施访问策略"><a href="#对加密密钥实施访问策略" class="headerlink" title="对加密密钥实施访问策略"></a>对加密密钥实施访问策略</h3><ol><li><strong>创建IAM策略</strong>: 为需要访问加密密钥的IAM角色或用户创建策略，明确指定哪些操作是允许的。</li><li><strong>绑定策略到用户或角色</strong>: 将策略应用于适当的IAM用户或角色，以控制对KMS密钥的访问。</li></ol><h3 id="实施数据备份和复制"><a href="#实施数据备份和复制" class="headerlink" title="实施数据备份和复制"></a>实施数据备份和复制</h3><ol><li><strong>自动备份</strong>: 利用AWS服务（如RDS、EBS的快照功能）进行定期数据备份。</li><li><strong>跨区域复制</strong>: 对于关键数据，使用跨区域复制功能以增加数据的耐久性和可用性。</li></ol><h3 id="实施数据访问、生命周期和保护策略"><a href="#实施数据访问、生命周期和保护策略" class="headerlink" title="实施数据访问、生命周期和保护策略"></a>实施数据访问、生命周期和保护策略</h3><ol><li><strong>数据访问控制</strong>: 使用IAM和资源级别的策略控制对数据的访问权限。</li><li><strong>数据生命周期管理</strong>: 利用S3的生命周期管理策略自动转移或删除旧数据。</li><li><strong>数据保护</strong>: 使用AWS Shield等工具保护数据免受DDoS攻击等安全威胁。</li></ol><h3 id="轮换加密密钥和续订证书"><a href="#轮换加密密钥和续订证书" class="headerlink" title="轮换加密密钥和续订证书"></a>轮换加密密钥和续订证书</h3><ol><li><strong>定期轮换加密密钥</strong>: 在KMS中设置密钥轮换，自动或手动更新加密密钥。</li><li><strong>监控和续订证书</strong>: 利用ACM的自动续订功能，确保SSL/TLS证书始终有效。</li></ol><h2 id="设计弹性架构"><a href="#设计弹性架构" class="headerlink" title="设计弹性架构"></a>设计弹性架构</h2><h3 id="API-创建和管理（例如，Amazon-API-Gateway、REST-API）"><a href="#API-创建和管理（例如，Amazon-API-Gateway、REST-API）" class="headerlink" title="API 创建和管理（例如，Amazon API Gateway、REST API）"></a>API 创建和管理（例如，Amazon API Gateway、REST API）</h3><h4 id="API-创建和管理概述"><a href="#API-创建和管理概述" class="headerlink" title="API 创建和管理概述"></a>API 创建和管理概述</h4><p>API（应用程序编程接口）是软件间交互的一套规则和定义，允许不同的系统和应用程序之间进行通信。Amazon API Gateway 是一个完全托管的服务，它使开发者能够轻松地创建、发布、维护、监控和保护任何规模的API。</p><h4 id="设计-REST-API"><a href="#设计-REST-API" class="headerlink" title="设计 REST API"></a>设计 REST API</h4><p>在使用Amazon API Gateway创建REST API之前，需要设计API的架构，包括资源、方法和状态码。</p><h5 id="最佳实践原则-36"><a href="#最佳实践原则-36" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>使用RESTful原则</strong>：设计符合REST架构风格的API，这意味着使用HTTP方法和状态码，资源的表述等。</li><li><strong>版本控制</strong>：通过API路径或头部信息实现API版本控制。</li></ul><h5 id="实践步骤-49"><a href="#实践步骤-49" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义API的资源（如用户、产品等）和子资源。</li><li>为每个资源定义CRUD（创建、读取、更新和删除）操作对应的HTTP方法（如GET、POST、PUT、DELETE）。</li><li>设计API的请求和响应模型，包括状态码和错误消息。</li></ol><h4 id="创建-API-与部署"><a href="#创建-API-与部署" class="headerlink" title="创建 API 与部署"></a>创建 API 与部署</h4><p>使用Amazon API Gateway创建API涉及到设置资源、方法、方法请求和响应等。</p><h5 id="最佳实践原则-37"><a href="#最佳实践原则-37" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：确保API的每个部分都采用适当的安全措施，如API密钥、身份验证和授权。</li><li><strong>性能优化</strong>：使用缓存和节流等技术来优化API性能。</li></ul><h5 id="实践步骤-50"><a href="#实践步骤-50" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在Amazon API Gateway中创建一个新的API。</li><li>设置API的资源和方法，并配置请求和响应的模型。</li><li>配置API的授权和认证机制。</li><li>部署API到一个或多个阶段（如开发、测试、生产）。</li></ol><h4 id="管理-API-生命周期"><a href="#管理-API-生命周期" class="headerlink" title="管理 API 生命周期"></a>管理 API 生命周期</h4><p>API的管理包括监控、维护、版本更新和退役。</p><h5 id="最佳实践原则-38"><a href="#最佳实践原则-38" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>监控和日志记录</strong>：监控API的使用情况和性能，记录日志以便于故障排查。</li><li><strong>持续迭代</strong>：定期更新API以添加新功能或改进现有功能。</li></ul><h5 id="实践步骤-51"><a href="#实践步骤-51" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用Amazon CloudWatch监控API的调用次数、错误率和延迟。</li><li>利用AWS CloudTrail记录API的管理事件。</li><li>为API发布新版本和更新，同时保持旧版本的稳定性。</li><li>当API退役时，通知消费者，并提供迁移路径。</li></ol><h4 id="确保-API-安全"><a href="#确保-API-安全" class="headerlink" title="确保 API 安全"></a>确保 API 安全</h4><p>保护API以防止未授权访问和攻击是至关重要的。</p><h5 id="最佳实践原则-39"><a href="#最佳实践原则-39" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>使用HTTPS</strong>：确保所有API调用都通过HTTPS进行，以保证数据传输的安全性。</li><li><strong>访问控制</strong>：使用IAM角色和策略控制对API的访问。</li></ul><h5 id="实践步骤-52"><a href="#实践步骤-52" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>强制执行SSL/TLS，确保API仅通过HTTPS提供服务。</li><li>配置API Gateway资源策略，限制IP地址或IAM用户的访问。</li><li>使用API Gateway的API密钥和使用计划来控制和限制客户端的API请求。</li><li>实施AWS WAF（Web应用程序防火墙）以防止常见的网络攻击。</li></ol><h4 id="监控和优化-API-性能"><a href="#监控和优化-API-性能" class="headerlink" title="监控和优化 API 性能"></a>监控和优化 API 性能</h4><p>API性能的监控和优化是确保API可靠和高效的关键。</p><h5 id="最佳实践原则-40"><a href="#最佳实践原则-40" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>性能指标</strong>：关注API的延迟和错误率等关键性能指标。</li><li><strong>缓存策略</strong>：合理设置API缓存以提高响应速度和减轻后端负载。</li></ul><h5 id="实践步骤-53"><a href="#实践步骤-53" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设置Amazon CloudWatch警报，当API的性能指标超出预定阈值时接收通知。</li><li>使用API Gateway缓存减少后端服务的调用次数。</li><li>分析API使用模式，并据此调整请求节流限制。</li></ol><h3 id="具有合适使用案例的-AWS-Managed-Services（例如，AWS-Transfer-Family、Amazon-Simple-Queue-Service-Amazon-SQS-、Secrets-Manager）"><a href="#具有合适使用案例的-AWS-Managed-Services（例如，AWS-Transfer-Family、Amazon-Simple-Queue-Service-Amazon-SQS-、Secrets-Manager）" class="headerlink" title="具有合适使用案例的 AWS Managed Services（例如，AWS Transfer Family、Amazon Simple Queue Service [Amazon SQS]、Secrets Manager）"></a>具有合适使用案例的 AWS Managed Services（例如，AWS Transfer Family、Amazon Simple Queue Service [Amazon SQS]、Secrets Manager）</h3><h4 id="AWS-Transfer-Family-使用案例"><a href="#AWS-Transfer-Family-使用案例" class="headerlink" title="AWS Transfer Family 使用案例"></a>AWS Transfer Family 使用案例</h4><p>AWS Transfer Family 提供安全的文件传输服务，使您能够轻松地在AWS上接收、存储和共享数据。</p><h5 id="最佳实践原则-41"><a href="#最佳实践原则-41" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：确保传输过程中使用加密协议，如SFTP、FTPS和FTP。</li><li><strong>集成</strong>：与AWS服务（如Amazon S3和Amazon EFS）集成以存储和处理数据。</li></ul><h5 id="实践步骤-54"><a href="#实践步骤-54" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建一个AWS Transfer Family服务器，并指定服务类型（SFTP、FTPS、或FTP）。</li><li>配置用户，并将它们与IAM角色关联，以便控制对S3桶的访问。</li><li>设置网络访问，通过VPC或互联网进行传输。</li></ol><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>文件共享</strong>：企业可以使用AWS Transfer Family 安全地与合作伙伴共享文件。</li><li><strong>数据迁移</strong>：将本地数据迁移到AWS，作为云存储的一部分。</li><li><strong>内容分发</strong>：媒体公司可以将大型媒体文件上传到云端，供全球分发。</li></ul><h4 id="Amazon-Simple-Queue-Service-Amazon-SQS-使用案例"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS-使用案例" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS) 使用案例"></a>Amazon Simple Queue Service (Amazon SQS) 使用案例</h4><p>Amazon SQS 是一种完全托管的消息队列服务，它可以帮助您在软件组件之间解耦和扩展应用程序。</p><h5 id="最佳实践原则-42"><a href="#最佳实践原则-42" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>解耦组件</strong>：使用消息队列来解耦生产者和消费者进程。</li><li><strong>扩展性</strong>：根据工作负载动态调整消费者的数量。</li></ul><h5 id="实践步骤-55"><a href="#实践步骤-55" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建一个新的SQS队列。</li><li>配置消息保留策略和传递延迟设置。</li><li>在生产者应用程序中发送消息到队列。</li><li>在消费者应用程序中从队列接收和处理消息。</li></ol><h5 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>异步处理</strong>：应用程序可以将任务发送到SQS队列进行异步处理。</li><li><strong>应用程序扩展</strong>：在用户请求量增加时，通过增加消费者实例数量来处理更多的消息。</li><li><strong>容错性</strong>：在处理消息失败时，SQS可以重新尝试或将消息移动到死信队列。</li></ul><h4 id="AWS-Secrets-Manager-使用案例"><a href="#AWS-Secrets-Manager-使用案例" class="headerlink" title="AWS Secrets Manager 使用案例"></a>AWS Secrets Manager 使用案例</h4><p>AWS Secrets Manager 是一项服务，用于保护访问应用程序的敏感信息，如数据库密码、API密钥和其他秘密。</p><h5 id="最佳实践原则-43"><a href="#最佳实践原则-43" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期轮换秘密</strong>：自动更换秘密以提高安全性。</li><li><strong>集中管理</strong>：集中存储和访问所有秘密。</li></ul><h5 id="实践步骤-56"><a href="#实践步骤-56" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在AWS Secrets Manager中存储新的秘密。</li><li>配置秘密的自动轮换策略。</li><li>通过IAM策略控制对秘密的访问权限。</li><li>在应用程序中使用SDK或CLI获取秘密，而不是硬编码。</li></ol><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>数据库凭证管理</strong>：存储和管理数据库登录信息，自动处理密码更换。</li><li><strong>API密钥安全</strong>：安全地存储第三方服务的API密钥，并在需要时轻松访问。</li><li><strong>应用配置</strong>：存储应用程序配置详情，如端口、域和更多环境特定的秘密。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>AWS Managed Services 提供了一系列工具，以帮助组织在AWS云环境中高效、安全地操作。AWS Transfer Family 适用于需要安全文件传输的场景，Amazon SQS 适合于需要消息队列来实现应用程序解耦和扩展的情况，而AWS Secrets Manager 非常适合需要安全管理敏感信息的应用程序。通过这些服务，AWS用户可以提高应用程序的安全性、可靠性和扩展性，同时简化运维工作。</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="缓存策略基础"><a href="#缓存策略基础" class="headerlink" title="缓存策略基础"></a>缓存策略基础</h4><p>缓存策略是优化数据检索性能的关键组成部分。它涉及存储数据的临时副本，以便快速访问，减少对原始数据源的请求次数，从而提高应用程序的响应速度和减少延迟。</p><h5 id="最佳实践原则-44"><a href="#最佳实践原则-44" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li>**有效期 (TTL)**：为缓存的数据设置合适的生命周期。</li><li><strong>一致性</strong>：确保缓存数据的一致性，以防止过期或不正确的信息被提供。</li><li><strong>无效化</strong>：当原始数据更改时，及时无效化缓存。</li></ul><h5 id="实践步骤-57"><a href="#实践步骤-57" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>选择合适的缓存策略（如LRU、FIFO等）。</li><li>配置缓存存储，可以是内存中的、本地的或分布式的。</li><li>实施缓存失效逻辑，确保数据的一致性。</li></ol><h4 id="应用层缓存策略"><a href="#应用层缓存策略" class="headerlink" title="应用层缓存策略"></a>应用层缓存策略</h4><p>应用层缓存通常指在应用程序代码中实现的缓存，例如使用内存中的数据结构来存储计算结果或频繁访问的数据。</p><h5 id="最佳实践原则-45"><a href="#最佳实践原则-45" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>选择性缓存</strong>：仅缓存那些读取操作频繁且相对不经常更新的数据。</li><li><strong>内存管理</strong>：监控缓存占用的内存，并确保它不会导致应用程序崩溃。</li></ul><h5 id="实践步骤-58"><a href="#实践步骤-58" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序代码中标识高延迟或高计算成本的操作。</li><li>使用合适的数据结构（如哈希表）来存储这些操作的结果。</li><li>在数据更新时，更新缓存或标记为无效。</li></ol><h4 id="数据库缓存策略"><a href="#数据库缓存策略" class="headerlink" title="数据库缓存策略"></a>数据库缓存策略</h4><p>数据库缓存涉及在数据库系统中缓存查询结果，以减少对数据库引擎的查询次数。</p><h5 id="最佳实践原则-46"><a href="#最佳实践原则-46" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>查询优化</strong>：缓存那些执行成本高昂的查询结果。</li><li><strong>自动化</strong>：利用数据库管理系统提供的自动缓存机制。</li></ul><h5 id="实践步骤-59"><a href="#实践步骤-59" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用数据库查询分析器找出成本高昂的查询。</li><li>配置数据库级别的缓存设置，如MySQL的Query Cache或SQL Server的In-Memory OLTP。</li><li>监控缓存的效率并根据需要调整配置。</li></ol><h4 id="CDN-缓存策略"><a href="#CDN-缓存策略" class="headerlink" title="CDN 缓存策略"></a>CDN 缓存策略</h4><p>内容分发网络（CDN）缓存是一种分布式网络缓存，它存储静态资源，如图片、视频、CSS和JavaScript文件，以便于快速交付给全球用户。</p><h5 id="最佳实践原则-47"><a href="#最佳实践原则-47" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>地理分布</strong>：缓存内容应靠近用户，以减少延迟。</li><li><strong>版本控制</strong>：使用文件版本命名来管理缓存的更新。</li></ul><h5 id="实践步骤-60"><a href="#实践步骤-60" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>选择CDN提供商，并配置CDN缓存规则。</li><li>为静态资源实现版本控制，例如通过添加查询字符串或文件指纹。</li><li>设置缓存的TTL，确保内容的及时更新。</li></ol><h4 id="HTTP-缓存策略"><a href="#HTTP-缓存策略" class="headerlink" title="HTTP 缓存策略"></a>HTTP 缓存策略</h4><p>HTTP缓存策略涉及客户端（如浏览器）和服务器之间的缓存控制，通常通过HTTP头部来控制。</p><h5 id="最佳实践原则-48"><a href="#最佳实践原则-48" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>缓存控制头部</strong>：使用<code>Cache-Control</code>头部指令来控制资源的缓存行为。</li><li><strong>协商缓存</strong>：当可能时，使用<code>ETag</code>和<code>Last-Modified</code>头部进行缓存验证。</li></ul><h5 id="实践步骤-61"><a href="#实践步骤-61" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在服务器响应中设置<code>Cache-Control</code>头部，如<code>max-age</code>和<code>must-revalidate</code>。</li><li>使用<code>ETag</code>头部提供资源的特定版本标记。</li><li>通过<code>Last-Modified</code>头部提供资源最后修改的时间戳。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存策略是提高应用程序性能和用户体验的重要组成部分。无论是应用层缓存、数据库缓存、CDN缓存还是HTTP缓存，合理的缓存策略都可以显著减少数据检索时间，减轻后端服务的压力，并提供更快的响应速度。实施缓存时，重要的是要考虑数据的一致性、有效期和无效化策略，以确保用户始终访问到最新和最准确的信息。</p><h3 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h3><h4 id="微服务架构概述"><a href="#微服务架构概述" class="headerlink" title="微服务架构概述"></a>微服务架构概述</h4><p>微服务架构是一种设计方法，它通过将一个大型应用程序拆分成一组小型、松散耦合的服务来促进敏捷开发和部署。每个服务通常围绕特定业务功能构建，并且可以独立于其他服务进行开发、部署和扩展。</p><h5 id="最佳实践原则-49"><a href="#最佳实践原则-49" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>服务自治</strong>：每个服务应该是自包含的，并拥有特定的业务逻辑。</li><li><strong>松耦合</strong>：服务之间的依赖关系应该最小化。</li><li><strong>可维护性和可测试性</strong>：服务应该容易维护和测试。</li></ul><h5 id="实践步骤-62"><a href="#实践步骤-62" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>确定业务域，并围绕这些域设计服务。</li><li>设计服务API，并确保它们清晰和一致。</li><li>实现服务的持续集成和部署（CI/CD）。</li></ol><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责原则指的是微服务应该围绕一个核心功能构建，并且只做好一件事情。这有助于确保服务的复杂性保持在可管理的水平。</p><h5 id="最佳实践原则-50"><a href="#最佳实践原则-50" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>聚焦业务能力</strong>：服务应该围绕单一的业务能力构建。</li><li><strong>避免臃肿服务</strong>：避免创建大型服务，这些服务难以维护和扩展。</li></ul><h5 id="实践步骤-63"><a href="#实践步骤-63" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>明确界定服务的业务边界。</li><li>避免在单个服务中实现多个业务功能。</li><li>定期评估服务的职责，确保它们没有变得过于复杂。</li></ol><h4 id="服务自治和独立性"><a href="#服务自治和独立性" class="headerlink" title="服务自治和独立性"></a>服务自治和独立性</h4><p>服务自治是微服务设计的核心原则之一。每个服务都应该是自主的，能够独立于其他服务运行和演进。</p><h5 id="最佳实践原则-51"><a href="#最佳实践原则-51" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>独立部署</strong>：服务应该能够独立于其他服务进行部署。</li><li><strong>自主数据管理</strong>：服务应该拥有并管理自己的数据模型和数据库。</li></ul><h5 id="实践步骤-64"><a href="#实践步骤-64" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个服务实现独立的部署流程。</li><li>确保服务有自己的数据库或数据存储，不与其他服务共享。</li><li>使用服务发现机制，使服务能够独立地找到并与其他服务通信。</li></ol><h4 id="服务的松耦合和内聚"><a href="#服务的松耦合和内聚" class="headerlink" title="服务的松耦合和内聚"></a>服务的松耦合和内聚</h4><p>微服务应该是松耦合的，这意味着它们之间的依赖关系应该尽可能地少。同时，服务内部应该是高度内聚的，意味着服务内部的组件紧密相关且为同一目标工作。</p><h5 id="最佳实践原则-52"><a href="#最佳实践原则-52" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定义良好的接口</strong>：服务之间的交互应该通过定义良好的API进行。</li><li><strong>事件驱动通信</strong>：使用事件来减少服务间的直接依赖。</li></ul><h5 id="实践步骤-65"><a href="#实践步骤-65" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设计清晰的API和服务契约。</li><li>使用异步消息传递和事件来促进服务间的通信。</li><li>限制直接的服务到服务调用，以减少耦合。</li></ol><h4 id="可维护性和可测试性"><a href="#可维护性和可测试性" class="headerlink" title="可维护性和可测试性"></a>可维护性和可测试性</h4><p>微服务应该容易维护和测试，这有助于快速迭代和提高系统的稳定性。</p><h5 id="最佳实践原则-53"><a href="#最佳实践原则-53" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>模块化设计</strong>：服务应该是模块化的，以便于理解和更改。</li><li><strong>自动化测试</strong>：服务应该有一套完善的自动化测试套件。</li></ul><h5 id="实践步骤-66"><a href="#实践步骤-66" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>构建模块化的服务，使其能够容易地添加或修改功能。</li><li>开发单元测试、集成测试和端到端测试。</li><li>实施持续集成和持续部署流程。</li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>微服务设计原则旨在支持构建可维护、可扩展和可持续的服务。通过遵循单一职责原则、确保服务自治和独立性、实现服务的松耦合和内聚、以及强调可维护性和可测试性，团队可以创建出强大而灵活的微服务架构。这些原则有助于微服务在快速变化的市场中保持竞争力，同时降低长期的技术债务风险。</p><h3 id="事件驱动型架构"><a href="#事件驱动型架构" class="headerlink" title="事件驱动型架构"></a>事件驱动型架构</h3><p>事件驱动型架构是一种软件架构范式，它通过事件来触发和通信各个服务或应用程序组件之间的交互。在这种架构中，事件是一个重要的状态改变，它可以由系统内部或外部的动作产生，并且被系统内的其他组件所监听和响应。</p><h5 id="最佳实践原则-54"><a href="#最佳实践原则-54" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>解耦生产者和消费者</strong>：生产者产生事件而不需要知道哪些消费者会处理这些事件。</li><li><strong>异步通信</strong>：系统组件应该异步地处理事件，以提高性能和响应性。</li><li><strong>可伸缩性</strong>：事件驱动架构应该能够水平扩展，以处理大量的事件流。</li></ul><h5 id="实践步骤-67"><a href="#实践步骤-67" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义明确的事件模型和事件列表。</li><li>实现事件生产者，它负责发布系统中发生的事件。</li><li>实现事件消费者，它订阅感兴趣的事件并作出响应。</li><li>使用消息队列或事件总线来传输事件，确保系统的可靠性和可伸缩性。</li></ol><h3 id="水平扩展与垂直扩展"><a href="#水平扩展与垂直扩展" class="headerlink" title="水平扩展与垂直扩展"></a>水平扩展与垂直扩展</h3><p>水平扩展（Scaling Out）和垂直扩展（Scaling Up）是两种不同的系统扩展策略，用于提高应用程序或服务的处理能力。</p><h5 id="水平扩展（Scaling-Out）"><a href="#水平扩展（Scaling-Out）" class="headerlink" title="水平扩展（Scaling Out）"></a>水平扩展（Scaling Out）</h5><p>水平扩展指的是增加更多的节点来分摊负载，例如添加更多的服务器实例。</p><h6 id="最佳实践原则-55"><a href="#最佳实践原则-55" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h6><ul><li><strong>无状态服务</strong>：确保服务无状态，使得任何实例都能处理任何请求。</li><li><strong>负载均衡</strong>：使用负载均衡器来分配跨多个节点的请求。</li></ul><h6 id="实践步骤-68"><a href="#实践步骤-68" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>设计无状态的服务。</li><li>在多个服务器或容器中部署服务的实例。</li><li>配置负载均衡器来分配流量到不同的实例。</li></ol><h5 id="垂直扩展（Scaling-Up）"><a href="#垂直扩展（Scaling-Up）" class="headerlink" title="垂直扩展（Scaling Up）"></a>垂直扩展（Scaling Up）</h5><p>垂直扩展指的是增强单个节点的处理能力，如增加CPU、内存或存储资源。</p><h6 id="最佳实践原则-56"><a href="#最佳实践原则-56" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h6><ul><li><strong>资源优化</strong>：优化应用程序以充分利用增强的硬件资源。</li><li><strong>成本效益</strong>：评估垂直扩展的成本效益，因为它可能涉及昂贵的硬件升级。</li></ul><h6 id="实践步骤-69"><a href="#实践步骤-69" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>识别性能瓶颈，确定需要增强的资源（CPU、内存等）。</li><li>升级硬件或迁移到更强大的机器。</li><li>优化应用程序配置以利用新的硬件资源。</li></ol><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>事件驱动型架构通过促进组件之间的松耦合交互，提高了系统的响应性和可伸缩性。它允许系统更灵活地处理大量并发事件，而不会受到单点故障的影响。水平扩展和垂直扩展是两种主要的系统扩展策略，它们可以用来应对不同的性能和资源需求。水平扩展通过增加更多的处理节点来提升系统的并发处理能力，而垂直扩展则通过增强单个节点的资源来提升其处理能力。选择合适的扩展策略取决于应用程序的需求、成本考虑以及预期的负载增长。</p><h3 id="边缘加速器的正确使用（例如，内容分发网络-CDN-）"><a href="#边缘加速器的正确使用（例如，内容分发网络-CDN-）" class="headerlink" title="边缘加速器的正确使用（例如，内容分发网络 [CDN]）"></a>边缘加速器的正确使用（例如，内容分发网络 [CDN]）</h3><h4 id="边缘加速器的概念"><a href="#边缘加速器的概念" class="headerlink" title="边缘加速器的概念"></a>边缘加速器的概念</h4><p>边缘加速器，如内容分发网络（CDN），是一种分布式网络基础设施，用于通过在全球多个地点缓存内容来加快内容的交付速度。CDN 的工作机制是将内容复制到距离用户更近的服务器上，从而减少数据传输的延迟，提高访问速度和用户体验。</p><h5 id="CDN的工作原理"><a href="#CDN的工作原理" class="headerlink" title="CDN的工作原理"></a>CDN的工作原理</h5><ul><li><strong>缓存静态资源</strong>：将网站的静态资源（如图片、CSS、JavaScript文件）缓存到全球分布的边缘节点。</li><li><strong>内容复制</strong>：根据用户的地理位置，从最近的边缘节点提供内容，减少数据旅行的距离。</li><li><strong>负载均衡</strong>：动态地将用户请求分配到最近或响应最快的边缘节点。</li></ul><h4 id="正确使用CDN"><a href="#正确使用CDN" class="headerlink" title="正确使用CDN"></a>正确使用CDN</h4><p>使用CDN时，需要考虑资源的缓存策略、内容的更新频率以及如何确保内容的安全性和合规性。</p><h5 id="缓存策略-1"><a href="#缓存策略-1" class="headerlink" title="缓存策略"></a>缓存策略</h5><ul><li><strong>设置合理的缓存时间</strong>：为不同类型的资源设置适当的缓存时间（TTL），以优化性能和更新频率之间的平衡。</li><li><strong>版本控制</strong>：使用资源版本控制，如文件指纹（hash），以确保更新后的内容能够被用户及时获取。</li></ul><h6 id="实践步骤-70"><a href="#实践步骤-70" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>为网站上的静态资源配置CDN。</li><li>设置缓存头信息，如<code>Cache-Control</code>，以控制资源在CDN节点的缓存时间。</li><li>当资源更新时，更改资源的文件名或添加查询字符串，以使缓存失效。</li></ol><h5 id="内容更新"><a href="#内容更新" class="headerlink" title="内容更新"></a>内容更新</h5><ul><li><strong>即时清除缓存</strong>：当内容更新时，使用CDN提供的清除缓存的功能，以确保用户能够访问到最新的内容。</li><li><strong>预缓存新内容</strong>：在发布新内容前，预先将其推送到CDN节点，以加快首次访问速度。</li></ul><h6 id="实践步骤-71"><a href="#实践步骤-71" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>配置CDN的缓存清除机制，以便在内容更新时能够快速清除旧版本。</li><li>利用CDN的API或控制面板来管理缓存和预加载新内容。</li></ol><h5 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h5><ul><li><strong>使用HTTPS</strong>：确保CDN节点支持HTTPS，加密用户和CDN之间的数据传输。</li><li><strong>遵守数据合规</strong>：选择支持数据地理位置合规的CDN提供商，尤其是在处理有地理位置限制的内容时。</li></ul><h6 id="实践步骤-72"><a href="#实践步骤-72" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>启用CDN的SSL/TLS功能，为所有缓存内容提供HTTPS加密。</li><li>确保CDN提供商符合地区的数据保护法规，如GDPR。</li></ol><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>正确使用CDN可以显著提升网站的加载速度和用户体验，同时减轻原始服务器的负载。为了最大化CDN的效果，应当设计合理的缓存策略，确保内容的及时更新，并且遵循最佳的安全和合规实践。通过这些步骤，可以确保内容以最高效和最安全的方式分发给全球的用户。</p><h3 id="将应用程序迁移到容器中"><a href="#将应用程序迁移到容器中" class="headerlink" title="将应用程序迁移到容器中"></a>将应用程序迁移到容器中</h3><h4 id="将应用程序迁移到容器中的概念"><a href="#将应用程序迁移到容器中的概念" class="headerlink" title="将应用程序迁移到容器中的概念"></a>将应用程序迁移到容器中的概念</h4><p>将应用程序迁移到容器中是一种将应用程序与其依赖项打包在一起的方式，以便在不同的环境中进行部署和运行。容器化应用程序具有独立性、可移植性和可扩展性，使得应用程序的部署和管理更加简化和灵活。</p><h5 id="容器化的工作原理"><a href="#容器化的工作原理" class="headerlink" title="容器化的工作原理"></a>容器化的工作原理</h5><ul><li><strong>容器引擎</strong>：使用容器引擎（如Docker）创建和管理容器。</li><li><strong>容器镜像</strong>：将应用程序及其依赖项打包为容器镜像，其中包含了应用程序运行所需的一切。</li><li><strong>容器运行时</strong>：将容器镜像部署到容器运行时环境中，如Docker引擎，以便在不同的主机上运行。</li></ul><h4 id="将应用程序迁移到容器中的步骤"><a href="#将应用程序迁移到容器中的步骤" class="headerlink" title="将应用程序迁移到容器中的步骤"></a>将应用程序迁移到容器中的步骤</h4><h5 id="1-容器化应用程序"><a href="#1-容器化应用程序" class="headerlink" title="1. 容器化应用程序"></a>1. 容器化应用程序</h5><ul><li><strong>创建Dockerfile</strong>：编写一个Dockerfile，定义如何构建容器镜像。在Dockerfile中指定应用程序的依赖项、环境变量和运行命令。</li><li><strong>构建容器镜像</strong>：使用Docker命令构建容器镜像，将Dockerfile与应用程序代码放在同一个目录中，并执行构建命令。</li></ul><h5 id="2-测试容器化应用程序"><a href="#2-测试容器化应用程序" class="headerlink" title="2. 测试容器化应用程序"></a>2. 测试容器化应用程序</h5><ul><li><strong>本地测试</strong>：在本地环境中使用Docker运行容器镜像，确保应用程序能够在容器中正常运行。</li><li><strong>验证功能</strong>：测试应用程序的功能和性能，确保在容器中的运行与原始环境中一致。</li></ul><h5 id="3-配置容器编排工具"><a href="#3-配置容器编排工具" class="headerlink" title="3. 配置容器编排工具"></a>3. 配置容器编排工具</h5><ul><li><strong>选择容器编排工具</strong>：选择适合的容器编排工具（如Kubernetes），用于管理和编排容器集群。</li><li><strong>配置集群</strong>：根据应用程序的需求，配置容器编排工具以创建、扩展和管理容器集群。</li></ul><h5 id="4-部署容器化应用程序"><a href="#4-部署容器化应用程序" class="headerlink" title="4. 部署容器化应用程序"></a>4. 部署容器化应用程序</h5><ul><li><strong>创建容器编排文件</strong>：编写容器编排文件（如Kubernetes的YAML文件），描述应用程序的部署配置和资源要求。</li><li><strong>部署应用程序</strong>：使用容器编排工具部署应用程序，将容器镜像部署到容器集群中的节点上。</li></ul><h5 id="5-监控和管理容器化应用程序"><a href="#5-监控和管理容器化应用程序" class="headerlink" title="5. 监控和管理容器化应用程序"></a>5. 监控和管理容器化应用程序</h5><ul><li><strong>监控应用程序</strong>：配置监控工具，监视容器化应用程序的性能和运行状态。</li><li><strong>容器管理</strong>：使用容器编排工具管理容器集群，包括扩展、缩减、更新和回滚应用程序。</li></ul><h4 id="容器化应用程序的最佳实践"><a href="#容器化应用程序的最佳实践" class="headerlink" title="容器化应用程序的最佳实践"></a>容器化应用程序的最佳实践</h4><ul><li><strong>最小化容器镜像</strong>：确保容器镜像尽可能小，只包含应用程序运行所需的依赖项。</li><li><strong>使用版本控制</strong>：将应用程序代码和Dockerfile纳入版本控制，以便跟踪和管理变更。</li><li><strong>配置环境变量</strong>：使用环境变量来传递应用程序的配置，以便在不同环境中进行配置更改。</li><li><strong>持久化数据</strong>：将应用程序生成的数据存储在持久化存储卷或外部存储中，以便在容器重新启动时不丢失数据。</li></ul><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>将应用程序迁移到容器中可以提供更好的应用程序管理和部署方式。通过容器化，应用程序可以更加独立、可移植和可扩展。迁移到容器中的步骤包括容器化应用程序、测试容器化应用程序、配置容器编排工具、部署容器化应用程序以及监控和管理容器化应用程序。遵循最佳实践原则，可以确保容器化应用程序的高效性和可靠性。</p><h3 id="负载均衡概念（例如，Application-Load-Balancer）"><a href="#负载均衡概念（例如，Application-Load-Balancer）" class="headerlink" title="负载均衡概念（例如，Application Load Balancer）"></a>负载均衡概念（例如，Application Load Balancer）</h3><h4 id="负载均衡的概念"><a href="#负载均衡的概念" class="headerlink" title="负载均衡的概念"></a>负载均衡的概念</h4><p>负载均衡是一种在多个服务器之间分配工作负载的技术，以提高应用程序的可用性、性能和可扩展性。负载均衡器（Load Balancer）作为中间层，接收客户端请求并将其分发到后端服务器，以确保请求能够被高效地处理。</p><h5 id="负载均衡的工作原理"><a href="#负载均衡的工作原理" class="headerlink" title="负载均衡的工作原理"></a>负载均衡的工作原理</h5><ul><li><strong>请求分发</strong>：负载均衡器接收客户端请求，并根据特定的算法将请求分发到后端服务器。</li><li><strong>流量管理</strong>：负载均衡器监控后端服务器的负载情况，并根据负载情况动态地分配请求，以确保各个服务器的负载均衡。</li><li><strong>故障处理</strong>：负载均衡器检测后端服务器的健康状态，并自动将请求从故障服务器转发到正常的服务器上。</li></ul><h4 id="Application-Load-Balancer（应用程序负载均衡器）的概念"><a href="#Application-Load-Balancer（应用程序负载均衡器）的概念" class="headerlink" title="Application Load Balancer（应用程序负载均衡器）的概念"></a>Application Load Balancer（应用程序负载均衡器）的概念</h4><p>Application Load Balancer（ALB）是云平台（如AWS）上的一种负载均衡服务，专门用于分发应用程序流量。ALB能够根据请求的内容和上下文信息，智能地将请求分发到不同的后端服务器上。</p><h5 id="ALB的特点和功能"><a href="#ALB的特点和功能" class="headerlink" title="ALB的特点和功能"></a>ALB的特点和功能</h5><ul><li><strong>应用层负载均衡</strong>：ALB在应用层（第7层）进行负载均衡，可以根据请求的内容进行路由和转发。</li><li><strong>多协议支持</strong>：ALB支持HTTP、HTTPS和WebSocket等多种协议。</li><li><strong>容器集成</strong>：ALB可以与容器服务（如ECS、EKS）集成，实现自动服务发现和动态端口映射。</li><li><strong>SSL/TLS终止</strong>：ALB可以终止SSL/TLS连接，并将请求以明文形式转发给后端服务器。</li><li><strong>身份验证和授权</strong>：ALB支持基于身份验证和授权的访问控制，以保护应用程序的安全性。</li></ul><h4 id="使用Application-Load-Balancer的步骤"><a href="#使用Application-Load-Balancer的步骤" class="headerlink" title="使用Application Load Balancer的步骤"></a>使用Application Load Balancer的步骤</h4><h5 id="1-创建Application-Load-Balancer"><a href="#1-创建Application-Load-Balancer" class="headerlink" title="1. 创建Application Load Balancer"></a>1. 创建Application Load Balancer</h5><ul><li><strong>配置监听器</strong>：定义负载均衡器监听的端口和协议（如HTTP或HTTPS）。</li><li><strong>配置目标组</strong>：创建目标组，指定后端服务器的信息（如IP地址和端口）。</li></ul><h5 id="2-配置目标组"><a href="#2-配置目标组" class="headerlink" title="2. 配置目标组"></a>2. 配置目标组</h5><ul><li><strong>添加后端服务器</strong>：将后端服务器添加到目标组中，以便负载均衡器将请求分发到这些服务器上。</li><li><strong>配置健康检查</strong>：定义健康检查规则，用于监测后端服务器的健康状态。</li></ul><h5 id="3-配置路由规则"><a href="#3-配置路由规则" class="headerlink" title="3. 配置路由规则"></a>3. 配置路由规则</h5><ul><li><strong>创建规则</strong>：定义路由规则，根据请求的路径、主机名或其他条件将请求转发到相应的目标组。</li><li><strong>配置目标组权重</strong>：根据服务器的性能和资源配置，调整目标组的权重，以实现负载均衡。</li></ul><h5 id="4-监控和调优"><a href="#4-监控和调优" class="headerlink" title="4. 监控和调优"></a>4. 监控和调优</h5><ul><li><strong>监控负载均衡器</strong>：使用云平台提供的监控工具，监测负载均衡器的性能和可用性。</li><li><strong>调整负载均衡策略</strong>：根据实际情况，调整负载均衡器的算法和配置，以满足应用程序的需求。</li></ul><h4 id="Application-Load-Balancer的最佳实践"><a href="#Application-Load-Balancer的最佳实践" class="headerlink" title="Application Load Balancer的最佳实践"></a>Application Load Balancer的最佳实践</h4><ul><li><strong>多区域部署</strong>：将负载均衡器部署在多个区域，以提高应用程序的冗余性和可用性。</li><li><strong>安全性配置</strong>：启用SSL/TLS终止，使用安全证书保护数据传输。</li><li><strong>优化目标组</strong>：根据应用程序的特点和负载情况，调整目标组的健康检查设置和目标服务器权重。</li><li><strong>日志记录和监控</strong>：启用负载均衡器的日志记录和监控功能，以便及时发现和解决问题。</li></ul><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>Application Load Balancer（应用程序负载均衡器）是一种用于分发应用程序流量的负载均衡服务。通过配置监听器、目标组和路由规则，可以实现请求的智能分发和负载均衡。使用ALB可以提高应用程序的可用性、性能和可扩展性。在使用ALB时，应遵循最佳实践，以确保负载均衡器的安全性和高效性。</p><h3 id="多层架构"><a href="#多层架构" class="headerlink" title="多层架构"></a>多层架构</h3><h4 id="多层架构的概念"><a href="#多层架构的概念" class="headerlink" title="多层架构的概念"></a>多层架构的概念</h4><p>多层架构是一种软件设计模式，将应用程序分为多个层级，每个层级负责不同的功能和责任。每个层级都有明确定义的接口，层与层之间通过接口进行通信和交互。多层架构的目标是实现分离关注点、提高可维护性和可扩展性。</p><h5 id="多层架构的层级"><a href="#多层架构的层级" class="headerlink" title="多层架构的层级"></a>多层架构的层级</h5><ul><li><strong>表示层</strong>：负责处理用户界面和用户交互，将用户请求传递给下一层处理，并将处理结果呈现给用户。</li><li><strong>应用层</strong>：包含应用程序的业务逻辑和处理规则，负责协调各个层级的工作，并处理业务逻辑。</li><li><strong>领域层</strong>：包含应用程序的核心业务逻辑和业务实体，负责处理业务规则和数据验证。</li><li><strong>数据访问层</strong>：负责与数据存储交互，包括数据库访问、数据持久化和数据操作。</li></ul><h4 id="多层架构的优势"><a href="#多层架构的优势" class="headerlink" title="多层架构的优势"></a>多层架构的优势</h4><p>多层架构具有以下优势：</p><ul><li><strong>分离关注点</strong>：不同层级负责不同的功能，使得代码易于理解、维护和扩展。</li><li><strong>可测试性</strong>：每个层级都可以独立进行单元测试，方便进行测试和调试。</li><li><strong>可扩展性</strong>：每个层级可以独立进行扩展，增加新的功能或修改现有功能。</li><li><strong>可维护性</strong>：各个层级之间的松耦合性使得代码的修改和维护更加容易。</li><li><strong>团队协作</strong>：不同的开发团队可以同时开发不同的层级，提高开发效率。</li></ul><h4 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h4><p>表示层负责处理用户界面和用户交互，将用户的请求传递给下一层处理，并将处理结果呈现给用户。</p><p>表示层的功能包括：</p><ul><li><strong>用户界面</strong>：设计和开发用户界面，包括网页、移动应用等。</li><li><strong>用户输入处理</strong>：接收用户的输入请求，验证和解析用户输入。</li><li><strong>用户输出呈现</strong>：将处理结果呈现给用户，生成并发送响应。</li></ul><h4 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h4><p>应用层包含应用程序的业务逻辑和处理规则，负责协调各个层级的工作，并处理业务逻辑。</p><p>应用层的功能包括：</p><ul><li><strong>业务逻辑处理</strong>：实现应用程序的业务规则和处理逻辑。</li><li><strong>协调层级</strong>：协调表示层、领域层和数据访问层之间的交互和通信。</li><li><strong>异常处理</strong>：处理和管理应用程序的异常情况。</li></ul><h4 id="领域层（Domain-Layer）"><a href="#领域层（Domain-Layer）" class="headerlink" title="领域层（Domain Layer）"></a>领域层（Domain Layer）</h4><p>领域层包含应用程序的核心业务逻辑和业务实体，负责处理业务规则和数据验证。</p><p>领域层的功能包括：</p><ul><li><strong>业务实体</strong>：定义和实现业务实体，包括对象和数据模型。</li><li><strong>业务规则</strong>：实现业务规则和业务逻辑，确保数据的有效性和一致性。</li><li><strong>数据验证</strong>：验证和验证输入数据的有效性和完整性。</li></ul><h4 id="数据访问层（Data-Access-Layer）"><a href="#数据访问层（Data-Access-Layer）" class="headerlink" title="数据访问层（Data Access Layer）"></a>数据访问层（Data Access Layer）</h4><p>数据访问层负责与数据存储交互，包括数据库访问、数据持久化和数据操作。</p><p>数据访问层的功能包括：</p><ul><li><strong>数据库访问</strong>：与数据库进行交互，执行数据查询、插入、更新和删除操作。</li><li><strong>数据持久化</strong>：将数据持久化到数据库或其他数据存储介质中。</li><li><strong>数据操作</strong>：封装对数据的操作，提供高层次的数据访问接口。</li></ul><h4 id="多层架构的最佳实践"><a href="#多层架构的最佳实践" class="headerlink" title="多层架构的最佳实践"></a>多层架构的最佳实践</h4><ul><li><strong>单一职责原则</strong>：每个层级应该具有清晰的职责和功能，避免功能交叉和混乱。</li><li><strong>松耦合</strong>：各个层级之间应该松散耦合，通过接口进行通信，降低依赖性。</li><li><strong>抽象和封装</strong>：使用接口和抽象类来定义层级之间的交互和通信。</li><li><strong>分层架构图</strong>：绘制和维护分层架构图，以便开发人员理解和遵循架构设计。</li><li><strong>测试驱动开发</strong>：每个层级都应该进行单元测试，确保各个层级的功能和交互正常。</li></ul><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>多层架构将应用程序分为表示层、应用层、领域层和数据访问层，每个层级负责不同的功能和责任。多层架构的优势包括分离关注点、</p><h3 id="队列和消息收发概念（例如，发布-订阅）"><a href="#队列和消息收发概念（例如，发布-订阅）" class="headerlink" title="队列和消息收发概念（例如，发布/订阅）"></a>队列和消息收发概念（例如，发布/订阅）</h3><h4 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h4><p>队列是一种常用的数据结构，用于存储和管理元素。它遵循先进先出（FIFO）的原则，即先进入队列的元素将首先被处理，后进入队列的元素将在后续被处理。</p><p>队列的操作包括：</p><ul><li><strong>入队（Enqueue）</strong>：将元素添加到队列的末尾。</li><li><strong>出队（Dequeue）</strong>：从队列的头部移除并返回元素。</li><li><strong>查看队头元素（Peek）</strong>：查看队列头部的元素，但不将其移除。</li></ul><p>队列常用于处理异步任务、消息传递和事件处理等场景，其中消息收发是队列的一个重要应用。</p><h4 id="消息收发的概念"><a href="#消息收发的概念" class="headerlink" title="消息收发的概念"></a>消息收发的概念</h4><p>消息收发是一种用于在分布式系统中进行通信的模式。在消息收发模式中，消息发送者将消息发送到消息队列，而消息接收者从队列中接收和处理消息。</p><h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h5><p>发布/订阅（Publish/Subscribe）是一种常见的消息收发模式。在发布/订阅模式中，消息发送者（发布者）将消息发布到特定的主题（Topic），而消息接收者（订阅者）订阅感兴趣的主题，从而接收与该主题相关的消息。</p><p>发布/订阅模式的特点包括：</p><ul><li><strong>解耦性</strong>：发布者和订阅者之间是松耦合的，彼此不需要直接知道对方的存在。</li><li><strong>灵活性</strong>：发布者可以将消息发布到多个主题，订阅者可以订阅多个主题。</li><li><strong>扩展性</strong>：可以动态地添加新的发布者和订阅者，扩展系统的功能和规模。</li></ul><h4 id="使用队列和发布-订阅模式的步骤"><a href="#使用队列和发布-订阅模式的步骤" class="headerlink" title="使用队列和发布/订阅模式的步骤"></a>使用队列和发布/订阅模式的步骤</h4><h5 id="1-创建消息队列"><a href="#1-创建消息队列" class="headerlink" title="1. 创建消息队列"></a>1. 创建消息队列</h5><ul><li><strong>选择消息队列系统</strong>：选择适合你的需求的消息队列系统，如RabbitMQ、Apache Kafka等。</li><li><strong>配置消息队列</strong>：创建消息队列，设置队列的属性和参数。</li></ul><h5 id="2-定义消息格式和主题"><a href="#2-定义消息格式和主题" class="headerlink" title="2. 定义消息格式和主题"></a>2. 定义消息格式和主题</h5><ul><li><strong>消息格式</strong>：定义消息的结构和内容，包括消息的字段和数据类型。</li><li><strong>主题</strong>：定义不同的主题，用于区分不同类型的消息。</li></ul><h5 id="3-发布消息"><a href="#3-发布消息" class="headerlink" title="3. 发布消息"></a>3. 发布消息</h5><ul><li><strong>创建发布者</strong>：创建发布者应用程序，连接到消息队列。</li><li><strong>选择主题</strong>：选择要发布的消息主题。</li><li><strong>构造消息</strong>：构造消息，填充消息的内容和字段。</li><li><strong>发布消息</strong>：将消息发布到消息队列的指定主题。</li></ul><h5 id="4-订阅消息"><a href="#4-订阅消息" class="headerlink" title="4. 订阅消息"></a>4. 订阅消息</h5><ul><li><strong>创建订阅者</strong>：创建订阅者应用程序，连接到消息队列。</li><li><strong>选择订阅的主题</strong>：选择要订阅的消息主题。</li><li><strong>接收消息</strong>：订阅者从消息队列接收与其订阅的主题相关的消息。</li><li><strong>处理消息</strong>：订阅者处理接收到的消息，执行相应的操作。</li></ul><h4 id="队列和消息收发的最佳实践"><a href="#队列和消息收发的最佳实践" class="headerlink" title="队列和消息收发的最佳实践"></a>队列和消息收发的最佳实践</h4><ul><li><strong>消息持久化</strong>：确保消息在发送和接收过程中的持久化存储，以防止消息丢失。</li><li><strong>消息确认机制</strong>：使用消息确认机制，确保消息在发送和接收之间的可靠传递。</li><li><strong>消息序列化</strong>：对消息进行序列化和反序列化，以便在不同的应用程序和平台之间进行通信。</li><li><strong>错误处理和重试</strong>：处理发送和接收消息过程中的错误，并实现适当的重试机制。</li><li><strong>监控和日志记录</strong>：监控消息队列的性能和可用性，并记录相关的日志信息。</li></ul><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>队列是一种先进先出的数据结构，常用于存储和管理元素。消息收发是一种在分布式系统中进行通信的模式，其中发布/订阅是常见的消息收发模式。使用队列和发布/订阅模式可以实现异步任务处理、消息传递和事件处理等功能</p><h3 id="无服务器技术和模式（例如，AWS-Fargate、AWS-Lambda）"><a href="#无服务器技术和模式（例如，AWS-Fargate、AWS-Lambda）" class="headerlink" title="无服务器技术和模式（例如，AWS Fargate、AWS Lambda）"></a>无服务器技术和模式（例如，AWS Fargate、AWS Lambda）</h3><ul><li><h4 id="无服务器技术和模式概述"><a href="#无服务器技术和模式概述" class="headerlink" title="无服务器技术和模式概述"></a>无服务器技术和模式概述</h4><p>无服务器技术是一种云计算模型，它使开发人员能够构建和运行应用程序，而无需关注底层的服务器管理和维护。无服务器模式基于事件驱动的架构，可以根据需要自动扩展和收缩资源，以满足应用程序的需求。AWS（亚马逊网络服务）提供了多种无服务器服务，其中包括AWS Fargate和AWS Lambda。</p><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>AWS Fargate是一种无服务器容器计算引擎，允许开发人员在无需管理服务器的情况下运行容器化的应用程序。它提供了一种简化的方式来部署和管理容器，使开发人员可以专注于应用程序的开发和部署，而无需关注底层的基础设施。</p><h5 id="主要特性和用途"><a href="#主要特性和用途" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无服务器容器</strong>：AWS Fargate允许开发人员以无服务器的方式运行容器，无需管理底层的服务器资源。</li><li><strong>按需计费</strong>：AWS Fargate按实际使用的资源进行计费，可以根据应用程序的需求自动扩展和收缩容器。</li><li><strong>与其他AWS服务集成</strong>：AWS Fargate可以与其他AWS服务集成，如Amazon ECS（Elastic Container Service）和Amazon ECR（Elastic Container Registry），以构建完整的容器解决方案。</li></ul><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建任务定义</strong>：定义容器的规格、映像和其他配置。</li><li><strong>创建集群</strong>：创建一个容器集群，用于托管和管理容器实例。</li><li><strong>启动任务</strong>：将任务定义部署到集群中，启动容器实例。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理容器实例，进行日志记录、扩展和更新等操作。</li></ol><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>AWS Lambda是一种无服务器计算服务，以事件驱动的方式运行代码。开发人员可以编写函数并将其上传到AWS Lambda，然后在需要时自动触发执行函数。AWS Lambda负责管理底层的计算资源，使开发人员可以专注于编写业务逻辑。</p><h5 id="主要特性和用途-1"><a href="#主要特性和用途-1" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无服务器计算</strong>：AWS Lambda以无服务器的方式运行代码，无需管理底层的服务器。</li><li><strong>按需计费</strong>：AWS Lambda按代码的实际执行时间和资源使用进行计费，没有持续运行的费用。</li><li><strong>自动扩展</strong>：AWS Lambda根据请求的数量和负载自动扩展和收缩资源。</li><li><strong>与其他AWS服务集成</strong>：AWS Lambda可以与其他AWS服务集成，如API网关、S3、DynamoDB等，以构建强大的无服务器应用程序。</li></ul><h5 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>编写函数</strong>：编写函数代码，处理特定的事件或请求。</li><li><strong>创建Lambda函数</strong>：使用AWS管理控制台或CLI工具创建Lambda函数，并上传函数代码。</li><li><strong>配置触发器</strong>：配置触发器，指定何时触发函数的执行，如API调用、定时任务或其他事件。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理Lambda函数，查看执行日志、设置权限和调整函数配置等操作。</li></ol><h4 id="无服务器技术的最佳实践"><a href="#无服务器技术的最佳实践" class="headerlink" title="无服务器技术的最佳实践"></a>无服务器技术的最佳实践</h4><ul><li><strong>函数拆分</strong>：将应用程序拆分为多个小型函数，以提高可维护性和扩展性。</li><li><strong>状态管理</strong>：避免在函数之间共享状态，使用无状态函数设计，将状态存储在外部服务中。</li><li><strong>日志和监控</strong>：记录函数的执行日志，并使用监控工具来监视函数的性能和可用性。</li><li><strong>安全性</strong>：实施适当的安全措施，如函数级别的访问控制、数据加密和网络安全配置。</li><li><strong>测试和部署</strong>：编写自动化测试用例，使用持续集成和部署工具来自动部署和更新函数。</li></ul><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>无服务器技术和模式使开发人员能够构建和运行应用程序，而无需关注底层的服务器管理和维护。AWS Fargate是一种无服务器容器计算引擎，允许无服务器地运行容器化的应用程序。AWS Lambda是一种无服务器计算服务，以事件驱动的方式运行代码。无服务器技术的最佳实践包括函数拆分、状态管理、日志和监控、安全性以及测试和部署。</p></li></ul><h3 id="具有相关特性的存储类型（例如，对象、文件、数据块）"><a href="#具有相关特性的存储类型（例如，对象、文件、数据块）" class="headerlink" title="具有相关特性的存储类型（例如，对象、文件、数据块）"></a>具有相关特性的存储类型（例如，对象、文件、数据块）</h3><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>对象存储是一种存储数据的方式，它以对象的形式存储数据和元数据，并提供简单的API来管理和访问数据。</p><h5 id="主要特性和用途-2"><a href="#主要特性和用途-2" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无限扩展</strong>：对象存储可以存储大规模的数据，具有无限的扩展性。</li><li><strong>高可用性</strong>：对象存储通常具有高可用性，数据会自动在多个地理位置进行复制和冗余存储。</li><li><strong>持久性</strong>：对象存储数据通常是持久的，不容易丢失。</li><li><strong>适用于大文件和多媒体</strong>：对象存储适用于存储大型文件和多媒体内容，如图像、视频和音频文件。</li><li><strong>与其他服务集成</strong>：对象存储可以与其他服务集成，如CDN、数据分析和备份服务。</li></ul><h5 id="示例服务"><a href="#示例服务" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon S3</strong>：亚马逊简单存储服务（Amazon S3）是一种对象存储服务，用于在亚马逊云上存储和检索数据。它是一种高度可扩展、持久性强的存储解决方案，广泛用于各种应用程序和场景。</li></ul><h4 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h4><p>文件存储是一种存储数据的方式，它以文件的形式存储数据，并提供文件系统接口来管理和访问数据。</p><h5 id="主要特性和用途-3"><a href="#主要特性和用途-3" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>文件系统接口</strong>：文件存储提供类似于传统文件系统的接口，如读取、写入和删除文件。</li><li><strong>适用于结构化数据</strong>：文件存储适用于存储结构化的数据，如文本文件、配置文件和日志文件。</li><li><strong>共享访问</strong>：多个应用程序或用户可以共享访问文件存储中的数据。</li><li><strong>与现有应用程序兼容</strong>：文件存储可以与现有的应用程序和工具集成，无需进行大规模的代码更改。</li></ul><h5 id="示例服务-1"><a href="#示例服务-1" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon EFS</strong>：亚马逊弹性文件系统（Amazon EFS）是一种可扩展的、共享的文件存储服务，用于在亚马逊云上存储和访问文件数据。它提供标准文件系统接口，可以与多个EC2实例共享访问。</li></ul><h4 id="数据块存储"><a href="#数据块存储" class="headerlink" title="数据块存储"></a>数据块存储</h4><p>数据块存储是一种存储数据的方式，它将数据划分为固定大小的数据块，并使用唯一的标识符来管理和访问这些数据块。</p><h5 id="主要特性和用途-4"><a href="#主要特性和用途-4" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>低延迟</strong>：数据块存储通常具有低延迟的读写操作，适用于需要快速访问的应用程序。</li><li><strong>随机访问</strong>：可以随机访问数据块，而不需要读取整个文件或对象。</li><li><strong>适用于数据库和应用程序</strong>：数据块存储适用于存储数据库和应用程序的数据，如关系数据库和分布式文件系统。</li></ul><h5 id="示例服务-2"><a href="#示例服务-2" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon EBS</strong>：亚马逊弹性块存储（Amazon EBS）是一种持久性块存储服务，用于在亚马逊云上附加和使用块级存储卷。它提供低延迟的随机访问，并可与EC2实例进行关联。</li></ul><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p>存储类型包括对象存储、文件存储和数据块存储。对象存储适用于存储大规模数据和多媒体内容，如Amazon S3。文件存储适用于结构化数据和共享访问，如Amazon EFS。数据块存储适用于低延迟和随机访问的应用程序，如Amazon EBS。选择适当的存储类型取决于应用程序的需求和数据的特性。</p><h3 id="容器编排（例如，Amazon-Elastic-Container-Service-Amazon-ECS-、Amazon-Elastic-Kubernetes-Service-Amazon-EKS-）"><a href="#容器编排（例如，Amazon-Elastic-Container-Service-Amazon-ECS-、Amazon-Elastic-Kubernetes-Service-Amazon-EKS-）" class="headerlink" title="容器编排（例如，Amazon Elastic Container Service [Amazon ECS]、Amazon Elastic Kubernetes Service [Amazon EKS]）"></a>容器编排（例如，Amazon Elastic Container Service [Amazon ECS]、Amazon Elastic Kubernetes Service [Amazon EKS]）</h3><h4 id="容器编排概述"><a href="#容器编排概述" class="headerlink" title="容器编排概述"></a>容器编排概述</h4><p>容器编排是一种管理和调度容器化应用程序的技术，它可以帮助开发人员自动化容器的部署、扩展和管理。容器编排工具提供了一种简化的方式来定义、组织和运行容器，以便应用程序能够高效地运行在分布式环境中。AWS（亚马逊网络服务）提供了多种容器编排服务，其中包括Amazon Elastic Container Service（Amazon ECS）和Amazon Elastic Kubernetes Service（Amazon EKS）。</p><h4 id="Amazon-Elastic-Container-Service（Amazon-ECS）"><a href="#Amazon-Elastic-Container-Service（Amazon-ECS）" class="headerlink" title="Amazon Elastic Container Service（Amazon ECS）"></a>Amazon Elastic Container Service（Amazon ECS）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>Amazon Elastic Container Service（Amazon ECS）是一种高度可扩展的容器编排服务，用于在AWS云上运行和管理容器化应用程序。它提供了一种简单的方式来部署、运行和扩展容器，同时具备高可用性和可靠性。</p><h5 id="主要特性和用途-5"><a href="#主要特性和用途-5" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>托管容器</strong>：Amazon ECS允许开发人员将容器化的应用程序部署到托管的集群中，无需关注底层的基础设施。</li><li><strong>自动扩展</strong>：Amazon ECS可以根据应用程序的负载自动扩展和收缩容器实例，以确保应用程序的性能和可用性。</li><li><strong>与其他AWS服务集成</strong>：Amazon ECS可以与其他AWS服务集成，如Amazon EC2（Elastic Compute Cloud）、Amazon S3（Simple Storage Service）和Amazon VPC（Virtual Private Cloud），以构建完整的应用程序解决方案。</li><li><strong>任务定义和服务</strong>：通过任务定义和服务，可以定义容器的规格、映像和其他配置，并确保容器的持续运行和自动恢复。</li></ul><h5 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建集群</strong>：创建一个Amazon ECS集群，用于托管和管理容器实例。</li><li><strong>定义任务</strong>：创建一个任务定义，定义容器的规格、映像和其他配置。</li><li><strong>启动任务</strong>：使用任务定义创建一个任务，并将其部署到集群中，启动容器实例。</li><li><strong>创建服务</strong>：创建一个服务，指定任务的副本数和负载均衡策略，以确保容器的持续运行和自动恢复。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理容器实例和服务，进行日志记录、扩展和更新等操作。</li></ol><h4 id="Amazon-Elastic-Kubernetes-Service（Amazon-EKS）"><a href="#Amazon-Elastic-Kubernetes-Service（Amazon-EKS）" class="headerlink" title="Amazon Elastic Kubernetes Service（Amazon EKS）"></a>Amazon Elastic Kubernetes Service（Amazon EKS）</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>Amazon Elastic Kubernetes Service（Amazon EKS）是一种托管的Kubernetes服务，用于在AWS云上运行和管理Kubernetes容器编排平台。它提供了一个高度可扩展、安全和可靠的方式来部署和管理容器化应用程序。</p><h5 id="主要特性和用途-6"><a href="#主要特性和用途-6" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>托管Kubernetes集群</strong>：Amazon EKS提供了一个托管的Kubernetes控制平面，负责管理和调度容器化应用程序。</li><li><strong>自动扩展</strong>：Amazon EKS可以根据应用程序的负载自动扩展和收缩Kubernetes节点，以满足应用程序的需求。</li><li><strong>与其他AWS服务集成</strong>：Amazon EKS可以与其他AWS服务集成，如Amazon EC2、Amazon S3和Amazon VPC，以构建强大的容器化应用程序解决方案。</li><li><strong>Kubernetes生态系统</strong>：Amazon EKS与Kubernetes生态系统紧密集成，可以使用Kubernetes的丰富功能和工具来部署和管理应用程序。</li></ul><h5 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建集群</strong>：创建一个Amazon EKS集群，该集群将作为Kubernetes控制平面的托管环境。</li><li><strong>配置kubectl</strong>：配置kubectl命令行工具，以便与Amazon EKS集群进行通信。</li><li><strong>部署应用程序</strong>：使用Kubernetes清单文件定义和部署应用程序的Pod、服务和其他资源。</li><li><strong>扩展和管理</strong>：使用kubectl命令行工具或Kubernetes仪表板来扩展和管理应用程序，进行水平扩展、滚动更新和故障恢复等操作。</li><li><strong>监控和日志</strong>：使用Kubernetes的监控和日志工具，如Prometheus和Elasticsearch，来监控和记录应用程序的性能和日志。</li></ol><h4 id="容器编排的最佳实践"><a href="#容器编排的最佳实践" class="headerlink" title="容器编排的最佳实践"></a>容器编排的最佳实践</h4><ul><li><p><strong>声明式清单</strong>：使用声明式的清单文件来定义和部署应用程序，以便实现可重复、可维护和可扩展的部署。</p></li><li><p><strong>自动化部署</strong>：使用持续集成和持续部署（CI/CD）工具来自动化应用程序的</p></li><li><p>部署过程，包括构建、测试、部署和监控等环节，以提高开发和交付效率。</p><ul><li><strong>服务发现和负载均衡</strong>：使用容器编排工具提供的服务发现和负载均衡功能，以实现容器之间的通信和流量分发。</li><li><strong>弹性扩展</strong>：根据应用程序的负载情况，使用自动扩展功能来动态调整容器实例的数量，以满足需求并节省资源。</li><li><strong>安全性</strong>：实施适当的安全措施，如访问控制、网络隔离和容器映像的安全扫描，以保护容器化应用程序的安全性。</li><li><strong>日志和监控</strong>：使用日志和监控工具来收集、分析和可视化容器化应用程序的日志和性能指标，以便快速发现和解决问题。</li><li><strong>持续改进</strong>：不断优化容器编排的流程和架构，通过监控和分析数据来改进应用程序的性能、可靠性和可扩展性。</li></ul><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p>容器编排是一种管理和调度容器化应用程序的技术，可以帮助开发人员自动化容器的部署、扩展和管理。AWS提供了多种容器编排服务，包括Amazon ECS和Amazon EKS。Amazon ECS是一种高度可扩展的容器编排服务，用于在AWS云上运行和管理容器化应用程序。Amazon EKS是一种托管的Kubernetes服务，用于在AWS云上运行和管理Kubernetes容器编排平台。容器编排的最佳实践包括使用声明式清单、自动化部署、服务发现和负载均衡、弹性扩展、安全性、日志和监控以及持续改进。</p></li></ul><h3 id="何时使用只读副本"><a href="#何时使用只读副本" class="headerlink" title="何时使用只读副本"></a>何时使用只读副本</h3><h4 id="只读副本概述"><a href="#只读副本概述" class="headerlink" title="只读副本概述"></a>只读副本概述</h4><p>只读副本是数据库系统中的一种常见技术，它允许在主数据库的基础上创建一个副本，并将该副本配置为只读模式。只读副本用于提供读取性能的扩展、高可用性和冗余备份。在某些情况下，只读副本可以提供更好的性能和可用性，同时减轻主数据库的负载。</p><h4 id="何时使用只读副本-1"><a href="#何时使用只读副本-1" class="headerlink" title="何时使用只读副本"></a>何时使用只读副本</h4><p>以下是一些适合使用只读副本的情况：</p><h5 id="1-读取密集型工作负载"><a href="#1-读取密集型工作负载" class="headerlink" title="1. 读取密集型工作负载"></a>1. 读取密集型工作负载</h5><p>如果应用程序有大量的读取操作，而写入操作较少，可以考虑使用只读副本来分担主数据库的读取负载。只读副本可以处理读取请求，从而提高整体性能和响应时间。</p><h5 id="2-高可用性和容错"><a href="#2-高可用性和容错" class="headerlink" title="2. 高可用性和容错"></a>2. 高可用性和容错</h5><p>只读副本可以提供高可用性和容错能力。当主数据库发生故障或不可用时，只读副本可以继续提供读取服务，确保应用程序的连续性。这对于对可用性要求较高的关键业务非常重要。</p><h5 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3. 负载均衡"></a>3. 负载均衡</h5><p>通过将读取请求分发到多个只读副本，可以实现负载均衡，从而提高整体系统的性能和吞吐量。只读副本可以根据负载情况自动处理读取请求，减轻主数据库的负载。</p><h5 id="4-数据分析和报告"><a href="#4-数据分析和报告" class="headerlink" title="4. 数据分析和报告"></a>4. 数据分析和报告</h5><p>如果需要对数据库中的数据进行复杂的分析和报告，可以使用只读副本来执行这些任务，而不会对主数据库的性能产生负面影响。只读副本可以专门用于数据分析，提供更高的性能和资源。</p><h5 id="5-备份和恢复"><a href="#5-备份和恢复" class="headerlink" title="5. 备份和恢复"></a>5. 备份和恢复</h5><p>只读副本可以作为主数据库的冗余备份。通过定期将主数据库的数据复制到只读副本，可以确保在主数据库发生故障或数据损坏时能够快速恢复数据。</p><h4 id="部署只读副本的步骤"><a href="#部署只读副本的步骤" class="headerlink" title="部署只读副本的步骤"></a>部署只读副本的步骤</h4><p>以下是部署只读副本的一般步骤：</p><ol><li><p><strong>创建只读副本</strong>：在主数据库的基础上创建一个副本，并将其配置为只读模式。这可以通过数据库管理工具或数据库系统提供的命令来完成。</p></li><li><p><strong>配置复制</strong>：配置主数据库和只读副本之间的数据复制机制。这可以使用数据库系统提供的复制功能，如MySQL的主从复制或PostgreSQL的流复制。</p></li><li><p><strong>连接和路由</strong>：确保应用程序能够连接到只读副本并发送读取请求。这可能涉及到调整应用程序的数据库连接字符串或配置负载均衡器来路由读取请求到只读副本。</p></li><li><p><strong>监控和维护</strong>：监控只读副本的状态和性能，确保它正常工作并与主数据库保持同步。定期进行维护操作，如备份和更新，以保持只读副本的可用性和数据完整性。</p></li></ol><h4 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ul><li><p><strong>数据一致性</strong>：只读副本是通过复制主数据库的数据来实现的，因此在进行读取操作时，可能会存在一定的延迟，导致读取到的数据可能不是最新的。在应用程序中要注意处理这种数据一致性的情况。</p></li><li><p><strong>负载均衡策略</strong>：根据应用程序的读取负载情况选择合适的负载均衡策略，如轮询、最少连接等，以确保读取请求能够均衡地分发到只读副本。</p></li><li><p><strong>监控和警报</strong>：建立监控和警报系统，及时检测只读副本的状态和性能问题。监控指标可以包括副本延迟、同步状态、负载情况等。</p></li><li><p><strong>定期测试和维护</strong>：定期进行测试和维护操作，如故障切换测试、备份恢复测试和软件更新。这可以帮助确保只读副本的可用性和数据完整性。</p></li></ul><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p>只读副本是一种常见的数据库技术，用于提供读取性能的扩展、高可用性和冗余备份。适合使用只读副本的情况包括读取密集型工作负载、高可用性和容错、负载均衡、数据分析和报告以及备份和恢复。部署只读副本的步骤包括创建副本、配置复制、连接和路由以及监控和维护。在使用只读副本时，需要注意数据一致性、负载均衡策略、监控和警报以及定期测试和维护等注意事项和最佳实践。</p><h3 id="工作流编排（例如，AWS-Step-Functions）"><a href="#工作流编排（例如，AWS-Step-Functions）" class="headerlink" title="工作流编排（例如，AWS Step Functions）"></a>工作流编排（例如，AWS Step Functions）</h3><h4 id="工作流编排概述"><a href="#工作流编排概述" class="headerlink" title="工作流编排概述"></a>工作流编排概述</h4><p>工作流编排是一种将多个任务和步骤组织起来，按照特定的顺序和条件执行的技术。它可以帮助简化复杂的业务逻辑和流程，并提供可靠的执行和错误处理机制。AWS Step Functions是亚马逊云服务（AWS）提供的一项工作流编排服务，它使开发人员能够轻松地构建、部署和管理具有复杂业务逻辑的工作流应用程序。</p><h4 id="何时使用工作流编排"><a href="#何时使用工作流编排" class="headerlink" title="何时使用工作流编排"></a>何时使用工作流编排</h4><p>以下是一些适合使用工作流编排的情况：</p><h5 id="1-复杂的业务逻辑"><a href="#1-复杂的业务逻辑" class="headerlink" title="1. 复杂的业务逻辑"></a>1. 复杂的业务逻辑</h5><p>如果应用程序的业务逻辑涉及多个步骤和条件，且这些步骤需要按照特定的顺序执行，那么使用工作流编排可以帮助组织和管理这些步骤，使业务逻辑更易于理解和维护。</p><h5 id="2-异步和分布式任务"><a href="#2-异步和分布式任务" class="headerlink" title="2. 异步和分布式任务"></a>2. 异步和分布式任务</h5><p>当应用程序需要执行异步和分布式任务时，工作流编排可以帮助协调和管理这些任务的执行顺序和依赖关系。工作流编排可以处理任务的并行执行、等待和超时等复杂情况。</p><h5 id="3-错误处理和重试"><a href="#3-错误处理和重试" class="headerlink" title="3. 错误处理和重试"></a>3. 错误处理和重试</h5><p>工作流编排提供了强大的错误处理和重试机制。当任务执行失败时，工作流编排可以根据配置的错误处理策略进行相应的处理，如重试、错误通知或执行备用步骤。</p><h5 id="4-可视化和监控"><a href="#4-可视化和监控" class="headerlink" title="4. 可视化和监控"></a>4. 可视化和监控</h5><p>工作流编排通常提供可视化界面，用于可视化工作流的结构和执行状态。这可以帮助开发人员和运维团队更好地理解和监控工作流的执行情况，及时发现和解决问题。</p><h4 id="使用-AWS-Step-Functions-的步骤"><a href="#使用-AWS-Step-Functions-的步骤" class="headerlink" title="使用 AWS Step Functions 的步骤"></a>使用 AWS Step Functions 的步骤</h4><p>以下是使用AWS Step Functions进行工作流编排的一般步骤：</p><ol><li><p><strong>定义状态机</strong>：使用AWS Step Functions提供的定义语言（如Amazon States Language）来定义工作流的状态机。状态机由一系列状态和状态转换组成，每个状态代表一个任务或步骤。</p></li><li><p><strong>配置输入和输出</strong>：为工作流定义输入和输出参数，以便任务之间可以传递数据。输入参数可以是工作流的初始输入，输出参数可以是工作流的最终结果。</p></li><li><p><strong>定义状态转换</strong>：为每个状态定义状态转换条件和动作。状态转换条件可以是成功或失败的条件，动作可以是执行任务、等待、重试或跳转到其他状态。</p></li><li><p><strong>部署和执行</strong>：将定义好的状态机部署到AWS Step Functions，并通过API或控制台触发工作流的执行。工作流将按照定义的状态机和转换逻辑执行任务。</p></li><li><p><strong>监控和调试</strong>：使用AWS Step Functions提供的监控和日志功能来监控工作流的执行情况。可以查看工作流的状态、执行时间和错误信息，以及进行调试和故障排除。</p></li></ol><h4 id="注意事项和最佳实践-1"><a href="#注意事项和最佳实践-1" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ul><li><p><strong>模块化设计</strong>：将工作流分解为较小的任务和步骤，并通过模块化的方式设计状态机。这样可以提高工作流的可维护性和重用性。</p></li><li><p><strong>错误处理和重试策略</strong>：定义适当的错误处理和重试策略，以处理任务执行失败的情况。可以配置重试次数、重试间隔和备用步骤等。</p></li><li><p><strong>保持状态的幂等性</strong>：确保工作流中的任务和步骤具有幂等性，即多次执行不会产生不一致的结果。这样可以避免由于重试导致的数据重复或不一致性。</p></li><li><p><strong>监控和警报</strong>：建立监控和警报系统，及时检测工作流的执行状态和错误情况。可以使用AWS CloudWatch等服务来监控工作流的指标和日志。</p></li><li><p><strong>版本控制和回滚</strong>：对工作流的定义和配置进行版本控制，并确保可以回滚到之前的版本。这样可以方便地管理和维护工作流的变更和更新。</p></li></ul><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p>工作流编排是一种将多个任务和步骤组织起来、按照特定顺序和条件执行的技术。AWS Step Functions是一项强大的工作流编排服务，适用于复杂的业务逻辑、异步和分布式任务、错误处理和重试以及可视化和监控需求。使用AWS Step Functions的步骤包括定义状态机、配置输入和输出、定义状态转换、部署和执行以及监控和调试。在使用AWS Step Functions时，需要注意模块化设计、错误处理和重试策略、保持状态的幂等性、监控和警报以及版本控制和回滚等注意事项和最佳实践。</p><h2 id="设计高可用性架构和-或容错架构"><a href="#设计高可用性架构和-或容错架构" class="headerlink" title="设计高可用性架构和/或容错架构"></a>设计高可用性架构和/或容错架构</h2><h4 id="AWS全球基础设施"><a href="#AWS全球基础设施" class="headerlink" title="AWS全球基础设施"></a>AWS全球基础设施</h4><p>AWS全球基础设施包括多个地理区域和可用区。每个区域是一组数据中心，每个区域内的可用区则是更小的独立单元，可提供冗余和容错能力。例如，如果一个可用区出现故障，其他可用区仍能继续运行。Amazon Route 53是一种DNS服务，可以根据地理位置智能地路由用户到最近的区域。</p><h4 id="AWS-Managed-Services及其使用案例"><a href="#AWS-Managed-Services及其使用案例" class="headerlink" title="AWS Managed Services及其使用案例"></a>AWS Managed Services及其使用案例</h4><p>AWS Managed Services提供了许多托管服务，如Amazon Comprehend（一种自然语言处理服务）和Amazon Polly（一个文本转语音服务）。这些服务简化了管理任务，并提高了可用性。例如，使用Amazon Polly，你可以轻松将文本转换为语音输出，而无需深入了解语音合成技术。</p><h4 id="基本联网概念"><a href="#基本联网概念" class="headerlink" title="基本联网概念"></a>基本联网概念</h4><p>联网概念包括路由表、子网和网络ACLs等。路由表定义了网络流量如何从一个子网转移到另一个子网或外部网络。在AWS中，你可以设置路由表来指导网络流量的流向，以确保高效和安全的数据传输。</p><h4 id="灾难恢复策略"><a href="#灾难恢复策略" class="headerlink" title="灾难恢复策略"></a>灾难恢复策略</h4><p>灾难恢复策略包括备份和还原、长明灯（持续运行的最小资源）、热备用、双活故障转移等。这些策略通过定义RPO（恢复点目标）和RTO（恢复时间目标）来确保在发生灾难时数据和应用程序的快速恢复。例如，使用AWS的备份服务可以定期备份关键数据，以便在需要时迅速恢复。</p><h4 id="分布式设计模式"><a href="#分布式设计模式" class="headerlink" title="分布式设计模式"></a>分布式设计模式</h4><p>分布式设计模式涉及在多个服务器、区域或可用区中分布应用程序和数据，以提高可靠性和可用性。例如，可以在不同的AWS区域部署应用程序的副本，以防某个区域出现故障。</p><h4 id="故障转移策略"><a href="#故障转移策略" class="headerlink" title="故障转移策略"></a>故障转移策略</h4><p>故障转移策略包括自动检测故障并将流量重定向到健康的服务器或区域。例如，Amazon RDS的多可用区部署可以在主数据库故障时自动故障转移到备用数据库。</p><h4 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h4><p>不可变基础设施意味着一旦创建，资源（如服务器）就不会被更改。相反，任何更新都通过替换现有资源来实现。这减少了配置漂移和相关故障的可能性。</p><h4 id="负载均衡概念"><a href="#负载均衡概念" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h4><p>负载均衡器（如Application Load Balancer）可以在多个服务器之间分配流量，以优化性能和可用性。例如，如果一个服务器过载，负载均衡器可以将流量转移到其他较少负载的服务器。</p><h4 id="代理概念"><a href="#代理概念" class="headerlink" title="代理概念"></a>代理概念</h4><p>代理（如Amazon RDS Proxy）是一种数据库代理服务，它可以帮助管理数据库连接，提高可扩展性和可用性。它作为应用程序和数据库之间的中间层，优化连接。</p><h4 id="Service-Quotas和限流"><a href="#Service-Quotas和限流" class="headerlink" title="Service Quotas和限流"></a>Service Quotas和限流</h4><p>Service Quotas是AWS服务的使用限额。在设计容错架构时，重要的是要了解这些限额并相应地配置备用环境。限流可以帮助管理资源使用，防止系统过载。</p><h4 id="存储选项和特性"><a href="#存储选项和特性" class="headerlink" title="存储选项和特性"></a>存储选项和特性</h4><p>AWS提供多种存储选项，如EBS、S3和Glacier，每种都有不同的特</p><p>性，如持久性和复制。选择正确的存储解决方案对于确保数据的可用性和持久性至关重要。</p><h4 id="工作负载可见性"><a href="#工作负载可见性" class="headerlink" title="工作负载可见性"></a>工作负载可见性</h4><p>工具如AWS X-Ray可以提供工作负载的可见性，帮助识别和排除性能问题。它允许你跟踪请求在分布式系统中的路径，并识别瓶颈。</p><p>以上各点是设计高可用性和/或容错架构时需要掌握的关键知识点。每个点都是构建强大、可靠云基础设施的基石。</p><h2 id="确定高性能和-或可扩展的存储解决方案"><a href="#确定高性能和-或可扩展的存储解决方案" class="headerlink" title="确定高性能和/或可扩展的存储解决方案"></a>确定高性能和/或可扩展的存储解决方案</h2><h4 id="可满足业务要求的混合存储解决方案"><a href="#可满足业务要求的混合存储解决方案" class="headerlink" title="可满足业务要求的混合存储解决方案"></a>可满足业务要求的混合存储解决方案</h4><p>混合存储解决方案结合了本地存储和云存储的优势，以满足不同业务需求。例如，一个公司可能使用本地存储处理高速、低延迟的任务，同时使用云存储进行数据备份和灾难恢复。</p><ul><li><strong>本地存储</strong>: 快速访问，适用于处理大量实时数据。</li><li><strong>云存储</strong>: 可扩展性强，适合长期数据存储、共享和远程访问。</li></ul><p>案例：一个视频编辑公司可能在本地服务器上存储当前正在编辑的视频，以利用高速访问；同时，将已完成的项目存储在云中，以节省本地存储空间和便于客户访问。</p><h4 id="具有合适使用案例的存储服务"><a href="#具有合适使用案例的存储服务" class="headerlink" title="具有合适使用案例的存储服务"></a>具有合适使用案例的存储服务</h4><ul><li><strong>Amazon S3</strong>: 一种对象存储服务，适用于存储大量非结构化数据。例如，可以用于存储网站的静态文件、备份数据或大数据分析。</li><li><strong>Amazon Elastic File System (EFS)</strong>: 提供简单、可扩展的文件存储。适用于需要共享文件系统的应用，如内容管理系统或数据分析应用。</li><li><strong>Amazon Elastic Block Store (EBS)</strong>: 提供块存储，适用于需要持久化存储的情况，如数据库或企业级应用。</li></ul><p>案例：如果需要存储网站图像和视频，Amazon S3是理想选择；如果需要运行需要高吞吐量共享文件系统的应用，可以选择EFS；对于运行数据库，EBS更合适。</p><h4 id="具有相关特性的存储类型"><a href="#具有相关特性的存储类型" class="headerlink" title="具有相关特性的存储类型"></a>具有相关特性的存储类型</h4><ul><li><strong>对象存储</strong>: 如Amazon S3，适合存储非结构化数据。特点是可扩展性高，成本效益好。</li><li><strong>文件存储</strong>: 如Amazon EFS，适合需要共享访问的场景。</li><li><strong>数据块存储</strong>: 如Amazon EBS，适合需要高性能、低延迟的应用，如数据库。</li></ul><p>案例：一个电子健康记录系统可能使用文件存储来存储和共享病历，同时使用数据块存储来支持其数据库。</p><h4 id="技能一：确定可满足性能要求的存储服务和配置"><a href="#技能一：确定可满足性能要求的存储服务和配置" class="headerlink" title="技能一：确定可满足性能要求的存储服务和配置"></a>技能一：确定可满足性能要求的存储服务和配置</h4><p>分析业务需求，确定数据访问模式、吞吐量需求和延迟敏感度。例如，对于高频读写的数据库，需要选择低延迟、高吞吐量的存储解决方案，如Amazon EBS的高性能配置。</p><p>案例：一家金融服务公司可能需要使用高性能的EBS配置来支持其高速交易系统。</p><h4 id="技能二：确定可扩展以适应未来需求的存储服务"><a href="#技能二：确定可扩展以适应未来需求的存储服务" class="headerlink" title="技能二：确定可扩展以适应未来需求的存储服务"></a>技能二：确定可扩展以适应未来需求的存储服务</h4><p>评估业务增长和数据增长预期，选择可扩展性强的存储解决方案。例如，Amazon S3在对象存储方面提供几乎无限的扩展性，适合长期数据增长。</p><p>案例：随着用户基数的增长，一款社交媒体应用可能需要不断扩大其存储容量，因此选择S3作为其图片和视频存储的理想选择。<br>确定高性能数据库解决方案时，需要考虑多个方面。我将逐一讲解以下知识点，并尽量使用通俗易懂的例子来阐述。</p><h2 id="确定高性能数据库解决方案。"><a href="#确定高性能数据库解决方案。" class="headerlink" title="确定高性能数据库解决方案。"></a>确定高性能数据库解决方案。</h2><h3 id="AWS-全球基础设施"><a href="#AWS-全球基础设施" class="headerlink" title="AWS 全球基础设施"></a>AWS 全球基础设施</h3><p>AWS（亚马逊网络服务）提供了一个全球性的基础设施，包括多个地理位置分布的区域和可用区。每个AWS区域是一个独立的地理区域，每个区域内又包含多个物理上分离的、冗余连接的数据中心，这些被称为可用区。例如，如果您的用户主要在中国，选择靠近中国的亚马逊数据中心可以减少延迟，提高服务的响应速度。</p><h3 id="缓存策略和服务"><a href="#缓存策略和服务" class="headerlink" title="缓存策略和服务"></a>缓存策略和服务</h3><p>Amazon ElastiCache 是一个广泛使用的缓存服务，它支持常见的缓存策略，如Redis和Memcached。通过使用ElastiCache，可以将频繁访问的数据存储在内存中，从而快速响应读取请求，减轻数据库的负担。例如，一个电商网站可以将热销商品的信息存储在ElastiCache中，以便快速响应用户的查询请求。</p><h3 id="数据访问模式"><a href="#数据访问模式" class="headerlink" title="数据访问模式"></a>数据访问模式</h3><p>数据访问模式主要分为读取密集型和写入密集型。读取密集型的应用，如新闻网站，主要面向大量的读取操作，而写入密集型的应用，如社交媒体的评论系统，则面临着大量的数据写入操作。根据应用的访问模式，选择合适的数据库类型和配置是非常重要的。</p><h3 id="数据库容量规划"><a href="#数据库容量规划" class="headerlink" title="数据库容量规划"></a>数据库容量规划</h3><p>数据库容量规划包括容量单位、实例类型和预置IOPS（输入/输出操作每秒）。这需要根据应用程序的需求来定制，例如一个需要处理大量事务的金融系统可能需要高IOPS的数据库配置。预置IOPS是一种性能模式，它可以保证在高负载下提供一致的I/O性能。</p><h3 id="数据库连接和代理"><a href="#数据库连接和代理" class="headerlink" title="数据库连接和代理"></a>数据库连接和代理</h3><p>数据库连接管理是数据库性能的关键因素之一。过多的数据库连接会消耗大量资源，而连接池技术可以有效地管理这些连接。数据库代理如Amazon RDS Proxy可以帮助管理和缩放数据库连接，提高应用程序的可扩展性和弹性。</p><h3 id="数据库引擎的适用案例"><a href="#数据库引擎的适用案例" class="headerlink" title="数据库引擎的适用案例"></a>数据库引擎的适用案例</h3><p>不同的数据库引擎适合不同的使用场景。例如，对于需要高度可靠性和一致性的银行系统，适合使用传统的关系型数据库，如MySQL或PostgreSQL。对于需要高速数据分析和实时处理的大数据应用，非关系型数据库如Amazon DynamoDB可能更合适。</p><h3 id="数据库复制"><a href="#数据库复制" class="headerlink" title="数据库复制"></a>数据库复制</h3><p>数据库复制是指在多个数据库之间同步数据，以提高数据的可用性和灾难恢复能力。例如，只读副本可以用于负载均衡和备份，如果主数据库发生故障，可以快速切换到副本上继续提供服务。</p><h3 id="数据库类型和服务"><a href="#数据库类型和服务" class="headerlink" title="数据库类型和服务"></a>数据库类型和服务</h3><p>数据库可以分为关系型和非关系型两大类。关系型数据库，如MySQL，适合于结构化数据和复杂查询；而非关系型数据库，如MongoDB，适合于非结构化数据和快速的读写操作。无服务器的关系数据库（如Amazon Aurora Serverless）和内存中的非关系数据库（如Redis）提供了不同的性能和扩展性选项，适合于不同的应用场景。</p><p>确定高性能和可扩展的网络架构，以及掌握相关知识点，是确保网络系统可靠、高效的关键。以下是对您提到的各个知识点的详细解释：</p><h2 id="确定高性能的数据摄取和转换解决方案。"><a href="#确定高性能的数据摄取和转换解决方案。" class="headerlink" title="确定高性能的数据摄取和转换解决方案。"></a>确定高性能的数据摄取和转换解决方案。</h2><h3 id="边缘联网服务及其使用案例"><a href="#边缘联网服务及其使用案例" class="headerlink" title="边缘联网服务及其使用案例"></a>边缘联网服务及其使用案例</h3><p>边缘联网服务允许数据更靠近用户处理，从而减少延迟和提高性能。例如，Amazon CloudFront 是一个内容分发网络（CDN）服务，它缓存数据至全球分布的节点，使得用户可以快速访问数据。AWS Global Accelerator 则通过优化路径，加速用户到 AWS 应用程序的访问。</p><p><strong>举例：</strong><br>一个视频流媒体公司使用 Amazon CloudFront 来分发内容。当用户请求视频时，他们会从最近的边缘位置获取数据，而不是从远端的数据中心，从而减少了加载时间。</p><h3 id="设计网络架构"><a href="#设计网络架构" class="headerlink" title="设计网络架构"></a>设计网络架构</h3><p>网络架构设计是指定义网络的结构和组件，如子网、路由和IP地址等。合理设计可以提高网络的安全性、可扩展性和性能。</p><p><strong>举例：</strong><br>在AWS中，您可以创建多个子网，将网络划分为不同的部分，每部分可以有不同的安全级别和路由策略。例如，公共子网可用于托管需要外部访问的资源，如Web服务器，而私有子网则用于数据库。</p><h3 id="负载均衡概念-1"><a href="#负载均衡概念-1" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h3><p>负载均衡是一种技术，用于在多个服务器之间分配网络或应用程序流量。Application Load Balancer (ALB) 是 AWS 提供的一种负载均衡器，专门用于HTTP和HTTPS流量，它可以根据请求内容将流量路由至不同的后端。</p><p><strong>举例：</strong><br>一个网站可以使用 ALB 来分配流量至多个服务器，确保没有单一服务器过载。ALB 可以根据用户请求的URL或请求头来决定将流量路由至哪个服务器。</p><h3 id="网络连接选项"><a href="#网络连接选项" class="headerlink" title="网络连接选项"></a>网络连接选项</h3><p>AWS 提供多种网络连接选项，包括 VPN、Direct Connect 和 AWS PrivateLink，以适应不同的连接需求。</p><ul><li><strong>AWS VPN</strong> 允许您安全地连接您的本地网络到 AWS。</li><li><strong>Direct Connect</strong> 提供了一种私有的、高速的网络连接，直接连接您的数据中心和 AWS。</li><li><strong>AWS PrivateLink</strong> 提供了一种安全的连接方式，允许您通过私有网络访问 AWS 服务。</li></ul><p><strong>举例：</strong><br>企业可以使用 AWS Direct Connect 在其数据中心和 AWS 之间建立专用网络连接，以提高网络传输速度并降低网络成本。</p><h3 id="确定高性能的数据摄取和转换解决方案"><a href="#确定高性能的数据摄取和转换解决方案" class="headerlink" title="确定高性能的数据摄取和转换解决方案"></a>确定高性能的数据摄取和转换解决方案</h3><h4 id="数据分析和可视化服务"><a href="#数据分析和可视化服务" class="headerlink" title="数据分析和可视化服务"></a>数据分析和可视化服务</h4><h5 id="示例：Amazon-Athena-和-AWS-Lake-Formation"><a href="#示例：Amazon-Athena-和-AWS-Lake-Formation" class="headerlink" title="示例：Amazon Athena 和 AWS Lake Formation"></a>示例：Amazon Athena 和 AWS Lake Formation</h5><ul><li><strong>Amazon Athena</strong> 是一种基于 SQL 的服务，允许用户直接在 Amazon S3 上分析数据。适用场景包括对大量未处理的日志文件进行即席查询和分析。</li><li><strong>AWS Lake Formation</strong> 用于构建、保护和管理数据湖。它简化了数据收集、存储、清洁和安全控制的过程。例如，企业可以使用 Lake Formation 快速设置数据湖，集成各种数据源。</li></ul><h4 id="数据摄取模式"><a href="#数据摄取模式" class="headerlink" title="数据摄取模式"></a>数据摄取模式</h4><h5 id="示例：频率"><a href="#示例：频率" class="headerlink" title="示例：频率"></a>示例：频率</h5><ul><li><strong>频率</strong> 指数据摄取发生的频繁程度，比如实时、每日或每周。例如，一个电子商务网站可能会实时摄取交易数据，而一个月度财务报告可能只需要每月摄取数据。</li></ul><h4 id="数据传输服务"><a href="#数据传输服务" class="headerlink" title="数据传输服务"></a>数据传输服务</h4><h5 id="示例：AWS-DataSync-和-AWS-Storage-Gateway"><a href="#示例：AWS-DataSync-和-AWS-Storage-Gateway" class="headerlink" title="示例：AWS DataSync 和 AWS Storage Gateway"></a>示例：AWS DataSync 和 AWS Storage Gateway</h5><ul><li><strong>AWS DataSync</strong> 可用于快速、简单、安全地移动大量数据。适合于将本地数据迁移到 AWS 或在 AWS 服务之间同步数据。</li><li><strong>AWS Storage Gateway</strong> 是一种混合存储服务，允许本地环境与 AWS 云存储服务无缝集成。适用于需要定期备份本地数据到云的场景。</li></ul><h4 id="数据转换服务"><a href="#数据转换服务" class="headerlink" title="数据转换服务"></a>数据转换服务</h4><h5 id="示例：AWS-Glue"><a href="#示例：AWS-Glue" class="headerlink" title="示例：AWS Glue"></a>示例：AWS Glue</h5><ul><li><strong>AWS Glue</strong> 是一种完全托管的 ETL (提取、转换、加载) 服务。例如，可以使用 AWS Glue 自动化地将来自不同源的数据格式化、清洁，并准备用于分析。</li></ul><h4 id="对摄取接入点的安全访问"><a href="#对摄取接入点的安全访问" class="headerlink" title="对摄取接入点的安全访问"></a>对摄取接入点的安全访问</h4><ul><li>确保数据在摄取过程中的安全性至关重要。例如，使用加密和身份验证机制来保护数据的完整性和机密性。</li></ul><h4 id="满足业务要求所需的规模和速度"><a href="#满足业务要求所需的规模和速度" class="headerlink" title="满足业务要求所需的规模和速度"></a>满足业务要求所需的规模和速度</h4><ul><li>根据业务需求选择合适的数据处理能力和传输速度。例如，处理大量实时数据流可能需要更高的处理速度和计算资源。</li></ul><h4 id="流式传输数据服务"><a href="#流式传输数据服务" class="headerlink" title="流式传输数据服务"></a>流式传输数据服务</h4><h5 id="示例：Amazon-Kinesis"><a href="#示例：Amazon-Kinesis" class="headerlink" title="示例：Amazon Kinesis"></a>示例：Amazon Kinesis</h5><ul><li><strong>Amazon Kinesis</strong> 提供实时数据处理能力。适用于需要实时监控和分析的场景，如社交媒体数据流或实时游戏数据分析。</li></ul><p>以上每个服务和概念都是构建高性能数据摄取和转换解决方案的重要部分。通过理解这些服务的适用场景和特点，可以更好地设计和实施数据处理策略，以满足特定业务需求。</p><h2 id="设计成本优化型存储解决方案"><a href="#设计成本优化型存储解决方案" class="headerlink" title="设计成本优化型存储解决方案"></a>设计成本优化型存储解决方案</h2><h4 id="访问选项"><a href="#访问选项" class="headerlink" title="访问选项"></a>访问选项</h4><h5 id="示例：S3-存储桶的申请方付款"><a href="#示例：S3-存储桶的申请方付款" class="headerlink" title="示例：S3 存储桶的申请方付款"></a>示例：S3 存储桶的申请方付款</h5><ul><li>在 Amazon S3 中，可以配置存储桶以启用“申请方付款”模式。这意味着数据访问费用由访问者承担，而不是存储桶的拥有者。适用于公共数据集的共享场景。</li></ul><h4 id="AWS-成本管理服务功能"><a href="#AWS-成本管理服务功能" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><h5 id="示例：成本分配标签和多账户账单"><a href="#示例：成本分配标签和多账户账单" class="headerlink" title="示例：成本分配标签和多账户账单"></a>示例：成本分配标签和多账户账单</h5><ul><li><strong>成本分配标签</strong> 允许用户按项目、部门等对 AWS 资源的成本进行分类和跟踪。</li><li><strong>多账户账单</strong> 功能使组织能够将多个 AWS 账户的成本和使用情况集中到一个账单中，简化财务管理。</li></ul><h4 id="AWS-成本管理工具"><a href="#AWS-成本管理工具" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><h5 id="示例：AWS-Cost-Explorer、AWS-Budgets"><a href="#示例：AWS-Cost-Explorer、AWS-Budgets" class="headerlink" title="示例：AWS Cost Explorer、AWS Budgets"></a>示例：AWS Cost Explorer、AWS Budgets</h5><ul><li><strong>AWS Cost Explorer</strong> 用于分析和可视化 AWS 花费和使用情况数据。</li><li><strong>AWS Budgets</strong> 允许用户设置预算，以监控服务的使用情况和成本。</li></ul><h4 id="AWS-存储服务"><a href="#AWS-存储服务" class="headerlink" title="AWS 存储服务"></a>AWS 存储服务</h4><h5 id="示例：Amazon-FSx、Amazon-EFS、Amazon-S3、Amazon-EBS"><a href="#示例：Amazon-FSx、Amazon-EFS、Amazon-S3、Amazon-EBS" class="headerlink" title="示例：Amazon FSx、Amazon EFS、Amazon S3、Amazon EBS"></a>示例：Amazon FSx、Amazon EFS、Amazon S3、Amazon EBS</h5><ul><li><strong>Amazon FSx</strong> 提供完全托管的 Windows 文件服务器。</li><li><strong>Amazon EFS</strong> 为 Linux 实例提供简单、可扩展的文件存储。</li><li><strong>Amazon S3</strong> 是高度可扩展的对象存储服务。</li><li><strong>Amazon EBS</strong> 提供块存储卷，用于与 EC2 实例一起使用。</li></ul><h4 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h4><ul><li>定期备份数据，确保在灾难发生时可恢复。可利用 AWS Backup 等服务自动化此过程。</li></ul><h4 id="数据块存储选项"><a href="#数据块存储选项" class="headerlink" title="数据块存储选项"></a>数据块存储选项</h4><h5 id="示例：HDD-卷类型和-SSD-卷类型"><a href="#示例：HDD-卷类型和-SSD-卷类型" class="headerlink" title="示例：HDD 卷类型和 SSD 卷类型"></a>示例：HDD 卷类型和 SSD 卷类型</h5><ul><li><strong>HDD 卷类型</strong> 适用于频繁访问不太集中的数据。</li><li><strong>SSD 卷类型</strong> 适合于高吞吐量和低延迟的需求。</li></ul><h4 id="数据生命周期"><a href="#数据生命周期" class="headerlink" title="数据生命周期"></a>数据生命周期</h4><ul><li>使用数据生命周期管理策略自动将老旧数据转移到更经济的存储类别。</li></ul><h4 id="混合存储选项"><a href="#混合存储选项" class="headerlink" title="混合存储选项"></a>混合存储选项</h4><h5 id="示例：DataSync、Transfer-Family、Storage-Gateway"><a href="#示例：DataSync、Transfer-Family、Storage-Gateway" class="headerlink" title="示例：DataSync、Transfer Family、Storage Gateway"></a>示例：DataSync、Transfer Family、Storage Gateway</h5><ul><li><strong>DataSync</strong> 自动化数据转移。</li><li><strong>Transfer Family</strong> 管理文件传输。</li><li><strong>Storage Gateway</strong> 连接本地和云存储。</li></ul><h4 id="存储访问模式"><a href="#存储访问模式" class="headerlink" title="存储访问模式"></a>存储访问模式</h4><ul><li>分析数据的访问模式，选择最适合的存储类型，如频繁访问或偶尔访问。</li></ul><h4 id="存储分层"><a href="#存储分层" class="headerlink" title="存储分层"></a>存储分层</h4><h5 id="示例：对象存储的冷分层"><a href="#示例：对象存储的冷分层" class="headerlink" title="示例：对象存储的冷分层"></a>示例：对象存储的冷分层</h5><ul><li>对象存储的冷分层适用于不常访问的数据，比如 Amazon S3 的 Glacier。</li></ul><h4 id="存储类型的相关特性"><a href="#存储类型的相关特性" class="headerlink" title="存储类型的相关特性"></a>存储类型的相关特性</h4><h5 id="示例：对象、文件、数据块存储"><a href="#示例：对象、文件、数据块存储" class="headerlink" title="示例：对象、文件、数据块存储"></a>示例：对象、文件、数据块存储</h5><ul><li><strong>对象存储</strong>：适用于大量非结构化数据。</li><li><strong>文件存储</strong>：适用于需要共享文件系统的场景。</li><li><strong>数据块存储</strong>：适用于数据库和其他需要持久存储的应用。</li></ul><h2 id="设计成本优化型计算解决方案"><a href="#设计成本优化型计算解决方案" class="headerlink" title="设计成本优化型计算解决方案"></a>设计成本优化型计算解决方案</h2><p>当设计成本优化型计算解决方案时，需要考虑多个方面，包括AWS成本管理服务、全球基础设施、购买选项、计算策略等。以下是这些主要知识点的详细解释和实例。</p><h4 id="AWS-成本管理服务功能-1"><a href="#AWS-成本管理服务功能-1" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><ul><li><strong>成本分配标签</strong>：允许你标记AWS资源，以便跟踪成本。例如，你可以为不同的部门或项目标记不同的资源，从而更容易地追踪和管理这些成本。</li><li><strong>多账户账单</strong>：如果你管理多个AWS账户，这个功能可以帮助你集中查看和管理这些账户的费用。它能够让你从总体上把握成本，便于进行成本优化。</li></ul><h4 id="具有合适使用案例的-AWS-成本管理工具"><a href="#具有合适使用案例的-AWS-成本管理工具" class="headerlink" title="具有合适使用案例的 AWS 成本管理工具"></a>具有合适使用案例的 AWS 成本管理工具</h4><ul><li><strong>Cost Explorer</strong>：用于可视化和理解AWS花费和使用情况。例如，你可以使用它来查看过去几个月的消费趋势，预测未来的费用。</li><li><strong>AWS Budgets</strong>：允许你设定预算和警报，以便在费用或使用量超出预设的阈值时收到通知。</li><li><strong>AWS 成本和使用情况报告</strong>：提供详细的成本和使用数据，方便你深入分析成本。</li></ul><h4 id="AWS-全球基础设施-1"><a href="#AWS-全球基础设施-1" class="headerlink" title="AWS 全球基础设施"></a>AWS 全球基础设施</h4><ul><li><strong>可用区</strong>：AWS在特定区域内的多个独立数据中心。通过在不同的可用区部署应用，可以提高可靠性和可用性。</li><li><strong>AWS 区域</strong>：AWS全球的地理区域，每个区域包含多个可用区。选择距离用户较近的区域可以减少延迟，可能还能降低数据传输费用。</li></ul><h4 id="AWS-购买选项"><a href="#AWS-购买选项" class="headerlink" title="AWS 购买选项"></a>AWS 购买选项</h4><ul><li><strong>Spot 实例</strong>：以市场定价购买的实例，适合于可以容忍中断的灵活和非关键任务。通常比按需实例便宜很多。</li><li><strong>预留实例</strong>：提前预订的实例，适合长期稳定的需求，价格低于按需实例。</li><li><strong>Savings Plans</strong>：为一致的使用量提供更低的价格，适用于长期稳定的使用。</li></ul><h4 id="分布式计算策略"><a href="#分布式计算策略" class="headerlink" title="分布式计算策略"></a>分布式计算策略</h4><ul><li><strong>边缘处理</strong>：在离数据来源更近的地方进行数据处理，如使用AWS Lambda@Edge在边缘位置运行代码，减少延迟，优化性能。</li></ul><h4 id="混合计算选项"><a href="#混合计算选项" class="headerlink" title="混合计算选项"></a>混合计算选项</h4><ul><li><strong>AWS Outposts</strong>：将AWS服务、基础设施和操作模型带到几乎任何数据中心、共同位置空间或云环境。</li><li><strong>AWS Snowball Edge</strong>：物理设备，用于数据传输和边缘计算，适合大量数据迁移和离线处理。</li></ul><h4 id="实例类型、系列和大小"><a href="#实例类型、系列和大小" class="headerlink" title="实例类型、系列和大小"></a>实例类型、系列和大小</h4><ul><li><strong>内存优化型</strong>：适合内存密集型应用，如大型数据库。</li><li><strong>计算优化型</strong>：适合计算密集型任务，如高性能计算。</li><li><strong>虚拟化</strong>：提供虚拟服务器，适合多种用途。</li></ul><h4 id="优化计算利用率"><a href="#优化计算利用率" class="headerlink" title="优化计算利用率"></a>优化计算利用率</h4><ul><li><strong>容器</strong>：通过容器技术（如Docker），可以更高效地使用资源，提高应用的部署速度和可移植性。</li><li><strong>无服务器计算</strong>：如AWS Lambda，按需自动扩展，只为实际使用的资源付费。</li><li><strong>微服务</strong>：将应用拆分为小型、独立的服务，可以独立</li></ul><h2 id="设计成本优化型数据库解决方案"><a href="#设计成本优化型数据库解决方案" class="headerlink" title="设计成本优化型数据库解决方案"></a>设计成本优化型数据库解决方案</h2><p>在设计成本优化型数据库解决方案时，考虑以下关键知识点非常重要：</p><h4 id="AWS-成本管理服务功能-2"><a href="#AWS-成本管理服务功能-2" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><p>AWS 提供多种成本管理工具，帮助您理解、控制和优化 AWS 资源的成本。</p><ul><li><strong>成本分配标签</strong>：允许您将自定义标签分配给 AWS 资源，以便对成本进行更详细的跟踪。例如，您可以为不同的部门或项目分配标签，以跟踪每个部门或项目的资源使用情况和成本。</li><li><strong>多账户账单</strong>：如果您有多个 AWS 账户，可以使用此功能来合并账单。这有助于简化账单管理并获得整体成本视图。</li></ul><h4 id="AWS-成本管理工具-1"><a href="#AWS-成本管理工具-1" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><ul><li><strong>Cost Explorer</strong>：一个强大的工具，用于可视化和分析您的 AWS 贴费数据。您可以查看历史数据，预测未来开支，以及识别成本趋势。</li><li><strong>AWS Budgets</strong>：允许您设置预算以控制成本。您可以为 AWS 成本、使用量、保留实例覆盖率等设置预算。</li><li><strong>AWS 成本和使用情况报告</strong>：提供详细的成本和使用数据报告，支持将数据导出到 Amazon S3，方便进行深入分析。</li></ul><h4 id="缓存策略-2"><a href="#缓存策略-2" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>缓存可以显著减少数据库的负载，降低成本。例如，使用 Amazon ElastiCache 来缓存常用数据，减少对数据库的直接访问次数。</p><h4 id="数据留存策略"><a href="#数据留存策略" class="headerlink" title="数据留存策略"></a>数据留存策略</h4><p>合理的数据留存策略可以减少不必要的存储成本。例如，使用 Amazon S3 的生命周期策略自动转移或删除旧数据。</p><h4 id="数据库容量规划-1"><a href="#数据库容量规划-1" class="headerlink" title="数据库容量规划"></a>数据库容量规划</h4><ul><li><strong>容量单位</strong>：合理规划数据库容量可以避免资源浪费。例如，根据业务需求选择合适的 Amazon RDS 实例类型和大小。</li></ul><h4 id="数据库连接和代理-1"><a href="#数据库连接和代理-1" class="headerlink" title="数据库连接和代理"></a>数据库连接和代理</h4><ul><li>使用 Amazon RDS Proxy 可以有效管理数据库连接，减少不必要的资源开销。</li></ul><h4 id="数据库引擎的合适使用案例"><a href="#数据库引擎的合适使用案例" class="headerlink" title="数据库引擎的合适使用案例"></a>数据库引擎的合适使用案例</h4><ul><li><strong>异构迁移</strong>：例如，从 Oracle 迁移到 Amazon Aurora。</li><li><strong>同构迁移</strong>：例如，从一个 MySQL 数据库迁移到另一个 MySQL 数据库。</li></ul><h4 id="数据库复制-1"><a href="#数据库复制-1" class="headerlink" title="数据库复制"></a>数据库复制</h4><ul><li><strong>只读副本</strong>：例如，使用 Amazon RDS for MySQL 的只读副本来分担读取负载，从而提高性能和可靠性。</li></ul><h4 id="数据库类型和服务-1"><a href="#数据库类型和服务-1" class="headerlink" title="数据库类型和服务"></a>数据库类型和服务</h4><ul><li><strong>关系数据库与非关系数据库</strong>：选择适合您数据模式的数据库类型。例如，结构化数据使用 Amazon RDS，非结构化数据使用 Amazon DynamoDB。</li><li><strong>Aurora 与 DynamoDB 的比较</strong>：Aurora 适用于需要高性能事务处理的场景，而 DynamoDB 适用于需要高度可扩展、低延迟的 NoSQL 解决方案。</li></ul><h3 id="设计成本优化型网络架构"><a href="#设计成本优化型网络架构" class="headerlink" title="设计成本优化型网络架构"></a>设计成本优化型网络架构</h3><h4 id="AWS-成本管理服务功能-3"><a href="#AWS-成本管理服务功能-3" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><p>AWS成本管理服务提供了多种工具和功能，帮助用户监控、管理和优化他们在AWS上的支出和使用情况。这包括：</p><ul><li><p><strong>成本分配标签</strong>：它们允许用户通过添加标签来组织资源，以便更容易地追踪成本和使用情况。例如，你可以为不同的项目或部门设置标签，以便更容易地分配成本。</p></li><li><p><strong>多账户账单</strong>：对于拥有多个AWS账户的组织来说，多账户账单功能可以帮助它们更好地理解和管理各个账户的开销。</p></li></ul><h4 id="AWS-成本管理工具-2"><a href="#AWS-成本管理工具-2" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><ul><li><p><strong>Cost Explorer</strong>：这是一个可视化工具，用户可以通过它查看和分析他们的AWS成本和使用情况数据。例如，你可以使用Cost Explorer来查看过去几个月的支出趋势，或者分析特定服务的成本。</p></li><li><p><strong>AWS Budgets</strong>：这个工具允许用户设置预算并接收警报，以便在成本或使用量超出预定阈值时得到通知。</p></li><li><p><strong>AWS 成本和使用情况报告</strong>：这是一种更高级的工具，它提供关于AWS使用情况和成本的详细报告。用户可以用它来进行深入的成本分析。</p></li></ul><h4 id="负载均衡概念-2"><a href="#负载均衡概念-2" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h4><ul><li><strong>Application Load Balancer</strong>：这是一种用于分配进入应用程序的流量的负载均衡器。例如，如果你有一个高流量的网站，使用Application Load Balancer可以帮助分散流量，提高应用程序的可用性和效率。</li></ul><h4 id="NAT-网关"><a href="#NAT-网关" class="headerlink" title="NAT 网关"></a>NAT 网关</h4><ul><li><strong>NAT实例与NAT网关成本比较</strong>：NAT实例是一种基于EC2的解决方案，而NAT网关是AWS提供的托管服务。通常，NAT网关比NAT实例更易于管理且可扩展性更好，但可能在某些情况下成本更高。</li></ul><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><ul><li><strong>私有线路、专用线路、VPN</strong>：这些都是连接到AWS的不同方法。私有线路（如AWS Direct Connect）提供了一种直接连接到AWS的方式，可以降低网络成本，提高带宽效率。专用线路适用于需要高安全性的连接。VPN提供了一种通过互联网安全连接到AWS的方式。</li></ul><h4 id="网络路由、拓扑和对等连接"><a href="#网络路由、拓扑和对等连接" class="headerlink" title="网络路由、拓扑和对等连接"></a>网络路由、拓扑和对等连接</h4><ul><li><strong>AWS Transit Gateway和VPC对等连接</strong>：这些服务允许不同的VPC之间以及VPC和本地网络之间的通信。例如，使用Transit Gateway可以更容易地管理大规模的网络拓扑，而VPC对等连接允许两个VPC之间直接通信。</li></ul><h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><ul><li><strong>DNS</strong>：域名系统（DNS）是网络上的一项关键服务，用于将域名转换为IP地址。在AWS中，Amazon Route 53提供了强大的DNS服务，支持成本优化和高可用性。</li></ul><p>通过这些知识点的掌握，你可以更好地设计和管理一个成本效益高、性能优化的AWS网络架构。</p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conspectus for SAA</title>
      <link href="/2023/12/24/saa%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/12/24/saa%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="Elastic-Load-Balancing（弹性负载均衡）"><a href="#Elastic-Load-Balancing（弹性负载均衡）" class="headerlink" title="Elastic Load Balancing（弹性负载均衡）"></a>Elastic Load Balancing（弹性负载均衡）</h3><p> 是一种自动分配进入应用程序的网络流量的服务。它可以确保负载均匀分布在多个服务器上，从而提高应用程序的可用性和容错能力。Elastic Load Balancing支持三种主要类型的负载均衡器：</p><ol><li><strong>应用程序负载均衡器（Application Load Balancer）</strong>：适用于HTTP和HTTPS流量，提供高级路由功能，可以基于内容将流量路由到不同的服务。</li><li><strong>网络负载均衡器（Network Load Balancer）</strong>：适用于TCP流量，特别适合处理高性能、低延迟的网络传输。网络负载均衡器能够在数毫秒内自动响应流量变化。</li><li><strong>经典负载均衡器（Classic Load Balancer）</strong>：提供基本的负载均衡功能，适用于应用程序和网络层面的负载均衡。</li></ol><p>Elastic Load Balancing可以集成到AWS的其他服务中，如Auto Scaling（自动扩展服务），以确保应用程序在不同的负载条件下均能稳定运行。通过Elastic Load Balancing，可以自动检测不健康的实例，并将流量重新分配到健康的实例上，从而保证应用程序的高可用性。</p><h3 id="Auto-Scaling（自动扩展）"><a href="#Auto-Scaling（自动扩展）" class="headerlink" title="Auto Scaling（自动扩展）"></a>Auto Scaling（自动扩展）</h3><p>是一种云计算服务，用于自动调整计算资源的数量以满足应用程序的需求。这种服务通常与云计算平台（如AWS、Azure或Google Cloud）结合使用。Auto Scaling的主要特点和优点包括：</p><ol><li><strong>动态扩展和缩减</strong>：根据预定义的指标（如CPU使用率、网络流量或自定义指标），自动增加或减少服务器实例的数量。这确保了在需求增加时提供足够的资源，而在需求减少时减少不必要的开支。</li><li><strong>成本效益</strong>：通过仅在需要时添加资源，并在不需要时移除资源，Auto Scaling有助于优化成本，因为用户只需为实际使用的资源付费。</li><li><strong>高可用性和容错性</strong>：通过跨多个地理区域或可用区自动分配资源，Auto Scaling可以提高应用程序的可用性和抗故障能力。</li><li><strong>预测性扩展</strong>：某些自动扩展服务还提供基于预测分析的扩展，这意味着它们可以根据历史数据和趋势分析来预测需求，并相应地调整资源。</li><li><strong>与负载均衡器集成</strong>：Auto Scaling通常与负载均衡器（如Elastic Load Balancing）集成，以确保新添加的实例可以接收到流量，并且流量在所有实例之间均匀分配。</li></ol><p>Auto Scaling适用于需要根据流量或其他指标动态调整资源的应用程序，例如电子商务网站、大数据分析应用程序和在线游戏服务器。通过自动扩展，这些应用程序可以在负载高峰期间保持性能，并在低峰期间减少资源浪费。</p><h3 id="Amazon-CloudFront"><a href="#Amazon-CloudFront" class="headerlink" title="Amazon CloudFront"></a>Amazon CloudFront</h3><p>是由亚马逊网络服务（AWS）提供的内容分发网络（CDN）服务。它帮助以低延迟和高传输速度向用户提供内容，如网页、视频、图像和其他静态和动态文件。CloudFront通过在全球范围内的边缘位置缓存内容，使内容更接近最终用户，从而减少内容传输的距离和时间。</p><p>在设置和配置Amazon CloudFront时，您有几个选项和参数可以考虑。以下是一些关键设置：</p><p>源：</p><p>源类型：指定您内容的源，可以是AWS资源（例如S3存储桶、EC2实例）或自定义源（例如HTTP服务器）。<br>源协议策略：选择CloudFront与源之间通信时使用的协议，可以是HTTP或HTTPS。<br>分发设置：</p><p>价格级别：选择决定用于传送内容的边缘位置数量的价格级别（边缘位置越多，成本越高但性能更好）。<br>替代域名（CNAME）：指定要与CloudFront分发关联的任何自定义域名。<br>SSL证书：选择用于安全连接的SSL证书（您可以使用AWS证书管理器来管理SSL证书）。<br>默认根对象：定义当用户访问分发的根URL时要提供的默认文件。<br>缓存行为设置：</p><p>路径模式：定义匹配特定路径或模式的规则<br>这些只是Amazon CloudFront的一些关键设置，具体选择的设置取决于您的应用程序要求和分发的预期行为。建议查阅AWS文档以获取关于每个参数及其影响的详细信息。</p><h3 id="AWS-Glacier"><a href="#AWS-Glacier" class="headerlink" title="AWS Glacier"></a>AWS Glacier</h3><p>是亚马逊网络服务（AWS）提供的一种低成本、长期存储服务。它旨在为需要长期保存数据的场景提供可靠的、安全的存储解决方案。Glacier适用于备份、归档和长期数据保留等用途。</p><p>以下是AWS Glacier的一些关键特点和概念：</p><ol><li><p>存储类别：AWS Glacier提供了三种存储类别：标准存储（Standard）、大容量存储（Bulk）和快速存储（Expedited）。每种存储类别具有不同的定价和可用性。标准存储适用于大多数场景，而大容量存储和快速存储适用于需要快速检索数据的特定用例。</p></li><li><p>存储桶和存档：在AWS Glacier中，数据存储在称为存储桶（Vault）的容器中。每个存储桶可以包含多个存档（Archive），每个存档代表一个文件或对象。存档可以是任意大小，最大支持40TB。</p></li><li><p>数据上传和检索：您可以使用AWS Glacier提供的API或AWS管理控制台将数据上传到存储桶中。上传的数据被分割成多个部分，并进行压缩和加密，然后存储在AWS的数据中心中。对于大容量存储和快速存储，数据可以更快地检索出来。数据检索请求可以是实时的（快速存储）或延迟几个小时（大容量存储）。</p></li><li><p>数据保留和可用性：AWS Glacier被设计为长期存储解决方案，数据的可用性相对较低。数据检索请求可能需要几个小时才能完成，因此不适合需要实时访问的数据。但是，AWS Glacier提供了数据可靠性保证，并采取了多重复制和数据校验等措施来确保数据的安全性和完整性。</p></li><li><p>定价：AWS Glacier的定价基于存储的数据量、数据上传和检索的操作次数以及存储的时间长度。不同的存储类别和数据检索速度会影响定价。您可以参考AWS Glacier的定价页面或使用AWS计算器来估算使用该服务的成本。</p></li></ol><p>AWS Glacier提供了一种经济高效的长期数据存储解决方案，适用于需要将数据安全地保存多年的场景。它与其他AWS服务（如Amazon S3和Amazon Glacier Deep Archive）相互集成，为用户提供了灵活的存储和数据管理选项。</p><h3 id="AWS-Elastic-Transcoder"><a href="#AWS-Elastic-Transcoder" class="headerlink" title="AWS Elastic Transcoder"></a>AWS Elastic Transcoder</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一项云视频转码服务。它可以帮助用户将视频文件转换成不同的格式，以适应不同的设备和平台，比如移动设备、电视、互联网流媒体等等。以下是一些关于 AWS Elastic Transcoder 的关键信息：</p><ol><li><p><strong>视频转码：</strong> Elastic Transcoder 可以将输入的视频文件转码成多种输出格式，包括不同的分辨率、编码和容器格式。这有助于确保视频在不同设备上的流畅播放。</p></li><li><p><strong>自动缩放：</strong> 它能够自动调整输出视频的分辨率和比特率，以适应不同的终端设备和带宽条件。</p></li><li><p><strong>预设模板：</strong> Elastic Transcoder 提供了多种预设模板，可用于快速配置输出参数，用户可以选择适合其需求的预设，也可以自定义设置。</p></li><li><p><strong>工作流程：</strong> 用户可以创建自定义工作流程，将多个转码任务组合在一起，以实现复杂的视频处理需求。</p></li><li><p><strong>云服务：</strong> Elastic Transcoder 是一项托管的云服务，用户无需关心基础设施维护和扩展，只需支付按用量计费。</p></li><li><p><strong>集成性：</strong> 它可以与其他 AWS 服务和云存储服务（如Amazon S3）集成，使视频转码和存储变得更加简单。</p></li></ol><p>AWS Elastic Transcoder 是一个强大的工具，适用于需要处理和分发视频内容的各种应用，包括媒体流媒体、在线教育、广告等。通过使用它，您可以确保您的视频在不同的设备上以最佳质量进行播放。</p><h3 id="AWS-简单通知服务（Simple-Notification-Service，SNS）"><a href="#AWS-简单通知服务（Simple-Notification-Service，SNS）" class="headerlink" title="AWS 简单通知服务（Simple Notification Service，SNS）"></a>AWS 简单通知服务（Simple Notification Service，SNS）</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一项托管的通知服务，用于构建分布式、可扩展的应用程序和微服务架构。以下是关于 AWS SNS 的关键信息：</p><ol><li><p><strong>消息发布和订阅：</strong> SNS 允许开发人员将消息发布到主题（Topic），然后允许订阅者通过不同的通信协议接收这些消息。订阅者可以是应用程序、服务器、移动设备或终端用户。</p></li><li><p><strong>多通信协议支持：</strong> SNS 支持多种通信协议，包括电子邮件、短信、HTTP、HTTPS、Lambda、SQS（简单队列服务）等。这意味着您可以以多种方式将消息传递给订阅者，以适应不同的用例。</p></li><li><p><strong>消息筛选：</strong> SNS 支持消息筛选功能，让订阅者可以只接收与他们关心的主题相关的消息，这可以降低不必要的消息传递。</p></li><li><p><strong>可扩展性：</strong> SNS 可以轻松扩展以处理大量的消息和订阅者。它是高可用的，可以确保消息的可靠传递。</p></li><li><p><strong>事件驱动架构：</strong> SNS 可以作为事件驱动架构的一部分，将通知消息传递给触发器（例如 AWS Lambda 函数），从而实现自动化和响应式应用程序。</p></li><li><p><strong>安全性：</strong> SNS 提供身份验证和授权机制，以确保消息的安全传递，并可以与 AWS Identity and Access Management（IAM）集成，以控制对 SNS 主题的访问权限。</p></li></ol><p>AWS SNS 可以用于各种用例，包括应用程序提醒、监控和警报、社交媒体分享、移动应用程序通知等。它是构建具有高度可扩展性和弹性的分布式应用程序的有力工具，有助于将消息和通知传递到目标接收者，无论是人还是应用程序。</p><h3 id="AWS-Simple-Queue-Service（SQS）"><a href="#AWS-Simple-Queue-Service（SQS）" class="headerlink" title="AWS Simple Queue Service（SQS）"></a>AWS Simple Queue Service（SQS）</h3><p>是亚马逊网络服务（AWS）提供的一种完全托管的消息队列服务。它允许应用程序在分布式系统中进行异步通信，并解耦发送者和接收者之间的关系。SQS可用于构建可靠的、可扩展的应用程序，处理大量消息并保证消息的可靠传递。</p><p>以下是AWS Simple Queue Service的一些关键特点和概念：</p><ol><li><p>消息队列：SQS使用消息队列来存储和传递消息。消息队列是一种中间件，可以存储消息并按照先进先出（FIFO）的顺序将其传递给消费者。</p></li><li><p>队列类型：SQS提供两种类型的队列：标准队列和先进先出（FIFO）队列。标准队列提供高吞吐量和最少一次交付保证，但消息的顺序不是严格保证的。FIFO队列提供严格的消息顺序保证，但吞吐量略低。</p></li><li><p>消息传递：应用程序可以使用SQS API将消息发送到队列中，并使用API接收消息。消息可以是任意大小，最大支持256KB。发送者和接收者可以是不同的应用程序，甚至可以跨越不同的系统和云服务。</p></li><li><p>可靠性和可伸缩性：SQS提供高度可靠的消息传递，确保消息不会丢失。它还具有自动伸缩的能力，可以根据负载的变化自动调整吞吐量。</p></li><li><p>可见性超时：当消费者接收到消息后，消息将在一段时间内不可见，称为可见性超时。在此期间，消费者可以处理消息，但其他消费者无法看到该消息。如果消费者在处理消息时发生故障或未能删除消息，消息将重新变为可见状态，供其他消费者处理。</p></li><li><p>消息保留：SQS可以保留消息，即使消息被消费者接收和处理，也可以在队列中保留一段时间。这对于需要重放或重新处理消息的场景非常有用。</p></li><li><p>延迟队列：SQS还支持延迟队列，可以将消息延迟发送到队列中。这对于需要在一定时间后执行某些操作的应用程序非常有用。</p></li></ol><p>AWS Simple Queue Service提供了一种可靠、高可用的消息队列服务，适用于构建分布式系统、异步通信和处理大量消息的场景。它与其他AWS服务（如AWS Lambda、Amazon EC2和Amazon SNS）集成，提供了灵活的消息传递选项和可扩展性。</p><h3 id="DynamoDB-表（DynamoDB-table）"><a href="#DynamoDB-表（DynamoDB-table）" class="headerlink" title="DynamoDB 表（DynamoDB table）"></a>DynamoDB 表（DynamoDB table）</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一种全托管的 NoSQL 数据库服务，用于存储和检索数据。以下是关于 DynamoDB 表的关键信息：</p><ol><li><p><strong>分布式和托管：</strong> DynamoDB 表是一种完全托管的数据库服务，它自动处理底层硬件和分布式数据库的运维工作，使开发人员可以专注于数据建模和应用程序逻辑。</p></li><li><p><strong>键值存储：</strong> DynamoDB 是一种键值存储数据库，每个表都有一个主键，可以是单一属性或组合属性。这使得数据的检索和查询非常快速。</p></li><li><p><strong>无模式和灵活：</strong> DynamoDB 是无模式的数据库，这意味着您可以在同一表中存储不同结构的数据，而不需要预定义模式。这使得 DynamoDB 适用于多样化的数据。</p></li><li><p><strong>自动缩放：</strong> DynamoDB 具有自动扩展和缩小的能力，根据负载的变化自动调整读取和写入容量单元，以确保高性能和低延迟。</p></li><li><p><strong>多区域复制：</strong> 您可以配置 DynamoDB 表以进行多区域复制，以增加数据的可用性和容错性。这使得数据在多个 AWS 区域之间进行复制和同步。</p></li><li><p><strong>安全性：</strong> DynamoDB 提供了身份和访问管理（IAM）集成，以控制对表的访问权限。您可以定义细粒度的权限策略，以确保数据的安全性。</p></li><li><p><strong>高可用性：</strong> DynamoDB 具有高可用性和持久性，保证数据的可靠性和持久性。</p></li><li><p><strong>全局二级索引：</strong> 您可以创建全局二级索引，以支持不同于主键的查询需求，这使得检索数据更加灵活。</p></li></ol><p>DynamoDB 表通常用于构建具有大规模、低延迟读取和写入需求的应用程序，如电子商务平台、游戏分数排名、用户配置文件存储等。它是一种强大的数据库服务，可以适应各种用例，并提供高度的可扩展性和性能。</p><h3 id="EBS（Elastic-Block-Store）"><a href="#EBS（Elastic-Block-Store）" class="headerlink" title="EBS（Elastic Block Store）"></a>EBS（Elastic Block Store）</h3><p>是亚马逊网络服务（AWS）提供的一种持久性块存储服务，用于在云中运行的虚拟机实例（如Amazon EC2实例）上存储数据。EBS 提供了可靠、高性能和可扩展的块级存储解决方案，允许用户创建、附加、备份和恢复数据卷。</p><p>以下是 EBS 的一些关键特点和功能：</p><ol><li><p>持久性存储：EBS 提供持久性存储，确保数据在实例终止或发生故障时不会丢失。数据存储在 EBS 卷上，并且持久保存在亚马逊的后端存储系统中。</p></li><li><p>高性能：EBS 提供低延迟和高吞吐量的性能，适用于各种工作负载，包括数据库、文件存储和应用程序数据。</p></li><li><p>可扩展性：用户可以根据需要创建和调整 EBS 卷的容量，无需中断实例。EBS 卷的大小可以从几GB到16TB不等。</p></li><li><p>快照备份：EBS 允许用户创建卷的快照备份，以便在需要时进行数据恢复或创建新的卷。快照是卷的点-in-time 副本，可以用作数据备份、复制和迁移。</p></li><li><p>多种卷类型：EBS 提供多种卷类型，以满足不同的性能和成本需求。其中包括：SSD（固态硬盘）卷类型（如 gp2、io1、io2）和 HDD（硬盘驱动器）卷类型（如 st1、sc1）。</p></li><li><p>可靠性和可用性：EBS 提供了数据冗余和故障转移功能，以确保数据的可靠性和可用性。EBS 卷的数据会在多个存储设备上进行复制，以提供高可靠性。</p></li><li><p>集成性：EBS 与其他 AWS 服务集成紧密，例如 Amazon EC2、Amazon RDS（关系型数据库服务）和 Amazon EMR（弹性 MapReduce 服务），使用户可以轻松地将 EBS 用于各种应用场景。</p></li></ol><p>通过使用 EBS，用户可以在 AWS 上创建和管理持久性存储卷，为云中的应用程序提供可靠的数据存储解决方案。EBS 提供了高性能、可扩展性和数据保护功能，使用户能够根据需要灵活地管理和使用存储资源。</p><h4 id="EBS-提供不同类型的存储选项"><a href="#EBS-提供不同类型的存储选项" class="headerlink" title="(EBS) 提供不同类型的存储选项"></a>(EBS) 提供不同类型的存储选项</h4><p>Amazon Elastic Block Store (EBS) 提供不同类型的存储选项，每种类型都针对特定的使用案例和性能需求设计。以下是四种主要类型的 EBS 卷的概述：</p><p>EBS Provisioned IOPS SSD (io1/io2): 这种类型的 EBS 卷专为 I/O 密集型的事务型工作负载设计，如数据库应用程序。它们提供高性能的 SSD 支持，并允许用户预设 IOPS（每秒输入/输出操作次数），以满足高吞吐量和低延迟的需求。对于需要持续高 IOPS 的应用，如大型关系型数据库或高频交易系统，这是理想的选择。</p><p>EBS General Purpose SSD (gp2/gp3): 这是一种通用的 SSD 卷，适用于广泛的工作负载。它们提供了良好的性能和价格比，对 IOPS 有基本的需求，但不像 io1/io2 那样高。这种卷适合用于系统引导盘、虚拟桌面环境、中小型数据库和开发/测试环境。</p><p>EBS Cold HDD (sc1): 这种硬盘驱动器 (HDD) 卷提供了较低的存储成本，并适用于低频访问的数据。它们是为需要较大存储容量但不频繁访问数据的应用程序设计的，如备份、数据仓库和冷数据存储。</p><p>EBS Throughput Optimized HDD (st1): 这是另一种 HDD 类型的卷，专为吞吐量密集型的工作负载设计，如大数据、数据仓库、日志处理和大型数据集的批量处理。st1 卷提供高吞吐量性能，适用于频繁读写的大数据集。</p><p>选择哪种类型的 EBS 卷取决于您的具体应用需求，包括性能、成本和存储容量的考虑。例如，对于高性能数据库，可能会选择 Provisioned IOPS SSD，而对于成本敏感且访问频率较低的数据存储，则可能选择 Cold HDD 或 Throughput Optimized HDD。</p><h3 id="EFS（Elastic-File-System）"><a href="#EFS（Elastic-File-System）" class="headerlink" title="EFS（Elastic File System）"></a>EFS（Elastic File System）</h3><p>是亚马逊网络服务（AWS）提供的一种托管的弹性文件存储服务，可用于在云中运行的应用程序和服务。它提供了一个简单、可扩展和高性能的文件系统，可以与多个 Amazon EC2 实例共享数据，并且可以在不同的可用区域之间复制和备份数据。</p><p>以下是 EFS 的一些关键特点和功能：</p><ol><li><p>共享文件系统：EFS 允许多个 Amazon EC2 实例同时访问和共享相同的文件系统。这使得多个实例可以同时读取和写入相同的文件，方便了分布式应用程序和共享存储需求的实现。</p></li><li><p>自动扩展：EFS 可以根据需要自动扩展存储容量和性能，无需中断实例。它可以根据文件系统的使用情况自动调整存储容量，并提供高吞吐量和低延迟的性能。</p></li><li><p>可靠性和耐用性：EFS 提供了高度可靠和耐用的文件存储解决方案。数据在多个可用区域进行复制，以提供高可用性和数据冗余。此外，EFS 还支持自动的文件系统级别的备份和恢复功能。</p></li><li><p>安全性和权限控制：EFS 提供了细粒度的权限控制，允许用户对文件和目录设置访问权限。用户可以使用 AWS Identity and Access Management（IAM）来管理对文件系统的访问，并通过文件系统级别的加密来保护数据的安全性。</p></li><li><p>高性能：EFS 提供了低延迟和高吞吐量的性能，适用于各种工作负载，包括大规模并发访问和大型文件的读写操作。</p></li><li><p>跨可用区域复制：EFS 支持在不同的 AWS 区域之间进行文件系统的复制和备份，以提供更高的可用性和灾备能力。</p></li><li><p>集成性：EFS 与其他 AWS 服务集成紧密，例如 Amazon EC2、Amazon ECS（容器服务）和 AWS Lambda（无服务器计算服务），使用户可以轻松地将 EFS 用于各种应用场景。</p></li></ol><p>通过使用 EFS，用户可以轻松地创建和管理共享的弹性文件系统，为云中的应用程序提供可靠和高性能的文件存储解决方案。EFS 提供了自动扩展、高可用性和安全性等功能，使用户能够轻松地实现多实例共享数据和分布式应用程序的需求。</p><h3 id="ElastiCache"><a href="#ElastiCache" class="headerlink" title="ElastiCache"></a>ElastiCache</h3><p> 是亚马逊网络服务（AWS）提供的一种托管的内存缓存服务，旨在提高应用程序的性能和可扩展性。它支持两种流行的开源内存缓存引擎：Redis 和 Memcached。</p><p>以下是 ElastiCache 的一些关键特点和功能：</p><ol><li><p>高性能缓存：ElastiCache 提供了快速、低延迟的内存缓存服务，可以显著提高应用程序的读取性能。通过将常用的数据存储在内存中，应用程序可以更快地检索数据，减轻后端数据库的负载。</p></li><li><p>托管服务：ElastiCache 是一种完全托管的服务，AWS 负责管理缓存集群的设置、维护和监控。这样，用户无需关心硬件和软件的细节，可以专注于应用程序的开发和性能优化。</p></li><li><p>可扩展性：ElastiCache 允许用户根据需要扩展缓存集群的规模，以适应不断增长的数据和流量。用户可以根据应用程序的需求增加或减少节点数，以实现水平扩展和高可用性。</p></li><li><p>Redis 和 Memcached 支持：ElastiCache 支持两种主流的开源内存缓存引擎：Redis 和 Memcached。用户可以根据自己的需求选择适合的引擎。Redis 提供了更丰富的功能，例如数据持久化、复制和发布/订阅，而 Memcached 则提供了简单高效的缓存功能。</p></li><li><p>自动故障转移和恢复：ElastiCache 提供自动故障转移功能，当缓存节点发生故障时，会自动将请求路由到可用节点，以保证高可用性和持续的服务。</p></li><li><p>安全性和权限控制：ElastiCache 提供了多层次的安全性和权限控制机制。用户可以使用 AWS Identity and Access Management（IAM）来管理对 ElastiCache 的访问权限，并通过网络隔离和访问控制列表（ACL）来保护缓存集群的安全性。</p></li><li><p>监控和日志记录：ElastiCache 提供了丰富的监控和日志记录功能，用户可以实时监控缓存集群的性能指标、运行状况和事件。此外，ElastiCache 还与 AWS CloudWatch 和 AWS CloudTrail 集成，以便进行更全面的监控和日志分析。</p></li></ol><p>通过使用 ElastiCache，用户可以轻松地添加和管理高性能的内存缓存层，提高应用程序的响应速度和可伸缩性。ElastiCache 提供了托管服务、可扩展性、安全性和监控等功能，使用户能够轻松地构建和管理缓存集群，以满足不同应用程序的需求。</p><h3 id="ECS（Elastic-Container-Service）"><a href="#ECS（Elastic-Container-Service）" class="headerlink" title="ECS（Elastic Container Service）"></a>ECS（Elastic Container Service）</h3><p>是亚马逊网络服务（AWS）提供的一种托管容器编排服务，用于在云中运行和管理容器化应用程序。它支持 Docker 容器，并提供了一种简单而高效的方式来部署、运行和扩展容器化应用程序。</p><p>以下是 ECS 的一些关键特点和功能：</p><ol><li><p>容器编排：ECS 提供了一种灵活的容器编排机制，可以方便地部署和管理容器化应用程序。它允许用户定义任务（Task）和服务（Service），并自动处理容器的调度、启动、停止和扩展。</p></li><li><p>容器集群：ECS 使用容器集群（Cluster）作为容器化应用程序的运行环境。用户可以创建和管理多个集群，每个集群可以包含多个 EC2 实例或 Fargate 任务（无需 EC2 实例）。集群提供了资源管理、负载均衡和容器调度等功能。</p></li><li><p>弹性扩展：ECS 允许根据应用程序的需求自动扩展容器实例。用户可以定义自动扩展策略，根据 CPU 使用率、内存使用率或其他指标来动态调整容器实例数量，以满足流量和负载的变化。</p></li><li><p>任务定义：ECS 使用任务定义（Task Definition）来描述容器化应用程序的配置和要求。任务定义包括容器映像、资源限制、网络设置和存储卷等信息。通过任务定义，用户可以定义应用程序的结构和配置，并将其部署到容器集群中。</p></li><li><p>服务调度：ECS 提供了服务调度功能，可以确保容器实例持续运行和可用。服务定义了要运行的任务数量、负载均衡设置和健康检查规则等。ECS 会自动监视容器实例的健康状态，并根据需要启动、停止或替换容器实例，以保持服务的可用性。</p></li><li><p>与其他 AWS 服务集成：ECS 与其他 AWS 服务集成紧密，例如 Elastic Load Balancing、Amazon VPC、AWS IAM 和 AWS CloudFormation 等。这使得用户可以轻松地将 ECS 与其他服务结合使用，构建完整的应用程序架构。</p></li><li><p>支持 Fargate：ECS 提供了 Fargate 托管模式，允许用户无需管理 EC2 实例即可运行容器。Fargate 提供了一种无服务器的容器执行环境，用户只需定义任务和服务，而无需关心底层基础设施。</p></li></ol><p>通过使用 ECS，用户可以轻松地部署、运行和扩展容器化应用程序。ECS 提供了容器编排、弹性扩展、服务调度和与其他 AWS 服务的集成等功能，使用户能够以高效和可靠的方式管理容器化应用程序，并实现弹性和可伸缩的部署。</p><h3 id="AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景："><a href="#AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景：" class="headerlink" title="AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景："></a>AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景：</h3><ol><li><p>**Amazon Simple Storage Service (S3)**：</p><ul><li>特点：高度可扩展的对象存储服务，提供99.999999999%的持久性，支持存储任意大小的数据。</li><li>应用场景：适用于存储网站内容、备份、归档、大数据分析等。</li></ul></li><li><p>**Amazon Elastic Block Store (EBS)**：</p><ul><li>特点：为EC2实例提供块级存储卷，支持频繁的读写操作，可实现持久存储。</li><li>应用场景：适合于需要持久、低延迟存储的场景，如数据库、文件系统等。</li></ul></li><li><p>**Amazon Elastic File System (EFS)**：</p><ul><li>特点：提供简单、可扩展的文件存储服务，可同时供多个EC2实例访问。</li><li>应用场景：适用于需要共享文件存储的应用，如内容管理、数据共享等。</li></ul></li><li><p><strong>Amazon Glacier</strong>：</p><ul><li>特点：低成本的长期备份和归档服务，检索时间可能从几分钟到几小时不等。</li><li>应用场景：适合长期数据归档，如法规遵从、数字保存等。</li></ul></li><li><p><strong>AWS Storage Gateway</strong>：</p><ul><li>特点：连接本地环境与AWS云存储的混合存储服务，支持文件、块及磁带数据。</li><li>应用场景：适用于需要将本地存储环境与云端集成的场景。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>：</p><ul><li>特点：快速、可扩展的NoSQL数据库服务，支持键值和文档数据模型。</li><li>应用场景：适用于需要高性能、灵活的数据库解决方案的应用，如移动应用、Web应用等。</li></ul></li><li><p>**Amazon Relational Database Service (RDS)**：</p><ul><li>特点：简化的关系数据库服务，支持包括MySQL、PostgreSQL、Oracle等在内的多种数据库引擎。</li><li>应用场景：适用于需要传统关系数据库的应用，如企业应用、ERP系统等。</li></ul></li></ol><p>每种服务都有其优势和局限性，选择合适的存储服务需要根据具体的应用需求、成本考虑以及性能要求来决定。</p><h3 id="AWS-Key-Management-Service（KMS）"><a href="#AWS-Key-Management-Service（KMS）" class="headerlink" title="AWS Key Management Service（KMS）"></a>AWS Key Management Service（KMS）</h3><p>是亚马逊网络服务（AWS）提供的一种托管密钥管理服务，用于创建和控制加密密钥，以保护数据的安全性。KMS 可以帮助用户轻松地生成、存储、使用和管理加密密钥，以加密和解密数据，并确保数据在存储和传输过程中的保密性。</p><p>以下是 AWS Key Management Service 的一些关键特点和功能：</p><ol><li><p>密钥生成和管理：KMS 提供了简单的 API 和控制台界面，用于生成和管理加密密钥。用户可以创建自己的主密钥（Customer Master Key，CMK）或使用 AWS 托管的主密钥。KMS 还提供了密钥轮换、禁用和删除等功能，以确保密钥的安全性和可管理性。</p></li><li><p>数据加密和解密：KMS 可以用于加密和解密数据。用户可以使用 KMS 提供的 API 或 AWS SDK 来对数据进行加密，然后在需要时使用相同的密钥进行解密。KMS 支持多种加密算法和模式，包括对称密钥加密和非对称密钥加密。</p></li><li><p>密钥策略和访问控制：KMS 允许用户定义密钥策略来控制谁可以使用密钥进行加密和解密操作。用户可以为每个密钥指定访问权限，并使用 AWS Identity and Access Management（IAM）来管理和控制对密钥的访问。</p></li><li><p>审计和监控：KMS 提供了审计日志和监控功能，用于跟踪密钥的使用情况和操作历史。用户可以通过 AWS CloudTrail 来获取密钥的操作日志，并使用 AWS CloudWatch 来监控密钥的使用情况和性能。</p></li><li><p>集成和扩展性：KMS 可以与其他 AWS 服务和应用程序集成，以提供端到端的数据加密解决方案。例如，可以将 KMS 与 Amazon S3、Amazon EBS、Amazon RDS 等服务结合使用，以实现对数据的加密保护。</p></li></ol><p>通过使用 AWS Key Management Service，用户可以轻松地生成、存储和管理加密密钥，以保护数据的安全性。KMS 提供了密钥生成和管理、数据加密和解密、密钥策略和访问控制、审计和监控等功能，为用户提供了一种可靠和安全的密钥管理解决方案。</p><h3 id="Amazon-Kinesis-Data-Streams"><a href="#Amazon-Kinesis-Data-Streams" class="headerlink" title="Amazon Kinesis Data Streams"></a>Amazon Kinesis Data Streams</h3><p>是亚马逊网络服务（AWS）提供的一种实时数据流平台，用于收集、处理和分析大规模实时数据流。它能够处理和存储来自数千个数据源的大量数据，并使用户能够实时处理和分析这些数据，以获得有关数据的实时洞察。</p><p>以下是 Amazon Kinesis Data Streams 的一些关键特点和功能：</p><ol><li><p>数据收集：Kinesis Data Streams 可以接收来自各种数据源（如应用程序、传感器、日志文件等）的大规模实时数据流。数据以流的形式发送到 Kinesis Data Streams，并按照时间顺序进行排序和存储。</p></li><li><p>实时数据处理：Kinesis Data Streams 允许用户实时处理数据流。用户可以使用 AWS Lambda、Amazon Kinesis Data Analytics、自定义应用程序等方式对数据进行实时处理和转换。这使用户能够即时响应数据流中的事件和模式，并执行实时计算、过滤、聚合等操作。</p></li><li><p>数据持久化和存储：Kinesis Data Streams 提供持久化的数据存储，可以在一段时间内保留数据流中的数据。用户可以根据需要配置数据保留期限，并随时访问和检索存储的数据。</p></li><li><p>可伸缩性和高可用性：Kinesis Data Streams 具有高度可伸缩和高可用的特性。它可以处理大量的并发数据流，并自动分配和扩展资源以适应数据流的需求。此外，Kinesis Data Streams 在多个 AWS 区域内提供冗余和容错，以确保数据的持续可用性和可靠性。</p></li><li><p>数据安全和访问控制：Kinesis Data Streams 提供多层数据安全和访问控制机制。用户可以使用 AWS Identity and Access Management（IAM）来管理对数据流的访问权限，并使用数据加密和传输加密等功能来保护数据的安全性。</p></li><li><p>与其他 AWS 服务的集成：Kinesis Data Streams 可以与其他 AWS 服务集成，以构建端到端的实时数据处理和分析解决方案。例如，可以将 Kinesis Data Streams 与 Amazon Kinesis Data Firehose、Amazon Kinesis Data Analytics、Amazon S3、Amazon Redshift 等服务结合使用，实现数据的收集、处理、存储和分析。</p></li></ol><p>通过使用 Amazon Kinesis Data Streams，用户可以轻松地处理和分析大规模实时数据流。它提供了数据收集、实时数据处理、数据持久化和存储、可伸缩性和高可用性、数据安全和访问控制等功能，为用户构建实时数据处理和分析的强大平台。</p><h3 id="ENI代表Elastic-Network-Interface（弹性网络接口）"><a href="#ENI代表Elastic-Network-Interface（弹性网络接口）" class="headerlink" title="ENI代表Elastic Network Interface（弹性网络接口）"></a>ENI代表Elastic Network Interface（弹性网络接口）</h3><p>是亚马逊网络服务（AWS）提供的一种虚拟网络接口，用于连接Amazon Elastic Compute Cloud（EC2）实例与虚拟私有云（VPC）之间的网络。</p><p>每个EC2实例可以附加一个或多个ENI，每个ENI都有自己的私有IP地址、MAC地址和安全组。ENI可以用于实现高级网络配置和功能，例如创建多个网络接口、实现高可用性和负载均衡、实现虚拟专用网络（VPC）间的流量转发等。</p><p>以下是ENI的一些关键特点和功能：</p><ol><li><p>网络连接：ENI允许EC2实例连接到VPC中的子网，并通过子网的路由表与其他资源进行通信。每个ENI都有一个私有IP地址，可以用于内部通信和与其他资源交互。</p></li><li><p>多个IP地址：每个ENI可以分配一个或多个IP地址，这些地址可以是IPv4地址或IPv6地址。这使得EC2实例能够处理多个网络流量和服务。</p></li><li><p>安全组：每个ENI都可以与一个或多个安全组相关联，用于控制入站和出站的网络流量。安全组是一种虚拟防火墙，可以定义允许或拒绝的网络流量规则。</p></li><li><p>弹性IP地址：ENI可以与弹性IP地址（Elastic IP）相关联，使EC2实例的IP地址保持不变。这对于需要固定公网IP地址的应用程序或服务非常有用。</p></li><li><p>高可用性和负载均衡：通过将多个ENI附加到EC2实例上，可以实现高可用性和负载均衡。这样，即使一个ENI或实例发生故障，仍然可以继续提供服务。</p></li><li><p>虚拟专用网络（VPC）间的流量转发：ENI还可以用于在不同的VPC之间转发流量。这可以通过在两个VPC之间创建一个带有ENI的转发实例来实现。</p></li></ol><p>通过使用ENI，用户可以实现更灵活和高级的网络配置，以满足特定的应用程序需求。ENI提供了网络连接、多个IP地址、安全组、弹性IP地址、高可用性和负载均衡等功能，为用户提供了强大的网络管理和控制能力。</p><h3 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h3><p>代表Elastic IP（弹性IP），是亚马逊网络服务（AWS）提供的一种静态公网IP地址。Elastic IP地址是与AWS账户相关联的IP地址，可以动态地映射到用户的云资源（如EC2实例、NAT网关等），并保持不变，即使资源被停止、重新启动或迁移。</p><p>以下是Elastic IP的一些关键特点和功能：</p><ol><li><p>固定公网IP地址：Elastic IP提供了一个固定的公网IP地址，用户可以将其分配给EC2实例、NAT网关或其他支持公网访问的AWS资源。这使得用户可以通过固定的IP地址访问其云资源，而不受资源启动、停止或重新分配的影响。</p></li><li><p>弹性和可靠性：Elastic IP是弹性和可靠的，可以在需要时轻松地将其映射到不同的云资源。用户可以根据需要将Elastic IP从一个实例或资源解绑，并绑定到另一个实例或资源上，而无需更改与该IP地址相关联的应用程序或服务。</p></li><li><p>公网访问：通过将Elastic IP地址分配给EC2实例或其他支持公网访问的资源，用户可以通过公网访问这些资源。这对于需要对外提供服务或需要远程访问资源的应用程序非常有用。</p></li><li><p>网络地址转换（NAT）：Elastic IP还可以与网络地址转换（NAT）网关相关联，用于实现私有子网中EC2实例的出站互联网访问。NAT网关使用Elastic IP地址作为源IP地址，将私有子网中的流量转发到公网。</p></li><li><p>费用和配额：Elastic IP地址在使用期间会产生费用。AWS为每个账户提供了一定数量的免费Elastic IP地址配额，超出配额的部分将会收取费用。用户可以根据需要管理和分配Elastic IP地址。</p></li></ol><p>通过使用Elastic IP，用户可以获得固定的公网IP地址，并将其分配给需要公网访问的云资源。Elastic IP具有弹性和可靠性，可以轻松映射到不同的资源，同时还可以与NAT网关一起使用实现私有子网中的出站互联网访问。</p><h3 id="AWS-CloudTrail-和-Amazon-CloudWatch-都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别："><a href="#AWS-CloudTrail-和-Amazon-CloudWatch-都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别：" class="headerlink" title="AWS CloudTrail 和 Amazon CloudWatch 都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别："></a>AWS CloudTrail 和 Amazon CloudWatch 都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别：</h3><ol><li><p><strong>功能焦点</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：主要用于记录和监控AWS账户中的API调用和相关事件。CloudTrail提供了一个记录谁在何时对AWS资源执行了什么操作的详细历史。这些信息对于安全分析、资源变更追踪、和合规审计非常重要。</li><li><strong>Amazon CloudWatch</strong>：专注于监控AWS资源和应用程序的运行状况。CloudWatch可以收集和跟踪指标，设置和管理告警，自动反应系统的变化。它用于实时监控应用程序的性能和运行状况。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：用于安全和合规审计。例如，追踪特定用户在特定时间进行的操作，审计资源的配置历史和变更，或者检测不寻常的活动，以识别安全威胁。</li><li><strong>Amazon CloudWatch</strong>：用于性能监控和管理。例如，监控EC2实例的CPU和网络使用情况，设置基于特定阈值的警报（如内存使用率过高），或自动扩展资源以应对负载变化。</li></ul></li><li><p><strong>数据类型</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：主要记录API调用和相关事件的日志，包括调用者身份、调用时间、请求参数以及响应元素等。</li><li><strong>Amazon CloudWatch</strong>：主要收集指标数据，如CPU利用率、磁盘读写、网络流量等。同时，CloudWatch Logs可以收集、监控和存储日志文件。</li></ul></li><li><p><strong>数据保留</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：默认情况下，CloudTrail事件日志在S3中保留无限期，但是可以根据需要配置保留策略。</li><li><strong>Amazon CloudWatch</strong>：指标数据的默认保留期限不同（从3小时到15个月不等），而日志数据的保留期限是可以配置的，从永久保存到自动删除都可以。</li></ul></li></ol><p>总结来说，CloudTrail更偏向于安全和合规的日志记录，而CloudWatch则侧重于性能监控和实时数据分析。两者通常结合使用，以提供全面的资源监控和事件记录功能。</p><h3 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h3><p>Amazon Athena 是一种交互式查询服务，使您能够使用标准 SQL 轻松分析存储在 Amazon S3 中的数据。没有需设置复杂的数据仓库或管理基础设施。</p><h3 id="AWS-Data-Exchange"><a href="#AWS-Data-Exchange" class="headerlink" title="AWS Data Exchange"></a>AWS Data Exchange</h3><p>AWS Data Exchange 允许客户在 AWS 云中轻松查找、订阅和使用第三方数据。这种服务简化了数据许可和交换过程。</p><h3 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h3><p>AWS Data Pipeline 是一种云服务，用于自动化数据移动和转换过程。它可以帮助你轻松地将数据从一个地方移动和处理到另一个地方。</p><h3 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h3><p>Amazon EMR 是一种托管的群集平台，可处理大量数据集并运行大数据分析作业。它支持多种大数据框架，如 Apache Hadoop 和 Apache Spark。</p><h3 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h3><p>AWS Glue 是一种完全托管的提取、转换和加载（ETL）服务，用于准备和加载数据。它自动发现和分类数据，使得数据集成更加容易。</p><h3 id="Amazon-Kinesis"><a href="#Amazon-Kinesis" class="headerlink" title="Amazon Kinesis"></a>Amazon Kinesis</h3><p>Amazon Kinesis 使您能够在实时地收集、处理和分析视频和数据流。这对于实时应用程序和数据分析非常重要。</p><h3 id="AWS-Lake-Formation"><a href="#AWS-Lake-Formation" class="headerlink" title="AWS Lake Formation"></a>AWS Lake Formation</h3><p>AWS Lake Formation 是一种服务，用于建立、安全地管理和共享数据湖。它简化了数据湖的设置和管理。</p><h3 id="Amazon-Managed-Streaming-for-Apache-Kafka-Amazon-MSK"><a href="#Amazon-Managed-Streaming-for-Apache-Kafka-Amazon-MSK" class="headerlink" title="Amazon Managed Streaming for Apache Kafka (Amazon MSK)"></a>Amazon Managed Streaming for Apache Kafka (Amazon MSK)</h3><p>Amazon MSK 是一种完全托管的 Apache Kafka 服务，使您能够构建和运行应用程序，这些应用程序可处理来自多个数据源的流数据。</p><h3 id="Amazon-OpenSearch-Service"><a href="#Amazon-OpenSearch-Service" class="headerlink" title="Amazon OpenSearch Service"></a>Amazon OpenSearch Service</h3><p>Amazon OpenSearch Service（原名Amazon Elasticsearch Service）提供了在 AWS 上运行 OpenSearch（一种流行的开源搜索和分析引擎）的能力。</p><h3 id="Amazon-QuickSight"><a href="#Amazon-QuickSight" class="headerlink" title="Amazon QuickSight"></a>Amazon QuickSight</h3><p>Amazon QuickSight 是一种快速、易用的商业智能服务，用于从您的数据中构建可视化效果，并提供洞察力。</p><h3 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h3><p>Amazon Redshift 是一种快速、可扩展的数据仓库服务，使您能够分析所有数据使用标准 SQL 和现有的商业智能工具。</p><h3 id="应用程序集成"><a href="#应用程序集成" class="headerlink" title="应用程序集成"></a>应用程序集成</h3><h4 id="Amazon-AppFlow"><a href="#Amazon-AppFlow" class="headerlink" title="Amazon AppFlow"></a>Amazon AppFlow</h4><p>Amazon AppFlow 是一种集成服务，使您能够在 AWS 和 SaaS 应用程序（如 Salesforce、ServiceNow 和 Slack）之间轻松传输数据。</p><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><p>AWS AppSync 是一种完全托管的服务，用于开发 GraphQL API，实现应用程序数据的即时同步。</p><h4 id="Amazon-EventBridge"><a href="#Amazon-EventBridge" class="headerlink" title="Amazon EventBridge"></a>Amazon EventBridge</h4><p>Amazon EventBridge 是一种服务器事件总线服务，它使应用程序能够与来自 AWS 服务、自定义应用程序和 SaaS 应用程序的事件进行交互。</p><h4 id="Amazon-MQ"><a href="#Amazon-MQ" class="headerlink" title="Amazon MQ"></a>Amazon MQ</h4><p>Amazon MQ 是一种托管的消息代理服务，适用于 ActiveMQ 和 RabbitMQ，使您能夠建立通信系统，轻松地在应用程序之间发送和接收消息。</p><h4 id="Amazon-Simple-Notification-Service-Amazon-SNS"><a href="#Amazon-Simple-Notification-Service-Amazon-SNS" class="headerlink" title="Amazon Simple Notification Service (Amazon SNS)"></a>Amazon Simple Notification Service (Amazon SNS)</h4><p>Amazon SNS 是一种完全托管的发布/订阅消息通知服务，您可以用它来分离微服务、分布式系统和服务器。</p><h4 id="Amazon-Simple-Queue-Service-Amazon-SQS"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS)"></a>Amazon Simple Queue Service (Amazon SQS)</h4><p>Amazon SQS 提供了托管的消息队列服务，以便您可以通过解耦和扩展微服务、分布式系统和服务器应用程序来传输任何量的数据。</p><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><p>AWS Step Functions 是一种服务，用于在 AWS 上协调各种服务的组件。它使得创建和管理复杂工作流程变得容易。</p><h3 id="AWS-成本管理"><a href="#AWS-成本管理" class="headerlink" title="AWS 成本管理"></a>AWS 成本管理</h3><h4 id="AWS-Budgets"><a href="#AWS-Budgets" class="headerlink" title="AWS Budgets"></a>AWS Budgets</h4><p>AWS Budgets 允许您设置自定义的预算，以便跟踪您的成本和使用情况。</p><h4 id="AWS-成本和使用情况报告"><a href="#AWS-成本和使用情况报告" class="headerlink" title="AWS 成本和使用情况报告"></a>AWS 成本和使用情况报告</h4><p>这项服务提供了有关您的 AWS 成本</p><p>和使用情况的详细报告，帮助您更好地了解和管理 AWS 费用。</p><h4 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h4><p>AWS Cost Explorer 是一种分析工具，用于可视化和理解 AWS 花费和使用情况数据。</p><h4 id="Savings-Plans"><a href="#Savings-Plans" class="headerlink" title="Savings Plans"></a>Savings Plans</h4><p>Savings Plans 是一种灵活的定价模型，提供对特定 AWS 服务的显著折扣，换取一定时间内的使用承诺。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><p>AWS Batch 允许您运行大规模的批处理作业，自动地在 AWS 的云计算资源上。</p><h4 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h4><p>Amazon Elastic Compute Cloud (Amazon EC2) 提供了可伸缩的计算容量。这使您可以快速启动和管理虚拟服务器。</p><h4 id="Amazon-EC2-Auto-Scaling"><a href="#Amazon-EC2-Auto-Scaling" class="headerlink" title="Amazon EC2 Auto Scaling"></a>Amazon EC2 Auto Scaling</h4><p>Amazon EC2 Auto Scaling 帮助您确保具有正确数量的 Amazon EC2 实例来处理应用程序的负载。</p><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><p>AWS Elastic Beanstalk 是一种易于使用的服务，用于部署和扩展 Web 应用程序和服务。</p><h4 id="AWS-Outposts"><a href="#AWS-Outposts" class="headerlink" title="AWS Outposts"></a>AWS Outposts</h4><p>AWS Outposts 是一种完全托管的服务，将 AWS 基础设施、服务、API 和工具扩展到几乎任何数据中心、共同托管空间或本地设施。</p><h4 id="AWS-Serverless-Application-Repository"><a href="#AWS-Serverless-Application-Repository" class="headerlink" title="AWS Serverless Application Repository"></a>AWS Serverless Application Repository</h4><p>AWS Serverless Application Repository 是一种管理和部署无服务器应用程序的平台。</p><h4 id="VMware-Cloud-on-AWS"><a href="#VMware-Cloud-on-AWS" class="headerlink" title="VMware Cloud on AWS"></a>VMware Cloud on AWS</h4><p>VMware Cloud on AWS 是一个集成的云服务，使您能够在 AWS 云上运行基于 VMware 的环境。</p><h4 id="AWS-Wavelength"><a href="#AWS-Wavelength" class="headerlink" title="AWS Wavelength"></a>AWS Wavelength</h4><p>AWS Wavelength 将 AWS 服务扩展到移动和边缘设备，使开发人员能够构建提供超低延迟应用程序的应用程序。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="Amazon-ECS-Anywhere"><a href="#Amazon-ECS-Anywhere" class="headerlink" title="Amazon ECS Anywhere"></a>Amazon ECS Anywhere</h4><p>Amazon ECS Anywhere 允许您在任何基础设施上运行 Amazon ECS，包括您自己的数据中心。</p><h4 id="Amazon-EKS-Anywhere"><a href="#Amazon-EKS-Anywhere" class="headerlink" title="Amazon EKS Anywhere"></a>Amazon EKS Anywhere</h4><p>Amazon EKS Anywhere 提供了一种在您自己的基础设施上运行 Amazon EKS 的方式。</p><h4 id="Amazon-EKS-Distro"><a href="#Amazon-EKS-Distro" class="headerlink" title="Amazon EKS Distro"></a>Amazon EKS Distro</h4><p>Amazon EKS Distro 是一个 Kubernetes 分发版，您可以在任何环境中运行它，包括您自己的数据中心。</p><h4 id="Amazon-Elastic-Container-Registry-Amazon-ECR"><a href="#Amazon-Elastic-Container-Registry-Amazon-ECR" class="headerlink" title="Amazon Elastic Container Registry (Amazon ECR)"></a>Amazon Elastic Container Registry (Amazon ECR)</h4><p>Amazon ECR 是一种完全托管的 Docker 容器注册服务，使开发人员可以轻松存储、管理和部署 Docker 容器映像。</p><h4 id="Amazon-Elastic-Container-Service-Amazon-ECS"><a href="#Amazon-Elastic-Container-Service-Amazon-ECS" class="headerlink" title="Amazon Elastic Container Service (Amazon ECS)"></a>Amazon Elastic Container Service (Amazon ECS)</h4><p>Amazon ECS 是一种高度可扩展的、高性能的容器管理服务，支持 Docker 容器。</p><h4 id="Amazon-Elastic-Kubernetes-Service-Amazon-EKS"><a href="#Amazon-Elastic-Kubernetes-Service-Amazon-EKS" class="headerlink" title="Amazon Elastic Kubernetes Service (Amazon EKS)"></a>Amazon Elastic Kubernetes Service (Amazon EKS)</h4><p>Amazon EKS 是一种托管服务，使您可以在 AWS 上轻松运行 Kubernetes。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h4><p>Amazon Aurora 是一种兼容 MySQL 和 PostgreSQL 的关系数据库，它结合了商业数据库的性能和可用性以及开源数据库的成本效益。</p><h4 id="Amazon-Aurora-Serverless"><a href="#Amazon-Aurora-Serverless" class="headerlink" title="Amazon Aurora Serverless"></a>Amazon Aurora Serverless</h4><p>Amazon Aurora Serverless 是一种自动缩放的 Aurora 数据库版本，适用于不需要持续数据库连接的应用程序。</p><h4 id="Amazon-DocumentDB（兼容-MongoDB）"><a href="#Amazon-DocumentDB（兼容-MongoDB）" class="headerlink" title="Amazon DocumentDB（兼容 MongoDB）"></a>Amazon DocumentDB（兼容 MongoDB）</h4><p>Amazon DocumentDB 是一种文档数据库服务，与 MongoDB 兼容，为 JSON 数据提供持久性存储。</p><h4 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h4><p>Amazon DynamoDB 是一种快速和灵活的 NoSQL 数据库服务，适用于所有需要一致的、单毫秒级延迟的应用程序。</p><h4 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h4><p>Amazon ElastiCache 是一种缓存服务，支持 Redis 和 Memcached。它用于提升数据库和应用程序的性能。</p><h4 id="Amazon-Keyspaces（适用于-Apache-Cassandra）"><a href="#Amazon-Keyspaces（适用于-Apache-Cassandra）" class="headerlink" title="Amazon Keyspaces（适用于 Apache Cassandra）"></a>Amazon Keyspaces（适用于 Apache Cassandra）</h4><p>Amazon Keyspaces 是一种可扩展、高可用性和托管的 Apache Cassandra 兼容数据库服务。</p><p>!</p><p>ChatGPT</p><h2 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h2><p>Amazon Neptune 是一种完全托管的图数据库服务，专门设计用于存储和导航连接数据。它支持广泛的图查询语言，如Gremlin和SPARQL，使其适用于构建高效的关系网络应用程序，如社交网络、推荐引擎或知识图谱。</p><h2 id="Amazon-Quantum-Ledger-Database-Amazon-QLDB"><a href="#Amazon-Quantum-Ledger-Database-Amazon-QLDB" class="headerlink" title="Amazon Quantum Ledger Database (Amazon QLDB)"></a>Amazon Quantum Ledger Database (Amazon QLDB)</h2><p>Amazon QLDB 是一个完全托管的账本数据库，提供一个透明、可验证且不可篡改的交易日志记录功能。它旨在为需要记录和跟踪数据变更历史的应用程序提供高性能和易于使用的数据结构。</p><h2 id="Amazon-RDS"><a href="#Amazon-RDS" class="headerlink" title="Amazon RDS"></a>Amazon RDS</h2><p>Amazon RDS（Relational Database Service）是一个托管型SQL数据库服务，支持多种数据库引擎，如MySQL、PostgreSQL、Oracle和SQL Server。它简化了数据库设置、运维和扩展工作，同时提供高可用性和安全性。</p><h2 id="Amazon-Redshift-1"><a href="#Amazon-Redshift-1" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p>Amazon Redshift 是一种完全托管的、基于列的数据仓库服务，它允许用户通过SQL查询大规模数据集。它特别适合用于数据仓库和大数据分析任务。</p><h2 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h2><p>AWS X-Ray 是一种服务，帮助开发人员分析和调试在AWS环境中运行的应用程序。它提供了一个详细的视图，显示应用程序如何在分布式系统中执行，帮助识别和解决性能瓶颈和错误。</p><h2 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h2><p>AWS Amplify 是一套工具和服务，可帮助前端开发人员更快地构建全栈应用程序。它提供了一系列功能，包括认证、API、数据库和文件存储，以及与React、Angular、Vue和其他JavaScript框架的集成。</p><h2 id="Amazon-API-Gateway"><a href="#Amazon-API-Gateway" class="headerlink" title="Amazon API Gateway"></a>Amazon API Gateway</h2><p>Amazon API Gateway 是一项托管服务，使开发人员可以轻松地创建、发布、维护、监控和保护API。它处理所有的API托管任务，包括流量管理、授权和访问控制、监控以及API版本管理。</p><h2 id="AWS-Device-Farm"><a href="#AWS-Device-Farm" class="headerlink" title="AWS Device Farm"></a>AWS Device Farm</h2><p>AWS Device Farm 是一种应用测试服务，允许开发人员在多种真实设备上测试他们的Web和移动应用程序。它提供了一个云端平台，用于测试应用程序的功能性和性能，确保在多种设备和操作系统上都能正常运行。</p><h2 id="Amazon-Pinpoint"><a href="#Amazon-Pinpoint" class="headerlink" title="Amazon Pinpoint"></a>Amazon Pinpoint</h2><p>Amazon Pinpoint 是一种灵活的、用户参与服务，旨在帮助公司通过电子邮件、短信、推送通知等渠道有效地与客户沟通。它支持客户参与分析和营销活动的自动化。</p><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend"></a>Amazon Comprehend</h2><p>Amazon Comprehend 是一种基于自然语言处理（NLP）的服务，可以识别文本中的语言、提取关键短语、地点、人名、品牌、情绪等。它广泛用于文本分析和数据挖掘。</p><h2 id="Amazon-Forecast"><a href="#Amazon-Forecast" class="headerlink" title="Amazon Forecast"></a>Amazon Forecast</h2><p>Amazon Forecast 是一种基于机器学习的预测服务，它可以根据历史数据预测未来趋势。这种服务适用于库存规划、资源需求预测、金融市场分析等场景。</p><h2 id="Amazon-Fraud-Detector"><a href="#Amazon-Fraud-Detector" class="headerlink" title="Amazon Fraud Detector"></a>Amazon Fraud Detector</h2><p>Amazon Fraud Detector 是一种基于机器学习和大量欺诈数据集的服务，用于检测在线活动中的欺诈行为。它可以帮助企业识别潜在的欺诈交易和异常活动。</p><h2 id="Amazon-Kendra"><a href="#Amazon-Kendra" class="headerlink" title="Amazon Kendra"></a>Amazon Kendra</h2><p>Amazon Kendra 是一种高度精准的企业级搜索服务，使用机器学习提供更自然的搜索体验。它能够理解复杂的用户查询，提供高相关性的搜索结果。</p><h2 id="Amazon-Lex"><a href="#Amazon-Lex" class="headerlink" title="Amazon Lex"></a>Amazon Lex</h2><p>Amazon Lex 是一种服务，使开发人员能够构建能与用户自然交流的对话界面。它是构建聊天机器人的主要工具，可以集成到各种应用程序和服务中。</p><h2 id="Amazon-Polly"><a href="#Amazon-Polly" class="headerlink" title="Amazon Polly"></a>Amazon Polly</h2><p>Amazon Polly 是一种文本转语音服务，它使用高级深度学习技术将文本转换成自然听起来的语音。它支持多种语言和声音，适用于创建各种语音应用程序。</p><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p>Amazon Rekognition 是一种图像和视频分析服务，它使用机器学习模型识别图像和视频中的对象、场景、人脸等。它广泛用于媒体分析、安全监控等领域。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p>Amazon SageMaker 是一个全面的机器学习服务，它帮助数据科学家和开发人员快速构建、训练和部署机器学习模型。它提供了一系列工具来简化机器学习工作流程。</p><h2 id="Amazon-Textract"><a href="#Amazon-Textract" class="headerlink" title="Amazon Textract"></a>Amazon Textract</h2><p>Amazon Textract 是一种文档分析服务，它可以自动提取PDF、图像和扫描文档中的文本、表格和表单数据。它可以用于自动化文档处理任务。</p><h2 id="Amazon-Transcribe"><a href="#Amazon-Transcribe" class="headerlink" title="Amazon Transcribe"></a>Amazon Transcribe</h2><p>Amazon Transcribe 是一个自动语音识别服务，它可以将音频和视频文件中的语音转换为文本。它支持多种语言和方言，适用于生成字幕、转录会议记录等。</p><h2 id="Amazon-Translate"><a href="#Amazon-Translate" class="headerlink" title="Amazon Translate"></a>Amazon Translate</h2><p>Amazon Translate 是一种神经机器翻译服务，它提供快速、高质量的语言翻译。它支持多种语言，可以用于网站、应用程序和内容的本地化。</p><h2 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h2><p>AWS Auto Scaling 是一种服务，帮助您自动调整AWS资源的数量，以满足应用程序的需求。它可以根据预定的条件和指标自动增加或减少资源，确保性能和成本效率。</p><h2 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h2><p>AWS CloudFormation 是一种服务，使开发人员可以使用代码来定义和部署AWS资源。它可以自动化和简化资源管理，确保基础设施的一致性和重复性。</p><h2 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h2><p>AWS CloudTrail 是一项服务，用于记录AWS账户的API调用和相关事件。这些日志可以用于安全分析、资源变更追踪和合规性审计。</p><h2 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h2><p>是 Amazon Web Services（AWS）提供的一项监控服务，主要用于对在 AWS 上运行的应用程序和资源进行监控和管理。CloudWatch 提供了多种功能，使您能够收集和跟踪指标、收集和监控日志文件，以及设置警报。下面是 CloudWatch 的一些主要功能和应用：</p><p>指标收集与监控：CloudWatch 可以收集如 CPU 使用率、网络使用量、磁盘读写次数等各种指标。这些指标可用于监控 AWS 资源（如 EC2 实例、Amazon RDS 数据库实例等）的性能。</p><p>日志管理：CloudWatch Logs 服务允许您监控、存储和访问日志文件。您可以使用 CloudWatch Logs 来监控应用程序的日志，这对于诊断问题和维护应用程序运行状况非常有用。</p><p>警报：CloudWatch Alarms 可以让您在某个指标达到预设阈值时得到通知。警报可以用于实时监控应用程序和资源的状态，并在问题出现时及时做出响应。</p><p>自动化反应：结合 AWS 自动化工具（如 AWS Lambda 或 Auto Scaling），当特定指标达到某个值时，CloudWatch 可以触发自动化动作，例如启动或停止实例。</p><p>自定义指标与仪表板：您还可以发布自定义指标到 CloudWatch，并使用 CloudWatch Dashboards 创建可视化的数据面板，这有助于您更直观地理解和分析数据。</p><p>集成与扩展性：CloudWatch 与其他 AWS 服务紧密集成，例如 AWS Identity and Access Management (IAM)、Amazon S3、Amazon EC2 等，支持广泛的应用场景。</p><h2 id="AWS-Command-Line-Interface-AWS-CLI"><a href="#AWS-Command-Line-Interface-AWS-CLI" class="headerlink" title="AWS Command Line Interface (AWS CLI)"></a>AWS Command Line Interface (AWS CLI)</h2><p>AWS Command Line Interface (CLI) 是一个工具，允许开发人员通过命令行界面管理AWS服务。它提供了一种简便的方式来访问AWS的广泛服务。</p><h2 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h2><p>AWS Compute Optimizer 是一种工具，它使用机器学习来推荐适合您工作负载的AWS资源配置。它旨在优化性能和成本效率。</p><h2 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h2><p>AWS Config 是一种服务，用于评估、审计和评估AWS资源的配置。它可以帮助确保资源符合公司政策和合规性要求。</p><h2 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h2><p>AWS Control Tower 是一种管理服务，提供了一个中央仪表板来监控和管理多个AWS账户。它提供了一种简化的方式来建立和维护安全的、合规的多账户环境。</p><h2 id="AWS-Health-Dashboard"><a href="#AWS-Health-Dashboard" class="headerlink" title="AWS Health Dashboard"></a>AWS Health Dashboard</h2><p>AWS Health Dashboard 提供了有关 AWS 服务健康状况的实时信息。它提供了服务中断和维护事件的通知，帮助用户及时了解和应对潜在的服务影响。</p><h2 id="AWS-License-Manager"><a href="#AWS-License-Manager" class="headerlink" title="AWS License Manager"></a>AWS License Manager</h2><p>AWS License Manager 使用户能够管理软件许可证的使用情况。它有助于用户遵守许可证规定，避免超出许可证的约束，从而降低合规风险。</p><h2 id="Amazon-Managed-Grafana"><a href="#Amazon-Managed-Grafana" class="headerlink" title="Amazon Managed Grafana"></a>Amazon Managed Grafana</h2><p>Amazon Managed Grafana 是一种开源分析和可视化平台，由 AWS 管理。用户可以使用它来监控和分析其AWS环境中的数据。</p><h2 id="Amazon-Managed-Service-for-Prometheus"><a href="#Amazon-Managed-Service-for-Prometheus" class="headerlink" title="Amazon Managed Service for Prometheus"></a>Amazon Managed Service for Prometheus</h2><p>这是一种完全托管的服务，它兼容开源 Prometheus，用于监控和警报。它专门用于容器化和微服务架构的监控。</p><h2 id="AWS-管理控制台"><a href="#AWS-管理控制台" class="headerlink" title="AWS 管理控制台"></a>AWS 管理控制台</h2><p>AWS管理控制台是一个基于网页的界面，用于管理AWS账户和运行的服务。它提供了一个用户友好的界面，用于访问和管理AWS资源。</p><h2 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h2><p>AWS Organizations 允许用户以集中的方式管理和治理其多个AWS账户。它支持账户分组、策略设置和成本报告等功能。</p><h2 id="AWS-Proton"><a href="#AWS-Proton" class="headerlink" title="AWS Proton"></a>AWS Proton</h2><p>AWS Proton 是一种完全托管的应用交付服务，用于自动化和管理服务器和无服务器应用程序的部署。</p><h2 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h2><p>AWS Service Catalog 允许组织创建和管理可授权给用户使用的预定义的IT服务和产品目录。</p><h2 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h2><p>AWS Systems Manager 提供了一套集成工具，用于自动化和管理AWS环境。这包括资源配置、监控和自动化任务执行等。</p><h2 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h2><p>AWS Trusted Advisor 是一种在线工具，提供了对AWS环境的最佳实践建议。它涉及成本优化、性能、安全和容错能力。</p><h2 id="AWS-Well-Architected-Tool"><a href="#AWS-Well-Architected-Tool" class="headerlink" title="AWS Well-Architected Tool"></a>AWS Well-Architected Tool</h2><p>这是一种帮助用户检查其AWS工作负载是否符合最佳实践的工具。它提供了指导和建议，以优化工作负载。</p><h2 id="媒体服务"><a href="#媒体服务" class="headerlink" title="媒体服务"></a>媒体服务</h2><h3 id="Amazon-Elastic-Transcoder"><a href="#Amazon-Elastic-Transcoder" class="headerlink" title="Amazon Elastic Transcoder"></a>Amazon Elastic Transcoder</h3><p>这是一种媒体转码服务，用于将音视频文件转换成不同的格式，以便在各种设备和平台上播放。</p><h3 id="Amazon-Kinesis-Video-Streams"><a href="#Amazon-Kinesis-Video-Streams" class="headerlink" title="Amazon Kinesis Video Streams"></a>Amazon Kinesis Video Streams</h3><p>该服务允许用户安全地将视频流连接到AWS用于分析和其他处理。</p><h2 id="迁移和传输"><a href="#迁移和传输" class="headerlink" title="迁移和传输"></a>迁移和传输</h2><h3 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h3><p>此服务帮助企业快速准确地了解其IT基础设施，以便更有效地规划迁移。</p><h3 id="AWS-Application-Migration-Service"><a href="#AWS-Application-Migration-Service" class="headerlink" title="AWS Application Migration Service"></a>AWS Application Migration Service</h3><p>这是一种自动化迁移服务，可简化应用程序的迁移过程，从而加速迁移和降低成本。</p><h3 id="AWS-Database-Migration-Service-AWS-DMS"><a href="#AWS-Database-Migration-Service-AWS-DMS" class="headerlink" title="AWS Database Migration Service (AWS DMS)"></a>AWS Database Migration Service (AWS DMS)</h3><p>AWS DMS 支持不同数据库之间的迁移，包括跨平台迁移，同时最小化停机时间。</p><h3 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h3><p>DataSync 是一个数据迁移工具，用于快速、安全地移动大量数据到和从AWS。</p><h3 id="AWS-Migration-Hub"><a href="#AWS-Migration-Hub" class="headerlink" title="AWS Migration Hub"></a>AWS Migration Hub</h3><p>AWS Migration Hub 提供了一个中心位置来跟踪和管理整个迁移过程。</p><h3 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h3><p>这包括一系列物理设备，用于大数据量的迁移，以及边缘计算和存储。</p><h3 id="AWS-Transfer-Family"><a href="#AWS-Transfer-Family" class="headerlink" title="AWS Transfer Family"></a>AWS Transfer Family</h3><p>提供安全、全面的文件传输服务，支持标准协议，如SFTP、FTPS和FTP。</p><h2 id="联网和内容分发"><a href="#联网和内容分发" class="headerlink" title="联网和内容分发"></a>联网和内容分发</h2><h3 id="AWS-Client-VPN"><a href="#AWS-Client-VPN" class="headerlink" title="AWS Client VPN"></a>AWS Client VPN</h3><p>这是一种托管的VPN服务，可为用户提供安全的远程访问。</p><h3 id="Amazon-CloudFront-1"><a href="#Amazon-CloudFront-1" class="headerlink" title="Amazon CloudFront"></a>Amazon CloudFront</h3><p>CloudFront 是一种全球内容分发网络(CDN)服务，它加速了网站和其他web内容的分发。</p><h3 id="AWS-Direct-Connect"><a href="#AWS-Direct-Connect" class="headerlink" title="AWS Direct Connect"></a>AWS Direct Connect</h3><p>通过 Direct Connect，用户可以在AWS和自己的数据中心之间建立私有网络连接。</p><h3 id="弹性负载均衡（ELB）"><a href="#弹性负载均衡（ELB）" class="headerlink" title="弹性负载均衡（ELB）"></a>弹性负载均衡（ELB）</h3><p>ELB 自动分发进入的应用程序流量，提高应用的可用性和容错能力。</p><h3 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h3><p>这是一种服务，可以提高用户向全球用户提供应用程序的性能。</p><h3 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h3><p>PrivateLink 提供了一种安全的连接方式，将AWS服务和VPC、本地网络连接起来。</p><h3 id="Amazon-Route-53"><a href="#Amazon-Route-53" class="headerlink" title="Amazon Route 53"></a>Amazon Route 53</h3><p>这是一种可扩展的云DNS服务，用于域名解析和路由互联网流量。</p><h3 id="AWS-Site-to-Site-VPN"><a href="#AWS-Site-to-Site-VPN" class="headerlink" title="AWS Site-to-Site VPN"></a>AWS Site-to-Site VPN</h3><p>通过 Site-to-Site VPN，用户可以将本地网络安全地连接到AWS VPC。</p><h3 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h3><p>Transit Gateway 简化了网络架构，允许不同的VPC和本地网络通过单一网关连接。</p><h3 id="Amazon-VPC"><a href="#Amazon-VPC" class="headerlink" title="Amazon VPC"></a>Amazon VPC</h3><p>Amazon VPC 允许用户在AWS云中启动AWS资源，提供了可控的网络环境。</p><h2 id="安全性、身份与合规性"><a href="#安全性、身份与合规性" class="headerlink" title="安全性、身份与合规性"></a>安全性、身份与合规性</h2><h3 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h3><p>这是一个资源门户，提供有关AWS合规性和安全性文档的访问。</p><h3 id="AWS-Audit-Manager"><a href="#AWS-Audit-Manager" class="headerlink" title="AWS Audit Manager"></a>AWS Audit Manager</h3><p>Audit Manager 帮助用户自动化合规性审计过程，简化了审计工作。</p><h3 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h3><p>ACM 用于轻松创建、管理和部署SSL/TLS证书，保障网站和应用的安全。</p><h3 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h3><p>CloudHSM 提供了硬件安全模块(HSM)设备，以增强数据加密和密钥管理的安全性。</p><h3 id="Amazon-Cognito"><a href="#Amazon-Cognito" class="headerlink" title="Amazon Cognito"></a>Amazon Cognito</h3><p>Cognito 提供用户身份和数据同步服务，支持移动和网络应用程序的用户认证。</p><h3 id="Amazon-Detective"><a href="#Amazon-Detective" class="headerlink" title="Amazon Detective"></a>Amazon Detective</h3><p>Amazon Detective 是一种分析服务，用于调查和识别安全问题和可疑活动。</p><h3 id="AWS-Directory-Service"><a href="#AWS-Directory-Service" class="headerlink" title="AWS Directory Service"></a>AWS Directory Service</h3><p>这个服务为AWS资源提供了Microsoft Active Directory (AD)的实现。</p><h3 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h3><p>Firewall Manager 简化了AWS账户内防火墙规则的管理和维护。</p><h3 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h3><p>GuardDuty 是一种智能威胁检测服务，保护AWS账户和工作负载免受恶意活动。</p><h3 id="AWS-IAM-Identity-Center-AWS-Single-Sign-On"><a href="#AWS-IAM-Identity-Center-AWS-Single-Sign-On" class="headerlink" title="AWS IAM Identity Center (AWS Single Sign-On)"></a>AWS IAM Identity Center (AWS Single Sign-On)</h3><p>提供单点登录(SSO)服务，使用户可以方便地访问AWS和第三方应用程序。</p><h3 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h3><p>IAM 允许用户管理对AWS服务和资源的访问权限。</p><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><p>Inspector 是一种自动化安全评估服务，帮助改善应用程序的安全性和合规性。</p><h3 id="AWS-Key-Management-Service-AWS-KMS"><a href="#AWS-Key-Management-Service-AWS-KMS" class="headerlink" title="AWS Key Management Service (AWS KMS)"></a>AWS Key Management Service (AWS KMS)</h3><p>KMS 提供了创建和控制加密密钥的能力，用于加密数据。</p><h3 id="Amazon-Macie"><a href="#Amazon-Macie" class="headerlink" title="Amazon Macie"></a>Amazon Macie</h3><p>Macie 使用机器学习和模式匹配来识别和保护敏感数据。</p><h3 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h3><p>这是一种防火墙服务，用于保护VPC网络。</p><h3 id="AWS-Resource-Access-Manager-AWS-RAM"><a href="#AWS-Resource-Access-Manager-AWS-RAM" class="headerlink" title="AWS Resource Access Manager (AWS RAM)"></a>AWS Resource Access Manager (AWS RAM)</h3><p>RAM 允许用户共享AWS资源，实现跨账户资源共享。</p><h3 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h3><p>Secrets Manager 用于管理、检索和轮换数据库凭证、API密钥和其他机密。</p><h3 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h3><p>Security Hub 提供了一个集中的安全和合规性视图，跨多个AWS服务聚合安全性数据。</p><h3 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h3><p>Shield 是一种DDoS保护服务，保护AWS资源免受DDoS攻击。</p><h3 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h3><p>AWS WAF (Web Application Firewall) 是一种帮助保护 Web 应用程序或 API 免受网络攻击的服务。它可以过滤、监控和控制传入和传出的 HTTP(S) 流量。AWS WAF 提供了自定义的规则集，可以用来阻止常见的网络攻击，如 SQL 注入和跨站脚本 (XSS)。</p><h3 id="无服务器服务"><a href="#无服务器服务" class="headerlink" title="无服务器服务"></a>无服务器服务</h3><h4 id="AWS-AppSync-1"><a href="#AWS-AppSync-1" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><p>AWS AppSync 是一种托管的 GraphQL 服务，用于构建 API，使应用程序能够安全地访问、操纵和组合来自一个或多个数据源的数据。它支持实时数据同步和离线数据访问，适用于构建复杂的数据驱动应用程序。</p><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><p>AWS Fargate 是一种无服务器计算引擎，用于 Amazon ECS 和 EKS，让用户无需管理服务器即可运行容器。Fargate 自动管理容器的扩展和基础设施，使得容器化应用程序的部署和管理更加简便。</p><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><p>AWS Lambda 是一种事件驱动的计算服务，可运行代码以响应事件并自动管理计算资源。Lambda 可以用于构建各种应用程序和后端服务，只需上传代码，Lambda 即可为其分配资源并运行。</p><h3 id="存储服务"><a href="#存储服务" class="headerlink" title="存储服务"></a>存储服务</h3><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><p>AWS Backup 是一种集中式备份服务，可用于跨 AWS 服务备份数据。它提供了自动化的解决方案，用于备份 AWS 云中的数据，以及跨多个服务的备份管理和监控。</p><h4 id="Amazon-Elastic-Block-Store-Amazon-EBS"><a href="#Amazon-Elastic-Block-Store-Amazon-EBS" class="headerlink" title="Amazon Elastic Block Store (Amazon EBS)"></a>Amazon Elastic Block Store (Amazon EBS)</h4><p>Amazon EBS 提供高性能块存储，适用于 Amazon EC2 实例。EBS 卷用于持久存储，适用于数据库、文件系统等场景，提供高吞吐量和低延迟。</p><h4 id="Amazon-Elastic-File-System-Amazon-EFS"><a href="#Amazon-Elastic-File-System-Amazon-EFS" class="headerlink" title="Amazon Elastic File System (Amazon EFS)"></a>Amazon Elastic File System (Amazon EFS)</h4><p>Amazon EFS 提供了一种简单、可扩展的文件存储，适用于 Linux-based 的 Amazon EC2 实例。EFS 可以用于多种应用程序，支持高并发和高吞吐量。</p><h4 id="Amazon-FSx"><a href="#Amazon-FSx" class="headerlink" title="Amazon FSx"></a>Amazon FSx</h4><p>Amazon FSx 提供了多种完全托管的文件系统选项，包括适用于 Windows 文件服务器和 Lustre。FSx 为特定的工作负载和应用程序提供了优化的文件存储。</p><h4 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h4><p>Amazon S3 (Simple Storage Service) 是一种对象存储服务，提供了高度可扩展、持久、安全和低成本的存储解决方案。它广泛用于数据备份、存档、大数据分析等。</p><h4 id="Amazon-S3-Glacier"><a href="#Amazon-S3-Glacier" class="headerlink" title="Amazon S3 Glacier"></a>Amazon S3 Glacier</h4><p>Amazon S3 Glacier 是一种低成本的存储服务，用于数据归档和长期备份。提供了高耐久性的存储，但访问时间较长，适合不经常访问的数据。</p><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><p>是一种混合云存储服务，它允许您在本地环境和 AWS 云之间无缝地连接。这项服务主要用于数据备份、存档、灾难恢复和移动数据到 AWS 云。它支持三种不同类型的网关：文件网关、卷网关和磁带网关，每种都有其特定的用途。</p><ol><li><strong>文件网关</strong>：允许您将文件存储在 Amazon S3 中，同时保持本地存储的访问方式。它支持 NFS 和 SMB 协议，适用于文件共享、数据湖和备份。</li><li><strong>卷网关</strong>：提供两种模式，存储卷和缓存卷。存储卷模式将您的数据存储在 AWS 云中，同时保留本地的一个副本。缓存卷模式则将您的主数据集保留在 AWS 云中，只缓存经常访问的数据。</li><li><strong>磁带网关</strong>：用于替代物理磁带基础设施，将磁带存储虚拟化。您可以使用它来备份数据并将其存储在 AWS 云中，同时保持与现有磁带备份应用程序的兼容性。</li></ol><p>AWS Storage Gateway 通过这些功能，帮助企业实现云存储的优势，同时减少对本地存储资源的需求。它的主要优点包括成本效率、灵活的存储选项、简化的数据管理和提高的数据安全性。</p><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>是一种用于确定各种用户或系统进程是否有权访问特定资源的方式。它是计算机安全和网络管理中常用的概念。ACL 通常用于文件系统、数据库、网络设备等，以控制对文件、目录、数据库记录、网络连接等的访问权限。</p><p>一个 ACL 包含一系列的访问控制条目（ACEs）。每个 ACE 指定了一个主体（可以是用户、用户组、或系统进程）和该主体对于特定对象的访问权限。这些权限可以包括读取、写入、执行等操作。</p><p>例如，在文件系统中，一个 ACL 可以指定某个用户可以读取一个文件，但不能修改它。在网络环境中，ACL 可以用来控制哪些IP地址可以访问网络中的特定设备。</p><p>ACL 的主要作用包括：</p><p>保护敏感数据：通过限制对敏感信息的访问，来保护数据的安全性和隐私。</p><p>最小权限原则：确保用户和进程只有完成其任务所必需的最小权限，以减少潜在的安全风险。</p><p>权限管理：提供一种灵活的方式来指定和管理不同用户和用户组对资源的访问权限。</p><p>审计和合规性：通过记录和监控对资源的访问尝试，帮助组织遵守法规要求，并进行安全审计。</p><p>不同的系统和应用可能会有不同的 ACL 实现方式，但它们的核心目的都是为了保护资源不被未授权访问，并确保资源的安全和完整性。</p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>practise for AWS SAA</title>
      <link href="/2023/12/24/saa%E9%A2%98%E5%BA%93/"/>
      <url>/2023/12/24/saa%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="AWS-Certified-Solutions-Architect-Associate"><a href="#AWS-Certified-Solutions-Architect-Associate" class="headerlink" title="AWS Certified Solutions Architect - Associate"></a>AWS Certified Solutions Architect - Associate</h1><h2 id="1-AWS-为确保数据安全而执行的操作流程是什么？"><a href="#1-AWS-为确保数据安全而执行的操作流程是什么？" class="headerlink" title="1. AWS 为确保数据安全而执行的操作流程是什么？"></a>1. AWS 为确保数据安全而执行的操作流程是什么？</h2><p><strong>A</strong>. AES-256 encryption of data stored on any shared storage device<br>.AES-256 加密存储在任何共享存储设备上的数据</p><p><strong>B</strong>. Decommissioning of storage devices using industry-standard practices<br>.使用行业标准做法停用存储设备</p><p><strong>C</strong>. Background virus scans of EBS volumes and EBS snapshots<br>.EBS 卷和 EBS 快照的后台病毒扫描</p><p><strong>D</strong>. Replication of data across multiple AWS Regions</p><p><strong>E</strong>. Secure wiping of EBS data when an EBS volume is un-mounted<br>.卸载 EBS 卷时安全擦除 EBS 数据</p><p>答案 ：B</p><ul><li>A:加密存储在任何共享存储设备上的数据是用户的责任。</li><li>C:AWS不会对用户实例执行病毒扫描</li><li>D:AWS不会跨区域复制数据，除非是由用户完成的。</li></ul><h2 id="客户有一个-Web-应用程序，该应用程序使用基于-Cookie-的会话来跟踪登录用户。它使用-Elastic-Load-Balancing-和-Auto-Scaling-部署在-AWS-上。当负载增加时，Auto-Scaling-会启动新实例，但其他实例上的负载不会减少-这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？"><a href="#客户有一个-Web-应用程序，该应用程序使用基于-Cookie-的会话来跟踪登录用户。它使用-Elastic-Load-Balancing-和-Auto-Scaling-部署在-AWS-上。当负载增加时，Auto-Scaling-会启动新实例，但其他实例上的负载不会减少-这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？" class="headerlink" title="客户有一个 Web 应用程序，该应用程序使用基于 Cookie 的会话来跟踪登录用户。它使用 Elastic Load Balancing 和 Auto Scaling 部署在 AWS 上。当负载增加时，Auto Scaling 会启动新实例，但其他实例上的负载不会减少;这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？"></a>客户有一个 Web 应用程序，该应用程序使用基于 Cookie 的会话来跟踪登录用户。它使用 Elastic Load Balancing 和 Auto Scaling 部署在 AWS 上。当负载增加时，Auto Scaling 会启动新实例，但其他实例上的负载不会减少;这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？</h2><p><strong>A</strong>. ELB DNS record’s TTL is set too high.<br>.ELB DNS 记录的 TTL 设置过高。</p><p><strong>B</strong>. The new instances are not being added to the ELB during the Auto Scaling cooldown period.<br>.在 Auto Scaling 冷却期间，不会将新实例添加到 ELB。</p><p><strong>C</strong>. The website uses the dynamic content feature of Amazon CloudFront which is keeping connections alive to the ELB.<br>.该网站使用 Amazon CloudFront 的动态内容功能，该功能使与 ELB 的连接保持活动状态。</p><p><strong>D</strong>. ELB is continuing to send requests with previously established sessions to the same backend instances rather than spreading them out to the new instances.<br>.ELB 将继续将具有先前建立的会话的请求发送到相同的后端实例，而不是将它们分散到新实例。</p><p>答案：正确答案是 D，因为 ELB 是有状态的，并且使用基于 cookie 的会话。因此，它可能会继续向以前建立的会话发送请求，因此现有用户的体验很差.选项 A 是错误的，因为 Elastic Load Balancing 在 DNS 记录上使用 60 秒的 TTL 设置，并且没有提到配置是什么，选项 B 是错误的，因为仍会添加实例以减少负载，并且只有在这些实例之后的新实例才会取决于冷却时间。选项 C 是错误的，因为 CloudFront 会根据 TTL 将流量路由回源服务器</p><h2 id="3-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？"><a href="#3-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？" class="headerlink" title="3.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？"></a>3.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？</h2><p><strong>A</strong>. AWS Glacier</p><p><strong>B</strong>. AWS Elastic Transcoder</p><p><strong>C</strong>. AWS Simple Notification Service<br>.AWS 简单通知服务</p><p><strong>D</strong>. AWS Simple Queue Service</p><p>正确答案是D，因为SQS可用于构建可扩展和解耦的软件。SQS 可用于存储消息，文件位于 S3 中并相应地进行处理和扩展，选项 A 是错误的，因为 Glacier 是一种存档存储解决方案，选项 B 是错误的，因为 Elastic Transcoder 是一种用于转码不同格式视频的托管服务，选项 C 是错误的，因为 SNS 是发布/订阅消息收发服务。</p><h2 id="4-在-EC2-实例上运行的应用程序处理存储在-Amazon-S3-上的敏感信息。该信息可通过-Internet-访问。安全团队担心与-Amazon-S3-的-Internet-连接存在安全风险。哪种解决方案可以解决安全问题？"><a href="#4-在-EC2-实例上运行的应用程序处理存储在-Amazon-S3-上的敏感信息。该信息可通过-Internet-访问。安全团队担心与-Amazon-S3-的-Internet-连接存在安全风险。哪种解决方案可以解决安全问题？" class="headerlink" title="4.在 EC2 实例上运行的应用程序处理存储在 Amazon S3 上的敏感信息。该信息可通过 Internet 访问。安全团队担心与 Amazon S3 的 Internet 连接存在安全风险。哪种解决方案可以解决安全问题？"></a>4.在 EC2 实例上运行的应用程序处理存储在 Amazon S3 上的敏感信息。该信息可通过 Internet 访问。安全团队担心与 Amazon S3 的 Internet 连接存在安全风险。哪种解决方案可以解决安全问题？</h2><p><strong>A</strong>. Access the data through an Internet Gateway.</p><p><strong>B</strong>. Access the data through a VPN connection.</p><p><strong>C</strong>. Access the data through a NAT Gateway.</p><p><strong>D</strong>. Access the data through a VPC endpoint for Amazon S3.<br>.通过 Amazon S3 的 VPC 终端节点访问数据。</p><p>正确答案是 D，因为 VPC 终端节点允许 EC2 实例在不通过 Internet 的情况下访问 S3，请参阅 AWS 文档 - VPC 终端节点，VPC 终端节点使您能够将 VPC 私下连接到受支持的 AWS 服务和由 PrivateLink 提供支持的 VPC 终端节点服务，而无需互联网网关、NAT 设备、VPN 连接或 AWS Direct Connect 连接。VPC 中的实例不需要公有 IP 地址即可与服务中的资源进行通信。您的 VPC 和其他服务之间的流量不会离开 Amazon 网络，终端节点是虚拟设备。它们是水平扩展、冗余且高度可用的 VPC 组件，允许 VPC 中的实例与服务之间进行通信，而不会对网络流量施加可用性风险或带宽限制，选项 A 和 C 是错误的，因为 NAT 网关和 Internet 网关通过 Internet 将流量路由到 Amazon S3 的公有终端节点，选项 B 是错误的，因为无法通过 VPN 连接到 Amazon S3。</p><h2 id="5-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？"><a href="#5-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？" class="headerlink" title="5.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？"></a>5.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？</h2><p><strong>A</strong>. Configure a lifecycle hook for your Auto Scaling group<br>.为您的 Auto Scaling 组配置生命周期挂钩</p><p><strong>B</strong>. Add a scaling-specific cooldown period to the scaling policy<br>.在扩展策略中添加特定于扩展的冷却期</p><p><strong>C</strong>. Adjust the CPU threshold that triggers a scaling action<br>.调整触发扩展操作的 CPU 阈值</p><p><strong>D</strong>. Attach a new launch configuration to the Auto Scaling group<br>.将新的启动配置附加到 Auto Scaling 组</p><p>正确答案是 B，因为您需要调整新添加实例的冷却时间以启动和处理流量，请参阅 AWS 文档 - Auto Scaling 冷却时间，Auto Scaling 冷却时间是 Auto Scaling 组的可配置设置，有助于确保 Auto Scaling 不会在之前的扩展活动生效之前启动或终止其他实例。在 Auto Scaling 组使用简单的扩展策略动态扩展后，Auto Scaling 会等待冷却期完成，然后再恢复扩展活动。当您手动扩展 Auto Scaling 组时，默认设置不等待冷却时间，但您可以覆盖默认值并遵守冷却时间。如果实例运行状况不佳，Auto Scaling 不会等待冷却时间结束，然后再替换运行状况不佳的实例。</p><h2 id="6-一家公司正在-AWS-上构建需要访问各种-AWS-服务的软件。应使用哪种配置来确保-AWS-凭证（即访问密钥-ID-秘密访问密钥组合）不会泄露？"><a href="#6-一家公司正在-AWS-上构建需要访问各种-AWS-服务的软件。应使用哪种配置来确保-AWS-凭证（即访问密钥-ID-秘密访问密钥组合）不会泄露？" class="headerlink" title="6.一家公司正在 AWS 上构建需要访问各种 AWS 服务的软件。应使用哪种配置来确保 AWS 凭证（即访问密钥 ID/秘密访问密钥组合）不会泄露？"></a>6.一家公司正在 AWS 上构建需要访问各种 AWS 服务的软件。应使用哪种配置来确保 AWS 凭证（即访问密钥 ID/秘密访问密钥组合）不会泄露？</h2><p><strong>A</strong>. Enable Multi-Factor Authentication for your AWS root account.<br>.为您的 AWS 根账户启用 Multi-Factor Authentication。</p><p><strong>B</strong>. Assign an IAM role to the Amazon EC2 instance<br>.将 IAM 角色分配给 Amazon EC2 实例</p><p><strong>C</strong>. Store the AWS Access Key ID/Secret Access Key combination in software comments.<br>.将 AWS 访问密钥 ID/秘密访问密钥组合存储在软件注释中。</p><p><strong>D</strong>. Assign an IAM user to the Amazon EC2 Instance.<br>.将 IAM 用户分配给 Amazon EC2 实例。</p><p>正确答案是 B，因为 EC2 实例可以使用 IAM 角色访问其他 AWS 服务，这有助于生成临时的短期凭证，请参阅 AWS 文档 - IAM 角色，IAM 角色类似于用户，因为它是具有权限策略的 AWS 身份，用于确定身份在 AWS 中可以做什么和不能做什么。但是，角色不是与一个人唯一关联，而是任何需要它的人都可以承担。此外，角色没有任何与之关联的凭据（密码或访问密钥）。相反，如果将用户分配给角色，则会动态创建访问密钥并提供给用户，选项 A 是错误的，因为 MFA 是启用双因素身份验证，选项 C 是错误的，因为不建议存储凭证，选项 D 是错误的，因为无法将 IAM 用户分配给 EC2 实例</p><h2 id="7-Web-应用程序允许客户将订单上传到-S3-存储桶。生成的-Amazon-S3-事件会触发一个-Lambda-函数，该函数将消息插入-SQS-队列。单个-EC2-实例从队列中读取消息，处理消息，并将其存储在按唯一订单-ID-分区的-DynamoDB-表中。下个月，流量预计将增加-10-倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？"><a href="#7-Web-应用程序允许客户将订单上传到-S3-存储桶。生成的-Amazon-S3-事件会触发一个-Lambda-函数，该函数将消息插入-SQS-队列。单个-EC2-实例从队列中读取消息，处理消息，并将其存储在按唯一订单-ID-分区的-DynamoDB-表中。下个月，流量预计将增加-10-倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？" class="headerlink" title="7.Web 应用程序允许客户将订单上传到 S3 存储桶。生成的 Amazon S3 事件会触发一个 Lambda 函数，该函数将消息插入 SQS 队列。单个 EC2 实例从队列中读取消息，处理消息，并将其存储在按唯一订单 ID 分区的 DynamoDB 表中。下个月，流量预计将增加 10 倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？"></a>7.Web 应用程序允许客户将订单上传到 S3 存储桶。生成的 Amazon S3 事件会触发一个 Lambda 函数，该函数将消息插入 SQS 队列。单个 EC2 实例从队列中读取消息，处理消息，并将其存储在按唯一订单 ID 分区的 DynamoDB 表中。下个月，流量预计将增加 10 倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？</h2><p><strong>A</strong>. Lambda function</p><p><strong>B</strong>. SQS queue</p><p><strong>C</strong>. EC2 instance</p><p><strong>D</strong>. DynamoDB table</p><p>正确答案是 C 作为单个 EC2 实例不可扩展，需要使用 Auto Scaling 改进架构以随着需求的变化而扩展或缩减，选项 B 和 D 是 AWS 托管服务，并根据配置和需求进行扩展，选项 A 是错误的，因为 Lambda 函数会根据传入的需求进行扩展。</p><h2 id="8-客户希望跟踪对其-Amazon-Simple-Storage-Service-（S3）-存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？"><a href="#8-客户希望跟踪对其-Amazon-Simple-Storage-Service-（S3）-存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？" class="headerlink" title="8.客户希望跟踪对其 Amazon Simple Storage Service （S3） 存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？"></a>8.客户希望跟踪对其 Amazon Simple Storage Service （S3） 存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？</h2><p><strong>A</strong>. Enable AWS CloudTrail to audit all Amazon S3 bucket access.<br>.启用 AWS CloudTrail 以审核所有 Amazon S3 存储桶访问。</p><p><strong>B</strong>. Enable server access logging for all required Amazon S3 buckets<br>.为所有必需的 Amazon S3 存储桶启用服务器访问日志记录</p><p><strong>C</strong>. Enable the Requester Pays option to track access via AWS Billing<br>.启用 Requester Pays （申请者付款） 选项以跟踪通过 AWS Billing 的访问</p><p><strong>D</strong>. Enable Amazon S3 event notifications for Put and Post.<br>.为 Put 和 Post 启用 Amazon S3 事件通知。</p><p>正确答案是 B，为了跟踪对存储桶的访问请求，您可以启用访问日志记录。每个访问日志记录都提供有关单个访问请求的详细信息，例如请求者、存储桶名称、请求时间、请求操作、响应状态和错误代码（如果有）。访问日志信息在安全和访问审计中很有用，请参阅 AWS 文档了解 S3 服务器日志，选项 A 是错误的，因为 CloudTrail 只会提供对 S3 的 API 调用信息，而不是单个访问信息，选项 C 是错误的，因为它仅在您希望用户为对象访问付费时帮助处理计费，选项 D 是错误的，因为事件通知未涵盖所有信息</p><h2 id="9-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"><a href="#9-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题" class="headerlink" title="9.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"></a>9.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题</h2><p><strong>A</strong>. Disable sticky sessions<br>.禁用粘性会话</p><p><strong>B</strong>. Reduce the frequency of the health checks<br>.降低运行状况检查的频率</p><p><strong>C</strong>. Enable cross zone load balancer<br>.启用跨区域负载均衡器</p><p><strong>D</strong>. Amazon recommends to use two availability zone behind ELB<br>.Amazon 建议在 ELB 后面使用两个可用区</p><p>正确答案是 A，因为粘性会话可能会导致用户被路由到相同的实例，选项 B 是错误的，因为降低运行状况检查的频率只会帮助确定实例是否健康。对于跨可用区的所有实例都是一样的，选项 C 是错误的，因为启用跨区域负载均衡器只会帮助在实例之间平均路由流量，而不是在可用区之间路由流量，这里似乎不是这种情况，选项 D 是错误的，因为 AWS 建议将实例分散到所有可用可用区以使应用程序高可用</p><h2 id="0-如何保护-EBS-卷上的静态数据？"><a href="#0-如何保护-EBS-卷上的静态数据？" class="headerlink" title="0.如何保护 EBS 卷上的静态数据？"></a>0.如何保护 EBS 卷上的静态数据？</h2><p><strong>A</strong>. Encrypt the volume using the S3 server-side encryption service<br>.使用 S3 服务器端加密服务加密卷</p><p><strong>B</strong>. Attach the volume to an instance using EC2’s SSL interface.<br>.使用 EC2 的 SSL 接口将卷附加到实例。</p><p><strong>C</strong>. Create an IAM policy that restricts read and write access to the volume.<br>.创建一个 IAM 策略，以限制对卷的读取和写入访问。</p><p><strong>D</strong>. Use EBS encryption</p><p><strong>E</strong>. Use an encrypted file system on top of the EBS volume<br>.在 EBS 卷上使用加密文件系统</p><p>正确答案是D，因为EBS加密可用于加密EBS卷，EBS加密是AWS在一段时间内推出的。在 EBS 加密之前，选项 E 是正确的答案，因为您需要在 EBS 卷上使用加密文件系统，直到今天，您还需要第三方安全工具来加密 EBS 卷的数据。借助 Amazon EBS 加密，您现在可以创建加密的 EBS 卷并将其附加到支持的实例类型。然后，卷上的数据、磁盘 I/O 和从卷创建的快照都将被加密。加密发生在托管 EC2 实例的服务器上，在数据在 EC2 实例和 EBS 存储之间移动时提供数据加密。EBS 加密基于行业标准的 AES-256 加密算法，选项 A 是错误的，因为 S3 - SSE 不适用于 EBS，选项 B 是错误的，因为 SSL 用于传输中的数据，选项 C 是错误的，因为 IAM 策略无法限制对 EC2 的读写访问。</p><h2 id="11-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"><a href="#11-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？" class="headerlink" title="11.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"></a>11.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？</h2><p><strong>A</strong>. A standalone Amazon EC2 instance</p><p><strong>B</strong>. Amazon RDS in a Multi-AZ configuration</p><p><strong>C</strong>. Amazon EC2 instances in a replication configuration utilizing a single Availability Zone<br>.使用单个可用区的复制配置中的 Amazon EC2 实例</p><p><strong>D</strong>. Amazon EC2 instances in a replication configuration utilizing two different Availability Zones<br>.使用两个不同可用区的复制配置中的 Amazon EC2 实例</p><p>这里的关键点是设计一个具有操作系统权限的 HA 解决方案数据库解决方案，正确答案是 D，因为 RDS 是 AWS 的托管服务，它不提供操作系统权限，并且对于 HA，至少需要在 2 个可用区中存在实例，选项 A 是错误的，因为单个实例不提供 HA，选项 B 是错误的，因为 RDS 不提供操作系统权限，选项 C 是错误的，因为单个可用区不提供 HA</p><h2 id="12-您有一个在-Amazon-Elastic-Compute-Cloud-实例上运行的应用程序，该应用程序将-5GB-的视频对象上传到-Amazon-Simple-Storage-Service-（S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？"><a href="#12-您有一个在-Amazon-Elastic-Compute-Cloud-实例上运行的应用程序，该应用程序将-5GB-的视频对象上传到-Amazon-Simple-Storage-Service-（S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？" class="headerlink" title="12.您有一个在 Amazon Elastic Compute Cloud 实例上运行的应用程序，该应用程序将 5GB 的视频对象上传到 Amazon Simple Storage Service （S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？"></a>12.您有一个在 Amazon Elastic Compute Cloud 实例上运行的应用程序，该应用程序将 5GB 的视频对象上传到 Amazon Simple Storage Service （S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？</h2><p><strong>A</strong>. Enable enhanced networking<br>.启用增强网络</p><p><strong>B</strong>. Use Amazon S3 multipart upload</p><p><strong>C</strong>. Leveraging Amazon CloudFront, use the HTTP POST method to reduce latency.<br>.利用 Amazon CloudFront，使用 HTTP POST 方法减少延迟。</p><p><strong>D</strong>. Use Amazon Elastic Block Store Provisioned IOPS and use an Amazon EBS-optimized instance<br>.使用 Amazon Elastic Block Store 预置 IOPS 并使用 Amazon EBS 优化实例</p><p>正确答案是 B，因为分段上传允许您将单个对象作为一组分段并行上传。每个部分都是对象数据的连续部分。您可以按任意顺序独立上传这些对象部分。如果任何部件的传输失败，您可以重新传输该部件，而不会影响其他部件。上传对象的所有部分后，Amazon S3 将组装这些部分并创建对象。一般来说，当您的对象大小达到 100 MB 时，您应该考虑使用分段上传，而不是在单个操作中上传对象，请参阅 AWS 文档了解 S3 分段上传，选项 A 和 D 是错误的，因为增强联网、IOPS、EBS 优化有助于提高 EC2 实例在 AWS 网络内的性能，选项 C 是错误的，因为 CloudFront 允许从全局位置上传对象更顺畅一些，但不会改善S3 上传时间</p><h2 id="13-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？"><a href="#13-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？" class="headerlink" title="13.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？"></a>13.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon DynamoDB</p><p>正确答案是 C，因为 EFS 是创建用户主目录的理想解决方案，并且可以跨组织的个人访问，并能够对其进行配置，请参阅 AWS EFS 常见问题和创建可写的每用户目录，问。Amazon EFS 适用于哪些使用案例？，Amazon EFS 旨在为各种工作负载和应用程序提供性能，包括大数据和分析、媒体处理工作流、内容管理、Web 服务和主目录。</p><h2 id="14-您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的-EC2-定价选项是什么？"><a href="#14-您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的-EC2-定价选项是什么？" class="headerlink" title="14.您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的 EC2 定价选项是什么？"></a>14.您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的 EC2 定价选项是什么？</h2><p><strong>A</strong>. On-Demand Instances</p><p><strong>B</strong>. Spot Instances + On-Demand Instances</p><p><strong>C</strong>. Reserved Instances (3 year contract)<br>.预留实例（3 年合同）</p><p><strong>D</strong>. Dedicated Instances</p><p>正确答案是 A，因为与 Spot 实例相比，按需实例将有助于预置额外的容量，并保证这些额外实例的可用性，请参阅 AWS 文档 - EC2 购买选项，选项 B 是错误的，因为 Spot 实例可能具有成本效益，但不能保证可用性，选项 C 是错误的，因为使用预留实例不具有成本效益，选项 D 是错误的，因为专用实例仅提供与其他客户端隔离的硬件，并且成本最高。</p><h2 id="15-一家公司正准备向开发人员提供-AWS-管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司-Active-Directory-中的组分配的。以下哪些组合将允许开发人员访问-AWS-控制台？选择-2-个答案"><a href="#15-一家公司正准备向开发人员提供-AWS-管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司-Active-Directory-中的组分配的。以下哪些组合将允许开发人员访问-AWS-控制台？选择-2-个答案" class="headerlink" title="15.一家公司正准备向开发人员提供 AWS 管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司 Active Directory 中的组分配的。以下哪些组合将允许开发人员访问 AWS 控制台？选择 2 个答案"></a>15.一家公司正准备向开发人员提供 AWS 管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司 Active Directory 中的组分配的。以下哪些组合将允许开发人员访问 AWS 控制台？选择 2 个答案</h2><p><strong>A</strong>. AWS Directory Service AD Connector<br>.AWS Directory Service AD 连接器</p><p><strong>B</strong>. AWS Directory Service Simple AD<br>.AWS Directory Service 简单 AD</p><p><strong>C</strong>. AWS Identity and Access Management groups<br>.AWS Identity and Access Management 组</p><p><strong>D</strong>. AWS Identity and Access Management roles<br>.AWS Identity and Access Management 角色</p><p><strong>E</strong>. AWS Identity and Access Management users<br>.AWS Identity and Access Management 用户</p><p>正确答案是 A 和 D，因为 AD 连接器需要连接到本地 Active Directory，IAM 角色可用于身份提供商和联合身份验证，请参阅 AWS 博客 - 如何使用 AD 连接器连接本地 Active Directory，AD Connector 是一个目录网关，您可以使用它将目录请求重定向到本地 Microsoft Active Directory，而无需在云中缓存任何信息，您的最终用户和 IT 管理员可以使用其现有的企业凭证登录 Amazon WorkSpaces、Amazon WorkDocs 或 Amazon WorkMail 等 AWS 应用程序，您可以通过对 AWS 管理控制台的基于 IAM 角色的访问来管理 Amazon EC2 实例或 Amazon S3 存储桶等 AWS 资源，选项 B 是错误的，因为 Simple AD 是独立的 AD 设置，不允许连接到本地 AD。选项C和E是错误的，因为用户和组不起作用。</p><h2 id="16-ABCD-公司最近在-AWS-上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB-表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？"><a href="#16-ABCD-公司最近在-AWS-上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB-表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？" class="headerlink" title="16.ABCD 公司最近在 AWS 上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB 表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？"></a>16.ABCD 公司最近在 AWS 上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB 表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？</h2><p><strong>A</strong>. Serialize the image and store it in multiple DynamoDB tables<br>.序列化映像并将其存储在多个 DynamoDB 表中</p><p><strong>B</strong>. Create an “Images” DynamoDB table to store the Image with a foreign key constraint to the “Product” table.<br>.创建一个 “Images” DynamoDB 表，以存储具有外键约束的 Image，以约束 “Product” 表。</p><p><strong>C</strong>. Add an image data type to the “Product” table to store the images in binary format<br>.将图像数据类型添加到“Product”表中，以二进制格式存储图像</p><p><strong>D</strong>. Store the images in Amazon S3 and add an S3 URL pointer to the “Product” table item for each image<br>.将图像存储在 Amazon S3 中，并为每个图像添加指向“Product”表项的 S3 URL 指针</p><p>因为 DynamoDB 不适合图像存储，图像应该存储在 S3 中，图像指针在 DynamoDB 中，请参阅 AWS 存储选项白皮书，选项 A 和 B 是错误的，因为 DynamoDB 不适合图像存储，选项 C 是错误的，因为没有图像数据类型</p><h2 id="17-一家公司正在使用区域顶点-（mycompany-com）-启动静态网站。该公司希望将-Amazon-Route-53-用于-DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）"><a href="#17-一家公司正在使用区域顶点-（mycompany-com）-启动静态网站。该公司希望将-Amazon-Route-53-用于-DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）" class="headerlink" title="17.一家公司正在使用区域顶点 （mycompany.com） 启动静态网站。该公司希望将 Amazon Route 53 用于 DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）"></a>17.一家公司正在使用区域顶点 （mycompany.com） 启动静态网站。该公司希望将 Amazon Route 53 用于 DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）</h2><p><strong>A</strong>. Host the website on an Amazon EC2 instance with ELB and Auto scaling and map a Route 53 alias record to the ELB endpoint.<br>.在具有 ELB 和 Auto Scaling 的 Amazon EC2 实例上托管网站，并将 Route 53 别名记录映射到 ELB 终端节点。</p><p><strong>B</strong>. Host the website using AWS Elastic Beanstalk and map a Route 53 alias record to the Beanstalk stack.<br>.使用 AWS Elastic Beanstalk 托管网站，并将 Route 53 别名记录映射到 Beanstalk 堆栈。</p><p><strong>C</strong>. Host the website on an Amazon EC2 instance and map a Route 53 alias record to the public IP address of the Amazon EC2 instance.<br>.在 Amazon EC2 实例上托管网站，并将 Route 53 别名记录映射到 Amazon EC2 实例的公有 IP 地址。</p><p><strong>D</strong>. Serve the website from an Amazon S3 bucket and map a Route 53 alias record to the website endpoint.<br>.从 Amazon S3 存储桶提供网站，并将 Route 53 别名记录映射到网站终端节点。</p><p><strong>E</strong>. Create a Route 53 hosted zone and set the NS records of the domain to use Route 53 name servers.<br>.创建 Route 53 托管区域并将域的 NS 记录设置为使用 Route 53 名称服务器。</p><p>正确答案是 D 和 E，因为静态网站可以托管在 S3 上，提供规模和具有成本效益的解决方案。可以在 Route 53 中创建具有托管区域的别名记录以将域指向 S3，请参阅 AWS 文档 - Route 53 路由到 S3 存储桶，Amazon Simple Storage Service （Amazon S3） 提供安全、持久、高度可扩展的云存储。您可以将 S3 存储桶配置为托管可包含网页和客户端脚本的静态网站。（S3 不支持服务器端脚本），要将域流量路由到 S3 存储桶，请使用 Amazon Route 53 创建指向存储桶的别名记录。别名记录是 Route 53 对 DNS 的扩展。它类似于 CNAME 记录，不同之处在于您可以为根域（如 example.com）和子域（如 <a href="http://www.example.com)创建别名记录.您只能为子域创建cname记录./">www.example.com）创建别名记录。您只能为子域创建CNAME记录。</a></p><h2 id="18-您正在构建一个由关系数据库支持的-Web-应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？"><a href="#18-您正在构建一个由关系数据库支持的-Web-应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？" class="headerlink" title="18.您正在构建一个由关系数据库支持的 Web 应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？"></a>18.您正在构建一个由关系数据库支持的 Web 应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？</h2><p><strong>A</strong>. Use ElastiCache to store critical pieces of data in memory for low-latency access.<br>.使用 ElastiCache 将关键数据片段存储在内存中，以实现低延迟访问。</p><p><strong>B</strong>. Use Amazon SQS to distribute messages among workers that are less busy<br>.使用 Amazon SQS 在不太繁忙的工作线程之间分发消息</p><p><strong>C</strong>. Use an Auto Scaling group and ELB Classic Load Balancer for the application tier.<br>.将 Auto Scaling 组和 ELB Classic Load Balancer 用于应用层。</p><p><strong>D</strong>. Use Data Pipeline to replicate your relational data across all of your web tier nodes<br>.使用 Data Pipeline 跨所有 Web 层节点复制关系数据</p><p>正确答案是 A，因为 ElastiCache 可以通过缓存结果来帮助提高性能，因为操作主要是读取密集型的，并且数据库查询将是计算密集型的，请参阅 AWS 存储选项白皮书，ElastiCache 通过在内存中存储关键数据片段来实现低延迟访问来提高应用程序性能。它经常用作读取密集型应用程序中的数据库前端，通过缓存 I/O 密集型查询的结果来提高性能并减少数据库的负载。它还经常用于管理 Web 会话数据、缓存动态生成的网页以及缓存计算密集型计算的结果，例如推荐引擎的输出。对于需要比字符串更复杂的数据结构的应用程序，例如列表、集合、哈希和排序集，Redis 引擎通常用作内存中 NoSQL 数据库。</p><h2 id="19-您正在设计一个将静态资产存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的-Web-应用程序。您希望此存储桶每秒立即接收超过-150-个-PUT-请求。您应该怎么做才能确保最佳性能？"><a href="#19-您正在设计一个将静态资产存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的-Web-应用程序。您希望此存储桶每秒立即接收超过-150-个-PUT-请求。您应该怎么做才能确保最佳性能？" class="headerlink" title="19.您正在设计一个将静态资产存储在 Amazon Simple Storage Service （S3） 存储桶中的 Web 应用程序。您希望此存储桶每秒立即接收超过 150 个 PUT 请求。您应该怎么做才能确保最佳性能？"></a>19.您正在设计一个将静态资产存储在 Amazon Simple Storage Service （S3） 存储桶中的 Web 应用程序。您希望此存储桶每秒立即接收超过 150 个 PUT 请求。您应该怎么做才能确保最佳性能？</h2><p><strong>A</strong>. Use multi-part upload.</p><p><strong>B</strong>. Add a random prefix to the key names</p><p><strong>C</strong>. Amazon S3 will automatically manage performance at this scale.<br>.Amazon S3 将自动管理此规模的性能。</p><p><strong>D</strong>. Use a predictable naming scheme, such as sequential numbers or date time sequences, in the key names<br>.在键名称中使用可预测的命名方案，例如序列号或日期时间序列</p><p>正确答案是 B，注意 - 大约 2018 年 7 月，根据最近的 AWS 公告，S3 性能发生了巨大变化，文档已更新，请参阅 AWS 文档 - S3 性能，为键名引入随机性的一种方法是添加哈希字符串作为键名的前缀。例如，您可以计算您计划分配为键名称的字符序列的 MD5 哈希值，选项 A 是错误的，因为分段上传仅有助于缩短对象上传时间，选项 C 是错误的，因为 Amazon S3 可以扩展以支持非常高的请求速率。但是，如果 Amazon S3 存储桶中的工作负载通常超过每秒 100 个 PUT/LIST/DELETE 请求或每秒超过 300 个 GET 请求，则建议实施最佳实践，选项 D 是错误的，因为使用可预测的命名方案会降低性能</p><h2 id="20-您正在运行一个包含以下内容的-2-层应用程序：一个-ELB、EC2-上的三个-Web-应用程序服务器和-1-个-MySQL-RDS-数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）"><a href="#20-您正在运行一个包含以下内容的-2-层应用程序：一个-ELB、EC2-上的三个-Web-应用程序服务器和-1-个-MySQL-RDS-数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）" class="headerlink" title="20.您正在运行一个包含以下内容的 2 层应用程序：一个 ELB、EC2 上的三个 Web 应用程序服务器和 1 个 MySQL RDS 数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）"></a>20.您正在运行一个包含以下内容的 2 层应用程序：一个 ELB、EC2 上的三个 Web 应用程序服务器和 1 个 MySQL RDS 数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）</h2><p><strong>A</strong>. Create an RDS read-replica and redirect half of the database read request to it<br>.创建一个 RDS 只读副本，并将一半的数据库读取请求重定向到该副本</p><p><strong>B</strong>. Cache database queries in amazon ElastiCache</p><p><strong>C</strong>. Setup RDS in multi-availability zone mode.<br>.在多可用区模式下设置 RDS。</p><p><strong>D</strong>. Shard the database and distribute loads between shards.<br>.对数据库进行分片，并在分片之间分配负载。</p><p><strong>E</strong>. Use amazon CloudFront to cache database queries.<br>.使用 Amazon CloudFront 缓存数据库查询。</p><p>正确答案是 A、B 和 D，因为主要问题是数据库性能下降，只读副本，ElastiCache 可以帮助提高读取性能，而分片可以帮助提高写入性能，选项 C 是错误的 RDS 多可用区更像是一种高可用性解决方案，选项 E 是错误的，因为 CloudFront 无法缓存数据库查询。</p><h2 id="21-您在特定区域中有一个-EC2-实例。此-EC2-实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？"><a href="#21-您在特定区域中有一个-EC2-实例。此-EC2-实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？" class="headerlink" title="21.您在特定区域中有一个 EC2 实例。此 EC2 实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？"></a>21.您在特定区域中有一个 EC2 实例。此 EC2 实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？</h2><p><strong>A</strong>. Create a duplicate EC2 Instance in another AZ. Keep it in the shutdown state. When required, bring it back up.<br>.在另一个可用区中创建重复的 EC2 实例。 使其保持关闭状态。需要时，将其恢复。</p><p><strong>B</strong>. Backup the EBS data volume. If the instance fails, bring up a new EC2 instance and attach the volume.<br>.备份 EBS 数据卷。如果实例失败，请启动新的 EC2 实例并附加卷。</p><p><strong>C</strong>. Store the EC2 data on S3. If the instance fails, bring up a new EC2 instance and restore the data from S3.<br>.将 EC2 数据存储在 S3 上。如果实例失败，请启动新的 EC2 实例并从 S3 还原数据。</p><p><strong>D</strong>. Create an AMI of the EC2 Instance and copy it to another region.<br>.创建 EC2 实例的 AMI 并将其复制到另一个区域。</p><p>正确答案是 D，因为 AMI 可以在安装软件的情况下创建，并且由于 AMI 是区域范围的，因此可以将它们复制到另一个区域以启动实例，请参阅 AWS 文档 - AMI 跨区域复制，跨地理位置不同的区域复制 AMI 具有以下好处：，选项 A 是错误的，因为它是 AZ 在区域发生故障时不提供 HA，，选项 B 是错误的，因为预配置的软件可能在根卷上有设置，并且需要跨区域复制快照才能重新创建卷，选项 C 是错误的，因为这是恢复故障实例的漫长且低效的方法。</p><h2 id="22-以下哪项最能描述什么是“堡垒主机”？"><a href="#22-以下哪项最能描述什么是“堡垒主机”？" class="headerlink" title="22.以下哪项最能描述什么是“堡垒主机”？"></a>22.以下哪项最能描述什么是“堡垒主机”？</h2><p><strong>A</strong>. Bastion hosts are instances that sit within your private subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with the bastion host, it then acts as a ‘jump’ server, allowing you to use SSH or RDP to log into other instances (within public subnets) deeper within your network.<br>.堡垒主机是位于私有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 SSH 或 RDP 登录网络更深处的其他实例（在公有子网内）。</p><p><strong>B</strong>. Bastion hosts are instances that sit within your private subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with the bastion host, it then acts as a ‘jump’ server, allowing you to use HTTPS to log into other instances (within public subnets) deeper within your network.<br>.堡垒主机是位于私有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 HTTPS 登录到网络更深处的其他实例（在公共子网内）。</p><p><strong>C</strong>. Bastion hosts are instances that sit within your public subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with the bastion host, it then acts as a ‘jump’ server, allowing you to use HTTPS to log into other instances (within private subnets) deeper within your network.<br>.堡垒主机是位于公有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 HTTPS 登录网络更深处的其他实例（在私有子网内）。</p><p><strong>D</strong>. Bastion hosts are instances that sit within your public subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with a bastion host, it then acts as a ‘jump’ server, allowing you to use SSH or RDP to log into other instances (within private subnets) deeper within your network.<br>.堡垒主机是位于公有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 SSH 或 RDP 登录网络更深处的其他实例（在私有子网内）。****</p><p>正确答案是 D，因为 Bastion 主机充当公共子网中的跳转服务器，以允许 SSH/RDP 访问私有子网中的实例，选项 A 和 B 是错误的，因为 Bastion 应该在公共子网中并且可以访问 Internet，选项 C 是错误的，因为 Bastion 只允许 SSH/RDP 而不是 HTTPS 连接。</p><h2 id="23-公司要求在遍历私有子网时记录所有-IP-数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？"><a href="#23-公司要求在遍历私有子网时记录所有-IP-数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？" class="headerlink" title="23.公司要求在遍历私有子网时记录所有 IP 数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？"></a>23.公司要求在遍历私有子网时记录所有 IP 数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？</h2><p><strong>A</strong>. Create VPC flow logs on the subnet<br>.在子网上创建 VPC 流日志</p><p><strong>B</strong>. Enable source destination check on private Amazon EC2 instances.<br>.在私有 Amazon EC2 实例上启用源目标检查。</p><p><strong>C</strong>. Enable AWS CloudTrail logging and specify an Amazon S3 bucket for storing log files.<br>.启用 AWS CloudTrail 日志记录并指定用于存储日志文件的 Amazon S3 存储桶。</p><p><strong>D</strong>. Create an Amazon CloudWatch logs to capture packet information.<br>.创建 Amazon CloudWatch 日志以捕获数据包信息。</p><p>正确答案是 A，因为只有 VPC 流允许您跟踪和捕获进出 VPC 内网络接口的所有信息，请参阅 AWS 文档 - VPC 流日志，VPC 流日志是一项功能，可让您捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据可以发布到 Amazon CloudWatch Logs 和 Amazon S3。创建流日志后，您可以在所选目标中检索和查看其数据，流日志可以帮助您完成许多任务;例如，排查特定流量未到达实例的原因，这反过来又可以帮助您诊断限制性过强的安全组规则。您还可以使用流日志作为安全工具来监控到达实例的流量，选项 B 是错误的，因为源/目标检查不跟踪数据包信息。默认情况下，每个 EC2 实例都会执行源/目标检查。这意味着实例必须是它发送或接收的任何流量的源或目标，选项 C 是错误的，因为 CloudTrail 是一项支持对您的 AWS 账户进行监管、合规性、操作审计和风险审计的服务。借助 CloudTrail，您可以记录、持续监控和保留与 AWS 基础设施中的操作相关的账户活动，选项 D 是错误的，因为 CloudWatch 不能用于跟踪数据包信息，而是一项监控和管理服务。</p><h2 id="24-一家公司正在将访问密钥（访问密钥-ID-和秘密访问密钥）存储在自定义-AMI-上的文本文件中。该公司使用访问密钥从从-AMI-创建的实例访问-DynamoDB-表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？"><a href="#24-一家公司正在将访问密钥（访问密钥-ID-和秘密访问密钥）存储在自定义-AMI-上的文本文件中。该公司使用访问密钥从从-AMI-创建的实例访问-DynamoDB-表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？" class="headerlink" title="24.一家公司正在将访问密钥（访问密钥 ID 和秘密访问密钥）存储在自定义 AMI 上的文本文件中。该公司使用访问密钥从从 AMI 创建的实例访问 DynamoDB 表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？"></a>24.一家公司正在将访问密钥（访问密钥 ID 和秘密访问密钥）存储在自定义 AMI 上的文本文件中。该公司使用访问密钥从从 AMI 创建的实例访问 DynamoDB 表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？</h2><p><strong>A</strong>. Put the access key in an S3 bucket and retrieve the access key on boot from the instance.<br>.将访问密钥放入 S3 存储桶中，并在启动时从实例中检索访问密钥。</p><p><strong>B</strong>. Pass the access key to the instances through instance user data.<br>.通过实例用户数据将访问密钥传递给实例。</p><p><strong>C</strong>. Obtain the access key from a key server launched in a private subnet.<br>.从私有子网中启动的密钥服务器获取访问密钥。</p><p><strong>D</strong>. Create an IAM role with permissions to access the table and launch all instances with the new role.<br>.创建一个有权访问表的 IAM 角色，并使用新角色启动所有实例。</p><p>正确答案是 D，因为 EC2 实例的 IAM 角色允许在实例上运行的应用程序访问 AWS 资源，而无需创建和存储任何访问密钥，请参阅 AWS 文档 - IAM 最佳实践，在 Amazon EC2 实例上运行的应用程序需要凭证才能访问其他 AWS 服务。要以安全的方式向应用程序提供凭证，请使用 IAM 角色。角色是具有自己的权限集的实体，但不是用户或组。角色也没有像 IAM 用户那样拥有自己的永久凭证集。对于 Amazon EC2，IAM 会动态地向 EC2 实例提供临时凭证，这些凭证会自动为您轮换，当您启动 EC2 实例时，您可以为该实例指定一个角色作为启动参数。在 EC2 实例上运行的应用程序在访问 AWS 资源时可以使用角色的凭证。角色的权限决定了允许应用程序执行的操作。</p><h2 id="25-一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的-Amazon-EC2-实例的前端队列。EC2-实例将投票推送到-RDBMS-数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？"><a href="#25-一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的-Amazon-EC2-实例的前端队列。EC2-实例将投票推送到-RDBMS-数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？" class="headerlink" title="25.一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的 Amazon EC2 实例的前端队列。EC2 实例将投票推送到 RDBMS 数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？"></a>25.一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的 Amazon EC2 实例的前端队列。EC2 实例将投票推送到 RDBMS 数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？</h2><p><strong>A</strong>. Each front-end node should send votes to an Amazon SQS queue. Provision worker instances to read the SQS queue and process message information into the RDBMS database.<br>.每个前端节点都应向 Amazon SQS 队列发送投票。预置工作线程实例以读取 SQS 队列并将消息信息处理到 RDBMS 数据库中。</p><p><strong>B</strong>. As the load on the database increases, horizontally-scale the RDBMS database with additional memory-optimized instances. When voting has ended, scale down the additional instances.<br>.随着数据库负载的增加，使用其他内存优化实例水平扩展 RDBMS 数据库。投票结束后，缩减其他实例。</p><p><strong>C</strong>. Re-provision the RDBMS database with larger, memory-optimized instances. When voting end, re-provision the back-end database with smaller instances.<br>.使用更大的内存优化实例重新预置 RDBMS 数据库。投票结束时，使用较小的实例重新预配后端数据库。</p><p><strong>D</strong>. Send votes from each front-end node to Amazon DynamoDB. Provision worker instances to process the votes in DynamoDB into the RDBMS database.<br>.将投票从每个前端节点发送到 Amazon DynamoDB。预置工作线程实例以将 DynamoDB 中的投票处理到 RDBMS 数据库中。</p><p>正确答案是 A，因为 SQS 可以帮助提供松耦合并充当数据库的缓冲区。此外，由于峰值是暂时的，因此无需扩展 RDBMS，选项 B 是错误的，因为 Auto Scaling 不适用于 RDBMS，选项 C 是错误的，因为 RDBMS 无法重新预置回较小的实例，选项 D 是错误的，因为 DynamoDB 将提供单独的重复持久性数据存储，这将更昂贵地输入、处理和删除数据。</p><h2 id="26-应用程序当前将大量记录写入一个区域中的-DynamoDB-表。辅助应用程序需要每-2-小时检索一次写入-DynamoDB-表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从-DynamoDB-表中获取相关更改的理想方法？"><a href="#26-应用程序当前将大量记录写入一个区域中的-DynamoDB-表。辅助应用程序需要每-2-小时检索一次写入-DynamoDB-表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从-DynamoDB-表中获取相关更改的理想方法？" class="headerlink" title="26.应用程序当前将大量记录写入一个区域中的 DynamoDB 表。辅助应用程序需要每 2 小时检索一次写入 DynamoDB 表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从 DynamoDB 表中获取相关更改的理想方法？"></a>26.应用程序当前将大量记录写入一个区域中的 DynamoDB 表。辅助应用程序需要每 2 小时检索一次写入 DynamoDB 表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从 DynamoDB 表中获取相关更改的理想方法？</h2><p><strong>A</strong>. Insert a timestamp for each record and then scan the entire table for the timestamp as per the last 2 hours.<br>.为每条记录插入时间戳，然后扫描整个表中过去 2 小时的时间戳。</p><p><strong>B</strong>. Create another DynamoDB table with the records modified in the last 2 hours.<br>.使用过去 2 小时内修改的记录创建另一个 DynamoDB 表。</p><p><strong>C</strong>. Use DynamoDB Streams to monitor the changes in the DynamoDB table.<br>.使用 DynamoDB 流 监控 DynamoDB 表中的更改。</p><p><strong>D</strong>. Transfer records to S3 which were modified in the last 2 hours.<br>.将在过去 2 小时内修改的记录传输到 S3。</p><p>正确答案是 C，因为 DynamoDB 流有助于监控 DynamoDB 表中的更改。第二个应用程序可以检查流中的更改，请参阅 AWS 文档 - DynamoDB Streams，DynamoDB Streams 支持诸如此类的解决方案以及许多其他解决方案。DynamoDB 流 在任何 DynamoDB 表中捕获按时间排序的项目级修改序列，并将此信息存储在日志中长达 24 小时。应用程序可以近乎实时地访问此日志并查看数据项目在修改之前和之后出现的情况，DynamoDB 流是有关 Amazon DynamoDB 表中项目更改的有序信息流。当您在表上启用流时，DynamoDB 会捕获有关对表中数据项的每次修改的信息，每当应用程序创建、更新或删除表中的项目时，DynamoDB 流都会写入一条流记录，其中包含已修改项目的主键属性。流记录包含有关对 DynamoDB 表中单个项目的数据修改的信息。您可以配置流，以便流记录捕获其他信息，例如已修改项目的“之前”和“之后”图像。</p><h2 id="27-客户希望将-Amazon-Simple-Storage-Service-（S3）-和-Amazon-Glacier-用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的-Amazon-S3-存储桶的访问？"><a href="#27-客户希望将-Amazon-Simple-Storage-Service-（S3）-和-Amazon-Glacier-用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的-Amazon-S3-存储桶的访问？" class="headerlink" title="27.客户希望将 Amazon Simple Storage Service （S3） 和 Amazon Glacier 用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的 Amazon S3 存储桶的访问？"></a>27.客户希望将 Amazon Simple Storage Service （S3） 和 Amazon Glacier 用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的 Amazon S3 存储桶的访问？</h2><p><strong>A</strong>. A custom bucket policy limited to the Amazon S3 API in the Amazon Glacier archive “company-backup”<br>.仅限于 Amazon Glacier 存档“company-backup”中的 Amazon S3 API 的自定义存储桶策略</p><p><strong>B</strong>. A custom bucket policy limited to the Amazon S3 API in “company-backup”<br>.仅限于“company-backup”中的 Amazon S3 API 的自定义存储桶策略</p><p><strong>C</strong>. A custom IAM user policy limited to the Amazon S3 API for the Amazon Glacier archive “company-backup”.<br>.仅限于 Amazon Glacier 存档“company-backup”的 Amazon S3 API 的自定义 IAM 用户策略。</p><p><strong>D</strong>. A custom IAM user policy limited to the Amazon S3 API in “company-backup”.<br>.仅限于“company-backup”中的 Amazon S3 API 的自定义 IAM 用户策略。</p><p>正确答案是 D，因为 IAM 策略可以授予 S3 并且配置了适当的生命周期规则以将数据存档到 Glacier，请参阅 S3 IAM 策略，选项 A 和 C 是错误的，因为它们的目标是 Glacier，选项 B 是错误的，因为存储桶策略需要（现有）委托人，用户策略需要（现有）用户/组/角色</p><h2 id="28-您的公司有一组-EC2-实例，用于访问存储在-S3-存储桶中的数据对象。您的-IT-安全部门关注此架构的安全性，并希望您实现以下措施：-1）-确保-EC2-实例安全地访问存储在-S3-存储桶中的数据对象-2）-防止意外删除对象-以下哪项有助于以经济高效的方式满足-IT-安全部门的要求？选择-2-个答案"><a href="#28-您的公司有一组-EC2-实例，用于访问存储在-S3-存储桶中的数据对象。您的-IT-安全部门关注此架构的安全性，并希望您实现以下措施：-1）-确保-EC2-实例安全地访问存储在-S3-存储桶中的数据对象-2）-防止意外删除对象-以下哪项有助于以经济高效的方式满足-IT-安全部门的要求？选择-2-个答案" class="headerlink" title="28.您的公司有一组 EC2 实例，用于访问存储在 S3 存储桶中的数据对象。您的 IT 安全部门关注此架构的安全性，并希望您实现以下措施： 1） 确保 EC2 实例安全地访问存储在 S3 存储桶中的数据对象 2） 防止意外删除对象 以下哪项有助于以经济高效的方式满足 IT 安全部门的要求？选择 2 个答案"></a>28.您的公司有一组 EC2 实例，用于访问存储在 S3 存储桶中的数据对象。您的 IT 安全部门关注此架构的安全性，并希望您实现以下措施： 1） 确保 EC2 实例安全地访问存储在 S3 存储桶中的数据对象 2） 防止意外删除对象 以下哪项有助于以经济高效的方式满足 IT 安全部门的要求？选择 2 个答案</h2><p><strong>A</strong>. Create an IAM user and ensure the EC2 Instances use the IAM user credentials to access the data in the bucket.<br>.创建 IAM 用户并确保 EC2 实例使用 IAM 用户凭证访问存储桶中的数据。</p><p><strong>B</strong>. Create an IAM Role and ensure the EC2 Instances use the IAM Role to access the data in the bucket.<br>.创建 IAM 角色并确保 EC2 实例使用 IAM 角色访问存储桶中的数据。</p><p><strong>C</strong>. Use S3 Cross-Region Replication to replicate the objects so that the integrity of data is maintained.<br>.使用 S3 跨区域复制复制对象，以保持数据的完整性。</p><p><strong>D</strong>. Use a S3 bucket policy that prevents accidental deletions<br>.使用防止意外删除的 S3 存储桶策略</p><p><strong>E</strong>. Configure S3 to use versioning and enable Multi-Factor Authentication (MFA) protected access<br>.将 S3 配置为使用版本控制并启用多重身份验证 （MFA） 保护访问</p><p>正确答案是 B &amp; E，请参阅 AWS 文档 - IAM 最佳实践和 S3 版本控制，S3 对象版本控制可防止您意外覆盖或删除对象，并为您提供检索对象先前版本的机会，在 Amazon EC2 实例上运行的应用程序需要凭证才能访问其他 AWS 服务。要以安全的方式向应用程序提供凭证，请使用 IAM 角色。角色是具有自己的权限集的实体，但不是用户或组。角色也没有像 IAM 用户那样拥有自己的永久凭证集。对于 Amazon EC2，IAM 会动态地向 EC2 实例提供临时凭证，这些凭证会自动为您轮换，选项 A 是错误的，因为使用 IAM 用户不安全且不是最佳实践，选项 C 是错误的，因为跨区域复制会创建重复对象，从而增加成本，并且它们不会阻止从两个区域删除。选项 D 是错误的，因为存储桶策略无法防止意外删除和恢复</p><h2 id="一家公司正计划使用-Docker-容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？"><a href="#一家公司正计划使用-Docker-容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？" class="headerlink" title="一家公司正计划使用 Docker 容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？"></a>一家公司正计划使用 Docker 容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？</h2><p><strong>A</strong>. Use Kubernetes for container orchestration and Reserved instances for all underlying instances.<br>.将 Kubernetes 用于容器编排，将预留实例用于所有底层实例。</p><p><strong>B</strong>. Use ECS orchestration and Reserved Instances for all underlying instances.<br>.将 ECS 编排和预留实例用于所有底层实例。</p><p><strong>C</strong>. Use Docker for container orchestration and a combination of Spot and Reserved Instances for the underlying instances.<br>.将 Docker 用于容器编排，并将 Spot 实例和预留实例组合用于底层实例。</p><p><strong>D</strong>. Use ECS for container orchestration and a combination of Spot and Reserved Instances for the underlying instances.<br>.将 ECS 用于容器编排，并将 Spot 实例和预留实例组合用于底层实例。</p><p>正确答案是 D，因为将预留实例用于长期关键批处理，将 Spot 实例用于非关键批处理要求具有成本效益。ECS 可用于容器编排和支持 Spot 实例，请参阅 AWS 文档 - ECS Spot 实例，选项 A 和 B 是错误的，因为它们仅使用预留实例不具有成本效益，选项 C 是错误的，因为 Docker 无法执行容器编排。</p><h2 id="30-公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？"><a href="#30-公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？" class="headerlink" title="30.公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？"></a>30.公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？</h2><p><strong>A</strong>. Store data in an EBS volume and create snapshots once a week.<br>.将数据存储在 EBS 卷中，并每周创建一次快照。</p><p><strong>B</strong>. Store data in an S3 bucket and enable versioning.<br>.将数据存储在 S3 存储桶中并启用版本控制。</p><p><strong>C</strong>. Store data in two S3 buckets in different AWS regions.<br>.将数据存储在不同 AWS 区域的两个 S3 存储桶中。</p><p><strong>D</strong>. Store data on EC2 instance storage.</p><p>正确答案是 B，因为对象版本控制有助于在意外删除或覆盖的情况下恢复对象，请参阅 AWS 文档 - S3 版本控制，启用版本控制的存储桶使您能够从意外删除或覆盖中恢复对象。例如：</p><h2 id="31-一家公司正计划在-AWS-的-EC2-实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关-IT-管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？"><a href="#31-一家公司正计划在-AWS-的-EC2-实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关-IT-管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？" class="headerlink" title="31.一家公司正计划在 AWS 的 EC2 实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关 IT 管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？"></a>31.一家公司正计划在 AWS 的 EC2 实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关 IT 管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？</h2><p><strong>A</strong>. Add tags to the instances marking each environment and then segregate access using IAM Policies.<br>.向标记每个环境的实例添加标签，然后使用 IAM 策略隔离访问。</p><p><strong>B</strong>. Add Userdata to the underlying instances to mark each environment.<br>.将用户数据添加到基础实例以标记每个环境。</p><p><strong>C</strong>. Add Metadata to the underlying instances to mark each environment.<br>.将元数据添加到基础实例以标记每个环境。</p><p><strong>D</strong>. Add each environment to a separate Auto Scaling Group.<br>.将每个环境添加到单独的 Auto Scaling 组。</p><p>正确答案是A，因为使用IAM策略对资源的标签可以帮助对属于不同环境的资源进行访问控制，请参阅AWS文档-标签，标签是您分配给AWS资源的标签。每个标签都由一个键和一个可选值组成，这两个值都是您定义的，标签使您能够以不同的方式对 AWS 资源进行分类，例如，按用途、所有者或环境。当您拥有许多相同类型的资源时，这很有用 - 您可以根据分配给特定资源的标签快速识别该资源。例如，您可以为账户的 Amazon EC2 实例定义一组标签，以帮助您跟踪每个实例的所有者和堆栈级别，我们建议您设计一组满足每种资源类型需求的标签键。使用一组一致的标签键可以让您更轻松地管理资源。您可以根据添加的标签搜索和筛选资源。</p><h2 id="32-一家数据分析初创公司要求解决方案架构师为索引数据推荐-AWS-数据存储选项。数据处理引擎每天将生成超过-64-TB-的处理数据，项目大小可达-300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种-AWS-数据存储服务？"><a href="#32-一家数据分析初创公司要求解决方案架构师为索引数据推荐-AWS-数据存储选项。数据处理引擎每天将生成超过-64-TB-的处理数据，项目大小可达-300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种-AWS-数据存储服务？" class="headerlink" title="32.一家数据分析初创公司要求解决方案架构师为索引数据推荐 AWS 数据存储选项。数据处理引擎每天将生成超过 64 TB 的处理数据，项目大小可达 300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种 AWS 数据存储服务？"></a>32.一家数据分析初创公司要求解决方案架构师为索引数据推荐 AWS 数据存储选项。数据处理引擎每天将生成超过 64 TB 的处理数据，项目大小可达 300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种 AWS 数据存储服务？</h2><p><strong>A</strong>. Amazon RDS</p><p><strong>B</strong>. Amazon Redshift</p><p><strong>C</strong>. Amazon DynamoDB</p><p><strong>D</strong>. Amazon S3</p><p>正确答案是 C，因为 DynamoDB 将帮助存储索引数据，同时自动扩展。每个项目的属性累积大小必须符合最大 DynamoDB 项目大小 （400KB）。桌子的大小没有实际限制。表在项目数或字节数方面不受限制，选项 A 是错误的，因为 RDS 不会以每天 64TB 的数据进行扩展。此外，所有数据库实例的总存储限制为 100TiB，选项 B 是错误的，因为 Redshift 更像是一种数据分析解决方案，它不会自动扩展。它需要随着需求的变化而调整大小，选项 D 是错误的，因为 S3 不适用于索引数据</p><h2 id="33-您正在构建一个自动转录服务，Amazon-EC2-工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？"><a href="#33-您正在构建一个自动转录服务，Amazon-EC2-工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？" class="headerlink" title="33.您正在构建一个自动转录服务，Amazon EC2 工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？"></a>33.您正在构建一个自动转录服务，Amazon EC2 工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？</h2><p><strong>A</strong>. Multiple Amazon EBS volume with snapshots</p><p><strong>B</strong>. A single Amazon Glacier vault</p><p><strong>C</strong>. A single Amazon S3 bucket</p><p><strong>D</strong>. Multiple instance stores<br>.多个实例存储</p><p>这里的关键点是存储需要持久、经济高效和可扩展，正确答案是 C，因为 S3 提供了持久、经济高效和可扩展的存储，选项 A 是错误的，因为 EBS 卷是持久的，但价格昂贵，选项 B 是错误的，因为 Glacier 虽然持久、经济高效且可扩展，但更像是一种存档解决方案，具有不经常访问的数据需求，选项 D 是错误的，因为实例存储不是持久的，因为它们链接到实例的生命周期。如果 EC2 实例终止，数据将丢失。</p><h2 id="34-解决方案架构师正在为生产关系数据库设计存储层。数据库将在-Amazon-EC2-上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机-I-O-延迟。哪种数据存储方式满足上述要求？"><a href="#34-解决方案架构师正在为生产关系数据库设计存储层。数据库将在-Amazon-EC2-上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机-I-O-延迟。哪种数据存储方式满足上述要求？" class="headerlink" title="34.解决方案架构师正在为生产关系数据库设计存储层。数据库将在 Amazon EC2 上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机 I/O 延迟。哪种数据存储方式满足上述要求？"></a>34.解决方案架构师正在为生产关系数据库设计存储层。数据库将在 Amazon EC2 上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机 I/O 延迟。哪种数据存储方式满足上述要求？</h2><p><strong>A</strong>. Store data in a file system backed by Amazon Elastic File System (EFS)<br>.将数据存储在 Amazon Elastic File System （EFS） 支持的文件系统中</p><p><strong>B</strong>. Store data in Amazon S3 and use a third-party solution to expose Amazon S3 as a file system to the database server.<br>.将数据存储在 Amazon S3 中，并使用第三方解决方案将 Amazon S3 作为文件系统公开给数据库服务器。</p><p><strong>C</strong>. Store data in Amazon DynamoDB and emulate relational database semantics.<br>.将数据存储在 Amazon DynamoDB 中并模拟关系数据库语义。</p><p><strong>D</strong>. Stripe data across multiple Amazon EBS volumes using RAID 0<br>.使用 RAID 0 跨多个 Amazon EBS 卷条带化数据</p><p>正确答案是 D，因为具有 RAID 0 的 EBS 卷将有助于扩展并提供最低的随机 I/O，请参阅 AWS 文档 - EC2 Raid Config，借助 Amazon EBS，您可以使用可用于传统裸机服务器的任何标准 RAID 配置，只要您的实例的操作系统支持该特定 RAID 配置。这是因为所有 RAID 都是在软件级别完成的。为了获得比单个卷更高的 I/O 性能，RAID 0 可以将多个卷条带化在一起;对于实例冗余，RAID 1 可以将两个卷镜像在一起，选项 A 是错误的，因为 EFS 不适合数据库文件系统，选项 B 是错误的，因为 S3 不能用作数据库服务器的文件系统，选项 C 是错误的，因为 DynamoDB 不能用作关系数据库。</p><h2 id="35-解决方案架构师需要在-Amazon-EC2-实例上部署-HTTP-HTTPS-服务，并支持使用负载均衡器的-WebSocket。建筑师如何满足这些要求？"><a href="#35-解决方案架构师需要在-Amazon-EC2-实例上部署-HTTP-HTTPS-服务，并支持使用负载均衡器的-WebSocket。建筑师如何满足这些要求？" class="headerlink" title="35.解决方案架构师需要在 Amazon EC2 实例上部署 HTTP/HTTPS 服务，并支持使用负载均衡器的 WebSocket。建筑师如何满足这些要求？"></a>35.解决方案架构师需要在 Amazon EC2 实例上部署 HTTP/HTTPS 服务，并支持使用负载均衡器的 WebSocket。建筑师如何满足这些要求？</h2><p><strong>A</strong>. Configure a Network Load balancer.<br>.配置 Network Load Balancer。</p><p><strong>B</strong>. Configure an Application Load Balancer.<br>.配置 Application Load Balancer。</p><p><strong>C</strong>. Configure a Classic Load Balancer.<br>.配置 Classic Load Balancer。</p><p><strong>D</strong>. Configure a Layer-4 Load Balancer.<br>.配置四层负载均衡器。</p><p>正确答案是 B，因为 Application Load Balancer 与 Classic 和 Network Load Balancer 不同，它支持 WebSockets，请参阅 AWS 文档 - ELB Application Load Balancer，Application Load Balancer 支持基于内容的路由，并支持在容器中运行的应用程序。它们支持一对行业标准协议（WebSocket 和 HTTP/2），还提供对目标实例和容器运行状况的额外可见性。在容器或EC2实例上运行的网站和移动应用程序将受益于Application Load Balancer的使用，选项A，C和D是错误的，因为它们不支持WebSockets。</p><h2 id="36-Amazon-EC2-实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到-Amazon-CloudWatch-中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？"><a href="#36-Amazon-EC2-实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到-Amazon-CloudWatch-中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？" class="headerlink" title="36.Amazon EC2 实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到 Amazon CloudWatch 中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？"></a>36.Amazon EC2 实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到 Amazon CloudWatch 中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？</h2><p><strong>A</strong>. Create an Amazon CloudWatch alarm on an Amazon CloudWatch Logs filter for that message; based on that alarm, trigger an Amazon CloudWatch action to reboot the instance<br>.在 Amazon CloudWatch Logs 筛选条件上为该消息创建 Amazon CloudWatch 警报;根据该警报，触发 Amazon CloudWatch 操作以重启实例</p><p><strong>B</strong>. Create an AWS CloudTrail alarm on low CPU; based on that alarm, trigger an Amazon SNS message to the Operations team<br>.在 CPU 使用率较低时创建 AWS CloudTrail 警报;根据该警报，触发向运营团队发送 Amazon SNS 消息</p><p><strong>C</strong>. Create an Amazon CloudWatch alarm on instance memory usage; based on that alarm, trigger an Amazon CloudWatch action to reboot the instance<br>.创建有关实例内存使用情况的 Amazon CloudWatch 警报;根据该警报，触发 Amazon CloudWatch 操作以重启实例</p><p><strong>D</strong>. Create an AWS CloudTrail alarm to detect the deadlock, based on the alarm, trigger an Amazon SNS message to the Operations team<br>.创建 AWS CloudTrail 警报以检测死锁，根据警报触发向运营团队发送 Amazon SNS 消息</p><p>正确答案是 A，因为您可以在 CloudWatch 日志上确认 CloudWatch 警报以查找消息并重启实例，请参阅 AWS 文档 - CloudWatch 日志监控，选项 C 是错误的，因为没有内存条件，它无助于处理重启，选项 B 和 D 是错误的，因为 CloudTrail 提供您的 AWS 账户活动的事件历史记录， 包括通过 AWS 管理控制台、AWS 开发工具包、命令行工具和其他 AWS 服务执行的操作。它不提供警报。</p><h2 id="37-您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？"><a href="#37-您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？" class="headerlink" title="37.您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？"></a>37.您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？</h2><p><strong>A</strong>. Run the bastion on two instances one in each AZ<br>.在两个实例上运行堡垒，每个可用区一个</p><p><strong>B</strong>. Run the bastion on an active Instance in one AZ and have an AMI ready to boot up in the event of failure<br>.在一个可用区中的活动实例上运行堡垒，并准备好在发生故障时启动 AMI</p><p><strong>C</strong>. Configure the bastion instance in an Auto Scaling group Specify the Auto Scaling group to include multiple AZs but have a min-size of 1 and max-size of 1<br>.在 Auto Scaling 组中配置堡垒实例 指定 Auto Scaling 组以包含多个可用区，但最小大小为 1，最大大小为 1</p><p><strong>D</strong>. Configure an ELB in front of the bastion instance<br>.在堡垒实例前配置ELB</p><p>正确答案是 C，因为堡垒主机允许来自外部网络的用户能够登录私有子网中的实例。堡垒主机可以通过在多个可用区中启用自动扩展（最小值和最大值为 1）来实现高可用性，这样，如果一个实例出现故障，另一个实例无需人工干预即可使用，选项 A 是错误的，因为它仍然无法处理可用区故障，选项 B 是错误的，因为它仍然需要手动干预。选项 D 是错误的，因为 ELB 不仅仅是 Web 访问。</p><h2 id="38-当您设计支持-24-小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？"><a href="#38-当您设计支持-24-小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？" class="headerlink" title="38.当您设计支持 24 小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？"></a>38.当您设计支持 24 小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？</h2><p><strong>A</strong>. Launch enhanced networking instances in a placement group to support the heavy traffic<br>.在置放群组中启动增强型联网实例，以支持繁重的流量</p><p><strong>B</strong>. Apply Service Oriented Architecture (SOA) principles instead of a 3-tier architecture<br>.应用面向服务的架构 （SOA） 原则，而不是 3 层架构</p><p><strong>C</strong>. Use Elastic Beanstalk to enable blue-green deployment<br>.使用 Elastic Beanstalk 启用蓝绿部署</p><p><strong>D</strong>. Use ElastiCache as in-memory storage on top of DynamoDB to store user sessions<br>.将 ElastiCache 用作 DynamoDB 上的内存中存储来存储用户会话</p><p>正确答案是 D，因为带有 DynamoDB 的 ElastiCache 将有助于提供可扩展、更快的读/写和内存存储以减少延迟，选项 A 是错误的，因为只会提高 EC2 实例中的内部吞吐量，选项 B 是错误的，因为它只是简化了架构但不能减少延迟，选项 C 是错误的，因为它改进了部署，最大限度地减少了应用程序的停机时间并易于回滚</p><h2 id="39-Web-应用程序在从单个客户-Amazon-系统映像-（AMI）-启动的-10-个-EC2-实例上运行。EC2-实例位于-Internet-Application-Load-Balancer-后面。Amazon-Route-53-为应用程序提供-DNS。如果-Web-服务器实例停止回复请求，解决方案架构师应如何自动恢复？"><a href="#39-Web-应用程序在从单个客户-Amazon-系统映像-（AMI）-启动的-10-个-EC2-实例上运行。EC2-实例位于-Internet-Application-Load-Balancer-后面。Amazon-Route-53-为应用程序提供-DNS。如果-Web-服务器实例停止回复请求，解决方案架构师应如何自动恢复？" class="headerlink" title="39.Web 应用程序在从单个客户 Amazon 系统映像 （AMI） 启动的 10 个 EC2 实例上运行。EC2 实例位于 Internet Application Load Balancer 后面。Amazon Route 53 为应用程序提供 DNS。如果 Web 服务器实例停止回复请求，解决方案架构师应如何自动恢复？"></a>39.Web 应用程序在从单个客户 Amazon 系统映像 （AMI） 启动的 10 个 EC2 实例上运行。EC2 实例位于 Internet Application Load Balancer 后面。Amazon Route 53 为应用程序提供 DNS。如果 Web 服务器实例停止回复请求，解决方案架构师应如何自动恢复？</h2><p><strong>A</strong>. Launch the instances in an Auto Scaling group with an Elastic Load Balancing health check.<br>.使用 Elastic Load Balancing 运行状况检查启动 Auto Scaling 组中的实例。</p><p><strong>B</strong>. Launch instances in multiple Availability Zones and set the load balancer to Multi-AZ<br>.在多个可用区中启动实例，并将负载均衡器设置为多可用区</p><p><strong>C</strong>. Add CloudWatch alarm actions for each instance to restart if the Status Check (Any) fails<br>.为每个实例添加 CloudWatch 警报操作，以便在状态检查 （Any） 失败时重新启动</p><p><strong>D</strong>. Add Route 53 records for each instance with an instance health check<br>.使用实例运行状况检查为每个实例添加 Route 53 记录</p><p>正确答案是 A，因为启用了 Auto Scaling 和运行状况检查的 ELB 将有助于处理恢复。Auto Scaling 有助于将实例替换为 Auto Scaling 配置中指定的 AMI。ELB 将帮助处理仅将流量路由到正常运行的实例。Route 53 DNS 只需指向 ELB，Auto Scaling 实例的运行状况为正常或不正常。Auto Scaling 组中的所有实例都以正常状态启动。除非 Amazon EC2 Auto Scaling 收到运行状况不佳的通知，否则假定实例运行状况良好。此通知可以来自以下一个或多个来源：Amazon EC2、Elastic Load Balancing 或自定义运行状况检查，在 Amazon EC2 Auto Scaling 将实例标记为运行状况不佳后，将计划对其进行替换。如果您不希望替换实例，可以暂停任何单个 Auto Scaling 组的运行状况检查过程，要发现 EC2 实例的可用性，负载均衡器会定期发送 ping、尝试连接或发送请求来测试 EC2 实例。这些测试称为运行状况检查。运行状况检查时运行状况良好的实例的状态为 InService。运行状况检查时运行状况不佳的任何实例的状态为 OutOfService。负载均衡器对所有已注册的实例执行运行状况检查，无论实例处于健康状态还是不健康状态，负载均衡器仅将请求路由到健康实例当负载均衡器确定某个实例运行状况不佳时，它会停止将请求路由到该实例。负载均衡器在实例恢复到正常状态后继续将请求路由到实例。，负载均衡器使用 Elastic Load Balancing 提供的默认运行状况检查配置或您配置的运行状况检查配置来检查已注册实例的运行状况，如果您已将 Auto Scaling 组与 Classic 负载均衡器关联，则可以使用负载均衡器运行状况检查来确定 Auto Scaling 组中实例的运行状况。默认情况下，Auto Scaling 组会定期确定每个实例的运行状况，选项 B 是错误的，因为多个可用区中的 ELB 和 Auto Scaling 提供 HA，但如果未配置运行状况检查，则无助于恢复，选项 C 是错误的，因为每个实例不需要 CloudWatch 警报，因为使用 Auto Scaling 组，实例会不断变化。选项 D 是错误的，因为 Route 53 需要指向 Application Load Balancer。它不提供实例的负载均衡。</p><h2 id="40-我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在-AWS-S3-存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案："><a href="#40-我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在-AWS-S3-存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案：" class="headerlink" title="40.我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在 AWS S3 存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案："></a>40.我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在 AWS S3 存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案：</h2><p><strong>A</strong>. Identity Federation based on AWS STS using an AWS IAM policy for the respective S3 bucket<br>.基于 AWS STS 的联合身份验证，使用相应 S3 存储桶的 AWS IAM 策略</p><p><strong>B</strong>. Use ACLs to restrict the access to the selects AWS accounts<br>.使用 ACL 限制对所选 AWS 账户的访问</p><p><strong>C</strong>. Set up S3 bucket policies with a conditional statement restricting IP address<br>.使用限制 IP 地址的条件语句设置 S3 存储桶策略</p><p><strong>D</strong>. IAM user per every registered client with an IAM policy that grants S3 access to the respective bucket<br>.每个注册客户端的 IAM 用户，其 IAM 策略授予对相应存储桶的 S3 访问权限</p><p>正确答案是 A，因为它是一个移动应用程序，用户可以使用 STS 的联合身份验证进行身份验证，并仅授予对相应 S3 存储桶的访问权限，请参阅 AWS 文档 - IAM Web 联合身份验证</p><h2 id="41-一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的-Web-服务器即将加载，作为架构师，您不希望使用现有的-Web-服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？"><a href="#41-一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的-Web-服务器即将加载，作为架构师，您不希望使用现有的-Web-服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？" class="headerlink" title="41.一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的 Web 服务器即将加载，作为架构师，您不希望使用现有的 Web 服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？"></a>41.一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的 Web 服务器即将加载，作为架构师，您不希望使用现有的 Web 服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？</h2><p><strong>A</strong>. Create a secondary S3 bucket. Then, use an AWS Lambda to sync the contents to the primary bucket.<br>.创建辅助 S3 存储桶。然后，使用 AWS Lambda 将内容同步到主存储桶。</p><p><strong>B</strong>. Use Auto Scaling and increase the capacity as demand increased<br>.使用 Auto Scaling 并随着需求的增加增加容量</p><p><strong>C</strong>. Use Pre-Signed URLs instead to upload the images.<br>.请改用预签名 URL 上传图像。</p><p><strong>D</strong>. Use ECS Containers to upload the images.<br>.使用 ECS 容器上传镜像。</p><p>正确答案是C，因为该解决方案正在寻找减少Web服务器上负载的选项，可以为上传生成预签名URL，这将允许用户直接上传到S3，而不必通过Web服务器路由请求。选项 D 是错误的，因为 ECS 容器需要额外的硬件，从而增加成本和时间。</p><h2 id="42-您目前正在为您的公司构建一个将使用-API-网关的解决方案。您希望确保在设计-API-网关时能够减少对-API-网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。"><a href="#42-您目前正在为您的公司构建一个将使用-API-网关的解决方案。您希望确保在设计-API-网关时能够减少对-API-网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。" class="headerlink" title="42.您目前正在为您的公司构建一个将使用 API 网关的解决方案。您希望确保在设计 API 网关时能够减少对 API 网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。"></a>42.您目前正在为您的公司构建一个将使用 API 网关的解决方案。您希望确保在设计 API 网关时能够减少对 API 网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。</h2><p><strong>A</strong>. Use AWS API Gateway with CloudFront<br>.将 AWS API Gateway 与 CloudFront 结合使用</p><p><strong>B</strong>. Enable API Gateway Caching</p><p><strong>C</strong>. Enable API Stages<br>.启用 API 阶段</p><p><strong>D</strong>. Enable CORS configuration for the API Gateway<br>.为 API Gateway 启用 CORS 配置</p><p>正确答案是 B，因为 API Gateway 缓存有助于缓存终端节点的响应并提高性能，请参阅 AWS 文档 - API Gateway 缓存，您可以在 Amazon API Gateway 中启用 API 缓存来缓存终端节点的响应。通过缓存，您可以减少对终端节点的调用次数，还可以改善对 API 的请求的延迟。当您为阶段启用缓存时，API Gateway 会在指定的生存时间 （TTL） 周期内（以秒为单位）缓存来自终端节点的响应。然后，API Gateway 通过从缓存中查找终端节点响应来响应请求，而不是向终端节点发出请求。API 缓存的默认 TTL 值为 300 秒。最大 TTL 值为 3600 秒。TTL=0 表示缓存被禁用，选项 A 是错误的，因为 CloudFront 已经与 API 网关一起使用，选项 C 是错误的，因为 API 阶段用于部署不同版本的 API，选项 D 是错误的，因为 CORS 启用了 API 的跨域访问</p><h2 id="43-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？"><a href="#43-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？" class="headerlink" title="43.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？"></a>43.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？</h2><p><strong>A</strong>. AWS Glacier</p><p><strong>B</strong>. AWS Elastic Transcoder</p><p><strong>C</strong>. AWS Simple Notification Service<br>.AWS 简单通知服务</p><p><strong>D</strong>. AWS Simple Queue Service</p><p>正确答案是D，因为SQS可用于构建可扩展和解耦的软件。SQS 可用于在 S3 中存储消息和文件，并相应地进行处理和扩展。</p><h2 id="44-解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用-Amazon-CloudWatch-监控此流量信息是否存在异常。架构师应该采取什么方法？"><a href="#44-解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用-Amazon-CloudWatch-监控此流量信息是否存在异常。架构师应该采取什么方法？" class="headerlink" title="44.解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用 Amazon CloudWatch 监控此流量信息是否存在异常。架构师应该采取什么方法？"></a>44.解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用 Amazon CloudWatch 监控此流量信息是否存在异常。架构师应该采取什么方法？</h2><p><strong>A</strong>. Maintain traffic history on each Amazon EC2 instance.<br>.维护每个 Amazon EC2 实例上的流量历史记录。</p><p><strong>B</strong>. Enable Amazon VPC Flow Logs.</p><p><strong>C</strong>. Enable CloudTrail for VPC<br>.为 VPC 启用 CloudTrail</p><p><strong>D</strong>. Enable Amazon VPC Network Logs</p><p>正确答案是 B，因为只有 VPC 流日志可以帮助跟踪 VPC 中网络接口之间的流量，请参阅 AWS 文档 - VPC 流日志，VPC 流日志是一项功能，可让您捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据可以发布到 Amazon CloudWatch Logs 和 Amazon S3。创建流日志后，您可以在所选目标中检索和查看其数据，流日志可以帮助您完成许多任务;例如，排查特定流量未到达实例的原因，这反过来又可以帮助您诊断限制性过强的安全组规则。您还可以使用流日志作为安全工具来监控到达实例的流量，选项 A 是错误的，因为需要捕获传入流量才能在每个 EC2 实例中进行维护。此外，它们需要在单个外部源进行整合，选项 C 是错误的，因为 CloudTrail 无法帮助跟踪 VPC 之间的网络流量。CloudTrail 提供您的 AWS 账户活动的事件历史记录，包括通过 AWS 管理控制台、AWS 开发工具包、命令行工具和其他 AWS 服务执行的操作，选项 D 是错误的，因为有 VPC 网络日志配置。</p><h2 id="45-一家公司正在使用-AWS-Key-Management-Service-（KMS）-进行安全密钥管理。已建议该公司记录其-AWS-KMS-密钥的所有使用情况。什么是最简单的解决方案？"><a href="#45-一家公司正在使用-AWS-Key-Management-Service-（KMS）-进行安全密钥管理。已建议该公司记录其-AWS-KMS-密钥的所有使用情况。什么是最简单的解决方案？" class="headerlink" title="45.一家公司正在使用 AWS Key Management Service （KMS） 进行安全密钥管理。已建议该公司记录其 AWS KMS 密钥的所有使用情况。什么是最简单的解决方案？"></a>45.一家公司正在使用 AWS Key Management Service （KMS） 进行安全密钥管理。已建议该公司记录其 AWS KMS 密钥的所有使用情况。什么是最简单的解决方案？</h2><p><strong>A</strong>. Associate AWS KMS metrics with Amazon CloudWatch</p><p><strong>B</strong>. Use AWS CloudTrail to log AWS KMS key usage.</p><p><strong>C</strong>. Deploy a monitoring agent to the RDS instances.<br>.将监控Agent部署到RDS实例。</p><p><strong>D</strong>. Poll AWS KMS periodically with a scheduled job.<br>.使用计划作业定期轮询 AWS KMS。</p><p>正确答案是 B，因为 CloudTrail 与 AWS KMS 集成并帮助跟踪 KMS 发生的所有事件，请参阅 AWS 文档 - 使用 CloudTrail 进行 AWS KMS 日志记录，AWS KMS 与 AWS CloudTrail 集成，后者是一项服务，可在 AWS KMS 中提供用户、角色或 AWS 服务执行的操作的记录。CloudTrail 将对 AWS KMS 的所有 API 调用作为事件捕获，包括来自 AWS KMS 控制台的调用和对 AWS KMS API 的代码调用。如果您创建跟踪，则可以使 CloudTrail 事件持续传送到 Amazon S3 存储桶，包括 AWS KMS 的事件。如果您未配置跟踪，您仍然可以在 CloudTrail 控制台的 Event history （事件历史记录） 中查看最新事件。通过使用 CloudTrail 收集的信息，您可以确定向 AWS KMS 发出了什么请求、发出请求的 IP 地址、何人发出的请求、请求的发出时间以及其他详细信息。</p><h2 id="46-一位解决方案架构师正在设计一种解决方案，用于在-Amazon-S3-中存储大量事件数据。架构师预计工作负载将始终超过每秒-100-个请求。架构师应该在-Amazon-S3-中执行哪些操作来优化性能？"><a href="#46-一位解决方案架构师正在设计一种解决方案，用于在-Amazon-S3-中存储大量事件数据。架构师预计工作负载将始终超过每秒-100-个请求。架构师应该在-Amazon-S3-中执行哪些操作来优化性能？" class="headerlink" title="46.一位解决方案架构师正在设计一种解决方案，用于在 Amazon S3 中存储大量事件数据。架构师预计工作负载将始终超过每秒 100 个请求。架构师应该在 Amazon S3 中执行哪些操作来优化性能？"></a>46.一位解决方案架构师正在设计一种解决方案，用于在 Amazon S3 中存储大量事件数据。架构师预计工作负载将始终超过每秒 100 个请求。架构师应该在 Amazon S3 中执行哪些操作来优化性能？</h2><p><strong>A</strong>. Randomize the key name prefix</p><p><strong>B</strong>. Store the event data in separate buckets<br>.将事件数据存储在单独的存储桶中</p><p><strong>C</strong>. Randomize the key name suffix</p><p><strong>D</strong>. Use Amazon S3 Transfer Acceleration</p><p>正确答案是 A，因为随机性有助于将对象分布在多个分区中，从而提高性能，注意 - AWS S3 的最新增强功能现在提供了更高的性能，支持每秒至少 3,500 个请求来添加数据和每秒 5,500 个请求来检索数据，S3 性能已更新，但这是之前来自 AWS 的建议。Amazon S3 在每个 AWS 区域中维护对象键名称的索引。对象键以 UTF-8 二进制顺序存储在索引中的多个分区中。密钥名称决定了密钥存储在哪个分区中。使用顺序前缀（如时间戳或字母顺序）会增加 Amazon S3 将大量密钥作为特定分区目标的可能性，从而使分区的 I/O 容量不堪重负。如果在键名前缀中引入一些随机性，则键名以及 I/O 负载将分布在多个分区中，示例 1：在键名中添加十六进制哈希前缀，为键名引入随机性的一种方法是添加哈希字符串作为键名的前缀。例如，您可以计算计划分配为键名的字符序列的 MD5 哈希值。从哈希中，选取特定数量的字符，并将它们作为前缀添加到键名称中。以下示例显示了具有四个字符哈希的键名称。</p><h2 id="47-Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的-Facebook-帐户登录游戏，游戏会将玩家数据和得分信息直接记录到-DynamoDB-表中。对-DynamoDB-API-的请求进行签名的最安全方法是什么？"><a href="#47-Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的-Facebook-帐户登录游戏，游戏会将玩家数据和得分信息直接记录到-DynamoDB-表中。对-DynamoDB-API-的请求进行签名的最安全方法是什么？" class="headerlink" title="47.Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的 Facebook 帐户登录游戏，游戏会将玩家数据和得分信息直接记录到 DynamoDB 表中。对 DynamoDB API 的请求进行签名的最安全方法是什么？"></a>47.Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的 Facebook 帐户登录游戏，游戏会将玩家数据和得分信息直接记录到 DynamoDB 表中。对 DynamoDB API 的请求进行签名的最安全方法是什么？</h2><p><strong>A</strong>. Create an IAM user with access credentials that are distributed with the mobile app to sign the requests<br>.使用随移动应用程序分发的访问凭证创建一个 IAM 用户，以便对请求进行签名</p><p><strong>B</strong>. Distribute the AWS root account access credentials with the mobile app to sign the requests<br>.将 AWS 根账户访问凭证与移动应用程序一起分发，以便对请求进行签名</p><p><strong>C</strong>. Request temporary security credentials using web identity federation to sign the requests<br>.使用 Web 联合身份验证请求临时安全凭证以对请求进行签名</p><p><strong>D</strong>. Establish cross account access between the mobile app and the DynamoDB table to sign the requests<br>.在移动应用程序和 DynamoDB 表之间建立跨账户访问，以便对请求进行签名</p><p>正确答案是 C，因为使用 IAM 角色 Web 联合身份验证将有助于身份验证和生成临时凭证，请参阅 AWS 文档 - IAM Web 联合身份验证，示例流程 - Cognito 是简化 Web 联合身份验证的服务。</p><h2 id="48-您正在为读取密集型的小型数据库创建新的联机事务处理-（OLTP）-应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种-Amazon-EBS-存储选项将实现最一致的性能，以帮助保持性能？"><a href="#48-您正在为读取密集型的小型数据库创建新的联机事务处理-（OLTP）-应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种-Amazon-EBS-存储选项将实现最一致的性能，以帮助保持性能？" class="headerlink" title="48.您正在为读取密集型的小型数据库创建新的联机事务处理 （OLTP） 应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种 Amazon EBS 存储选项将实现最一致的性能，以帮助保持性能？"></a>48.您正在为读取密集型的小型数据库创建新的联机事务处理 （OLTP） 应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种 Amazon EBS 存储选项将实现最一致的性能，以帮助保持性能？</h2><p><strong>A</strong>. Provisioned IOP SSD<br>.预置 IOP SSD</p><p><strong>B</strong>. General purpose SSD</p><p><strong>C</strong>. Cold HDD .冷硬盘</p><p><strong>D</strong>. Throughtput Optimized HDD.<br>.吞吐量优化的 HDD。</p><p>正确答案是 A，因为建议将预置 IOPS SSD 用于具有持续高吞吐量的 OLTP 要求，请参阅 AWS 文档 - EBS 卷类型，预配置 IOPS SSD （io1） 卷旨在满足对存储性能和一致性敏感的 I/O 密集型工作负载的需求，尤其是数据库工作负载。</p><h2 id="49-您有一个-Web-样式的应用程序，该应用程序具有无状态但-CPU-和内存密集型-Web-层，在-VPC-内的-cc2-8xlarge-EC2-实例上运行。负载不足的实例在业务定义的-SLA-内返回请求时出现问题。应用程序在-DynamoDB-表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合-SLA-的问题？"><a href="#49-您有一个-Web-样式的应用程序，该应用程序具有无状态但-CPU-和内存密集型-Web-层，在-VPC-内的-cc2-8xlarge-EC2-实例上运行。负载不足的实例在业务定义的-SLA-内返回请求时出现问题。应用程序在-DynamoDB-表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合-SLA-的问题？" class="headerlink" title="49.您有一个 Web 样式的应用程序，该应用程序具有无状态但 CPU 和内存密集型 Web 层，在 VPC 内的 cc2.8xlarge EC2 实例上运行。负载不足的实例在业务定义的 SLA 内返回请求时出现问题。应用程序在 DynamoDB 表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合 SLA 的问题？"></a>49.您有一个 Web 样式的应用程序，该应用程序具有无状态但 CPU 和内存密集型 Web 层，在 VPC 内的 cc2.8xlarge EC2 实例上运行。负载不足的实例在业务定义的 SLA 内返回请求时出现问题。应用程序在 DynamoDB 表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合 SLA 的问题？</h2><p><strong>A</strong>. Add another cc2.8xlarge application instance, and put both behind an Elastic Load Balancer<br>.添加另一个 cc2.8xlarge 应用程序实例，并将这两个实例放在 Elastic Load Balancer 后面</p><p><strong>B</strong>. Move the cc2.8xlarge to the same Availability Zone as the DynamoDB table<br>.将 cc2.8xlarge 移动到与 DynamoDB 表相同的可用区</p><p><strong>C</strong>. Cache the database responses in ElastiCache for more rapid access<br>.在 ElastiCache 中缓存数据库响应，以便更快速地访问</p><p><strong>D</strong>. Move the database from DynamoDB to RDS MySQL in scale-out read-replica configuration<br>.在横向扩展只读副本配置中将数据库从 DynamoDB 移动到 RDS MySQL</p><p>这里的关键点是数据层已正确配置，响应速度始终很快，只是应用程序响应需要改进，正确答案是 A，因为性能在负载期间受到影响，解决方案可以在负载均衡器平衡负载的情况下横向扩展，选项 B 是错误的，因为它没有提高处理能力，因此没有提高响应时间和性能，选项 C 和 D 是错误的，因为数据层响应速度很快</p><h2 id="50-解决方案架构师需要使用-AWS-为本地数据中心托管的三层-Web-应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？"><a href="#50-解决方案架构师需要使用-AWS-为本地数据中心托管的三层-Web-应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？" class="headerlink" title="50.解决方案架构师需要使用 AWS 为本地数据中心托管的三层 Web 应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？"></a>50.解决方案架构师需要使用 AWS 为本地数据中心托管的三层 Web 应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？</h2><p><strong>A</strong>. Continuously replicate the production database server to Amazon RDS. Use AWS CloudFormation to deploy the application and any additional servers if necessary.<br>.将生产数据库服务器持续复制到 Amazon RDS。如有必要，请使用 AWS CloudFormation 部署应用程序和任何其他服务器。</p><p><strong>B</strong>. Continuously replicate the production database server to Amazon RDS. Create one application load balancer and register on-premises servers. Configure ELB Application Load Balancer to automatically deploy Amazon EC2 instances for application and additional servers, if the on-premises application is down.<br>.将生产数据库服务器持续复制到 Amazon RDS。创建一个 Application Load Balancer 并注册本地服务器。将 ELB Application Load Balancer 配置为在本地应用程序关闭时自动为应用程序和其他服务器部署 Amazon EC2 实例。</p><p><strong>C</strong>. Use a scheduled Lambda function to replicate the production database to AWS. Use Amazon Route 53 health checks to deploy the application automatically to Amazon S3, if production is unhealthy.<br>.使用计划的 Lambda 函数将生产数据库复制到 AWS。如果生产运行状况不佳，请使用 Amazon Route 53 运行状况检查将应用程序自动部署到 Amazon S3。</p><p><strong>D</strong>. Use a scheduled Lambda function to replicate the production database to AWS. Register on-premises servers to an Auto Scaling group and deploy the application to additional servers, if production is unavailable.<br>.使用计划的 Lambda 函数将生产数据库复制到 AWS。如果生产不可用，请将本地服务器注册到 Auto Scaling 组，并将应用程序部署到其他服务器。</p><p>请注意，对于基于 MAC 地址的软件许可，您可以使用弹性网络接口 （ENI），其 MAC 地址也可以预先分配以预配许可证。您可以将这些实例与实例关联，就像与弹性 IP 地址关联一样。 使用 Elastic Load Balancing （ELB） 将流量分配到多个实例。然后，您将更新 DNS 记录，以指向您的 Amazon EC2 实例或使用 CNAME 指向您的负载均衡器。对于不太重要的系统，我们建议将此选项用于传统的基于 Web 的应用程序，您可以确保在 AWS 中提供任何安装包和配置信息，例如，以 Amazon EBS 快照的形式。这将加快应用程序服务器的设置速度，因为您可以在多个可用区中快速创建多个卷以附加到 Amazon EC2 实例。然后，您可以进行相应的安装和配置，例如，使用备份和恢复方法，选项B是错误的，因为指示灯中不需要ALB。只有RDS需要复制，选项C是错误的，因为Lambda函数复制数据库更改不可靠，Route 53运行状况检查无法部署，S3不适合应用程序部署。 请注意，对于基于 MAC 地址的软件许可，您可以使用弹性网络接口 （ENI），其 MAC 地址也可以预先分配以预配许可证。您可以将这些实例与实例关联，就像与弹性 IP 地址关联一样。 使用 Elastic Load Balancing （ELB） 将流量分配到多个实例。然后，您将更新 DNS 记录，以指向您的 Amazon EC2 实例或使用 CNAME 指向您的负载均衡器。对于不太重要的系统，我们建议将此选项用于传统的基于 Web 的应用程序，您可以确保在 AWS 中提供任何安装包和配置信息，例如，以 Amazon EBS 快照的形式。这将加快应用程序服务器的设置速度，因为您可以在多个可用区中快速创建多个卷以附加到 Amazon EC2 实例。然后，您可以进行相应的安装和配置，例如，使用备份和恢复方法，选项B是错误的，因为指示灯中不需要ALB。只有RDS需要复制，选项C是错误的，因为Lambda函数复制数据库更改不可靠，Route 53运行状况检查无法部署，S3不适合应用程序部署。，选项 D 是错误的，因为 Lambda 函数在复制数据库更改方面不可靠，并且 Auto Scaling 无法跨本地服务器</p><h2 id="51-用户创建了一个应用程序，该应用程序将托管在-EC2-上。应用程序调用-DynamoDB-以获取某些数据。应用程序正在使用-DynamoDB-开发工具包从-EC2-实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？"><a href="#51-用户创建了一个应用程序，该应用程序将托管在-EC2-上。应用程序调用-DynamoDB-以获取某些数据。应用程序正在使用-DynamoDB-开发工具包从-EC2-实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？" class="headerlink" title="51.用户创建了一个应用程序，该应用程序将托管在 EC2 上。应用程序调用 DynamoDB 以获取某些数据。应用程序正在使用 DynamoDB 开发工具包从 EC2 实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？"></a>51.用户创建了一个应用程序，该应用程序将托管在 EC2 上。应用程序调用 DynamoDB 以获取某些数据。应用程序正在使用 DynamoDB 开发工具包从 EC2 实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？</h2><p><strong>A</strong>. The user should attach an IAM role with DynamoDB access to the EC2 instance<br>.用户应将具有 DynamoDB 访问权限的 IAM 角色附加到 EC2 实例</p><p><strong>B</strong>. The user should create an IAM user with DynamoDB access and use its credentials within the application to connect with DynamoDB<br>.用户应创建具有 DynamoDB 访问权限的 IAM 用户，并在应用程序中使用其凭证与 DynamoDB 连接</p><p><strong>C</strong>. The user should create an IAM role, which has EC2 access so that it will allow deploying the application<br>.用户应创建一个具有 EC2 访问权限的 IAM 角色，以便允许部署应用程序</p><p><strong>D</strong>. The user should create an IAM user with DynamoDB and EC2 access. Attach the user with the application so that it does not use the root account credentials<br>.用户应创建具有 DynamoDB 和 EC2 访问权限的 IAM 用户。将用户与应用程序附加，以便它不使用 root 帐户凭据</p><p>正确答案是 A，因为创建 IAM 角色并将其附加到实例是最佳实践。然后，应用程序可以使用临时凭证进行 DynamoDB 调用，选项 B 和 D 是错误的，因为不建议使用 IAM 用户，因为您需要对凭证进行硬编码以公开它们，并且很难轮换，选项 C 是错误的，因为您需要创建一个具有 DynamoDB 访问权限的角色并将其分配给 EC2。应用程序不需要具有 EC2 访问权限。</p><h2 id="52-客户将其公司网站托管在面向公众的负载均衡器后面的-Web-服务器群集上。客户还使用-Amazon-Route-53-来管理其公有-DNS。客户应如何配置-DNS-区域顶点记录以指向负载均衡器？"><a href="#52-客户将其公司网站托管在面向公众的负载均衡器后面的-Web-服务器群集上。客户还使用-Amazon-Route-53-来管理其公有-DNS。客户应如何配置-DNS-区域顶点记录以指向负载均衡器？" class="headerlink" title="52.客户将其公司网站托管在面向公众的负载均衡器后面的 Web 服务器群集上。客户还使用 Amazon Route 53 来管理其公有 DNS。客户应如何配置 DNS 区域顶点记录以指向负载均衡器？"></a>52.客户将其公司网站托管在面向公众的负载均衡器后面的 Web 服务器群集上。客户还使用 Amazon Route 53 来管理其公有 DNS。客户应如何配置 DNS 区域顶点记录以指向负载均衡器？</h2><p><strong>A</strong>. Create an A record pointing to the IP address of the load balancer<br>.创建指向负载均衡器的 IP 地址的 A 记录</p><p><strong>B</strong>. Create a CNAME record pointing to the load balancer DNS name.<br>.创建指向负载均衡器 DNS 名称的 CNAME 记录。</p><p><strong>C</strong>. Create a CNAME record aliased to the load balancer DNS name.</p><p><strong>D</strong>. Create an A record aliased to the load balancer DNS name<br>.创建别名为负载均衡器 DNS 名称的 A 记录</p><p>正确答案是 D，因为 Route 53 支持在 A 记录上为顶级域名记录设置别名记录，Q。我可以将我的顶级域名（example.com 与 <a href="http://www.example.com)指向我的/">www.example.com）指向我的</a> Elastic Load Balancer 吗？Amazon Route 53 提供了一种称为“别名”记录的特殊类型的记录，可让您将顶级域名 （example.com） DNS 名称映射到 ELB DNS 名称（即 elb1234.elb.amazonaws.com）。与 Amazon Elastic Load Balancer 关联的 IP 地址可能因扩展、缩减或软件更新而随时更改。Route 53 使用负载均衡器的一个或多个 IP 地址响应别名记录的每个请求。对映射到 ELB 负载均衡器的别名记录的查询是免费的。这些查询在 Amazon Route 53 使用情况报告中列为“AWS-DNS-Intra-Queries”。</p><h2 id="53-关于加密的-Amazon-Elastic-Block-Store-（EBS）-卷，以下哪项是正确的？选择-2-个答案"><a href="#53-关于加密的-Amazon-Elastic-Block-Store-（EBS）-卷，以下哪项是正确的？选择-2-个答案" class="headerlink" title="53.关于加密的 Amazon Elastic Block Store （EBS） 卷，以下哪项是正确的？选择 2 个答案"></a>53.关于加密的 Amazon Elastic Block Store （EBS） 卷，以下哪项是正确的？选择 2 个答案</h2><p><strong>A</strong>. Supported on all Amazon EBS volume types<br>.支持所有 Amazon EBS 卷类型</p><p><strong>B</strong>. Snapshots are automatically encrypted<br>.快照自动加密</p><p><strong>C</strong>. Available to all instance types<br>.适用于所有实例类型</p><p><strong>D</strong>. Existing volumes can be encrypted<br>.可以对现有卷进行加密</p><p><strong>E</strong>. Shared volumes can be encrypted<br>.可以对共享卷进行加密</p><p>这里的关键点是检查加密的 EBS 卷是否为 true，请参阅 AWS 文档 - EBS 加密，正确答案是 A 和 B，所有 EBS 卷类型（通用型 SSD [gp2]、预置 IOPS SSD [io1]、吞吐量优化型 HDD [st1]、Cold HDD [sc1] 和磁性 [标准]）都支持此功能，从加密卷中获取的快照会自动加密，选项 C 是错误的，因为 Amazon EBS 加密仅适用于某些实例类型。选中支持的实例类型，选项 D 错误，因为现有卷无法加密，您需要创建加密快照以重新创建加密卷，选项 E 错误，因为卷不共享，但快照共享。此外，AWS最近允许共享加密快照，但不能公开，您可以与特定的AWS账户共享加密快照，但不能将其公开</p><h2 id="54-应用程序在私有子网中的-Amazon-EC2-实例上运行。应用程序需要在-Amazon-Kinesis-Data-Streams-上读取和写入数据，并且公司策略要求此流量不应流向-Internet。如何满足这些要求？"><a href="#54-应用程序在私有子网中的-Amazon-EC2-实例上运行。应用程序需要在-Amazon-Kinesis-Data-Streams-上读取和写入数据，并且公司策略要求此流量不应流向-Internet。如何满足这些要求？" class="headerlink" title="54.应用程序在私有子网中的 Amazon EC2 实例上运行。应用程序需要在 Amazon Kinesis Data Streams 上读取和写入数据，并且公司策略要求此流量不应流向 Internet。如何满足这些要求？"></a>54.应用程序在私有子网中的 Amazon EC2 实例上运行。应用程序需要在 Amazon Kinesis Data Streams 上读取和写入数据，并且公司策略要求此流量不应流向 Internet。如何满足这些要求？</h2><p><strong>A</strong>. Configure a NAT gateway in a public subnet and route all traffic to Amazon Kinesis through the Nat gateway.<br>.在公有子网中配置 NAT 网关，并通过 NAT 网关将所有流量路由到 Amazon Kinesis。</p><p><strong>B</strong>. Configure a Gateway VPC endpoint gateway for Kinesis and route all traffic to Kinesis through the Gateway VPC endpoint.<br>.为 Kinesis 配置网关 VPC 终端节点网关，并通过网关 VPC 终端节点将所有流量路由到 Kinesis。</p><p><strong>C</strong>. Configure an Interface VPC endpoint interface for Kinesis and route all traffic to Kinesis through the Interface VPC endpoint.<br>.为 Kinesis 配置接口 VPC 终端节点接口，并通过接口 VPC 终端节点将所有流量路由到 Kinesis。</p><p><strong>D</strong>. Configure an AWS Direct Connect private virtual interface for Kinesis and route all traffic to Kinesis through the virtual interface.<br>.为 Kinesis 配置 AWS Direct Connect 私有虚拟接口，并通过该虚拟接口将所有流量路由到 Kinesis。</p><p>正确答案是 C，因为接口 VPC 终端节点允许从私有子网中的实例访问 kinesis 数据流，而无需通过 Internet 路由流量，请参阅 AWS 文档 - 具有接口 VPC 终端节点的 AWS Kinesis，您可以使用接口 VPC 终端节点来防止 Amazon VPC 和 Kinesis Data Streams 之间的流量离开 Amazon 网络。接口 VPC 终端节点不需要 Internet 网关、NAT 设备、VPN 连接或 AWS Direct Connect 连接。接口 VPC 终端节点由 AWS PrivateLink 提供支持，这是一种 AWS 技术，可在 AWS 服务之间使用弹性网络接口和 Amazon VPC 中的私有 IP 进行私有通信。</p><h2 id="55-您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态-IP-地址硬编码到后端，这会阻止您使用-ELB-部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择-2-个正确答案"><a href="#55-您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态-IP-地址硬编码到后端，这会阻止您使用-ELB-部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择-2-个正确答案" class="headerlink" title="55.您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态 IP 地址硬编码到后端，这会阻止您使用 ELB 部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择 2 个正确答案"></a>55.您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态 IP 地址硬编码到后端，这会阻止您使用 ELB 部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择 2 个正确答案</h2><p><strong>A</strong>. Do not migrate the application to the cloud until it can be converted to work with the ELB and Auto Scaling<br>.在将应用程序转换为使用 ELB 和 Auto Scaling 之前，请勿将其迁移到云中</p><p><strong>B</strong>. Ensure that the instance it’s using has an elastic IP address assigned to it<br>.确保为其使用的实例分配了弹性 IP 地址</p><p><strong>C</strong>. Write a custom script that pings the health of the instance, and, if the instance stops responding, switches the elastic IP address to a standby instance<br>.编写一个自定义脚本来 ping 实例的运行状况，如果实例停止响应，则将弹性 IP 地址切换到备用实例</p><p><strong>D</strong>. Create an AMI of the instance and launch it using Auto Scaling which will deploy the instance again if it becomes unhealthy<br>.创建实例的 AMI 并使用 Auto Scaling 启动它，如果实例运行状况不佳，它将再次部署实例</p><h2 id="56-解决方案架构师正在构建一个将数据存储到-Amazon-RDS-中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？"><a href="#56-解决方案架构师正在构建一个将数据存储到-Amazon-RDS-中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？" class="headerlink" title="56.解决方案架构师正在构建一个将数据存储到 Amazon RDS 中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？"></a>56.解决方案架构师正在构建一个将数据存储到 Amazon RDS 中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？</h2><p><strong>A</strong>. Use Amazon DynamoDB Accelerator</p><p><strong>B</strong>. Use Amazon RDS read replicas</p><p><strong>C</strong>. Use Amazon CloudFront<br>.使用 Amazon CloudFront</p><p><strong>D</strong>. Use Amazon ElastiCache</p><p>正确答案是 D，因为 ElastiCache 有助于缓存结果并提供低延迟访问，请参阅 AWS 文档 - ElastiCache 常见问题，问：是否可以将 Amazon ElastiCache for Memcached 与 Amazon RDS 或 Amazon DynamoDB 等 AWS 持久性数据存储一起使用？是的，Amazon ElastiCache 是 Amazon RDS 或 Amazon DynamoDB 等数据存储的理想前端， 为具有极高请求速率和/或低延迟要求的应用程序提供高性能中间层，选项 A 是错误的，因为 DynamoDB Accelerator 仅适用于 DynamoDB，选项 B 是错误的，因为 RDS 只读副本有助于减少主数据库的负载。但是，它不提供低延迟，选项C是错误的，因为CloudFront没有帮助与RDS连接。</p><h2 id="57-您正在运行一个-Web-应用程序，该应用程序在两个可用区中具有四个-Amazon-EC2-实例。这些实例位于-ELB-Classic-Load-Balancer-后面的-Auto-Scaling-组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？"><a href="#57-您正在运行一个-Web-应用程序，该应用程序在两个可用区中具有四个-Amazon-EC2-实例。这些实例位于-ELB-Classic-Load-Balancer-后面的-Auto-Scaling-组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？" class="headerlink" title="57.您正在运行一个 Web 应用程序，该应用程序在两个可用区中具有四个 Amazon EC2 实例。这些实例位于 ELB Classic Load Balancer 后面的 Auto Scaling 组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？"></a>57.您正在运行一个 Web 应用程序，该应用程序在两个可用区中具有四个 Amazon EC2 实例。这些实例位于 ELB Classic Load Balancer 后面的 Auto Scaling 组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？</h2><p><strong>A</strong>. Cross-zone load balancing is not configured on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上未配置跨可用区负载均衡</p><p><strong>B</strong>. Access logs are not enabled on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上未启用访问日志</p><p><strong>C</strong>. A SSL/TLS certificate has not been deployed on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上尚未部署 SSL/TLS 证书</p><p><strong>D</strong>. Sticky bits is not enabled on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上未启用粘滞位</p><p>正确答案是 A，因为可能未启用跨区域负载均衡，因此流量会在可用区之间平均分配，而不管该可用区的实例如何。启用跨区域负载均衡后，无论实例位于哪个可用区，流量都会在实例之间平均分配，请参阅 AWS 文档 - ELB 跨区域，如果 Classic Load Balancer 的负载均衡器节点可以分发请求，而不管可用区如何，这称为跨区域负载均衡。启用跨区域负载均衡后，负载均衡器节点会在为负载均衡器启用的可用区之间均匀分配传入请求。否则，每个负载均衡器节点仅将请求分发到其可用区中的实例。例如，如果您在可用区 us-west-2a 中有 10 个实例，在 us-west-2b 中有 2 个实例，则如果启用了跨区域负载均衡，则请求将均匀分布在所有 12 个实例中。否则，us-west-2b 中的 2 个实例处理的请求数与 us-west-2a 中的 10 个实例相同。</p><h2 id="58-您正在-VPC-内部管理一个旧应用程序，其配置中具有硬编码的-IP-地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？"><a href="#58-您正在-VPC-内部管理一个旧应用程序，其配置中具有硬编码的-IP-地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？" class="headerlink" title="58.您正在 VPC 内部管理一个旧应用程序，其配置中具有硬编码的 IP 地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？"></a>58.您正在 VPC 内部管理一个旧应用程序，其配置中具有硬编码的 IP 地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？</h2><p><strong>A</strong>. Create an ELB to reroute traffic to a failover instance<br>.创建 ELB 以将流量重新路由到故障转移实例</p><p><strong>B</strong>. Create a secondary ENI that can be moved to a failover instance<br>.创建可移动到故障转移实例的辅助 ENI</p><p><strong>C</strong>. Use Route53 health checks to fail traffic over to a failover instance<br>.使用 Route53 运行状况检查将流量故障转移到故障转移实例</p><p><strong>D</strong>. Assign a secondary private IP address to the primary ENI that can be moved to a failover instance<br>.为可移动到故障转移实例的主 ENI 分配辅助私有 IP 地址</p><p>正确答案是 B &amp; D，因为应用程序是遗留的，需要硬编码的 IP 地址，您可以使用辅助 ENI 或辅助 IP 地址，请参阅 AWS 文档 - 使用 ENI 的 EC2，为确保故障转移功能，请考虑对网络接口上的传入流量使用辅助私有 IPv4。如果实例发生故障，您可以将接口和/或辅助私有 IPv4 地址移动到备用实例，选项 A 和 C 是错误的，因为它们不允许维护固定的硬编码 IP 地址。</p><h2 id="59-一家公司正在使用-Spot-实例来处理其工作负载。他们希望-Spot-实例停止而不是终止，以防-Spot-实例中断。如何配置？选择-2"><a href="#59-一家公司正在使用-Spot-实例来处理其工作负载。他们希望-Spot-实例停止而不是终止，以防-Spot-实例中断。如何配置？选择-2" class="headerlink" title="59.一家公司正在使用 Spot 实例来处理其工作负载。他们希望 Spot 实例停止而不是终止，以防 Spot 实例中断。如何配置？选择 2"></a>59.一家公司正在使用 Spot 实例来处理其工作负载。他们希望 Spot 实例停止而不是终止，以防 Spot 实例中断。如何配置？选择 2</h2><p><strong>A</strong>. Spot instance should have a one-time request type<br>.竞价型实例应具有一次性请求类型</p><p><strong>B</strong>. Spot instance should have a persistent request type<br>.Spot 实例应具有持久性请求类型</p><p><strong>C</strong>. Use EBS volume with the Spot instances<br>.将 EBS 卷与 Spot 实例结合使用</p><p><strong>D</strong>. Use Instance store volume with the Spot instances<br>.将实例存储卷与 Spot 实例结合使用</p><p><strong>E</strong>. Specify it in the launch configuration<br>.在启动配置中指定它</p><p>正确答案是 B 和 C，因为 Spot 实例定义了持久性请求类型，而 EBS 支持的实例允许它们停止和启动，请参阅 AWS 文档 - 启动停止 Spot 实例，Amazon EC2 Spot 现在允许在中断时停止 Amazon EBS 支持的实例，而不是在容量不再以您首选的价格可用时终止。然后，当容量在您的价格和时间要求范围内可用时，Spot 可以通过从停止状态重新启动实例来满足您的请求。要使用此新功能，请在提交持久性 Spot 请求时选择“停止”而不是“终止”作为中断行为。当您选择“停止”时，Spot 将在中断时关闭您的实例。将保存 EBS 根设备和附加的 EBS 卷，并保留其数据。当容量在您的价格和时间要求范围内再次可用时，Spot 将重新启动您的实例。重新启动后，EBS 根设备将从其先前的状态恢复，之前附加的数据卷将重新附加，并且实例将保留其实例 ID。</p><h2 id="60-您有一个在-us-west-2-中运行的应用程序，该应用程序需要始终运行-6-个-Amazon-Elastic-Compute-Cloud-（EC2）-实例。该区域有三个可用区（us-west-2a、us-west-2b-和-us-west-2c），如果-us-west-2-中的任何单个可用区不可用，以下哪个部署可提供-100-的容错能力？选择-2-个答案"><a href="#60-您有一个在-us-west-2-中运行的应用程序，该应用程序需要始终运行-6-个-Amazon-Elastic-Compute-Cloud-（EC2）-实例。该区域有三个可用区（us-west-2a、us-west-2b-和-us-west-2c），如果-us-west-2-中的任何单个可用区不可用，以下哪个部署可提供-100-的容错能力？选择-2-个答案" class="headerlink" title="60.您有一个在 us-west-2 中运行的应用程序，该应用程序需要始终运行 6 个 Amazon Elastic Compute Cloud （EC2） 实例。该区域有三个可用区（us-west-2a、us-west-2b 和 us-west-2c），如果 us-west-2 中的任何单个可用区不可用，以下哪个部署可提供 100% 的容错能力？选择 2 个答案"></a>60.您有一个在 us-west-2 中运行的应用程序，该应用程序需要始终运行 6 个 Amazon Elastic Compute Cloud （EC2） 实例。该区域有三个可用区（us-west-2a、us-west-2b 和 us-west-2c），如果 us-west-2 中的任何单个可用区不可用，以下哪个部署可提供 100% 的容错能力？选择 2 个答案</h2><p><strong>A</strong>. Us-west-2a with two EC2 instances, us-west-2b with two EC2 instances, and us-west-2c with two EC2 instances<br>.us-west-2a 具有两个 EC2 实例，us-west-2b 具有两个 EC2 实例，us-west-2c 具有两个 EC2 实例</p><p><strong>B</strong>. Us-west-2a with three EC2 instances, us-west-2b with three EC2 instances, and us-west-2c with no EC2 instances<br>.us-west-2a 具有三个 EC2 实例，us-west-2b 具有三个 EC2 实例，us-west-2c 具有三个 EC2 实例</p><p><strong>C</strong>. Us-west-2a with four EC2 instances, us-west-2b with two EC2 instances, and us-west-2c with two EC2 instances<br>.us-west-2a 具有 4 个 EC2 实例，us-west-2b 具有 2 个 EC2 实例，us-west-2c 具有 2 个 EC2 实例</p><p><strong>D</strong>. Us-west-2a with six EC2 instances, us-west-2b with six EC2 instances, and us-west-2c with no EC2 instances<br>.us-west-2a 具有 6 个 EC2 实例，us-west-2b 具有 6 个 EC2 实例，us-west-2c 没有 EC2 实例</p><p><strong>E</strong>. Us-west-2a with three EC2 instances, us-west-2b with three EC2 instances, and us-west-2c with three EC2 instances<br>.us-west-2a 具有三个 EC2 实例，us-west-2b 具有三个 EC2 实例，us-west-2c 具有三个 EC2 实例</p><p>正确答案是 D 和 E，因为即使 AZ 宕机，也会有 6 个实例始终运行提供容错能力，选项 A 是错误的，如果 AZ 宕机，只有 4 个实例可用，选项 B 是错误的，因为如果 AZ 宕机，只有 3 个实例可用，选项 C 是错误的，因为如果 Us-west-2a AZ 宕机，只有 4 个实例可用</p><h2 id="61-解决方案架构师计划将-NAT-实例迁移到-NAT-网关。架构师具有带有脚本的-NAT-实例来管理高可用性。使用-NAT-网关实现类似高可用性的最有效方法是什么？"><a href="#61-解决方案架构师计划将-NAT-实例迁移到-NAT-网关。架构师具有带有脚本的-NAT-实例来管理高可用性。使用-NAT-网关实现类似高可用性的最有效方法是什么？" class="headerlink" title="61.解决方案架构师计划将 NAT 实例迁移到 NAT 网关。架构师具有带有脚本的 NAT 实例来管理高可用性。使用 NAT 网关实现类似高可用性的最有效方法是什么？"></a>61.解决方案架构师计划将 NAT 实例迁移到 NAT 网关。架构师具有带有脚本的 NAT 实例来管理高可用性。使用 NAT 网关实现类似高可用性的最有效方法是什么？</h2><p><strong>A</strong>. Remove source/destination check on NAT instances.<br>.删除 NAT 实例上的源/目标检查。</p><p><strong>B</strong>. Launch a NAT Gateway in each Availability Zone<br>.在每个可用区中启动 NAT 网关</p><p><strong>C</strong>. Use a mix of NAT instances and NAT gateway<br>.混合使用 NAT 实例和 NAT 网关</p><p><strong>D</strong>. Add an ELB Application Load Balancer in front of NAT gateway<br>.在NAT网关前添加ELB Application Load Balancer</p><p>正确答案是 B，因为 NAT 网关是按可用区启动的，并且应该在每个可用区中启动以确保高可用性，请参阅 AWS 文档 - NAT 网关，如果您在多个可用区中有资源，并且它们共享一个 NAT 网关，则在 NAT 网关的可用区关闭时，其他可用区中的资源将失去 Internet 访问权限。要创建独立于可用区的架构，请在每个可用区中创建一个 NAT 网关并配置路由以确保资源使用同一可用区中的 NAT 网关，选项 A 是错误的，因为删除源/目标不会将流量路由回原始实例，选项 C 是错误的，因为 NAT 实例和 NAT 网关的混合不提供高可用性。选项 D 是错误的，因为 ELB 用于负载均衡，而不是高可用性。</p><h2 id="62-在公有子网中启动要用作-NAT（网络地址转换）设备的实例后，您可以修改路由表，使-NAT-设备成为私有子网的-Internet-绑定流量的目标。当您尝试从私有子网中的实例到-Internet-建立出站连接时，您不会成功。以下哪项步骤可以解决问题？"><a href="#62-在公有子网中启动要用作-NAT（网络地址转换）设备的实例后，您可以修改路由表，使-NAT-设备成为私有子网的-Internet-绑定流量的目标。当您尝试从私有子网中的实例到-Internet-建立出站连接时，您不会成功。以下哪项步骤可以解决问题？" class="headerlink" title="62.在公有子网中启动要用作 NAT（网络地址转换）设备的实例后，您可以修改路由表，使 NAT 设备成为私有子网的 Internet 绑定流量的目标。当您尝试从私有子网中的实例到 Internet 建立出站连接时，您不会成功。以下哪项步骤可以解决问题？"></a>62.在公有子网中启动要用作 NAT（网络地址转换）设备的实例后，您可以修改路由表，使 NAT 设备成为私有子网的 Internet 绑定流量的目标。当您尝试从私有子网中的实例到 Internet 建立出站连接时，您不会成功。以下哪项步骤可以解决问题？</h2><p><strong>A</strong>. Attaching a second Elastic Network interface (ENI) to the NAT instance, and placing it in the private subnet<br>.将第二个弹性网络接口 （ENI） 附加到 NAT 实例，并将其放置在私有子网中</p><p><strong>B</strong>. Attaching an Elastic IP address to the instance in the private subnet<br>.将弹性 IP 地址附加到私有子网中的实例</p><p><strong>C</strong>. Attaching a second Elastic Network Interface (ENI) to the instance in the private subnet, and placing it in the public subnet<br>.将第二个弹性网络接口 （ENI） 附加到私有子网中的实例，并将其放置在公有子网中</p><p><strong>D</strong>. Disabling the Source/Destination Check attribute on the NAT instance<br>.禁用 NAT 实例上的 Source/Destination Check 属性</p><p>正确答案是 D，因为 NAT 上的源/目标检查属性必须禁用。EIP 和 ENI 与通过 NAT 路由流量无关，请参阅 AWS 文档 - VPC NAT，默认情况下每个 EC2 实例执行源/目标检查。这意味着实例必须是它发送或接收的任何流量的源或目标。但是，当源或目标不是其本身时，NAT 实例必须能够发送和接收流量。因此，您必须在 NAT 实例上禁用源/目标检查。</p><h2 id="63-管理员在-AWS-中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合-POSIX-标准。哪个-AWS-服务可以执行此操作？"><a href="#63-管理员在-AWS-中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合-POSIX-标准。哪个-AWS-服务可以执行此操作？" class="headerlink" title="63.管理员在 AWS 中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合 POSIX 标准。哪个 AWS 服务可以执行此操作？"></a>63.管理员在 AWS 中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合 POSIX 标准。哪个 AWS 服务可以执行此操作？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon EC2 Instance store</p><p>正确答案是 C，因为 EFS 提供了创建符合 POSIX 的共享存储的能力，请参阅 AWS 文档 - EFS，Amazon EFS 提供符合 POSIX 的弹性共享文件存储。您创建的文件系统支持来自多个 Amazon EC2 实例的并发读写访问，并且可以从创建它的 AWS 区域中的所有可用区访问，选项 A 和 D 是错误的，因为实例和 EBS 卷无法共享，选项 B 是错误的，因为 S3 不符合 POSIX 标准</p><h2 id="64-一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在-Amazon-EC2-实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种-AWS-服务来存储数据并满足这些要求？"><a href="#64-一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在-Amazon-EC2-实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种-AWS-服务来存储数据并满足这些要求？" class="headerlink" title="64.一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在 Amazon EC2 实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种 AWS 服务来存储数据并满足这些要求？"></a>64.一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在 Amazon EC2 实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种 AWS 服务来存储数据并满足这些要求？</h2><p><strong>A</strong>. Amazon S3</p><p><strong>B</strong>. Amazon DynamoDB</p><p><strong>C</strong>. Amazon RDS</p><p><strong>D</strong>. Amazon EBS</p><p>正确答案是 B，因为 DynamoDB 提供了扩展到无限大小的能力，同时以最小的延迟提供对数据的访问，请参阅 AWS 文档 - DynamoDB，Amazon DynamoDB 是一种完全托管的 NoSQL 数据库服务，可提供快速且可预测的性能以及无缝的可扩展性。借助 DynamoDB，您可以减轻操作和扩展分布式数据库的管理负担，这样您就不必担心硬件预置、设置和配置、复制、软件修补或集群扩展，选项 A 是错误的，因为与 DynamoDB 相比，S3 延迟会更长，选项 C 是错误的，因为 RDS 不会扩展到无限大小，并且与 DynamoDB 相比延迟会更多，选项 D 是错误的，因为与 DynamoDB 相比，EBS 无法扩展到无限大小，并且延迟会更多</p><h2 id="您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的-IP-地址。如何将高可用性应用于运行该应用程序的实例？"><a href="#您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的-IP-地址。如何将高可用性应用于运行该应用程序的实例？" class="headerlink" title="您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的 IP 地址。如何将高可用性应用于运行该应用程序的实例？"></a>您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的 IP 地址。如何将高可用性应用于运行该应用程序的实例？</h2><p><strong>A</strong>. Assign a public IP address to the EC2 instance, have a backup instance running. In the event of failure, move the Public IP from the primary instance to the backup instance.<br>.为 EC2 实例分配公有 IP 地址，运行备份实例。如果发生故障，请将公网 IP 从主实例移动到备份实例。</p><p><strong>B</strong>. Assign an elastic IP address to the EC2 instance, have a backup instance running. In the event of failure, move the Elastic IP from the primary instance to the backup instance.<br>.为 EC2 实例分配弹性 IP 地址，运行备份实例。如果发生故障，请将弹性 IP 从主实例移动到备份实例。</p><p><strong>C</strong>. Use ELB for load balancing and assign the IP address and use auto scaling to manage load<br>.使用 ELB 进行负载均衡并分配 IP 地址并使用弹性伸缩来管理负载</p><p><strong>D</strong>. EC2 instance cannot be configured with hardcoded IP address<br>.无法使用硬编码的 IP 地址配置 EC2 实例</p><p>正确答案是 B，因为您可以拥有固定的静态弹性 IP 地址并分配给 EC2 实例。如果 EC2 实例发生故障，则生成一个新实例并将弹性 IP 地址分配给新实例，请参阅 AWS 文档 - Fault Tolerance 和 HA 架构，弹性 IP 地址是公有 IP 地址，可以在区域内的实例之间以编程方式映射。它们与 AWS 账户关联，而不是与特定实例或实例的生命周期关联。弹性 IP 地址可用于解决主机或可用区故障，方法是将地址快速重新映射到另一个正在运行的实例或刚刚启动的替换实例。预留实例可以帮助保证此类容量在另一个区域中可用，选项 A 是错误的，因为公有 IP 地址不是静态的，如果实例重新启动或停止并启动，选项 C 是错误的，因为无法为 ELB 分配固定 IP 地址，选项 D 是错误的，因为可以为 EC2 实例分配弹性 IP 地址。</p><h2 id="67-一位解决方案架构师正在-Amazon-VPC-中规划一个新的-Web-应用程序。客户已指定新-Web-应用程序的体系结构必须包括在高度可用的-Web-服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该"><a href="#67-一位解决方案架构师正在-Amazon-VPC-中规划一个新的-Web-应用程序。客户已指定新-Web-应用程序的体系结构必须包括在高度可用的-Web-服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该" class="headerlink" title="67.一位解决方案架构师正在 Amazon VPC 中规划一个新的 Web 应用程序。客户已指定新 Web 应用程序的体系结构必须包括在高度可用的 Web 服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该"></a>67.一位解决方案架构师正在 Amazon VPC 中规划一个新的 Web 应用程序。客户已指定新 Web 应用程序的体系结构必须包括在高度可用的 Web 服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该</h2><p><strong>A</strong>. Deliver session state as messages in the Amazon SQS queue.<br>.将会话状态作为消息传送到 Amazon SQS 队列中。</p><p><strong>B</strong>. Enable session state on Amazon CloudFront.<br>.在 Amazon CloudFront 上启用会话状态。</p><p><strong>C</strong>. Store session state in Amazon ElastiCache</p><p><strong>D</strong>. Provide session state through Elastic Load Balancing sticky sessions<br>.通过 Elastic Load Balancing 粘性会话提供会话状态</p><p>正确答案是 C，因为 ElasticCache 可以帮助存储会话信息，这些信息可以在多个实例之间共享。这有助于在不内部维护状态的情况下设计应用程序，请参阅 AWS 文档 - ElastiCache 常见问题，问：使用 Amazon ElastiCache for Memcached 可以缓存哪些内容？，您可以使用该服务缓存各种对象，从持久性数据存储（例如 Amazon RDS、DynamoDB 或 EC2 上托管的自我管理数据库）中的内容到动态生成的网页（例如使用 Nginx）， 或可能不需要持久性后备存储的瞬态会话数据。您还可以使用它来实现高频计数器，以在大容量 Web 应用程序中部署准入控制，选项 A 和 B 是错误的，因为 CloudFront 和 SQS 不适合状态存储，选项 D 是错误的，因为 Elastic Load Balancing 粘性会话限制了高可用性 Web 服务器的使用，因为状态与单个实例相关联，而不是外部维护。</p><h2 id="68-解决方案架构师在-Amazon-VPC-中运行了一个多层应用程序。该应用程序具有一个-ELB-Classic-Load-Balancer-作为公有子网中的前端，以及一个基于-Amazon-EC2-的预留代理，该代理执行到私有子网中托管的两个后端-Amazon-EC2-实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）"><a href="#68-解决方案架构师在-Amazon-VPC-中运行了一个多层应用程序。该应用程序具有一个-ELB-Classic-Load-Balancer-作为公有子网中的前端，以及一个基于-Amazon-EC2-的预留代理，该代理执行到私有子网中托管的两个后端-Amazon-EC2-实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）" class="headerlink" title="68.解决方案架构师在 Amazon VPC 中运行了一个多层应用程序。该应用程序具有一个 ELB Classic Load Balancer 作为公有子网中的前端，以及一个基于 Amazon EC2 的预留代理，该代理执行到私有子网中托管的两个后端 Amazon EC2 实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）"></a>68.解决方案架构师在 Amazon VPC 中运行了一个多层应用程序。该应用程序具有一个 ELB Classic Load Balancer 作为公有子网中的前端，以及一个基于 Amazon EC2 的预留代理，该代理执行到私有子网中托管的两个后端 Amazon EC2 实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）</h2><p><strong>A</strong>. Replace the Amazon EC2 reserve proxy with an ELB internal Classic Load Balancer<br>.将 Amazon EC2 预留代理替换为 ELB 内部 Classic Load Balancer</p><p><strong>B</strong>. Add Auto Scaling to the Amazon EC2 backend fleet.<br>.将 Auto Scaling 添加到 Amazon EC2 后端队列。</p><p><strong>C</strong>. Add Auto Scaling to the Amazon EC2 reserve proxy layer.<br>.将 Auto Scaling 添加到 Amazon EC2 预留代理层。</p><p><strong>D</strong>. Use t2 burstable instance types for the backend fleet.<br>.将 t2 可突增实例类型用于后端队列。</p><p><strong>E</strong>. Replace both the frontend and reserve proxy layers with an ELB Application Load Balancer.<br>.将前端和预留代理层替换为 ELB Application Load Balancer。</p><p>正确答案是 B &amp; E，因为 AWS ALB 可以执行基于内容的路由，并可用于替换反向代理层。ALB 还由 AWS 托管，具有高度可用性和可扩展性。后端队列可以与 Auto Scaling 相关联以根据需求进行扩展，选项 A 是错误的，因为经典 ELB 不提供基于内容的路由功能，选项 C 是错误的，因为与 ALB 相比，Auto Scaling 不是一个经济高效的解决方案，选项 D 是错误的，因为 t2 可突增不提供可扩展性，但能够在有限的时间内突增到基线以上。</p><h2 id="69-解决方案架构师需要为在-Amazon-EC2-实例上运行的一组-Web-应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？"><a href="#69-解决方案架构师需要为在-Amazon-EC2-实例上运行的一组-Web-应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？" class="headerlink" title="69.解决方案架构师需要为在 Amazon EC2 实例上运行的一组 Web 应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？"></a>69.解决方案架构师需要为在 Amazon EC2 实例上运行的一组 Web 应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？</h2><p><strong>A</strong>. Create a crontab job script in each instance to push the logs regularly to Amazon S3<br>.在每个实例中创建一个 crontab 任务脚本，以定期将日志推送到 Amazon S3</p><p><strong>B</strong>. Install and configure Amazon CloudWatch Logs agent in the Amazon EC2<br>.在 Amazon EC2 中安装和配置 Amazon CloudWatch Logs 代理</p><p><strong>C</strong>. Enable Amazon CloudWatch Events in the AWS Management Console.<br>.在 AWS 管理控制台中启用 Amazon CloudWatch Events。</p><p><strong>D</strong>. Enable AWS CloudTrail to map all API calls invoked by the application<br>.启用 AWS CloudTrail 以映射应用程序调用的所有 API 调用</p><p>正确答案是 B，因为 CloudWatch Logs 代理可以自动将日志发送到 CloudWatch，请参阅 AWS 文档 - CloudWatch Logs 代理，CloudWatch Logs 代理提供了一种将日志数据从 Amazon EC2 实例发送到 CloudWatch Logs 的自动化方法。代理由以下组件组成：，您可以在现有 EC2 实例上使用 CloudWatch Logs 代理安装程序来安装和配置 CloudWatch Logs 代理。安装完成后，日志会自动从实例流向您在安装代理时创建的日志流。代理确认它已启动并保持运行状态，直到您禁用它，除了使用代理之外，您还可以使用 AWS CLI、CloudWatch Logs 开发工具包或 CloudWatch Logs API 发布日志数据。AWS CLI 最适合在命令行或通过脚本发布数据。CloudWatch Logs 开发工具包最适合直接从应用程序发布日志数据或构建您自己的日志发布应用程序，选项 A 是错误的，因为这需要开发工作，选项 C 是错误的，因为 Events 提供近乎实时的系统事件流，这些事件描述了 Amazon Web Services （AWS） 资源中的更改。它无助于捕获应用程序日志，选项 D 是错误的，因为 CloudTrail 仅适用于审计日志。它不处理应用程序日志。</p><h2 id="70-您有一个在-Amazon-EC2-上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的-Amazon-EC2-实例以最经济高效的方式减少积压？"><a href="#70-您有一个在-Amazon-EC2-上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的-Amazon-EC2-实例以最经济高效的方式减少积压？" class="headerlink" title="70.您有一个在 Amazon EC2 上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的 Amazon EC2 实例以最经济高效的方式减少积压？"></a>70.您有一个在 Amazon EC2 上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的 Amazon EC2 实例以最经济高效的方式减少积压？</h2><p><strong>A</strong>. Reserved instances .预留实例</p><p><strong>B</strong>. Spot instances .竞价型实例</p><p><strong>C</strong>. Dedicated instances .独享实例</p><p><strong>D</strong>. On-demand instances .按需实例</p><p>这里的关键点是以最具成本效益的方式实现解决方案，如果这个过程被中断，视频将被另一个基于排队系统的实例转码，正确答案是B，因为Spot实例可以以最具成本效益的方式处理负载，并且Spot实例可以突然终止的情况已经处理好了。</p><h2 id="71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？"><a href="#71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？" class="headerlink" title="71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？"></a>71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon DynamoDB</p><h2 id="71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？-1"><a href="#71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？-1" class="headerlink" title="71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？"></a>71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon DynamoDB</p><p>正确答案是 C，因为 EFS 是创建用户主目录的理想解决方案，并且可以跨组织的个人访问，并能够对其进行配置，请参阅 AWS EFS 常见问题和创建可写的每用户目录，问。Amazon EFS 适用于哪些使用案例？，Amazon EFS 旨在为各种工作负载和应用程序提供性能，包括大数据和分析、媒体处理工作流、内容管理、Web 服务和主目录。</p><h2 id="72-一家公司在其-200-GB-数据仓库上有两种不同类型的换盆需求-–-数据科学家运行少量并发临时-SQL-查询，每个查询可能需要几分钟才能运行。–-整个公司的显示屏运行许多快速-SQL-查询来填充仪表板，哪种设计能以最低的成本满足这些要求？"><a href="#72-一家公司在其-200-GB-数据仓库上有两种不同类型的换盆需求-–-数据科学家运行少量并发临时-SQL-查询，每个查询可能需要几分钟才能运行。–-整个公司的显示屏运行许多快速-SQL-查询来填充仪表板，哪种设计能以最低的成本满足这些要求？" class="headerlink" title="72.一家公司在其 200 GB 数据仓库上有两种不同类型的换盆需求;– 数据科学家运行少量并发临时 SQL 查询，每个查询可能需要几分钟才能运行。– 整个公司的显示屏运行许多快速 SQL 查询来填充仪表板，哪种设计能以最低的成本满足这些要求？"></a>72.一家公司在其 200 GB 数据仓库上有两种不同类型的换盆需求;– 数据科学家运行少量并发临时 SQL 查询，每个查询可能需要几分钟才能运行。– 整个公司的显示屏运行许多快速 SQL 查询来填充仪表板，哪种设计能以最低的成本满足这些要求？</h2><p><strong>A</strong>. Replicate relevant data between Amazon Redshift and Amazon DynamoDB. Data scientists use Redshift. Dashboards use DynamoDB<br>.在 Amazon Redshift 和 Amazon DynamoDB 之间复制相关数据。数据科学家使用 Redshift。控制面板使用 DynamoDB</p><p><strong>B</strong>. Configure auto-replication between Amazon Redshift and Amazon RDS. Data scientists use Redshift and Dashboards use RDS<br>.配置 Amazon Redshift 和 Amazon RDS 之间的自动复制。数据科学家使用 Redshift，控制面板使用 RDS</p><p><strong>C</strong>. Use Amazon Redshift for both requirements, with separate query queues configured in workload management.<br>.使用 Amazon Redshift 满足这两个要求，并在工作负载管理中配置单独的查询队列。</p><p><strong>D</strong>. Use Amazon Redshift for Data Scientists; Run automated dashboard queries against Redshift and store the results in Amazon ElastiCache, Dashboards query ElastiCache.<br>.将 Amazon Redshift 用于数据科学家;对 Redshift 运行自动控制面板查询并将结果存储在 Amazon ElastiCache 中，控制面板查询 ElastiCache。</p><p>正确答案是 C，因为 Redshift 提供工作负载管理，可以帮助确定交互式和长时间运行的作业的优先级。将数据存储在单个存储服务中也有助于将成本降至最低，请参阅 AWS 文档 - Redshift 的混合工作负载，混合工作负载同时运行批处理和交互式工作负载（短期运行和长时间运行的查询或报告）以支持业务需求或需求。通常，管理和配置混合工作负载需要对访问模式、系统资源的使用方式和性能要求有透彻的了解，混合工作负载通常具有某些进程比其他进程需要更高的优先级。有时，这意味着必须在给定的 SLA 内完成某项工作。其他时候，这意味着您只想防止非关键报告工作负载在任何时候消耗过多的集群资源，如果没有工作负载管理 （WLM），每个查询的优先级都相同，这可能会导致个人、团队或工作负载消耗过多的集群资源，而这些资源不如其他更关键的业务关键型作业有价值。您可以使用 WLM 来定义业务关注点的分离，并确定系统中不同类型的并发运行查询的优先级：选项 A 和 B 是错误的，因为它会导致数据重复，并且 2 个服务的成本不会很小，选项 D 是错误的，因为 ElastiCache 不会提供最新数据。</p><h2 id="73-使用以下-AWS-服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择-2-个答案"><a href="#73-使用以下-AWS-服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择-2-个答案" class="headerlink" title="73.使用以下 AWS 服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择 2 个答案"></a>73.使用以下 AWS 服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择 2 个答案</h2><p><strong>A</strong>. Amazon DynamoDB</p><p><strong>B</strong>. Amazon Elastic Compute Cloud (EC2)</p><p><strong>C</strong>. Amazon Elastic Load Balancing</p><p><strong>D</strong>. Amazon Simple Notification Service (SNS)</p><p><strong>E</strong>. Amazon Simple Storage Service (S3)</p><p>正确答案是 B 和 C，因为 ELB 可用于通过跨多个可用区跨多个 EC2 实例路由流量来提供高可用性，Elastic Load Balancing 会自动在多可用区的多个 Amazon EC2 实例之间分配传入的应用程序流量。它使您能够在应用程序中实现容错能力，无缝地提供路由应用程序流量所需的负载均衡容量，选项 A、D 和 E 是错误的，因为它们都是 AWS 托管服务，并且本身具有可扩展性和 HA。</p><h2 id="74-一家公司正计划在-AWS-中部署应用程序。此应用程序需要-EC2-实例才能持续执行日志处理活动，这些活动需要大约-500MiB-s-的数据吞吐量。以下哪项是满足此要求的最佳存储选项？"><a href="#74-一家公司正计划在-AWS-中部署应用程序。此应用程序需要-EC2-实例才能持续执行日志处理活动，这些活动需要大约-500MiB-s-的数据吞吐量。以下哪项是满足此要求的最佳存储选项？" class="headerlink" title="74.一家公司正计划在 AWS 中部署应用程序。此应用程序需要 EC2 实例才能持续执行日志处理活动，这些活动需要大约 500MiB/s 的数据吞吐量。以下哪项是满足此要求的最佳存储选项？"></a>74.一家公司正计划在 AWS 中部署应用程序。此应用程序需要 EC2 实例才能持续执行日志处理活动，这些活动需要大约 500MiB/s 的数据吞吐量。以下哪项是满足此要求的最佳存储选项？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS Throughput Optimized HDD</p><p><strong>C</strong>. EBS General Purpose SSD</p><p><strong>D</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p>正确答案是 B，因为吞吐量优化型 HDD 最适合通常涉及大数据、ETL 作业和日志处理的大型顺序 I/O 工作负载，请参阅 AWS 文档 - EBS 卷类型，吞吐量优化型 HDD （st1） 卷提供低成本的磁性存储，根据吞吐量而不是 IOPS 来定义性能。此卷类型非常适合大型顺序工作负载，例如 Amazon EMR、ETL、数据仓库和日志处理。不支持可启动的 st1 卷，吞吐量优化的 HDD （st1） 卷虽然类似于 Cold HDD （sc1） 卷，但旨在支持频繁访问的数据，此卷类型针对涉及大型顺序 I/O 的工作负载进行了优化，我们建议工作负载执行小型随机 I/O 的客户使用 gp2，较大的卷会线性扩展这些限制， 吞吐量上限为 500 MiB/s。</p><h2 id="75-您正在为客户设置-VPN，以将其远程网络连接到其-Amazon-VPC-环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下：-可预测的网络性能-支持-BGP-对等互连和路由策略-安全的-IPsec-VPN-连接，但不能通过-Internet-以下哪个-VPN-选项最能满足客户的要求？从以下选项中选择正确答案"><a href="#75-您正在为客户设置-VPN，以将其远程网络连接到其-Amazon-VPC-环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下：-可预测的网络性能-支持-BGP-对等互连和路由策略-安全的-IPsec-VPN-连接，但不能通过-Internet-以下哪个-VPN-选项最能满足客户的要求？从以下选项中选择正确答案" class="headerlink" title="75.您正在为客户设置 VPN，以将其远程网络连接到其 Amazon VPC 环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下： - 可预测的网络性能 - 支持 BGP 对等互连和路由策略 - 安全的 IPsec VPN 连接，但不能通过 Internet 以下哪个 VPN 选项最能满足客户的要求？从以下选项中选择正确答案"></a>75.您正在为客户设置 VPN，以将其远程网络连接到其 Amazon VPC 环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下： - 可预测的网络性能 - 支持 BGP 对等互连和路由策略 - 安全的 IPsec VPN 连接，但不能通过 Internet 以下哪个 VPN 选项最能满足客户的要求？从以下选项中选择正确答案</h2><p><strong>A</strong>. Software appliance-based VPN connection with IPsec<br>.基于 IPsec 的基于软件设备的 VPN 连接</p><p><strong>B</strong>. AWS Direct Connect and IPsec Hardware VPN connection over private lines<br>.通过专线的 AWS Direct Connect 和 IPsec 硬件 VPN 连接</p><p><strong>C</strong>. AWS Direct Correct with AWS VPN CloudHub<br>.AWS Direct 使用 AWS VPN CloudHub 进行校正</p><p><strong>D</strong>. AWS VPN CloudHub<br>.AWS VPN 云中心</p><p>正确答案是B，因为使用Direct Connect将提供可预测的网络性能并支持BGP对等互连和路由策略，而VPN将提供安全的IPsec VPN连接，但不能通过Internet，请参阅AWS文档 - VPC VPN连接，选项A是错误的，因为流量仍然通过Internet路由，选项C和D是错误的，因为CloudHub有助于多个远程站点之间的通信</p><h2 id="76-照片共享服务将图片存储在-Amazon-Simple-Storage-Service-（S3）-中，并允许使用与-OpenID-Connect-兼容的身份提供商登录应用程序。对于-Amazon-S3-操作，您应该使用哪种-AWS-Security-Token-Service-临时访问方法？"><a href="#76-照片共享服务将图片存储在-Amazon-Simple-Storage-Service-（S3）-中，并允许使用与-OpenID-Connect-兼容的身份提供商登录应用程序。对于-Amazon-S3-操作，您应该使用哪种-AWS-Security-Token-Service-临时访问方法？" class="headerlink" title="76.照片共享服务将图片存储在 Amazon Simple Storage Service （S3） 中，并允许使用与 OpenID Connect 兼容的身份提供商登录应用程序。对于 Amazon S3 操作，您应该使用哪种 AWS Security Token Service 临时访问方法？"></a>76.照片共享服务将图片存储在 Amazon Simple Storage Service （S3） 中，并允许使用与 OpenID Connect 兼容的身份提供商登录应用程序。对于 Amazon S3 操作，您应该使用哪种 AWS Security Token Service 临时访问方法？</h2><p><strong>A</strong>. SAML-based Identity Federation</p><p><strong>B</strong>. Cross-Account Access</p><p><strong>C</strong>. AWS IAM users</p><p><strong>D</strong>. Web Identity Federation</p><p>正确答案是 D，请参阅 AWS 文档 - IAM Web 联合身份验证，使用 Web 联合身份验证，您无需创建自定义登录代码或管理自己的用户身份。相反，您的应用程序的用户可以使用知名身份提供商 （IdP）（例如 Login with Amazon、Facebook、Google 或任何其他与 OpenID Connect （OIDC） 兼容的 IdP）登录，接收身份验证令牌，然后将该令牌交换为 AWS 中的临时安全凭证，这些凭证映射到有权使用您 AWS 账户中的资源的 IAM 角色。使用 IdP 可帮助您确保 AWS 账户的安全，因为您不必在应用程序中嵌入和分发长期安全凭证，选项 A 是错误的，因为 SAML 主要用于符合 SAML 标准的身份提供商，选项 B 是错误的，因为跨账户访问是提供对其他 AWS 账户的访问权限，选项 C 是错误的，因为 IAM 用户是向实际用户授予访问权限</p><h2 id="77-您的任务是在-AWS-中构建应用程序。该架构将由-EC2、Classic-Load-Balancer、Auto-Scaling-和-Route-53-组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在-Route-53-中，您最好使用哪种路由策略来实现蓝绿部署？"><a href="#77-您的任务是在-AWS-中构建应用程序。该架构将由-EC2、Classic-Load-Balancer、Auto-Scaling-和-Route-53-组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在-Route-53-中，您最好使用哪种路由策略来实现蓝绿部署？" class="headerlink" title="77.您的任务是在 AWS 中构建应用程序。该架构将由 EC2、Classic Load Balancer、Auto Scaling 和 Route 53 组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在 Route 53 中，您最好使用哪种路由策略来实现蓝绿部署？"></a>77.您的任务是在 AWS 中构建应用程序。该架构将由 EC2、Classic Load Balancer、Auto Scaling 和 Route 53 组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在 Route 53 中，您最好使用哪种路由策略来实现蓝绿部署？</h2><p><strong>A</strong>. Simple</p><p><strong>B</strong>. Multi-answer</p><p><strong>C</strong>. Latency</p><p><strong>D</strong>. Weighted .加权</p><p>正确答案是 D，因为加权路由策略有助于在不同环境中以受控方式分配流量。测试后即可进行切换，请参阅AWS蓝绿部署白皮书和路由策略</p><h2 id="78-工作负载包括从-Amazon-S3-存储桶下载映像、处理映像并将其移动到另一个-Amazon-S3-存储桶。Amazon-EC2-实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？"><a href="#78-工作负载包括从-Amazon-S3-存储桶下载映像、处理映像并将其移动到另一个-Amazon-S3-存储桶。Amazon-EC2-实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？" class="headerlink" title="78.工作负载包括从 Amazon S3 存储桶下载映像、处理映像并将其移动到另一个 Amazon S3 存储桶。Amazon EC2 实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？"></a>78.工作负载包括从 Amazon S3 存储桶下载映像、处理映像并将其移动到另一个 Amazon S3 存储桶。Amazon EC2 实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？</h2><p><strong>A</strong>. Change the Amazon EC2 instance to compute optimized.<br>.将 Amazon EC2 实例更改为计算优化型。</p><p><strong>B</strong>. Launch a second Amazon EC2 instance to monitor the health of the first<br>.启动第二个 Amazon EC2 实例以监控第一个实例的运行状况</p><p><strong>C</strong>. Trigger a Lambda function when a new object is uploaded.<br>.在上传新对象时触发 Lambda 函数。</p><p><strong>D</strong>. Initially copy the images to an attached Amazon EBS volume.<br>.最初将映像复制到附加的 Amazon EBS 卷。</p><p>正确答案是 C，因为 Lambda 为流程提供了高可用性，并且消除了对任何计算基础设施的需求，请参阅 AWS 文档 - Lambda，AWS Lambda 是一种无服务器计算服务，它运行您的代码以响应事件并自动为您管理底层计算资源。您可以使用 AWS Lambda 通过自定义逻辑扩展其他 AWS 服务，或创建自己的后端服务，这些服务以 AWS 规模、性能和安全性运行。AWS Lambda 可以自动运行代码以响应多个事件，例如通过 Amazon API Gateway 的 HTTP 请求、对 Amazon S3 存储桶中的对象的修改、Amazon DynamoDB 中的表更新以及 AWS Step Functions 中的状态转换。 容量配置和自动扩展、代码和安全补丁部署，以及代码监控和日志记录。您需要做的就是提供代码，选项 A、B 和 D 是错误的，因为它们不会在实例出现故障时提供高可用性。</p><h2 id="79-一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？"><a href="#79-一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？" class="headerlink" title="79.一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？"></a>79.一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？</h2><p><strong>A</strong>. Classic Load Balancer</p><p><strong>B</strong>. Network Load Balancer</p><p><strong>C</strong>. Application Load Balancer</p><p><strong>D</strong>. Use Route 53 instead<br>.请改用 Route 53</p><p>正确答案是 B，因为 Network Load Balancer 在第 4 层 TCP 上工作，它将请求转发到后端实例而不修改标头，请参阅 AWS 文档 - ELB 侦听器，选项 A 和 C 是错误的，因为经典 ELB 和 ALB 可以在第 7 层上工作，它们可以修改标头，选项 D 是错误的，因为 Route 53 不执行负载均衡器的工作。</p><h2 id="80-一家公司有一个使用-S3-存储桶作为其数据层的应用程序。根据对-S3-存储桶的监控，可以看出-GET-请求的数量为每秒-400-个请求。IT-运营团队接收有关用户在访问应用程序时收到-HTTP-500-或-503-错误的服务请求。可以做些什么来解决这些错误？选择-2-个答案"><a href="#80-一家公司有一个使用-S3-存储桶作为其数据层的应用程序。根据对-S3-存储桶的监控，可以看出-GET-请求的数量为每秒-400-个请求。IT-运营团队接收有关用户在访问应用程序时收到-HTTP-500-或-503-错误的服务请求。可以做些什么来解决这些错误？选择-2-个答案" class="headerlink" title="80.一家公司有一个使用 S3 存储桶作为其数据层的应用程序。根据对 S3 存储桶的监控，可以看出 GET 请求的数量为每秒 400 个请求。IT 运营团队接收有关用户在访问应用程序时收到 HTTP 500 或 503 错误的服务请求。可以做些什么来解决这些错误？选择 2 个答案"></a>80.一家公司有一个使用 S3 存储桶作为其数据层的应用程序。根据对 S3 存储桶的监控，可以看出 GET 请求的数量为每秒 400 个请求。IT 运营团队接收有关用户在访问应用程序时收到 HTTP 500 或 503 错误的服务请求。可以做些什么来解决这些错误？选择 2 个答案</h2><p><strong>A</strong>. Add a CloudFront distribution in front of the bucket.<br>.在存储桶前面添加 CloudFront 分配。</p><p><strong>B</strong>. Add an ELB in front of the S3 bucket.<br>.在 S3 存储桶前面添加一个 ELB。</p><p><strong>C</strong>. Add randomness to the key names.<br>.为键名称添加随机性。</p><p><strong>D</strong>. Enable Versioning for the S3 bucket.<br>.为 S3 存储桶启用版本控制。</p><p>正确答案是 A 和 C，因为以 S3 为源的 CloudFront 有助于缓存请求并减少对 S3 的直接调用，随机性有助于 S3 中跨分区的数据分发，请参阅 AWS 文档 - S3 性能，Amazon S3 在每个 AWS 区域中维护对象键名称的索引。对象键以 UTF-8 二进制顺序存储在索引中的多个分区中。密钥名称决定了密钥存储在哪个分区中。使用顺序前缀（如时间戳或字母顺序）会增加 Amazon S3 将大量密钥作为特定分区目标的可能性，从而使分区的 I/O 容量不堪重负。如果您在键名前缀中引入了一些随机性，则键名以及 I/O 负载将分布在多个分区中，如果您的工作负载主要发送 GET 请求，除了上述准则外，您还应考虑使用 Amazon CloudFront 进行性能优化，将 Amazon CloudFront 与 Amazon S3 集成， 您可以以低延迟和高数据传输速率将内容分发给用户。你也会向 Amazon S3 发送更少的直接请求，这将降低你的成本，例如假设你有几个非常受欢迎的对象Amazon CloudFront 从 Amazon S3 获取这些对象并对其进行缓存。然后，Amazon CloudFront 可以从其缓存中处理对象的未来请求，从而减少它发送到 Amazon S3 的 GET 请求的数量，选项 B 是错误的，因为 ELB 用于将流量分配到 EC2 实例，不适用于 S3，选项 D 是错误的，因为版本控制有助于维护多个副本，并有助于从意外删除或覆盖中恢复。</p><h2 id="81-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？"><a href="#81-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？" class="headerlink" title="81.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？"></a>81.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？</h2><p><strong>A</strong>. Configure a lifecycle hook for your Auto Scaling group<br>.为您的 Auto Scaling 组配置生命周期挂钩</p><p><strong>B</strong>. Add a scaling-specific cooldown period to the scaling policy<br>.在扩展策略中添加特定于扩展的冷却期</p><p><strong>C</strong>. Adjust the CPU threshold that triggers a scaling action<br>.调整触发扩展操作的 CPU 阈值</p><p><strong>D</strong>. Attach a new launch configuration to the Auto Scaling group<br>.将新的启动配置附加到 Auto Scaling 组</p><p>正确答案是 B，因为您需要调整新添加实例的冷却时间以启动和处理流量，请参阅 AWS 文档 - Auto Scaling 冷却时间，Auto Scaling 冷却时间是 Auto Scaling 组的可配置设置，有助于确保 Auto Scaling 不会在之前的扩展活动生效之前启动或终止其他实例。在 Auto Scaling 组使用简单的扩展策略动态扩展后，Auto Scaling 会等待冷却期完成，然后再恢复扩展活动。当您手动扩展 Auto Scaling 组时，默认设置不等待冷却时间，但您可以覆盖默认值并遵守冷却时间。如果实例运行状况不佳，Auto Scaling 不会等待冷却时间结束，然后再替换运行状况不佳的实例。</p><h2 id="82-一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种-AWS-服务来提供从视频游戏到数据存储的可靠数据摄取？"><a href="#82-一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种-AWS-服务来提供从视频游戏到数据存储的可靠数据摄取？" class="headerlink" title="82.一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种 AWS 服务来提供从视频游戏到数据存储的可靠数据摄取？"></a>82.一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种 AWS 服务来提供从视频游戏到数据存储的可靠数据摄取？</h2><p><strong>A</strong>. AWS Data Pipeline</p><p><strong>B</strong>. Amazon Kinesis Firehose</p><p><strong>C</strong>. Amazon DynamoDB Streams</p><p><strong>D</strong>. Amazon Elasticsearch Service</p><p>正确答案是 B，因为 Kinesis Firehose 可以帮助以最少的管理实现可靠的数据摄取，请参阅 AWS 文档 - Kinesis Firehose，Amazon Kinesis Data Firehose 是一项完全托管的服务，用于将实时流数据传输到 Amazon Simple Storage Service （Amazon S3）、Amazon Redshift、Amazon Elasticsearch Service （Amazon ES） 和 Splunk 等目标。Kinesis Data Firehose 与 Kinesis Data Streams、Kinesis Video Streams 和 Amazon Kinesis Data Analytics 一起是 Kinesis 流数据平台的一部分。使用 Kinesis Data Firehose，您无需编写应用程序或管理资源。您可以将数据创建器配置为将数据发送到 Kinesis Data Firehose，它会自动将数据传输到您指定的目标。您还可以将 Kinesis Data Firehose 配置为在传输数据之前对其进行转换。</p><h2 id="83-您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案："><a href="#83-您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案：" class="headerlink" title="83.您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案："></a>83.您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案：</h2><p><strong>A</strong>. Create a Lambda function deployment package consisting of code and any dependencies<br>.创建包含代码和任何依赖项的 Lambda 函数部署程序包</p><p><strong>B</strong>. Develop each app in a separate Docker container and deploy using CloudFormation<br>.在单独的 Docker 容器中开发每个应用程序，并使用 CloudFormation 进行部署</p><p><strong>C</strong>. Develop each app in one Docker container and deploy using Elastic Beanstalk<br>.在一个 Docker 容器中开发每个应用程序，并使用 Elastic Beanstalk 进行部署</p><p><strong>D</strong>. Develop each app in a separate Docker container and deploy using Elastic Beanstalk<br>.在单独的 Docker 容器中开发每个应用程序，并使用 Elastic Beanstalk 进行部署</p><p>正确答案是D，因为有了Elastic Beanstalk，每个应用程序都可以部署为一个单独的Docker容器，参考AWS文档-Elastic Beanstalk Create Deploy Docker，Elastic Beanstalk支持从Docker容器部署Web应用程序。使用 Docker 容器，您可以定义自己的运行时环境。您可以选择自己的平台、编程语言和其他平台不支持的任何应用程序依赖项（例如包管理器或工具）。Docker 容器是独立的，包括 Web 应用程序运行所需的所有配置信息和软件，通过将 Docker 与 Elastic Beanstalk 结合使用，您拥有了一个自动处理容量预置、负载均衡、扩展和应用程序运行状况监控详细信息的基础设施。您可以在支持与 Elastic Beanstalk 集成的各种服务（包括但不限于 VPC、RDS 和 IAM）的环境中管理 Web 应用程序。</p><h2 id="84-组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到-AWS，并且需要-AWS-解决方案。如何以最低的成本满足这一要求？"><a href="#84-组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到-AWS，并且需要-AWS-解决方案。如何以最低的成本满足这一要求？" class="headerlink" title="84.组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到 AWS，并且需要 AWS 解决方案。如何以最低的成本满足这一要求？"></a>84.组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到 AWS，并且需要 AWS 解决方案。如何以最低的成本满足这一要求？</h2><p><strong>A</strong>. Use Amazon Glacier for regular storage and Amazon S3 for archiving data.<br>.使用 Amazon Glacier 进行常规存储，使用 Amazon S3 存档数据。</p><p><strong>B</strong>. Use Amazon EBS for regular storage and Amazon S3 for archiving data.<br>.使用 Amazon EBS 进行常规存储，使用 Amazon S3 存档数据。</p><p><strong>C</strong>. Use Amazon S3 for regular storage and Amazon Glacier for archiving data.<br>.使用 Amazon S3 进行常规存储，使用 Amazon Glacier 存档数据。</p><p><strong>D</strong>. Use Amazon EBS for archiving data and Amazon Glacier for regular storage.<br>.使用 Amazon EBS 存档数据，使用 Amazon Glacier 进行常规存储。</p><p>正确答案是 C，因为 S3 将为具有快速访问功能的存储和用于存档的 Glacier 提供理想的解决方案。可以定义对象转换规则以将对象从 S3 移动到 Glacier。此外，该解决方案具有成本效益，选项A是错误的，因为Glacier无法提供对数据的快速访问，选项B和D是错误的，因为EBS不是一个具有成本效益的解决方案。</p><h2 id="85-作为应用程序架构要求的一部分，您工作的公司已请求能够针对-Elastic-Load-Balancer-中的所有组合日志文件运行分析。在-AWS-环境中，哪些服务用于收集日志和处理日志文件分析？"><a href="#85-作为应用程序架构要求的一部分，您工作的公司已请求能够针对-Elastic-Load-Balancer-中的所有组合日志文件运行分析。在-AWS-环境中，哪些服务用于收集日志和处理日志文件分析？" class="headerlink" title="85.作为应用程序架构要求的一部分，您工作的公司已请求能够针对 Elastic Load Balancer 中的所有组合日志文件运行分析。在 AWS 环境中，哪些服务用于收集日志和处理日志文件分析？"></a>85.作为应用程序架构要求的一部分，您工作的公司已请求能够针对 Elastic Load Balancer 中的所有组合日志文件运行分析。在 AWS 环境中，哪些服务用于收集日志和处理日志文件分析？</h2><p><strong>A</strong>. Amazon S3 for storing the ELB log files and EC2 for processing the log files in analysis<br>.Amazon S3 用于存储 ELB 日志文件，EC2 用于处理分析中的日志文件</p><p><strong>B</strong>. Amazon EC2 for storing and processing the log files<br>.用于存储和处理日志文件的 Amazon EC2</p><p><strong>C</strong>. Amazon DynamoDB to store the logs and EC2 for running custom log analysis scripts<br>.Amazon DynamoDB 用于存储日志，EC2 用于运行自定义日志分析脚本</p><p><strong>D</strong>. Amazon S3 for storing ELB log files and Amazon EMR for processing the log files in analysis<br>.Amazon S3 用于存储 ELB 日志文件，Amazon EMR 用于在分析中处理日志文件</p><p>正确答案是D，因为S3可用于存储ELB日志文件，并让EMR执行相同的分析，选项A是错误的，因为您需要在EC2实例上部署应用程序，并且它处理EMR开箱即用的分布式并行处理，选项B和C是错误的，因为DynamoDB和EC2不适合存储日志。</p><h2 id="86-一家公司正在使用托管-VPN-连接来连接其本地数据中心。他们想监控-vpn-何时出现故障。他们如何实施监控？"><a href="#86-一家公司正在使用托管-VPN-连接来连接其本地数据中心。他们想监控-vpn-何时出现故障。他们如何实施监控？" class="headerlink" title="86.一家公司正在使用托管 VPN 连接来连接其本地数据中心。他们想监控 vpn 何时出现故障。他们如何实施监控？"></a>86.一家公司正在使用托管 VPN 连接来连接其本地数据中心。他们想监控 vpn 何时出现故障。他们如何实施监控？</h2><p><strong>A</strong>. Using TunnelState CloudWatch metrics</p><p><strong>B</strong>. Using custom CloudWatch metrics</p><p><strong>C</strong>. Use Lambda function to consume the VPN logs<br>.使用 Lambda 函数使用 VPN 日志</p><p><strong>D</strong>. Create and deploy an external service to ping the VPN endpoint<br>.创建并部署外部服务以 ping VPN 终结点</p><p>正确答案是 A，因为现在可以使用 CloudWatch 监控 VPN 连接，请参阅 AWS 文档 - CloudWatch VPN Monitoring，TunnelState，隧道的状态0 表示 DOWN，1 表示 UP，单位：布尔值</p><h2 id="87-公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种-AWS-服务可以帮助减少延迟？"><a href="#87-公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种-AWS-服务可以帮助减少延迟？" class="headerlink" title="87.公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种 AWS 服务可以帮助减少延迟？"></a>87.公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种 AWS 服务可以帮助减少延迟？</h2><p><strong>A</strong>. Amazon CloudFront with on-premises servers as the origin.<br>.以本地服务器为源的 Amazon CloudFront。</p><p><strong>B</strong>. ELB Application Load Balancer.</p><p><strong>C</strong>. Amazon Route 53 latency-based routing.<br>.Amazon Route 53 基于延迟的路由。</p><p><strong>D</strong>. Amazon EFS to store and serve static files.<br>.Amazon EFS，用于存储和提供静态文件。</p><p>正确答案是 A，因为 CloudFront 可用于缓存静态资源并在本地托管时提供低延迟访问，请参阅 AWS 文档 - CloudFront Origins，CloudFront 支持使用多个 AWS 资源作为源。例如，您可以指定 Amazon S3 存储桶或 MediaStore 容器、MediaPackage 通道或自定义源，例如 Amazon EC2 实例或您自己的 HTTP Web 服务器，选项 B、C 和 D 是错误的，因为它们无助于减少延迟。</p><h2 id="88-解决方案架构师必须满足哪些要求才能指定-Amazon-EC2-实例应停止而不是终止其-Spot-实例中断？（选择两个。"><a href="#88-解决方案架构师必须满足哪些要求才能指定-Amazon-EC2-实例应停止而不是终止其-Spot-实例中断？（选择两个。" class="headerlink" title="88.解决方案架构师必须满足哪些要求才能指定 Amazon EC2 实例应停止而不是终止其 Spot 实例中断？（选择两个。"></a>88.解决方案架构师必须满足哪些要求才能指定 Amazon EC2 实例应停止而不是终止其 Spot 实例中断？（选择两个。</h2><p><strong>A</strong>. The Spot Instance request type must be one-time.<br>.Spot 实例请求类型必须为一次性。</p><p><strong>B</strong>. The Spot Instance request type must be persistent.<br>.Spot 实例请求类型必须是持久的。</p><p><strong>C</strong>. The root volume must be an Amazon EBS volume<br>.根卷必须是 Amazon EBS 卷</p><p><strong>D</strong>. The root volume must be an instance store volume.<br>.根卷必须是实例存储卷。</p><p><strong>E</strong>. The launch configuration is changed.<br>.启动配置已更改。</p><p>确答案是 B 和 C，因为 Spot 实例定义了持久性请求类型，而 EBS 支持的实例允许它们停止和启动，请参阅 AWS 文档 - 启动停止 Spot 实例，Amazon EC2 Spot 现在允许在中断时停止 Amazon EBS 支持的实例，而不是在容量不再以您首选的价格可用时终止。然后，当容量在您的价格和时间要求范围内可用时，Spot 可以通过从停止状态重新启动实例来满足您的请求。要使用此新功能，请在提交持久性 Spot 请求时选择“停止”而不是“终止”作为中断行为。当您选择“停止”时，Spot 将在中断时关闭您的实例。将保存 EBS 根设备和附加的 EBS 卷，并保留其数据。当容量在您的价格和时间要求范围内再次可用时，Spot 将重新启动您的实例。重新启动后，EBS 根设备将从其先前的状态恢复，以前附加的数据卷将重新附加，并且实例将保留其实例 ID，选项 A、D 和 E 是错误的，因为它们无效。</p><h2 id="89-您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到-Amazon-Virtual-Private-Cloud-（VPC）-之前的架构师已经部署了-3-层-VPC。配置如下：-VPC-vpc-2f8tLC447-IGW-ig-2d8bc445-NACL-acl-2080c448-子网和路由表：-Web-服务器的子网-258bc44d-应用程序服务器的子网-248DC44c-数据库服务器的子网-9189c6f9-路由表：rtb-2i8bc449-rtb-238bc44b-关联：-子网-258bc44d：-rtb-2i8bc449-子网-248DC44c：-rtb-238bc44b-子网-9189c6f9：-rtb-238bc44b-您现在可以开始将-EC2-实例部署到-VPC-中了。Web-服务器必须能够直接访问-Internet-应用程序，而数据库服务器不能直接访问-Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从-Internet-检索更新？"><a href="#89-您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到-Amazon-Virtual-Private-Cloud-（VPC）-之前的架构师已经部署了-3-层-VPC。配置如下：-VPC-vpc-2f8tLC447-IGW-ig-2d8bc445-NACL-acl-2080c448-子网和路由表：-Web-服务器的子网-258bc44d-应用程序服务器的子网-248DC44c-数据库服务器的子网-9189c6f9-路由表：rtb-2i8bc449-rtb-238bc44b-关联：-子网-258bc44d：-rtb-2i8bc449-子网-248DC44c：-rtb-238bc44b-子网-9189c6f9：-rtb-238bc44b-您现在可以开始将-EC2-实例部署到-VPC-中了。Web-服务器必须能够直接访问-Internet-应用程序，而数据库服务器不能直接访问-Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从-Internet-检索更新？" class="headerlink" title="89.您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到 Amazon Virtual Private Cloud （VPC） 之前的架构师已经部署了 3 层 VPC。配置如下： VPC vpc-2f8tLC447 IGW ig-2d8bc445 NACL acl-2080c448 子网和路由表： Web 服务器的子网-258bc44d 应用程序服务器的子网-248DC44c 数据库服务器的子网-9189c6f9 路由表：rtb-2i8bc449 rtb-238bc44b 关联： 子网-258bc44d： rtb-2i8bc449 子网-248DC44c： rtb-238bc44b 子网-9189c6f9： rtb-238bc44b 您现在可以开始将 EC2 实例部署到 VPC 中了。Web 服务器必须能够直接访问 Internet 应用程序，而数据库服务器不能直接访问 Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从 Internet 检索更新？"></a>89.您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到 Amazon Virtual Private Cloud （VPC） 之前的架构师已经部署了 3 层 VPC。配置如下： VPC vpc-2f8tLC447 IGW ig-2d8bc445 NACL acl-2080c448 子网和路由表： Web 服务器的子网-258bc44d 应用程序服务器的子网-248DC44c 数据库服务器的子网-9189c6f9 路由表：rtb-2i8bc449 rtb-238bc44b 关联： 子网-258bc44d： rtb-2i8bc449 子网-248DC44c： rtb-238bc44b 子网-9189c6f9： rtb-238bc44b 您现在可以开始将 EC2 实例部署到 VPC 中了。Web 服务器必须能够直接访问 Internet 应用程序，而数据库服务器不能直接访问 Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从 Internet 检索更新？</h2><p><strong>A</strong>. Create a bastion and NAT Instance in subnet-258bc44d and add a route from rtb-238bc44b to subnet-258bc44d.<br>.在 subnet-258bc44d 中创建堡垒和 NAT 实例，并添加从 rtb-238bc44b 到 subnet-258bc44d 的路由。</p><p><strong>B</strong>. Add a route from rtb-238bc44b to igw-2d8bc445 and add a bastion and NAT instance within Subnet-248DC44c.<br>.添加从 rtb-238bc44b 到 igw-2d8bc445 的路由，并在 Subnet-248DC44c 中添加堡垒和 NAT 实例。</p><p><strong>C</strong>. Create a Bastion and NAT Instance in subnet-258bc44d. Add a route from rtb-238bc44b to igw-2d8bc445. And a new NACL that allows access between subnet-258bc44d and subnet-248bc44c.<br>.在 subnet-258bc44d 中创建堡垒和 NAT 实例。添加从 rtb-238bc44b 到 igw-2d8bc445 的路由。以及允许在 subnet-258bc44d 和 subnet-248bc44c 之间进行访问的新 NACL。</p><p><strong>D</strong>. Create a Bastion and NAT instance in subnet-258bc44d and add a route from rtb-238bc44b to the NAT instance.<br>.在 subnet-258bc44d 中创建堡垒和 NAT 实例，并将 rtb-238bc44b 路由添加到 NAT 实例。</p><p>正确答案是 D，因为堡垒和 NAT 应该在公有子网中。由于 Web Server 可以直接访问 Internet，因此子网 subnet-258bc44d 应该是公共的，路由 rtb-2i8bc449 指向 IGW。专用子网的路由 rtb-238bc44b 应指向 NAT 进行传出 Internet 访问，选项 A 是错误的，因为路由应指向 NAT，选项 B 是错误的，因为将 IGW 添加到路由 rtb-238bc44b 会将应用程序和数据库服务器暴露给 Internet。堡垒和 NAT 应该在公共子网中，选项 C 是错误的，因为路由应该指向 NAT 而不是 Internet 网关，否则它将可以访问 Internet。</p><h2 id="90-一家公司在-Amazon-EC2-实例上运行具有单层架构的旧版。磁盘-I-0-较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上-8-点到早上-8-点停止。哪些存储选项最适合此工作负载？"><a href="#90-一家公司在-Amazon-EC2-实例上运行具有单层架构的旧版。磁盘-I-0-较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上-8-点到早上-8-点停止。哪些存储选项最适合此工作负载？" class="headerlink" title="90.一家公司在 Amazon EC2 实例上运行具有单层架构的旧版。磁盘 I/0 较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上 8 点到早上 8 点停止。哪些存储选项最适合此工作负载？"></a>90.一家公司在 Amazon EC2 实例上运行具有单层架构的旧版。磁盘 I/0 较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上 8 点到早上 8 点停止。哪些存储选项最适合此工作负载？</h2><p><strong>A</strong>. Amazon EC2 instance storage</p><p><strong>B</strong>. Amazon EBS General Purpose SSD (gp2) storage</p><p><strong>C</strong>. Amazon S3</p><p><strong>D</strong>. Amazon EBS Provision IOPS SSD (io1) storage</p><p>正确答案是 B，因为使用率很低，偶尔会出现峰值，EBS 通用型 SSD （gp2） 存储将是存储的理想选择。gp2 还提供突增功能来处理偶尔出现的峰值，请参阅 AWS 文档 - EBS gp2 卷，通用型 SSD （gp2） 卷提供经济高效的存储，是各种工作负载的理想选择。这些卷提供个位数毫秒的延迟，并能够在较长时间内突增至 3,000 IOPS。在最低 100 IOPS（33.33 GiB 及以下）和最大 10,000 IOPS（3,334 GiB 及以上）之间，基准性能以每 GiB 卷大小 3 IOPS 的速度线性扩展。AWS 设计 gp2volumes 可在 99% 的时间内提供预置性能。gp2 卷的大小范围从 1 GiB 到 16 TiB，选项 A 是错误的，因为 EC2 实例存储不保持持久性，选项 C 是错误的，因为 S3 是对象存储，无法附加到 EC2 实例，选项 D 是错误的，因为使用率很低，偶尔会出现峰值 gp2 比 io1 更合适。</p><h2 id="91-一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在-ELB-Application-Load-Balancer-后面的-EC2-实例上的-VPC-中运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从-Internet-访问数据库，但群集必须能够从-Internet-获取软件修补程序。哪种-VPC-设计满足这些要求？"><a href="#91-一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在-ELB-Application-Load-Balancer-后面的-EC2-实例上的-VPC-中运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从-Internet-访问数据库，但群集必须能够从-Internet-获取软件修补程序。哪种-VPC-设计满足这些要求？" class="headerlink" title="91.一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在 ELB Application Load Balancer 后面的 EC2 实例上的 VPC 中运行。这些实例在跨多个可用区的 Auto Scaling 组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从 Internet 访问数据库，但群集必须能够从 Internet 获取软件修补程序。哪种 VPC 设计满足这些要求？"></a>91.一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在 ELB Application Load Balancer 后面的 EC2 实例上的 VPC 中运行。这些实例在跨多个可用区的 Auto Scaling 组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从 Internet 访问数据库，但群集必须能够从 Internet 获取软件修补程序。哪种 VPC 设计满足这些要求？</h2><p><strong>A</strong>. Public subnets for both the application tier and the database cluster<br>.应用层和数据库群集的公有子网Public subnets for both the application tier and the database cluster</p><p><strong>B</strong>. Public subnets for the application tier, and private subnets for the database cluster<br>.应用层的公有子网和数据库集群的私有子网</p><p><strong>C</strong>. Public subnets for the application tier and NAT Gateway, and private subnets for the database cluster<br>.应用层和 NAT 网关的公有子网，以及数据库集群的私有子网</p><p><strong>D</strong>. Public subnets for the application tier, and private subnets for the database cluster and NAT Gateway<br>.应用层的公有子网，以及数据库集群和 NAT 网关的私有子网</p><p>正确答案是 C，因为应用层需要位于公共子网中才能从 Internet 访问。数据库集群应托管在私有子网中，因为它们不应从 Internet 访问。但是，数据库集群需要访问互联网才能下载补丁，这可以通过托管在公有子网中的 NAT 网关来完成，请参阅 AWS 文档 - VPC 场景 2</p><h2 id="92-解决方案架构师被要求将存储在-Amazon-S3-上的视频内容从-Amazon-CloudFront-交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？"><a href="#92-解决方案架构师被要求将存储在-Amazon-S3-上的视频内容从-Amazon-CloudFront-交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？" class="headerlink" title="92.解决方案架构师被要求将存储在 Amazon S3 上的视频内容从 Amazon CloudFront 交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？"></a>92.解决方案架构师被要求将存储在 Amazon S3 上的视频内容从 Amazon CloudFront 交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？</h2><p><strong>A</strong>. Configure CloudFront to use signed-URLs to access Amazon S3<br>.将 CloudFront 配置为使用签名 URL 访问 Amazon S3</p><p><strong>B</strong>. Store the videos as private objects in Amazon S3 and let CloudFront serve the objects by using only Origin Access Identity (OAI)<br>.将视频作为私有对象存储在 Amazon S3 中，并让 CloudFront 仅使用源访问身份 （OAI） 提供对象</p><p><strong>C</strong>. Use Amazon S3 static website as the origin of CloudFront, and configure CloudFront to deliver the videos by generating a signed URL for users<br>.使用 Amazon S3 静态网站作为 CloudFront 的源，并将 CloudFront 配置为通过为用户生成签名 URL 来传输视频</p><p><strong>D</strong>. Use OAI for CloudFront to access private S3 objects and select the Restrict Viewer Access option in CloudFront cache behavior to use signed URLs.<br>.使用 OAI for CloudFront 访问私有 S3 对象，并在 CloudFront 缓存行为中选择 Restrict Viewer Access （限制查看器访问） 选项以使用签名 URL。 </p><p>正确答案是 D，因为 S3 存储桶必须是私有的，并且使用源访问身份通过 CloudFront 进行访问控制。需要启用限制访问选项才能使用签名 URL 来防止未经授权的访问，请参阅 AWS 文档 - 在 Amazon CloudFront 中访问私有内容，要在 Amazon CloudFront 中使用私有内容，您需要一个启用了私有内容的 Amazon CloudFront 分配，以及您信任的授权账户列表来访问您的私有内容。从 Amazon CloudFront 控制台的 Create Distribution Wizard （创建分配向导） 中，开始创建 Web 分配。在“Origin Settings”（源设置）部分中，选择您仅为私有内容创建的 Amazon S3 存储桶，并确保选择以下选项：，这将在您的 Amazon S3 存储桶上设置权限，以保护您的内容不被公开访问，但仍允许 CloudFront 访问您的内容。 在“默认缓存行为设置”部分的底部，确保启用“限制查看器访问”选项，并选择“self”作为受信任的签名者。这些签名者被称为受信任的签名者，因为您信任由他们签名的 URL，并允许他们访问您的私有内容。在我们的示例中，我们使用 self 作为唯一的可信签名者，这意味着只有您的账户才能对 URL 进行签名以访问您的 CloudFront 私有内容，选项 A 是错误的，因为解决方案不完整，选项 B 是错误的，因为分配需要启用限制查看器才能仅通过签名 URL 强制访问，选项 C 对于限制 S3 存储桶需要定义的私有访问是错误的。</p><h2 id="93-餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？"><a href="#93-餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？" class="headerlink" title="93.餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？"></a>93.餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？</h2><p><strong>A</strong>. Amazon SNS</p><p><strong>B</strong>. AWS Lambda with sequential dispatch<br>.具有顺序调度功能的 AWS Lambda</p><p><strong>C</strong>. A FIFO queue in Amazon SQS</p><p><strong>D</strong>. A standard queue in Amazon SQS</p><p>正确答案是 C，因为 FIFO SQS 队列可以帮助保持序列的插入顺序，并以相同的顺序进行处理，请参阅 AWS 文档 - SQS FIFO 队列，FIFO（先进先出）队列旨在增强应用程序之间的消息传递，当操作和事件的顺序至关重要时，或者不能容忍重复，选项 A 是错误的，因为 SNS 仅帮助通知，它会将事件发布给所有订阅者，选项 B 是错误的，因为 Lambda 无法保证顺序调度，选项 D 是错误的，因为 SQS 标准队列不保证顺序。</p><h2 id="94-您的公司拥有单独的-AWS-账户用于开发和生产。在开发账户中为每个开发人员分配一个-IAM-用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建-IAM-用户？"><a href="#94-您的公司拥有单独的-AWS-账户用于开发和生产。在开发账户中为每个开发人员分配一个-IAM-用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建-IAM-用户？" class="headerlink" title="94.您的公司拥有单独的 AWS 账户用于开发和生产。在开发账户中为每个开发人员分配一个 IAM 用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建 IAM 用户？"></a>94.您的公司拥有单独的 AWS 账户用于开发和生产。在开发账户中为每个开发人员分配一个 IAM 用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建 IAM 用户？</h2><p><strong>A</strong>. Create an IAM role in the development account. Allow IAM Users in the development account to assume the role<br>.在开发账户中创建 IAM 角色。允许开发账户中的 IAM 用户代入角色</p><p><strong>B</strong>. Create an IAM group in the production account. Grant IAM users in the development account membership in the group<br>.在生产账户中创建 IAM 组。向开发账户中的 IAM 用户授予组成员资格</p><p><strong>C</strong>. Create an IAM role in the production account. Allow IAM users in the development account to assume the role<br>.在生产账户中创建 IAM 角色。允许开发账户中的 IAM 用户代入该角色</p><p><strong>D</strong>. Create an IAM group in the development account Grant IAM users in the development account membership in the group<br>.在开发账户中创建 IAM 组 授予开发账户中的 IAM 用户组成员资格</p><p>正确答案是 C，因为您需要在生产账户中定义一个角色以授予对 S3 存储桶的访问权限，并允许开发账户代入该角色。然后，开发账户可以将对角色的访问权限委托给其 IAM 用户，请参阅 AWS 文档 - IAM 角色跨账户访问，将对一个账户中资源的访问权限授予另一个账户中的可信委托人。角色是授予跨账户访问权限的主要方式。但是，借助 AWS 提供的某些 Web 服务，您可以将策略直接附加到资源（而不是使用角色作为代理）。这些策略称为基于资源的策略，您可以使用它们向另一个 AWS 账户中的委托人授予对资源的访问权限。以下服务支持指定资源的基于资源的策略：Amazon Simple Storage Service （S3） 存储桶、Amazon Glacier 文件库、Amazon Simple Notification Service （SNS） 主题和 Amazon Simple Queue Service （SQS） 队列</p><h2 id="95-哪些情况可能导致发生多可用区-Amazon-RDS-故障转移？（选择二）"><a href="#95-哪些情况可能导致发生多可用区-Amazon-RDS-故障转移？（选择二）" class="headerlink" title="95.哪些情况可能导致发生多可用区 Amazon RDS 故障转移？（选择二）"></a>95.哪些情况可能导致发生多可用区 Amazon RDS 故障转移？（选择二）</h2><p><strong>A</strong>. RDS instance is stopped manually.<br>.RDS实例已手动停止。</p><p><strong>B</strong>. A replica of the RDS instance is created in a different region.<br>.RDS实例的副本是在不同的区域创建的。</p><p><strong>C</strong>. An Availability Zone becomes unavailable.<br>.可用区变得不可用。</p><p><strong>D</strong>. Another master user is created.<br>.将创建另一个主用户。</p><p><strong>E</strong>. A failure of the primary database instance.<br>.主数据库实例失败。</p><p>正确答案是 C 和 E 作为主实例或 AZ 关闭将导致自动故障转移，请参阅 AWS 文档 - RDS Multi-AZ，Amazon RDS 会自动处理故障转移，以便您可以尽快恢复数据库操作，而无需管理干预。如果出现以下任一情况，主数据库实例将自动切换到备用副本：选项 A、B 和 D 是错误的，因为它们不会导致自动故障转移。</p><h2 id="96-您的组织正在使用-ALB-处理服务请求。其中一个-API-请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？"><a href="#96-您的组织正在使用-ALB-处理服务请求。其中一个-API-请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？" class="headerlink" title="96.您的组织正在使用 ALB 处理服务请求。其中一个 API 请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？"></a>96.您的组织正在使用 ALB 处理服务请求。其中一个 API 请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？</h2><p><strong>A</strong>. Track the request using “X-Amzn-Trace-Id” HTTP header<br>.使用“X-Amzn-Trace-Id”HTTP 标头跟踪请求</p><p><strong>B</strong>. Track the request using “X-Amzn-Track-Id” HTTP header<br>.使用“X-Amzn-Track-Id”HTTP 标头跟踪请求</p><p><strong>C</strong>. Track the request using “X-Aws-Track-Id” HTTP header<br>.使用“X-Aws-Track-Id”HTTP 标头跟踪请求</p><p><strong>D</strong>. Track the request using “X-Aws-Trace-Id” HTTP header<br>.使用“X-Aws-Trace-Id”HTTP 标头跟踪请求</p><p>正确答案是 A，因为 ALB 注入了一个标识符“X-Amzn-Trace-Id”，该标识符可用于跨各种服务跟踪请求，请参阅 AWS 文档 - ELB Application Load Balancer，请求跟踪Application Load Balancer 在进入负载均衡器的所有请求上注入新的自定义标识符“X-Amzn-Trace-Id” HTTP 标头。请求跟踪允许您在请求通过构成网站和分布式应用程序的各种服务时通过其唯一 ID 跟踪请求。您可以使用唯一跟踪标识符以单个请求的粒度发现应用程序堆栈中的任何性能或计时问题。</p><h2 id="97-您正在-Amazon-Elastic-Cloud-Compute-（EC2）-上部署必须调用-AWS-API-的应用程序。应使用哪种方法将凭据安全地传递到应用程序？"><a href="#97-您正在-Amazon-Elastic-Cloud-Compute-（EC2）-上部署必须调用-AWS-API-的应用程序。应使用哪种方法将凭据安全地传递到应用程序？" class="headerlink" title="97.您正在 Amazon Elastic Cloud Compute （EC2） 上部署必须调用 AWS API 的应用程序。应使用哪种方法将凭据安全地传递到应用程序？"></a>97.您正在 Amazon Elastic Cloud Compute （EC2） 上部署必须调用 AWS API 的应用程序。应使用哪种方法将凭据安全地传递到应用程序？</h2><p><strong>A</strong>. Pass API credentials to the instance using instance userdata.<br>.使用实例 userdata 将 API 凭证传递到实例。</p><p><strong>B</strong>. Use AWS Identity and Access Management roles for EC2 instances.<br>.将 AWS Identity and Access Management 角色用于 EC2 实例。</p><p><strong>C</strong>. Embed the API credentials into your JAR files.<br>.将 API 凭证嵌入到 JAR 文件中。</p><p><strong>D</strong>. Store API credentials as an object in Amazon Simple Storage Service<br>.将 API 凭证作为对象存储在 Amazon Simple Storage Service 中</p><p>正确答案是 B，因为安全传递凭证可以使用 IAM 角色安全地传递，其中凭证由 AWS 维护并经常轮换，请参阅 AWS 文档 - EC2 实例的 IAM 角色，应用程序必须使用 AWS 凭证签署其 API 请求。因此，如果您是应用程序开发人员，则需要一种策略来管理在 EC2 实例上运行的应用程序的凭证。例如，您可以安全地将 AWS 凭证分发到实例，使这些实例上的应用程序能够使用您的凭证对请求进行签名，同时保护您的凭证免受其他用户的侵害。但是，将凭证安全地分发到每个实例具有挑战性，尤其是 AWS 代表您创建的实例，例如 Spot 实例或 Auto Scaling 组中的实例。在轮换 AWS 凭证时，您还必须能够更新每个实例上的凭证，我们设计了 IAM 角色，以便您的应用程序可以安全地从您的实例发出 API 请求，而无需您管理应用程序使用的安全凭证。您可以委派发出 API 请求的权限，而不是创建和分发 AWS 凭证</p><h2 id="98-解决方案架构师必须为需要非常高的顺序-I-0-的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？"><a href="#98-解决方案架构师必须为需要非常高的顺序-I-0-的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？" class="headerlink" title="98.解决方案架构师必须为需要非常高的顺序 I/0 的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？"></a>98.解决方案架构师必须为需要非常高的顺序 I/0 的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？</h2><p><strong>A</strong>. An Amazon EC2 instance store local SSD volume<br>.Amazon EC2 实例存储本地 SSD 卷</p><p><strong>B</strong>. An Amazon EBS provisioned IOPS SSD volume<br>.Amazon EBS 预置 IOPS SSD 卷</p><p><strong>C</strong>. An Amazon EBS Throughput Optimized HDD volume</p><p><strong>D</strong>. An Amazon EBS general purpose SSD volume<br>.Amazon EBS 通用型 SSD 卷</p><p>正确答案是 C，因为吞吐量优化 HDD 为具有顺序 I/O 的大数据应用程序提供了理想的存储解决方案，请参阅 AWS 文档 - EBS 卷类型，吞吐量优化 HDD （st1） 卷提供低成本的磁性存储，它根据吞吐量而不是 IOPS 来定义性能。此卷类型非常适合大型顺序工作负载，例如 Amazon EMR、ETL、数据仓库和日志处理。不支持可启动的 st1 卷，吞吐量优化的 HDD （st1） 卷虽然类似于 Cold HDD （sc1） 卷，但旨在支持频繁访问的数据，此卷类型针对涉及大型顺序 I/O 的工作负载进行了优化，我们建议工作负载执行小型随机 I/O 的客户使用 gp2</p><h2 id="99-一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种-AWS-服务来运行数据库？"><a href="#99-一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种-AWS-服务来运行数据库？" class="headerlink" title="99.一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种 AWS 服务来运行数据库？"></a>99.一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种 AWS 服务来运行数据库？</h2><p><strong>A</strong>. Amazon S3</p><p><strong>B</strong>. Amazon Aurora</p><p><strong>C</strong>. Amazon DynamoDB</p><p><strong>D</strong>. Amazon Redshift</p><p>正确答案是B，因为Aurora提供了一个高度可扩展的关系型数据库，参考AWS文档-Aurora常见问题，Amazon Aurora是一个关系型数据库引擎，它结合了高端商用数据库的速度和可靠性，以及开源数据库的简单性和成本效益。Amazon Aurora MySQL 的性能是 MySQL 的五倍，无需对大多数 MySQL 应用程序进行任何更改;同样，Amazon Aurora PostgreSQL 的性能是 PostgreSQL 的三倍。Amazon RDS 管理您的 Amazon Aurora 数据库，处理耗时的任务，例如预置、修补、备份、恢复、故障检测和修复。您需要为使用的每个 Amazon Aurora 数据库实例支付简单的月度费用。不需要前期成本或长期承诺，选项 A 是错误的，因为 S3 不是事务数据库，选项 C 是错误的，因为 DynamoDB 不适合需要跨多个表联接的要求，选项 D 是错误的，因为 Redshift 不是事务数据库解决方案。</p><h2 id="100-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索文件并将其上传到-Amazon-S3-存储桶。解决方案架构师应如何设计解决方案来满足这些要求？"><a href="#100-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索文件并将其上传到-Amazon-S3-存储桶。解决方案架构师应如何设计解决方案来满足这些要求？" class="headerlink" title="100.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索文件并将其上传到 Amazon S3 存储桶。解决方案架构师应如何设计解决方案来满足这些要求？"></a>100.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索文件并将其上传到 Amazon S3 存储桶。解决方案架构师应如何设计解决方案来满足这些要求？</h2><p><strong>A</strong>. Use Amazon S3 VPC endpoints<br>.使用 Amazon S3 VPC 终端节点</p><p><strong>B</strong>. Use a NAT Gateway</p><p><strong>C</strong>. Deploy a proxy server</p><p><strong>D</strong>. Use a private Amazon S3 Bucket<br>.使用私有 Amazon S3 存储桶</p><p>正确答案是 A，因为 VPC 终端节点可以帮助应用程序通过 Amazon 网络私下访问 S3，而无需浏览互联网，请参阅 AWS 文档 - VPC 终端节点，VPC 终端节点使您能够将 VPC 私下连接到受支持的 AWS 服务和由 PrivateLink 提供支持的 VPC 终端节点服务，而无需互联网网关、NAT 设备、VPN 连接、 或 AWS Direct Connect 连接。VPC 中的实例不需要公有 IP 地址即可与服务中的资源进行通信。您的 VPC 和其他服务之间的流量不会离开 Amazon 网络，终端节点是虚拟设备。它们是水平扩展、冗余且高度可用的 VPC 组件，允许 VPC 中的实例与服务之间进行通信，而不会对网络流量施加可用性风险或带宽限制。支持以下 AWS 服务：选项 B 是错误的，因为 NAT 网关仍然通过 Internet 路由请求，选项 C 是错误的，因为代理服务器仍会通过 Internet 路由请求，选项 D 是错误的，因为私有 S3 存储桶仍然需要访问 Internet。</p><h2 id="101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？"><a href="#101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？" class="headerlink" title="101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？"></a>101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？</h2><p><strong>A</strong>. Deploy the database on multiple Amazon EC2 instances backed by Amazon EBS across multiple Availability Zones.<br>.跨多个可用区将数据库部署在由 Amazon EBS 支持的多个 Amazon EC2 实例上。</p><p><strong>B</strong>. Use Amazon RDS with a multiple Availability Zone option.<br>.将 Amazon RDS 与多可用区选项结合使用。</p><p><strong>C</strong>. Use RDS with a single Availability Zone option and schedule periodic database snapshots.<br>.将 RDS 与单个可用区选项结合使用，并计划定期数据库快照。</p><p><strong>D</strong>. Use Amazon DynamoDB</p><h2 id="101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？-1"><a href="#101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？-1" class="headerlink" title="101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？"></a>101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？</h2><p><strong>A</strong>. Deploy the database on multiple Amazon EC2 instances backed by Amazon EBS across multiple Availability Zones.<br>.跨多个可用区将数据库部署在由 Amazon EBS 支持的多个 Amazon EC2 实例上。</p><p><strong>B</strong>. Use Amazon RDS with a multiple Availability Zone option.<br>.将 Amazon RDS 与多可用区选项结合使用。</p><p><strong>C</strong>. Use RDS with a single Availability Zone option and schedule periodic database snapshots.<br>.将 RDS 与单个可用区选项结合使用，并计划定期数据库快照。</p><p><strong>D</strong>. Use Amazon DynamoDB</p><p>正确答案是 B，因为 RDS 是最适合结构化数据的选项。RDS提供了易于管理的可管理性，并且具有多可用区选项，可以提供高可用性，请参阅AWS白皮书-存储选项，Amazon RDS非常适合依赖MySQL，Oracle或SQL Server传统关系数据库引擎的现有应用程序。由于 Amazon RDS 提供对本机数据库引擎的完全兼容性和直接访问，因此为这些数据库设计的大多数代码、库和工具都应无需修改即可与 Amazon RDS 配合使用。Amazon RDS 也非常适合具有结构化数据的新应用程序，这些应用程序需要比 Amazon 的 NoSQL 数据库产品 Amazon DynamoDB 提供的更复杂的查询和联接功能，选项 A 是错误的，因为在 EC2 实例上托管数据库不容易管理，选项 C 是错误的，因为具有单个可用区的 RDS 无法提供高可用性。选项 D 是错误的，因为 DynamoDB 不适用于结构化数据。</p><h2 id="102-一家公司正在设计混合-IT-架构，需要在本地数据中心与其-Virtual-Private-Cloud-（VPC）-之间建立私有连接。以下哪项将使公司能够实现这一目标？选择-2-个答案"><a href="#102-一家公司正在设计混合-IT-架构，需要在本地数据中心与其-Virtual-Private-Cloud-（VPC）-之间建立私有连接。以下哪项将使公司能够实现这一目标？选择-2-个答案" class="headerlink" title="102.一家公司正在设计混合 IT 架构，需要在本地数据中心与其 Virtual Private Cloud （VPC） 之间建立私有连接。以下哪项将使公司能够实现这一目标？选择 2 个答案"></a>102.一家公司正在设计混合 IT 架构，需要在本地数据中心与其 Virtual Private Cloud （VPC） 之间建立私有连接。以下哪项将使公司能够实现这一目标？选择 2 个答案</h2><p><strong>A</strong>. AWS DataPipeline</p><p><strong>B</strong>. ClassicLink</p><p><strong>C</strong>. AWS Direct Connect<br>.AWS 云专线</p><p><strong>D</strong>. Amazon Route53</p><p><strong>E</strong>. VPN connection</p><p>正确答案是 C 和 E，因为 VPN 和 Direct Connect 允许本地和 VPC 之间的私有连接，选项 A 是错误的，因为 Data Pipeline 是在存储服务（包括本地服务器）之间移动数据，但会使用 Internet，选项 B 是错误的，因为 ClassicLink 允许您将 EC2-Classic 实例链接到您账户中的 VPC， ，选项 D 是错误的，因为 Route 53 是将请求路由到 VPC 的 DNS 服务。</p><h2 id="103-您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在-AWS-环境中自动修复系统状态检查失败的过程？"><a href="#103-您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在-AWS-环境中自动修复系统状态检查失败的过程？" class="headerlink" title="103.您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在 AWS 环境中自动修复系统状态检查失败的过程？"></a>103.您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在 AWS 环境中自动修复系统状态检查失败的过程？</h2><p><strong>A</strong>. Write a script that queries the EC2 API for each instance status check<br>.编写一个脚本，用于查询每个实例状态检查的 EC2 API</p><p><strong>B</strong>. Create CloudWatch metrics that stop and start the instance based off of status check alarms<br>.创建基于状态检查警报停止和启动实例的 CloudWatch 指标</p><p><strong>C</strong>. Implement a third party monitoring tool such as Nagios<br>.实施第三方监控工具，例如 Nagios</p><p><strong>D</strong>. Write a script that periodically shuts down and starts instances<br>.编写一个定期关闭和启动实例的脚本</p><p>正确答案是 B，因为系统检查无法修复，您需要停止并启动实例，这将在另一台机器上启动实例。CloudWatch 可用于基于系统检查自动执行该过程，请参阅 AWS 文档 - EC2 监控系统实例状态检查</p><h2 id="104-公司的策略要求对存储在-Amazon-S3-中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？"><a href="#104-公司的策略要求对存储在-Amazon-S3-中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？" class="headerlink" title="104.公司的策略要求对存储在 Amazon S3 中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？"></a>104.公司的策略要求对存储在 Amazon S3 中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？</h2><p><strong>A</strong>. AWS CloudHSM</p><p><strong>B</strong>. AWS Trusted Advisor</p><p><strong>C</strong>. Server Side Encryption (SSE-S3)</p><p><strong>D</strong>. Server Side Encryption (SSE-KMS)</p><p>正确答案是 C，因为 SSE-S3 提供 S3 的服务器端加密，S3 为您管理加密密钥，请参阅 AWS 文档 - S3 服务器端加密，将服务器端加密与 Amazon S3 托管密钥结合使用 （SSE-S3） – 每个对象都使用唯一密钥进行加密。作为额外的保护措施，它使用定期轮换的主密钥对密钥本身进行加密。Amazon S3 服务器端加密使用最强大的分组密码之一 256 位高级加密标准 （AES-256） 来加密您的数据，选项 A 是错误的，因为 Cloud HSM 不是无缝的，需要您处理密钥，选项 B 是错误的，因为 Trusted Advisor 不提供加密。AWS Trusted Advisor 是一种在线工具，可为您提供实时指导，帮助您按照 AWS 最佳实践预置资源，选项 D 是错误的，因为它需要您生成和管理密钥，类似于 SSE-S3，但具有一些额外的好处以及使用此服务的一些额外费用。使用信封密钥（即保护数据加密密钥的密钥）有单独的权限，该密钥可针对 S3 中的对象进行未经授权的访问提供额外的保护。SSE-KMS 还为您提供密钥使用时间和使用者的审计跟踪。此外，还可以选择自己创建和管理加密密钥，也可以使用对你、你正在使用的服务和你所在的区域唯一的默认密钥。</p><h2 id="105-一家公司正在-Amazon-Simple-Storage-Service-（S3）-上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择-3-个答案"><a href="#105-一家公司正在-Amazon-Simple-Storage-Service-（S3）-上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择-3-个答案" class="headerlink" title="105.一家公司正在 Amazon Simple Storage Service （S3） 上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择 3 个答案"></a>105.一家公司正在 Amazon Simple Storage Service （S3） 上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择 3 个答案</h2><p><strong>A</strong>. Use Amazon S3 server-side encryption with AWS Key Management Service managed keys.<br>.将 Amazon S3 服务器端加密与 AWS Key Management Service 托管密钥结合使用。</p><p><strong>B</strong>. Use Amazon S3 server-side encryption with customer-provided keys</p><p><strong>C</strong>. Use Amazon S3 server-side encryption with EC2 key pair.<br>.将 Amazon S3 服务器端加密与 EC2 密钥对结合使用。</p><p><strong>D</strong>. Use Amazon S3 bucket policies to restrict access to the data at rest.<br>.使用 Amazon S3 存储桶策略限制对静态数据的访问。</p><p><strong>E</strong>. Encrypt the data on the client-side before ingesting to Amazon S3 using their own master key<br>.在客户端加密数据，然后使用自己的主密钥提取到 Amazon S3</p><p><strong>F</strong>. Use SSL to encrypt the data while in transit to Amazon S3.<br>.使用 SSL 在传输到 Amazon S3 时对数据进行加密。</p><p>正确答案是 A、B 和 E，请参阅 AWS S3 使用加密保护数据，使用 S3 的静态数据加密可以使用服务器端或客户端加密来实现。可以使用 KMS 提供的密钥 （SSE-KMS） 或客户提供的密钥 （SSE-C） 实现 SSE。CSE 可以通过在将数据上传到 S3 之前对数据进行加密，然后在客户端从 S3 下载数据后解密数据来实现，选项 C 是错误的，因为服务器端加密不适用于 EC2 密钥对，选项 D 是错误的，因为存储桶策略只是为了限制对 S3 的访问，选项 F 是错误的，因为它仅针对传输中的数据。</p><h2 id="106-解决方案架构师需要部署基于-node-js-的-Web-应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到-Linux-服务器的部署。使用哪种服务可以满足这些要求？"><a href="#106-解决方案架构师需要部署基于-node-js-的-Web-应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到-Linux-服务器的部署。使用哪种服务可以满足这些要求？" class="headerlink" title="106.解决方案架构师需要部署基于 node.js 的 Web 应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到 Linux 服务器的部署。使用哪种服务可以满足这些要求？"></a>106.解决方案架构师需要部署基于 node.js 的 Web 应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到 Linux 服务器的部署。使用哪种服务可以满足这些要求？</h2><p><strong>A</strong>. Amazon EC2</p><p><strong>B</strong>. Amazon API Gateway</p><p><strong>C</strong>. AWS Elastic Beanstalk</p><p><strong>D</strong>. Amazon EC2 Container Service</p><p>正确答案是 C，因为 Elastic Beanstalk 提供了一个支持 node.js 的托管 Web 应用程序平台。它处理最新补丁和更新的部署，还提供部署版本控制，能够轻松回滚，请参阅 AWS 文档 - Elastic Beanstalk 和部署，AWS Elastic Beanstalk 是一项易于使用的服务，用于在熟悉的服务器（如 Apache）上部署和扩展使用 Java、.NET、PHP、Node.js、Python、Ruby、Go 和 Docker 开发的 Web 应用程序和服务， Nginx、Passenger 和 IIS，您只需上传代码，Elastic Beanstalk 就会自动处理部署，从容量预置、负载均衡、自动扩展到应用程序运行状况监控。同时，您保留对支持应用程序的 AWS 资源的完全控制权，并可以随时访问底层资源，Elastic Beanstalk 为您预置和运营基础设施并管理应用程序堆栈（平台），因此您不必花费时间或开发专业知识。它还将使运行应用程序的底层平台保持最新状态，并提供最新的补丁和更新。相反，您可以专注于编写代码，而不是花时间管理和配置服务器、数据库、负载平衡器、防火墙和网络，选项 A 和 C 是错误的，因为部署和回滚的处理仍然需要处理，选项 B 是错误的，因为 API 网关只提供 API 编排并且需要后端服务。</p><h2 id="107-您已经开始了一项新工作，并且正在审查贵公司在-AWS-上的基础设施-您注意到一个-Web-应用程序，其中-Elastic-Load-Balancer-（ELB）-位于-Auto-Scaling-组中的-Web-实例前面。当您在-CloudWatch-中检查-ELB-的指标时，您会在可用区-（AZ）-A-中看到-4-个正常运行的实例，在可用区-B-中看到-0-个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？"><a href="#107-您已经开始了一项新工作，并且正在审查贵公司在-AWS-上的基础设施-您注意到一个-Web-应用程序，其中-Elastic-Load-Balancer-（ELB）-位于-Auto-Scaling-组中的-Web-实例前面。当您在-CloudWatch-中检查-ELB-的指标时，您会在可用区-（AZ）-A-中看到-4-个正常运行的实例，在可用区-B-中看到-0-个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？" class="headerlink" title="107.您已经开始了一项新工作，并且正在审查贵公司在 AWS 上的基础设施 您注意到一个 Web 应用程序，其中 Elastic Load Balancer （ELB） 位于 Auto Scaling 组中的 Web 实例前面。当您在 CloudWatch 中检查 ELB 的指标时，您会在可用区 （AZ） A 中看到 4 个正常运行的实例，在可用区 B 中看到 0 个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？"></a>107.您已经开始了一项新工作，并且正在审查贵公司在 AWS 上的基础设施 您注意到一个 Web 应用程序，其中 Elastic Load Balancer （ELB） 位于 Auto Scaling 组中的 Web 实例前面。当您在 CloudWatch 中检查 ELB 的指标时，您会在可用区 （AZ） A 中看到 4 个正常运行的实例，在可用区 B 中看到 0 个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？</h2><p><strong>A</strong>. Set the ELB to only be attached to another AZ<br>.将 ELB 设置为仅附加到另一个可用区</p><p><strong>B</strong>. Make sure Auto Scaling is configured to launch in both AZs<br>.确保将 Auto Scaling 配置为在两个可用区中启动</p><p><strong>C</strong>. Make sure your AMI is available in both AZs<br>.确保您的 AMI 在两个可用区中都可用</p><p><strong>D</strong>. Make sure the maximum size of the Auto Scaling Group is greater than 4<br>.确保 Auto Scaling 组的最大大小大于 4</p><p>正确答案是 B，因为 Auto Scaling 组可能未配置为同时使用两个可用区，因此在单个可用区中启动实例，选项 A 是错误的，因为 ELB 可以在单个可用区内启动，但仍然可以将流量路由到两个可用区，选项 C 是错误的，因为 AMI 是区域性的，可用于两个可用区，选项 D 是错误的，因为在扩展的情况下，大于 4 的最大大小只会导致在可用区之间均匀启动超过 4 个实例</p><h2 id="108-需要在-EC2-实例上托管数据库。EBS-卷需要支持高-IOPS-速率，因为数据库上预计会有大量读取和写入请求。哪种-Amazon-EBS-卷类型可以满足此数据库的性能要求？"><a href="#108-需要在-EC2-实例上托管数据库。EBS-卷需要支持高-IOPS-速率，因为数据库上预计会有大量读取和写入请求。哪种-Amazon-EBS-卷类型可以满足此数据库的性能要求？" class="headerlink" title="108.需要在 EC2 实例上托管数据库。EBS 卷需要支持高 IOPS 速率，因为数据库上预计会有大量读取和写入请求。哪种 Amazon EBS 卷类型可以满足此数据库的性能要求？"></a>108.需要在 EC2 实例上托管数据库。EBS 卷需要支持高 IOPS 速率，因为数据库上预计会有大量读取和写入请求。哪种 Amazon EBS 卷类型可以满足此数据库的性能要求？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS Throughput Optimized HDD</p><p><strong>C</strong>. EBS General Purpose SSD</p><p><strong>D</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p>正确答案是 A，因为预配置 IOPS SSD （io1） 卷旨在满足对存储性能和一致性敏感的 I/O 密集型工作负载（尤其是数据库工作负载）的需求。与使用存储桶和积分模型来计算性能的 gp2 不同，io1 卷允许您在创建卷时指定一致的 IOPS 速率，并且 Amazon EBS 在给定年份内 99.9% 的时间内提供预置 IOPS 性能的 10% 以内。</p><h2 id="109-公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？"><a href="#109-公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？" class="headerlink" title="109.公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？"></a>109.公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？</h2><p><strong>A</strong>. AWS Data Pipeline</p><p><strong>B</strong>. Amazon Kinesis Data Streams</p><p><strong>C</strong>. Amazon Redshift</p><p><strong>D</strong>. Amazon S3</p><p>正确答案是 B，因为 Kinesis Data Streams 提供实时可扩展的数据摄取服务，请参阅 AWS 文档 - Kinesis Data Streams，Amazon Kinesis Data Streams （KDS） 是一种可大规模扩展且持久的实时数据流服务。KDS 每秒可以从数十万个来源（如网站点击流、数据库事件流、金融交易、社交媒体源、IT 日志和位置跟踪事件）连续捕获千兆字节的数据。收集的数据以毫秒为单位，可用于实时分析使用案例，例如实时控制面板、实时异常检测、动态定价等，选项 A 是错误的，AWS Data Pipeline 仅帮助传输数据，选项 C 是错误的，因为 Redshift 是一种数据仓库服务，不提供实时摄取，选项 D 是错误的，因为 S3 提供存储并且无法扩展以实时摄取数据作为数据聚合。</p><h2 id="110-您的任务是选择数据存储来保留新应用程序的-GPS-坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种-AWS-服务符合您的要求？"><a href="#110-您的任务是选择数据存储来保留新应用程序的-GPS-坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种-AWS-服务符合您的要求？" class="headerlink" title="110.您的任务是选择数据存储来保留新应用程序的 GPS 坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种 AWS 服务符合您的要求？"></a>110.您的任务是选择数据存储来保留新应用程序的 GPS 坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种 AWS 服务符合您的要求？</h2><p><strong>A</strong>. Amazon Redshift</p><p><strong>B</strong>. Amazon DynamoDB</p><p><strong>C</strong>. Amazon S3</p><p><strong>D</strong>. Amazon RDS</p><p>正确答案是 B，因为 DynamoDB 是由 AWS 管理的 NoSQL 数据存储，可以提供毫秒级延迟，Amazon DynamoDB 是一种快速灵活的 NoSQL 数据库服务，适用于需要一致的个位数毫秒级延迟的所有应用程序。它是一个完全托管的云数据库，支持文档和键值存储模型。其灵活的数据模型、可靠的性能和吞吐能力的自动扩展，使其非常适合移动、Web、游戏、广告技术、物联网和许多其他应用程序，请参阅 AWS 文档 - DynamoDB</p><h2 id="111-您的主管已指示您为其-AWS-账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？"><a href="#111-您的主管已指示您为其-AWS-账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？" class="headerlink" title="111.您的主管已指示您为其 AWS 账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？"></a>111.您的主管已指示您为其 AWS 账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？</h2><p><strong>A</strong>. Pilot Light</p><p><strong>B</strong>. Warm standby</p><p><strong>C</strong>. Multi-Site</p><p><strong>D</strong>. Backup and Restore<br>.备份和恢复</p><h2 id="113-一家公司目前有一个包含-60TB-数据的-Redshift-集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？"><a href="#113-一家公司目前有一个包含-60TB-数据的-Redshift-集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？" class="headerlink" title="113.一家公司目前有一个包含 60TB 数据的 Redshift 集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？"></a>113.一家公司目前有一个包含 60TB 数据的 Redshift 集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？</h2><p><strong>A</strong>. Take a copy of the underlying EBS volumes to S3, and then do Cross-Region Replication.<br>.将底层 EBS 卷复制到 S3，然后执行跨区域复制。</p><p><strong>B</strong>. Enable Cross-Region snapshots for the Redshift Cluster.<br>.为 Redshift 集群启用跨区域快照。</p><p><strong>C</strong>. Create a CloudFormation template to restore the Cluster in another region.<br>.创建 CloudFormation 模板以还原其他区域中的集群。</p><p><strong>D</strong>. Enable Cross Availability Zone snapshots for the Redshift Cluster.<br>.为 Redshift 集群启用跨可用区快照。</p><p>正确答案是 B，因为 Redshift 允许跨区域快照，这可以是在单独的区域中恢复集群，请参阅 AWS 文档 - Redshift 快照，跨区域复制快照会产生数据传输费用。将快照复制到目标区域后，它将变为活动状态并可用于还原目的，选项 A 是错误的，因为 Redshift 不会公开底层卷，选项 C 是错误的，因为 CloudFormation 有助于创建集群，但有助于处理数据，选项 D 是错误的，因为可用区快照不允许跨区域还原。</p><h2 id="114-一家公司正在使用-API-Gateway-和部署阶段来管理每个-API-的多个发布阶段，例如-alpha、beta-和生产。他们希望为-API-中的每个阶段指定不同的-AWS-Lambda-函数名称。如何设计-API-网关？"><a href="#114-一家公司正在使用-API-Gateway-和部署阶段来管理每个-API-的多个发布阶段，例如-alpha、beta-和生产。他们希望为-API-中的每个阶段指定不同的-AWS-Lambda-函数名称。如何设计-API-网关？" class="headerlink" title="114.一家公司正在使用 API Gateway 和部署阶段来管理每个 API 的多个发布阶段，例如 alpha、beta 和生产。他们希望为 API 中的每个阶段指定不同的 AWS Lambda 函数名称。如何设计 API 网关？"></a>114.一家公司正在使用 API Gateway 和部署阶段来管理每个 API 的多个发布阶段，例如 alpha、beta 和生产。他们希望为 API 中的每个阶段指定不同的 AWS Lambda 函数名称。如何设计 API 网关？</h2><p><strong>A</strong>. Swagger extensions .Swagger 扩展</p><p><strong>B</strong>. Stage Variables .阶段变量</p><p><strong>C</strong>. API Gateway variables</p><p><strong>D</strong>. Deployment variables .部署变量</p><p>正确答案是 B，因为阶段变量有助于定义环境变量，这些变量可以为不同的阶段提供不同的配置，请参阅 AWS 文档 - 阶段变量，阶段变量是名称-值对，您可以将其定义为与 API 部署阶段关联的配置属性。它们的作用类似于环境变量，可以在 API 设置和映射模板中使用，例如，您可以在阶段配置中定义阶段变量，然后将其值设置为 API 中方法的 HTTP 集成的 URL 字符串。稍后，您可以使用 API 设置中的关联阶段变量名称引用 URL 字符串。这样，您可以通过将阶段变量值重置为相应的 URL，在每个阶段使用具有不同端点的相同 API 设置。您还可以访问映射模板中的阶段变量，或者将配置参数传递到 AWS Lambda 或 HTTP 后端。</p><h2 id="115-客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到-5-个大型-EC2-实例的负载。然而，在感恩节假期前一周，他们遇到了近-20-个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？"><a href="#115-客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到-5-个大型-EC2-实例的负载。然而，在感恩节假期前一周，他们遇到了近-20-个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？" class="headerlink" title="115.客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到 5 个大型 EC2 实例的负载。然而，在感恩节假期前一周，他们遇到了近 20 个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？"></a>115.客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到 5 个大型 EC2 实例的负载。然而，在感恩节假期前一周，他们遇到了近 20 个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？</h2><p><strong>A</strong>. Keep only 10 instances running and manually launch 10 instances every day during office hours.<br>.每天只运行 10 个实例，并在办公时间手动启动 10 个实例。</p><p><strong>B</strong>. Setup to run 10 instances during the pre-vacation period and only scale up during the office time by launching 10 more instances using the Auto Scaling schedule.<br>.设置为在假期前期间运行 10 个实例，并且仅在办公时间内通过使用 Auto Scaling 计划再启动 10 个实例来扩展。</p><p><strong>C</strong>. During the pre-vacation period setup a scenario where the organization has 15 instances running and 5 instances to scale up and down using Auto Scaling based on the network I/O policy.<br>.在假期前期间，设置一个场景，其中组织有 15 个实例正在运行，5 个实例可以使用基于网络 I/O 策略的 Auto Scaling 进行扩展和缩减。</p><p><strong>D</strong>. During the pre-vacation period setup 20 instances to run continuously.<br>.在假期前期间，设置 20 个实例以连续运行。</p><p>正确答案是 B 在运行 10 个实例时具有成本效益，并且仅在办公时间启动 10 个实例，选项 A 是错误的，因为手动启动实例很麻烦且不具有成本效益，选项 C 是错误的，因为与 B 相比运行 15 个实例不具有成本效益，选项 D 是错误的，因为始终运行 20 个实例是开销，因为它并不总是需要并且不具有成本效益</p><h2 id="116-一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种-Linux-EC2-实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？"><a href="#116-一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种-Linux-EC2-实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？" class="headerlink" title="116.一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种 Linux EC2 实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？"></a>116.一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种 Linux EC2 实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon EFS</p><p><strong>C</strong>. Amazon S3</p><p><strong>D</strong>. Amazon EC2 Instance store</p><p>正确答案是 C，因为 EFS 提供了一个能够操作大文件的共享文件系统，请参阅 AWS 文档 - EFS 和 EFS 性能，Amazon EFS 提供文件系统访问语义，例如强大的数据一致性和文件锁定，视频编辑、演播室制作、广播处理、声音设计和渲染等媒体工作流程通常依赖于共享存储来操作大文件。具有高吞吐量和共享文件访问的强大数据一致性模型可以缩短执行这些作业所需的时间，并将多个本地文件存储库整合到一个位置供所有用户使用。选项 A 和 D 是错误的，因为 EBS 和实例存储卷无法共享，选项 B 是错误的，因为 S3 可以共享， 但是，对于操作大文件并不理想。</p><h2 id="117-您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的图片，并为您提供最高的灵活性来轮换凭证？"><a href="#117-您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的图片，并为您提供最高的灵活性来轮换凭证？" class="headerlink" title="117.您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在 Amazon Simple Storage Service （S3） 存储桶中的图片，并为您提供最高的灵活性来轮换凭证？"></a>117.您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在 Amazon Simple Storage Service （S3） 存储桶中的图片，并为您提供最高的灵活性来轮换凭证？</h2><p><strong>A</strong>. Identity federation based on AWS Security Token Service (STS) using an AWS Identity and Access Management (IAM) policy for the respective Amazon S3 bucket<br>.基于 AWS Security Token Service （STS） 的联合身份验证，使用相应 Amazon S3 存储桶的 AWS Identity and Access Management （IAM） 策略</p><p><strong>B</strong>. IAM user per registered client with an IAM policy granting Amazon S3 access to the respective bucket<br>.每个注册客户端的 IAM 用户，其 IAM 策略授予对相应存储桶的 Amazon S3 访问权限</p><p><strong>C</strong>. Amazon S3 bucket policies with a conditional statement restricting by IP address<br>.具有按 IP 地址限制的条件语句的 Amazon S3 存储桶策略</p><p><strong>D</strong>. Access Control Lists (ACL) to restrict access to selected AWS accounts<br>.访问控制列表 （ACL），用于限制对选定 AWS 账户的访问</p><p>正确答案是 A，因为这里轮换凭证的最大灵活性的关键点是使用 AWS 使用 STS 维护和管理的临时凭证，请参阅 AWS 文档 - IAM Web 联合身份验证，选项 B、C 和 D 不灵活，需要为每个用户维护。</p><h2 id="118-具有全球用户的网站在-ELB-Application-Load-Balancer-后面的-EC2-实例上运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行，并传输存储在共享-Amazon-EFS-文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？"><a href="#118-具有全球用户的网站在-ELB-Application-Load-Balancer-后面的-EC2-实例上运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行，并传输存储在共享-Amazon-EFS-文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？" class="headerlink" title="118.具有全球用户的网站在 ELB Application Load Balancer 后面的 EC2 实例上运行。这些实例在跨多个可用区的 Auto Scaling 组中运行，并传输存储在共享 Amazon EFS 文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？"></a>118.具有全球用户的网站在 ELB Application Load Balancer 后面的 EC2 实例上运行。这些实例在跨多个可用区的 Auto Scaling 组中运行，并传输存储在共享 Amazon EFS 文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？</h2><p><strong>A</strong>. Move the digital assets to Amazon Glacier.<br>.将数字资产迁移到 Amazon Glacier。</p><p><strong>B</strong>. Cache static content using CloudFront.<br>.使用 CloudFront 缓存静态内容。</p><p><strong>C</strong>. Resize the files so that they are smaller.<br>.调整文件的大小，使其更小。</p><p><strong>D</strong>. Use reserved EC2 Instances.</p><p>正确答案是 B，因为要求是提高下载性能并减少全局用户的系统负载，CloudFront 将帮助缓存内容并为用户提供低延迟访问，请参阅 AWS 文档 - CloudFront 缓存，Amazon CloudFront 是一种 Web 服务，可加快静态和动态 Web 内容的分发速度， 例如 .html、.css、.js 和图像文件。CloudFront 通过称为边缘站点的全球数据中心网络传输您的内容。当用户请求您使用 CloudFront 提供的内容时，用户将被路由到提供最低延迟（时间延迟）的边缘站点，以便以最佳性能交付内容。如果内容已经位于延迟最低的边缘站点中，则 CloudFront 会立即提供它，选项 A 是错误的，因为 Glacier 用于数据存档，选项 C 是错误的，因为它不能解决问题，选项 D 是错误的，因为预留的 EC2 实例有助于降低长期使用的成本，它无助于提高性能。</p><h2 id="119-您使用-S3-运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？"><a href="#119-您使用-S3-运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？" class="headerlink" title="119.您使用 S3 运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？"></a>119.您使用 S3 运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？</h2><p><strong>A</strong>. Remove public read access and use signed URLs with expiry dates<br>.删除公共读取访问权限并使用具有到期日期的签名 URL</p><p><strong>B</strong>. Use CloudFront distributions for static content.<br>.将 CloudFront 分配用于静态内容。</p><p><strong>C</strong>. Block the IPs of the offending websites in Security Groups.<br>.在安全组中屏蔽违规网站的IP。</p><p><strong>D</strong>. Store photos on an EBS volume of the web server.<br>.将照片存储在 Web 服务器的 EBS 卷上。</p><p>正确答案是A，因为网站可以使用有限时间访问的预签名URL并不断刷新，这样其他网站就无法访问它们，请参考AWS文档-S3与预签名URL共享对象，默认情况下所有对象都是私有的。只有对象所有者才有权访问这些对象。但是，对象所有者可以选择通过创建预签名 URL 来与他人共享对象，使用他们自己的安全凭证授予下载对象的限时权限，选项 B 是错误的，因为仍然可以直接访问 CloudFront URL，选项 C 不可扩展，选项 D 不起作用，因为在 EBS 上存储图像仍需要公开。</p><h2 id="120-您计划创建一个-EC2-实例，该实例将创建-S3-对象并修改-CloudWatch-警报。部署此实例的最佳方式是什么？选择正确答案"><a href="#120-您计划创建一个-EC2-实例，该实例将创建-S3-对象并修改-CloudWatch-警报。部署此实例的最佳方式是什么？选择正确答案" class="headerlink" title="120.您计划创建一个 EC2 实例，该实例将创建 S3 对象并修改 CloudWatch 警报。部署此实例的最佳方式是什么？选择正确答案"></a>120.您计划创建一个 EC2 实例，该实例将创建 S3 对象并修改 CloudWatch 警报。部署此实例的最佳方式是什么？选择正确答案</h2><p><strong>A</strong>. Assign an S3 policy to one IAM user and a CloudWatch policy to another IAM user. Have the instance execute tasks as the appropriate IAM user for the given task<br>.将 S3 策略分配给一个 IAM 用户，将 CloudWatch 策略分配给另一个 IAM 用户。让实例以给定任务的相应 IAM 用户身份执行任务</p><p><strong>B</strong>. Assign an S3 policy and a CloudWatch policy to a single IAM user. Have the instance execute tasks as the IAM user<br>.将 S3 策略和 CloudWatch 策略分配给单个 IAM 用户。让实例以 IAM 用户身份执行任务</p><p><strong>C</strong>. Assign an S3 policy and a CloudWatch policy to a single IAM role. Assign the IAM role to the instance at deployment time<br>.将 S3 策略和 CloudWatch 策略分配给单个 IAM 角色。在部署时将 IAM 角色分配给实例</p><p><strong>D</strong>. Assign an S3 policy to one IAM role and a CloudWatch policy to another IAM role. Assign both IAM roles to the EC2 instance at deployment time<br>.将 S3 策略分配给一个 IAM 角色，将 CloudWatch 策略分配给另一个 IAM 角色。在部署时将两个 IAM 角色分配给 EC2 实例</p><p>正确答案是 C，因为方法是创建一个策略，将权限附加到单个 IAM 角色，并分配要启动的角色 EC2 实例，请参阅 AWS 文档 - IAM 最佳实践，选项 A 和 B 是错误的，因为不建议使用 IAM 用户，选项 D 是错误的，因为只能将单个角色附加到 EC2 实例</p><h2 id="121-您的安全团队要求每个-Amazon-ECS-任务都有一个-IAM-策略，该策略将任务的权限限制为仅使用其使用-AWS-服务所需的权限。你怎么能做到这一点？"><a href="#121-您的安全团队要求每个-Amazon-ECS-任务都有一个-IAM-策略，该策略将任务的权限限制为仅使用其使用-AWS-服务所需的权限。你怎么能做到这一点？" class="headerlink" title="121.您的安全团队要求每个 Amazon ECS 任务都有一个 IAM 策略，该策略将任务的权限限制为仅使用其使用 AWS 服务所需的权限。你怎么能做到这一点？"></a>121.您的安全团队要求每个 Amazon ECS 任务都有一个 IAM 策略，该策略将任务的权限限制为仅使用其使用 AWS 服务所需的权限。你怎么能做到这一点？</h2><p><strong>A</strong>. Use IAM roles for Amazon ECS tasks to associate a specific IAM role with each ECS task definition<br>.将 IAM 角色用于 Amazon ECS 任务，将特定 IAM 角色与每个 ECS 任务定义相关联</p><p><strong>B</strong>. Use IAM roles on the Amazon ECS container instances to associate IAM role with each ECS task on that instance<br>.使用 Amazon ECS 容器实例上的 IAM 角色将 IAM 角色与该实例上的每个 ECS 任务相关联</p><p><strong>C</strong>. Connect to each running amazon ECS container instance and add discrete credentials<br>.连接到每个正在运行的 Amazon ECS 容器实例并添加离散凭证</p><p><strong>D</strong>. Reboot each Amazon ECS task programmatically to generate new instance metadata for each task<br>.以编程方式重启每个 Amazon ECS 任务，以便为每个任务生成新的实例元数据</p><p>正确答案是A，因为IAM角色需要与ECS任务定义相关联，请参考AWS文档-ECS任务IAM角色，使用AMC任务的IAM角色可以指定任务中的容器可以使用的IAM角色。应用程序必须使用 AWS 凭证对其 AWS API 请求进行签名，此功能提供了一种用于管理应用程序要使用的凭证的策略，类似于 Amazon EC2 实例配置文件向 EC2 实例提供凭证的方式。您可以将 IAM 角色与 ECS 任务定义或 RunTask API 操作相关联，而不是创建 AWS 凭证并将其分发到容器或使用 EC2 实例的角色。然后，任务容器中的应用程序可以使用 AWS 开发工具包或 CLI 向授权的 AWS 服务发出 API 请求。</p><h2 id="122-您正在为-VPC-环境设计数据泄漏防护解决方案。您希望您的-VPC-实例能够访问-Internet-上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方-CDN-通过其-URL-访问。您希望明确拒绝从-VPC-实例到-Internet-上主机的任何其他出站连接。您会考虑以下哪一项选择？"><a href="#122-您正在为-VPC-环境设计数据泄漏防护解决方案。您希望您的-VPC-实例能够访问-Internet-上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方-CDN-通过其-URL-访问。您希望明确拒绝从-VPC-实例到-Internet-上主机的任何其他出站连接。您会考虑以下哪一项选择？" class="headerlink" title="122.您正在为 VPC 环境设计数据泄漏防护解决方案。您希望您的 VPC 实例能够访问 Internet 上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方 CDN 通过其 URL 访问。您希望明确拒绝从 VPC 实例到 Internet 上主机的任何其他出站连接。您会考虑以下哪一项选择？"></a>122.您正在为 VPC 环境设计数据泄漏防护解决方案。您希望您的 VPC 实例能够访问 Internet 上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方 CDN 通过其 URL 访问。您希望明确拒绝从 VPC 实例到 Internet 上主机的任何其他出站连接。您会考虑以下哪一项选择？</h2><p><strong>A</strong>. Configure a web proxy server in your VPC and enforce URL-based rules for outbound access Remove default routes.<br>.在 VPC 中配置 Web 代理服务器，并强制执行基于 URL 的出站访问规则 删除默认路由。</p><p><strong>B</strong>. Implement security groups and configure outbound rules to only permit traffic to software depots.<br>.实施安全组并配置出站规则，以仅允许流向软件库的流量。</p><p><strong>C</strong>. Move all your instances into private VPC subnets remove default routes from all routing tables and add specific routes to the software depots and distributions only.<br>.将所有实例移动到私有 VPC 子网中，从所有路由表中删除默认路由，并仅将特定路由添加到软件库和分配中。</p><p><strong>D</strong>. Implement network access control lists to all specific destinations, with an Implicit deny as a rule.<br>.对所有特定目标实施网络访问控制列表，并通常使用隐式拒绝。</p><p>正确答案是A，因为安全组和NACL的规则中不能有URL，路由也不能，只能使用IP地址或其他安全组，参考AWS回答，Web代理服务器是目前最常用的代理服务器类型。Web 代理控制 HTTP 和 HTTPS 流量，并具有来自 Web 客户端（如 Web 浏览器、Web 命令行工具、编程工具和 Web 应用程序服务器）的无处不在的支持。SOCKS 代理服务器虽然不如 Web 代理常见，但利用自定义 SOCKS 代理客户端来控制任何类型的 IP 网络流量。无论哪种情况，都必须配置每个 EC2 实例（通常通过初始实例引导或应用程序部署和配置）才能在操作系统或应用程序级别利用代理解决方案。</p><h2 id="123-解决方案架构师需要设计一个-Amazon-RDS-for-MySQL-解决方案，其中用户必须仅使用-SSL-连接进行身份验证。解决方案架构师应该如何设计解决方案？"><a href="#123-解决方案架构师需要设计一个-Amazon-RDS-for-MySQL-解决方案，其中用户必须仅使用-SSL-连接进行身份验证。解决方案架构师应该如何设计解决方案？" class="headerlink" title="123.解决方案架构师需要设计一个 Amazon RDS for MySQL 解决方案，其中用户必须仅使用 SSL 连接进行身份验证。解决方案架构师应该如何设计解决方案？"></a>123.解决方案架构师需要设计一个 Amazon RDS for MySQL 解决方案，其中用户必须仅使用 SSL 连接进行身份验证。解决方案架构师应该如何设计解决方案？</h2><p><strong>A</strong>. Only allow SSL connections through a VPC security group.<br>.仅允许通过 VPC 安全组进行 SSL 连接。</p><p><strong>B</strong>. Use GRANT and ALTER commands with the REQUIRE SSL option for the user.<br>.对用户使用带有 REQUIRE SSL 选项的 GRANT 和 ALTER 命令。</p><p><strong>C</strong>. Connect with a MySQL client that references the public key.<br>.使用引用公钥的 MySQL 客户端进行连接。</p><p><strong>D</strong>. Ensure that the SSL parameters are set in the parameter group at launch.<br>.确保在启动时在参数组中设置了 SSL 参数。</p><p>正确答案是C，至于SSL连接AWS将SSL证书附加到主实例，客户端需要使用公钥进行连接，请参阅AWS文档-RDS MySQL SSL连接，Amazon RDS支持与运行MySQL数据库引擎的数据库实例进行安全套接字层（SSL）连接，Amazon RDS会创建SSL证书，并在Amazon RDS预置实例时在数据库实例上安装该证书。这些证书由证书颁发机构签名。SSL 证书包括数据库实例终端节点作为 SSL 证书的公用名 （CN），以防止欺骗攻击。公有密钥存储在 Amazon RDS 创建的 SSL 证书是受信任的根实体 <a href="https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem.,An">https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem.,An</a> 在大多数情况下应该可以工作，但如果您的应用程序不接受证书链，则可能会失败。如果您的应用程序不接受证书链，您可能需要使用中间证书连接到您的区域，要使用默认的 mysql 客户端加密连接，请使用 –ssl-ca 参数启动 mysql 客户端以引用公钥，如以下示例所示，以下示例显示了如何使用 MySQL 5.7 及更高版本的 –ssl-ca 参数启动客户端。</p><h2 id="124-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"><a href="#124-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题" class="headerlink" title="124.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"></a>124.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题</h2><p><strong>A</strong>. Disable sticky sessions<br>.禁用粘性会话</p><p><strong>B</strong>. Reduce the frequency of the health checks<br>.降低运行状况检查的频率</p><p><strong>C</strong>. Enable cross zone load balancer<br>.启用跨区域负载均衡器</p><p><strong>D</strong>. Amazon recommends using two availability zone behind ELB<br>.Amazon 建议在 ELB 后面使用两个可用区</p><p>正确答案是 A，因为粘性会话可能会导致用户被路由到相同的实例，选项 B 是错误的，因为降低运行状况检查的频率只会帮助确定实例是否正常。对于跨可用区的所有实例都是一样的，选项 C 是错误的，因为启用跨区域负载均衡器只会帮助在实例之间平均路由流量，而不是在可用区之间路由流量，这里似乎不是这种情况，选项 D 是错误的，因为 AWS 建议将实例分散到所有可用可用区以使应用程序高可用</p><h2 id="125-一家新闻公司制作了很多视频。他们希望在-AWS-中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在-5-小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？"><a href="#125-一家新闻公司制作了很多视频。他们希望在-AWS-中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在-5-小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？" class="headerlink" title="125.一家新闻公司制作了很多视频。他们希望在 AWS 中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在 5 小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？"></a>125.一家新闻公司制作了很多视频。他们希望在 AWS 中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在 5 小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？</h2><p><strong>A</strong>. Use AWS S3 Standard<br>.使用 AWS S3 标准</p><p><strong>B</strong>. Use AWS S3 Infrequent Access<br>.使用 AWS S3 不频繁访问</p><p><strong>C</strong>. Use AWS Glacier with Standard retrievals</p><p><strong>D</strong>. Use AWS Glacier with pay for Expedited retrievals as needed.<br>.根据需要使用 AWS Glacier 付费加急检索。</p><p>正确答案是 D，因为 Glacier 提供了最具成本效益的存档解决方案。对于默认为标准检索的正常请求，可以在 3-5 小时内检索视频。对于快速检索，可以提出加急检索请求，但需要额外付费才能在 1-5 分钟内提供视频，请参阅 AWS 文档 - Glacier 常见问题 - 数据检索，问：如何使用标准检索？，要进行标准检索，请将 InitiateJob API 请求中的“Tier”参数设置为“Standard”。如果未指定层，则请求将默认为“标准”，问：什么是加急检索？，加急检索允许您在偶尔需要紧急请求存档子集时快速访问数据。对于除最大档案 （250MB+） 外的所有档案，使用加急检索访问的数据通常在 1 到 5 分钟内可用。有两种类型的加急检索：按需检索和预置检索。按需请求类似于 EC2 按需实例，在绝大多数情况下都可用。预置的请求保证在您需要时可用，选项 A 和 B 是错误的，因为 S3 不是一个具有成本效益的解决方案，选项 C 是错误的，因为标准检索无法在几分钟内获取视频。</p><h2 id="126-您的公司正准备在-AWS-上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的-EC2-实例上运行，这些实例具有多可用区-RDS-MySQL-超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现-RDS-MySQL-上存在读取争用。满足这些要求的最佳方法是什么？选择-2。"><a href="#126-您的公司正准备在-AWS-上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的-EC2-实例上运行，这些实例具有多可用区-RDS-MySQL-超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现-RDS-MySQL-上存在读取争用。满足这些要求的最佳方法是什么？选择-2。" class="headerlink" title="126.您的公司正准备在 AWS 上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的 EC2 实例上运行，这些实例具有多可用区 RDS MySQL 超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现 RDS MySQL 上存在读取争用。满足这些要求的最佳方法是什么？选择 2。"></a>126.您的公司正准备在 AWS 上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的 EC2 实例上运行，这些实例具有多可用区 RDS MySQL 超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现 RDS MySQL 上存在读取争用。满足这些要求的最佳方法是什么？选择 2。</h2><p><strong>A</strong>. Deploy ElastiCache in-memory cache running in each availability zone<br>.部署在每个可用区中运行的 ElastiCache 内存中缓存</p><p><strong>B</strong>. Implement sharding to distribute load to multiple RDS MySQL instances<br>.实施分片以将负载分配给多个 RDS MySQL 实例</p><p><strong>C</strong>. Increase the RDS MySQL Instance size and Implement provisioned IOPS<br>.增加 RDS MySQL 实例大小并实现预置 IOPS</p><p><strong>D</strong>. Add an RDS MySQL read replica in each availability zone<br>.在每个可用区中添加 RDS MySQL 只读副本</p><p>这里的关键点是存在读取争用，正确答案是 A 和 D，因为 RDS 需要使用只读副本或使用 ElastiCache 等缓存解决方案进行横向扩展，选项 B 是错误的，因为这只是一个读取争用，写入工作正常，分片将有助于改进写入，选项 C 是错误的，因为无法扩展到超出限制， 这只是一个读取争用，写入工作正常</p><h2 id="127-一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种-AWS-服务将满足上述要求？"><a href="#127-一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种-AWS-服务将满足上述要求？" class="headerlink" title="127.一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种 AWS 服务将满足上述要求？"></a>127.一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种 AWS 服务将满足上述要求？</h2><p><strong>A</strong>. Amazon S3</p><p><strong>B</strong>. Amazon EBS</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon Storage Gateway VTL</p><p>正确答案是 A，因为 S3 提供了持久、可扩展的对象存储。S3 还允许对文档进行版本控制，这可以帮助用户恢复到以前的版本，以便从覆盖或意外删除中恢复，请参阅 AWS 文档 - S3 版本控制，启用版本控制的存储桶使您能够从意外删除或覆盖中恢复对象。例如：选项 B 是错误的，因为 EBS 是附加到 EC2 实例的持久块存储卷，选项 C 是错误的，因为 EFS 是一种弹性且可扩展的文件存储，虽然它可以帮助共享文档，但它不提供版本控制功能，选项 D 是错误的，因为 AWS Storage Gateway VTL 有助于使用 AWS 存储扩展您的本地 IT 基础设施。</p><h2 id="128-组织已在-EC2-实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？"><a href="#128-组织已在-EC2-实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？" class="headerlink" title="128.组织已在 EC2 实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？"></a>128.组织已在 EC2 实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？</h2><p><strong>A</strong>. Apply the latest patch of OS and always keep it updated.<br>.应用最新的操作系统补丁并始终保持更新。</p><p><strong>B</strong>. Allow only IAM users to connect with the EC2 instances with their own secret access key.<br>.仅允许 IAM 用户使用自己的秘密访问密钥与 EC2 实例连接。</p><p><strong>C</strong>. Disable the password-based login for all the users. All the users should use their own keys to connect with the instance securely.<br>.为所有用户禁用基于密码的登录。所有用户都应使用自己的密钥安全地与实例连接。</p><p><strong>D</strong>. Create a procedure to revoke the access rights of the individual user when they are not required to connect to EC2 instance anymore for the purpose of application configuration.<br>.创建一个过程，当单个用户不再需要连接到 EC2 实例进行应用程序配置时，该用户将撤消其访问权限。</p><p>正确答案是 B，因为 IAM 用户无法使用其访问密钥连接到 EC2 实例。对 EC2 实例的访问由 ssh 密钥管理，请参阅 AWS 文章 - 保护 EC2 实例的提示，选项 A 是错误的，因为 EC2 实例应始终更新为最新补丁，选项 C 是错误的，因为应禁用基于密码的登录，并且对于每个用户，应将其密钥从他们添加到实例中以登录，选项 D 是错误的，因为在不需要时应删除访问权限。</p><h2 id="129-解决方案架构师正在设计一个-Lambda-函数，该函数调用-API-来列出所有正在运行的-Amazon-RDS-实例。请求应如何授权？"><a href="#129-解决方案架构师正在设计一个-Lambda-函数，该函数调用-API-来列出所有正在运行的-Amazon-RDS-实例。请求应如何授权？" class="headerlink" title="129.解决方案架构师正在设计一个 Lambda 函数，该函数调用 API 来列出所有正在运行的 Amazon RDS 实例。请求应如何授权？"></a>129.解决方案架构师正在设计一个 Lambda 函数，该函数调用 API 来列出所有正在运行的 Amazon RDS 实例。请求应如何授权？</h2><p><strong>A</strong>. Create an IAM access and secret key, and store it in the Lambda function<br>.创建 IAM 访问密钥和私有密钥，并将其存储在 Lambda 函数中</p><p><strong>B</strong>. Assign an IAM role to the Lambda function with permissions to list all Amazon RDS instances.<br>.向 Lambda 函数分配一个 IAM 角色，该角色有权列出所有 Amazon RDS 实例。</p><p><strong>C</strong>. Assign an IAM role to Amazon RDS with permissions to list all Amazon RDS instances.<br>.向 Amazon RDS 分配一个 IAM 角色，该角色有权列出所有 Amazon RDS 实例。</p><p><strong>D</strong>. Create an IAM access and secret key and store it in an encrypted RDS database.<br>.创建 IAM 访问密钥和私有密钥，并将其存储在加密的 RDS 数据库中。</p><p>正确答案是 B，因为 Lambda 函数需要分配一个具有列出 RDS 实例权限的角色，请参阅 AWS 文档 - Lambda 权限，每个 Lambda 函数都有一个与之关联的 IAM 角色（执行角色）。您可以在创建 Lambda 函数时指定 IAM 角色。您授予此角色的权限决定了 AWS Lambda 在代入该角色时可以执行的操作。您向 IAM 角色授予的权限有两种类型：选项 A 是错误的，因为不建议使用访问密钥，选项 C 是错误的，因为权限应该授予 Lambda 实例而不是 RDS，选项 D 是错误的，因为不建议使用访问密钥，并且 Lambda 也需要引用 RDS 实例的权限。</p><h2 id="130-一家公用事业公司正在构建一个应用程序，用于存储来自-10-000-多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用-Amazon-DynamoDB-的可扩展性和快速性，您如何以最经济高效的方式实施它？"><a href="#130-一家公用事业公司正在构建一个应用程序，用于存储来自-10-000-多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用-Amazon-DynamoDB-的可扩展性和快速性，您如何以最经济高效的方式实施它？" class="headerlink" title="130.一家公用事业公司正在构建一个应用程序，用于存储来自 10,000 多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用 Amazon DynamoDB 的可扩展性和快速性，您如何以最经济高效的方式实施它？"></a>130.一家公用事业公司正在构建一个应用程序，用于存储来自 10,000 多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用 Amazon DynamoDB 的可扩展性和快速性，您如何以最经济高效的方式实施它？</h2><p><strong>A</strong>. Create tables for each week. Move the data to S3 for archival and delete the old tables<br>.为每周创建表格。将数据移动到 S3 进行存档并删除旧表</p><p><strong>B</strong>. Create tables for each week with the current week configured for higher throughput. Move the data to Glacier for archival and delete the old tables<br>.为每周创建表，并将当前周配置为更高的吞吐量。将数据移动到 Glacier 进行存档并删除旧表</p><p><strong>C</strong>. Create a single table for higher throughput. Move the data to S3 for archival.<br>.创建单个表以提高吞吐量。将数据移动到 S3 进行存档。</p><p><strong>D</strong>. Create a single table for higher throughput. Move the data to Glacier for archival.<br>.创建单个表以提高吞吐量。将数据移动到 Glacier 进行存档。</p><p>正确答案是 B，因为每周的数据提取模式都不同，因此最好为每周定义不同的 DynamoDB 表，并配置当前周更高的预置吞吐量。然后可以将数据移动到 Glacier 并删除旧的 DynamoDB 表，选项 A 是错误的，因为当前一周的表吞吐量需要配置得更高，而 S3 不是存档的理想解决方案，选项 C 和 D 是错误的，因为单个表不会执行并且旧数据不会被删除。</p><h2 id="131-一家公司已启用-CloudTrail-记录其-AWS-账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择-2-个答案"><a href="#131-一家公司已启用-CloudTrail-记录其-AWS-账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择-2-个答案" class="headerlink" title="131.一家公司已启用 CloudTrail 记录其 AWS 账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择 2 个答案"></a>131.一家公司已启用 CloudTrail 记录其 AWS 账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择 2 个答案</h2><p><strong>A</strong>. Enable SSL certificates for the CloudTrail logs.</p><p><strong>B</strong>. CloudTrail, by default, encrypts the logs in S3<br>.默认情况下，CloudTrail 对 S3 中的日志进行加密</p><p><strong>C</strong>. Enable Server-Side Encryption for the trail.<br>.为跟踪启用服务器端加密。</p><p><strong>D</strong>. Enable CloudTrail Log File Integrity Validation.<br>.启用 CloudTrail 日志文件完整性验证。</p><p><strong>E</strong>. Enable Server-Side Encryption for the destination S3 bucket.<br>.为目标 S3 存储桶启用服务器端加密。</p><p><strong>F</strong>. Enable CloudTrail Log File Durability Validation.<br>.启用 CloudTrail 日志文件持久性验证。</p><p>正确答案是 B &amp; D，因为存储在 S3 中的 CloudTrail 日志由 AWS 使用服务器端加密进行加密。CloudTrail 还提供日志文件完整性验证功能，以帮助确定日志是否被篡改，请参阅 AWS 文档 - CloudTrail 加密和日志文件完整性验证，默认情况下，CloudTrail 传输到存储桶的日志文件由 Amazon 服务器端加密和 Amazon S3 托管加密密钥 （SSE-S3） 进行加密，以确定日志文件是否被修改， 在 CloudTrail 交付后删除或保持不变，您可以使用 CloudTrail 日志文件完整性验证。此功能是使用行业标准算法构建的：用于哈希的 SHA-256 和用于数字签名的带有 RSA 的 SHA-256。这使得在不检测的情况下修改、删除或伪造 CloudTrail 日志文件在计算上是不可行的。您可以使用 AWS CLI 在 CloudTrail 传输文件的位置验证文件。</p><h2 id="132-解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个-Linux-应用程序使用。哪些服务符合此要求？"><a href="#132-解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个-Linux-应用程序使用。哪些服务符合此要求？" class="headerlink" title="132.解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个 Linux 应用程序使用。哪些服务符合此要求？"></a>132.解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个 Linux 应用程序使用。哪些服务符合此要求？</h2><p><strong>A</strong>. Amazon EFS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. AWS Storage Gateway</p><p><strong>D</strong>. Amazon EBS</p><p>正确答案是 A，因为 EFS 提供了一个 AWS 托管且可扩展且高度可用的共享文件系统，请参阅 AWS 文档 - EFS，Amazon Elastic File System （Amazon EFS） 提供简单、可扩展、弹性的文件存储，用于 AWS 云服务和本地资源。它易于使用，并提供了一个简单的界面，可让您快速轻松地创建和配置文件系统。Amazon EFS 旨在在不中断应用程序的情况下按需弹性扩展，并在您添加和删除文件时自动扩展和收缩，因此您的应用程序在需要时拥有所需的存储。它旨在提供对数千个 Amazon EC2 实例的大规模并行共享访问，使您的应用程序能够实现高水平的聚合吞吐量和 IOPS，并随着文件系统的增长而扩展，并具有一致的低延迟。作为一项区域性服务，Amazon EFS 旨在实现跨多个可用区冗余存储数据的高可用性和持久性，借助这些功能，Amazon EFS 非常适合支持广泛的使用案例，包括 Web 服务和内容管理、企业应用程序、媒体和娱乐处理工作流、主目录、数据库备份、开发人员工具、容器存储、 和大数据分析工作负载，选项 B 是错误的，因为 S3 是基于对象的存储，选项 C 是错误的，因为 AWS Storage Gateway 是一种混合存储服务，使您的本地应用程序能够无缝使用 AWS 云存储。您可以将该服务用于备份和归档、灾难恢复、云数据处理、存储分层和迁移，选项 D 是错误的，因为 EBS 卷不能在多个实例之间共享。</p><h2 id="171-一家公司托管一个流行的-Web-应用程序。Web-应用程序连接到在私有-VPC-子网中运行的数据库。Web-服务器必须只能由通过-SSL-连接的客户访问。RDS-MySQL-数据库服务器必须只能从-Web-服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。"><a href="#171-一家公司托管一个流行的-Web-应用程序。Web-应用程序连接到在私有-VPC-子网中运行的数据库。Web-服务器必须只能由通过-SSL-连接的客户访问。RDS-MySQL-数据库服务器必须只能从-Web-服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。" class="headerlink" title="171.一家公司托管一个流行的 Web 应用程序。Web 应用程序连接到在私有 VPC 子网中运行的数据库。Web 服务器必须只能由通过 SSL 连接的客户访问。RDS MySQL 数据库服务器必须只能从 Web 服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。"></a>171.一家公司托管一个流行的 Web 应用程序。Web 应用程序连接到在私有 VPC 子网中运行的数据库。Web 服务器必须只能由通过 SSL 连接的客户访问。RDS MySQL 数据库服务器必须只能从 Web 服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。</h2><p><strong>A</strong>. Create a network ACL on the web server’s subnet and allow HTTPS inbound and MySQL outbound. Place both database and web servers on the same subnet.<br>.在 Web 服务器的子网上创建网络 ACL，并允许 HTTPS 入站和 MySQL 出站。将数据库服务器和 Web 服务器放在同一个子网上。</p><p><strong>B</strong>. Open an HTTPS port on the security group for web servers and set the source to 0.0.0.0/0. Open the MySQL port on the database security group and attach it to the MySQL instance. Set the source to Web Server Security Group.<br>.在Web服务器的安全组上打开HTTPS端口，并将源设置为0.0.0.0/0。打开数据库安全组上的 MySQL 端口，并将其附加到 MySQL 实例。将源设置为“Web 服务器安全组”。</p><p><strong>C</strong>. Create a network ACL on the web server’s subnet, allow HTTPS inbound, and specify the source as 0.0.0.0/0. Create a network ACL on a database subnet, allow MySQL port inbound for web servers, and deny all outbound traffic.<br>.在 Web 服务器的子网上创建网络 ACL，允许 HTTPS 入站，并将源指定为 0.0.0.0/0。在数据库子网上创建网络 ACL，允许 Web 服务器的 MySQL 端口入站，并拒绝所有出站流量。</p><p><strong>D</strong>. Open the MySQL port on the security group for web server and set the source to 0.0.0.0/0. Open the HTTPS port on the database security group and attach it to the MySQL instance. Set the source to Web Server Security Group.<br>.在Web服务器的安全组上打开MySQL端口，并将源设置为0.0.0.0/0。打开数据库安全组上的 HTTPS 端口并将其附加到 MySQL 实例。将源设置为“Web 服务器安全组”。</p><p>正确答案是B，因为Web服务器需要在HTTPS上向Internet开放，而MySQL数据库需要打开才能仅接受来自Web服务器的连接，请参阅AWS文档-安全规则参考，Web安全规则，数据库安全规则，选项A是错误的，因为<strong>ACL是无状态的，需要同时启用入站和出站。</strong>选项C是错误的，因为ACL是无状态的，数据库子网需要允许出站流量，选项D是错误的，因为配置相反。MySQL端口需要在DB安全组上打开，HTTPS端口需要在Web服务器安全组上打开。</p><h2 id="172-以下哪项需要自定义-CloudWatch-指标才能监控？"><a href="#172-以下哪项需要自定义-CloudWatch-指标才能监控？" class="headerlink" title="172.以下哪项需要自定义 CloudWatch 指标才能监控？"></a>172.以下哪项需要自定义 CloudWatch 指标才能监控？</h2><p><strong>A</strong>. Memory Utilization of an EC2 instance</p><p><strong>B</strong>. CPU Utilization of an EC2 instance</p><p><strong>C</strong>. Disk usage activity of an EC2 instance<br>.EC2 实例的磁盘使用活动</p><p><strong>D</strong>. Data transfer of an EC2 instance</p><p>正确答案是 A，因为内存利用率没有被捕获，并且需要为内存利用率实现相同的脚本，请参阅 AWS 文档 - 监控 EC2，CloudWatch 依赖于此管理程序提供的信息，它只能看到实例状态的最硬件端部分，包括 CPU 使用率（但不包括负载）、总内存大小（但不包括内存使用率）、 硬盘上的 I/O 操作数（但不是分区布局和空间使用情况）和网络流量（但不是生成它的进程）。</p><h2 id="173-您正在-VPC-内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择-2-个答案"><a href="#173-您正在-VPC-内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择-2-个答案" class="headerlink" title="173.您正在 VPC 内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择 2 个答案"></a>173.您正在 VPC 内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择 2 个答案</h2><p><strong>A</strong>. Configure a security group for every zone. Configure a default allow all rule. Configure explicit deny rules for the zones that shouldn’t be able to communicate with one another<br>.为每个可用区配置一个安全组。配置默认的“全部允许”规则。为不应能够相互通信的区域配置显式拒绝规则</p><p><strong>B</strong>. Configure your instances to use pre-set IP addresses with an IP address range every security zone. Configure NACL to explicitly allow or deny communication between the different IP address ranges, as required for interzone communication<br>.将您的实例配置为使用预设的 IP 地址，每个安全区域都有一个 IP 地址范围。将 NACL 配置为显式允许或拒绝不同 IP 地址范围之间的通信，这是区域间通信的需要</p><p><strong>C</strong>. Configure a security group for every zone. Configure allow rules only between zone that need to be able to communicate with one another. Use implicit deny all rule to block any other traffic<br>.为每个可用区配置一个安全组。仅在需要能够相互通信的区域之间配置允许规则。使用隐式全部拒绝规则阻止任何其他流量</p><p><strong>D</strong>. Configure multiple subnets in your VPC, one for each zone. Configure routing within your VPC in such a way that each subnet only has routes to other subnets with which it needs to communicate, and doesn’t have routes to subnets with which it shouldn’t be able to communicate.<br>.在 VPC 中配置多个子网，每个区域一个子网。在 VPC 中配置路由，使每个子网只有到需要与之通信的其他子网的路由，并且没有到不应与之通信的子网的路由。</p><p>正确答案是 B 和 C，因为可以使用区域中所有实例的安全组或区域级别的 NACL 来控制通信，请参阅 AWS 文档 - VPC 安全性，选项 B 作为 NACL 可用于配置具有 IP 地址的规则以允许或拒绝流量，选项 C 作为安全组可以获取 IP 地址或安全组并可以允许它们。默认值为隐式拒绝，选项 A 错误，因为安全组不允许拒绝规则，选项 D 错误，因为默认路由不可修改，无法使用路由表来确定 VPC 中子网之间的路由。在 VPC 中，所有子网都可以从同一 VPC 中的所有其他子网访问。这是默认行为，无法更改。</p><h2 id="174-您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择-2-个答案"><a href="#174-您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择-2-个答案" class="headerlink" title="174.您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择 2 个答案"></a>174.您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择 2 个答案</h2><p><strong>A</strong>. Use Route 53’s Latency Based Routing and serve the image out of us-west-2 as well as us-east-1<br>.使用 Route 53 的基于延迟的路由，并从 us-west-2 和 us-east-1 中提供映像</p><p><strong>B</strong>. Serve the image out through CloudFront<br>.通过 CloudFront 提供映像</p><p><strong>C</strong>. Serve the image out of S3 so that it isn’t being served out of your web application tier<br>.从 S3 中提供映像，以便它不会从 Web 应用程序层中提供</p><p><strong>D</strong>. Use EBS PIOPs to serve the image faster out of your EC2 instances<br>.使用 EBS PIOP 更快地从 EC2 实例中提供映像</p><p>正确答案是 A 和 B，因为基于 Route 53 延迟的路由可以帮助将用户请求路由到延迟最小的服务器，并且使用 CloudFront，请求可以通过全球边缘站点分发</p><h2 id="175-一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从-Amazon-EC2-实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达-500MB-s。哪种存储类型可以满足此应用程序的性能要求？"><a href="#175-一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从-Amazon-EC2-实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达-500MB-s。哪种存储类型可以满足此应用程序的性能要求？" class="headerlink" title="175.一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从 Amazon EC2 实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达 500MB/s。哪种存储类型可以满足此应用程序的性能要求？"></a>175.一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从 Amazon EC2 实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达 500MB/s。哪种存储类型可以满足此应用程序的性能要求？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS General Purpose SSD</p><p><strong>C</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p><strong>D</strong>. EBS Throughput Optimized HDD</p><p>正确答案是 D，因为吞吐量优化型 HDD 为大型顺序数据提供了理想的存储解决方案，支持 500 miB/s 的吞吐量，请参阅 AWS 文档 - EBS 卷类型，吞吐量优化型 HDD （st1） 卷提供低成本的磁性存储，根据吞吐量而不是 IOPS 来定义性能。此卷类型非常适合大型顺序工作负载，例如 Amazon EMR、ETL、数据仓库和日志处理。不支持可启动的 st1 卷，吞吐量优化的 HDD （st1） 卷虽然类似于 Cold HDD （sc1） 卷，但旨在支持频繁访问的数据，此卷类型针对涉及大型顺序 I/O 的工作负载进行了优化，我们建议工作负载执行小型随机 I/O 的客户使用 gp2</p><h2 id="176-移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？"><a href="#176-移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？" class="headerlink" title="176.移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？"></a>176.移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？</h2><p><strong>A</strong>. Application Load Balancer</p><p><strong>B</strong>. Amazon API Gateway</p><p><strong>C</strong>. Amazon Cognito</p><p><strong>D</strong>. AWS Device Farm</p><p>正确答案是 B，因为 API Gateway 可以为应用程序提供单点接口，以提供与底层服务的松散耦合，请参阅 AWS 文档 - AWS 上的微服务，使用 API Gateway，您可以创建一个 API，充当应用程序从后端服务访问数据、业务逻辑或功能的“前门”， 例如在 Amazon EC2 和 Amazon ECS 上运行的工作负载、在 Lambda 上运行的代码或任何 Web 应用程序。使用 API Gateway 服务定义的 API 对象是一组资源和方法。资源是 API 域中的类型化对象，可能已将数据模型或关系关联到其他资源。可以将每个资源配置为响应一个或多个方法，即标准 HTTP 谓词，如 GET、POST 或 PUT。REST API 可以部署到不同的阶段、版本化以及克隆到新版本，选项 A 是错误的，因为 Application Load Balancer 无助于跨多个底层服务解耦，选项 C 是错误的，因为 Amazon Cognito 允许您快速轻松地向 Web 和移动应用程序添加用户注册、登录和访问控制。Amazon Cognito 可扩展到数百万用户，并支持通过 SAML 2.0 登录社交身份提供商（如 Facebook、Google 和 Amazon）和企业身份提供商，选项 D 是错误的，因为 AWS Device Farm 是一项应用程序测试服务，可让您同时在多个设备上测试 Android、iOS 和 Web 应用程序并与之交互， 或在设备上实时重现问题。</p><h2 id="关于对存储在数据库（即-Amazon-RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案"><a href="#关于对存储在数据库（即-Amazon-RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案" class="headerlink" title="关于对存储在数据库（即 Amazon RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案"></a>关于对存储在数据库（即 Amazon RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案</h2><p><strong>A</strong>. Encryption cannot be enabled on RDS instances unless the keys are not managed by KMS.<br>.除非密钥不受 KMS 管理，否则无法在 RDS 实例上启用加密。</p><p><strong>B</strong>. Encryption can be enabled on RDS instances to encrypt the underlying storage, and this will by default also encrypt snapshots as they are created. No additional configuration needs to be made on the client side for this to work.<br>.可以在 RDS 实例上启用加密来加密底层存储，默认情况下，这也会在创建快照时对其进行加密。无需在客户端进行其他配置即可正常工作。</p><p><strong>C</strong>. Encryption can be enabled on RDS instances to encrypt the underlying storage, and this will by default also encrypt snapshots as they are created. However, some additional configuration needs to be made on the client side for this to work.<br>.可以在 RDS 实例上启用加密来加密底层存储，默认情况下，这也会在创建快照时对其进行加密。但是，需要在客户端进行一些额外的配置才能正常工作。</p><p><strong>D</strong>. Encryption can be enabled on RDS instances to encrypt the underlying storage, but you cannot encrypt snapshots as they are created.<br>.可以在 RDS 实例上启用加密来加密底层存储，但您不能在创建快照时对其进行加密。</p><h2 id="179-您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？"><a href="#179-您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？" class="headerlink" title="179.您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？"></a>179.您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？</h2><p><strong>A</strong>. Leverage Route 53 health checks to automatically fail over to backup site when the primary site becomes unreachable<br>.利用 Route 53 运行状况检查，在主站点无法访问时自动故障转移到备份站点</p><p><strong>B</strong>. Implement the Pilot Light DR architecture so that traffic can be processed seamlessly in case the primary site becomes unreachable<br>.实施 Pilot Light DR 架构，以便在主站点无法访问时可以无缝处理流量</p><p><strong>C</strong>. Implement either Fully Working Low Capacity Standby or Multi-site Active-Active architecture so that the end users will not experience any delay even if the primary site becomes unreachable<br>.实施完全工作的低容量备用或多站点主动-主动体系结构，以便即使主站点无法访问，最终用户也不会遇到任何延迟</p><p><strong>D</strong>. Implement multi-region architecture to ensure high availability<br>.实施多区域架构，确保高可用性</p><p>正确答案是 C，因为要求是没有任何成本限制的最短停机时间灾难恢复，因此最好实施暖备用或多站点双活实施，请参阅 AWS 博客灾难恢复或白皮书</p><h2 id="180-应用程序在单个-AWS-区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种-AWS-服务符合要求？"><a href="#180-应用程序在单个-AWS-区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种-AWS-服务符合要求？" class="headerlink" title="180.应用程序在单个 AWS 区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种 AWS 服务符合要求？"></a>180.应用程序在单个 AWS 区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种 AWS 服务符合要求？</h2><p><strong>A</strong>. Amazon Route 53</p><p><strong>B</strong>. Elastic Load Balancing</p><p><strong>C</strong>. Amazon CloudFront .亚马逊 CloudFront</p><p><strong>D</strong>. Amazon S3 Website hosting.</p><p>正确答案是 A，因为 Route 53 是 AWS 托管的 DNS 服务。它是全局的，可以配置为跨多个区域路由流量，并能够进行运行状况检查和故障转移路由。它还支持主动-主动或主动-被动路由，选项 B 是错误的，因为 ELB 不能跨区域，选项 C 是错误的，因为 CloudFront 仅允许跨边缘站点进行缓存和渲染，选项 D 是错误的，因为 S3 是区域性的，无助于跨区域路由流量。</p><h2 id="181-您有一个业务关键型两层-Web-应用程序，目前部署在单个区域的两个可用区中，使用-Elastic-Load-Balancing-和-Auto-Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且-Auto-Scaling-无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？"><a href="#181-您有一个业务关键型两层-Web-应用程序，目前部署在单个区域的两个可用区中，使用-Elastic-Load-Balancing-和-Auto-Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且-Auto-Scaling-无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？" class="headerlink" title="181.您有一个业务关键型两层 Web 应用程序，目前部署在单个区域的两个可用区中，使用 Elastic Load Balancing 和 Auto Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且 Auto Scaling 无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？"></a>181.您有一个业务关键型两层 Web 应用程序，目前部署在单个区域的两个可用区中，使用 Elastic Load Balancing 和 Auto Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且 Auto Scaling 无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？</h2><p><strong>A</strong>. Deploy in two regions using Weighted Round Robin (WRR), with Auto Scaling minimums set for 100% peak load per region.<br>.使用加权轮询 （WRR） 在两个区域进行部署，并将 Auto Scaling 最小值设置为每个区域 100% 的峰值负载。</p><p><strong>B</strong>. Deploy in three AZs, with Auto Scaling minimum set to handle 50% peak load per zone.<br>.部署在三个可用区中，Auto Scaling 最小值设置为处理每个区域 50% 的峰值负载。</p><p><strong>C</strong>. Deploy in three AZs, with Auto Scaling minimum set to handle 33% peak load per zone.<br>.在三个可用区中部署，将 Auto Scaling 最小值设置为处理每个区域 33% 的峰值负载。</p><p><strong>D</strong>. Deploy in two regions using Weighted Round Robin (WRR), with Auto Scaling minimums set for 50% peak load per region.<br>.使用加权轮询 （WRR） 在两个区域进行部署，并将 Auto Scaling 最小值设置为每个区域 50% 的峰值负载。</p><p>正确答案是 B 作为 3 个可用区，每个可用区有 50%，即使其中一个关闭并且自动扩展无法启动任何实例，50% + 50% LB 处理所有负载，选项 C 是错误的，因为它每个提供 33%，如果一个关闭，其余两个将处理 66% 的负载，选择 A 和 D 是错误的，因为 WRR 需要 Route 53。数据库还需要低延迟的同步复制，这是行不通的。此外，对于 D 来说，50% 不会以任何方式起作用</p><h2 id="182-您正在-AWS-上构建一个大型机密文档-Web-服务器，其所有文档都将存储在-S3-上。其中一项要求是不能直接从-S3-公开访问它，您需要使用-CloudFront-来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案"><a href="#182-您正在-AWS-上构建一个大型机密文档-Web-服务器，其所有文档都将存储在-S3-上。其中一项要求是不能直接从-S3-公开访问它，您需要使用-CloudFront-来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案" class="headerlink" title="182.您正在 AWS 上构建一个大型机密文档 Web 服务器，其所有文档都将存储在 S3 上。其中一项要求是不能直接从 S3 公开访问它，您需要使用 CloudFront 来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案"></a>182.您正在 AWS 上构建一个大型机密文档 Web 服务器，其所有文档都将存储在 S3 上。其中一项要求是不能直接从 S3 公开访问它，您需要使用 CloudFront 来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案</h2><p><strong>A</strong>. Create an Identity and Access Management (IAM) user for CloudFront and grant access to the objects in your S3 bucket to that IAM User.<br>.为 CloudFront 创建 Identity and Access Management （IAM） 用户，并向该 IAM 用户授予对 S3 存储桶中对象的访问权限。</p><p><strong>B</strong>. Create an Origin Access identity (OAI) for Cloud Front and grant access to the objects in your S3 bucket to that OAl.<br>.为 Cloud Front 创建源访问身份 （OAI），并向该 OAl 授予对 S3 存储桶中对象的访问权限。</p><p><strong>C</strong>. Create individual policies for each bucket the documents are stored in and in that policy grant access to only CloudFront.<br>.为存储文档的每个存储桶创建单独的策略，并在该策略中仅授予对 CloudFront 的访问权限。</p><p><strong>D</strong>. Create an S3 bucket policy that lists the CloudFront distribution ID as the Principal and the target bucket as the Amazon Resource Name (ARN).<br>.创建一个 S3 存储桶策略，将 CloudFront 分配 ID 列为委托人，将目标存储桶列为 Amazon 资源名称 （ARN）</p><p>请参考 AWS CloudFront 限制对 S3 的访问，正确答案是 B，源访问身份是与分配关联的特殊 CloudFront 用户。对于 Web 分配，它与 S3 相关联。OAI 允许在不公开 S3 内容的情况下公开内容，选项 A、C 和 D 是错误的，因为它们允许 S3 允许对 CloudFront 进行独占访问，而 CloudFront 能够分发内容。</p><p>请参考 AWS CloudFront 限制对 S3 的访问，正确答案是 B，源访问身份是与分配关联的特殊 CloudFront 用户。对于 Web 分配，它与 S3 相关联。OAI 允许在不公开 S3 内容的情况下公开内容，选项 A、C 和 D 是错误的，因为它们允许 S3 允许对 CloudFront 进行独占访问，而 CloudFront 能够分发内容。</p><h2 id="183-解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？"><a href="#183-解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？" class="headerlink" title="183.解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？"></a>183.解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？</h2><p><strong>A</strong>. Amazon Aurora .亚马逊极光</p><p><strong>B</strong>. Amazon RDS MySQL with Multi-AZ enabled.<br>.启用了多可用区的 Amazon RDS MySQL。</p><p><strong>C</strong>. Amazon DynamoDB .Amazon DynamoDB</p><p><strong>D</strong>. Amazon ElastiCache .Amazon Elasti缓存</p><p>正确答案是 A，因为 Amazon Aurora 通过跨 3 个可用区复制数据并执行数据完整性检查来维护 6 个副本来提供高持久性，请参阅 AWS 文档 - RDS Aurora 常见问题，问：Amazon Aurora 如何提高数据库对磁盘故障的容错能力？，Amazon Aurora 会自动将您的数据库卷划分为 10GB 的段，分布在多个磁盘上。数据库卷的每个 10GB 数据块在三个可用区之间以六种方式进行复制。Amazon Aurora 旨在透明地处理最多两个数据副本的丢失，而不会影响数据库写入可用性，以及最多三个副本的丢失，而不会影响读取可用性。Amazon Aurora 存储还具有自我修复功能。数据块和磁盘会持续扫描错误并自动修复，选项 B 是错误的，因为多可用区 RDS，数据只在 2 个可用区之间复制，选项 C 和 D 是错误的，因为它们不是关系型数据库。</p><h2 id="184-管理员在单个Amazon-EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon-EC2实例分离？"><a href="#184-管理员在单个Amazon-EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon-EC2实例分离？" class="headerlink" title="184.管理员在单个Amazon EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon EC2实例分离？"></a>184.管理员在单个Amazon EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon EC2实例分离？</h2><p><strong>A</strong>. Amazon ELB .Amazon ELB</p><p><strong>B</strong>. Auto Scaling Group<br>.Auto Scaling 组</p><p><strong>C</strong>. Amazon EC2 Security Group<br>.Amazon EC2 安全组</p><p><strong>D</strong>. Amazon SQS .亚马逊 SQS</p><p>正确答案是 A，因为 Elastic Load Balancer 可以帮助为多个底层 EC2 实例提供单个访问点，请参阅 AWS 文档 - ELB，负载均衡器接受来自客户端的传入流量，并将请求路由到一个或多个可用区中的注册目标（例如 EC2 实例）。负载均衡器还会监控其已注册目标的运行状况，并确保它仅将流量路由到正常运行的目标。当负载均衡器检测到运行状况不佳的目标时，它会停止将流量路由到该目标，然后在检测到目标再次正常运行时继续将流量路由到该目标。选项 B 是错误的，因为 Auto Scaling 有助于扩展但不会提供单个访问点，选项 C 是错误的，因为 EC2 安全组充当控制一个或多个实例流量的虚拟防火墙。选项 D 是错误的，因为 SQS 提供完全托管的消息队列服务。</p><h2 id="185-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"><a href="#185-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？" class="headerlink" title="185.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"></a>185.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？</h2><p><strong>A</strong>. A standalone Amazon EC2 instance<br>.独立 Amazon EC2 实例</p><p><strong>B</strong>. Amazon RDS in a Multi-AZ configuration<br>.多可用区配置中的 Amazon RDS</p><p><strong>C</strong>. Amazon EC2 instances in a replication configuration utilizing a single Availability Zone<br>.使用单个可用区的复制配置中的 Amazon EC2 实例</p><p><strong>D</strong>. Amazon EC2 instances in a replication configuration utilizing two different Availability Zones<br>.使用两个不同可用区的复制配置中的 Amazon EC2 实例</p><p>这里的关键点是设计一个具有操作系统权限的 HA 解决方案数据库解决方案，正确答案是 D，因为 RDS 是 AWS 的托管服务，它不提供操作系统权限，并且对于 HA，至少需要在 2 个可用区中存在实例，选项 A 是错误的，因为单个实例不提供 HA，选项 B 是错误的，因为 RDS 不提供操作系统权限，选项 C 是错误的，因为单个可用区不提供 HA</p><h2 id="186-你需要一种解决方案，以便在Amazon-ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。"><a href="#186-你需要一种解决方案，以便在Amazon-ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。" class="headerlink" title="186.你需要一种解决方案，以便在Amazon ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。"></a>186.你需要一种解决方案，以便在Amazon ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。</h2><p><strong>A</strong>. Application Load Balancers support dynamic host port mapping.<br>.Application Load Balancer 支持动态主机端口映射。</p><p><strong>B</strong>. CloudFront custom origins support dynamic host port mapping.<br>.CloudFront 自定义源支持动态主机端口映射。</p><p><strong>C</strong>. All Elastic Load Balancing instances support dynamic host port mapping.<br>.所有 Elastic Load Balancing 实例都支持动态主机端口映射。</p><p><strong>D</strong>. Classic Load Balancers support dynamic host port mapping.<br>.Classic Load Balancer 支持动态主机端口映射。</p><p>正确答案是 A，因为 Application Load Balancer 有助于动态端口映射并在多个 ECS 容器之间均匀分配流量，请参阅 AWS 知识文章 - ECS 动态端口映射，使用 Application Load Balancer 的动态端口映射可以更轻松地从 ECS 集群上的同一 ECS 服务运行多个任务，Classic Load Balancer 要求您在容器实例上静态映射端口号。您不能在同一实例上运行任务的多个副本，因为端口会发生冲突。Application Load Balancer 允许动态端口映射。您可以在同一容器实例上拥有来自单个服务的多个任务。</p><h2 id="187-一家公司要求其开发人员将应用程序日志存储在-S3-存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？"><a href="#187-一家公司要求其开发人员将应用程序日志存储在-S3-存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？" class="headerlink" title="187.一家公司要求其开发人员将应用程序日志存储在 S3 存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？"></a>187.一家公司要求其开发人员将应用程序日志存储在 S3 存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？</h2><p><strong>A</strong>. Create a cron job to detect the stale logs and delete them accordingly.<br>.创建一个 cron 作业来检测过时的日志并相应地删除它们。</p><p><strong>B</strong>. Use a bucket policy to manage the deletion.<br>.使用存储桶策略管理删除操作。</p><p><strong>C</strong>. Use an IAM Policy to manage the deletion.<br>.使用 IAM 策略管理删除操作。</p><p><strong>D</strong>. Use S3 Lifecycle Policies to manage the deletion.<br>.使用 S3 生命周期策略管理删除。</p><p>正确答案是 D，因为 S3 对象生命周期管理有助于在存储类和过期之间自动转换对象，请参阅 AWS 文档 - S3 对象生命周期管理，要管理您的对象，以便在整个生命周期内经济高效地存储它们，请配置它们的生命周期。生命周期配置是一组规则，用于定义 Amazon S3 应用于一组对象的操作。有两种类型的操作：选项A是错误的，尽管可能不具有成本效益，因为它需要实例轮询S3来检查过期项目并删除它们，选项B和C是错误的，因为它们允许对S3存储桶和对象进行访问控制。</p><h2 id="188-您有一个在六个-Amazon-EC2-实例上运行的-Web-应用程序，每个实例消耗大约-45-的资源。您正在使用自动扩展来确保-6-个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的-Amazon-系统映像-（AMI）。您应该做出以下哪项体系结构选择？"><a href="#188-您有一个在六个-Amazon-EC2-实例上运行的-Web-应用程序，每个实例消耗大约-45-的资源。您正在使用自动扩展来确保-6-个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的-Amazon-系统映像-（AMI）。您应该做出以下哪项体系结构选择？" class="headerlink" title="188.您有一个在六个 Amazon EC2 实例上运行的 Web 应用程序，每个实例消耗大约 45% 的资源。您正在使用自动扩展来确保 6 个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的 Amazon 系统映像 （AMI）。您应该做出以下哪项体系结构选择？"></a>188.您有一个在六个 Amazon EC2 实例上运行的 Web 应用程序，每个实例消耗大约 45% 的资源。您正在使用自动扩展来确保 6 个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的 Amazon 系统映像 （AMI）。您应该做出以下哪项体系结构选择？</h2><p><strong>A</strong>. Deploy 6 EC2 instances in one availability zone and use Amazon Elastic Load Balancer.<br>.在一个可用区中部署 6 个 EC2 实例并使用 Amazon Elastic Load Balancer。</p><p><strong>B</strong>. Deploy 3 EC2 instances in one region and 3 in another region and use Amazon Elastic Load Balancer.<br>.在一个区域部署 3 个 EC2 实例，在另一个区域部署 3 个实例，并使用 Amazon Elastic Load Balancer。</p><p><strong>C</strong>. Deploy 3 EC2 instances in one availability zone and 3 in another availability zone and use Amazon Elastic Load Balancer.<br>.在一个可用区中部署 3 个 EC2 实例，在另一个可用区中部署 3 个 EC2 实例，并使用 Amazon Elastic Load Balancer。</p><p><strong>D</strong>. Deploy 2 EC2 instances in three regions and use Amazon Elastic Load Balancer.<br>.在三个区域部署 2 个 EC2 实例并使用 Amazon Elastic Load Balancer。</p><p>正确答案是 C，因为在 2 个可用区中使用 3 个 EC2 实例进行自动扩展将提供高可用性，并且 ELB 将在所有实例上提供平均的流量分配，选项 A 是错误的，因为单个可用区不会提供高可用性，选项 B 和 D 是错误的，因为实例位于不同的区域，除非复制，否则 AMI 将不可用。此外，ELB 是一项区域性服务，无法跨区域将负载分配给实例。</p><h2 id="189-一个组织正在其共享服务-VPC-中构建-Amazon-Redshift-集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？"><a href="#189-一个组织正在其共享服务-VPC-中构建-Amazon-Redshift-集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？" class="headerlink" title="189.一个组织正在其共享服务 VPC 中构建 Amazon Redshift 集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？"></a>189.一个组织正在其共享服务 VPC 中构建 Amazon Redshift 集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？</h2><p><strong>A</strong>. Run the cluster in a different VPC and connect through VPC peering.<br>.在不同的 VPC 中运行集群，并通过 VPC 对等连接。</p><p><strong>B</strong>. Create a database user inside the Amazon Redshift cluster only for users on the network<br>.仅在 Amazon Redshift 集群中为网络上的用户创建数据库用户</p><p><strong>C</strong>. Define a cluster security group for the cluster that allows access from the allowed networks.<br>.为集群定义一个集群安全组，该安全组允许从允许的网络进行访问。</p><p><strong>D</strong>. Only allow access to networks that connect with the shared services network via VPN.<br>.仅允许访问通过 VPN 与共享服务网络连接的网络。</p><p>正确答案是C，因为可以为Redshift集群配置安全组来控制访问，请参阅AWS文档-Redshift安全组，当您预置Amazon Redshift集群时，默认情况下它是锁定的，因此没有人可以访问它。要向其他用户授予对 Amazon Redshift 集群的入站访问权限，请将该集群与安全组关联。如果您使用的是 EC2-Classic 平台，则可以定义集群安全组并将其与集群关联，如下所述。如果您在 EC2-VPC 平台上，则可以使用现有的 Amazon VPC 安全组，也可以定义一个新安全组，然后将其与集群关联，选项 A 和 D 是错误的，因为 VPC 对等互连和 VPN 是连接服务，无法控制流量以确保安全，选项 B 是错误的，因为 Redshift 用户账户在用户级别处理身份验证和授权，并且无法控制网络流量。</p><h2 id="190-一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？"><a href="#190-一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？" class="headerlink" title="190.一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？"></a>190.一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS Throughput Optimized HDD<br>.EBS 吞吐量优化型 HDD</p><p><strong>C</strong>. EBS General Purpose SSD<br>.EBS 通用型固态硬盘</p><p><strong>D</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p>正确答案是 D，因为 Cold HDD （sc1） 卷提供低成本的磁性存储，根据吞吐量而不是 IOPS 来定义性能。sc1 的吞吐量限制低于 st1，非常适合大型顺序冷数据工作负载。如果您需要不频繁地访问数据并希望节省成本，sc1 提供了廉价的块存储。不支持可启动的 sc1 卷。Cold HDD （sc1） 卷虽然类似于吞吐量优化型 HDD （st1） 卷，但旨在支持不经常访问的数据，请参阅 AWS 文档 - EBS 卷类型 - Cold HDD</p><h2 id="191-一位解决方案架构师正在构建一个将数据存储到-DynamoDB-中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？"><a href="#191-一位解决方案架构师正在构建一个将数据存储到-DynamoDB-中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？" class="headerlink" title="191.一位解决方案架构师正在构建一个将数据存储到 DynamoDB 中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？"></a>191.一位解决方案架构师正在构建一个将数据存储到 DynamoDB 中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？</h2><p><strong>A</strong>. Use Amazon RDS read replicas.<br>.使用 Amazon RDS 只读副本。</p><p><strong>B</strong>. Use Amazon CloudFront<br>.使用 Amazon CloudFront</p><p><strong>C</strong>. Use Amazon ElastiCache.<br>.使用 Amazon ElastiCache。</p><p><strong>D</strong>. Use Amazon DynamoDB Accelerator<br>.使用 Amazon DynamoDB Accelerator</p><p>正确答案是 D，因为 DynamoDB Accelerator 有助于在 DynamoDB 中缓存数据并提供 10 倍的性能，请参阅 AWS 文档 - DynamoDB Accelerator，Amazon DynamoDB Accelerator （DAX） 是适用于 DynamoDB 的完全托管、高度可用的内存中缓存，即使在每秒数百万个请求的情况下，也能将性能提高多达 10 倍（从毫秒到微秒）。DAX 可以完成向 DynamoDB 表添加内存中加速所需的所有繁重工作，而无需开发人员管理缓存失效、数据填充或集群管理。现在，您可以专注于为客户构建出色的应用程序，而无需担心大规模性能问题。您无需修改应用程序逻辑，因为 DAX 与现有 DynamoDB API 调用兼容。您只需在 AWS 管理控制台中单击几下或使用 AWS 开发工具包即可启用 DAX。与 DynamoDB 一样，您只需为预置的容量付费，选项 A 是错误的，因为 RDS 只读副本不适用于 DynamoDB，选项 B 是错误的，因为 CloudFront 仅提供边缘级缓存，选项 C 是错误的，因为 ElastiCache 无法提供 DAX 的性能。</p><h2 id="192-您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在-VPC-中运行，该应用程序在应用程序层前面使用-ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？"><a href="#192-您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在-VPC-中运行，该应用程序在应用程序层前面使用-ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？" class="headerlink" title="192.您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在 VPC 中运行，该应用程序在应用程序层前面使用 ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？"></a>192.您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在 VPC 中运行，该应用程序在应用程序层前面使用 ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？</h2><p><strong>A</strong>. EC2 instance running your WAF software is included in an Auto Scaling group and placed in between two Elastic load balancers<br>.运行 WAF 软件的 EC2 实例包含在 Auto Scaling 组中，并放置在两个 Elastic Load Balancer 之间</p><p><strong>B</strong>. Remove all but TLS 1.2 from the ALB and enable Advanced Protocol Filtering This will enable the ALB itself to perform WAF functionality<br>.从 ALB 中删除除 TLS 1.2 之外的所有内容并启用高级协议过滤 这将使 ALB 本身能够执行 WAF 功能</p><p><strong>C</strong>. Add previously identified hostile source IPs as an explicit INBOUND DENY NACL to the web tier subnet<br>.将以前标识的恶意源 IP 作为显式 INBOUND DENY NACL 添加到 Web 层子网</p><p><strong>D</strong>. Use AWS WAF with ALB to protect your web applications from common web exploits<br>.将 AWS WAF 与 ALB 结合使用，以保护您的 Web 应用程序免受常见 Web 攻击</p><p>正确答案是 D，因为 ALB 与 AWS WAF 集成，可用于保护 Web 应用程序免受常见 Web 漏洞的攻击，请参阅 AWS 文档 - ELB Application Load Balancer，Web Application Firewall - 您现在可以使用 AWS WAF 来保护 Application Load Balancer 上的 Web 应用程序。AWS WAF 是一种 Web 应用程序防火墙，可帮助保护您的 Web 应用程序免受可能影响应用程序可用性、危及安全性或消耗过多资源的常见 Web 漏洞的攻击。</p><h2 id="193-一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求"><a href="#193-一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求" class="headerlink" title="193. 一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求"></a>193. 一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求</h2><p><strong>A</strong>. AWS EKS .AWS EKS的</p><p><strong>B</strong>. AWS Lambda .AWS Lambda的</p><p><strong>C</strong>. AWS API Gateway<br>.AWS API 网关</p><p><strong>D</strong>. AWS ELB .AWS ELB（英语：ELB）</p><p>正确答案是 A，因为 Amazon Elastic Container Service for Kubernetes （Amazon EKS） 是一项托管服务，可让您轻松地在 AWS 上运行 Kubernetes，而无需建立或维护自己的 Kubernetes 控制平面。Kubernetes 是一个开源系统，用于自动部署、扩展和管理容器化应用程序。Amazon EKS 跨多个可用区运行 Kubernetes 控制层面实例，以确保高可用性。Amazon EKS 会自动检测和替换运行状况不佳的控制层面实例，并为其提供自动版本升级和修补，请参阅 AWS 文档 - EKS</p><h2 id="194-一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？"><a href="#194-一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？" class="headerlink" title="194.一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？"></a>194.一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？</h2><p><strong>A</strong>. Amazon S3 .亚马逊 S3</p><p><strong>B</strong>. Amazon EBS .亚马逊EBS</p><p><strong>C</strong>. Amazon EFS .亚马逊 EFS</p><p><strong>D</strong>. AWS Storage Gateway - Volume gateway<br>.AWS Storage Gateway - 卷网关</p><p>正确答案是 C，因为 EFS 提供了 AWS 托管的可共享文件存储，能够从多个服务器访问，请参阅 AWS 文档 - EFS，Amazon Elastic File System （Amazon EFS） 为基于 Linux 的工作负载提供了一个简单、可扩展的弹性文件系统，以便与 AWS 云服务和本地资源一起使用。它旨在在不中断应用程序的情况下按需扩展到 PB 级，并在您添加和删除文件时自动增长和收缩，因此您的应用程序在需要时拥有所需的存储。它旨在提供对数千个 Amazon EC2 实例的大规模并行共享访问，使您的应用程序能够以一致的低延迟实现高水平的聚合吞吐量和 IOPS。Amazon EFS 是一项完全托管的服务，无需更改现有应用程序和工具，通过标准文件系统接口提供访问以实现无缝集成，选项 A 是错误的，因为 S3 是对象存储，选项 B 是错误的，因为 EBS 卷附加到实例并且无法在服务器之间共享。选项 D 是错误的，因为 Storage Gateway 是一种混合云存储服务，可将您现有的本地环境与 AWS 云连接起来</p><h2 id="195-应用程序允许制造站点上传文件。每个上传的-3-GB-文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？"><a href="#195-应用程序允许制造站点上传文件。每个上传的-3-GB-文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？" class="headerlink" title="195.应用程序允许制造站点上传文件。每个上传的 3 GB 文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？"></a>195.应用程序允许制造站点上传文件。每个上传的 3 GB 文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？</h2><p><strong>A</strong>. Use a Kinesis Data Delivery Stream to store the file. Use Lambda for processing.<br>.使用 Kinesis Data Delivery Stream 存储文件。使用 Lambda 进行处理。</p><p><strong>B</strong>. Use an SQS queue to store the file, to be accessed by a fleet of EC2 Instances.<br>.使用 SQS 队列存储文件，供 EC2 实例队列访问。</p><p><strong>C</strong>. Store the file in an EBS volume, which can then be accessed by another EC2 Instance for processing.<br>.将文件存储在 EBS 卷中，然后可由另一个 EC2 实例访问该卷进行处理。</p><p><strong>D</strong>. Store the file in an S3 bucket. Use Amazon S3 event notification to invoke a Lambda function for file processing.<br>.将文件存储在 S3 存储桶中。使用 Amazon S3 事件通知调用 Lambda 函数进行文件处理。</p><p>正确答案是 D，因为元数据提取的处理在几秒钟内完成，lambda 可用于元数据提取，S3 用于存储文件。S3 事件通知可以充当调用 lambda 函数的源，请参阅 AWS 文档 - Lambda with S3，Amazon S3 可以将事件（例如，在存储桶中创建对象时）发布到 AWS Lambda，并通过将事件数据作为参数传递来调用您的 Lambda 函数。通过此集成，您可以编写处理 Amazon S3 事件的 Lambda 函数。在 Amazon S3 中，您可以添加存储桶通知配置，用于标识您希望 Amazon S3 发布的事件类型和要调用的 Lambda 函数，选项 A 是错误的，因为 Kinesis 可以与 Lambda 集成，但 Kinesis 不能用于存储超过 1MiB 的消息。检查 Kinesis Data Streams Limit，选项 B 是错误的，因为 SQS 本身不存储文件，需要 S3。持久性 EC2 实例需要处于自动扩展模式才能扩展和处理文件，与 Lambda 相比，这将不那么划算，选项 C 是错误的，因为与 S3 存储相比，EBS 卷很昂贵，与 EC2 相比，与 Lambda 相同。</p><h2 id="196-一位解决方案架构师正在使用-AWS-Lambda-设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？"><a href="#196-一位解决方案架构师正在使用-AWS-Lambda-设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？" class="headerlink" title="196.一位解决方案架构师正在使用 AWS Lambda 设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？"></a>196.一位解决方案架构师正在使用 AWS Lambda 设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？</h2><p><strong>A</strong>. Create a Lambda function for each individual environment.<br>.为每个单独的环境创建一个 Lambda 函数。</p><p><strong>B</strong>. Use Amazon DynamoDB to store environment variables.<br>.使用 Amazon DynamoDB 存储环境变量。</p><p><strong>C</strong>. Use encrypted AWS Lambda environment variables.<br>.使用加密的 AWS Lambda 环境变量。</p><p><strong>D</strong>. Implement a dedicated Lambda function for distributing environment variables.<br>.实施用于分配环境变量的专用 Lambda 函数。</p><p>正确答案是 D，因为 AWS 建议在之前加密变量并使用 Lambda 函数公开它们，这提供了更安全和可扩展的解决方案，请参阅 AWS 文档 - Lambda 环境变量，当您部署 Lambda 函数时，您指定的所有环境变量在部署过程之后（而不是在部署过程中）默认加密。然后，当调用函数时，AWS Lambda 会自动解密它们。如果您需要将敏感信息存储在环境变量中，我们强烈建议您在部署 Lambda 函数之前对该信息进行加密。</p><h2 id="197-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索数据并将其上传到-DynamoDB-表。解决方案架构师应如何设计解决方案来满足这些要求？"><a href="#197-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索数据并将其上传到-DynamoDB-表。解决方案架构师应如何设计解决方案来满足这些要求？" class="headerlink" title="197.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索数据并将其上传到 DynamoDB 表。解决方案架构师应如何设计解决方案来满足这些要求？"></a>197.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索数据并将其上传到 DynamoDB 表。解决方案架构师应如何设计解决方案来满足这些要求？</h2><p><strong>A</strong>. Use a NAT Gateway<br>.使用NAT网关</p><p><strong>B</strong>. Use Amazon VPC endpoints<br>.使用 Amazon VPC 终端节点</p><p><strong>C</strong>. Use a NAT Instance<br>.使用 NAT 实例</p><p><strong>D</strong>. Deploy a proxy server<br>.部署代理服务器</p><p>正确答案是 B，因为 VPC 终端节点可以帮助应用程序通过 Amazon 网络私下访问 DynamoDB，而无需浏览 Internet，请参阅 AWS 文档 - VPC 终端节点，VPC 终端节点使您能够将 VPC 私下连接到受支持的 AWS 服务和由 PrivateLink 提供支持的 VPC 终端节点服务，而无需互联网网关、NAT 设备、VPN 连接、 或 AWS Direct Connect 连接。VPC 中的实例不需要公有 IP 地址即可与服务中的资源进行通信。您的 VPC 和其他服务之间的流量不会离开 Amazon 网络，终端节点是虚拟设备。它们是水平扩展、冗余且高度可用的 VPC 组件，允许 VPC 中的实例与服务之间进行通信，而不会对网络流量施加可用性风险或带宽限制。支持以下AWS服务：选项A和C是错误的，因为NAT网关和NAT实例仍然通过互联网路由请求，选项D是错误的，因为代理服务器仍然会通过互联网路由请求</p><h2 id="198-您需要使用-AWS-为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问-3-个月，并可使用-5-年。哪种-AWS-服务以最具成本效益的方式满足这些要求？"><a href="#198-您需要使用-AWS-为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问-3-个月，并可使用-5-年。哪种-AWS-服务以最具成本效益的方式满足这些要求？" class="headerlink" title="198.您需要使用 AWS 为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问 3 个月，并可使用 5 年。哪种 AWS 服务以最具成本效益的方式满足这些要求？"></a>198.您需要使用 AWS 为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问 3 个月，并可使用 5 年。哪种 AWS 服务以最具成本效益的方式满足这些要求？</h2><p><strong>A</strong>. Use Storage Gateway to store data to S3 and use life-cycle policies to move the data into Redshift for long-time archiving<br>.使用 Storage Gateway 将数据存储到 S3，并使用生命周期策略将数据移动到 Redshift 中进行长期存档</p><p><strong>B</strong>. Use Direct Connect to upload data to S3 and use IAM policies to move the data into Glacier for longtime archiving<br>.使用 Direct Connect 将数据上传到 S3，并使用 IAM 策略将数据移动到 Glacier 中进行长期存档</p><p><strong>C</strong>. Upload the data on EBS, use life-cycle policies to move EBS snapshots into S3 and later into Glacier for long-time archiving<br>.将数据上传到 EBS 上，使用生命周期策略将 EBS 快照移动到 S3 中，然后移动到 Glacier 中进行长期存档</p><p><strong>D</strong>. Upload data to S3 and use life-cycle policies to move the data into Glacier for long-time archiving<br>.将数据上传到 S3 并使用生命周期策略将数据移动到 Glacier 中进行长期存档</p><p>正确答案是 D，因为 S3 对象生命周期管理有助于处理来自各种存储类（包括 Glacier）的对象转换，选项 A 是错误的，因为 Redshift 是一种数据仓库解决方案，选项 B 是错误的，因为 Direct Connect 不具有成本效益并且 IAM 策略对生命周期管理没有帮助，选项 C 是错误的，因为生命周期策略不适用于 EBS</p><h2 id="199-一个组织创建了-10-个-IAM-用户。该组织希望每个-IAM-用户都有权访问单独的-DynamoDB-表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？"><a href="#199-一个组织创建了-10-个-IAM-用户。该组织希望每个-IAM-用户都有权访问单独的-DynamoDB-表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？" class="headerlink" title="199.一个组织创建了 10 个 IAM 用户。该组织希望每个 IAM 用户都有权访问单独的 DynamoDB 表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？"></a>199.一个组织创建了 10 个 IAM 用户。该组织希望每个 IAM 用户都有权访问单独的 DynamoDB 表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？</h2><p><strong>A</strong>. Define the group policy and add a condition which allows the access based on the IAM name<br>.定义组策略并添加允许基于 IAM 名称进行访问的条件</p><p><strong>B</strong>. Create a DynamoDB table with the same name as the IAM user name and define the policy rule which grants access based on the DynamoDB ARN using a variable<br>.创建一个与 IAM 用户名同名的 DynamoDB 表，并使用变量定义基于 DynamoDB ARN 授予访问权限的策略规则</p><p><strong>C</strong>. Create a separate DynamoDB database for each user and configure a policy in the group based on the DB variable<br>.为每个用户创建单独的 DynamoDB 数据库，并根据数据库变量在组中配置策略</p><p><strong>D</strong>. It is not possible to have a group level policy which allows different IAM users to different DynamoDB Tables<br>.不可能有允许不同 IAM 用户访问不同 DynamoDB 表的组级策略</p><p>正确答案是B，因为DynamoDB表可以创建与IAM用户同名，IAM策略规则定义为仅授予对特定表的访问权限。</p><h2 id="200-一家公司需要存档-6TB-的数据。与利益相关者就-8-小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？"><a href="#200-一家公司需要存档-6TB-的数据。与利益相关者就-8-小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？" class="headerlink" title="200.一家公司需要存档 6TB 的数据。与利益相关者就 8 小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？"></a>200.一家公司需要存档 6TB 的数据。与利益相关者就 8 小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？</h2><p><strong>A</strong>. AWS S3 Standard<br>.AWS S3 标准版</p><p><strong>B</strong>. AWS Glacier .AWS 冰川</p><p><strong>C</strong>. AWS S3 Infrequent Access<br>.AWS S3 不频繁访问</p><p><strong>D</strong>. AWS EBS Volumes<br>.AWS EBS 卷</p><p>正确答案是 B，因为 Glacier 提供了最具成本效益的解决方案，标准检索可在 3-5 小时内完成，请参阅 AWS 文档 - Glacier 常见问题，问：什么是标准检索？，标准检索允许您在几个小时内访问您的任何档案。标准检索通常在 3 – 5 小时内完成，问：如何使用标准检索，要进行标准检索，请将 InitiateJob API 请求中的“Tier”参数设置为“Standard”如果未指定层，则请求将默认为“标准”。</p><h2 id="201-您的任务是为您的公司创建-VPC-网络拓扑。VPC-网络必须同时支持面向-Internet-的应用程序和仅通过-VPN-访问的面向内部的应用程序。面向-Internet-和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在-VPC-中创建多少个子网才能满足这些要求？"><a href="#201-您的任务是为您的公司创建-VPC-网络拓扑。VPC-网络必须同时支持面向-Internet-的应用程序和仅通过-VPN-访问的面向内部的应用程序。面向-Internet-和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在-VPC-中创建多少个子网才能满足这些要求？" class="headerlink" title="201.您的任务是为您的公司创建 VPC 网络拓扑。VPC 网络必须同时支持面向 Internet 的应用程序和仅通过 VPN 访问的面向内部的应用程序。面向 Internet 和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在 VPC 中创建多少个子网才能满足这些要求？"></a>201.您的任务是为您的公司创建 VPC 网络拓扑。VPC 网络必须同时支持面向 Internet 的应用程序和仅通过 VPN 访问的面向内部的应用程序。面向 Internet 和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在 VPC 中创建多少个子网才能满足这些要求？</h2><p><strong>A</strong>. 2</p><p><strong>B</strong>. 3</p><p><strong>C</strong>. 4</p><p><strong>D</strong>. 6</p><p>正确答案是 D，因为需要至少 3 个可用区，并且需要在公有子网和私有子网中都有实例以实现高可用性，因此每个可用区需要 6 个子网作为公有子网和私有子网。</p><h2 id="203-您的公司希望利用-AWS-存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？"><a href="#203-您的公司希望利用-AWS-存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？" class="headerlink" title="203.您的公司希望利用 AWS 存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？"></a>203.您的公司希望利用 AWS 存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？</h2><p><strong>A</strong>. Configure the Simple Storage Service S3</p><p><strong>B</strong>. Configure Storage Gateway Cached Volume</p><p><strong>C</strong>. Configure Storage Gateway Stored Volume.</p><p><strong>D</strong>. Configure Amazon Glacier.</p><p>正确答案是C，因为Storage Gateway存储卷有助于备份数据，同时数据也在本地维护，提供低延迟访问</p><p>提问：卷网关与以前可用的网关缓存和网关存储模式之间有什么关系？</p><p>答：卷网关代表支持基于块的卷网关系列，以前称为网关缓存模式和网关存储模式，在缓存卷模式下，你的数据存储在Amazon S3中，并且经常访问的数据的缓存由网关在本地维护。使用此模式，可以节省主存储的成本，最大限度地减少在本地扩展存储的需求，同时保留对最常用数据的低延迟访问，在存储卷模式下，数据存储在本地存储上，卷作为存储在Amazon S3中的Amazon EBS快照异步备份。这提供了持久且廉价的异地备份。例如，如果你需要替换容量进行灾难恢复，你可以将这些备份本地恢复到网关或云中恢复到Amazon EC2.</p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Question bank </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash for Begginners</title>
      <link href="/2023/11/22/Bash%20Basic/"/>
      <url>/2023/11/22/Bash%20Basic/</url>
      
        <content type="html"><![CDATA[<h1 id="Bash-Basic"><a href="#Bash-Basic" class="headerlink" title="Bash Basic"></a>Bash Basic</h1><h2 id="Shell-和-Terminal有什么区别"><a href="#Shell-和-Terminal有什么区别" class="headerlink" title="Shell 和 Terminal有什么区别"></a>Shell 和 Terminal有什么区别</h2><ol><li><p><strong>Shell</strong>：</p><ul><li>Shell 是用户与操作系统交互的接口，特别是在类Unix系统中（比如Linux和macOS）。</li><li>它是一个命令行解释器，提供了一个命令行用户界面，用户可以在其中输入命令，Shell 会解释这些命令并调用操作系统来执行。</li><li>Shell 有许多不同的变种，包括 Bourne Shell (sh), Bourne Again Shell (bash), C Shell (csh), Korn Shell (ksh), Z Shell (zsh) 等。</li><li>Shell 也可以提供编程的功能，比如变量、控制结构（if-then-else, loops）、函数等。</li></ul></li><li><p><strong>Terminal</strong>：</p><ul><li>Terminal，有时被称为终端模拟器，是一个软件程序，用来模拟早期的硬件终端。</li><li>它是一个环境，用户可以在其中使用Shell。你可以在Terminal中启动一个Shell会话，输入命令，看到命令的输出。</li><li>Terminal 程序捕获用户的输入并将其发送到Shell，同时将Shell的输出显示给用户。</li><li>现代的操作系统，如Windows、macOS和Linux，通常都有自己的终端模拟器程序，比如macOS的Terminal.app，Linux的gnome-terminal、konsole等，Windows的Command Prompt和PowerShell等。</li></ul></li></ol><p>简单来说，Shell 是用来解释和执行命令的程序，而 Terminal 是用来与 Shell 交互的界面。在日常使用中，术语 “打开一个终端” 通常意味着启动一个终端程序并在其中运行一个Shell。</p><h2 id="学习Bash的原因"><a href="#学习Bash的原因" class="headerlink" title="学习Bash的原因"></a>学习Bash的原因</h2><p>当你遇见一些需要同时操作许多不同文件的情况或场景的时候，Bash远远会比其他编程语言执行的要快和简单</p><ol><li><p>Bash有很多内建命令，例如cp，mv，rm，grep，find等，这些命令可以直接在命令行中使用，非常适合进行文件操作和文本处理</p></li><li><p>Bash支持管道|和重定向&gt;&gt;,&gt;,&lt; 能够将一个命令的输出非常容易地转换成另一个命令地输入，以此来创建复杂的命令链。</p></li><li><p>Bash可以使用通配符，如*或者？和正则表达式来匹配文件名或文本模式，这在处理多个文件时，非常有用。</p></li><li><p>Bash直接运行在操作系统中，不需要额外的运行时环境或虚拟机。意味着它可以直接访问系统资源和工具。</p></li><li><p>Bash能够允许用户编写复杂的自动化脚本来执行一系列命令，无需编译。</p></li></ol><p>6.最后一点，Bash直接余操作系统的内核交互，是没有额外的抽象层。</p><h2 id="Bash-for-Beginners"><a href="#Bash-for-Beginners" class="headerlink" title="Bash for Beginners"></a>Bash for Beginners</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122144022802.png" alt="image-20231122144022802"></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122145006070.png" alt="image-20231122145006070"></p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>学Bash最好的办法就是不要离开你的Terimnal</p><ol><li>能够帮你学习命令的一个命令 help </li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122145704095.png" alt="image-20231122145704095"></p><ol start="2"><li>能够帮助你学习的第二个命令man</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122150215508.png" alt="image-20231122150215508"></p><ol start="3"><li><p>pwd和cd</p><p>cd的底层逻辑不是记录你去过的地方，而是用一个栈来对你的目录进行推入和弹出</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122151730947.png" alt="image-20231122151730947"></p></li><li><p>tree和ls</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122152044955.png" alt="image-20231122152044955"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122152057732.png"></p><ol start="5"><li>pushd和popd，dirs</li></ol><p>在Bash中，<code>pushd</code> 和 <code>popd</code> 是用来操作目录栈的内建命令，它们与 <code>dirs</code> 命令一起工作，以帮助你在不同的目录之间快速地切换。</p><h3 id="pushd-命令"><a href="#pushd-命令" class="headerlink" title="pushd 命令"></a>pushd 命令</h3><p><code>pushd</code> 命令用于将一个目录添加到目录栈的顶部，并且将你的当前工作目录切换到那个目录。这对于临时切换到另一个目录，执行一些操作，然后返回到原始目录非常有用。</p><p>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pushd</span> /path/to/new/directory</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>/path/to/new/directory</code> 放入目录栈，并且把当前工作目录切换到这个新目录。</p><h3 id="popd-命令"><a href="#popd-命令" class="headerlink" title="popd 命令"></a>popd 命令</h3><p><code>popd</code> 命令用于从目录栈中移除顶部的目录，并将当前工作目录切换到新的栈顶目录。</p><p>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">popd</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，栈顶的目录将被移除，你的当前工作目录将变为之前通过 <code>pushd</code> 添加的下一个目录。</p><h3 id="dirs-命令"><a href="#dirs-命令" class="headerlink" title="dirs 命令"></a>dirs 命令</h3><p><code>dirs</code> 命令用于显示当前目录栈的内容，即你用 <code>pushd</code> 添加的所有目录列表。</p><p>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dirs</span></span><br></pre></td></tr></table></figure><p>这个命令会列出目录栈中的所有目录，通常以空格分隔。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用 <code>pushd</code> 和 <code>popd</code> 的简单示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设当前目录是 /home/user</span></span><br><span class="line"><span class="built_in">pushd</span> /var/www    <span class="comment"># 将 /var/www 添加到目录栈并切换到该目录</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /var/www</span></span><br><span class="line"><span class="built_in">pushd</span> /etc        <span class="comment"># 将 /etc 添加到目录栈并切换到该目录</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /etc</span></span><br><span class="line"><span class="built_in">dirs</span>              <span class="comment"># 显示目录栈内容</span></span><br><span class="line"><span class="comment"># 输出可能是 /etc /var/www /home/user</span></span><br><span class="line"><span class="built_in">popd</span>              <span class="comment"># 移除栈顶目录 (/etc) 并切换到下一个目录 (/var/www)</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /var/www</span></span><br><span class="line"><span class="built_in">popd</span>              <span class="comment"># 移除栈顶目录 (/var/www) 并切换到下一个目录 (/home/user)</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /home/user</span></span><br></pre></td></tr></table></figure><p>使用 <code>pushd</code> 和 <code>popd</code> 可以让你在多个工作目录之间快速切换，而无需手动输入 <code>cd</code> 命令和目录路径。这在编写脚本或进行复杂的文件系统操作时尤其有用。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122152543455.png" alt="image-20231122152543455"></p><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122201845965.png" alt="image-20231122201845965"></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122202023427.png" alt="image-20231122202023427"></p><h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122203644825.png" alt="image-20231122203644825"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122204052818.png" alt="image-20231122204052818"></p><h4 id="标准输出重定向-gt-和-gt-gt"><a href="#标准输出重定向-gt-和-gt-gt" class="headerlink" title="标准输出重定向 (&gt; 和 &gt;&gt;)"></a>标准输出重定向 (<code>&gt;</code> 和 <code>&gt;&gt;</code>)</h4><h5 id="使用-gt-重定向标准输出"><a href="#使用-gt-重定向标准输出" class="headerlink" title="使用 &gt; 重定向标准输出"></a>使用 <code>&gt;</code> 重定向标准输出</h5><p>当你想把命令的输出保存到一个文件中时，可以使用 <code>&gt;</code> 操作符。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> &gt; hello.txt</span><br></pre></td></tr></table></figure><p>这条命令会创建（或覆盖）一个名为 <code>hello.txt</code> 的文件，并将 <code>echo</code> 命令的输出写入该文件。</p><h5 id="使用-gt-gt-追加到文件"><a href="#使用-gt-gt-追加到文件" class="headerlink" title="使用 &gt;&gt; 追加到文件"></a>使用 <code>&gt;&gt;</code> 追加到文件</h5><p>如果你不想覆盖文件中现有的内容，而是想追加内容，可以使用 <code>&gt;&gt;</code> 操作符。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Another line&quot;</span> &gt;&gt; hello.txt</span><br></pre></td></tr></table></figure><p>这会将 “Another line” 追加到 <code>hello.txt</code> 文件的末尾。</p><h4 id="标准输入重定向-lt"><a href="#标准输入重定向-lt" class="headerlink" title="标准输入重定向 (&lt;)"></a>标准输入重定向 (<code>&lt;</code>)</h4><h5 id="使用-lt-重定向标准输入"><a href="#使用-lt-重定向标准输入" class="headerlink" title="使用 &lt; 重定向标准输入"></a>使用 <code>&lt;</code> 重定向标准输入</h5><p><code>&lt;</code> 操作符用于将文件内容作为命令的输入。例如，如果你有一个名为 <code>commands.txt</code> 的文件，包含一系列命令，你可以使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt; commands.txt</span><br></pre></td></tr></table></figure><p>这条命令会执行 <code>commands.txt</code> 文件中的 Bash 命令。</p><h4 id="组合输入和输出重定向"><a href="#组合输入和输出重定向" class="headerlink" title="组合输入和输出重定向"></a>组合输入和输出重定向</h4><p>你还可以组合使用输入和输出重定向。例如，以下命令将 <code>input.txt</code> 文件中的内容作为 <code>sort</code> 命令的输入，并将结果输出到 <code>output.txt</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><h4 id="标准错误重定向-2-gt"><a href="#标准错误重定向-2-gt" class="headerlink" title="标准错误重定向 (2&gt;)"></a>标准错误重定向 (<code>2&gt;</code>)</h4><h5 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h5><p>在 Bash 中，标准错误（stderr）是一个单独的输出流，用于输出错误信息。使用 <code>2&gt;</code> 可以重定向错误信息到一个文件。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> non_existent_file 2&gt; error.log</span><br></pre></td></tr></table></figure><p>如果 <code>non_existent_file</code> 不存在，<code>ls</code> 命令的错误信息会被写入到 <code>error.log</code>。</p><h4 id="结合标准输出和标准错误重定向"><a href="#结合标准输出和标准错误重定向" class="headerlink" title="结合标准输出和标准错误重定向"></a>结合标准输出和标准错误重定向</h4><p>有时你可能想同时重定向标准输出和标准错误到同一个文件。这可以通过以下方式实现：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; output_and_error.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这条命令将 <code>command</code> 的标准输出和标准错误都重定向到 <code>output_and_error.log</code> 文件。</p><p>当然可以。以下是一篇关于如何使用 Bash 更新服务器操作系统的知识点总结的博客草稿，采用 Markdown 格式编写：</p><hr><h3 id="Bash-更新服务器操作系统"><a href="#Bash-更新服务器操作系统" class="headerlink" title="Bash 更新服务器操作系统"></a>Bash 更新服务器操作系统</h3><p>在服务器管理中，定期更新操作系统是一项重要的维护任务。使用 Bash 脚本可以简化这一过程。在本文中，我们将探讨如何使用 Bash 命令来更新服务器的操作系统。</p><h4 id="1-理解-Bash-和-Shell"><a href="#1-理解-Bash-和-Shell" class="headerlink" title="1. 理解 Bash 和 Shell"></a>1. 理解 Bash 和 Shell</h4><p>首先，了解 Bash 和 Shell 的基本概念是很重要的。Bash（Bourne Again SHell）是一种流行的命令行界面和脚本语言，用于与操作系统交互。</p><h4 id="2-检查更新"><a href="#2-检查更新" class="headerlink" title="2. 检查更新"></a>2. 检查更新</h4><p>在更新之前，你应该检查是否有可用的更新。这通常可以通过以下命令完成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>这个命令会同步包数据库，并列出可用的更新。</p><h4 id="3-安装更新"><a href="#3-安装更新" class="headerlink" title="3. 安装更新"></a>3. 安装更新</h4><p>一旦检查了可用的更新，下一步就是安装它们。这可以通过以下命令完成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>此命令会下载并安装更新。请注意，这可能需要一些时间，具体取决于更新的大小和数量。</p><h4 id="4-清理不必要的包"><a href="#4-清理不必要的包" class="headerlink" title="4. 清理不必要的包"></a>4. 清理不必要的包</h4><p>更新后，可能会有一些不再需要的包留在系统上。运行以下命令可以清理这些包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure><h4 id="5-重启服务器"><a href="#5-重启服务器" class="headerlink" title="5. 重启服务器"></a>5. 重启服务器</h4><p>某些更新（特别是内核更新）可能需要重启服务器才能生效。可以使用以下命令来安全地重启服务器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>当然可以。下面是一篇使用 Markdown 编写的关于如何使用 Bash 查找和终止异常或不需要的进程的博客文章。</p><hr><h3 id="Bash-查找和终止异常或不需要的进程"><a href="#Bash-查找和终止异常或不需要的进程" class="headerlink" title="Bash 查找和终止异常或不需要的进程"></a>Bash 查找和终止异常或不需要的进程</h3><p>在日常的系统管理和运维工作中，经常需要处理运行中的异常或不需要的进程。使用 Bash，我们可以有效地识别这些进程并安全地终止它们。本文将介绍如何使用 Bash 来查找和终止这些进程。</p><h4 id="查找进程"><a href="#查找进程" class="headerlink" title="查找进程"></a>查找进程</h4><p>要查找正在运行的进程，最常用的命令是 <code>ps</code> 和 <code>top</code>。</p><h5 id="使用-ps-命令"><a href="#使用-ps-命令" class="headerlink" title="使用 ps 命令"></a>使用 <code>ps</code> 命令</h5><p><code>ps</code> 命令可以显示当前系统中活动的进程。常见用法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>这个命令会列出所有运行中的进程及其详细信息，包括进程 ID、CPU 和内存使用率等。</p><h5 id="使用-top-命令"><a href="#使用-top-命令" class="headerlink" title="使用 top 命令"></a>使用 <code>top</code> 命令</h5><p>另一个有用的工具是 <code>top</code>，它提供了一个实时更新的进程列表，类似于 Windows 中的任务管理器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>通过 <code>top</code>，可以实时观察进程的状态和系统资源的使用情况。</p><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>一旦识别出需要终止的进程，可以使用 <code>kill</code> 命令来终止它们。</p><h5 id="使用-kill-命令"><a href="#使用-kill-命令" class="headerlink" title="使用 kill 命令"></a>使用 <code>kill</code> 命令</h5><p>要终止一个进程，首先需要知道它的进程 ID（PID）。使用 <code>kill</code> 命令后跟 PID 可以发送信号来终止进程：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> [PID]</span><br></pre></td></tr></table></figure><p>如果进程不响应普通的 <code>kill</code> 命令，可以使用 <code>-9</code> 选项强制终止：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 [PID]</span><br></pre></td></tr></table></figure><h5 id="使用-pkill-和-killall"><a href="#使用-pkill-和-killall" class="headerlink" title="使用 pkill 和 killall"></a>使用 <code>pkill</code> 和 <code>killall</code></h5><p>如果你知道进程的名称而不是 PID，可以使用 <code>pkill</code> 或 <code>killall</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill [进程名]</span><br><span class="line">killall [进程名]</span><br></pre></td></tr></table></figure><h2 id="Bash脚本基础"><a href="#Bash脚本基础" class="headerlink" title="Bash脚本基础"></a>Bash脚本基础</h2><p>Bash 脚本是 Linux 和 Unix 系统中自动化任务和管理系统的强大工具。本教程将介绍 Bash 脚本的基本概念，包括脚本的定义、使用原因、格式、权限设置，以及如何将脚本添加到 PATH 目录中。</p><h3 id="什么是-Bash-脚本？"><a href="#什么是-Bash-脚本？" class="headerlink" title="什么是 Bash 脚本？"></a>什么是 Bash 脚本？</h3><p>Bash 脚本是一系列在 Bash shell 中执行的命令集合。它们被编写在文本文件中，可被 Bash 直接执行。</p><h3 id="为什么使用-Bash-脚本？"><a href="#为什么使用-Bash-脚本？" class="headerlink" title="为什么使用 Bash 脚本？"></a>为什么使用 Bash 脚本？</h3><p>使用 Bash 脚本可以自动化复杂的、重复的任务，提高效率并减少人为错误。它们在系统管理、程序开发和数据处理等领域非常有用。</p><h3 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h3><p>一个基本的 Bash 脚本格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这里是注释</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure><p>好的，下面我会详细地介绍 Bash 脚本的基本语法和一些关键概念。</p><h3 id="1-脚本结构"><a href="#1-脚本结构" class="headerlink" title="1. 脚本结构"></a>1. <strong>脚本结构</strong></h3><ul><li><p><strong>Shebang（#!）</strong>：每个 Bash 脚本通常以 <code>#!</code> 开头，后面跟着解释器的路径。对于 Bash 脚本，这行通常是 <code>#!/bin/bash</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注释</strong>：使用 <code>#</code> 开头的行是注释，不会被执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一条注释</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. <strong>变量</strong></h3><ul><li><p><strong>声明变量</strong>：在 Bash 中，你可以通过简单地赋值来声明变量。不需要使用任何关键字。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用变量</strong>：使用 <code>$</code> 符号来引用变量的值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-命令执行"><a href="#3-命令执行" class="headerlink" title="3. 命令执行"></a>3. <strong>命令执行</strong></h3><ul><li><p><strong>执行命令</strong>：Bash 脚本中的命令和你在命令行中输入的命令一样。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-控制结构"><a href="#4-控制结构" class="headerlink" title="4. 控制结构"></a>4. <strong>控制结构</strong></h3><ul><li><p><strong>条件语句</strong>（if-else）：用于根据条件执行不同的代码块。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$name</span> == <span class="string">&quot;张三&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;名字是张三&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;名字不是张三&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p><strong>循环</strong>（for, while）：用于重复执行一段代码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这是第 <span class="variable">$i</span> 次&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这是第 <span class="variable">$i</span> 次&quot;</span></span><br><span class="line">    i=$((i + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. <strong>函数</strong></h3><ul><li><p><strong>定义函数</strong>：函数可以帮助组织和复用代码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用函数</strong>：调用函数并传递参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">greet <span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-输入输出"><a href="#6-输入输出" class="headerlink" title="6. 输入输出"></a>6. <strong>输入输出</strong></h3><ul><li><p><strong>读取输入</strong>：使用 <code>read</code> 命令读取用户输入。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;请输入你的名字:&quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$name</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>输出重定向</strong>：使用 <code>&gt;</code> 和 <code>&gt;&gt;</code> 将输出重定向到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是一条消息&quot;</span> &gt; file.txt    <span class="comment"># 覆盖文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是另一条消息&quot;</span> &gt;&gt; file.txt   <span class="comment"># 追加到文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-特殊变量"><a href="#7-特殊变量" class="headerlink" title="7. 特殊变量"></a>7. <strong>特殊变量</strong></h3><ul><li><p>**$0, $1, $2, …**：这些特殊变量用于访问脚本的参数。<code>$0</code> 是脚本名，<code>$1</code> 是第一个参数，依此类推。</p></li><li><p>**$#**：参数的数量。</p></li><li><p><strong>$@</strong> 和 **$***：所有参数的列表。<code>$@</code> 在双引号中使用时，每个参数都是独立的，而 <code>$*</code> 将所有参数视为单个字符串。</p></li></ul><h3 id="8-退出状态"><a href="#8-退出状态" class="headerlink" title="8. 退出状态"></a>8. <strong>退出状态</strong></h3><ul><li><p><strong>退出状态</strong>：每个命令执行完毕后都会返回一个退出状态。成功的命令返回 0，失败的命令返回非零值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment"># 显示上一个命令的退出状态</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><h3 id="5-1运行级别"><a href="#5-1运行级别" class="headerlink" title="5.1运行级别"></a><strong>5.1运行级别</strong></h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a><strong>基本</strong></h4><table><thead><tr><th align="left">0</th><th>关机</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td>单用户（找回丢失密码）</td><td></td></tr><tr><td align="left">2</td><td>多用户状态没有网络服务</td><td></td></tr><tr><td align="left">3</td><td>系统未使用保留给用户</td><td>multi-user.target</td></tr><tr><td align="left">4</td><td>图形界面</td><td></td></tr><tr><td align="left">5</td><td>系统重启</td><td>graphical.target</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>常用系统级别是3和5，也可以切换运行级别和指定默认运行级别</strong>。</p><h4 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a><strong>切换运行级别</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>init 运行级别<strong>（init 3）</strong></td><td>将运行级别切换为3（多用户状态有网络服务）</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>init 只能用来切换运行级别。下次开机后系统自动回到运行级别5。</strong></p><h4 id="设置默认运行级别"><a href="#设置默认运行级别" class="headerlink" title="设置默认运行级别"></a><strong>设置默认运行级别</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>systemctl get-default</td><td>查看当前默认运行级别</td></tr><tr><td>systemctl set-default multi-user.target</td><td>设置默认运行级别为3</td></tr><tr><td>systemctl set -default graphical.target</td><td>设置默认运行级别为5</td></tr></tbody></table><p><strong>==Note==</strong><br>-<strong>此方式永久性的修改了默认运行级别。每次开机后系统都会运行该默认运行级别。</strong></p><h4 id="开机流程说明"><a href="#开机流程说明" class="headerlink" title="开机流程说明"></a><strong>开机流程说明</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/326400f8c502421a9482254a802e0787.png" alt="img"></p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a><strong>帮助指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>man 命令或配置文件</td><td>获得命令或配置文件的帮助信息</td></tr><tr><td>help 命令</td><td>获得shell内置命令的帮助信息</td></tr></tbody></table><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a><strong>文件目录类</strong></h3><h4 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a><strong>pwd指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>pwd</td><td>显示当前工作目录的绝对途径</td></tr></tbody></table><h4 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a><strong>ls指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ls 目录或文件</td><td>显示当前目录下所有的文件和目录（不包括隐藏的）</td></tr><tr><td>ls -a 目录或文件</td><td>显示当前目录下所有的文件和目录（包括隐藏的）</td></tr><tr><td>ls -l 目录或文件 或 ll 目录或文件</td><td>以列表的方式显示信息</td></tr><tr><td>ls -lh 目录或文件</td><td>以列表的方式人性化地显示信息</td></tr></tbody></table><h4 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a><strong>cd指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的家目录</td></tr><tr><td>cd ~</td><td>切换到当前用户的家目录</td></tr><tr><td>cd .</td><td>保持当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h4 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a><strong>mkdir指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>mkdir 要创建的单级目录</td><td>创建单级目录</td></tr><tr><td>mkdir -p 要创建的多级目录</td><td>创建多级目录</td></tr></tbody></table><h4 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a><strong>rmdir指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>rmdir 要删除的空目录</td><td>删除空目录</td></tr><tr><td>rm -rf 要删除的非空目录</td><td>删除非空目录</td></tr></tbody></table><h4 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a><strong>touch指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>touch 文件名称</td><td>创建一个空文件</td></tr></tbody></table><h4 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a><strong>cp指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th><th>Remake</th></tr></thead><tbody><tr><td>cp source dest</td><td>将source拷贝到dest</td><td></td></tr><tr><td>cp -r source dest</td><td>将source递归拷贝到dest</td><td></td></tr><tr><td>\cp source dest</td><td>将source拷贝到dest(强制覆盖不提示)</td><td></td></tr></tbody></table><h4 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a><strong>rm指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>rm 要删除的文件或目录</td><td>移除文件或目录</td></tr><tr><td>rm -r 要删除的目录</td><td>递归删除目录</td></tr><tr><td>rm -f 要删除的文件或目录</td><td>强制删除目录不提示</td></tr></tbody></table><h4 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a><strong>mv指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>mv oldFileName newFileName</td><td>重命名（两者在同一目录下面）</td></tr><tr><td>mv /temp/movefile /targetFolder</td><td>移动文件</td></tr></tbody></table><h4 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a><strong>cat指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>cat 要查看的文件</td><td>查看文件的内容</td></tr><tr><td>cat -n 要查看的文件</td><td>查看文件的内容并显示行号</td></tr><tr><td>cat -n 要查看的文件  more</td><td>将cat查看的内容交给more指令来处理（为了浏览方便）</td></tr></tbody></table><h4 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a><strong>more指令</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/fb32e188764542ebb25549929c4a24ff.png" alt="img"><br>|Order|illustrate|<br>|—–|—–|<br>|more 要查看的文件|查看文件的内容（浏览更方便）|</p><h4 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a><strong>less指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>less 要查看的文件</td><td>查看文件的内容</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>less 指令用来分屏查看文件内容，它的功能与more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</strong></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/5a3f4976cdc74d8e966916588413378c.png" alt="img"></p><h4 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a><strong>echo指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>echo $PATH</td><td>输出当前PATH环境变量</td></tr><tr><td>echo $HOSTNAME</td><td>输出当前HOSTNAME环境变量（主机名）</td></tr><tr><td>echo ‘hello world’</td><td>输出hello world</td></tr></tbody></table><h4 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a><strong>head指令</strong></h4><p>==head指令用于查看文件开头的部分内容（默认情况下显示前10行）。==<br>|Order|illustrate|<br>|—–|—–|<br>|head 文件|查看文件开头的前10行内容|<br>|head -n 5 文件|查看文件开头的前5行内容|</p><h4 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a><strong>tail指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>tail 文件</td><td>查看文件尾部的后10行内容</td></tr><tr><td>tail -n 5 文件</td><td>查看文件尾部的后5行内容</td></tr><tr><td>tail -f 文件</td><td>实时追踪该文档的所有更新</td></tr></tbody></table><h4 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a><strong>&gt;指令和&gt;&gt;指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ls -l &gt; 文件</td><td>列表的内容写入（覆盖）到文件</td></tr><tr><td>ls -l &gt;&gt; 文件</td><td>列表的内容追加到文件</td></tr><tr><td>cat 文件1 &gt; 文件2</td><td>文件1的内容覆盖到文件2</td></tr><tr><td>echo ‘hello’  &gt;&gt; 文件</td><td>hello追加到文件中</td></tr></tbody></table><h4 id="In指令"><a href="#In指令" class="headerlink" title="In指令"></a><strong>In指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ln -s 原文件或目录 软链接名</td><td>给原文件创建一个软链接(这样软链接就指向了原文件或目录)</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>当工作目录为软链接所在目录，使用pwd查看的目录仍然是软链接所在目录而不是原目录。</strong></p><h4 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a><strong>history指令</strong></h4><p>==history指令用于查看已经执行过的历史命令。==</p><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>histrory</td><td>查看已经执行过的历史命令</td></tr><tr><td>histrory n</td><td>查看最近执行过的n条历史命令</td></tr><tr><td>!n</td><td>执行历史编号为n的历史命令</td></tr></tbody></table><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h4><p>date指令用于显示当前日期<br>|Order|illustrate|<br>|—–|—–|<br>|date|显示当前时间|<br>|date +%Y|显示当前年份|<br>|date +%m|显示当前月份|<br>|date +%d|显示当前是哪一天|<br>|date “+%Y-%m-%d %H:%M:%S”|显示年月日时分秒|</p><h4 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>date -s 字符串时间</td><td>设置系统当前时间</td></tr></tbody></table><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><p>cal指令用于显示日历<br>|Order|illustrate|<br>|—–|—–|<br>|cal|显示本月日历|<br>|cal 年份|显示本年所有月日历|</p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a><strong>搜索查找类</strong></h3><h4 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a><strong>find指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>find 指定目录 -name 要查找的文件或目录</td><td>按照指定目录查询文件或目录</td></tr><tr><td>find 指定目录 -user 用户名</td><td>按照指定目录查找指定用户名的所有文件或目录</td></tr><tr><td>find 指定目录 -size 文件大小</td><td>按照指定目录查找满足文件大小的所有文件或目录</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>1.文件大小：大于+，小于-，等于=</strong><br><strong>2.find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</strong><br><strong>find指令也可以不指定目录进行查找。</strong></p><h4 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a><strong>locate指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>locate 要查找的文件或目录</td><td>快速查找文件或目录</td></tr><tr><td><strong>==Note==</strong></td><td></td></tr><tr><td><strong>1.locate指令无需遍历整个文件系统，locate 指令利用事先建立的系统中所有文件名称及路径的         locate数据库实现快速定位给定的文件路径。</strong></td><td></td></tr></tbody></table><p><strong>2.为了保证查询结果的准确度，管理员必须定期更新locate时刻。</strong></p><p><strong>3.由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locatc数据库。</strong></p><h4 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a><strong>which指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>which 要查找的命令</td><td>查找指令的存放路径</td></tr></tbody></table><p><strong>==Note==</strong><br>which指令用于查找指令的存放路径。</p><h4 id="管道符“-”和grep指令"><a href="#管道符“-”和grep指令" class="headerlink" title="管道符“|”和grep指令"></a><strong>管道符“|”和grep指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>grep 查找内容 源文件</td><td>将源文件中的查找内容输出</td></tr><tr><td>grep -n 查找内容 源文件</td><td>将源文件中的查找内容输出，并显示行号</td></tr><tr><td>grep -i 查找内容 源文件</td><td>将源文件中的查找内容输出（不区分大小写）</td></tr></tbody></table><p><strong>==Note==</strong><br>1.管道符“|”表示将前一个命令的处理结果输出传递给后面的命令处理。<br>    grep指令用于过滤查找，可配合管道符“|”使用。</p><p>==<strong>Case study</strong><br><strong>请在 hello.txt文件中，查找”yes”所在行，并且显示行号。<br>法一：cat hello.txt | grep -n “yes”<br>法二：grep -n “yes” hello.txt</strong></p><h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><h4 id="gzip-gunzio指令"><a href="#gzip-gunzio指令" class="headerlink" title="gzip/gunzio指令"></a>gzip/gunzio指令</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>gzip 文件</td><td>压缩文件（只能将文件压缩为*.gz文件）</td></tr><tr><td>gunzip 文件.gz</td><td>解压缩文件</td></tr></tbody></table><h4 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="==zip/unzip指令=="></a>==<strong>zip/unzip指令</strong>==</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>zip XXX.zip 要压缩的文件</td><td>压缩文件</td></tr><tr><td>zip -r XXX.zip 要压缩的目录</td><td>压缩目录（递归压缩）</td></tr><tr><td>unzip XXX.zip</td><td>将压缩包解压到当前目录下</td></tr><tr><td>unzip -d 目标目录 XXX.zip</td><td>将压缩包解压到指定目录下</td></tr></tbody></table><h4 id="tar指令"><a href="#tar指令" class="headerlink" title="==tar指令=="></a>==<strong>tar指令</strong>==</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>tar-z</td><td>压缩/解压缩</td></tr><tr><td>tar-c</td><td>产生tar打包文件</td></tr><tr><td>tar-v</td><td>显示详细信息</td></tr><tr><td>tar-f</td><td>指定压缩后的文件名</td></tr><tr><td>tar-x</td><td>解包.tar文件</td></tr><tr><td>tar-C</td><td>解压缩到指定目录（解压缩的目录必须存在）</td></tr><tr><td>tar -zcvf 打包文件.tar.gz 被打包的文件</td><td>打包压缩文件</td></tr><tr><td>tar -zxvf 打包文件.tar.gz</td><td>解包解压缩文件至当前目录下</td></tr><tr><td>tar -zxvf 打包文件.tar.gz -C 目标目录</td><td>解包解压缩文件至当前指定目录下</td></tr></tbody></table><h3 id="Bash组基本介绍"><a href="#Bash组基本介绍" class="headerlink" title="Bash组基本介绍"></a><strong>Bash组基本介绍</strong></h3><h4 id="Bash组基本介绍-1"><a href="#Bash组基本介绍-1" class="headerlink" title="Bash组基本介绍**"></a>Bash组基本介绍**</h4><p>在Bash中的每个用户必须属于一个组，且可以改变每个用户所在的组。<br>在Bash中的每个文件拥有以下概念：<br>1.所有者2.所在组3.其它组</p><h4 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件/目录所有者"></a><strong>文件/目录所有者</strong></h4><p><em><strong>一般为文件/目录的创建者，即谁创建文件/目录，谁就是该文件/目录的所有者。</strong></em></p><h4 id="查看文件-目录的所有者"><a href="#查看文件-目录的所有者" class="headerlink" title="查看文件/目录的所有者"></a><strong>查看文件/目录的所有者</strong></h4><p>ls -alh</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/e36e9c31bcb248cda9ecc05d69c2440b.png" alt="img"></p><h4 id="修改文件-目录的所有者"><a href="#修改文件-目录的所有者" class="headerlink" title="修改文件/目录的所有者"></a><strong>修改文件/目录的所有者</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chown 所有者 文件/目录</td><td>修改文件/目录的所有者</td></tr><tr><td>chown -R 所有者 目录</td><td>递归修改目录及目录内容的所有者</td></tr><tr><td>chown 所有者:所在组 文件/目录</td><td>修改文件/目录的所有者和所在组</td></tr></tbody></table><h4 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a><strong>文件/目录所在组</strong></h4><p><strong>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组(默认)。</strong></p><h3 id="查看文件-目录的所在组"><a href="#查看文件-目录的所在组" class="headerlink" title="查看文件/目录的所在组"></a><strong>查看文件/目录的所在组</strong></h3><p>ls -alh</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/966d4fe8a879494297ee9578ce9a97be.png" alt="img"></p><h4 id="修改文件-目录的所在组"><a href="#修改文件-目录的所在组" class="headerlink" title="修改文件/目录的所在组"></a><strong>修改文件/目录的所在组</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chgrp 所在组 文件/目录</td><td>修改文件/目录的所在组</td></tr><tr><td>chgrp -R 所在组 目录</td><td>递归修改目录及目录内容的所在组</td></tr></tbody></table><h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a><strong>其它组</strong></h4><p><strong>除文件的所有者和所在组的用户外，系统的其它用户都属于文件的其它组。</strong></p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p><img src="https://img-blog.csdnimg.cn/1055e2e25bcd4f32a559061862242ae5.png" alt="img"></p><p><strong>0-9位说明</strong></p><p>1.第0位确定文件类型（-、l、d、c、b）<br>        -表示普通文件<br>        l是链接，相当于windows的快捷方式<br>        d是目录，相当于windows的文件夹<br>        c是字符设备文件，例如鼠标，键盘<br>        b是块设备，例如硬盘<br>2.第1-3位确定该文件所有者拥有的权限。<br>3.第4-6位确定与该文件所有者同一组的用户拥有的权限。<br>4.第7-9位确定不与该文件所有者同一组的其他用户拥有的权限。</p><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a><strong>rwx作用到文件</strong></h4><pre><code> r表示可读（read）：可以查看文件中的内容 w表示可写（write）：可以修改文件中的内容，但是不一定可以删除该文件（因为删除一个      文件的前提是对该文件所在目录有写权限，才能删除该文件） x表示可执行（execute）：可以执行该文件</code></pre><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a><strong>rwx作用到目录</strong></h4><p><strong>1.r表示可读（read）：可以查看目录中的内容（ls查看）</strong></p><p><strong>2.w表示可写（write）：可以创建、删除目录中的内容，重命名目录</strong></p><p><strong>3.x表示可执行（execute）：可以进入该目录（cd进入）</strong></p><h4 id="ls-l扩展"><a href="#ls-l扩展" class="headerlink" title="ls -l扩展"></a><strong>ls -l扩展</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/1055e2e25bcd4f32a559061862242ae5.png" alt="img"></p><p>ls -l可显示目录下文件的详细信息,从左往右依次是：<br>     文件类型<br>     权限<br>     硬链接数（对于文件来说）或子目录数（对于目录来说，包括隐藏目录）<br>     用户<br>     组<br>     文件/文件夹大小（字节）<br>     最后修改日期<br>     文件名</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><strong>chmod</strong></h4><p><strong>chmod指令用于修改文件或者目录的权限。</strong></p><p><strong>+、-、=变更权限</strong><br>|Order|illustrate|<br>|—–|—–|<br>|chmod u=rwx,g=rx,o=x 文件/目录|给文件/目录的所有者读写执行的权限，所在组读执行的权限其它组执行的权限    |<br>|chmod o+x 文件/目录|给文件/目录的其它组增加执行的权限|<br>|chmod a-x 文件/目录|给文件/目录的所有人除去执行的权限|</p><table><thead><tr><th>Remake</th><th>—–</th></tr></thead><tbody><tr><td>u：</td><td>所有者</td></tr><tr><td>g：</td><td>所在组</td></tr><tr><td>o：</td><td>其它组</td></tr><tr><td>a：</td><td>所有人</td></tr><tr><td>=：</td><td>赋予</td></tr><tr><td>+：</td><td>增加</td></tr><tr><td>-：</td><td>除去</td></tr></tbody></table><h4 id="数字变更权限"><a href="#数字变更权限" class="headerlink" title="数字变更权限"></a><strong>数字变更权限</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chmod 751 文件/目录</td><td>给文件/目录的所有者读写执行的权限，所在组读执行的权限，其它组执行的权限</td></tr></tbody></table><h3 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h3><h4 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h4><p>1.任务调度：系统在某个时间执行的特定命令或者程序。<br>2.任务调度分类：<br>（1）.系统工作：有些重要的工作必须周而复始的执行<br>（2）.个别用户工作：个别用户可能希望执行某些程序</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/b8afa5a9321540b9a81ab9062238d683.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Azure云端防护：构建网络安全组</title>
      <link href="/2023/11/20/Linux%20Bash/"/>
      <url>/2023/11/20/Linux%20Bash/</url>
      
        <content type="html"><![CDATA[<h1 id="创建管理网络安全组"><a href="#创建管理网络安全组" class="headerlink" title="创建管理网络安全组"></a>创建管理网络安全组</h1><p>配置网络安全组和安全规则，以限制到特定服务器的网络流量。 你希望让应用服务器能通过 HTTP 连接到数据库服务器。 不希望数据库服务器通过 HTTP 连接到应用服务器。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121165732052.png" alt="image-20231121165732052"></p><h2 id="变量资源分配"><a href="#变量资源分配" class="headerlink" title="变量资源分配"></a>变量资源分配</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rg=learn-c5547acb-6432-4632-9c2e-17e555ac9e72</span><br></pre></td></tr></table></figure><p>  在 Azure Cloud Shell 中，将资源组分配给变量通常是为了简化管理任务和自动化脚本中的操作。当你在 Azure Cloud Shell 或任何脚本中运行命令时，经常需要引用资源组名称。如果你有一个变量，比如 <code>$rg</code>，存储了资源组的名称，你就可以在后续的命令中重复使用这个变量，而不是每次都输入完整的资源组名称。</p><p>例如，如果你将资源组名称分配给变量 <code>$rg</code>，那么你可以在创建资源、查询资源状态、删除资源等命令中使用这个变量，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分配资源组名称到变量</span></span><br><span class="line">rg=<span class="string">&quot;your-resource-group-name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用变量创建一个新的Azure虚拟机</span></span><br><span class="line">az vm create --resource-group <span class="variable">$rg</span> --name MyVm --image UbuntuLTS --generate-ssh-keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出资源组中的所有资源</span></span><br><span class="line">az resource list --resource-group <span class="variable">$rg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除资源组</span></span><br><span class="line">az group delete --name <span class="variable">$rg</span> --<span class="built_in">yes</span> --no-wait</span><br></pre></td></tr></table></figure><p>这样做有几个好处：</p><ol><li><p><strong>减少错误</strong>：每次输入资源组名称时都有可能出错，尤其是在名称很长或复杂时。使用变量可以减少这种风险。</p></li><li><p><strong>提高效率</strong>：不需要每次都输入完整的资源组名称，可以快速重复使用变量。</p></li><li><p><strong>提高可读性</strong>：在脚本中使用变量可以使代码更容易理解，尤其是对于其他可能查看或维护这些脚本的人。</p></li><li><p><strong>易于修改</strong>：如果资源组名称变更，或者你想要在不同的资源组上执行相同的一系列命令，你只需要在一个地方更新变量的值，而不是修改每一条命令。</p></li><li><p><strong>自动化和模板化</strong>：在自动化脚本中使用变量可以使脚本更加通用和可配置，这对于创建可复用的脚本模板非常有用。</p></li></ol><p>要在 Azure Cloud Shell 中分配资源组到变量 <code>rg</code>，你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rg=$(az group list --query <span class="string">&quot;[?name==&#x27;your-sandbox-resource-group-name&#x27;].name&quot;</span> -o tsv)</span><br></pre></td></tr></table></figure><p>这个命令使用 <code>az group list</code> 命令列出所有资源组，然后通过 <code>--query</code> 参数结合 JMESPath 查询语言来提取特定名称的资源组名，最后通过 <code>-o tsv</code> 输出为纯文本格式，然后将结果赋值给变量 <code>rg</code>。这样，你就可以在后续的 Azure CLI 命令中使用 <code>$rg</code> 来代表这个资源组名称了。</p><h2 id="创建ERP-servers虚拟网络和Applications子网"><a href="#创建ERP-servers虚拟网络和Applications子网" class="headerlink" title="创建ERP-servers虚拟网络和Applications子网"></a>创建ERP-servers虚拟网络和Applications子网</h2><p>  该命令是用来在Azure云服务中创建一个虚拟网络（Virtual Network，简称VNet）及其子网的。Azure的虚拟网络是一个隔离的网络环境，它允许你在Azure中自定义私有IP地址块、创建子网、配置路由和网络策略。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet create \  <span class="comment"># 调用Azure CLI的命令来创建一个虚拟网络。</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定Azure资源组的名称，该资源组是用来组织和管理Azure资源的容器。这里使用$rg变量来表示资源组名称。</span></span><br><span class="line">    --name ERP-servers \  <span class="comment"># 设置虚拟网络的名称为&quot;ERP-servers&quot;。</span></span><br><span class="line">    --address-prefixes 10.0.0.0/16 \  <span class="comment"># 定义虚拟网络的IP地址空间。这里使用了CIDR表示法，表示这个虚拟网络可以包含从10.0.0.0到10.0.255.255的IP地址。</span></span><br><span class="line">    --subnet-name Applications \  <span class="comment"># 在虚拟网络内创建一个子网，并命名为&quot;Applications&quot;。</span></span><br><span class="line">    --subnet-prefixes 10.0.0.0/24  <span class="comment"># 为&quot;Applications&quot;子网定义IP地址范围。这里的范围是10.0.0.0到10.0.0.255。</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，你将在指定的资源组中创建一个名为”ERP-servers”的虚拟网络，该网络拥有一个名为”Applications”的子网。这个子网的地址范围是10.0.0.0/24，这意味着它可以包含256个IP地址（从10.0.0.0到10.0.0.255）。</p><p>在实际执行该命令之前，确保你已经设置了<code>$rg</code>变量，它应该包含一个有效的资源组名称。如果<code>$rg</code>变量未设置或为空，命令将会失败。如果你不确定变量的当前值，可以通过以下命令来检查：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$rg</span></span><br></pre></td></tr></table></figure><p>如果变量未设置或你想要直接指定资源组名称，可以直接在命令中替换<code>$rg</code>部分，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet create \</span><br><span class="line">    --resource-group my-resource-group-name \</span><br><span class="line">    --name ERP-servers \</span><br><span class="line">    --address-prefixes 10.0.0.0/16 \</span><br><span class="line">    --subnet-name Applications \</span><br><span class="line">    --subnet-prefixes 10.0.0.0/24</span><br></pre></td></tr></table></figure><p>请确保将<code>my-resource-group-name</code>替换为实际使用的资源组名称。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121220713610.png" alt="image-20231121220713610"></p><h2 id="创建Databases子网"><a href="#创建Databases子网" class="headerlink" title="创建Databases子网"></a>创建Databases子网</h2><p>  为了在已经存在的虚拟网络 <code>ERP-servers</code> 中创建一个新的子网 <code>Databases</code>，你可以使用 <code>az network vnet subnet create</code> 命令。下面是这个命令的详细解释和格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet subnet create \  <span class="comment"># 命令用于在Azure中创建一个新的子网</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定子网所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --vnet-name ERP-servers \  <span class="comment"># 指定虚拟网络的名称，在这个例子中是&quot;ERP-servers&quot;</span></span><br><span class="line">    --address-prefixes 10.0.1.0/24 \  <span class="comment"># 定义子网的IP地址范围，这里使用CIDR表示法，表示子网可以包含从10.0.1.0到10.0.1.255的IP地址</span></span><br><span class="line">    --name Databases  <span class="comment"># 设置子网的名称为&quot;Databases&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称。如果 <code>$rg</code> 变量没有设置或者你不想使用变量，可以直接在命令中指定资源组的名称，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet subnet create \</span><br><span class="line">    --resource-group my-resource-group-name \</span><br><span class="line">    --vnet-name ERP-servers \</span><br><span class="line">    --address-prefixes 10.0.1.0/24 \</span><br><span class="line">    --name Databases</span><br></pre></td></tr></table></figure><p>请将 <code>my-resource-group-name</code> 替换为你的实际资源组名称。</p><p>执行这个命令将会在 <code>ERP-servers</code> 虚拟网络中创建一个新的子网 <code>Databases</code>，其IP地址范围是 <code>10.0.1.0/24</code>。这个子网可以用于数据库服务器或相关服务，以保持网络的逻辑分隔和组织。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221015180.png" alt="image-20231121221015180"></p><h2 id="创建ERP-SERVERS-NSG网络安全组"><a href="#创建ERP-SERVERS-NSG网络安全组" class="headerlink" title="创建ERP-SERVERS-NSG网络安全组"></a>创建ERP-SERVERS-NSG网络安全组</h2><p>  要在Azure中创建一个新的网络安全组（NSG），可以使用 <code>az network nsg create</code> 命令。网络安全组用于定义入站和出站网络流量的安全规则，以此来控制对Azure虚拟网络中资源的访问。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg create \  <span class="comment"># 命令用于在Azure中创建一个新的网络安全组</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定网络安全组所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --name ERP-SERVERS-NSG  <span class="comment"># 设置网络安全组的名称为&quot;ERP-SERVERS-NSG&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称。如果 <code>$rg</code> 变量没有设置或者你不想使用变量，可以直接在命令中指定资源组的名称，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg create \</span><br><span class="line">    --resource-group my-resource-group-name \</span><br><span class="line">    --name ERP-SERVERS-NSG</span><br></pre></td></tr></table></figure><p>请将 <code>my-resource-group-name</code> 替换为你的实际资源组名称。</p><p>执行这个命令后，将会在指定的资源组中创建一个名为 <code>ERP-SERVERS-NSG</code> 的网络安全组。创建了NSG之后，你可能还需要创建和关联安全规则来定义允许或拒绝的流量类型。这些规则可以通过 <code>az network nsg rule create</code> 命令来创建。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221102757.png" alt="image-20231121221102757"></p><h2 id="创建运行Ubuntu的VM"><a href="#创建运行Ubuntu的VM" class="headerlink" title="创建运行Ubuntu的VM"></a>创建运行Ubuntu的VM</h2><p>  创建两个 VM，名称分别为 AppServer 和 DataServer。 需将 AppServer 部署到 Applications 子网，并将 DataServer 部署到 Databases 子网。 将 VM 网络接口添加到 ERP-SERVERS-NSG 网络安全组。 然后使用这些 VM 测试网络安全组。</p><h3 id="AppServer"><a href="#AppServer" class="headerlink" title="AppServer"></a>AppServer</h3><p>要生成 AppServer VM，可以使用 <code>az vm create</code> 命令。该命令将创建一个新的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N https://raw.githubusercontent.com/MicrosoftDocs/mslearn-secure-and-isolate-with-nsg-and-service-endpoints/master/cloud-init.yml &amp;&amp; \</span><br><span class="line">az vm create \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定虚拟机所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --name AppServer \  <span class="comment"># 设置虚拟机的名称为&quot;AppServer&quot;</span></span><br><span class="line">    --vnet-name ERP-servers \  <span class="comment"># 指定虚拟机所属的虚拟网络名称</span></span><br><span class="line">    --subnet Applications \  <span class="comment"># 指定虚拟机所属的子网名称</span></span><br><span class="line">    --nsg ERP-SERVERS-NSG \  <span class="comment"># 指定虚拟机所使用的网络安全组的名称</span></span><br><span class="line">    --image Ubuntu2204 \  <span class="comment"># 指定虚拟机的映像（操作系统），这里使用Ubuntu 22.04</span></span><br><span class="line">    --size Standard_DS1_v2 \  <span class="comment"># 指定虚拟机的大小/性能配置</span></span><br><span class="line">    --generate-ssh-keys \  <span class="comment"># 自动生成SSH密钥对用于远程登录</span></span><br><span class="line">    --admin-username azureuser \  <span class="comment"># 指定管理员用户名</span></span><br><span class="line">    --custom-data cloud-init.yml \  <span class="comment"># 指定自定义数据（用于配置虚拟机）</span></span><br><span class="line">    --no-wait \  <span class="comment"># 不等待虚拟机创建完成，立即返回</span></span><br><span class="line">    --admin-password &lt;password&gt;  <span class="comment"># 指定管理员密码，将 &lt;password&gt; 替换为复杂的密码</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称，并将 <code>&lt;password&gt;</code> 替换为你希望设置的复杂密码。</p><p>此命令还使用 <code>wget</code> 命令从指定的URL下载 <code>cloud-init.yml</code> 文件。该文件包含了自定义数据，用于在虚拟机创建过程中配置虚拟机。请确保可以从 Cloud Shell 访问该 URL。</p><p>执行这个命令后，将会创建一个名为 <code>AppServer</code> 的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。虚拟机将使用指定的映像（Ubuntu 22.04）和大小（Standard_DS1_v2）。管理员用户名为 <code>azureuser</code>，密码为你设置的复杂密码。虚拟机创建过程中将使用 <code>cloud-init.yml</code> 文件进行配置。</p><p>请注意，命令中的 <code>--no-wait</code> 参数将使命令立即返回，而不等待虚拟机创建完成。如果希望等待虚拟机创建完成后再返回，请删除 <code>--no-wait</code> 参数。</p><p>你可以根据需要修改命令中的参数来适应你的环境和需求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221302267.png" alt="image-20231121221302267"></p><h3 id="DataServer"><a href="#DataServer" class="headerlink" title="DataServer"></a>DataServer</h3><p>要生成 DataServer VM，可以使用 <code>az vm create</code> 命令。该命令将创建一个新的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm create \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定虚拟机所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --name DataServer \  <span class="comment"># 设置虚拟机的名称为&quot;DataServer&quot;</span></span><br><span class="line">    --vnet-name ERP-servers \  <span class="comment"># 指定虚拟机所属的虚拟网络名称</span></span><br><span class="line">    --subnet Databases \  <span class="comment"># 指定虚拟机所属的子网名称</span></span><br><span class="line">    --nsg ERP-SERVERS-NSG \  <span class="comment"># 指定虚拟机所使用的网络安全组的名称</span></span><br><span class="line">    --size Standard_DS1_v2 \  <span class="comment"># 指定虚拟机的大小/性能配置</span></span><br><span class="line">    --image Ubuntu2204 \  <span class="comment"># 指定虚拟机的映像（操作系统），这里使用Ubuntu 22.04</span></span><br><span class="line">    --generate-ssh-keys \  <span class="comment"># 自动生成SSH密钥对用于远程登录</span></span><br><span class="line">    --admin-username azureuser \  <span class="comment"># 指定管理员用户名</span></span><br><span class="line">    --custom-data cloud-init.yml \  <span class="comment"># 指定自定义数据（用于配置虚拟机）</span></span><br><span class="line">    --no-wait \  <span class="comment"># 不等待虚拟机创建完成，立即返回</span></span><br><span class="line">    --admin-password &lt;password&gt;  <span class="comment"># 指定管理员密码，将 &lt;password&gt; 替换为复杂的密码</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称，并将 <code>&lt;password&gt;</code> 替换为你希望设置的复杂密码。</p><p>执行这个命令后，将会创建一个名为 <code>DataServer</code> 的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。虚拟机将使用指定的映像（Ubuntu 22.04）和大小（Standard_DS1_v2）。管理员用户名为 <code>azureuser</code>，密码为你设置的复杂密码。虚拟机创建过程中将使用 <code>cloud-init.yml</code> 文件进行配置。</p><p>请注意，命令中的 <code>--no-wait</code> 参数将使命令立即返回，而不等待虚拟机创建完成。如果希望等待虚拟机创建完成后再返回，请删除 <code>--no-wait</code> 参数。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121173541435.png" alt="image-20231121173541435"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221508537.png" alt="image-20231121221508537"></p><h2 id="检查运行状态"><a href="#检查运行状态" class="headerlink" title="检查运行状态"></a>检查运行状态</h2><p>要确认 VM 是否正在运行，可以使用 <code>az vm list</code> 命令。该命令将列出指定资源组中的虚拟机，并显示其详细信息，包括虚拟机的名称、部署状态和电源状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm list \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定要列出虚拟机的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --show-details \  <span class="comment"># 显示详细信息，包括部署状态和电源状态</span></span><br><span class="line">    --query <span class="string">&quot;[*].&#123;Name:name, Provisioned:provisioningState, Power:powerState&#125;&quot;</span> \  <span class="comment"># 使用JMESPath查询语法指定要显示的属性</span></span><br><span class="line">    --output table  <span class="comment"># 以表格形式输出结果</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称。</p><p>执行这个命令后，将会列出指定资源组中的虚拟机，并显示其名称、部署状态和电源状态。如果虚拟机正在运行，你将看到 <code>Power</code> 列的值为 <code>VM running</code>。</p><h2 id="检查默认连接"><a href="#检查默认连接" class="headerlink" title="检查默认连接"></a>检查默认连接</h2><h3 id="直接在shell里面使用SSH，"><a href="#直接在shell里面使用SSH，" class="headerlink" title="直接在shell里面使用SSH，"></a>直接在shell里面使用SSH，</h3><p>要列出分配给虚拟机的 IP 地址，以便连接到 VM，可以使用 <code>az vm list</code> 命令。该命令将列出指定资源组中的虚拟机，并显示其名称、私有 IP 地址和公共 IP 地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm list \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定要列出虚拟机的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --show-details \  <span class="comment"># 显示详细信息，包括私有 IP 地址和公共 IP 地址</span></span><br><span class="line">    --query <span class="string">&quot;[*].&#123;Name:name, PrivateIP:privateIps, PublicIP:publicIps&#125;&quot;</span> \  <span class="comment"># 使用JMESPath查询语法指定要显示的属性</span></span><br><span class="line">    --output table  <span class="comment"># 以表格形式输出结果</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的 Azure 资源组的名称。</p><p>执行这个命令后，将会列出指定资源组中的虚拟机，并显示其名称、私有 IP 地址和公共 IP 地址。你可以使用公共 IP 地址来连接到相应的虚拟机。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221602944.png" alt="image-20231121221602944"></p><h3 id="公共IP地址分配给变量"><a href="#公共IP地址分配给变量" class="headerlink" title="公共IP地址分配给变量"></a>公共IP地址分配给变量</h3><p>当你运行以下命令时：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">APPSERVERIP=<span class="string">&quot;<span class="subst">$(az vm list-ip-addresses \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --resource-group $rg \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --name AppServer \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --query <span class="string">&quot;[].virtualMachine.network.publicIpAddresses[*].ipAddress&quot;</span> \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --output tsv)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">DATASERVERIP=<span class="string">&quot;<span class="subst">$(az vm list-ip-addresses \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --resource-group $rg \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --name DataServer \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --query <span class="string">&quot;[].virtualMachine.network.publicIpAddresses[*].ipAddress&quot;</span> \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --output tsv)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>这些命令会执行两个 <code>az vm list-ip-addresses</code> 命令，每个命令获取一个虚拟机的公共 IP 地址。</p><ul><li>对于 AppServer，命令如下：<ul><li><code>--resource-group $rg</code>：指定资源组的名称，这里使用 <code>$rg</code> 变量表示资源组名称。</li><li><code>--name AppServer</code>：指定虚拟机的名称，这里是 AppServer。</li><li><code>--query &quot;[].virtualMachine.network.publicIpAddresses[*].ipAddress&quot;</code>：使用 JMESPath 查询语法指定要提取的公共 IP 地址。</li><li><code>--output tsv</code>：以制表符分隔的值格式输出结果。</li></ul></li><li>对于 DataServer，命令类似于上述命令，只是虚拟机的名称改为 DataServer。</li></ul><p>这些命令会将每个虚拟机的公共 IP 地址分配给相应的变量：</p><ul><li><code>APPSERVERIP</code> 变量将保存 AppServer 的公共 IP 地址。</li><li><code>DATASERVERIP</code> 变量将保存 DataServer 的公共 IP 地址。</li></ul><p>通过将公共 IP 地址保存到变量中，你可以在后续的操作中更方便地使用这些 IP 地址，比如用于 SSH 连接到虚拟机。</p><p>若要检查能否连接到 AppServer VM，请在 Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@<span class="variable">$APPSERVERIP</span> -o ConnectTimeout=5</span><br></pre></td></tr></table></figure><p>将会收到一条 Connection timed out 消息。</p><p>若要检查能否连接到 DataServer VM，请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@<span class="variable">$DATASERVERIP</span> -o ConnectTimeout=5</span><br></pre></td></tr></table></figure><p>将会收到同样的连接失败消息。</p><p>请记住，默认规则会拒绝所有进入虚拟网络的入站流量，除非该流量来自同一虚拟网络。 “拒绝所有入站”规则阻止了刚刚尝试的入站 SSH 连接。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121203649284.png" alt="image-20231121203649284"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221741123.png" alt="image-20231121221741123"></p><h2 id="为SSH创建安全规则"><a href="#为SSH创建安全规则" class="headerlink" title="为SSH创建安全规则"></a>为SSH创建安全规则</h2><p>创建一个新的入站安全规则，允许 SSH 访问。请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg rule create \  <span class="comment"># 创建网络安全组规则的 Azure CLI 命令</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定资源组的名称，这里使用 $rg 变量表示资源组名称</span></span><br><span class="line">    --nsg-name ERP-SERVERS-NSG \  <span class="comment"># 指定网络安全组的名称，这里是 ERP-SERVERS-NSG</span></span><br><span class="line">    --name AllowSSHRule \  <span class="comment"># 指定新规则的名称，这里是 AllowSSHRule</span></span><br><span class="line">    --direction Inbound \  <span class="comment"># 指定规则的方向为入站</span></span><br><span class="line">    --priority 100 \  <span class="comment"># 指定规则的优先级为 100</span></span><br><span class="line">    --source-address-prefixes <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定源地址前缀为任意地址</span></span><br><span class="line">    --source-port-ranges <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定源端口范围为任意端口</span></span><br><span class="line">    --destination-address-prefixes <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定目标地址前缀为任意地址</span></span><br><span class="line">    --destination-port-ranges 22 \  <span class="comment"># 指定目标端口范围为 22（SSH 端口）</span></span><br><span class="line">    --access Allow \  <span class="comment"># 指定允许访问</span></span><br><span class="line">    --protocol Tcp \  <span class="comment"># 指定协议为 TCP</span></span><br><span class="line">    --description <span class="string">&quot;Allow inbound SSH&quot;</span>  <span class="comment"># 指定规则的描述为 &quot;Allow inbound SSH&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保以下事项：</p><ul><li><code>$rg</code> 变量已经被设置为你的 Azure 资源组的名称。</li><li><code>ERP-SERVERS-NSG</code> 是你要添加规则的网络安全组的名称。你可以根据实际情况修改该名称。</li></ul><p>这个命令将创建一个名为 <code>AllowSSHRule</code> 的新规则，它允许从任何来源（<code>*</code>）通过 TCP 协议（端口 22）访问目标地址（任何地址）。该规则的优先级为 100，方向为入站，并设置访问权限为允许（Allow）。描述字段提供了关于规则的说明，这里是 “Allow inbound SSH”。</p><p>执行这个命令后，将会创建一个新的安全规则，允许 SSH 连接到相应的虚拟机。请确保根据你的网络安全需求和实际情况修改命令中的参数。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221817769.png" alt="image-20231121221817769"></p><h3 id="检查是否连接"><a href="#检查是否连接" class="headerlink" title="检查是否连接"></a>检查是否连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@<span class="variable">$APPSERVERIP</span> -o ConnectTimeout=5</span><br></pre></td></tr></table></figure><p>现在应该可以进行连接。 在 Are you sure you want to continue connecting (yes/no)? 消息后，输入 yes。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221947123.png" alt="image-20231121221947123"></p><h2 id="创建安全规则防止Web访问"><a href="#创建安全规则防止Web访问" class="headerlink" title="创建安全规则防止Web访问"></a>创建安全规则防止Web访问</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121215338383.png" alt="image-20231121215338383"></p><p>创建新的入站安全规则来拒绝端口 80 上的 HTTP 访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg rule create \  <span class="comment"># 创建网络安全组规则的 Azure CLI 命令</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定资源组的名称，这里使用 $rg 变量表示资源组名称</span></span><br><span class="line">    --nsg-name ERP-SERVERS-NSG \  <span class="comment"># 指定网络安全组的名称，这里是 ERP-SERVERS-NSG</span></span><br><span class="line">    --name httpRule \  <span class="comment"># 指定新规则的名称，这里是 httpRule</span></span><br><span class="line">    --direction Inbound \  <span class="comment"># 指定规则的方向为入站</span></span><br><span class="line">    --priority 150 \  <span class="comment"># 指定规则的优先级为 150</span></span><br><span class="line">    --source-address-prefixes 10.0.1.4 \  <span class="comment"># 指定源地址前缀为 10.0.1.4</span></span><br><span class="line">    --source-port-ranges <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定源端口范围为任意端口</span></span><br><span class="line">    --destination-address-prefixes 10.0.0.4 \  <span class="comment"># 指定目标地址前缀为 10.0.0.4</span></span><br><span class="line">    --destination-port-ranges 80 \  <span class="comment"># 指定目标端口范围为 80</span></span><br><span class="line">    --access Deny \  <span class="comment"># 指定访问权限为拒绝</span></span><br><span class="line">    --protocol Tcp \  <span class="comment"># 指定协议为 TCP</span></span><br><span class="line">    --description <span class="string">&quot;Deny from DataServer to AppServer on port 80&quot;</span>  <span class="comment"># 指定规则的描述为 &quot;Deny from DataServer to AppServer on port 80&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121222017283.png" alt="image-20231121222017283"></p><h2 id="测试虚拟机之间的HTTP连接"><a href="#测试虚拟机之间的HTTP连接" class="headerlink" title="测试虚拟机之间的HTTP连接"></a>测试虚拟机之间的HTTP连接</h2><p>检查新的规则是否生效。 AppServer 应该能通过 HTTP 与 DataServer 进行通信。 DataServer 应无法通过 HTTP 与 AppServer 进行通信。</p><h3 id="APP-Data"><a href="#APP-Data" class="headerlink" title="APP - Data"></a>APP - Data</h3><p>通过 SSH 连接到 AppServer VM，并检查是否可以通过 HTTP 与 DataServer 进行通信。请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -t azureuser@<span class="variable">$APPSERVERIP</span> <span class="string">&#x27;wget http://10.0.1.4; exit; bash&#x27;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保以下事项：</p><ul><li><code>$APPSERVERIP</code> 变量已经被设置为你的 AppServer VM 的公共 IP 地址。确保该变量已经正确设置。</li><li><code>azureuser</code> 是 AppServer VM 上的用户名。如果你在创建 VM 时使用了不同的用户名，请相应地修改命令中的用户名。</li></ul><p>这个命令将通过 SSH 连接到指定的 AppServer VM，并执行以下操作：</p><ol><li>使用 <code>wget</code> 命令尝试从 DataServer VM 的 IP 地址 <code>10.0.1.4</code> 下载一个文件（这里是默认的 HTTP 请求）。</li><li>执行完 <code>wget</code> 命令后，退出 SSH 连接。</li><li>如果连接成功并且可以通过 HTTP 访问 DataServer VM，那么你将进入本地的 Bash shell。</li></ol><h3 id="Data-APP"><a href="#Data-APP" class="headerlink" title="Data - APP"></a>Data - APP</h3><p>通过 SSH 连接到 DataServer VM，并检查是否可以通过 HTTP 与 AppServer 进行通信。请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -t azureuser@<span class="variable">$DATASERVERIP</span> <span class="string">&#x27;wget http://10.0.0.4; exit; bash&#x27;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保以下事项：</p><ul><li><code>$DATASERVERIP</code> 变量已经被设置为你的 DataServer VM 的公共 IP 地址。确保该变量已经正确设置。</li><li><code>azureuser</code> 是 DataServer VM 上的用户名。如果你在创建 VM 时使用了不同的用户名，请相应地修改命令中的用户名。</li></ul><p>这个命令将通过 SSH 连接到指定的 DataServer VM，并执行以下操作：</p><ol><li>使用 <code>wget</code> 命令尝试从 AppServer VM 的 IP 地址 <code>10.0.0.4</code> 下载一个文件（这里是默认的 HTTP 请求）。</li><li>执行完 <code>wget</code> 命令后，退出 SSH 连接。</li><li>如果连接成功并且可以通过 HTTP 访问 AppServer VM，那么你将进入本地的 Bash shell。</li><li>因为已阻止端口 80 上的访问，所以此访问应该不会成功。 几分钟后，会收到一条 <code>Connection timed out</code> 消息。 若要在超时之前中止命令，请按 Ctrl+C。</li></ol><h2 id="部署应用安全组"><a href="#部署应用安全组" class="headerlink" title="部署应用安全组"></a>部署应用安全组</h2><p>创建应用安全组 “ERP-DB-SERVERS-ASG”：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network asg create \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 资源组的名称</span></span><br><span class="line">    --name ERP-DB-SERVERS-ASG  <span class="comment"># 应用安全组的名称</span></span><br></pre></td></tr></table></figure><p>将 DataServer 与应用安全组关联：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nic ip-config update \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 资源组的名称</span></span><br><span class="line">    --application-security-groups ERP-DB-SERVERS-ASG  <span class="comment"># 应用安全组的名称</span></span><br><span class="line">    --name ipconfigDataServer  <span class="comment"># NIC 配置的名称</span></span><br><span class="line">    --nic-name DataServerVMNic  <span class="comment"># NIC 的名称</span></span><br><span class="line">    --vnet-name ERP-servers  <span class="comment"># 虚拟网络的名称</span></span><br><span class="line">    --subnet Databases  <span class="comment"># 子网的名称</span></span><br></pre></td></tr></table></figure><p>更新网络安全组中的 HTTP 规则：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg rule update \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 资源组的名称</span></span><br><span class="line">    --nsg-name ERP-SERVERS-NSG  <span class="comment"># 网络安全组的名称</span></span><br><span class="line">    --name httpRule  <span class="comment"># 规则的名称</span></span><br><span class="line">    --direction Inbound  <span class="comment"># 流量方向为入站</span></span><br><span class="line">    --priority 150  <span class="comment"># 规则的优先级</span></span><br><span class="line">    --source-address-prefixes <span class="string">&quot;&quot;</span>  <span class="comment"># 源地址前缀为空，表示任意源地址</span></span><br><span class="line">    --source-port-ranges <span class="string">&#x27;*&#x27;</span>  <span class="comment"># 源端口范围为任意端口</span></span><br><span class="line">    --source-asgs ERP-DB-SERVERS-ASG  <span class="comment"># 源应用安全组为 &quot;ERP-DB-SERVERS-ASG&quot;</span></span><br><span class="line">    --destination-address-prefixes 10.0.0.4  <span class="comment"># 目标地址前缀为 DataServer 的 IP 地址</span></span><br><span class="line">    --destination-port-ranges 80  <span class="comment"># 目标端口范围为 80</span></span><br><span class="line">    --access Deny  <span class="comment"># 访问权限为拒绝</span></span><br><span class="line">    --protocol Tcp  <span class="comment"># 使用 TCP 协议</span></span><br><span class="line">    --description <span class="string">&quot;Deny from DataServer to AppServer on port 80 using application security group&quot;</span>  <span class="comment"># 规则的描述</span></span><br></pre></td></tr></table></figure><p>第一个命令将创建一个名为 “ERP-DB-SERVERS-ASG” 的应用安全组。<br>第二个命令将关联 DataServer VM 的网络接口配置（NIC）与应用安全组。<br>第三个命令将更新 ERP-SERVERS-NSG 网络安全组中的 HTTP 规则，将源地址设置为空，源端口设置为任意，源应用安全组设置为 “ERP-DB-SERVERS-ASG”，目标地址设置为 DataServer 的 IP 地址（10.0.0.4），目标端口设置为 80，并将访问权限设置为拒绝。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121222134518.png" alt="image-20231121222134518"></p><p>应用安全组确认了网络安全组规则能正常运行，并且与使用源 IP 地址时相同。 如果我们添加了其他数据服务器，可以通过将新的服务器添加到 ERP-DB-SERVERS-ASG 来轻松地确保这些服务器具备适当的网络安全。</p>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes</title>
      <link href="/2023/10/07/Kubernetes/"/>
      <url>/2023/10/07/Kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是K8s"><a href="#什么是K8s" class="headerlink" title="什么是K8s"></a>什么是K8s</h3><iframe width="956" height="538" src="https://www.youtube.com/embed/ubz3cFgxeJA" title="Kubernetes" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>k8s就是为了大规模管理容器应用的自动化工具而已</li><li>如果你的业务不是以容器方式管理或者数量非常小是没有必要玩k8s</li></ul><h2 id="架构以及核心组件"><a href="#架构以及核心组件" class="headerlink" title="架构以及核心组件"></a>架构以及核心组件</h2><ol><li><p>Master节点：Master节点是集群的控制面，包含以下几个核心组件：</p><ul><li><p>kube-apiserver：它是Kubernetes API的前端，是所有操作和通信的入口点。</p></li><li><p>etcd：这是一个高可用性键值存储系统，用于保存所有集群数据。</p></li><li><p>kube-scheduler：根据资源可用性、策略、约束等因素，调度新创建的Pod到合适的工作节点上。</p></li><li><p>kube-controller-manager：运行了一系列的控制器，如节点控制器、副本控制器、端点控制器等。</p></li><li><p>cloud-controller-manager: 这是一个链接你的集群与云提供商API的桥梁，使得集群能够在云环境中运行。</p></li></ul></li><li><p>Worker节点：Worker节点运行着实际的应用，并由master节点进行管理。它们包括以下组件：</p><ul><li><p>kubelet：负责维护Pods并且与Kubernetes master节点进行交互。</p></li><li><p>kube-proxy：在每个节点上实现了网络规则，以处理集群内部的通信。</p></li><li><p>vContainer Runtime：用于运行容器，如Docker、containerd等。</p></li></ul></li><li><p>Pods：这是Kubernetes的最小部署单元，每个Pod内包含一个或多个紧密相关的容器。</p></li><li><p>Services：定义了访问和通信Pods的方式。Service可以将网络流量路由到正确的Pod。</p></li><li><p>Volumes：提供存储功能，使得数据能够在Pod之间持久化。</p></li><li><p>Namespaces：为集群中的资源和对象提供隔离。</p></li><li><p>Ingress：管理外部访问集群内服务的规则，可实现负载均衡、SSL终止和域名基础的虚拟主机。</p></li><li><p>ConfigMaps and Secrets：允许你将配置信息和敏感数据分离出来，以便安全地传递和使用。</p></li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>  在Kubernetes中，用户通过API Server提交一个描述应用程序的YAML或JSON配置文件。Scheduler会根据集群资源使用情况，将应用部署到某个Node上。如果Node发生故障，Controller会自动将应用迁移到其他Node上。</p><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><h3 id="传统的服务进程管理方式"><a href="#传统的服务进程管理方式" class="headerlink" title="传统的服务进程管理方式"></a>传统的服务进程管理方式</h3><h4 id="手工繁琐-需要大量的自动化工具"><a href="#手工繁琐-需要大量的自动化工具" class="headerlink" title="手工繁琐:需要大量的自动化工具"></a>手工繁琐:需要大量的自动化工具</h4><ol><li><p>Ansible： Ansible 是一种配置管理和自动化工具，可用于编写声明性的配置文件来定义服务器的状态。您可以使用 Ansible 来自动化服务器的设置、软件安装、配置文件管理等操作。</p></li><li><p>Chef： Chef 是一个自动化平台，允许您编写基础设施即代码。您可以使用 Chef 来定义服务器的状态，并在需要时自动配置服务器和部署服务。</p></li><li><p>Puppet： Puppet 是另一个配置管理工具，允许您定义服务器配置的期望状态，并确保服务器始终保持一致。</p></li><li><p>SaltStack： SaltStack 是一个事件驱动的自动化工具，可以用于自动配置和管理服务器，以及执行各种任务。</p></li><li><p>Jenkins： Jenkins 是一个持续集成和持续交付工具，可以用于自动化构建、部署和测试应用程序。您可以将 Jenkins 配置为监视代码仓库，并在代码提交后自动触发部署流程。</p></li><li><p>Docker Compose： 如果您希望使用 Docker 容器来部署传统的服务进程，可以使用 Docker Compose 来定义和管理多个容器的部署。</p></li><li><p>Terraform： 虽然 Terraform 主要用于基础设施即代码，但您可以使用它来自动化创建和管理服务器、网络、存储等资源。</p></li><li><p>Kubernetes Operator： 尽管 Kubernetes 本身是一个容器编排平台，但您可以使用 Kubernetes Operator 来创建自定义控制器，以自动化管理和部署特定类型的应用程序。</p></li></ol><h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><ol><li><p>准备环境： 在目标虚拟机或物理机上设置所需的操作系统和依赖项。这可能涉及安装操作系统、更新软件包、安装运行时环境（如Java、Node.js等）等。</p></li><li><p>安装服务进程： 将服务进程的执行文件和相关文件传输到目标机器，并将其安装到适当的位置。这可能涉及将二进制文件复制到目标目录，并设置执行权限。</p></li><li><p>配置服务： 编辑服务的配置文件，配置它所需的参数，例如端口号、数据库连接、认证凭据等。这些配置可能会存储在配置文件中，也可能存储在环境变量中。</p></li><li><p>启动服务： 使用特定的命令或脚本启动服务进程。这可以是一个简单的命令，例如 ./my-service，也可能是一系列复杂的操作。</p></li><li><p>监控和日志： 配置监控和日志记录，以便能够监视服务的运行状态和性能，以及收集服务的日志信息。</p></li><li><p>管理和维护： 随着时间的推移，您可能需要执行服务的升级、修复漏洞、处理配置更改等操作。这可能需要定期的维护和管理。</p></li></ol><h3 id="容器应用管理方式"><a href="#容器应用管理方式" class="headerlink" title="容器应用管理方式"></a>容器应用管理方式</h3><ul><li>Pod：Pod是Kubernetes中最小的可部署单元，它可以包含一个或多个容器。Pod提供了一个运行容器的环境，并且这些容器共享网络和存储资源。Pod可以被创建、启动、停止、删除等操作。</li></ul><ul><li>Deployment：Deployment是用来管理Pod的对象。它定义了应用程序的期望状态，Kubernetes会根据定义的副本数来创建和管理Pod。Deployment还支持滚动升级和回滚操作，可以方便地更新应用程序。</li></ul><ul><li>Service：Service是用来暴露应用程序的网络服务的对象。它为一组Pod提供了一个稳定的网络地址，并且可以通过这个地址来访问这些Pod。Service可以提供负载均衡、服务发现和服务代理等功能。</li></ul><ul><li>Ingress：Ingress是用来管理应用程序的入口流量的对象。它可以将外部流量路由到不同的Service，实现基于域名或路径的流量分发。Ingress还支持SSL/TLS终止和基本的身份验证等功能。</li></ul><ul><li>ConfigMap和Secret：ConfigMap用来存储应用程序的配置信息，可以通过环境变量或挂载文件的方式将配置信息传递给容器。Secret用来存储敏感的配置信息，如密码、API密钥等。ConfigMap和Secret可以在应用程序中被引用和使用。</li></ul><ul><li>StatefulSet：StatefulSet用来管理有状态应用程序的对象。它可以确保每个Pod有唯一的标识和稳定的网络身份，这对于需要持久化存储和有序部署的应用程序非常重要。</li></ul><h2 id="服务发现与负载均衡"><a href="#服务发现与负载均衡" class="headerlink" title="服务发现与负载均衡"></a>服务发现与负载均衡</h2><p>服务发现和负载均衡是通过 Service 和 Ingress 对象来实现的。</p><ol><li>Service：<br> Service 是 Kubernetes 的核心概念之一，它为一组运行相同任务的 Pod 提供了一个统一的访问接口。当 Service 创建后，Kubernetes 会自动为其分配一个 IP 地址（称为 ClusterIP），并且在整个集群内部都可以使用这个 IP 地址进行访问。</li></ol><p>  当请求到达 Service 后，Kubernetes 会根据预设的策略将请求转发给后端的 Pod。这种策略通常是轮询（Round Robin）或者是基于 Session 的粘性 Session Affinity，也可以配置更复杂的网络策略。这就完成了负载均衡的功能。</p><p>  Service 还有一个重要的特性，那就是它可以做到服务发现。每个 Service 在创建时，除了会被分配一个 ClusterIP 外，还会在 Kubernetes 集群的内部 DNS 中创建一个记录。这样其他的 Pod 就可以通过 Service 的名字来找到它，而不需要知道具体的 IP 地址。</p><ol start="2"><li>Ingress：<br> 虽然 Service 可以提供内部的服务发现和负载均衡，但是如果我们希望从集群外部访问某个服务，就需要用到 Ingress。Ingress 是 Kubernetes 的一个对象，它定义了如何通过 HTTP 或 HTTPS 协议从集群外部访问内部的 Service。</li></ol><p>  当一个请求到达 Ingress 后，Ingress Controller 会根据预定义的规则将请求路由（Route）到相应的 Service。这样我们就可以用一个统一的入口来访问集群内部的多个服务，而不需要为每个服务都暴露一个端口出来。</p><p>  另外，Ingress 还可以提供其他的功能，比如 SSL/TLS 终止、基于路径或者域名的路由，甚至是负载均衡和重试等。</p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Kubernetes支持多种存储解决方案，包括本地存储、网络存储（如NFS、iSCSI、GlusterFS等）以及云存储（如AWS EBS、GCE PD等）。同时，Kubernetes还提供了Persistent Volume (PV) 和 Persistent Volume Claim (PVC) 的抽象概念，使得用户可以在不了解具体存储技术的情况下，也能使用持久化存储。</p><h3 id="本地存储："><a href="#本地存储：" class="headerlink" title="本地存储："></a>本地存储：</h3><p>  这是最简单的存储方式，即在Pod所在的节点上直接分配磁盘空间。但它的生命周期与Pod相同，当Pod被删除时，数据也会丢失。而且，如果Pod迁移到其他节点，数据将无法访问。因此，本地存储主要用于临时性的、不需要长期保存的数据。</p><h3 id="网络存储："><a href="#网络存储：" class="headerlink" title="网络存储："></a>网络存储：</h3><p>  为了解决本地存储的限制，我们可以使用网络存储。网络存储就是通过网络协议，将远程服务器上的存储资源连接到本地，使其看起来像是本地的磁盘。常见的网络存储协议包括NFS（Network File System）、iSCSI (Internet Small Computer Systems Interface) 和 GlusterFS等。这些网络存储解决方案提供了跨节点的、可共享的、持久性的存储。</p><h3 id="云存储："><a href="#云存储：" class="headerlink" title="云存储："></a>云存储：</h3><p>  对于在公有云平台上运行的Kubernetes集群，通常会使用云存储服务，如AWS的EBS (Elastic Block Store) 或者GCE的PD (Persistent Disk)。这些云存储服务通常提供了高可用、高性能和自动备份等高级功能。</p><h4 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h4><ul><li>是 Amazon Web Services 的一项服务，提供持久化、高性能、块级存储，可以与 AWS 的 EC2 实例一起使用。你可以创建一个 EBS 卷并将其附加到 EC2 实例上。然后，你可以像使用物理硬盘驱动器一样使用这个卷，包括文件系统、数据库或者应用程序等。EBS 提供了几种类型的卷，以满足不同的需求，例如：通用 SSD（gp2）、预配置 IOPS SSD（io1/io2）、吞吐优化 HDD（st1）、冷 HDD（sc1）和磁性（标准）。</li></ul><h4 id="PD"><a href="#PD" class="headerlink" title="PD"></a>PD</h4><p>Google Cloud Platform 的一项服务，为 Google Compute Engine 和 Google Kubernetes Engine 提供持久化、高性能的块存储。你可以创建一个 PD 卷并将其附加到 GCE 或 GKE 上的虚拟机实例。PD 提供了两种类型的卷：标准硬盘（HDD）和 SSD。SSD 可以分为常规 SSD 和高性能 Provisioned IOPS SSD。</p><h3 id="Persistent-Volume-PV-："><a href="#Persistent-Volume-PV-：" class="headerlink" title="Persistent Volume (PV)："></a>Persistent Volume (PV)：</h3><p>  Kubernetes引入了PV和PVC的概念，以解决存储的生命周期管理问题。PV是集群中的一块独立的存储空间，它与Pod的生命周期独立，即使Pod被删除，PV中的数据也不会丢失。管理员可以预先创建多个PV，并指定其大小、访问模式（只读、读写）等属性。</p><h3 id="Persistent-Volume-Claim-PVC-："><a href="#Persistent-Volume-Claim-PVC-：" class="headerlink" title="Persistent Volume Claim (PVC)："></a>Persistent Volume Claim (PVC)：</h3><p>  用户如果需要使用PV，必须通过创建一个PVC来申请。在PVC中，用户可以指定所需的存储空间大小、访问模式等信息。然后Kubernetes会自动匹配合适的PV给用户。当不再需要这个存储空间时，用户可以删除PVC，对应的PV会被释放，但数据不会丢失，除非管理员显式地删除PV。</p><h2 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h2><ol><li>日志：Kubernetes本身不提供一个原生的日志聚合解决方案，但是它允许使用各种通用的日志聚合工具。例如：</li></ol><p>Fluentd：一款开源数据收集器，可以整合各种类型的数据源，并将数据发送到多种类型的目标系统。</p><p>Logstash：这是Elastic Stack（ELK Stack）中的一部分，用于接收、处理和转发事件和日志消息。</p><p>Stackdriver Logging：Google Cloud Platform上的日志管理服务，也可以用于Kubernetes。</p><ol start="2"><li>监控：Kubernetes有内建的资源利用率和性能指标，比如CPU和内存使用情况。你可以使用以下工具来可视化这些数据：</li></ol><p>Prometheus：开源的监控和警告工具，与Kubernetes紧密集成，可以收集各种指标并提供强大的查询语言。</p><p>Grafana：开源的度量分析和可视化套件，经常与Prometheus一起使用，以图形方式展示Prometheus收集的数据。</p><p>Google Cloud Monitoring：Google Cloud Platform的服务，提供了完全托管的端到端IT运营管理平台，包括监控、日志管理和应用程序性能管理。</p><h2 id="Kubernetes与其他技术集成"><a href="#Kubernetes与其他技术集成" class="headerlink" title="Kubernetes与其他技术集成"></a>Kubernetes与其他技术集成</h2><ol><li>云服务提供商：Kubernetes 可以运行在各种环境中，包括公有云、私有云和混合云。AWS、Google Cloud 和 Azure 都提供了 Kubernetes 服务，如 Amazon EKS、Google GKE 和 Azure AKS。</li></ol><ol start="2"><li>CI/CD 工具：持续集成和持续部署（CI/CD）是现代 DevOps 实践的核心组成部分。Jenkins、GitLab CI、CircleCI 等工具都可以与 Kubernetes 集成，以自动化构建、测试和部署流程。</li></ol><ol start="3"><li>服务网格：服务网格用于控制服务间的通信。Istio 和 Linkerd 是两个常见的服务网格，它们可以与 Kubernetes 集成，提供高级路由、负载均衡、故障注入等功能。</li></ol><ol start="4"><li>配置管理：Helm 是 Kubernetes 的一个包管理器，类似于 Linux 中的 apt 或 yum。你可以使用 Helm 来打包、发布和管理 Kubernetes 应用。</li></ol><ol start="5"><li>安全性和策略执法：Open Policy Agent (OPA) 是一个轻量级的、通用的策略引擎，可以与 Kubernetes 集成，用于策略执法。</li></ol><ol start="6"><li>存储系统：Kubernetes 可以与各种存储系统集成，包括云存储服务（如 AWS EBS 和 Google Cloud Storage）、分布式文件系统（如 Ceph 和 GlusterFS）和数据库系统（如 MySQL 和 PostgreSQL）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cloud Konwleage </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS</title>
      <link href="/2023/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="第一部分：操作系统概述"><a href="#第一部分：操作系统概述" class="headerlink" title="第一部分：操作系统概述"></a>第一部分：操作系统概述</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>  是管理计算机硬件与软件资源的程序，是计算机系统中最基本的系统软件。操作系统需要处理管理与配置内存，决定系统资源供需的优先级，控制输入设备与输出设备，操作网络和管理文件系统等基本事务。</p><p><strong>注意：</strong>执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p><h4 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h4><ul><li>硬件之上</li><li>应用程序之下</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231001154949996.png" alt="image-20231001154949996"></p><ol><li>Linux,windows,Android界面属于外壳（shell）而不是内核（kernel），内核在外壳之下</li></ol><h4 id="kernel内部组件"><a href="#kernel内部组件" class="headerlink" title="kernel内部组件"></a>kernel内部组件</h4><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h3 id="1-2操作系统的类型和结构"><a href="#1-2操作系统的类型和结构" class="headerlink" title="1.2操作系统的类型和结构"></a>1.2操作系统的类型和结构</h3><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><ul><li><p>联机命令接口（Online Command Interface）：这种接口需要用户在命令执行过程中实时交互。例如，当一个程序运行时，它可能需要用户输入数据或选择选项。这种接口通常用于交互式应用程序，如文本编辑器或电子邮件客户端。在这种接口中，用户和计算机之间的交互是实时的，即用户的每个操作都会立即得到计算机的反馈。</p></li><li><p>脱机命令接口（Offline Command Interface）：这种接口允许用户在没有实时交互的情况下执行命令。用户可以预先设置一系列的命令，然后让计算机在适当的时间执行。这种接口通常用于批处理任务，如数据分析或报告生成。在这种接口中，用户和计算机之间的交互不是实时的，用户可以在任何时间设置命令，然后离开，等待计算机完成任务。</p></li></ul><h4 id="操作系统的类型"><a href="#操作系统的类型" class="headerlink" title="操作系统的类型"></a>操作系统的类型</h4><ol><li>批处理操作系统：这种类型的操作系统不与用户交互。所有需要执行的命令都被组织在批处理中，然后作为一个作业提交给系统。</li><li>多任务/多进程操作系统：也叫分时操作系统,这种类型的操作系统允许多个任务或进程同时运行。如Unix操作系统</li><li>多用户操作系统：这种类型的操作系统允许多个用户同时使用一个系统。</li><li>实时操作系统：这种类型的操作系统被设计用于实时应用程序，这些应用程序需要对事件的响应非常迅速。</li><li>分布式操作系统：这种类型的操作系统将多台机器的资源整合在一起，对用户来说就像一台机器一样。</li><li>嵌入式操作系统：这种类型的操作系统主要用于嵌入式系统，如家用电器、汽车等。</li></ol><h4 id="操作系统的基本结构"><a href="#操作系统的基本结构" class="headerlink" title="操作系统的基本结构"></a>操作系统的基本结构</h4><ol><li>单体结构：所有操作系统功能都被组织在一起并运行在同一地址空间。</li><li>分层结构：操作系统被划分为不同的层次，每一层都建立在其下一层的基础上。</li><li>微内核结构：只有最基本的系统功能（如进程调度、内存管理等）运行在内核空间，其他服务则运行在用户空间。</li><li>客户-服务器模型：这种结构将操作系统服务视为服务器，应用程序视为客户。客户通过向服务器发送请求来使用服务。</li><li>虚拟机：这是一种特殊的操作系统结构，它通过虚拟化技术模拟出一台或多台“虚拟”计算机，每台虚拟计算机都可以运行一个完整的操作系统。</li></ol><h3 id="1-3操作系统的四大特征"><a href="#1-3操作系统的四大特征" class="headerlink" title="1.3操作系统的四大特征"></a>1.3操作系统的四大特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ol><li><p>两个或多个事件在同一事件间隔内发生，这件事是在宏观上同时发生的，但微观上交替发生。</p></li><li><p>与并发不同的并行是指两个或多个事件在同一时刻同时发生。</p></li></ol><h5 id="操作系统的并发性"><a href="#操作系统的并发性" class="headerlink" title="操作系统的并发性"></a>操作系统的并发性</h5><p>操作系统就是伴随着“多道程序技术”而出现的。因此操作系统和程序并发是一起诞生的。</p><p><strong>注意：</strong></p><ol><li>单核CPU同一时刻只能执行一个程序，各个程序只能并发执行。</li><li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行执行。</li></ol><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><h5 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h5><p>在任意时刻，只允许一个进程访问资源，当一个进程正在访问某个资源时，其他需要访问资源的进程必须要等待。</p><h5 id="“同时”共享方式"><a href="#“同时”共享方式" class="headerlink" title="“同时”共享方式"></a>“同时”共享方式</h5><p>允许同一时刻，多个进程同时访问同一资源。能够被多个进程同时使用。</p><h5 id="并发和共享的关系。"><a href="#并发和共享的关系。" class="headerlink" title="并发和共享的关系。"></a>并发和共享的关系。</h5><p>  并发和共享的关系是相辅相成的，二者在操作系统中是密不可分的。并发运行的多个程序共享同一套系统资源，比如CPU时间、内存空间、文件系统和输入输出设备等。因此，共享是并发存在的基础。反过来，如果没有并发，也就没有资源共享的必要性。</p><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ol><li>是用多道程序设计技术。</li><li>操作系统将物理资源抽象为虚拟资源，如虚拟内存，虚拟处理器和虚拟设备等。虚拟性使得多个程序可以独立运行，它们实际上是共享同一组物理资源得虚拟实例。虚拟性提供了更好的资源管理和隔离性能。提高了系统的可靠性和安全性。</li></ol><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ol><li>任务的执行不需要等待前一个任务的完成才能执行下一个任务的能力。在异步操作中，任务可以并行执行或按照优先级进行调度，不依赖其他任务的完成状态。</li><li>程序的执行不是一贯到底，而是走停交接，推进的速度是不可预知的。</li><li>只要运行环境相同，OS需要保证程序运行的结果也要相同。</li></ol><h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li>DISK：存放OS，一开始是放在硬盘上，并没有在cpu上</li><li>BIOS：基本的IO处理系统，检测外设</li><li>Bootloader：加载OS，把硬盘中的OS放在CPU上</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231001180454793.png" alt="image-20231001180454793"></li></ul><h4 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h4><ol><li>加电自检（Power-On Self-Test，POST）：计算机开机后，会进行一系列的硬件自检，包括检查内存、显示适配器、硬盘驱动器等。如果自检过程中发现硬件故障，计算机可能会发出警报或显示错误信息。</li></ol><ol start="2"><li>BIOS/UEFI 初始化：自检完成后，计算机会加载并执行基本输入/输出系统（Basic Input/Output System，BIOS）或统一固件接口（Unified Extensible Firmware Interface，UEFI）。BIOS/UEFI负责初始化硬件设备，包括检测和配置内存、硬盘驱动器、键盘、鼠标等。</li></ol><ol start="3"><li>引导加载程序（Boot Loader）：BIOS/UEFI会在启动设备（通常是硬盘驱动器）上查找引导加载程序。引导加载程序是一个小型的程序，负责加载操作系统的核心组件。</li></ol><ol start="4"><li>操作系统内核加载：引导加载程序会加载操作系统内核到计算机的内存中。内核是操作系统的核心部分，负责管理计算机的资源和提供各种系统服务。</li></ol><ol start="5"><li>初始化和配置：操作系统内核加载后，会进行初始化和配置过程。这包括初始化设备驱动程序、建立系统数据结构、加载配置文件等。</li></ol><ol start="6"><li>用户登录：一旦操作系统初始化完成，计算机会显示登录界面，用户可以输入用户名和密码进行登录。</li></ol><ol start="7"><li>桌面环境加载：用户登录后，操作系统会加载桌面环境，例如Windows的资源管理器或Linux的图形用户界面（Graphical User Interface，GUI）。桌面环境提供了用户与计算机交互的图形界面。</li></ol><h3 id="中断，异常和系统调用"><a href="#中断，异常和系统调用" class="headerlink" title="中断，异常和系统调用"></a>中断，异常和系统调用</h3><h4 id="中断（来源于外设-异步处理）"><a href="#中断（来源于外设-异步处理）" class="headerlink" title="中断（来源于外设/异步处理）"></a>中断（来源于外设/异步处理）</h4><ul><li> 来自不同的硬件设备的计时器和网络的中断。</li><li> 操作系统回中断当前正在执行的程序，保存当前状态，并跳转道中断处理程序处理该事件。</li><li> 允许操作系统对外部事件做出及时响应</li><li> 持续,对用户程序是透明的.<h5 id="及时响应"><a href="#及时响应" class="headerlink" title="及时响应"></a>及时响应</h5></li><li>合理的时间内对外部事件做出快速的反应和处理.</li><li>意味着操作系统能够迅速中断当前程序,并跳转道相应的中断处理程序来处理事件.</li></ul><h4 id="系统调用（来源于应用程序-异步或同步处理）"><a href="#系统调用（来源于应用程序-异步或同步处理）" class="headerlink" title="系统调用（来源于应用程序/异步或同步处理）"></a>系统调用（来源于应用程序/异步或同步处理）</h4><ul><li>应用程序主动向操作系统发出服务请求</li><li>等待和持续</li></ul><h4 id="异常（来源于不良的应用程序-同步处理）"><a href="#异常（来源于不良的应用程序-同步处理）" class="headerlink" title="异常（来源于不良的应用程序/同步处理）"></a>异常（来源于不良的应用程序/同步处理）</h4><ul><li>执行程序中出现错误或异常的情况,例如除零错误,无效指令或内存访问错误.</li><li>杀死或重新执行意想不到的应用程序指令</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="2-1-进程的概念"><a href="#2-1-进程的概念" class="headerlink" title="2.1 进程的概念"></a>2.1 进程的概念</h3><ul><li>进程是操作系统就进行资源分配和调度的基本单位,是由程序,数据以及进程控制块三部分组成.</li><li>每个进程都有自己独立的空间地址,无法访问其他进程的内存,它们之间的信息交换需要通过操作系统提供的机制进行<h3 id="2-2-进程的生命周期"><a href="#2-2-进程的生命周期" class="headerlink" title="2.2 进程的生命周期"></a>2.2 进程的生命周期</h3>进程的生命周期由以下五个状态组成：</li><li>新建：进程刚被创建，但还未被调度到运行的状态。</li><li>就绪：进程已经准备好运行，正在等待系统分配资源。</li><li>运行：进程正在CPU上执行。</li><li>等待（阻塞）：进程因为某些事件（比如I/O操作）而暂停执行。</li><li>结束：进程已经完成执行。</li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>除了上面的五大基本状态外还会存在一些特殊的状态:</p><ol><li><p><strong>僵尸（Zombie）状态</strong>：当一个进程完成执行（终止）后，它需要将退出状态返回给父进程。如果父进程还没有请求这个状态信息，那么终止的进程就会进入僵尸状态。僵尸进程不再执行任何操作，但仍然在进程表中占据一个位置，直到父进程获取了其状态信息。例如，如果你在Linux终端中运行一个程序并且这个程序已经结束，但是你没有关闭终端，那么这个程序就是一个僵尸进程。</p></li><li><p><strong>孤儿（Orphan）状态</strong>：如果一个进程的父进程在它之前结束，那么这个进程就会变成孤儿进程。孤儿进程将被init进程（在Unix和Linux系统中，init是一个始终运行的进程，它是所有其他进程的祖先）接管，init会周期性地收集这些孤儿进程的状态信息，防止它们变成僵尸进程。例如，如果你在Linux终端中运行一个后台程序（使用&amp;运行），然后关闭终端，那么这个程序就会成为孤儿进程。</p></li><li><p><strong>阻塞（Blocked）状态</strong>：进程因为等待某个事件（如I/O操作）完成而无法继续运行，即使CPU是空闲的，这个进程也不会被调度到CPU上运行，直到所等待的事件完成。例如，如果一个进程正在读取一个非常大的文件，而这个文件的读取需要一些时间，那么在这个时间内，进程就会处于阻塞状态。</p></li><li><p><strong>后台（Background）状态</strong>：后台进程是在后台运行的进程，它们在命令行界面中被启动并放在后台运行，不会影响用户在前台的操作。例如，如果你在Linux终端中使用&amp;运行一个程序，那么这个程序就会在后台运行。</p></li><li><p><strong>睡眠（Sleeping）状态</strong>：进程正在等待某个条件变为真，例如等待时间、等待某个信号、等待资源可用等。在睡眠状态的进程不会占用CPU资源。例如，如果一个进程正在等待用户的输入，那么在用户输入之前，这个进程就会处于睡眠状态。</p></li><li><p><strong>停止（Stopped）状态</strong>：进程由于收到信号而被停止，例如用户可以发送SIGSTOP信号来停止一个进程。停止的进程可以通过SIGCONT信号来恢复执行。例如，如果你在Linux终端中运行一个程序，并且使用Ctrl+Z暂停它，那么这个程序就会进入停止状态。</p></li></ol><h3 id="2-3-进程调度"><a href="#2-3-进程调度" class="headerlink" title="2.3 进程调度"></a>2.3 进程调度</h3><p>进程调度是操作系统的重要功能之一，它决定了哪个进程可以获得CPU的使用权，以及可以使用多长时间。这通常由操作系统的调度策略决定，比如先来先服务（FCFS）、短作业优先（SJF）、优先级调度、时间片轮转（RR）等。</p><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>进程按照它们到达的顺序进行调度。例如，打印作业通常使用FCFS调度，因为我们希望打印任务按照提交的顺序完成。</p><h4 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h4><p>选择最短的作业（进程）首先执行。例如，在批处理系统中，我们可能希望最短的作业先完成，以便快速释放系统资源。</p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>每个进程都有一个优先级，优先级高的进程先执行。例如，在实时系统中，我们可能需要某些关键任务（如飞机的飞行控制）具有高于其他任务的优先级。</p><h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h4><p>进程被赋予一个固定的时间片（或称为时间量）。当一个进程的时间片用完时，操作系统就会剥夺该进程的CPU，将其转移到就绪队列的末尾，然后将CPU分配给下一个进程。这种调度算法常用于交互式系统，例如，多用户系统中，为了让每个用户都有公平的CPU使用时间，通常使用时间片轮转调度算法。</p><h3 id="2-4-多进程和多线程"><a href="#2-4-多进程和多线程" class="headerlink" title="2.4 多进程和多线程"></a>2.4 多进程和多线程</h3><p>多进程和多线程是操作系统中两种重要的并发执行技术。它们都可以提高系统的性能和响应时间，但是它们的实现方式和使用场景有所不同。</p><ol><li>多进程：</li></ol><p>进程是操作系统进行资源分配和调度的基本单位，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。多进程意味着有多个进程同时运行。每个进程都有自己的独立地址空间，进程之间的通信需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。</p><p>优点：每个进程有自己的独立地址空间，一个进程崩溃不会影响其他进程，安全性和稳定性较高。</p><p>缺点：进程的创建和销毁以及进程切换的开销较大，进程间通信复杂。</p><ol start="2"><li>多线程：</li></ol><p>线程是进程中的执行单元，是CPU调度和分派的基本单位。一个进程可以包含多个线程，它们共享进程的地址空间和资源，线程之间的通信比进程间通信更简单。</p><p>优点：线程的创建和销毁以及线程切换的开销小于进程，线程间通信简单。</p><p>缺点：因为线程共享进程的地址空间和资源，一个线程崩溃可能会影响整个进程，安全性和稳定性较低。</p><p>在实际应用中，多进程通常用于CPU密集型任务，如科学计算、图像处理等，而多线程通常用于IO密集型任务，如网络服务、图形界面等。</p><h4 id="进程间通信（IPC）机制"><a href="#进程间通信（IPC）机制" class="headerlink" title="进程间通信（IPC）机制"></a>进程间通信（IPC）机制</h4><ol><li><p>管道（Pipe）：管道是最早的IPC机制之一，它允许一个进程向另一个进程传递数据。管道通常遵循“先进先出”（FIFO）原则，数据从管道的一端进入，从另一端出来。</p></li><li><p>消息队列（Message Queue）：消息队列允许一个或多个进程向队列中添加消息，其他进程可以从队列中读取或删除消息。消息队列是一种比管道更灵活的IPC机制，因为它允许多个进程同时读写消息。</p></li></ol><ol start="3"><li>信号（Signal）：信号是一种用于通知进程某个事件已经发生的IPC机制。当一个进程收到一个信号时，它可以选择忽略这个信号、捕获并处理这个信号，或者按照默认的方式处理这个信号。</li></ol><ol start="4"><li>共享内存（Shared Memory）：共享内存允许多个进程访问同一块内存区域。这是一种非常高效的IPC机制，因为进程可以直接读写这块内存，而无需通过操作系统进行数据传输。但是，使用共享内存需要解决数据访问的同步问题，以防止多个进程同时修改同一块内存。</li></ol><ol start="5"><li>套接字（Socket）：套接字是一种网络通信的IPC机制，它允许运行在不同机器上的进程进行通信。套接字可以支持TCP/IP、UDP等多种网络协议。</li></ol><ol start="6"><li>信号量（Semaphore）：信号量主要用于解决多进程同步问题，它是一个整数值，可以用于控制对共享资源的访问。</li></ol><h3 id="2-5-线程的概念和实现"><a href="#2-5-线程的概念和实现" class="headerlink" title="2.5 线程的概念和实现"></a>2.5 线程的概念和实现</h3><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。每个线程都有自己的一组CPU寄存器（如程序计数器，堆栈指针，累加器等），以及自己的堆栈空间，用于保存运行中的临时数据。但线程并不拥有系统资源，它与其它线程共享所属进程的资源。线程的实现主要有两种方式：用户级线程和内核级线程。</p><h4 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h4><p>用户级线程和内核级线程是两种不同的线程实现方式，它们的主要区别在于管理线程的实体不同，以及对操作系统可见性的不同。</p><ol><li><p>用户级线程（User-Level Threads）：</p><p>用户级线程是完全在用户级别运行的线程，也就是说线程的创建、调度和管理都是由用户程序自行完成的，操作系统对其一无所知。这种方式的优点是线程切换开销小，不需要进行系统调用，同时可以定制化线程调度算法。但是，缺点是如果一个线程开始进行阻塞操作，那么整个进程（包括其中的所有线程）都会被阻塞，因为操作系统只能看到进程级别的阻塞。另外，由于操作系统对用户级线程不可见，因此不能利用多处理器并行处理。</p></li><li><p>内核级线程（Kernel-Level Threads）：</p><p>内核级线程是由操作系统内核进行管理的线程。线程的创建、调度和管理都是由操作系统内核完成。这种方式的优点是，由于线程对操作系统可见，因此一个线程进行阻塞操作时，不会影响到同一进程中的其他线程，同时可以利用多处理器进行并行处理。但是，缺点是线程切换需要进行系统调用，开销比用户级线程大。</p></li></ol><h2 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h2><h3 id="3-1-并发性的概念"><a href="#3-1-并发性的概念" class="headerlink" title="3.1 并发性的概念"></a>3.1 并发性的概念</h3><p>并发性是指两个或多个事件在同一时间间隔内发生。在计算机科学中，这通常指的是能够让多个任务在一段时间内同时运行的能力。并发并不意味着这些事件必须在同一时刻发生，实际上，在多核处理器中，这可能会发生，但在单核处理器中，这些事件是交替发生的。</p><h3 id="3-2-临界区和互斥"><a href="#3-2-临界区和互斥" class="headerlink" title="3.2 临界区和互斥"></a>3.2 临界区和互斥</h3><p>临界区是一个代码区域，其中包含访问共享资源的代码，这些资源在任何时候只能被一个线程使用。为了避免资源的冲突访问，必须确保在同一时间只有一个线程能够执行临界区的代码，这就需要使用互斥机制。</p><p>互斥是一种保护共享资源不被多个线程同时访问的方法。实现互斥的一种常见方法是使用锁，一个线程在访问资源时会锁定它，阻止其他线程访问，当它完成后会解锁，允许其他线程访问。</p><h3 id="3-3-死锁的概念和处理"><a href="#3-3-死锁的概念和处理" class="headerlink" title="3.3 死锁的概念和处理"></a>3.3 死锁的概念和处理</h3><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局（即阻塞状态），若无外力作用，它们都将无法推进下去。</p><h4 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h4><ol><li><p>预防死锁：这是最直接的方式，通过确保系统在分配资源时不满足死锁的4个必要条件（互斥、占有并等待、不可抢占、循环等待）中的一个或多个，从而预防死锁的发生。例如，只允许进程在没有占有任何资源的情况下请求资源，或者只允许进程一次性请求所有需要的资源。</p></li><li><p>避免死锁：在资源分配时采用某种算法进行动态检测，例如银行家算法，通过预测分配资源后系统的状态，如果可能导致死锁，则不分配。</p></li><li><p>检测死锁：定期检查系统资源分配状态，如果发现死锁，则进行处理。这种方法需要系统维护一个资源分配图，并定期进行检查。</p></li><li><p>解除死锁：当检测到死锁后，采取一些措施来解除死锁，例如撤销进程、剥夺资源、进程回滚等。</p></li></ol><p>实践中，处理死锁的方法需要根据系统的具体需求和资源管理策略来选择。有些系统可能会选择预防或避免死锁，而有些系统可能会选择允许死锁的发生，但会设定一定的机制来检测和解除死锁。</p><h3 id="3-4-同步机制"><a href="#3-4-同步机制" class="headerlink" title="3.4 同步机制"></a>3.4 同步机制</h3><p>同步是指在多个进程（或线程）中，为了保证这些进程（或线程）之间能有序地访问某些共享资源或完成某些特定任务，需要它们之间进行某种协调或通信。</p><h4 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h4><p>信号量是一个整数值，可以用来解决临界区问题，实现进程或线程之间的同步与互斥。信号量有两种操作：P（等待）和V（信号）。P操作会检查信号量的值，如果值大于零则将其减一；如果值为零则挂起执行。V操作则会将信号量的值加一，如果有挂起的进程或线程，则唤醒它们。</p><h4 id="条件变量（Condition-Variables）"><a href="#条件变量（Condition-Variables）" class="headerlink" title="条件变量（Condition Variables）"></a>条件变量（Condition Variables）</h4><p>条件变量常与互斥锁（Mutex）一起使用，用于线程间的同步。一个线程会因为某个条件不满足而在条件变量上等待，当条件满足时，另一个线程会通知在条件变量上等待的线程。</p><h4 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h4><p>管程是一种同步机制，它将共享变量的操作和条件检查集中在一个数据结构中，通过对这个数据结构的互斥访问实现同步。管程内部通常包含共享变量、操作共享变量的一组过程、以及用于同步的条件变量。</p><h4 id="消息传递（Message-Passing）"><a href="#消息传递（Message-Passing）" class="headerlink" title="消息传递（Message Passing）"></a>消息传递（Message Passing）</h4><p>消息传递是一种进程间通信方式，进程通过发送和接收消息进行通信。消息传递可以是同步的（发送者发送消息后必须等待接收者接收消息），也可以是异步的（发送者发送消息后可以继续执行，不必等待接收者接收消息）。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="4-1-内存的概念"><a href="#4-1-内存的概念" class="headerlink" title="4.1 内存的概念"></a>4.1 内存的概念</h3><p>内存是计算机的一种重要硬件设备，它用于存储和获取数据。内存是计算机中的临时存储区域，它可以在短时间内存储大量的信息，并且可以被处理器快速访问。内存是由一系列的存储单元组成，每个存储单元都有一个唯一的地址，用于标识数据的位置。</p><h3 id="4-2-内存分配策略"><a href="#4-2-内存分配策略" class="headerlink" title="4.2 内存分配策略"></a>4.2 内存分配策略</h3><p>内存分配策略是操作系统用于管理内存的方法，主要有以下几种：</p><ul><li>首次适应（First Fit）：这种方法是在内存中查找第一个足够大的空闲区域分配给进程。</li><li>最佳适应（Best Fit）：这种方法是在内存中查找最小但足够大的空闲区域分配给进程。</li><li>最坏适应（Worst Fit）：这种方法是在内存中查找最大的空闲区域分配给进程。</li></ul><h3 id="4-3-分页和分段"><a href="#4-3-分页和分段" class="headerlink" title="4.3 分页和分段"></a>4.3 分页和分段</h3><p>分页和分段是两种内存管理技术。</p><ul><li><p>分页：是将物理内存分成固定大小的页，每页的大小通常设置为4KB。当程序需要内存时，操作系统会分配一个或多个页。分页可以减少内存碎片，提高内存利用率。</p></li><li><p>分段：是将程序分成一些逻辑上独立的段，每个段可以独立地加载到内存中。分段可以使程序更易于理解和修改，也可以提高内存利用率。</p></li></ul><h3 id="4-4-虚拟内存和页面替换算法"><a href="#4-4-虚拟内存和页面替换算法" class="headerlink" title="4.4 虚拟内存和页面替换算法"></a>4.4 虚拟内存和页面替换算法</h3><p>虚拟内存是一种内存管理技术，它使得程序可以使用比物理内存更多的内存。虚拟内存通过将内存和硬盘结合起来，使得程序可以使用硬盘上的空间作为内存使用。</p><p>页面替换算法是虚拟内存系统中的一种技术，用于决定当内存已满时，哪个页面应该被替换出内存。常见的页面替换算法有FIFO（先进先出）、LRU（最近最少使用）等。</p><h4 id="FIFO（先进先出）："><a href="#FIFO（先进先出）：" class="headerlink" title="FIFO（先进先出）："></a>FIFO（先进先出）：</h4><p>  这是一种简单直观的策略，遵循的原则是先进入的数据先出去。例如，如果你有一个缓存空间，当它满了以后，你需要为新的数据项腾出空间，那么你会选择最早进入缓存的数据项进行替换。这种策略的优点是实现简单，但可能会导致频繁访问的数据被替换出去。</p><h4 id="LRU（最近最少使用）："><a href="#LRU（最近最少使用）：" class="headerlink" title="LRU（最近最少使用）："></a>LRU（最近最少使用）：</h4><p>  这种策略的原则是最近最少使用的数据最先被替换。这意味着如果一个数据项最近被访问过，那么在将来它被再次访问的可能性就更大。因此，当缓存满了以后，LRU策略会选择最长时间未被访问的数据项进行替换。这种策略相比FIFO能更好地处理局部性原理，即最近访问过的数据在未来可能再次被访问。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="5-1-文件系统的概念"><a href="#5-1-文件系统的概念" class="headerlink" title="5.1 文件系统的概念"></a>5.1 文件系统的概念</h3><p>文件系统是操作系统用于存储、组织、管理和访问计算机中的数据的一种方法。它定义了文件的命名规则，如何存储这些文件，以及如何从存储介质中检索这些文件。文件系统可以是磁盘文件系统，网络文件系统，或者分布式文件系统等。</p><h3 id="5-2-文件的存储和管理"><a href="#5-2-文件的存储和管理" class="headerlink" title="5.2 文件的存储和管理"></a>5.2 文件的存储和管理</h3><p>文件的存储和管理涉及到文件的创建、删除、读取、写入等操作。文件系统通常将文件存储在硬盘或其他形式的存储设备上。文件系统将存储设备分成一些小的存储单位，如扇区或块，然后将文件的数据存储在这些单位中。文件系统还需要管理文件的元数据，如文件名、文件大小、文件创建时间等。</p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><ul><li>元数据（Metadata）是用来描述其他数据的数据。它提供了关于其他数据的有用信息，但并不包含数据本身。元数据可以帮助我们理解数据的来源、结构、含义、时间和空间等相关信息。</li></ul><p>例如，一张照片的元数据可能包括拍摄日期、相机类型、ISO设置、焦距等信息；一首歌曲的元数据可能包括歌曲名称、艺术家、专辑、发行日期等信息；一个文件的元数据可能包括文件名、创建日期、修改日期、文件大小等信息。</p><ul><li>在数据库中，元数据可以描述数据表的名称、列的名称和类型、约束等信息；在网页中，元数据（如HTML的meta标签）可以描述网页的标题、描述、关键词等信息，这对搜索引擎优化（SEO）非常重要。</li></ul><h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><ul><li>广泛使用的密码散列函数</li><li>MD5常常用于检查数据的完整性。例如，在文件传输或存储的过程中，为了确保文件没有在传输或存储过程中被修改，我们可以计算文件的MD5值并将其存储为文件的元数据。当我们再次需要使用文件时，可以重新计算文件的MD5值并与存储的元数据中的MD5值进行比较，如果两者一致，那么就可以认为文件没有被修改。</li></ul><h3 id="5-3-文件的保护和安全"><a href="#5-3-文件的保护和安全" class="headerlink" title="5.3 文件的保护和安全"></a>5.3 文件的保护和安全</h3><p>文件的保护和安全是文件系统的重要组成部分。文件系统通常提供一些机制来保护文件，防止未经授权的访问或修改。这些机制包括文件权限、文件所有权、访问控制列表等。此外，文件系统可能还提供数据加密功能，以增加数据的安全性。</p><h4 id="文件权限："><a href="#文件权限：" class="headerlink" title="文件权限："></a>文件权限：</h4><p>文件权限决定了哪些用户或用户组可以访问或修改文件。在Unix和Linux系统中，文件权限通常分为读（r）、写（w）和执行（x）三类，每类权限可以赋予文件的所有者、所在组的成员以及其他用户。</p><h4 id="文件所有权："><a href="#文件所有权：" class="headerlink" title="文件所有权："></a>文件所有权：</h4><p>文件所有权决定了文件的所有者和所属的用户组。文件所有者通常可以更改文件的权限，包括决定哪些用户可以读取、写入或执行文件。</p><h4 id="访问控制列表："><a href="#访问控制列表：" class="headerlink" title="访问控制列表："></a>访问控制列表：</h4><p>ACL是一种更细粒度的权限控制机制。它允许管理员为每个用户或用户组分别设置文件的访问权限，而不仅仅是基于文件所有者和用户组。ACL可以为特定用户提供更具体的权限，比如只读、只写或读写权限。</p><h3 id="5-4-目录结构"><a href="#5-4-目录结构" class="headerlink" title="5.4 目录结构"></a>5.4 目录结构</h3><p>目录结构是文件系统用来组织文件的方式。在大多数文件系统中，文件被组织成一种层次结构，称为目录树。每个文件都有一个路径，表示其在目录树中的位置。目录可以包含文件和其他目录。目录结构使用户和应用程序可以方便地找到和管理文件。</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="6-1-设备管理的概念"><a href="#6-1-设备管理的概念" class="headerlink" title="6.1 设备管理的概念"></a>6.1 设备管理的概念</h3><p>设备管理是操作系统的一部分，主要负责管理和控制所有的输入/输出设备。设备管理的主要任务包括设备驱动程序的管理，设备调度，缓冲管理等。设备管理的主要目标是提高设备的利用率和系统的吞吐量，同时也要保证系统的公平性和响应时间。</p><h3 id="6-2-设备驱动程序"><a href="#6-2-设备驱动程序" class="headerlink" title="6.2 设备驱动程序"></a>6.2 设备驱动程序</h3><p>设备驱动程序是操作系统的一部分，用于管理和控制特定硬件设备。它是硬件设备和操作系统之间的接口，用于转换操作系统的指令为硬件设备可以理解的指令。设备驱动程序通常是由硬件制造商提供的，可以根据硬件设备的特性和操作系统的要求进行定制。</p><h3 id="6-3-设备调度"><a href="#6-3-设备调度" class="headerlink" title="6.3 设备调度"></a>6.3 设备调度</h3><p>设备调度是设备管理的一部分，主要负责决定哪个进程可以使用设备，以及何时可以使用设备。设备调度的目标是提高设备的利用率和系统的吞吐量，同时也要保证系统的公平性和响应时间。设备调度策略通常包括先来先服务（FCFS），最短寻道时间优先（SSTF），扫描（SCAN）等。</p><h4 id="先来先服务（FCFS，First-Come-First-Served）："><a href="#先来先服务（FCFS，First-Come-First-Served）：" class="headerlink" title="先来先服务（FCFS，First-Come, First-Served）："></a>先来先服务（FCFS，First-Come, First-Served）：</h4><p>  这是最简单的磁盘调度算法。操作系统按照请求到达的顺序来处理它们。这种方法的主要缺点是可能会导致“饥饿”现象，即某些请求可能需要等待很长时间才能得到处理。</p><h4 id="最短寻道时间优先（SSTF，Shortest-Seek-Time-First）："><a href="#最短寻道时间优先（SSTF，Shortest-Seek-Time-First）：" class="headerlink" title="最短寻道时间优先（SSTF，Shortest Seek Time First）："></a>最短寻道时间优先（SSTF，Shortest Seek Time First）：</h4><p>  在这种算法中，磁头会移动到距离当前位置最近的磁道。这种方法可以减少磁头移动的总时间，从而提高磁盘的性能。但是，它也可能导致饥饿现象。</p><h4 id="扫描（SCAN）："><a href="#扫描（SCAN）：" class="headerlink" title="扫描（SCAN）："></a>扫描（SCAN）：</h4><p>  在这种算法中，磁头从一端开始，逐渐向另一端移动，处理所有在其路径上的请求。当磁头到达磁盘的一端时，它会改变方向并继续扫描。这种方法被比喻为电梯运行，因此也被称为电梯算法。SCAN算法相比FCFS和SSTF更公平，因为它确保了所有的请求都会得到处理。</p><h3 id="6-4-缓冲管理"><a href="#6-4-缓冲管理" class="headerlink" title="6.4 缓冲管理"></a>6.4 缓冲管理</h3><p>  缓冲管理是设备管理的一部分，主要负责管理和控制缓冲区的使用。缓冲区是一种临时存储区，用于存储从设备读取的数据或者要写入设备的数据。缓冲管理的目标是提高设备的利用率和系统的吞吐量，同时也要保证系统的公平性和响应时间。缓冲管理策略通常包括单缓冲，双缓冲，循环缓冲等。</p><h2 id="安全与保护"><a href="#安全与保护" class="headerlink" title="安全与保护"></a>安全与保护</h2><h3 id="7-1-操作系统的安全问题"><a href="#7-1-操作系统的安全问题" class="headerlink" title="7.1 操作系统的安全问题"></a>7.1 操作系统的安全问题</h3><p>操作系统是计算机系统的核心，也是最容易受到攻击的部分。例如，黑客可能通过漏洞攻击操作系统，获取系统权限，进而对系统进行不法操作。例如，勒索软件”WannaCry”就是利用Windows系统的一个漏洞，对全球范围内的计算机进行攻击，导致大量数据丢失。</p><h3 id="7-2-访问控制和用户身份验证"><a href="#7-2-访问控制和用户身份验证" class="headerlink" title="7.2 访问控制和用户身份验证"></a>7.2 访问控制和用户身份验证</h3><p>访问控制和用户身份验证是保护信息系统安全的重要手段。例如，银行系统会通过密码和二次验证（如手机短信验证码）的方式，来验证用户的身份。此外，一些高安全级别的系统，如军事系统，可能还会使用生物特征（如指纹、虹膜）进行身份验证。</p><h3 id="7-3-病毒和防火墙"><a href="#7-3-病毒和防火墙" class="headerlink" title="7.3 病毒和防火墙"></a>7.3 病毒和防火墙</h3><p>病毒是一种能够自我复制并传播的恶意软件。例如，”ILOVEYOU”病毒在2000年通过电子邮件传播，导致全球范围内的大量计算机系统崩溃。防火墙则是一种可以阻止恶意软件进入系统的设备或软件。例如，家用路由器通常都内置了防火墙，可以阻止外部网络对家庭内部网络的非法访问。</p><h3 id="7-4-加密和网络安全"><a href="#7-4-加密和网络安全" class="headerlink" title="7.4 加密和网络安全"></a>7.4 加密和网络安全</h3><p>加密技术是保护数据安全的重要手段。例如，当我们在网上购物时，信用卡信息会通过HTTPS协议进行加密，防止数据在传输过程中被窃取。网络安全则是保护网络系统不受攻击的一系列措施。例如，一些公司会定期进行网络安全演练，以提高员工对网络安全的意识，防止社会工程学攻击。</p><h2 id="现代操作系统"><a href="#现代操作系统" class="headerlink" title="现代操作系统"></a>现代操作系统</h2><h3 id="8-1-分布式操作系统"><a href="#8-1-分布式操作系统" class="headerlink" title="8.1 分布式操作系统"></a>8.1 分布式操作系统</h3><p>分布式操作系统是一种控制和协调多台计算机共同工作的操作系统。在一个分布式系统中，用户可以访问远程资源就像访问本地资源一样。分布式操作系统提供了数据的一致性、容错性和并发性。</p><p>例如，Google的分布式文件系统GFS，它将文件分割成多个块存储在不同的节点上，从而提高了数据的可靠性和访问速度。Apache Hadoop也是一个著名的分布式操作系统，专门用于处理大数据。</p><h3 id="8-2-实时操作系统"><a href="#8-2-实时操作系统" class="headerlink" title="8.2 实时操作系统"></a>8.2 实时操作系统</h3><p>实时操作系统（RTOS）是为了控制实时应用程序而设计的操作系统，它能在特定的时间内稳定且预测性地响应外部事件。RTOS通常用于嵌入式系统如飞行控制系统、工厂自动化控制系统等。</p><p>例如，VxWorks是一个广泛使用的实时操作系统，被广泛应用在航空、航天、军事、网络通信等领域。另一个例子是FreeRTOS，一种开源的微型实时操作系统，适用于各种小型嵌入式设备。</p><h3 id="8-3-嵌入式操作系统"><a href="#8-3-嵌入式操作系统" class="headerlink" title="8.3 嵌入式操作系统"></a>8.3 嵌入式操作系统</h3><p>嵌入式操作系统是专为嵌入式系统设计的，通常需要具有实时性、稳定性、小型化和低功耗等特点。嵌入式操作系统通常用于智能家电、工业控制设备、车载电子设备等。</p><p>例如，QNX是一种商业的嵌入式操作系统，被广泛应用在汽车、医疗、工业自动化等领域。另一个例子是Linux，其轻量级版本如OpenWrt、Raspbian等也被广泛应用于各种嵌入式设备。</p><h3 id="8-4-云操作系统"><a href="#8-4-云操作系统" class="headerlink" title="8.4 云操作系统"></a>8.4 云操作系统</h3><p>云操作系统是基于云计算技术开发的新型操作系统。它将计算、存储、网络等资源统一管理和调度，为用户提供了伸缩性、弹性和按需付费等特点。</p><p>例如，Google的Chrome OS就是一种云操作系统，它把大部分计算和数据存储任务都放到了云端，用户只需要一台简单的设备就可以完成各种复杂的任务。另一个例子是OpenStack，这是一种开源的云操作系统，可以让任何人建立自己的私有或公有云。</p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2023/09/18/Python/"/>
      <url>/2023/09/18/Python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>一种多范式编程语言。<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2></li></ul><ol><li><p>Python变量和数据类型：Python有多种基本数据类型，包括整数（int），浮点数（float），字符串（str），列表（list）和字典（dict）等，变量在Python中不需要声明，直接赋值即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;</span><br><span class="line">y = <span class="number">3.14</span>;</span><br><span class="line">z = <span class="string">&quot;Hello,world!&quot;</span></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;john&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Python条件语句: Python使用if、elif（else if的缩写）和else关键字来进行条件判断。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is positive&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is negative&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is zero&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>Python循环: Python使用for和while关键字来进行循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用for循环遍历列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用while循环</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>Python函数: Python使用def关键字来定义函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><ul><li>Python的列表是一种数据结构，可以包含任何类型的数据，如整数，字符串，元组等，列表是可变的，意味着你可以在创建列表后可更改，添加或删除列表中的元素。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//在这个列表中，我们有一个整数（<span class="number">1</span>），一个字符串（<span class="string">&#x27;Hello&#x27;</span>），一个浮点数（<span class="number">3.14</span>）和一个布尔值（<span class="literal">True</span>）。</span><br><span class="line">my_list = [<span class="number">1</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">3.14</span>,<span class="literal">True</span>]</span><br></pre></td></tr></table></figure><h4 id="特性以及操作"><a href="#特性以及操作" class="headerlink" title="特性以及操作"></a>特性以及操作</h4><ol><li><p>索引：你可以通过索引访问列表中的元素。索引是从0开始的。例如，my_list[0] 将返回第一个元素，即1。</p></li><li><p>切片：你也可以访问列表的一部分，这称为切片。例如，my_list[1:3] 将返回从索引1开始到索引（不包括）的所有元素，即[‘Hello’, 3.14]。</p></li><li><p>列表是可变的，你可以更改列表中的元素。例如，my_list[1] = ‘World’ 将把第二个元素（’Hello’）更改为’World’。</p></li><li><p>添加元素：你可以使用 append() 方法在列表的末尾添加新元素，或者使用 insert() 方法在指定位置插入新元素。</p></li><li><p>删除元素：你可以使用 remove() 方法删除指定的元素，或者使用 pop() 方法删除指定索引处的元素。</p></li><li><p>长度：你可以使用 len() 函数获取列表的长度，即它包含的元素数量。</p></li></ol><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol><li>append(item):列表末尾添加一个新的元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_list.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>2.. extend(iterable):在列表末尾添加另一个列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_list.extend([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>insert(index,item):指定索引位置插入一个元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_list.insert(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,&#x27;a&#x27;，2，3]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>remove(item):删除列表中第一个出现的指定元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">my_list.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,3,2]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>pop(index):删除并返回指定索引位置的元素，若没有则删除并返回最后一个元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">item = my_list.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(item) <span class="comment">#输出：2</span></span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment">#输出[1,3]</span></span><br></pre></td></tr></table></figure><ol start="6"><li>index(item):用于查找列表中第一个出现的指定元素的索引</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">index  = my_list.index(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(index) <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure><ol start="7"><li>count(item):这个方法用于计算列表中指定元素出现的次数</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">count = my_list.count(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(count) <span class="comment"># 输出2</span></span><br></pre></td></tr></table></figure><ol start="8"><li><p>sort():这个方法用于对列表进行排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">my_list.sort()</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 1, 2, 3, 4, 5, 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>reverse():用于反转列表</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">my_list.reverse()</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br></pre></td></tr></table></figure><h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><ul><li>元组是一种不可变的序列类型，在Python中，元组是用圆括号（）创建的。元组中的元素可以是不同类型的，如整数，浮点数，字符串，甚至可以包含其他的复杂类型，如列表，字典或其他元组。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>不可变性： 一旦元组被创建，你就不能增加、修改或删除元组中的元素。这意味着元组是哈希的，可以用作字典的键。</li><li>有序性： 元组中的元素有固定的顺序，可以通过索引访问。</li><li>允许重复的元素： 元组可以包含重复的元素。</li><li>可以包含不同类型的元素： 元组的元素可以是任何类型。</li></ol><h4 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol><li>tuple.count(x):返回元组中元素x出现的次数</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t.count(<span class="number">2</span>))<span class="comment"># 输出3</span></span><br></pre></td></tr></table></figure><ol start="2"><li>tuple.index(x):返回元组中元素x第一次出现的索引，如果元组中不存在元素x，会抛出一个异常</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t.index(<span class="number">2</span>))<span class="comment"># 输出1，因为2是元组t中索引为1的元素</span></span><br></pre></td></tr></table></figure><ol start="3"><li>len(tuple):返回元组的长度</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t)) <span class="comment"># 输出6，因为元组t中有6个元素</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>max(tuple) 和 min(tuple)：返回元组中的最大值和最小值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="built_in">tuple</span>)) <span class="comment"># 输出4，因为4是元组t中的最大值 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(<span class="built_in">tuple</span>)) <span class="comment"># 输出1，因为1是元组t中的最小值</span></span><br></pre></td></tr></table></figure></li><li><p>tuple(seq):将序列seq转换为元组</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">t = <span class="built_in">tuple</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment"># 输出（1，2，3，4，5）</span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li>创建元组</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>访问元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>])  <span class="comment"># 输出 &#x27;physics&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>切片操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出 (2, 3, 4)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>合并元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)  <span class="comment"># 输出 (12, 34.56, &#x27;abc&#x27;, &#x27;xyz&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>元组解包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包（unpack）</span></span><br><span class="line">subject1, subject2, year1, year2 = tup1</span><br><span class="line"><span class="built_in">print</span>(subject1)  <span class="comment"># 输出 &#x27;physics&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(year1)  <span class="comment"># 输出 1997</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>计算元素个数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(tup1))  <span class="comment"># 输出 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检查元素是否存在</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1997</span> <span class="keyword">in</span> tup1)  <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure></li><li><p>元素索引</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1.index(<span class="number">2000</span>))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><ol start="9"><li>元素计数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1.count(<span class="number">2</span>))  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol><li><p>无序性：集合中的元素没有特定的顺序，因此不能通过索引或切片来访问元素。</p></li><li><p>唯一性：集合中的每个元素都是唯一的，即集合中不能有重复的元素。</p></li><li><p>可变性：可以添加或删除集合中的元素，但集合本身是不可哈希的，因此不能作为其他集合的元素或字典的键。</p></li></ol><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li>创建集合</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>添加元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">s.update([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4, 5, 6, 7&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>删除元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line">s.discard(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;4, 5&#125;，注意这里的输出可能会有所不同，因为pop()是随机删除一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>判断元素是否存在</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 is in the set&quot;</span>)  <span class="comment"># 输出：&quot;1 is in the set&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>集合的运算<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))  <span class="comment"># 输出：&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))  <span class="comment"># 输出：&#123;3, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))  <span class="comment"># 输出：&#123;1, 2&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))  <span class="comment"># 输出：&#123;1, 2, 5, 6&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li><p>discard()：删除集合中的指定元素，如果元素不存在，不会抛出错误。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.discard(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>pop()：随机删除集合中的一个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.pop()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出可能是：&#123;1, 2&#125; 或 &#123;2, 3&#125; 或 &#123;1, 3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>clear()：清空集合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：set()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>union()：返回两个集合的并集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))  <span class="comment"># 输出：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>intersection()：返回两个集合的交集</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))  <span class="comment"># 输出：&#123;3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li><p>difference()：返回集合的差集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))  <span class="comment"># 输出：&#123;1, 2&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>symmetric_difference()：返回两个集合的对称差集</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))  <span class="comment"># 输出：&#123;1, 2, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li><p>issubset()：判断集合是不是被其他集合包含</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.issubset(s2))  <span class="comment"># 输出：True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>issuperset()：判断集合是否包含其他集合</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.issuperset(s1))  <span class="comment"># 输出：True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>并集：两个集合的并集是包含两个集合所有元素的集合。</p></li><li><p>交集：两个集合的交集是同时包含在两个集合中的元素组成的集合。</p></li><li><p>差集：集合A与集合B的差集是包含在集合A但不包含在集合B中的元素组成的集合。</p></li><li><p>对称差集：两个集合的对称差集是只包含在一个集合中但不同时包含在两个集合中的元素组成的集合。</p></li></ul><h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul><li>无序性：字典中的元素没有特定的顺序，它们并不按照插入的顺序存储</li><li>键的唯一性：字典中的键必须是唯一的，如果在创建字典时同一个键被赋值两次，后一个值会被记住。</li><li>可变性：字典是可变的，我们可以添加，删除或修改字典中的键值对。</li></ul><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li>创建字典</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号创建字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用dict()函数创建字典</span></span><br><span class="line">dict2 = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(dict2)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 25&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>访问字典中的值</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># 输出：Alice</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>修改字典</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">21</span>  <span class="comment"># 修改已有的键值对</span></span><br><span class="line">dict1[<span class="string">&#x27;gender&#x27;</span>] = <span class="string">&#x27;Female&#x27;</span>  <span class="comment"># 添加新的键值对</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 21, &#x27;gender&#x27;: &#x27;Female&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>删除字典元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;Female&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;gender&#x27;</span>]  <span class="comment"># 删除键为&#x27;gender&#x27;的键值对</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol><li><p>dict.keys():返回一个包含字典所有键的视图对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.keys()) <span class="comment">#dict_keys([&#x27;name&#x27;,&#x27;age&#x27;])</span></span><br></pre></td></tr></table></figure></li><li><p>dict.values():此方法返回一个包含字典所有值的视图对象</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.values())  <span class="comment"># 输出：dict_values([&#x27;Tom&#x27;, 20])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>dict.items(): 此方法返回一个包含字典所有（键, 值）元组的视图对象。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.items())  <span class="comment"># 输出：dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20)])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>dict.get(key, default): 此方法返回字典中键为key的值；如果没有这样的键，则返回default。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;name&#x27;</span>))  <span class="comment"># 输出：&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;N/A&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>dict.setdefault(key, default): 如果字典中包含有给定键，则返回该键对应的值，否则将该键和default值插入字典中，并返回default。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;N/A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;N/A&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>dict.update(other): 将other字典的键/值对更新到当前字典中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">d.update(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 21, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>dict.pop(key, default): 删除并返回字典中键为key的值，如果没有这样的键，则返回default。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.pop(<span class="string">&#x27;age&#x27;</span>))  <span class="comment"># 输出：20</span></span><br><span class="line"><span class="built_in">print</span>(d.pop(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;N/A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>dict.clear(): 删除字典内所有元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">d.clear()</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Python的函数"><a href="#Python的函数" class="headerlink" title="Python的函数"></a>Python的函数</h2><ol><li>定义函数:<br>你可以定义一个由自己想要功能的函数，以下是简单的规则：</li></ol><ul><li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line"><span class="string">&quot;&quot;&quot;This function prints Hello,World!&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello，World！&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello_world();</span><br></pre></td></tr></table></figure><ol start="2"><li><p>函数参数：<br>在Python中，函数的参数可以有默认值，也支持使用可变参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, msg=<span class="string">&quot;Good day!&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This function greets to the person passed in as parameter</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, name + <span class="string">&#x27;, &#x27;</span> + msg)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Kate&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Bruce&quot;</span>, <span class="string">&quot;How do you do?&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>匿名函数<br>Python使用lambda来创建匿名函数。意即不再使用def语句这样标准的形式定义一个函数。<br>lambda只是一个表达式，函数体笔def简单多</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum = lambda arg1:arg1 + arg2</span><br><span class="line">print(&quot;Value of tatal:&quot;,sum(10,20))</span><br></pre></td></tr></table></figure></li><li><p>全局和局部变量：<br>在函数内部，你可以引用全局变量。如果你需要在函数内部改变全局变量，那么global关键字就派上用场了，如果不修改全局变量，可以使用局部变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    y = <span class="number">5</span></span><br><span class="line">    x += y</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;local x:&quot;</span>, x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;local y:&quot;</span>, y)</span><br><span class="line"></span><br><span class="line">example()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;global x:&quot;</span>, x)</span><br></pre></td></tr></table></figure></li><li><p>错误和异常处理<br>try/except语句</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">diveide</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">result = x/y</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;除数不能为零！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li><li><p>函数的递归<br>最好需要一个明确的退出条件，否则无限递归导致程序崩溃</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> n * factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>高阶函数<br>Python支持高阶函数，可以接受其他函数作为参数或返回一个函数的函数。这是函数式编程的一个重要特性，可以用来创建代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def apply_func(func,x,y)</span><br><span class="line">return func(x,y)</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><ol><li><p><strong>打开文件</strong>：我们使用内置的<code>open()</code>函数来打开一个文件。这个函数接收两个参数：文件名和模式。模式可以是<code>&#39;r&#39;</code>（读取，默认值），<code>&#39;w&#39;</code>（写入，如果文件存在则清空内容），<code>&#39;a&#39;</code>（追加，不清空文件内容，从文件末尾开始写入），或<code>&#39;b&#39;</code>（二进制模式）。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>读取文件</strong>：我们可以使用<code>read()</code>函数来读取文件的全部内容，或者使用<code>readline()</code>来一次读取一行。还可以使用<code>readlines()</code>来一次读取所有行并返回一个列表。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = f.read()</span><br><span class="line">line = f.readline()</span><br><span class="line">lines = f.readlines()</span><br></pre></td></tr></table></figure></li><li><p><strong>写入文件</strong>：我们可以使用<code>write()</code>函数来写入文件。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;Hello, World!&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭文件</strong>：当我们完成文件操作后，应该使用<code>close()</code>函数来关闭文件。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure></li><li><p><strong>with语句</strong>：在处理文件对象时，使用with关键字是一个好习惯。它的优点是文件会在语句结束后自动关闭，即使发生异常也是如此。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure></li><li><p><strong>操作文件和目录</strong>：Python的os模块提供了许多操作文件和目录的函数，如<code>os.remove()</code>删除文件，<code>os.rename()</code>重命名文件，<code>os.mkdir()</code>创建新目录，<code>os.rmdir()</code>删除目录等。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">os.rename(<span class="string">&#x27;oldname.txt&#x27;</span>, <span class="string">&#x27;newname.txt&#x27;</span>)</span><br><span class="line">os.mkdir(<span class="string">&#x27;newdir&#x27;</span>)</span><br><span class="line">os.rmdir(<span class="string">&#x27;olddir&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在Python中，异常处理涉及以下几个关键词：<code>try</code>, <code>except</code>, <code>finally</code>, <code>raise</code>。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    x = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="comment"># 如果在try部分引发了ZeroDivisionError，那么就执行这部分</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试除以零，这会引发一个 ZeroDivisionError。由于我们在 except 语句中处理了这个错误，所以程序会打印出 “You can’t divide by zero!”，而不是完全崩溃。</p><p>finally 语句是一个可选的语句，无论 <code>try</code> 块中的代码是否引发异常，它都会执行。这在需要确保文件正确关闭或网络连接正确终止等情况下非常有用。</p><p>raise 语句允许程序员自己引发异常。例如，如果你正在编写一个函数，你可以使用 <code>raise</code> 语句来引发一个 <code>TypeError</code>，如果函数的参数不是你期望的类型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(b, <span class="built_in">int</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;Inputs must be integers&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>add_numbers</code> 的参数不是整数，那么函数就会引发一个 TypeError。</p><h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><p>模块是Python代码的一种组织形式，它将相关的代码组织在一个文件中，以便于代码的复用和维护。你可以使用import语句来导入模块。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">16</span>))  <span class="comment"># 输出：4.0</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们导入了math模块，然后使用了它的sqrt函数来计算16的平方根。</p><p>Python的包是一种更高级的模块组织方式。它可以包含多个模块。一个包就是一个包含特殊文件 <strong>init</strong>.py 的目录，这个文件告诉Python这个目录应被视为一个Python包。</p><p>例如，如果你有以下目录结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line">__init__.py</span><br><span class="line">module1.py</span><br><span class="line">module2.py</span><br></pre></td></tr></table></figure><p>你可以这样导入和使用包中的模块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module1</span><br><span class="line">module1.some_function()</span><br></pre></td></tr></table></figure><p>在这个例子中，我们导入了my_package包中的module1模块，并调用了它的some_function函数。</p><h3 id="常用包和模块简介"><a href="#常用包和模块简介" class="headerlink" title="常用包和模块简介"></a>常用包和模块简介</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> numpy: 这是Python中用于数值计算的主要库。它提供了强大的多维数组对象和工具来处理这些数组。</span><br><span class="line"><span class="number">2.</span> pandas: 这是用于数据处理和分析的库。它提供了两个主要的数据结构：Series和DataFrame。</span><br><span class="line"><span class="number">3.</span> matplotlib: 这是用于绘制图形的库。你可以使用它来创建各种各样的图表，比如线图、散点图、柱状图等。</span><br><span class="line"><span class="number">4.</span> scikit-learn: 这是用于机器学习的库。它包含了大量的机器学习算法，比如分类、回归、聚类等。</span><br><span class="line"><span class="number">5.</span> requests: 这是用于发送HTTP请求的库。你可以使用它来获取网页内容，或者与Web服务交互。</span><br><span class="line"><span class="number">6.</span> flask: 这是一个轻量级的Web服务器和框架。你可以使用它来创建Web应用。</span><br><span class="line"><span class="number">7.</span> django: 这是一个高级的Web框架，它遵循MVC（Model-View-Controller）设计模式。你可以使用它来创建复杂的Web应用。</span><br><span class="line"><span class="number">8.</span> tensorflow和pytorch: 这两个库都是用于深度学习的。它们提供了创建和训练神经网络的工具。</span><br><span class="line"><span class="number">9.</span> beautifulsoup4: 这是一个用于解析HTML和XML文档的库，常常用于网页抓取。</span><br><span class="line"><span class="number">10.</span> sqlalchemy: 这是一个数据库抽象层和ORM（Object Relational Mapper）框架。你可以使用它来与各种数据库进行交互。</span><br></pre></td></tr></table></figure><h2 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><ol><li>类与对象：在Python中，几乎所有的东西都是对象，具有其属性和方法。类是对象的蓝图或圆形。我们可以使用类来创建对象，这些对象将具有类定义的属性和行为。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">p1 = MyClass() <span class="comment"># 创建对象</span></span><br><span class="line"><span class="built_in">print</span>(p1.x) <span class="comment"># 输出：5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>继承：继承允许我们定义一个继承所有办法和属性的类。父类是被继承的类，子类是继承父类的类。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fname</span>):</span><br><span class="line">    self.firstname = fname</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = Student(<span class="string">&quot;Mike&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.firstname) <span class="comment"># 输出：Mike</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>多态：多态是指同一操作作用于不同的对象，可以产生不同的结果。这意味着每个对象可以根据其类型以自己的方式响应常见的方法。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">animal</span>):</span><br><span class="line">  <span class="built_in">print</span>(animal.sound())</span><br><span class="line"></span><br><span class="line">cat_obj = Cat()</span><br><span class="line">dog_obj = Dog()</span><br><span class="line"></span><br><span class="line">make_sound(cat_obj) <span class="comment"># 输出：Meow</span></span><br><span class="line">make_sound(dog_obj) <span class="comment"># 输出：Woof</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>封装：封装是面向对象编程的一个主要原则，隐藏了对象的内部状态和实现细节，只提供了一组接口。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.__maxprice = <span class="number">900</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Selling Price: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.__maxprice))</span><br><span class="line"></span><br><span class="line">c = Computer()</span><br><span class="line">c.sell() <span class="comment"># 输出：Selling Price: 900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用标准库"><a href="#常用标准库" class="headerlink" title="常用标准库"></a>常用标准库</h2><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>提供了许多与操作系统交互的函数，如创建目录（Mkdir）,更改当前工作目录（chdir），获取当前工作目录（getcwd）等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(<span class="string">&#x27;new_dir&#x27;</span>)</span><br><span class="line">os.chdir(<span class="string">&#x27;new_dir&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>os.name</td><td>获取当前的操作系统名称</td></tr><tr><td>os.getcwd()</td><td>获取当前的工作目录</td></tr><tr><td>os.chdir(path)</td><td>改变当前的工作目录到指定的路径</td></tr><tr><td>os.listdir(path)</td><td>列出指定路径下的所有文件和目录</td></tr><tr><td>os.mkdir(path)</td><td>在指定的路径下创建一个新的目录</td></tr><tr><td>os.rmdir(path)</td><td>删除指定的目录</td></tr><tr><td>os.rename(src, dst)</td><td>重命名文件或目录，从src到dst</td></tr><tr><td>os.remove(path)</td><td>删除指定的文件</td></tr><tr><td>os.path.join(path1, path2, …)</td><td>将多个路径组合后返回</td></tr><tr><td>os.path.split(path)</td><td>返回路径的目录名和文件名</td></tr><tr><td>os.path.exists(path)</td><td>检测指定路径是否存在</td></tr><tr><td>os.path.isdir(path)</td><td>检测指定路径是目录</td></tr><tr><td>os.path.isfile(path)</td><td>检测指定路径是文件</td></tr></tbody></table><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span><br><span class="line">json_data = json.dumps(data)  # 将Python对象转换为JSON格式</span><br><span class="line">print(json_data)  </span><br><span class="line">new_data = json.loads(json_data)  # 将JSON格式的数据转换为Python对象</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>提供了对正则表达式的支持，正则表达式是一个特殊的序列，能够帮助你匹配或者找到其他字符串，使用特定的语法规则。</p><p><strong>Python re模块函数</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>re.match()</code></td><td>从字符串的开始位置匹配正则表达式，如果开始位置匹配不成功，match()返回None</td></tr><tr><td><code>re.search()</code></td><td>扫描整个字符串并返回第一个成功的匹配</td></tr><tr><td><code>re.findall()</code></td><td>返回一个列表，包含所有匹配的子串</td></tr><tr><td><code>re.sub()</code></td><td>用于替换字符串中的匹配项</td></tr><tr><td><code>re.compile()</code></td><td>用于编译正则表达式，生成一个正则表达式对象</td></tr></tbody></table><p><strong>正则表达式元字符</strong></p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除了换行符以外的任何字符</td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td></tr><tr><td><code>*</code></td><td>匹配0次或多次前面的正则表达式</td></tr><tr><td><code>+</code></td><td>匹配1次或多次前面的正则表达式</td></tr><tr><td><code>?</code></td><td>匹配0次或1次前面的正则表达式</td></tr><tr><td><code>\d</code></td><td>匹配任何数字，等价于<code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配任何非数字字符，等价于<code>[^0-9]</code></td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，等价于<code>[\t\n\r\f\v]</code></td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符，等价于<code>[^\t\n\r\f\v]</code></td></tr><tr><td><code>\w</code></td><td>匹配任何字母数字字符，等价于<code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配任何非字母数字字符，等价于<code>[^a-zA-Z0-9_]</code></td></tr></tbody></table><h4 id="简单的re模块例子"><a href="#简单的re模块例子" class="headerlink" title="简单的re模块例子"></a>简单的re模块例子</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用match方法</span></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;100081 BIT 100082&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用search方法</span></span><br><span class="line">search = re.search(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT 100082&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> search:</span><br><span class="line">    <span class="built_in">print</span>(search.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用findall方法</span></span><br><span class="line">findall = re.findall(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;100081 BIT 100082&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(findall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用sub方法</span></span><br><span class="line">sub = re.sub(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;:zipcode&#x27;</span>, <span class="string">&#x27;100081 BIT 100082&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用compile方法</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>)</span><br><span class="line">result = pattern.search(<span class="string">&#x27;BIT 100082&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    <span class="built_in">print</span>(result.group(<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><p>实现了特殊的容器数据类型，提供了Python内置的<code>dict</code>，<code>list</code>，<code>set</code>，<code>tuple</code>之外的更多数据类型。</p><ol><li>**<code>namedtuple()</code>**：<code>namedtuple</code>是一个函数，它用来创建一个自定义的元组对象，并且规定了元组元素的个数，可以用属性而不是索引来引用元组的某个元素。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个名为&#x27;Animal&#x27;的namedtuple，它包含&#x27;name&#x27;和&#x27;age&#x27;两个字段。</span></span><br><span class="line">Animal = namedtuple(<span class="string">&#x27;Animal&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;type&#x27;</span>])</span><br><span class="line"></span><br><span class="line">cat = Animal(name=<span class="string">&#x27;Kitty&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Cat&#x27;</span>)</span><br><span class="line">dog = Animal(name=<span class="string">&#x27;Max&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以用属性访问namedtuple的元素</span></span><br><span class="line"><span class="built_in">print</span>(cat.name)  <span class="comment"># 输出: Kitty</span></span><br><span class="line"><span class="built_in">print</span>(dog.<span class="built_in">type</span>)  <span class="comment"># 输出: Dog</span></span><br></pre></td></tr></table></figure><ol start="2"><li>**<code>deque</code>**：<code>deque</code>是一个双端队列，它可以从两端添加或删除元素。在需要添加和删除元素时，deque提供了更优于list的性能。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">dq = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment">#在队列右侧添加元素</span></span><br><span class="line">dq.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dq.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在队列左侧添加元素</span></span><br><span class="line">dq.appendleft(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除队列右侧元素</span></span><br><span class="line">dq.pop()</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;c&#x27;, &#x27;a&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除队列左侧元素</span></span><br><span class="line">dq.popleft()</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;a&#x27;])</span></span><br></pre></td></tr></table></figure><ol start="3"><li>**<code>Counter</code>**：<code>Counter</code>是一个简单的计数器，例如，它可以用来统计字符的个数：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">c = Counter(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: Counter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 1, &#x27;n&#x27;: 2&#125;)</span></span><br></pre></td></tr></table></figure><p>你还可以对Counter对象执行各种数学运算操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c1 = Counter(a=<span class="number">3</span>, b=<span class="number">2</span>)</span><br><span class="line">c2 = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c1 + c2)  <span class="comment"># 输出: Counter(&#123;&#x27;a&#x27;: 4, &#x27;b&#x27;: 4&#125;)</span></span><br></pre></td></tr></table></figure><ol start="4"><li>**<code>OrderedDict</code>**：<code>OrderedDict</code>是一个字典子类，它记住了字典元素添加的顺序：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="string">&#x27;z&#x27;</span>] = <span class="number">1</span></span><br><span class="line">od[<span class="string">&#x27;y&#x27;</span>] = <span class="number">2</span></span><br><span class="line">od[<span class="string">&#x27;x&#x27;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(od.keys()))  <span class="comment"># 输出: [&#x27;z&#x27;, &#x27;y&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>**<code>defaultdict</code>**：<code>defaultdict</code>是一个字典子类，它提供了一个工厂函数为字典查询提供默认值：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dd = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(dd[<span class="string">&#x27;key&#x27;</span>])  <span class="comment"># 输出: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当键不存在的时候，返回默认值0，而不是抛出KeyError异常</span></span><br><span class="line">dd[<span class="string">&#x27;key&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(dd[<span class="string">&#x27;key&#x27;</span>])  <span class="comment"># 输出: 1</span></span><br></pre></td></tr></table></figure><h2 id="Python应用"><a href="#Python应用" class="headerlink" title="Python应用"></a>Python应用</h2><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>一个开源的Python类库，用于数据分析，数据处理，数据可视化</p><h5 id="Pandas读取数据"><a href="#Pandas读取数据" class="headerlink" title="Pandas读取数据"></a>Pandas读取数据</h5><p>Pandas 提供了多种读取数据的方法，可以读取各种类型的文件，包括 CSV、Excel、SQL 数据库等。下面是一些常用的读取数据的方法：</p><ol><li>从 CSV 文件读取数据：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;file.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>从 Excel 文件读取数据：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;file.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>从 SQL 数据库读取数据：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///:memory:&#x27;</span>)</span><br><span class="line">df = pd.read_sql(<span class="string">&#x27;SELECT * FROM my_table&#x27;</span>, engine)</span><br></pre></td></tr></table></figure><p>注意，这些方法都会返回一个 DataFrame 对象，这是 Pandas 中用于数据操纵的主要数据结构。</p><p>你可以使用 <code>df.head()</code> 来查看 DataFrame 的前几行，以确保数据已经正确加载。</p><p>此外，这些函数都有许多可选参数，可以帮助你更精细地控制数据的加载过程。例如，<code>pd.read_csv</code> 允许你指定分隔符类型、处理缺失值、跳过特定的行等。你可以查阅 Pandas 的文档以获取更多信息。</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h6><p>Series是Pandas中的一维标签化数组，可以容纳任何数据类型，包括整数，字符串，浮点数，Python对象等。它是由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签组成，可以把它看作是一个带有标签的一维数组</p><h6 id="Serise多种创建方法"><a href="#Serise多种创建方法" class="headerlink" title="Serise多种创建方法"></a>Serise多种创建方法</h6><p>Pandas的Series是一个一维的数据结构，有点类似于Python的列表或数组，但是它有一些额外的功能，例如可以为每个元素指定一个标签（或者说索引）。</p><p>以下是创建Series的一些方法：</p><ol><li>用Python列表创建Series：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><ol start="2"><li>用NumPy数组创建Series：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><ol start="3"><li>用Python字典创建Series，字典的键会被用作Series的索引：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">s = pd.Series(d)</span><br></pre></td></tr></table></figure><ol start="4"><li>用标量创建Series，该标量值会被广播到指定的索引：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(<span class="number">5.</span>, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br></pre></td></tr></table></figure><p>以上就是创建Pandas Series的四种常用方法，每种方法都有其适用的场景，你可以根据实际需要选择使用。</p><h6 id="Series索引"><a href="#Series索引" class="headerlink" title="Series索引"></a>Series索引</h6><p>在Pandas中，Series对象的索引类似于Python的字典，它可以用来访问和操作数据。</p><p>创建Series时，可以通过<code>index</code>参数来指定索引。如果不指定，Pandas将自动创建一个从0开始的整数索引。</p><p>例如，创建一个带有指定索引的Series：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>此代码将输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a    1.0</span><br><span class="line">b    3.0</span><br><span class="line">c    5.0</span><br><span class="line">d    NaN</span><br><span class="line">e    6.0</span><br><span class="line">f    8.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>你可以像字典一样使用索引来访问和修改Series中的元素：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出：1.0</span></span><br><span class="line"></span><br><span class="line">s[<span class="string">&#x27;a&#x27;</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出：100.0</span></span><br></pre></td></tr></table></figure><p>还可以使用<code>.loc</code>和<code>.iloc</code>方法来进行索引。<code>.loc</code>用于基于标签的索引，而<code>.iloc</code>用于基于位置的索引：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(s.loc[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出：100.0</span></span><br><span class="line"><span class="built_in">print</span>(s.iloc[<span class="number">0</span>])  <span class="comment"># 输出：100.0</span></span><br></pre></td></tr></table></figure><h6 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h6><p>DataFrame是Pandas中的二维标签化数据结构。你可以把它看作是一个电子表格或SQL表，或者是Series对象的字典。它通常是最常用的pandas对象。与Series一样，DataFrame可以容纳多种类型的输入。</p><h6 id="多种方法创建DataFrame"><a href="#多种方法创建DataFrame" class="headerlink" title="多种方法创建DataFrame"></a>多种方法创建DataFrame</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#从字典创建 DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从列表创建 DataFrame</span></span><br><span class="line">data = [[<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>], [<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">35</span>]]</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#从 NumPy 数组创建 DataFrame</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.array([[<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>], [<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">35</span>]])</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中读取数据创建 DataFrame</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h6 id="DataFrame特性"><a href="#DataFrame特性" class="headerlink" title="DataFrame特性"></a>DataFrame特性</h6><ol><li><p>表格结构：DataFrame是一个表格，有行有列，每一列可以包含不同的数据类型，如整数，浮点数，字符串等。</p></li><li><p>标签索引：DataFrame通过行和列的标签进行索引，你可以使用列名或行标签来访问数据。</p></li></ol><p>3.灵活性：你可以执行各种数据操作，如筛选,切片，合并，聚合和重塑，以满足数据分析和处理和需求。</p><h6 id="DataFrame基本操作"><a href="#DataFrame基本操作" class="headerlink" title="DataFrame基本操作"></a>DataFrame基本操作</h6><ol><li><p>访问列数据：使用列名或标签访问列数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;Name&#x27;</span>]  <span class="comment"># 访问 &#x27;Name&#x27; 列</span></span><br></pre></td></tr></table></figure></li><li><p>增加和删除列：你可以轻松地添加和删除列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;City&#x27;</span>] = [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>]  <span class="comment"># 添加新列</span></span><br><span class="line">df.drop(<span class="string">&#x27;Age&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除 &#x27;Age&#x27; 列</span></span><br></pre></td></tr></table></figure></li><li><p>数据筛选：使用条件筛选数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]  <span class="comment"># 筛选年龄大于 30 的行</span></span><br></pre></td></tr></table></figure></li><li><p>聚合操作：进行统计和聚合计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]  <span class="comment"># 筛选年龄大于 30 的行</span></span><br></pre></td></tr></table></figure></li><li><p>数据排序：按列的值排序 DataFrame。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]  <span class="comment"># 筛选年龄大于 30 的行</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>模拟一组数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>],</span><br><span class="line">        <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;London&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Salary&#x27;</span>: [<span class="number">5000</span>, <span class="number">6000</span>, <span class="number">7000</span>, <span class="number">8000</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><h6 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择年龄大于30的行</span></span><br><span class="line">result = df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]</span><br></pre></td></tr></table></figure><h6 id="loc-和-iloc"><a href="#loc-和-iloc" class="headerlink" title=".loc 和 .iloc"></a>.loc 和 .iloc</h6><ol><li>label指定行列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[<span class="number">0</span>, <span class="string">&#x27;City&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>使用值列表哦批量查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result  = df.loc[[<span class="string">&#x27;Alice&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],<span class="string">&#x27;City&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>使用数值区间进行范围查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;Charlie&#x27;</span>,Salary]</span><br></pre></td></tr></table></figure></li><li>使用条件表达式查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[df[<span class="string">&#x27;Salary&#x27;</span>] &lt; <span class="number">7000</span> :  ]</span><br></pre></td></tr></table></figure></li><li>调用函数查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[<span class="keyword">lambda</span> df:(df[<span class="string">&quot;Salary&quot;</span>] &lt; = <span class="number">7000</span>) &amp; (df[<span class="string">&quot;Salary&quot;</span>] &gt; = <span class="number">5000</span>) ]</span><br></pre></td></tr></table></figure></li></ol><h6 id="isin"><a href="#isin" class="headerlink" title=".isin"></a>.isin</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择城市为&#x27;Paris&#x27;或&#x27;Tokyo&#x27;的行</span></span><br><span class="line">result = df[df[<span class="string">&#x27;City&#x27;</span>].isin([<span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>])]</span><br></pre></td></tr></table></figure><h6 id="query"><a href="#query" class="headerlink" title=".query"></a>.query</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择工资大于6000的行</span></span><br><span class="line">result = df.query(<span class="string">&#x27;Salary &gt; 6000&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="新增数据列"><a href="#新增数据列" class="headerlink" title="新增数据列"></a>新增数据列</h5><ol><li><p>使用直接赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#新增一个名为&#x27;C&#x27;的列，并赋值为一个列表</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>] = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用assign()方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建一个DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="comment">#使用assign()方法新增一个名为&#x27;C&#x27;的列，并赋值为一个列表</span></span><br><span class="line">df = df.assign(C=[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></li></ol><h5 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h5><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>sum()</code></td><td>计算数字的总和</td></tr><tr><td><code>mean()</code></td><td>计算平均值</td></tr><tr><td><code>median()</code></td><td>计算中位数</td></tr><tr><td><code>mode()</code></td><td>计算众数</td></tr><tr><td><code>variance()</code></td><td>计算方差</td></tr><tr><td><code>stddev()</code></td><td>计算标准差</td></tr><tr><td><code>min()</code></td><td>找到最小值</td></tr><tr><td><code>max()</code></td><td>找到最大值</td></tr><tr><td><code>numpy</code> 库</td><td>强大的数组和矩阵操作</td></tr><tr><td><code>pandas</code> 库</td><td>数据处理和分析，提供数据结构和统计函数</td></tr><tr><td><code>scipy</code> 库</td><td>高级的统计函数和科学计算工具</td></tr></tbody></table><p>当涉及到统计函数时，以下是每个函数的简单示例：</p><ol><li><p><code>sum()</code>: 计算数字的总和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">total = <span class="built_in">sum</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(total)  <span class="comment"># 输出：15</span></span><br></pre></td></tr></table></figure></li><li><p><code>mean()</code> 或 <code>average()</code>: 计算平均值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">12</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">36</span>]</span><br><span class="line">average = <span class="built_in">sum</span>(numbers) / <span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(average)  <span class="comment"># 输出：24.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>median()</code>: 计算中位数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">numbers.sort()</span><br><span class="line">n = <span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    median = (numbers[n//<span class="number">2</span> - <span class="number">1</span>] + numbers[n//<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    median = numbers[n//<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(median)  <span class="comment"># 输出：5</span></span><br></pre></td></tr></table></figure></li><li><p><code>mode()</code>: 计算众数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> mode</span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">result = mode(data)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure></li><li><p><code>variance()</code>: 计算方差</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> variance</span><br><span class="line">data = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>]</span><br><span class="line">result = variance(data)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：11.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>stddev()</code>: 计算标准差</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">from</span> statistics <span class="keyword">import</span> stdev</span><br><span class="line">   data = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>]</span><br><span class="line">   result = stdev(data)</span><br><span class="line">   <span class="built_in">print</span>(result)  <span class="comment"># 输出：3.3166247903554</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> `<span class="built_in">min</span>()` 和 `<span class="built_in">max</span>()`: 找到最小值和最大值</span><br><span class="line"></span><br><span class="line">   ```python</span><br><span class="line">   numbers = [<span class="number">15</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">11</span>]</span><br><span class="line">   min_val = <span class="built_in">min</span>(numbers)</span><br><span class="line">   max_val = <span class="built_in">max</span>(numbers)</span><br><span class="line">   <span class="built_in">print</span>(min_val)  <span class="comment"># 输出：3</span></span><br><span class="line">   <span class="built_in">print</span>(max_val)  <span class="comment"># 输出：22</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h4><p>首先，让我们导入numpy库。在你的Python环境中，你可以这样做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>我们使用 “as” 关键字给numpy库起了一个别名 “np”，这样在我们的代码中就可以使用 “np” 来代替 “numpy”，使代码更简洁。</p><p><strong>创建数组</strong></p><p>在numpy中，最基本的对象是ndarray对象，也就是n维数组。我们可以使用np.array()函数来创建一个数组。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure><p>这将会创建一个一维数组，并输出 <code>[1 2 3 4 5]</code>。</p><p><strong>数组的属性</strong></p><p>创建了数组之后，我们可以查看一些数组的属性。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shape of the array: &quot;</span>, arr.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Data type of the array: &quot;</span>, arr.dtype)</span><br></pre></td></tr></table></figure><p><code>shape</code> 属性返回一个元组，表示数组的形状（即各维度的大小）。<code>dtype</code> 属性则返回数组中元素的数据类型。</p><p><strong>多维数组</strong></p><p>我们不仅可以创建一维数组，还可以创建多维数组。例如，我们可以创建一个2x3的二维数组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr_2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr_2d)</span><br></pre></td></tr></table></figure><p>这将会输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br></pre></td></tr></table></figure><p><strong>数组的索引和切片</strong></p><p>我们可以使用索引和切片来访问和修改数组中的元素。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])  <span class="comment"># 输出数组的第一个元素</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># 将数组的第一个元素修改为10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr_2d[<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 输出二维数组的第一行第二列的元素</span></span><br><span class="line">arr_2d[<span class="number">1</span>, :] = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]  <span class="comment"># 将二维数组的第二行的所有元素修改为7, 8, 9</span></span><br></pre></td></tr></table></figure><h5 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h5><ol><li>加法：<code>numpy.add(x, y)</code>，对应元素相加。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))  <span class="comment"># Output: array([5, 7, 9])</span></span><br></pre></td></tr></table></figure><ol start="2"><li>减法：<code>numpy.subtract(x, y)</code>，对应元素相减。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.subtract(x, y))  <span class="comment"># Output: array([-3, -3, -3])</span></span><br></pre></td></tr></table></figure><ol start="3"><li>乘法：<code>numpy.multiply(x, y)</code>，对应元素相乘。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.multiply(x, y))  <span class="comment"># Output: array([ 4, 10, 18])</span></span><br></pre></td></tr></table></figure><ol start="4"><li>除法：<code>numpy.divide(x, y)</code>，对应元素相除。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.divide(x, y))  <span class="comment"># Output: array([0.25, 0.4 , 0.5 ])</span></span><br></pre></td></tr></table></figure><ol start="5"><li>幂运算：<code>numpy.power(x, y)</code>，对应元素做幂运算。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.power(x, y))  <span class="comment"># Output: array([  1,  32, 729], dtype=int32)</span></span><br></pre></td></tr></table></figure><ol start="6"><li>平方根：<code>numpy.sqrt(x)</code>，计算数组各元素的平方根。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.sqrt(x))  <span class="comment"># Output: array([1.        , 1.41421356, 1.73205081])</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>三角函数，如 numpy.sin(x)、numpy.cos(x)、numpy.tan(x)等。</p></li><li><p>指数和对数，如 <code>numpy.exp(x)</code>、<code>numpy.log(x)</code>、<code>numpy.log10(x)</code>等。</p></li></ol><h5 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h5><ol><li><code>numpy.random.rand(d0, d1, ..., dn)</code>: 生成一个给定形状的数组，数组中的值均匀分布在[0, 1)中。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.rand(<span class="number">3</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li><code>numpy.random.randn(d0, d1, ..., dn)</code>: 返回一个由d0, d1, …, dn确定的形状的数组，数组中的值来自标准正态分布。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.randn(<span class="number">3</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><ol start="3"><li><code>numpy.random.randint(low, high=None, size=None, dtype=&#39;l&#39;)</code>: 返回随机整数，范围区间为[low, high)，high默认为None。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">2</span>, size=<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">1</span>, size=<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">5</span>, size=(<span class="number">2</span>, <span class="number">4</span>)))</span><br></pre></td></tr></table></figure><ol start="4"><li>numpy.random.random(size=None)`: 返回随机的浮点数，在半开区间 [0.0, 1.0)。 </li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.random())</span><br><span class="line"><span class="built_in">print</span>(np.random.random((<span class="number">5</span>,)))</span><br><span class="line"><span class="built_in">print</span>(np.random.random((<span class="number">2</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><ol start="5"><li><code>numpy.random.choice(a, size=None, replace=True, p=None)</code>: 从一个给定的一维数组中生成随机数。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.choice(<span class="number">5</span>, <span class="number">3</span>))  <span class="comment"># 从0到4中随机选择3个数</span></span><br></pre></td></tr></table></figure><p>注意：为了获得可重复的结果，我们可以使用<code>numpy.random.seed()</code>函数设置随机数种子。</p><h6 id="蒙特卡洛模拟"><a href="#蒙特卡洛模拟" class="headerlink" title="蒙特卡洛模拟"></a>蒙特卡洛模拟</h6><p>这是一个使用NumPy进行蒙特卡洛模拟的例子。在这个例子中，我们将使用蒙特卡洛模拟来估计圆周率π的值。</p><p>基本思想是这样的：我们在一个边长为1的正方形内随机撒点，然后计算落在1/4圆内（半径为1）的点的数量。由于圆的面积是πr²，正方形的面积是1，所以落在1/4圆内的点的数量除以总的点的数量，大约等于π/4。</p><p>以下是Python代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义模拟的次数</span></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在[0, 1)区间内随机生成n个点的x和y坐标</span></span><br><span class="line">points = np.random.rand(n, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算这些点到原点的距离，然后判断这些距离是否小于1（也就是判断这些点是否落在1/4圆内）</span></span><br><span class="line">inside_circle = np.<span class="built_in">sum</span>(np.square(points).<span class="built_in">sum</span>(axis=<span class="number">1</span>) &lt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#估计π的值：落在1/4圆内的点的数量除以总的点的数量，然后乘以4</span></span><br><span class="line">pi_estimate = <span class="number">4</span> * inside_circle / n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;π的估计值为：<span class="subst">&#123;pi_estimate&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个代码运行后，会打印出一个π的估计值，这个值应该会接近真实的π值（3.14159…）。随着模拟次数n的增加，这个估计值会越来越接近真实的π值。</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HumanSystemOptimization</title>
      <link href="/2023/08/31/%E4%BA%BA%E4%BD%93%E8%B0%83%E4%BC%98/"/>
      <url>/2023/08/31/%E4%BA%BA%E4%BD%93%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>UPDATE: 鉴于文章比较长，很多同学没有耐心读完，后续也分享录制了一个 <a href="https://www.bilibili.com/video/BV1EW4y1R7yi/">视频版</a>，基本涵盖了文章里的大部分内容。</p><p>另外在健康生活实践方面，也提供一个极简版的基础列表，供大家参考：</p><ul><li>保持睡眠时长与质量。</li><li>不要吸烟。</li><li>尽可能每天做点运动。</li><li>减少糖分的摄入。</li></ul><p>能做到这四点，就已经可以达到一个还不错的健康状态了。剩下的可以根据各自的身体状况再来做补充调整。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>去年 5 月曾经写了一篇文章介绍了下 <a href="https://zhuanlan.zhihu.com/p/371254789">Lex Fridman 大佬的日常生活安排</a>，后续我也根据他的方法对自己的日常生活做了一系列规范和改进。这一年整体实行下来，效果还是非常显著的，本文的最后会对我的一些实践以及借助的工具做一些分享。</p><p>最近几个月，偶然在油管上看到了个 <a href="https://youtu.be/2ekdc6jCu2E">Rich Roll 采访 Andrew Huberman 的 podcast</a>，介绍了如何提升我们日常工作，学习表现的相关神经科学原理与可以利用的“工具”，瞬间打开了一扇新世界的大门。后续又一连追了好几集 Huberman 自己的 podcast，从各个方面了解了一下跟我们日常生活，健康，学习，工作，锻炼等方面相关的知识。与其它很多讲“养生”的文章和视频最大的区别在于，Huberman 本身是斯坦福的神经科学教授，其中讲述的内容都是<strong>来自于高质量，peer reviewed 的科学研究成果</strong>，从机体工作原理出发，非常细致地介绍了相关的实验和结论，并给出了很多实操建议（很多都是零成本，不是搞推销的……）。</p><p>通过一系列的学习，逐渐有种学习了各种人类的“组成和操作原理”的感觉。通过一系列的工具和实践，我们也可以<strong>像调优软件程序那样来“调优”我们自身的人体系统</strong>。这篇文章就来介绍一些相关的知识内容。注意，原版的 podcast 中有非常多专业性的阐述，在这篇文章中基本都去掉了，尽量以故事性的描述来讲解，相对会比较好理解。当然准确性也会因此有所下降，如果希望获取更专业的内容，强烈建议观看 <a href="https://hubermanlab.com/">原版的 podcast 内容</a>。</p><h1 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h1><p>如果你想要获得健康，更好的工作学习状态，提升生理健康如免疫，新陈代谢，以及心理健康如更好的心情，专注能力等，最最重要的前提是拥有一个良好的睡眠。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>睡眠最重要的控制机理是我们内在的生物钟。随着生物钟的影响，我们体内的各类化学物质会发生变化，体温也随之改变，会影响我们的各种内在状态和外在行为。Huberman 教授很形象地描述了这个“生物钟”的具体作用方式：在早上，身体释放的皮质醇（cortisol）和肾上腺素（aderenaline）会让我们醒来，同时还会设定松果体释放褪黑素的倒计时钟，会在十多个小时之后让我们感到困意再次入睡。</p><p>影响这个生物钟的最大因素是光照。我们的眼睛除了能够看到东西，另外一个重大的作用就是<strong>通过黑视素神经节细胞来接收光照信息，用以设定我们的内在生物钟</strong>。这也是为什么有时候我们通宵工作之后，虽然已经持续很久时间没有睡眠了，但随着太阳升起，整体的生物钟被设定到了类似起床时的状态，各类化学物质的释放会让我们突然感觉又有精神了。后续很多最佳实践里也都跟这个原理相关，我们需要控制自己接收光照的时间点，类型和时长。</p><p>此外，<strong>体温也是一个用于控制我们生物钟的手段</strong>。一般来说我们的体温会从深睡眠中比较低的状态逐渐升高，到醒来后持续上升。到了一天的后半段会开始逐渐下降，直到再次进入睡眠。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>基于上面的原理，Huberman 教授提供了一系列提升睡眠的最佳实践：</p><ul><li>皮质醇的释放与接触阳光有关，因此如果想尽快醒来且保持日间良好的精神状态，<strong>起床后应该到外面去接触阳光，持续 2-10 分钟</strong>。这对于血压控制，心理状态，设定睡眠的“倒计时钟”等都有很大好处。户外日光的效果最好，如果是人造光源，蓝光的效果会比较好，且最好是上部（天空的位置）的光源。根据光照强度推算，隔着窗户接收日光的强度会降低 50%以上，而达到同样效果所需要的光照时间则需要 50 到 100 倍。有意思的是，这一点对于视障人士也有效，因为前面提到的黑视素神经节细胞并不是用于视觉成像的细胞。</li><li>对应的，<strong>在晚上要尽量减少光源的接触</strong>，因为这会扰乱我们的生物钟，让身体系统误以为是在白天。尤其是晚上 11 点到次日凌晨 4 点之间接收光源，会抑制后续几天的多巴胺的释放，影响心情，心理健康，专注度，学习能力，新陈代谢等等。关于多巴胺的作用和机理，后面会再单独介绍。</li><li>如果不可避免需要在晚上接触光源，处于较低位置，暗淡的红光，蜡烛之类的会相对好一些。如果要看电脑，建议使用 blue blockers 眼镜，这跟一些电脑软件会自动调节屏幕色温的效果可能类似。</li><li>傍晚观察落日，对于后续入睡也有帮助，甚至能减轻晚上摄入光照的负面影响，有点神奇。</li><li>人一天中的精神状态一般会在中间有个短暂的低谷，所以午睡对于有些人可能是有帮助的。也可以用一些其它的非睡眠深度休息的方式来替代，如 <a href="https://youtu.be/M0u9GST_j3s">Yoga Nidra</a>，<a href="https://www.headspace.com/">冥想</a>，<a href="https://www.youtube.com/c/MichaelSealey">自我催眠</a>（可以利用一些 App，如 Reveri）等。</li><li>体温对生物钟周期的影响：<ul><li>早上洗冷水澡，会让人快速升温，从而把睡眠周期往前移（早起）。</li><li>晚上锻炼身体，会让人保持高体温，从而延后周期（晚睡）。</li><li>可以选购一些自动控制体温的智能床垫来提升睡眠质量。</li></ul></li><li>一般建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点。不过总体来看好像影响度比较小。</li><li>饮食和药物因素：<ul><li>咖啡因会占据腺苷（adenosine）的受体，阻断入睡的信号。有不少文章都提到中午之后尽量不要喝咖啡，但 Huberman 表示没有科学实验表明咖啡因对所有人的效果是一样的，得根据自己的测试情况来。比如他自己在下午 5 点喝咖啡也能正常入睡。</li><li>镁，对入睡有帮助。</li><li>芹黄素也能帮助入睡，但要注意对雌性激素的影响。</li><li>建议不要摄入太多牛磺酸。</li><li>不建议通过摄入褪黑素来帮助入睡，褪黑素药物本身的规格把控不严格，且褪黑素容易引起抑郁情绪。</li><li>中午可以吃低卡路里以及含酪氨酸的食物，如坚果，大豆，部分蔬菜等，提升多巴胺，肾上腺素，保持清醒。</li><li>晚上则可以吃点淀粉，白肉等富含色氨酸的食物，进而转化为血清素，会让人更加平静，容易入睡。</li></ul></li><li>对于绝大多数人，6-8 小时的睡眠时长是比较健康的。</li><li>对于各类药物的检索可以参考：<a href="https://examine.com/">examine.com</a>。</li></ul><h1 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h1><p>在前面 Lex 的分享中，提到了他采取了生酮饮食以及 fasting（禁食）的习惯，这引起了我对于饮食习惯的注意。Huberman 教授正好也有几个 podcast 介绍了 fasting，肠道健康等话题，很有意思。</p><h2 id="Fasting-的背景"><a href="#Fasting-的背景" class="headerlink" title="Fasting 的背景"></a>Fasting 的背景</h2><p>我们可以把身体跟进食相关的化学状态分成 2 类：</p><ol><li>吃饱了的状态，也就是血糖含量较高的状态。此时我们身体会更活跃地进行体内细胞的复制与成长。</li><li>禁食的状态，也就是血糖含量较低的状态。此时我们的身体会更活跃地进行体内细胞的修复与清理（autophagic）。</li></ol><p>由于睡眠时我们天然是不吃东西的，所以一般来说睡眠中的一部分时间会使我们处于禁食状态，饮食时间的选择实际上就是在控制上述两个状态的持续时间和平衡关系。比较有意思的是世界上很多民族文化和宗教中，都有一些跟禁食相关的习俗，甚至会持续很多天。</p><p>在 2012 年，科学家开始对小白鼠做实验，把他们分成两大组，一组可以在一天中的任何时间吃东西，而另一组只能在固定的 8 小时里吃东西。在大组里再区分小组，给小白鼠吃健康的和不健康的食物。结果发现，只能在 8 小时里吃东西的小白鼠们，即使吃的是不健康的高脂肪食物，他们的健康水平仍然得到了保持甚至提高，相比所有不做限制的组都有明显的提升。</p><p>这个研究震动了学术界，后续又有非常多的针对人类，不同性别，不同年龄，不同职业（包括运动员）的各种实验与论文发表，科学家们发现这种<strong>间歇性禁食状态对于身体有非常多的好处</strong>，包括：促进肝脏健康，胆汁酸代谢，炎症自愈，保持体重，提升 brown fat 储备（对健康有益），防止非酒精性脂肪肝，血糖控制，肠道健康等等。如果养成间歇性禁食的习惯 60 天以上，还会让我们的身体倾向于代谢脂肪来供能，控制体重。</p><p>因此，Huberman 教授指出，<strong>何时进食，与吃什么东西，其实是同等重要的</strong>。这个研究也让很多学术界的研究人员自己也都养成了 fasting 的习惯，包括 Huberman 自己。</p><h2 id="Fasting-的实践"><a href="#Fasting-的实践" class="headerlink" title="Fasting 的实践"></a>Fasting 的实践</h2><p>由于长时间的禁食难度较大，所以绝大多数的研究都专注于间歇性禁食，也就是 intermittent fasting。简单来说就是跟前面的小白鼠实验一样，在一天的固定时间段来吃东西（跟睡眠周期对齐），而其它时间段都不摄入任何食物的做法。这里简单整理为基础和高阶两个版本：</p><ul><li>基础：如果想享受 fasting 的基础收益，最简单的执行原则是<strong>起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西</strong>。</li><li>高阶：目前研究结果中<strong>最理想的进食窗口是 8 小时</strong>，结合社会习俗等，一般比较合理的时间在 10-18 点或 12-20 点的范围。看起来<strong>不吃早饭并不是什么坏事</strong> :)</li><li>作者特地温馨提醒，如果想通过健身来增肌，建议可以把这个时间窗口往前移，因为早上摄入蛋白质会对肌肉增长有益。而健身的时间可以自由选择。</li><li>尽量<strong>保证这个窗口时间的稳定性</strong>，也非常重要。否则就跟频繁倒时差产生的效果差不多，会打不少收益折扣。</li><li>如果想尝试高阶 fasting，建议逐渐切换进食习惯，例如每两天缩短 1 小时的进食窗口，逐渐达到理想的 8 小时。</li></ul><p>值得注意的是，这里说的不吃任何东西，并不是说连水也不能喝。从前面的背景可以看到，是否处于禁食状态，主要依据是血糖水平，因此：</p><ul><li>喝水，茶，咖啡（不加牛奶）等，并不会中断禁食。但一勺糖的摄入就会中断。</li><li>晚饭后想尽快进入禁食状态，可以做一些轻量运动，比如散步等，加快血糖清理。</li><li>二甲双胍，黄连素（berberine）等可以直接促进血糖清理。肉桂皮，柠檬汁，也能轻微降低血糖。</li></ul><p>最后，如果禁食期间觉得有些头晕，颤抖，并不需要立刻进食或摄入糖分。可以喝一点盐水（可以加柠檬汁），一般就能很好的缓解症状。这让我想起 Lex 会提到了会服用药片来补充各种电解质元素，比如钠，镁，钾等。</p><h2 id="饮食与消化道健康"><a href="#饮食与消化道健康" class="headerlink" title="饮食与消化道健康"></a>饮食与消化道健康</h2><p>由于我个人的肠胃功能比较差，所以也特别关注了一下消化道健康的话题。Huberman 邀请了一位非常知名的微生物学家 Sonnenburg 来介绍肠胃微生物群落与我们的健康之间的关系，也是学到了很多新的知识：</p><ul><li>肠道的微生物群不仅影响消化系统的健康运作，<strong>对人体的免疫系统也起到了非常关键的因素</strong>。</li><li>婴儿出生，成长的方式会形成非常不同的肠道菌群生态。暴露在微生物环境中（但要注意会引起疾病的情况），对于维持菌群环境是有益的，比如家里养宠物，让孩子自由玩耍等，不需要过度清洁与消毒。</li><li>什么是健康的肠道菌群生态，目前没有一个标准的结论。不过总体来看，<strong>菌群的多样性程度高，一般就表示更加健康</strong>。</li><li>抗生素会严重破坏肠道菌群生态，需要谨慎使用。</li></ul><p>在访谈中，两位重点讨论了一个实验，就是什么样的饮食方式会让我们更好的维持肠道菌群的多样性和健康。实验主要对比了两种附加饮食：</p><ul><li>高纤维食物：全谷类，豆类，蔬菜，坚果。这也是传统上被认为非常健康的食物，其中很多纤维的分解都需要肠道菌群的帮助，换句话说，纤维就是它们的“食物”。</li><li>发酵类食物：酸奶，牛奶酒（kefir），康普茶，酸菜，泡菜，纳豆等。注意需要是自然发酵，一般是冷藏且非罐装的食品。而且像酸奶这类要格外注意不要加糖等添加剂。</li></ul><p>实验的结果也颇令人意外：</p><ul><li>摄入发酵类食品的组，显著提升了肠道菌群的多样性。被试者<strong>几十个免疫标志物的显著降低，对各类炎症都有更好的抑制作用</strong>。没想到吧，肠道菌群还能调节炎症。</li><li>肠道菌群本来的多样化程度比较高的人，摄入高纤维食物是有帮助的。如果不是，则摄入高纤维食物的帮助不大。在工业化进程中，人类的进食习惯已经有很多代都转变为了摄入大量肉类，加工食品等，肠道菌群的生态无法仅通过提高纤维食物的量来改变其族群结构。</li></ul><p>此外在访谈中，两位还讨论了具体食谱推荐的问题，引用了 <a href="https://youtu.be/sJLK3sVexIk">Christopher Gardner 关于生酮饮食与地中海饮食比较的研究</a>。这里总结一下实践建议：</p><ul><li><strong>如果要改善肠道菌群生态，最好的方式是一天两次摄入天然发酵类食品</strong>。</li><li>高纤维食物对于肠道菌群生态的维护是有益的，建议日常饮食以植物类食物为主，尽量避免深度加工食品的摄入，控制糖的摄入。Sonnenburg 教授还讲了个故事，说微生物学家参加的会议，一般餐厅的沙拉吧总是会供不应求 :) 前面提到的 Rich Roll 大佬也是个素食者。</li><li><strong>益生菌的效果没有广泛研究支持</strong>，且这类产品的监管很有限。<strong>益生元的效果也是好坏参半</strong>，缺乏多样性，溶解速度太快等问题都使总体效果存疑。</li><li>地中海饮食相比生酮饮食来说对健康的影响效果接近，但更容易坚持遵循。另外生酮饮食如果长期实践可能有一定的风险。所以<strong>总体更推荐地中海饮食结构</strong>。</li></ul><p>另外值得参考的是我们也有官方的 <a href="https://sspai.com/post/72984">中国居民膳食指南</a>，或许更适合东方人的饮食习惯。</p><h1 id="心态与动力"><a href="#心态与动力" class="headerlink" title="心态与动力"></a>心态与动力</h1><p>这一部分主要介绍的是人体的多巴胺系统原理，以及如何利用它来形成健康，自律的生活方式。这一集是 Huberman 开播以来播放量最高的一集，对于强健我们的心智有着非常好的指导作用。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>多巴胺是一种非常重要的化学物质，主要作用于两个神经回路：一个影响身体的运动，例如帕金森病与多巴胺的分泌不足有关；另一个则影响我们的动机，欲望与快乐，这几乎与我们从事的各种活动有关，无论是工作，学习还是社交，休闲娱乐。这里我们会主要讨论多巴胺的后者影响能力。我们为什么会“放弃”，实际上是由于在不安，压力，沮丧等情绪作用下，身体内的去甲肾上腺素水平不断提升，当超过一定阈值时，神经系统中的认知控制就会关闭，我们就放弃了。多巴胺能够抑制去甲肾上腺素作用，从而持续“激励”我们前行。</p><p>神经系统中多巴胺含量水平的高低会影响我们的情绪，当多巴胺水平低时，我们会感到情绪低落，没有动力，而多巴胺水平高时，我们会感到兴奋和快乐。在通常情况下，我们的身体处于多巴胺 baseline 的状态，当我们达成一些令人兴奋的目标（比如玩游戏胜利，考试拿高分）后，多巴胺的水平会达到一个高峰，此时我们就会获得巨大的愉悦感。在高峰之后，多巴胺水平会回落到比 baseline 更低的一个水平，且这个状态会持续一段时间。</p><p>这里有两个非常重要的原理：</p><ul><li>多巴胺绝对值含量的高低只是一方面，<strong>更重要的是其“相对变化量”的多少</strong>。比如在刷抖音时看到了一个很有趣的视频，多巴胺水平升高，你会感到快乐，刷到下一个视频时，你感到的快乐程度好像不会那么强烈了，因为多巴胺已经在一个比较高的水平，难以形成更大的变化量。而同样的视频，如果你是几天之后看到，或许你会觉得有意思的多。所以<strong>当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高</strong>。</li><li><strong>多巴胺的总体“储备”是有限的</strong>！也就是说无论你是通过学习，工作，娱乐，社交，运动等不同方式来获得快乐，所消耗的“快乐货币”都是同一种：多巴胺。举几个例子来看下这个原理带来的影响：<ul><li>很多自律的人都会说自己是 work hard，play hard 的生活方式，比如工作日通过高强度的工作来获得成就和满足感，休息日进行各种休闲娱乐，运动，社交等方式来获得快乐，其实背后都是在释放多巴胺来获取快乐。长期持续，我们身体的多巴胺 baseline 会逐渐下降，出现一种耗尽（burn out）的心理感觉，对很多事物无法保持之前的兴趣与精力。</li><li>很多人会对玩电子游戏着迷，因为它们能带来巨大的多巴胺释放刺激让人感到快乐。但要意识到，多巴胺的储备是有限的，如果对此上瘾，你的多巴胺耗尽问题就会变得非常严重：一方面能够引起你兴趣的事物会变少，可能只有玩游戏才能带来快乐；另一方面，后续甚至会导致玩游戏本身也无法触发多巴胺释放，引起严重的抑郁问题。</li></ul></li></ul><p>另外，<strong>多巴胺也具有叠加效应</strong>。比如你喜欢健身，那么运动就会刺激多巴胺的释放。而我们实际去健身时，可能会不自觉地安排了很多其它的“快乐因素”，比如选一个精神状态比较好的日子，运动前喝一些能量饮料，跟认识的朋友一起去，边健身边 social，听一些自己喜欢的音乐或 podcast，等等。这些因素也都会促进多巴胺的释放，让你感到“前所未有的快乐”。但要注意前面的原理，多巴胺的高峰越高，后面随之而来持续的低谷也会越长，而且长此以往，可能会降低你单纯从运动中获取快乐的能力。这样的例子还有很多，比如边跟朋友吃饭，边玩手机，拍照发朋友圈，可以计算一下叠加了几种快乐因素 :)</p><h2 id="影响多巴胺的外界因素"><a href="#影响多巴胺的外界因素" class="headerlink" title="影响多巴胺的外界因素"></a>影响多巴胺的外界因素</h2><p>我们来看下具体影响多巴胺释放的各类因素有哪些，首先是促进多巴胺分泌的：</p><ul><li>巧克力，提升到 1.5 倍的多巴胺 baseline</li><li>性行为，提升到 2 倍</li><li>尼古丁，提升到 2.5 倍</li><li>可卡因，提升到 2.5 倍</li><li>安非他命，提升到 10 倍</li><li>咖啡因本身只会少量提升多巴胺，但它会抑制一些多巴胺受体，提升同等多巴胺造成感受的效果</li><li>马黛茶，包含咖啡因，能控制血糖，还能保护多巴胺神经元</li><li>刺蒺藜豆也能提升多巴胺（基本等同于 L-DOPA），还能提升男性精子数量和质量</li><li>运动，带有主观成分，喜欢跑步的人，可以提升到 2 倍 baseline</li><li>健康的社交关系也会促进多巴胺释放</li></ul><p>食物方面感觉 Huberman 教授<strong>非常推荐马黛茶</strong>。</p><p>也有很多提升多巴胺释放或影响其效果的药物：</p><ul><li>L-Tyrosine（酪氨酸），提升多巴胺</li><li>Phenethylamine（PEA），巧克力中也包含，能够提升多巴胺</li><li>Huperzine A，提升多巴胺</li><li>各种“聪明药”，如 Adderall, Modafinil, Alpha-GPC, Ginkgo 等，留学党应该很多都有耳闻</li></ul><p>通常来说，<strong>不推荐持续使用这些药物</strong>，因为多巴胺释放之后的高峰会带来 baseline 水平的降低，导致无法享受活动的快乐，无法专注，限制学习能力和神经元可塑性等。Huberman 表示<strong>一周使用一次的频率应该是安全的</strong>。</p><p>最后还有一个比较特别的研究，就是<strong>冷水浴能够提升多巴胺释放到 baseline 的 2.5 倍左右</strong>，且持续时间更长，能达到 3 小时左右。建议使用 10-14 摄氏度的水温，注意安全。此外冷水浴也不需要太频繁，每周 11 分钟左右足够。如果已经习惯了冷水浴，那么也就没有释放多巴胺的效果了。</p><p>还有一些因素会降低多巴胺，如：</p><ul><li><strong>褪黑素，会引起多巴胺的减少</strong>。前面也提到过并不建议使用褪黑素来帮助入睡，或者适应时差等。</li><li>睡眠时段接触光源，也会引起接下来几天的多巴胺水平下降。<strong>半夜睡不着刷手机是很有害的哦</strong>。</li></ul><h2 id="维持健康的多巴胺水平"><a href="#维持健康的多巴胺水平" class="headerlink" title="维持健康的多巴胺水平"></a>维持健康的多巴胺水平</h2><p>了解了原理和各种影响因素后，我们来看下如何有效设计我们的生活工作方式来维持健康，可持续的多巴胺水平。</p><p>简单回顾一下，前面我们已经知道了多巴胺储备有限，且对一件事物上瘾会不断提高感受快乐的阈值，那么如何让我们能对一件事情保持长时间的兴趣和投入度，又不至于耗尽多巴胺呢？一个经典的例子是赌场的运作方式，我们并不是每一次下注都能赢，偶尔赢一次会释放多巴胺，而且根据赢得钱的多少有所上下浮动，这会吸引玩家持续参与。这就是一种非常有效的<strong>间歇性且随机的奖励机制</strong>。感觉很多游戏，社交网络产品也借鉴了这个思路来进行设计。</p><p>对于我们经常需要从事的活动，我们也可以模拟这个机制。还记得前面提到的<strong>多巴胺叠加效应</strong>吗？我们可以<strong>通过随机化叠加因素的多少，来实现多巴胺释放的差异性</strong>。还是以健身为例，我们可以随机决定今天是否要听音乐，是否去健身时带手机，是否要在健身前喝能量饮料等因素。如果其它什么都不做，只是单纯健身，那么多巴胺的释放量就会相对较低。如此就能模拟多巴胺释放有高有低的随机奖励机制。</p><h2 id="成长型思维"><a href="#成长型思维" class="headerlink" title="成长型思维"></a>成长型思维</h2><p>最后来看下如何构建良好的思维方式来利用多巴胺系统提升自我。</p><p>有一个非常知名的实验，挑选了一群天生喜爱画画的小朋友，在他们完成画作后给与一些奖励。后面在移除这些奖励后，小朋友们对于画画的兴趣和动力大大降低了。这个实验说明，当我们因为一个活动收到奖励（比如金钱，美食等）时，我们<strong>反而会降低活动本身的愉悦程度</strong>。而且多巴胺本身影响我们对时间的认知，同时也影响我们的情绪状态，如果我们<strong>始终以完成活动后的奖励为目标，则整个过程中就很少释放多巴胺，让原本困难的过程变得更加难以坚持</strong>。</p><p>仔细想一下，这是一个非常有意思的观察。多巴胺有点像我们的“本能系统”，决定了我们是否有动力做一件事。但反过来<strong>我们的主观思想却可以影响这个系统起作用的方式</strong>，这也是人类为何能摆脱动物本能，达成很多需要“反人性”的投入才能取得的成就的原因吧。上述的实验是我们的主观思想造成的一个反面作用的例子，我们自然也可以实现正面作用，那就是成长型思维。</p><p>具体来说，就是<strong>通过自我暗示，把努力过程本身当作一种“奖励”</strong>。我在努力学习，这个过程本身就是有趣的，会让我不断变得更强，这样的想法会在过程中激发身体系统释放多巴胺，而多巴胺提升了我们的情绪和动力水平，也会让努力的过程中碰到的困难变得相对容易克服。专注于这个过程的本身，而不是在过程前进行各种外界刺激（如前面提到的药物），或者在过程后给自己巨大的奖励。</p><p>这种思维方式看起来很主观，但这就是我们的神经系统工作的方式，虽然人类的“硬件系统”都差不多，但知识，思维这些运行之上的“软件”却可以千差万别。<strong>我们可以通过自律，自我暗示来改变自身对各类活动的喜好</strong>。例如通过暗示 fasting 对我们健康的益处，来获取满足感，而不是借助于 fasting 结束后的大快朵颐。通过自律抵御高油盐食物的吸引力，并且自我暗示植物类食物对身体的好处，坚持一段时间，会觉得花椰菜也挺美味的。这也是为什么我们在这篇文章中介绍了很多原理性的内容，而不仅仅是行为建议。因为这些原理知识能够让我们做更好的自我暗示 :)</p><p>多巴胺系统中也有对我们认知成长造成“障碍”的运作机理。例如当我们接受到的信息支撑我们之前的信念时，也能够激发多巴胺的释放让我们感到快乐，这从本质上会改变我们对世界的认知。由此可见，“空杯心态”是多么难得的品质，网上如此多的争论无法达成共识也有很大一部分“归功”于此。如何克服神经系统中的这类缺陷呢？一种可能的方法是尽可能调节情绪，使自己处于镇静的状态（提升血清素水平），这样才能让自己更好的去倾听和吸收跟自己认知不一致的信息，更好地协同合作。</p><p>这一节的 podcast 对我本人的冲击非常大，强烈建议大家观看这期 <a href="https://hubermanlab.com/controlling-your-dopamine-for-motivation-focus-and-satisfaction/">Mindset &amp; Drive</a>，相信也会有不同的收获。</p><h1 id="学习与专注"><a href="#学习与专注" class="headerlink" title="学习与专注"></a>学习与专注</h1><p>在了解了多巴胺的运作机制基础上，我们可以继续探究一些跟大脑健康，专注度，如何进行高效学习相关的话题。</p><h2 id="学习的原理"><a href="#学习的原理" class="headerlink" title="学习的原理"></a>学习的原理</h2><p>从脑神经科学来看，学习的本质是神经元的重新连接（rewire），进一步来看，需要大脑处在一种学习的化学状态下，也就是 Huberman 经常提到的神经可塑性（neuroplasticity）状态。要达到这个神经可塑性状态，有两个重要条件，一个是足够的专注度，另外一个是“犯错”的信号（后面会展开）。另外大脑一个比较有意思的机制是，在学习时的神经可塑状态下，乙酰胆碱会标记需要改变的神经元，而具体的神经元重连接则主要是在休息和睡眠时发生，是不是有点像 JVM 虚拟机的垃圾回收机制 :)</p><p>什么是犯错信号呢？当我们尝试做一些事情，但没有达到预期目标时，身体会给大脑发信号，“我犯错了”。处在这种犯错，沮丧的认知状态下，神经系统会释放肾上腺素（提升 alertness），乙酰胆碱（提升 focus），多巴胺（促进神经元的 change，rewire）等化学物质，激活神经元的可塑性。也就是说，<strong>犯错是我们进入学习状态的重要前提</strong>。搞机器学习的同学应该很熟悉了吧，这跟我们训练模型不是一模一样么 :) 另外很多人可能觉得心流（flow）状态是学习的最佳状态，而 Huberman 则不这么认为。<strong>心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能</strong>。</p><p>对于这个学习状态，经典的实验是给人们戴上一些能转变角度的眼镜，然后执行一些类似物体抓取的任务。由于看到的东西通过眼镜改变了其本来的位置，一开始在尝试时总会出现抓取动作的偏离。但后续在进入神经可塑性状态后，我们能逐渐适应相关的视觉偏移，协调自己的听觉，动作等都与之协同，顺利完成任务。更有意思的是，<strong>这个“神经可塑性”的化学状态是可以持续的</strong>，我们甚至可以先通过一些其它操作触发大脑的这个机制，再去进行真正的学习，以加快学习的速度。这里还有一个隐藏逻辑，当你在遇到挫折困难时，大脑进入了可塑性状态，而此时你却放弃了，那么<strong>神经元也会重新连接到这种容易放弃的行为模式，形成恶性循环</strong>。</p><p>人在年幼时期大脑天然的神经可塑性会比较好，而在 25 岁以后则会大大下降。我们后面会提到如何来进行克服。</p><p>另外，<strong>休息和睡眠时也会发生大量的神经元重连接的活动</strong>，这也是之前我们就提到过的，高质量的睡眠是实现很多生理，心理健康强壮的先决条件。</p><h2 id="利用神经可塑性"><a href="#利用神经可塑性" class="headerlink" title="利用神经可塑性"></a>利用神经可塑性</h2><p>如果正在阅读文章的你还未满 25 岁，那么恭喜你，你的神经可塑性仍然非常的好，可以<strong>尽可能广泛的学习各种知识和技能</strong>。比如你可以很快学会各种乐器，新的语言，新的运动，新的专业技能等等。通过更广阔领域的体验接触，尽量找到你最有兴趣的方向，可以后续再不断深入经营。</p><p>如果已经像我一样超过了 25 岁，那么还有很多办法来提升神经可塑性：</p><ul><li>通过实验发现，<strong>成年人对于小幅度的增量学习是完全可以适应与掌握的</strong>。例如每次视觉上的偏差只有 7 度，而不是一下子就来个 180 的大颠倒，那么成年人也能很快从错误中学习纠正。应用到实际学习中，我们每次学习的内容可以控制一下不要太多（本文有点违反了，建议收藏慢慢学习），多次积累来完成神经系统的调整学习。</li><li>对于达成目标的渴求度越高，重要性越大，奖励的刺激越大（比如为了生存），则神经可塑性就会越容易出现。这个比较符合直觉，但是现实中可操作性可能不高。</li><li>第三点最有意思，<strong>通过扰乱前庭神经系统（vestibular system），能够达到神经元可塑性的状态</strong>。简单来说，就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习。这一下子就让我想到了<strong>淘宝成立初期的“倒立文化”，没想到还真的有科学依据</strong>。需要注意的是，这个体验必须要新颖，也就是说如果你已经倒立很熟练了，那么去做倒立就是个日常行为，并不会给身体一种在犯错边缘，需要纠正的刺激。</li></ul><p>Huberman 认为，大脑的主要功能链路是感知，认知，情感，思想，行动。在尝试控制我们的神经系统来进行各种任务时（例如学习，解决困难问题，挑战运动极限），我们是很难用精神思想来控制其本身的（比如不断跟自己说我不能分心），更可行的办法是“逆向链路”，从我们的行动出发，利用神经系统的运作原理，逐渐影响思想，情感，认知甚至感知部分。这也是 Huberman 非常推崇各种“行动工具”的原因。Mood follows action。</p><h2 id="学习的理想状态"><a href="#学习的理想状态" class="headerlink" title="学习的理想状态"></a>学习的理想状态</h2><p>除了神经可塑性的化学状态外，我们也需要注意其它的因素。例如我们<strong>不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考</strong>等。这些也都跟我们体内的多巴胺，肾上腺素，乙酰胆碱，血清素，褪黑素等化学物质的水平有关，需要做好调节。在之前 Rich Roll 的访谈节目中，Huberman 提了一个非常有效的“呼吸工具”，叫<strong>生理叹息</strong>（Physiological Sigh）。操作方法上简单来说就是吸两口气，然后出一口长气。通常情况下，只要一两次生理叹息就足以使我们的压力和警觉水平迅速下降，让人感到更加平静，提升学习表现。</p><p>前面提到的成长型思维也很重要，在遇到错误导致的沮丧感觉时，可以不断增强自我暗示，失败是帮助我们学习成长的唯一路径，对我们是有益的，以此增加多巴胺的释放，提升学习动力和过程中的愉悦感。</p><p>联系到睡眠对学习的促进作用，也有一些研究提供了一些相关的 tips：</p><ul><li>在学习时听一些有规律的节拍，在入睡时也播放同样的微弱节拍，能够提升学习和记忆的效果。</li><li>一般在 90 分钟的学习后（人体生物钟的周期），可以选择进行 20 分钟的休息（non sleep deep rest），也会加强学习的效果。</li><li>Gap effect，在学习中随机停止 10 秒钟，这些停止会在睡眠中加速“播放”，提升学习效果。</li></ul><h2 id="提升专注"><a href="#提升专注" class="headerlink" title="提升专注"></a>提升专注</h2><p>“专注”背后的机理是大脑中两种“网络模式”的协调，一种叫 Default network，在我们不做任何事情时被激活，另一种叫 Task networks，在我们专注于做某些事情时被激活。普通人的大脑能够很好地协调这两个模式，两者像跷跷板一样，当一种模式被激活时另一种模式会被抑制。而具有专注障碍（比如多动症）的人来说，这两者无法很好地进行协调，因此会出现无法专注的现象。</p><p>通过提升多巴胺水平，可以有效促进这两种网络模式的协调，因此有非常多的多动症治疗药物都跟提升多巴胺有关，例如 <strong>Adderall，Modafinil</strong> 等。一些调查表明，这些药物（经常被称为聪明药，nootropics）在美国被滥用的程度甚至超过了大麻，不少“学霸”都以此来提升注意力，减少对睡眠的需求。但 Huberman 教授表示，一方面多巴胺的刺激提升后都会带来多巴胺水平的低谷，另一方面这些药物也可能导致上瘾，对新陈代谢作用造成扰动，有很多负面影响，<strong>对长期的学习与记忆效果可能并没有提升作用</strong>。在之前介绍多巴胺的章节也有提到，应该谨慎使用这类药物，并严格控制使用频率不能过高。</p><p>最好的提升专注的方法当然是前面聊过的更好的控制我们的多巴胺系统，例如把行动跟背后的意义相连接，给自己正面的心理暗示；将任务拆成多个小的里程碑，通过过程自身的激励来促进多巴胺的释放提升我们的专注度。此外一些安全有效的提升专注力的方法包括：</p><ul><li>适量补充 <strong>Omega-3 EPA 鱼油</strong>，这是神经细胞的组成原料之一，能够有效减轻抑郁，对治疗多动症（ADHD）也有帮助。</li><li><strong>通过身体其它部分释放运动，可以帮助提升注意力</strong>。教授举的例子是作为神经科医生在开刀时，如果采用半蹲半站的姿态（运动释放），拿手术刀的手更稳定不容易颤抖。这让我想起以前读书时很多同学习惯转笔，现在工作了也有不少人喜欢玩指尖陀螺，或者站立办公，可能都是类似效果。</li><li><strong>限制视野范围，能够提升专注度</strong>。比如我们经常因为眼睛瞟到了任务栏上的消息提示闪动而分心，可以通过一些设置来进入“专注模式”。</li><li>视线的高低也会影响神经状态，<strong>视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕</strong>。工作时一般至少把显示器放置在鼻子位置之上。</li><li>大脑不擅长处理大量频繁的 context switch，典型的比如刷抖音，不同的信息以非常快的速度频繁切换，这对我们的注意力是有伤害作用的。2014 年的一项研究表示，<strong>我们每天在手机上花费的时间应该少于 60 分钟（青少年）/120 分钟（成年）</strong>，以免引起注意力障碍问题。</li><li>还有研究表明，<strong>17 分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力</strong>。只要做一次就可以，完全可以尝试一下。</li></ul><h2 id="大脑健康"><a href="#大脑健康" class="headerlink" title="大脑健康"></a>大脑健康</h2><p>最后来看下提升大脑健康和效能的一些方法。</p><p>首先是前面提到过的，保证高质量的睡眠。</p><p>运动方面，<strong>对大脑直接帮助最大的是有氧运动</strong>，提升心肺功能，支持大脑供能。建议每周 150-180 分钟的有氧训练。</p><p>对于大脑健康有帮助的食物，其中前三点是比较重要的，后面的部分涉及的研究没有那么多：</p><ul><li><strong>Omega3, 尤其是 EPA 等脂肪酸</strong>，是大脑组成的重要部分，且一般人都容易摄入不足。多吃鱼，牡蛎，鱼子酱，奇亚籽，核桃，大豆。一天至少摄入 1.5 克，理想情况需要 3 克以上。不喜欢吃鱼的话可以辅助摄入鱼油。</li><li><strong>磷脂酰丝氨酸</strong>，也对认知能力有帮助。通过鱼，肉类，卷心菜来摄入。</li><li><strong>乙酰胆碱</strong>，重要的神经调质，提升注意力。摄入胆碱的重要来源是鸡蛋，尤其是蛋黄。土豆，坚果，水果中也含有，虽然没有蛋黄中的含量那么丰富。可以通过 Alpha-GPC 等补充剂来获取。</li><li>肌酸，尤其对于不吃肉的人，一天需要摄入 5 克左右。</li><li>花青素，在蓝莓，黑莓，葡萄等食物中有提供。可以降低 DNA 损伤，缓解认知下降等问题。大约每天需要 60-120 克蓝莓的补充。</li><li>谷氨酰胺，可以通过牛肉，鸡肉，鱼肉，鸡蛋，大豆，卷心菜，菠菜，芹菜等食物来摄取。提升大脑在缺氧（高海拔地区）下的表现，还能够抑制对糖的需求。</li><li>水，钠，钾，镁等电解质是神经元信号传递所需的基础元素，需要保证。</li></ul><p>这一节中还讨论了我们身体对各种食物喜好进行判断的三个渠道，前两个分别是味觉判断和营养成分的下意识判断。第三个比较有意思，也跟多巴胺有关，即我们可以<strong>通过提升大脑代谢的活跃度来增加对某种食物的喜好</strong>。比如你如果不喜欢吃鱼，一种方法是你可以把鱼跟你平时爱吃的食物一起吃，另一种是给自己足够的心理暗示，说服自己吃鱼是有益身体健康的。通过这两种办法，你都可以让大脑释放多巴胺，从而逐渐提升对鱼类食物的喜好程度。</p><p>最后，如果你对膳食补充剂感兴趣，还可以看看 <a href="https://www.thorne.com/u/huberman">Huberman 教授平时会吃的补充剂有哪些</a>。</p><h1 id="长寿"><a href="#长寿" class="headerlink" title="长寿"></a>长寿</h1><p>最后我们来看下如何延年益寿，这是 Huberman 跟这个领域的专家，来自哈佛的 David Sinclair 的一集访谈节目。</p><h2 id="衰老的本质"><a href="#衰老的本质" class="headerlink" title="衰老的本质"></a>衰老的本质</h2><p>Sinclair 认为，衰老是一种疾病，它本身导致了非常多通常意义上的疾病的出现，比如阿尔兹海默症，癌症等。我们可以通过科学的手段来“治疗”衰老，甚至逆转它。</p><p>从本质上来说，衰老是<strong>基因信息的损失</strong>，这分为两部分：</p><ul><li>DNA 本身的信息，比如细胞中的 DNA 结构会在辐射等情况下受到破坏。</li><li>控制哪些基因进行表达的信息受到了破坏，也就是所谓的表观基因组（epigenome）。这部分在衰老的因素中占了 80%。</li></ul><p>人体内有一个天然的“衰老时钟”，而且并不是以匀速走的。在年轻时我们的生长发育过程中，这个时钟走得更快。所以如果青春期发育比较迅速的人，一般来说整体的时钟走的比较快，寿命也会相对短，是不是有点吓人……而且，一般比较矮小的人，像侏儒很少会得心脏病，癌症，也会明显更长寿。不过不要紧张，前面提到了，基因本身的信息只占了衰老因素的 20%，<strong>控制基因表达这部分占了大多数</strong>。</p><p>这里有点意外的是 Sinclair 教授介绍的最重要的几个实验，都跟前面我们提到的 fasting 有关。比如一般老鼠的寿命大概是 2 年，他们实验室有一只叫 Yoda 的老鼠，活了足足 5 年。其主要的做法就是选取了侏儒基因，以及执行 fasting。</p><p>教授详细介绍了 <strong>fasting 为何能提升动物/人类 30% 以上的寿命</strong>：</p><ul><li>在低血糖水平时，身体会抑制哺乳动物雷帕霉素靶蛋白（mTOR），激活去乙酰化酶（sirtuin），形成一个非常良好的化学状态，清理旧蛋白质，提高胰岛素敏感度，提供更多能量，修复细胞等等。后面这个乙酰化酶是我们抵御衰老的一个重要武器。</li><li>当胰岛素水平低时，“长寿基因”会被激活，如 SIRT1 等。</li><li>fasting 会给细胞足够的“休息时间”。</li><li>血糖水平低，会让身体对胰岛素更敏感，更快吸收血糖，也对健康有益。</li><li>当你从来不感受饥饿时，你的衰老时钟也走的更快。</li><li>除了 24 小时周期 fasting 触发的 autophagic，还有更深层次的清理机制，会在禁食第二，三天启动。在老年老鼠上的实验表明，这种长时间的禁食可以让他们延长寿命 35%。不过这个实操难度对普通人来说有点大。</li></ul><p>Sinclair 也对比了一些上个世纪失败的研究，比如通过抗氧化剂来抵御衰老。现代长寿研究的核心思想是，如何<strong>通过一些机制手段来触发身体自身的衰老抵抗机制</strong>。</p><p>此外 Sinclair 也介绍了一些激动人心的前沿技术，例如<strong>通过基因治疗方法，可以重启我们的 DNA 表达系统</strong>。通过一次注射，可以让盲人恢复视力，这已经在老鼠身上得到了验证。或许几年后，我们可以像死侍那样实现身体各部分的逆转老化。</p><h2 id="抗衰老手段"><a href="#抗衰老手段" class="headerlink" title="抗衰老手段"></a>抗衰老手段</h2><p>先来总览看一下各种抗衰老的手段。</p><h3 id="饮食-1"><a href="#饮食-1" class="headerlink" title="饮食"></a>饮食</h3><p>包括食物结构和饮食控制。饮食控制方面前面有提到过，建议缩短进食窗口到 8 小时左右。饮食结构可以参考最新发表在 Cell 上的这篇文章 <a href="https://www.cell.com/cell/pdf/S0092-8674(22)00398-1.pdf">Nutrition, longevity and disease: From molecular mechanisms to interventions</a>。简单总结一下就是多吃植物类的蛋白（花生，藜麦，豆类，西兰花等），脂肪（橄榄油，坚果，牛油果等），减少精制碳水（白米饭，白面包，蛋糕，饼干等）；动物脂肪，动物蛋白质，糖这些总体来说是加速衰老的。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/diet_for_longevity.png" alt="长寿饮食建议"></p><h3 id="体育锻炼"><a href="#体育锻炼" class="headerlink" title="体育锻炼"></a>体育锻炼</h3><p>有氧锻炼对心肺功能，血管健康等方面的促进对延寿很有帮助。力量训练也能持续保持我们的肌肉，关节，韧带的力量水平，支撑保护能力等，在年纪大时减少各种跌倒或者受伤的风险。一般建议是一周 3 小时左右的有氧运动，搭配 2 到 3 次的力量训练。有氧运动一般比较简单，跑步，骑车，游泳都可以。力量训练有一定的门槛，个人也最近正在学习一些入门训练方式。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/workout_plan.png" alt="力量训练计划"></p><h3 id="药物"><a href="#药物" class="headerlink" title="药物"></a>药物</h3><p>药物方面的研究也非常多，不过绝大多数都还在人体实验的早期。具体可以参考发表在 Nature 上的这篇 <a href="https://www.nature.com/articles/s41573-020-0067-7">The quest to slow ageing through drug discovery</a>，总结了各种相关研究，其中就包括了著名的二甲双胍，NMN 等。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/drugs_for_longevity.png" alt="长寿药物"></p><h3 id="细胞重编程"><a href="#细胞重编程" class="headerlink" title="细胞重编程"></a>细胞重编程</h3><p>前面也提到了基因表达是影响衰老最重要的因素，那么有没有手段来控制人体细胞的基因表达呢？著名的山中因子（Yamanaka Factors）给出了一种可能。山中伸弥团队发现的诱导方法是，通过慢病毒载体将 Oct4、Sox2、c-Myc、Klf4 四种转录因子基因转入成体细胞，将其转化为类似于胚胎干细胞的多能干细胞（iPS 细胞）。iPS 细胞与胚胎干细胞拥有相似的再生能力，理论上可以分化为成体的所有器官、组织，而这一点完美地对冲了由细胞衰减带来的人体衰老。听起来是不是非常的神奇？基于这些新技术也出现了很多主攻长寿领域的科技创新公司，如 <a href="https://www.lifebiosciences.com/">Life Biosciences</a>，<a href="https://altoslabs.com/">Altos Labs</a> 等，我们可以期待一下未来这些技术的普及应用。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/cell_reprogramming.png" alt="山中因子"></p><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h2><p>这里列出一些 Sinclair 自己的实践方式，如果想要采纳还是要结合自身的情况来看。有意思的是这集节目下有个热门留言是这个教授竟然已经 52 岁了，完全看不出来……所以你懂的。</p><ul><li>不吃早饭，午饭也吃的比较少，酸奶或者橄榄油，晚饭吃蔬菜为主，加鱼和虾，基本不吃牛排。不吃糖，甜品，面包。基本达到了 2 小时进食窗口的高阶 fasting 状态。他偶尔也会尝试一整天都不吃东西，但比较难坚持。</li><li>每天摄入 1 克的白藜芦醇（resveratrol），1 克的 NMN（进而会转化为 NAD，which is sirtuin 的“燃料”），还有二甲双胍（metformin）。其中锻炼的日子可能会跳过一些补充品。他并不吃复合维生素。</li><li>以蔬菜为主食的好处：富含各种营养，维生素；包含异种激素（Xenohormesis），植物基于“压力”之下产生的物质，对长寿有益。后者也可以通过槲皮素（quercetin）来做膳食补充。</li><li>一般会隔一天进行有氧运动和力量训练。有氧运动能提升 NAD 水平。</li><li>根据家族病史来决定一些药物摄入，如他 29 岁就开始服用降胆固醇药物。</li><li>对于人造甜味剂，教授认为总体来说是安全的。他偶尔也会喝健怡可乐。</li></ul><p>对于这一系列实践，Sinclair 教授都进行了 10 多年的自身实验，并使用各种手段来监控身体数据。通过监控数据可以推测出一个人的“生理年龄”如何（不是光看脸），他自己在上述实践下，生理年龄在持续下降，现在已经达到了 30 岁左右的水平（实际年龄 52 岁）。另外，他认为每个人的身体情况不一样，医院约定俗成的生理指标范围也不一定适合每个人。<strong>未来这种健康数据的实时监控与个性化诊断会成为主流</strong>。他举了一些例子：</p><ul><li>监控血糖水平 HbA1c，观察 fasting 的影响等。</li><li>监控炎症指标 CRP，与心脏病等各种疾病的诱发相关。</li><li>监控 LDL，通过药物等进行控制。膳食胆固醇对血液胆固醇几乎没有影响，不需要戒红肉，黄油等。</li><li>补充铁元素可能加速衰老。医学指标需要个性化，低铁元素含量并不一定导致贫血。</li></ul><p>还有一些影响寿命的负面因素：</p><ul><li>肥胖症会加速衰老。</li><li>吸烟，会破坏基因表达，加速衰老。</li><li>X 光检查同理，没有必要时，避免接触。</li></ul><p>展望一下 longevity 研究的未来，还是挺激动人心的。现代科学每一年能让我们的平均寿命延长 1/4 年，如果每一年能让我们的平均寿命延长超过 1 年，则达到了<strong>寿命“逃逸速度”</strong>（类比以 1000 英里每小时的速度往西飞行，太阳永远不会落下），实现了“永生”。著名的未来学家 Ray Kurzweil 预测，大约 12 年后（2034 年）就能实现，让我们拭目以待。</p><p>除了这集 podcast，也必须附上吴承霖大佬的万星项目 <a href="https://github.com/geekan/HowToLiveLonger">程序员延寿指南</a>。</p><h1 id="个人实践"><a href="#个人实践" class="headerlink" title="个人实践"></a>个人实践</h1><p>前面介绍的内容有点多，这篇文章篇幅也有些超了。最后来简单介绍下我个人目前采纳的一些行动和辅助工具。</p><p>睡眠方面暂时没有什么特别的措施，现在带娃基本上晚上睡眠质量也比较一般。只是会稍稍注意一下晚上 11 点后尽量不接触手机光源。早起接收光照这点，基本上就是早上遛狗或者开车通勤时间来接触，基本压力不大。如果比较讲究的同学，还可以下一个 <a href="https://mycircadianclock.org/">My Circadian Clock App</a> 来追踪一下生物钟，也是 Satchin Panda 等大佬参与开发的项目，值得信赖。</p><p>饮食方面，开始尝试 8 小时进食窗口的 fasting，目前感觉良好。中饭一般吃蔬菜为主的轻食，晚上就比较放飞自我，想吃啥吃啥。早上会看情况喝点盐水，茶或者 AG1 的补充剂。膳食补充剂目前基本只有复合维生素和 EPA 鱼油在使用，后面可以参考下 <a href="https://fastlifehacks.com/andrew-huberman-supplements-list/">Huberman 的“配方”</a> 增加一些。Huberman 自己也在节目中表示<strong>对白藜芦醇和 NMN 还在观望状态</strong>，我查了些资料发现有争议的地方还不少，所以我个人建议先采纳广受认可和使用的一些补充剂，如 EPA 鱼油，二甲双胍等。个人目前考虑的补充剂列表：</p><ul><li><a href="https://www.thorne.com/products/dp/basic-nutrients-2-day">基础维生素</a>，常规补充剂，也可以根据自己的饮食结构，生活习惯选择特定的营养物质补充。</li><li><a href="https://www.thorne.com/products/dp/super-epa-sp608nc">Omega-3 EPA</a>，常年销量靠前的补充剂，好处前面已经说了很多了。</li><li><a href="https://athleticgreens.com/en">AG1</a>，超火的小绿粉，各种植物提取物 + 各种维生素矿物会，Fridman 等大佬的节目里都有提到。个人买了一次，不过看一些其它评测貌似并不是很划得来。</li><li><a href="https://www.thorne.com/products/dp/betaine-hcl-pepsin-225-s">Betaine HCL &amp; Pepsin</a>，保护肠胃，促进吸收。</li><li><a href="https://www.thorne.com/products/dp/l-tyrosine">L-Tyrosine</a>，提升多巴胺，可能会买个尝尝鲜。</li><li><a href="https://zh.m.wikipedia.org/zh/%E4%BA%8C%E7%94%B2%E5%8F%8C%E8%83%8D">二甲双胍</a>，抗衰老“神药”，不过这个药的有效性和安全性还有争议，建议谨慎。</li><li><a href="https://www.thorne.com/products/dp/resveracel">ResveraCel</a>，白藜芦醇，NR 等抗衰老组合。效果同样有争议，尤其 NMN 这块更是各种产品鱼龙混杂无法分辨，谨慎购入。</li></ul><p>很多人都关心 fasting 可能引发胆结石，这里提供一些补充信息：</p><ul><li>从这篇 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1419405/">Bloch, H. M. 等人的论文</a> 来看，fasting 过程中胆汁的饱和度有一个先上升后下降的过程，<a href="https://youtu.be/2lGuXBwudKw">Dr. Berg 也以此做了解释</a>，认为 fasting 加生酮饮食（摄入脂肪）对胆囊健康反而是有益的。</li><li>从这篇 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1405175/">Sichieri, R. 等人的论文</a> 的结果来看，long overnight fasting 和节食会提升得胆结石的概率。不过减肥（减少脂肪）本身就会提升得胆结石的概率。</li><li>持续 24 小时以上的禁食相关的研究比较少（比较难执行），但从机理上来说长时间的禁食应该会增加得胆结石的概率。</li><li>饮食结构，自身状况对胆结石的形成也会有很大影响，例如高胆固醇，高胰岛素水平，高碳水饮食等。高纤维食物，健康的脂肪摄入，有助于降低得胆结石的概率。</li></ul><p>总体看下来，我个人感觉这块的实验上没有一个定论（就跟 <a href="https://www.coffeeandhealth.org/factsheet/gallstones-factsheet">咖啡是否会引发胆结石</a> 一样），但应该不是一个概率很大的问题，起码 Huberman 教授跟这个领域的另一位权威 Satchin Panda 教授都没有提到这块的问题。理想情况是执行 fasting 时持续对你的身体状况做医学指标的跟踪。其它就看个人选择了 :)</p><p>工作，学习，专注方面，主要看自律了。这方面我总体控制还可以，在了解了多巴胺的工作原理之后就更加有自信了，主要靠各种软件的专注模式来近似执行番茄时钟法，此外也采用了升降桌，大概有 30% 的时间站立办公。工作间歇会尝试一下 Yoga Nidra。此外晚上学习时段会用 iPad 的 Books 来记录一下阅读时间，基本上每天保持 30 分钟以上，持续坚持。后面考虑试试工作时喝马黛茶，以及夏天开始尝试冷水澡。</p><p>运动方面是这一年来改观最大的一项，依靠小米手环 PAI 指数功能的督促，基本上做到了每周平均 3 次的跑步或者羽毛球活动，持续把 PAI 值保持在 200 左右。总体来说对于精神状态的改观还是很大的，肚子上的脂肪也减少了很多。唯一比较困扰的是一般下班后运动都要 9，10 点开始了，结束后会离入睡的时间比较近，有时候会对睡眠质量有所影响。</p><p>最后，Huberman 教授的 podcast 中还有很多其它内容，比如习惯养成，健身增肌，应对恐惧与创伤，情绪管理等，感兴趣的朋友可以进一步挖掘。本文以实验事实与原理假设的陈述为主，以上所有的行动方案都需要在咨询医师，专业人员的条件下，结合自身情况执行，注意自身安全，本人与 Huberman 都不负相关后果责任。</p><p>备注：这篇文章也同时发布到了 <a href="https://github.com/zijie0/HumanSystemOptimization">Github</a>，欢迎大家 Star 并提出宝贵建议，谢谢！如果你对我的其它作品感兴趣，也欢迎搜索关注公众号：RandomGenerator。</p><p>转载：<a href="https://github.com/zijie0/HumanSystemOptimization">https://github.com/zijie0/HumanSystemOptimization</a></p>]]></content>
      
      
      <categories>
          
          <category> Human </category>
          
          <category> daily diet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS云计算基础</title>
      <link href="/2023/07/31/AWS%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/31/AWS%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="AWS云计算理论基础"><a href="#AWS云计算理论基础" class="headerlink" title="AWS云计算理论基础"></a>AWS云计算理论基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Amazon Web Services </li><li>可以理解成一群人买了一个空间，里面堆了一堆硬件然后租给你用，和网吧的原理是一样的。</li><li>AWS云计算是指亚马逊网络服务（Amazon Web Services）提供的一系列云计算服务。它允许个人、企业和组织通过互联网访问和使用IT资源</li></ul><iframe width="560" height="315" src="https://www.youtube.com/embed/a9__D53WsUs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>分别能够提供高级联网，数据分析，数据库，AWS游戏，机器学习，媒体服务，安全性，无服务器，存储等主要服务<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230807172336657.png" alt="image-20230807172336657"></li></ul><h3 id="云计算类型"><a href="#云计算类型" class="headerlink" title="云计算类型"></a>云计算类型</h3><ul><li>每种类型的云服务和部署方法都提供不同级别大的控制力，灵活性和管理功能。理解基础设施即服务和软件即服务之间的差异，以及可以使用的部署策略，有助于根据需求选用合适的服务组合。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230812141634839.png" alt="image-20230812141634839"></p><h4 id="云计算模型"><a href="#云计算模型" class="headerlink" title="云计算模型"></a>云计算模型</h4><h5 id="基础设施即服务（laaS）"><a href="#基础设施即服务（laaS）" class="headerlink" title="基础设施即服务（laaS）"></a>基础设施即服务（laaS）</h5><ul><li>提供基本的计算，存储和网络资源，用户可以在这些资源上构建和管理自己的应用程序。用户负责操作系统及以上的管理和维护，如虚拟机，存储实例等</li></ul><h5 id="平台即服务（PaaS）"><a href="#平台即服务（PaaS）" class="headerlink" title="平台即服务（PaaS）"></a>平台即服务（PaaS）</h5><ul><li>在laaS的基础上，PaaS还提供开发框架，数据库，中间件等。用户可以专注于应用程序开发，而不必关心底层基础设施的管理。</li></ul><h5 id="软件即服务（SaaS）"><a href="#软件即服务（SaaS）" class="headerlink" title="软件即服务（SaaS）"></a>软件即服务（SaaS）</h5><ul><li>提供完整的应用程序作为服务，用户无需安装，维护或管理应用程序本身。常见的有电子邮件，办公套件，客户关系，管理系统等。</li></ul><h5 id="函数即服务（FaaS）"><a href="#函数即服务（FaaS）" class="headerlink" title="函数即服务（FaaS）"></a>函数即服务（FaaS）</h5><ul><li>也称为无服务器计算，它允许开发人员编写单个函数（或功能块），并在需要时候自动触发执行，无需关心底层的服务器和基础设施。</li></ul><h5 id="容器即服务（CaaS）"><a href="#容器即服务（CaaS）" class="headerlink" title="容器即服务（CaaS）"></a>容器即服务（CaaS）</h5><ul><li>提供容器管理和编排的服务，用户可以将应用程序打包成容器，并在云平台上进行部署，扩展和管理</li></ul><h5 id="多云和混合云"><a href="#多云和混合云" class="headerlink" title="多云和混合云"></a>多云和混合云</h5><ul><li>多云指的是将应用程序和数据分布在等多个不同的云平台上，而混合云则是将云计算与传统本地基础设施相结合，使得用户可以在不同环境中灵活地部署和管理应用程序。</li></ul><h4 id="AWS核心服务"><a href="#AWS核心服务" class="headerlink" title="AWS核心服务"></a>AWS核心服务</h4><h5 id="计算服务："><a href="#计算服务：" class="headerlink" title="计算服务："></a>计算服务：</h5><p>Amazon EC2 (Elastic Compute Cloud)：提供可扩展的虚拟机实例，用于运行各种应用程序。</p><p>Amazon ECS (Elastic Container Service)：用于管理和编排Docker容器的服务。</p><p>AWS Lambda：无服务器计算服务，允许您在需要时运行代码，无需管理服务器。</p><p>Amazon Lightsail：为简单应用提供的轻量级计算实例，适用于初学者和小型项目。</p><h5 id="存储服务："><a href="#存储服务：" class="headerlink" title="存储服务："></a>存储服务：</h5><p>Amazon S3 (Simple Storage Service)：对象存储服务，用于存储和检索任意数量的数据。</p><p>Amazon EBS (Elastic Block Store)：提供持久性块存储卷，可附加到EC2实例。</p><p>Amazon Glacier：长期数据存储服务，适用于需要稳定存储而不需要频繁访问的数据。</p><p>Amazon EFS (Elastic File System)：提供可扩展的文件存储，可以在多个EC2实例之间共享。</p><h5 id="数据库服务："><a href="#数据库服务：" class="headerlink" title="数据库服务："></a>数据库服务：</h5><p>Amazon RDS (Relational Database Service)：托管的关系型数据库服务，支持多种数据库引擎。</p><p>Amazon DynamoDB：托管的NoSQL数据库服务，适用于高度可扩展和低延迟的应用程序。</p><p>Amazon Aurora：高性能、关系型数据库引擎，兼容MySQL和PostgreSQL。</p><p>Amazon Redshift：用于数据仓库和分析的大规模数据存储和处理服务。</p><h5 id="网络和内容分发："><a href="#网络和内容分发：" class="headerlink" title="网络和内容分发："></a>网络和内容分发：</h5><p>Amazon VPC (Virtual Private Cloud)：创建私有网络，允许您在AWS中隔离和配置资源。</p><p>Amazon CloudFront：内容分发网络，加速向全球用户分发静态和动态内容。</p><p>Amazon Route 53：可扩展的域名系统（DNS）服务，用于管理域名和路由流量。</p><h5 id="安全与身份管理："><a href="#安全与身份管理：" class="headerlink" title="安全与身份管理："></a>安全与身份管理：</h5><p>AWS IAM (Identity and Access Management)：身份和访问管理服务，用于管理用户、权限和资源访问。</p><p>Amazon Cognito：用于身份验证、授权和用户管理的服务。</p><h5 id="分析与大数据："><a href="#分析与大数据：" class="headerlink" title="分析与大数据："></a>分析与大数据：</h5><p>Amazon EMR (Elastic MapReduce)：大数据处理服务，支持Apache Hadoop、Spark等。</p><p>Amazon Athena：无服务器查询服务，用于分析S3中的数据。</p><p>Amazon Redshift Spectrum：扩展Redshift数据仓库，可以直接查询S3中的数据。</p><h5 id="人工智能与机器学习："><a href="#人工智能与机器学习：" class="headerlink" title="人工智能与机器学习："></a>人工智能与机器学习：</h5><p>Amazon SageMaker：用于构建、培训和部署机器学习模型的托管服务。</p><p>Amazon Rekognition：图像和视频分析服务，用于识别对象、人脸等。</p><p>Amazon Polly：文本转语音服务，可将文本转换为自然语音。</p><p>Amazon Lex：构建聊天机器人和语音交互应用的服务。</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><h5 id="AWS-CodeCommit："><a href="#AWS-CodeCommit：" class="headerlink" title="AWS CodeCommit："></a>AWS CodeCommit：</h5><p>提供托管的Git存储库，用于团队协作和版本控制。<br>可以将代码存储在私有存储库中，并管理代码的变更历史。</p><h5 id="AWS-CodeBuild："><a href="#AWS-CodeBuild：" class="headerlink" title="AWS CodeBuild："></a>AWS CodeBuild：</h5><p>托管的持续集成服务，用于构建、测试和打包应用程序。<br>自动执行构建过程，生成可部署的构建产物。</p><h5 id="AWS-CodeDeploy："><a href="#AWS-CodeDeploy：" class="headerlink" title="AWS CodeDeploy："></a>AWS CodeDeploy：</h5><p>自动化部署服务，用于将应用程序部署到不同的计算实例。<br>支持各种部署策略，如无停机部署、蓝绿部署等。</p><h5 id="AWS-CodePipeline："><a href="#AWS-CodePipeline：" class="headerlink" title="AWS CodePipeline："></a>AWS CodePipeline：</h5><p>托管的持续交付服务，用于创建、管理和自动化整个交付流程。<br>可以连接多个代码存储库、构建和部署服务，形成完整的交付流水线。</p><h5 id="AWS-CodeStar："><a href="#AWS-CodeStar：" class="headerlink" title="AWS CodeStar："></a>AWS CodeStar：</h5><p>为团队提供一站式的开发项目管理和协作工具。<br>集成了多个开发者工具，帮助您快速搭建、部署和管理应用。</p><h5 id="AWS-Cloud9："><a href="#AWS-Cloud9：" class="headerlink" title="AWS Cloud9："></a>AWS Cloud9：</h5><p>基于浏览器的集成开发环境（IDE），允许团队协作开发代码。<br>可以连接到远程服务器，编写、测试和调试代码。</p><h5 id="AWS-X-Ray："><a href="#AWS-X-Ray：" class="headerlink" title="AWS X-Ray："></a>AWS X-Ray：</h5><p>分布式应用程序性能分析服务，可帮助您识别和调试性能问题。<br>可以跟踪请求在不同服务之间的流动，并生成性能图表。</p><h5 id="AWS-Command-Line-Interface-CLI-："><a href="#AWS-Command-Line-Interface-CLI-：" class="headerlink" title="AWS Command Line Interface (CLI)："></a>AWS Command Line Interface (CLI)：</h5><p>命令行工具，使您能够通过命令管理AWS资源。<br>提供了丰富的命令和选项，用于自动化和管理任务。</p><h5 id="AWS-SAM-Serverless-Application-Model-："><a href="#AWS-SAM-Serverless-Application-Model-：" class="headerlink" title="AWS SAM (Serverless Application Model)："></a>AWS SAM (Serverless Application Model)：</h5><p>一种用于构建、测试和部署无服务器应用程序的开发框架。<br>基于CloudFormation，简化了无服务器应用程序的定义和部署。</p><h5 id="AWS-Amplify："><a href="#AWS-Amplify：" class="headerlink" title="AWS Amplify："></a>AWS Amplify：</h5><p>用于构建现代Web和移动应用程序的开发平台。<br>提供前端框架、托管、认证等功能，支持快速开发和部署。</p><h5 id="AWS的IDE和IDE工具包"><a href="#AWS的IDE和IDE工具包" class="headerlink" title="AWS的IDE和IDE工具包"></a>AWS的IDE和IDE工具包</h5><ul><li>AWS支持流行的集成开发环境（IDE）和IDE工具包提供支持，因此你可以在你的首选环境中在AWS上编写，调试和部署代码。</li></ul><h4 id="基础设施即代码（IaC）"><a href="#基础设施即代码（IaC）" class="headerlink" title="基础设施即代码（IaC）"></a>基础设施即代码（IaC）</h4><ul><li>AWS提供服务能够以编程，描述性和声明性的方式创建，部署和维护基础设施</li></ul><h5 id="AWS-CDK"><a href="#AWS-CDK" class="headerlink" title="AWS CDK"></a>AWS CDK</h5><ul><li><p>AWS云开发套件（AWS CDK）是一个软件开发框架，用于在代码中的定义云基础设施并通过AWS CloudFormation进行配置。CDK支持类似于TypeScript，JavaScript，Python，Java，C#/.Net和Go</p></li><li><p>配置云应用程序可能具有挑战性，需要编写自定义脚本，维护模板或学习特定于领域的语言。提供才成为构造的高级组件，可以使用经过验证的默认值预配置云资源，以便你可以轻松构建云应用程序。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230812151513189.png" alt="image-20230812151513189"></p><h4 id="AWS云形成"><a href="#AWS云形成" class="headerlink" title="AWS云形成"></a>AWS云形成</h4><ul><li>建模和设置AWS资源可能非常耗时，这就是AWS CloudFormation可以提供帮助的地方。CloudFormation帮助你建模和设置AWS资源，以便你可以花更少的时间管理资源，而将更多的时间专注于你的应用程序。创建模板后，CloudFormation会我为你预置这些资源。无需单独创建和配置AWS资源并且弄清楚哪些资源依赖哪些资源。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230812152841112.png" alt="image-20230812152841112"></p><h4 id="架构完善的基础设施"><a href="#架构完善的基础设施" class="headerlink" title="架构完善的基础设施"></a>架构完善的基础设施</h4><h5 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h5><ul><li>AWS Well-Architected可以帮助云架构和开发人员为各种应用程序和工作负载构建安全，高性能，弹性且高效的基础设施。AWS Well-Architected围绕六大支柱构建。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud Konwleage </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OceanBase</title>
      <link href="/2023/07/15/OceanBase/"/>
      <url>/2023/07/15/OceanBase/</url>
      
        <content type="html"><![CDATA[<h1 id="OceanBase"><a href="#OceanBase" class="headerlink" title="OceanBase"></a>OceanBase</h1><h2 id="传统集中式数据库面临的挑战"><a href="#传统集中式数据库面临的挑战" class="headerlink" title="传统集中式数据库面临的挑战"></a>传统集中式数据库面临的挑战</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230718091134287.png" alt="image-20230718091134287"></p><ul><li>可扩展性方面：传统集中式数据库的扩展性有限，当数据量增加或者并发访问量增大时，集中式数据库可能无法提供足够的性能和吞吐量</li><li>单点故障：由于集中式数据库只有一个中心节点，一旦该节点发生故障，整个系统将无法正常工作。这种单点故障可能导致系统可用性和数据的丢失</li><li>单点上限：在一个数据库系统中，单个节点能够处理的最大负载或并发连接数。通常由硬件资源以及数据库软件本身的性能限制所决定的，</li><li>数据库安全：传统型集中式数据库存储所有数据的中心节点成为攻击者的目标，一旦该节点被入侵或者遭受到其他安全威胁，整个数据库的数据会面临泄露和篡改的风险</li><li>数据一致性：由于集中式数据库的数据存储都在一个节点上，当多个用户同时对数据库进行操作时，可能会出现数据一致性的问题。例如，当一个用户在修改某个数据时，另一个用户可能正在读取该数据，导致读取的数据不一致</li><li>高延迟：远程用户在访问数据库时，可能会出现高延迟，这对于要低延迟响应的应用场景是不可接受的。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230718094411164.png" alt="image-20230718094411164"></p><h3 id="数据库分布规则"><a href="#数据库分布规则" class="headerlink" title="数据库分布规则"></a>数据库分布规则</h3><ul><li>是指分布式数据库系统中，决定怎么将数据分散到不同节点上，实现分布式存储和访问。</li></ul><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul><li>将数据划分成多个片段，每个片段存储在不同的节点上。分片规则可以基于数据的某个属性进行划分，例如按照用户ID进行哈希分片或按照地理位置进行范围分片<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4></li><li>将数据复制到多个节点上以提高数据的可用性和容错性。复制规则可以确定数据的副本数量，复制的同步方式以及副本的位置选择策略<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4></li><li>根据查询或操作的条件将请求路由到正确的节点上。路由规则可以基于数据的分片键或其他属性进行路由决策的，以确保操作在正确的节点上执行。<h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4></li><li>在节点的增加，减少或数据重平衡时，如何将数据从一个节点迁移到另一个节点上，以保持数据的均衡和一致性。<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3></li><li>使用通用数据库，可以实现数据库线性的扩容</li><li>数据库是单点数据库，数据库之间没有联系，不知道其他数据库的存在，依靠中间件完成需要跨库的事务</li><li>数据库中间件连接各个数据库，实现分库分表</li></ul><p>需要注意的是单中间件整合各个数据库时候，倘若该数据库服务器时间戳不一致的时候可能会导致数据不一致的问题，可能在数据同步阶段的时候不同服务器操作时间戳或早或晚可能会被视为未来操作或者视为过时操作会丢失数据。</p><p>解决上面的问题，能够使用专门统一数据库服务器的时间的服务器或者建立时间戳校验机制，或者定期校准时间戳。</p><h4 id="非短板"><a href="#非短板" class="headerlink" title="非短板"></a>非短板</h4><ul><li>能过通过线性扩展来达到分库分表，可以快速实现数据库的水平扩展；</li><li>技术成本较低，不需要改造核心数据库引擎，或者只需要做很少的改造；</li></ul><h4 id="短板"><a href="#短板" class="headerlink" title="短板"></a>短板</h4><ul><li>跨库分布式事物，数据库核心引擎没有分布式能力，只能通过中间件来完成分布式处理，但中间件很难做到RPO = 0，因此在遇到异常和故障时无法100%保证分布式事务的ACID能力</li><li>全局一致性，由于多个数据库服务器的时间戳不一致，因此很难保证多个库之间数据版本号的全局性一致</li><li>负载均衡，在扩容和缩容时候，底层数据库引擎无法在线调整数据分布规则，因此需要暂停业务并重新导数据，对业务和运维挑战很大；</li><li>跨库复杂SQL，跨库的复杂SQL运算，只能要求中间件能够完成，而中间件不具备分布式并行计算能力，最终会限制应用对SQL的使用，产生业务侵入性。</li></ul><h2 id="原生的分布式关系型数据库架构"><a href="#原生的分布式关系型数据库架构" class="headerlink" title="原生的分布式关系型数据库架构"></a>原生的分布式关系型数据库架构</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910195837934.png" alt="image-20230910195837934"></p><ul><li>一种新型的数据库架构，能更好的处理大规模数据，并具有高并发，高可用，高扩展等特点。</li></ul><h3 id="数据高可靠，服务高可用"><a href="#数据高可靠，服务高可用" class="headerlink" title="数据高可靠，服务高可用"></a>数据高可靠，服务高可用</h3><ul><li>多副本一致性Paxos，个别节点发生故障时，保证数据零丢失和服务快速恢复。</li></ul><h4 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h4><ul><li>一种解决分布式系统中的一致性问题的协议，保证系统中多个副本在面对网络延迟，分区，信息丢失等问题时。</li></ul><h5 id="Prepare阶段"><a href="#Prepare阶段" class="headerlink" title="Prepare阶段"></a>Prepare阶段</h5><ol><li>Paxos提议者会向一组接受者发送一个提议，改提议包含一个提议编号和提议内容。</li><li>接受者会在接收到提议后，如果该提议的编号是其所接收过的所有提议中最大的，那么它就会接受这个提议，并将自己之前接受的最大编号的提议回复给提议者。</li></ol><h5 id="Accept阶段"><a href="#Accept阶段" class="headerlink" title="Accept阶段"></a>Accept阶段</h5><ol><li>议者会根据Prepare阶段的回复，选择一个提议内容，然后再次向接受者发送提议，该提议包含了在Prepare阶段中提出的提议编号和选定的提议内容。</li><li>接受者在接收到提议后，如果该提议的编号仍然是其所接收过的所有提议中最大的，那么它就会接受这个提议。</li></ol><h3 id="线性扩容"><a href="#线性扩容" class="headerlink" title="线性扩容"></a>线性扩容</h3><ul><li>指随着硬件资源的增加，数据库的处理能力或存储能力能够线性增长。</li><li>线性扩容的好处是可以让系统在面对业务增长时，能够通过简单地扩展硬件资源来满足业务需求，而无需对系统的架构进行大的修改。</li><li>实现线性扩容，需要数据库系统具有良好的分布式架构，包括数据分片、负载均衡、分布式事务处理等能力。同时，也需要数据库系统能够有效地管理和调度各个节点的资源，以确保资源的充分利用。</li></ul><h3 id="全局一致性"><a href="#全局一致性" class="headerlink" title="全局一致性"></a>全局一致性</h3><ul><li>支持分布式事务，确保全局一致性，无需使用高端小型机和存储</li></ul><h3 id="对业务透明"><a href="#对业务透明" class="headerlink" title="对业务透明"></a>对业务透明</h3><ul><li>可以像使用单点数据库一样使用分布式数据库，业务迁移改造成本低。</li></ul><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><h5 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h5><ul><li>范围分片（按照某个字段）</li><li>哈希分片（通过哈希函数将数据均匀分布到各个节点）</li><li>列表分片（根据列表中定义的值将数据分布到各个节点）<h5 id="分片键"><a href="#分片键" class="headerlink" title="分片键"></a>分片键</h5></li><li>分片键是确定数据分布到哪个分片的关键。通常，分片键应该选择能够使数据均匀分布到各个分片的字段<h5 id="数据均匀分布"><a href="#数据均匀分布" class="headerlink" title="数据均匀分布"></a>数据均匀分布</h5></li><li>为了提高系统的性能和可用性，需要尽可能地使数据均匀分布到各个分片。如果数据在分片之间的分布不均匀，可能会导致某些节点过载，而其他节点闲置，这被称为”数据倾斜”<h5 id="数据迁移-1"><a href="#数据迁移-1" class="headerlink" title="数据迁移"></a>数据迁移</h5></li><li>当添加或删除节点时，需要重新分配数据，这被称为数据迁移。数据迁移是一个复杂的过程，需要在保证数据完整性和服务可用性的同时进行。<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4></li><li>支持分布式事务，保证数据的一致性，通常通过两阶段提交（2PC）或 三阶段提交（3PC）等协议来实现。<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4></li><li>为了提高数据的可用性和容错性，原生分布式关系型数据库会将数据复制到多个节点。如果某个节点发生故障，可以从其他节点获取数据。<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4></li><li>原生分布式关系型数据库需要支持负载均衡，以保证系统的性能。这通常通过分布式哈希、一致性哈希等算法来实现。<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4></li><li>在分布式系统中，节点故障是常见的问题。原生分布式关系型数据库需要支持故障恢复，以保证系统的持续运行。</li></ul><h4 id="弹性扩展"><a href="#弹性扩展" class="headerlink" title="弹性扩展"></a>弹性扩展</h4><ul><li>需要支持弹性扩展，即可以根据需要动态增加或减少节点。</li></ul><h2 id="OceanBase-1"><a href="#OceanBase-1" class="headerlink" title="OceanBase"></a>OceanBase</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910205750757.png" alt="image-20230910205750757"></p><h4 id="多种部署方式"><a href="#多种部署方式" class="headerlink" title="多种部署方式"></a>多种部署方式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910205925780.png" alt="image-20230910205925780"><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910210114199.png" alt="image-20230910210114199"> </p><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910211314030.png" alt="image-20230910211314030"></p><ul><li><p>OceanBase是蚂蚁金服完全自主研发的通用的分布式关系型数据库。OceanBase以集群的形式存在，至少三个节点分布在三个区域（Zone），每个节点上运行一个单进程程序，进程名observer。每个observer进程都包含连个模块：SQL引擎和存储引擎，所以每个节点地位基本是平等的。稍微特殊的是每个Zone里会有一个节点的observer内还会运行总控服务，三个总控服务内容一样，角色上会有一个Leader和Follower，只有Leader提供服务。</p></li><li><p>OceanBase集群还支持多租户管理</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230719094326659.png" alt="image-20230719094326659"></p></li></ul><h4 id="RootService总控服务（RS）"><a href="#RootService总控服务（RS）" class="headerlink" title="RootService总控服务（RS）"></a>RootService总控服务（RS）</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910215101839.png" alt="image-20230910215101839"></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>OceanBase的数据存在每个节点上，observer通过分区管理数据。分区是数据的子集，一个非分区就是一个分区，一个分区表包含多个分区，一个分区不能跨节点，分区表的不同分区可以跨节点。所以分区表可以做水平跨节点扩展。分区是数据的子集，是高可用的最小粒度。分析OceanBase是否丢数据，只要分析分区的数据写是否会丢。</p><h4 id="读写模式"><a href="#读写模式" class="headerlink" title="读写模式"></a>读写模式</h4><ul><li>OceanBase在初次读入一行数据时会将该行所在块读入到内存的Block Cache中，后面修改的时候并不是直接修改这个block，而是在另外一块内存中分配少量空间记录这笔修改，并且只记录变化部分，这称为增量数据（Memtable）。前面在Block Cache里的数据称为基线数据。同一记录如果反复修改多次，多个增量会议链表形式挂在该记录下</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230719095139281.png" alt="image-20230719095139281"></p><p>OceanBase的这种方式能够比传统数据库产生的脏块要小得多，所以OceanBase会把这些Memtable一直保存在缓存中或者推迟写入磁盘。当最后落盘的时候，Memtable会冻结成历史版本，然后和对应的基线数据在内存中进行合并，生成SSTable格式写入磁盘数据文件。合并的操作对资源有较大的影响，所以会在尽可能推迟合并操作到低峰期。若专门用户Memtable的内存利用率达到了一定的阈值，它会将Memtable直接以SSTable格式临时写入磁盘中。这就是转储的操作，相对对资源消耗比较小。</p><h4 id="多个资源池（Resource-Pool）"><a href="#多个资源池（Resource-Pool）" class="headerlink" title="多个资源池（Resource Pool）"></a>多个资源池（Resource Pool）</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910215905310.png" alt="image-20230910215905310"></p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>OceanBase的Memtable一天只落盘一次，但是记录Memtable的时候OceanBase会遵循WAL机制，生成相关的事务日志保存在日志缓冲区里。和Oracle不同的是OceanBase的这些事务日志在事务提交之前会一直在日志缓冲区里，若节点宕机，没提交的事务日志对业务来说也没有数据丢失，当提交后，OceanBase会做事务日志的持久化动作。所以可能对于一些大事务会占用不少的内存空间。而且OceanBase是没有Undo，假设业务事务回滚了，它只会有一些清理逻辑。</p><h4 id="宕机恢复"><a href="#宕机恢复" class="headerlink" title="宕机恢复"></a>宕机恢复</h4><p>OceanBase的节点宕机后，节点上部分分区的访问会受影响，但OceanBase集群会很快恢复这些分区访问，这是OceanBase的可用性特性。和传统数据库一样，宕机后恢复，它会读取事务日志，重做事务，但在不同在于observer不需要再次读入基线数据，只需要在事务日志在增量内存中构建相关分区的Memtable。相关分区被业务读取时，对应的基线数据所在块才会被再次读入Block Cache中。</p><h4 id="副本复制"><a href="#副本复制" class="headerlink" title="副本复制"></a>副本复制</h4><ul><li>Oracle一样，光支持WAL是不足以保障数据安全，OceanBase还要设法保障事务日志的可靠性。除了使用DirectIO持久化到本节点磁盘外，也需要持久化到其他节点上。</li><li>跟传统关系数据库主备两副本架构不一样，OceanBase选择了多副本架构，是如果副本数是偶数，会有传统双机房容灾的脑裂问题。脑裂问题的本质就是全体成员在局部通信中断故障时无法就哪个节点接管服务作出一致性决议。成员数是奇数，才有可能形成多数派。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230719104329304.png" alt="image-20230719104329304"></p><p>副本就是分区的别称，一个分区有三份数据，每份是一个副本。副本的内容除了数据还有事务日志。在这里我们只关心事务日志部分。三个副本在角色上是1个Leader（类似于主副本）2个Follower（类似于备副本）。只有Leader副本才会对外提供读写服务，这样就规避了单个分区多个节点同时写入的问题。但是注意每个分区只能单点写入跟OceanBase集群多个节点写入并不矛盾。因为Leader副本是可以分散到所有节点（OBServer）上。跟传统关系数据库一样，OceanBase维持三副本数据的同步是靠传输事务日志（Redo）机制实现的。</p><p>所以，为了保障事务日志的可靠性，OceanBase要把Leader副本上的事务日志持久化到本机和其他两个Follower副本上。宏观上表现就是可能存在各个节点彼此互相传输事务日志。这个跟MySQL的Master-Master架构里双向复制并不完全一样。 我们重点看看OceanBase如何认定事务日志可靠了。</p><p>使用Paxos协议，各个副本成员就事务日志持久化到磁盘进行表决。只要一半以上成员投票OK，Leader副本上的事务就可以继续提交了，Follower副本才开始应用Redo。这个协议是强制性约束，不够一半成员就会表决失败，Leader副本上事务就会回滚。这里没有类似Oracle或者MySQL的同步降级的做法。此外，剩余少数派成员最终也是要表决成功的，否则就是一个异常状态。</p><p>OceanBase会尽力自动去保障三副本成员状态的正常，否则就会告警等运维处理。这点也是强制性的约束，也是跟传统关系数据库不一样的地方。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h4 id="分布性"><a href="#分布性" class="headerlink" title="分布性"></a>分布性</h4><ul><li>集群形式部署，支持水平扩展</li><li>在线扩容/缩容，自动负载均衡</li><li>跨机房/城市部署，容灾/多活</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul><li>基于Paxos协议，强一致性同步</li><li>少数副本故障，数据不丢，服务自动回复</li></ul><h4 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h4><ul><li>按需分配实例，即时创建和销毁</li><li>在线扩容/缩容</li><li>租户之间资源隔离</li></ul><h4 id="高兼容"><a href="#高兼容" class="headerlink" title="高兼容"></a>高兼容</h4><ul><li>Oracle/MySQL两种兼容模式</li><li>数据平滑迁移</li><li>原生的SQL和事物引擎</li></ul><h2 id="集群技术架构"><a href="#集群技术架构" class="headerlink" title="集群技术架构"></a>集群技术架构</h2><h3 id="Paxos协议与负载均衡"><a href="#Paxos协议与负载均衡" class="headerlink" title="Paxos协议与负载均衡"></a>Paxos协议与负载均衡</h3><h4 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h4><ul><li>当一个表很大，能够水平拆分为若干分区，每个分区包含表的若干记录。根据行数据到分区的映射关系不同，分为hash分区，List分区，range分区</li><li>每个分区还能过通过不同维度再分，称为二级分区</li><li>分区是OceanBase数据架构的基本单元，传统数据库的分区表在分布式系统上实现</li></ul><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><ul><li>为数据安全和高可用的数据服务，分区的数据在物理层面上会存储多份，每一份叫做分区的一个副本</li><li>副本根据负载和特定的策略，由系统自动调度分散在多个Server上。副本支持迁移，复制，增删，类型转换等管理操作</li></ul><h5 id="副本构成"><a href="#副本构成" class="headerlink" title="副本构成"></a>副本构成</h5><p>副本构成由记录事务的日志，存储再内存的Memtable，磁盘上的静态数据SSTable</p><h5 id="副本类型"><a href="#副本类型" class="headerlink" title="副本类型"></a>副本类型</h5><ul><li>一个分区在一个zone中最多由一个全功能或日志型副本</li><li>只读型副本在同一个zone可以有多个<h6 id="全能型副本"><a href="#全能型副本" class="headerlink" title="全能型副本"></a>全能型副本</h6>拥有事务日志，MemTable和SSTable等全部完整的数据和功能，它可以随时快速切换为leader对外提供服务。<h6 id="日志型副本"><a href="#日志型副本" class="headerlink" title="日志型副本"></a>日志型副本</h6>只包含日志的副本，没有Memtable和SSTable。它参与日志投票并对外提供日志服务，可以参与其他副本的恢复，但子集不能变为主提供数据库服务。因为日志型副本所消耗的物理资源更少，它可以有效降低最后副本机器的成本，降低集群的总体成本<h6 id="只读型副本"><a href="#只读型副本" class="headerlink" title="只读型副本"></a>只读型副本</h6>包含完整的日志，MemTable和SSTable等，但是它的日志比较特殊。它不作为paxos成员参与日志的投票，而是作为一个观察者实时追赶paxos成员的日志，并在本地回放。可以在业务读取数据的一致性要求不高的时候，提供只读服务。因其不加入paxos成员组，又不会造成投票成员增加导致事务提交延时的增加</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230721195400362.png" alt="image-20230721195400362"></p><p>如上图，按照ID分为三个hash分区，每个分区再按照交易时间分为四个二级的range分区，然后会生成多份副本，副本数量会因集群数量而变化，一般来说会每个zone内只会包含一个副本</p><h4 id="多副本一致性协议"><a href="#多副本一致性协议" class="headerlink" title="多副本一致性协议"></a>多副本一致性协议</h4><h5 id="以分区为单位组建Paxos协议组"><a href="#以分区为单位组建Paxos协议组" class="headerlink" title="以分区为单位组建Paxos协议组"></a>以分区为单位组建Paxos协议组</h5><p>每个分区都有多份副本（Replica），自动建立Paxos组，在分区级用多副本保证数据可靠性和服务高可用，数据管理更加灵活方便</p><h5 id="自动选举主副本"><a href="#自动选举主副本" class="headerlink" title="自动选举主副本"></a>自动选举主副本</h5><p>OB自动生成多份副本，多副本自动选举主副本，主副本提供服务</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230721224526185.png" alt="image-20230721224526185"></p><h4 id="自动负载均衡与智能路由"><a href="#自动负载均衡与智能路由" class="headerlink" title="自动负载均衡与智能路由"></a>自动负载均衡与智能路由</h4><h5 id="自动负载均衡"><a href="#自动负载均衡" class="headerlink" title="自动负载均衡"></a>自动负载均衡</h5><p>主副本均匀打散到各个服务器中，使得各个服务器都能承载业务流量</p><h5 id="OB-Server相互独立"><a href="#OB-Server相互独立" class="headerlink" title="OB Server相互独立"></a>OB Server相互独立</h5><p>每台OB Server均可以独立执行SQL，如果应用需要访问的数据不同机器上，OB Server自动将请求路由至数据所在机器，对业务完全透明。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230721225131923.png" alt="image-20230721225131923"></p><h4 id="多副本同步Redo-Log-确保数据持久化"><a href="#多副本同步Redo-Log-确保数据持久化" class="headerlink" title="多副本同步Redo Log 确保数据持久化"></a>多副本同步Redo Log 确保数据持久化</h4><ul><li>Paxos组成员通过Redo-Log的多数派强同步确保数据的持久化</li><li>Leader无需等待所有Follower的反馈，多数派完成同步即可向应用反馈成功</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724153630019.png" alt="image-20230724153630019"></p><ol><li>应用写数据到P2分区。Zone2-OB Server1的P2为主副本（Leader），承接业务需求。</li><li>将Redo-Log同步请求发送到Zone1-OB Server1和Zone3-OB Server1中的P2从副本（Follower）；</li><li>任何一个Follower完成Redo-Log落盘并将响应返回给Leader后，Leader即认为Redo-Log完成强同步，无需再等待其他Follower的反馈；</li><li>Leader反馈应用操作完成。</li></ol><h4 id="智能路由服务，应用透明访问"><a href="#智能路由服务，应用透明访问" class="headerlink" title="智能路由服务，应用透明访问"></a>智能路由服务，应用透明访问</h4><h5 id="高效路由转发"><a href="#高效路由转发" class="headerlink" title="高效路由转发"></a>高效路由转发</h5><ul><li>对SQL做基本解析，确定对应Leader所在机器；</li><li>反向代理，将请求路由至对应Leader；Leader位置无法确定时随机选择OB Server；</li><li>轻量SQL解析 + 快速转发，保证高性能，单OB Proxy每秒转发百万次请求。</li></ul><h5 id="“非”计算节点，无状态"><a href="#“非”计算节点，无状态" class="headerlink" title="“非”计算节点，无状态"></a>“非”计算节点，无状态</h5><ul><li>每个OB Proxy是一个“无状态”的服务进程，不做数据持久化，对部署位置无要求；</li><li>OB Proxy不参与数据库引擎的计算任务，不参与事务处理；</li><li>多个OB Proxy之间无联系，可通过F5/SLB组成负载均衡集群；</li><li>不需要独立服务器，可以与OB Server共用一台服务器，如果应用对实时性要求高，也可以将OB Proxy部署到应用服务器中。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724160743540.png" alt="image-20230724160743540"></p><p>OB Proxy的故障是不会影响事务的功能，事务，持久化，落盘基本是由OB Server来完成。</p><h4 id="设置Primary-Zone，业务汇聚到特定Zone"><a href="#设置Primary-Zone，业务汇聚到特定Zone" class="headerlink" title="设置Primary Zone，业务汇聚到特定Zone"></a>设置Primary Zone，业务汇聚到特定Zone</h4><p>通过为不同的租户配置不同的Primary Zone，可以将业务流量集中到若干Zone中，减少跨Zone以及服务器的操作。Zone List，逗号两侧优先级相同，分号左侧优先级高于右侧</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724161140837.png" alt="image-20230724161140837"></p><h4 id="Primary-Zone有租户，数据库和表不同的级别。"><a href="#Primary-Zone有租户，数据库和表不同的级别。" class="headerlink" title="Primary Zone有租户，数据库和表不同的级别。"></a>Primary Zone有租户，数据库和表不同的级别。</h4><ul><li>如无特殊指定，自动继承上级对象的Primary_zone:database继承租户的primary_zone设置，table继承database的primary_zone设置。</li><li>database和table可以指定各自的primary_zone，不必和上一级对象的设置保持一致；提供更加灵活的负载均衡策略。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724162242300.png" alt="image-20230724162242300"></p><h4 id="Table-Group-将多个表的相同分区ID的主副本聚集在一个OB-Server中，减少分布式事务引入的开销"><a href="#Table-Group-将多个表的相同分区ID的主副本聚集在一个OB-Server中，减少分布式事务引入的开销" class="headerlink" title="Table Group,将多个表的相同分区ID的主副本聚集在一个OB Server中，减少分布式事务引入的开销"></a>Table Group,将多个表的相同分区ID的主副本聚集在一个OB Server中，减少分布式事务引入的开销</h4><ul><li>如果多个表的分区方式完全相同（分区类型，分区键个数，分区数量等），可以在逻辑上将这些表归属到同一个Table Group中，以影响动态负载均衡的策略</li><li>同一个Table Group中的所有表，分区ID（partition_id） 相同的所有分区，他们的leader在同一个observer上：在不影响全局负载均衡的前提下，可有效减少分布式事务引入的跨机访问开销。</li><li>如果负载均衡被打破（服务器故障后，扩容缩容等），Table Group中的所有表会作为一个整体来调整分区分布和Leader分布</li><li>动态创建和删除，并且对上层应用完全透明。</li><li>如果租户的unit_num=1 且 primary_zone只有一个zone，不需要tablegroup。</li></ul><p>RDS实例，mysql扩容主备切换，ELR提前解行锁.。。。。。持续更新学习中………</p><h2 id="OBCA模拟题库"><a href="#OBCA模拟题库" class="headerlink" title="OBCA模拟题库"></a>OBCA模拟题库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【判断题】分库分表的架构虽然解决了集中式数据库的扩展性问题，但也带来了新的问题(不支持复杂SQL， 较难保证分布式事务的ACID等) 。T</span><br><span class="line">【判断题】TPC-C就是一个跑分测试， 没有什么规则限制,只要能跑高分就行 F</span><br><span class="line">【判断题】Ocean Base数据库是在阿里和蚂蚁内部孵化了10年后才逐步推广到外部市场的。T</span><br><span class="line">【判断题】Ocean Base数据库是基于开源数据库的再发行产品。 F</span><br><span class="line">【判断题】Ocean Base已发布到阿里云公有云及专有云中。 T</span><br><span class="line">【判断题】Ocean Base只支持X 86架构的CPU， 不支持国产CPU(如鲲鹏、海光、飞腾等) F</span><br><span class="line">【判断题】Zone是个逻辑概念， 是给集群内的一批机器打上同一个tag， 属于同一个tag的服务器归属一个Zone。T</span><br><span class="line">【判断题】Zone可以对应不同的城市， 或者一个城市的不同机房， 或者一个机房的不同机架。 T</span><br><span class="line">【判断题】租户的资源池一旦创建完成，就不可改变。 F</span><br><span class="line">【判断题】分区的副本只包含硬盘上的静态数据(S STable) ， 不包括Mem Table数据和日志数据。 F</span><br><span class="line">【判断题】主副本只能打散到所有Zone内， 不能聚焦到一个Zone内 F</span><br><span class="line">【判断题】每台OBServer是相对独立的， 都有自己独立的SQL引擎， 如果应用需要的数据不在当前OBServer上， 该OB&lt;br&gt;Server将协调其他OBServer的数据， 统一反馈给应用， 这个过程对应用是透明的。 T</span><br><span class="line">【判断题】主副本通过同步Redo-Log日志的方式实现可靠性， 主副本需要收到所有从副本落盘成功的消息后才能响应应用。 F</span><br><span class="line">【判断题】企业在一个城市有2个机房， 将2个Zone部署到1个机房中， 将另一个Zone部署到另一个机房中， 可以提供机房级的容灾。 F</span><br><span class="line">【判断题】 Ocean Base可以支持在一个集群中同时支持MySQL租户和Oracle租户。 T</span><br><span class="line">【判断题】使用Explain命令查看SQL执行计划时， SQL也会真正执行。 F</span><br><span class="line">【判断题】合井必须依赖Ocean Base自动完成， 无法手工启动合并。 F</span><br><span class="line">【判断题】Ocean Base的数据在磁盘中按主键有序排列。 T</span><br><span class="line">【判断题】会话变量只对当前会话生效，不影响该租户下的其他会话。 T</span><br><span class="line">【判断题】Global级(租户级) 变量修改后， 对当前已经打开的session也依然生效。 F</span><br><span class="line">【判断题】如果同时存在集群级别参数和租户级别参数，那么集群级别参数将覆盖租户级别参数。 T</span><br><span class="line"></span><br><span class="line">【多选题】传统的集中式关系型数据库面临哪些挑战? AC</span><br><span class="line">A：成本高：运行在高端服务器、小型机、高端存储等专有硬件上；</span><br><span class="line">B：生态欠缺：文档、培训、应用等都不足；</span><br><span class="line">C：扩展性差：无法摆脱单机的架构，只能纵向扩展，无法横向扩展；</span><br><span class="line">D：性能差：任何时候，传统集中式数据库的性能都比分布式数据库较差；</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base的核心特性有哪些? ABCD</span><br><span class="line">A：高扩展，可以使用普通的PC服务器进行横向扩展；</span><br><span class="line">B：高性能，峰值峰值6，100万次/秒，单表最大3，200亿行；</span><br><span class="line">C：高可用， 通过Paxos协议保证强一致性， RPO=0， R TO&lt;30秒；</span><br><span class="line">D：高兼容， 支持MySQL及Oracle两种模式， 降低业务迁移改造成本；</span><br><span class="line">E：高成本，使用小型机、高端存储等专有硬件；</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base主要有哪些产品组成? ABCD</span><br><span class="line">A：数据库内核：提供SQL引擎及存储引擎， 同时兼容MySQL和Oracle模式； 使用Paxos协议确保高可用性；</span><br><span class="line">B：OCP云管理平台：给管理员提供的管理工具， 提供集群管理、Zone管理、租户管理等功能；</span><br><span class="line">C：OMS数据迁移工具：提供基线数据和增量数据的同步功能， 可以从数据仓库订阅数据链路、从异构数据库迁移数据；</span><br><span class="line">D：ODC开发者中心：提供数据库日常开发、SQL诊断、会话管理及数据导入导出能功能。</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base支持哪些事务隔离级别 BC</span><br><span class="line">A：脏读 </span><br><span class="line">B：Read-Committed </span><br><span class="line">C：Serializable</span><br><span class="line"></span><br><span class="line">【多选题】以下对OB Proxy的描述是正确的  AD</span><br><span class="line">A：OB Proxy位于应用和OBServer之间， 将应用的请求路由到合适的OBServer；</span><br><span class="line">B：OB Proxy需要部署到一台独立的服务器上， 以保证其性能要求；</span><br><span class="line">C：OB Proxy参与数据库引擎的计算任务以及事务处理；</span><br><span class="line">D：OB Proxy是一个“无状态”的服务进程， 不做数据持久化</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base备份恢复业务支持哪些存储介质  AD</span><br><span class="line">A：NFS B：IP-SAN C：FC-SAN D：阿里云OSS</span><br><span class="line"></span><br><span class="line">【多选题】参数有哪两个级别?  AD</span><br><span class="line">A：集群级</span><br><span class="line">B：Zone级</span><br><span class="line">C：OBServer级</span><br><span class="line">D：租户级</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base是一个什么类型的数据库  C</span><br><span class="line">A：集中式数据库；</span><br><span class="line">B：No SQL数据库；</span><br><span class="line">C：分布式关系型数据库；</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base是一个集群， 以下哪个组件管理整个集群， 支持全局DDL、集群数据合并等功能。  B</span><br><span class="line">A：OB Proxy</span><br><span class="line">B：Root Service总控服务</span><br><span class="line">C：OCP管理平台 </span><br><span class="line">D：ODC开发者中心</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base集群可以同时支持MySQL和Oracle的租户， 哪个黑屏工具可以连接到Oracle租户  A</span><br><span class="line">A：Ocean Base客户端；</span><br><span class="line">B：标准MySQL客户端</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base不支持什么操作系统  B</span><br><span class="line">A：CentOS； </span><br><span class="line">B：Windows </span><br><span class="line">C：中标麒麟</span><br><span class="line">D：银河麒麟</span><br><span class="line"></span><br><span class="line">【单选题】如果一个Ocean Base集群有3个Zone， 每个Zone有5台OBSer er。那么一个分区有几份副本呢?  B</span><br><span class="line">A：10 B：3 C：6 D：5</span><br><span class="line"></span><br><span class="line">【单选题】如果一个集群有3个Zone， 每个Zone有5台OBServer。一个租户对应的资源池的Unit eNum=3， 最终该集群有多少个服务器中有该租户的资源单元呢?  B</span><br><span class="line">A： 15 B：9 C：45 D：30</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base是以() 为单位组建Paxos协议组。  D</span><br><span class="line">A：租户 B：数据库 C：表 D：分区</span><br><span class="line"></span><br><span class="line">【单选题】以下关于Ocean Base扩容和缩容描述正确的是。  C</span><br><span class="line">A：需要管理员停止业务 </span><br><span class="line">B：需要业务做一定的修改</span><br><span class="line">C：支持动态扩容和缩容，对业务无感知</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base使用两阶段提交协议保证事务的原子性， 在两阶段提交协议中， 谁是协调者呢?  B</span><br><span class="line">A：OB Proxy </span><br><span class="line">B：OBServer</span><br><span class="line">C：Root Service总控服务</span><br><span class="line">D：OCP云管理平台</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base使用哪种技术解决了读写互斥的问题。  A</span><br><span class="line">A：MVCC</span><br><span class="line">B：Paxos协议</span><br><span class="line">C：全局快照</span><br><span class="line">D：互斥锁</span><br><span class="line"></span><br><span class="line">单选题】使用JDBC连接Oracle租户时， 需要使用哪种JDBC驱动。  C</span><br><span class="line">A：MySQL标准的JDBC驱动</span><br><span class="line">B：Oracle标准的JDBC驱动</span><br><span class="line">C：Ocean Base自己开发的JDBC驱动</span><br><span class="line"></span><br><span class="line">【单选题】为了达到更好的压缩效果， Ocean Base一般会进行进行几次压缩  B</span><br><span class="line">A：1次 B：2次 C：3次 D：4次</span><br><span class="line"></span><br><span class="line">【单选题】mini freeze是简单的dump操作， 多个mini freeze的数据会(  )合并； 多个minor freeze会(  ) 合并， 但不会和S STable合并。  B</span><br><span class="line">A：实时、异步</span><br><span class="line">B：异步、实时</span><br><span class="line">C：实时、离散</span><br><span class="line">D：离散、实时</span><br><span class="line"></span><br><span class="line">【单选题】 Alter system命令可以修改集群参数和租户参数， 如该命令指定Zone或者OBServer， 最多可以同时指定几个?  A</span><br><span class="line">A：1个 B：2个C：3个D：4个</span><br><span class="line"></span><br><span class="line">【单选题】通过哪个命令可以查询参数的属性。  A</span><br><span class="line">A：show parameters like&#x27;%&lt;pattern&gt;%&#x27;；</span><br><span class="line">B：alter system set&lt;name&gt;=&lt;value&gt;；</span><br><span class="line">C：show variables like&#x27;%&lt;pattern&gt;%&#x27;；</span><br><span class="line">D：set@@global.&lt;name&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">【单选题】以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控告警等功能?  B</span><br><span class="line">A：ODC开发者中心 </span><br><span class="line">B：OCP云管理平台</span><br><span class="line">C：OB Proxy </span><br><span class="line">D：OBServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">判断：</span><br><span class="line">1.一个租户在同一个 Server 上可以有一个或多个资源单元 UNIT   错误</span><br><span class="line">2.创建资源单元仅仅指定  CPU、MEMORY 参数即可，无需指定 OPS、DISK_SIZE、SESSION_NUM参数  错误</span><br><span class="line">3.OCEANBASE 在少数副本不可用的情况下，可以实现 RPO=0,RTO&lt;30 秒    正确</span><br><span class="line">4.Zone 可以对应不同的城市，或者一个城市的不同机房、或者一个机房的不同机架，以实现不同级别的容灾   正确</span><br><span class="line">5.主副本只能打散到所有 Zone 内，实现访问流量的负载均衡，不能将主副本聚焦到一个Zone内。   错误</span><br><span class="line">6.扩容服务器加入集群后，集群会基于负载均衡的策略，将主副本及从副本迁移到扩容服务器中，以实现整体的负载均衡    正确</span><br><span class="line">7.租户逻辑上类似传统数据库实例，创建完成后，每个租户都拥有自己的专属进程     正确</span><br><span class="line">8.OceanBase 的 Paxos 协议，不同于传统的主备库或者双选方案，可以彻底规避在容灾场景下的脑裂问题（也就是同时又两个主数据库的场景）     正确</span><br><span class="line">9.修改资源池可以实现租户的另一种扩容/缩容的方式，比如在每个 zone 中增加/减少节</span><br><span class="line">点数量，可以通过修改资源池的 unit_num 来实现   正确</span><br><span class="line">10.创建租户时，需要指定租户类型为 Oracle 租户或者 MYSQL 租户，以满足不同开发者的需求。   正确</span><br><span class="line">11.同一个资源单元定义 unit cofig(比如 2C8G，或者 4C16G 等)，可以被多个资源池使用。   错误</span><br><span class="line"></span><br><span class="line">多选：</span><br><span class="line"></span><br><span class="line">1.OMS 实时同步工具是异构数据库迁移到 OceanBase 的利器，OMS 支持哪些功： BCDE</span><br><span class="line">A:支持会话管理和系统全局变量的可视化修改，用户记忆变量的难度</span><br><span class="line">B:支持多种类型数据源，支持包括 Oracle、MYSQL、DB2、OceanBase 等数据库到</span><br><span class="line">OceanBase 的全量迁移和增量实时数据同步</span><br><span class="line">C:一站式交互，数据迁移全生命周期管理，数据迁移的创建、配置和监控都在管控界面上连贯操作完成，交互简便</span><br><span class="line">D：兼容性评估和改造：异构数据迁移 OceanBase 的对象兼容性评估和改写建议，极大降低业务迁移的门槛和业务改造的难度。</span><br><span class="line">E:多重数据校验：提供多种方式校验的保护。要更加全面、省时、高效地保证数据质量</span><br><span class="line"></span><br><span class="line">2.关于 OceanBase 的 Zone，以下说法正确的是CDEF </span><br><span class="line">A:每个 Zone 可以包含一个分区的多个副本</span><br><span class="line">B:不同 Zone 一定要部署在不同机房</span><br><span class="line">C:一个分区的多个副本应分布在不同的 Zone 中，每个 Zone 有且只有分区的一个全功能副本</span><br><span class="line">D:Available Zone 的含义是可用区，通常指一个机房</span><br><span class="line">E:一个 OceanBase 集群由若干个 Zone 组成</span><br><span class="line">F:一个 Zone 包括若干物理服务器</span><br><span class="line">3.关于 OceanBase 的系统参数的生效范围，以下说法正确的是： ABC </span><br><span class="line">A:可以在某台 OBServer 生效</span><br><span class="line">B:可以在某个 Zone 生效</span><br><span class="line">C:可以在集群范围生效</span><br><span class="line">D:可以在某个 Region 生效</span><br><span class="line">4.随着业务不断发展，原有租户的资源无法满足业务需要，有哪些扩容方式？ BC </span><br><span class="line">A:无法对租户进行扩容，需要创建一个新的租户满足业务需要</span><br><span class="line">B:调整资源池中，资源单元（resource unit）的数量，如原数量是 1，可以增加为 2</span><br><span class="line">C:调整资源池里的资源单元（resource unit）的规则，比如之前规格是 2C8G,可以调整为 4C16G</span><br><span class="line">5.RootService 总控服务提供资源分配及调度功能，主要包括哪些功能： ABCD</span><br><span class="line"> A：分区及副本管理</span><br><span class="line">B: 动态负载均衡</span><br><span class="line">C:SQL 引擎</span><br><span class="line">D:扩容和缩容</span><br><span class="line">6.关于 OceanBase 的修改系统参数命令 ALTER SYSTEM SET XX=’YY’，以下说法正确的是：   BCDE</span><br><span class="line">A:如果不要任何条件，则会返回错误；</span><br><span class="line">B:可以修改该 Parameter 在某个 zone 上的值</span><br><span class="line">C:可以修改该 Parameter 在某台具体的 OBServer 上的值</span><br><span class="line">D:如果不带任何条件，则修改所有 OBServer 的值</span><br><span class="line">E:可以修改 Parameter 在某个 Region 的值</span><br><span class="line">7.关于 OceanBase 的分区 Partition，以下说法正确的是：AB</span><br><span class="line">A:数据表根据分区规则，拆分成多个分区，每个分区包括表中的若干行记录</span><br><span class="line">B：每个分区，还可以用不同的分区维度再进行分区，叫做二级分区 C:OceanBase 只支持一级分区，不支持二级分区</span><br><span class="line">D: OceanBase 的分区是数据迁移的最小单元，也是高可用切换的最小单元</span><br><span class="line">E:OceanBase 支持表的自动分区分裂</span><br><span class="line">8.关于租户的扩容方式，以下说法正确的是：  AB</span><br><span class="line">A：租户扩容，可先通过添加服务节点，完成集群扩容，再通过增加资源单元的个数完成租户扩容</span><br><span class="line">B:如果集群和节点资源足够，可以直接修改租户资源池相关的资源单元规格大小，进行扩容</span><br><span class="line">C:OceanBase 是分布式集群具有横向扩展的能力，租户扩容仅仅需要添加阶段即可，无需扩容租户的资源单元</span><br><span class="line">D:租户无法进行扩容，如果资源无法满足需求，需要重新建立更大资源池的租户。</span><br><span class="line"></span><br><span class="line">9.系统管理员可以根据业务需要创建不同的租户，租户具有哪些特性 ABCD </span><br><span class="line">A:有自己独立的系统变量</span><br><span class="line">B:有独立的 information_schema 等系统数据库</span><br><span class="line">C:可以创建自己的用户</span><br><span class="line">D:可以创建数据库，表等所有对象</span><br><span class="line">11.关于 OceanBase 的应用日志级别，以下说法正确的是： CDE </span><br><span class="line">A:warn 警告，用于记录严重错误，需要立即处理</span><br><span class="line">B：info 提示，用户记录系统运行的当前状态，该信息为错误信息</span><br><span class="line">C:ERROR 严重错误，用于记录系统的故障信息，且必须进行故障排除，否则系统不可用</span><br><span class="line">D: info 提示，用户记录系统运行的当前状态，该信息为正常信息</span><br><span class="line">E:warn 警告，用于记录可能会出现的潜在错误</span><br><span class="line"></span><br><span class="line">12.分区数据一般有多份副本，OceanBase 的 副本有什么类型：ACD</span><br><span class="line">A:全能型B 只写型 C:日志型 D:只读型</span><br><span class="line"></span><br><span class="line">13.OceanBase 开发者中心 ODC 是为 OceanBase 数据库量身打造的企业数据库开发平台，主要支持哪些功能 ABCDE </span><br><span class="line">A:提供引导式创建和可视化修改各类数据库对象的服务</span><br><span class="line">B:支持多种文件格式的导入和导出</span><br><span class="line">C:通过 WebSQL 技术为开发人员提供 SQL 语法高亮、格式化、只能提示等贴心特性、支持 PL 对象及匿名快的编译、运行调试</span><br><span class="line">D:实时管控数据库会话访问，支持查看和终止会话，且提供 SQL 执行计划分析和 SQL 调优指导服务</span><br><span class="line">E:支持会话变量和系统全局变量的可视化修改，降低用户记忆变量的难度</span><br><span class="line"></span><br><span class="line">14.关于 OceanBase 的租户权限管理,以下说法正确的是：AB</span><br><span class="line">A:任何租户（，不论是系统租户还是普通租户）下的用户不能跨租户访问其他普通租户下的用户数据</span><br><span class="line">B:只有系统租户下的管理员用户才有集群管理的权限，执行系统管理操作，如创建/删除普通租户。设置系统配置参数，开启每日合并操作</span><br><span class="line">C:系统租户下的管理员用户可以访问其他普通租户的用户数据</span><br><span class="line">D:系统租户下的管理员用户可以给其他普通租户的用户进行授权，使得普通租户的用户拥有系统管理员的权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">15.关于 OCP 的告警功能，下列说法正确的是：  ABCDEF</span><br><span class="line">A:OCP 告警依赖专有云底座</span><br><span class="line">B:可以查看告警列表</span><br><span class="line">C:可以调整告警阈值</span><br><span class="line">D:不支持用户修改告警阈值</span><br><span class="line">E:可以自定义告警发送对象</span><br><span class="line">F:可以调整告警开关，确定哪些项需要监控</span><br><span class="line"></span><br><span class="line">16.关于 OceanBase 实物引擎的 MVCC 多版本并发控制，以下说法正确的是： ACD </span><br><span class="line">A: 读操作读取特定快照版本的已提交数据</span><br><span class="line">B：写会阻塞读操作</span><br><span class="line">C: 所有修改的行加互斥锁、实现写-写互斥</span><br><span class="line">D: 读写互不阻塞</span><br><span class="line">17.OceanBase 支持哪些分区方式的分区表 ABD </span><br><span class="line">A：Range </span><br><span class="line">B：Hash </span><br><span class="line">C：Datetime </span><br><span class="line">D：list</span><br><span class="line">19.以下哪个描述不是 OceanBase 的架构特点：中心管控</span><br><span class="line">20. 租户创建完成后，可以使用黑屏客户端连接数据库，除了指定数据库的 IP、端口号、用户名、密码等信息外，OceanBase 一般用户名使用什么格式 </span><br><span class="line">用户名@租户名  例如 root@sys</span><br><span class="line">21.建立 table group 的主要目的是：减少跨机分布式事物</span><br><span class="line">22. OceanBase 产品的数据库内核是什么   完全自主研发</span><br><span class="line">23.当应用向数据库写数据时，默认会访问主副本，此次主副本会同步（）到从副本，保证数据的高可用 D</span><br><span class="line">A:undo-log 日志</span><br><span class="line">B:系统日志</span><br><span class="line">C:心跳消息</span><br><span class="line">D：redo-log 日志</span><br><span class="line"></span><br><span class="line">24.以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控警告等功能。  OCP云管理平台</span><br><span class="line">25.部署 OceanBase 集群时，各个 OBServer 的 RPC 允许的时钟偏差最大是多少100毫秒</span><br><span class="line">26.如果一个 OceanBase 集群由 5 个 Zone，每个 Zone 有 10 台 OB Server，那么一个分区最多有几份全功能型副本   5个</span><br><span class="line">27.Linux 系统一般用什么用户来部署 OceanBaseADMIN</span><br><span class="line">28.OceanBase 服务器要求使用的磁盘类型: SSD固态磁盘</span><br><span class="line">29.假设OceanBase有3个Zone,其中2个Zone部署在一个城市的两个机房中，另外一个Zone部署在另外一个城市的一个机房中。如果同城的一个机房宕机，下面说法正确的是？    强一致同步延迟不变</span><br><span class="line">30.Major_freeze_duty_time 设置为 02:00 意味着什么每日凌晨两点，系统自动发起一次内存冻结操作</span><br><span class="line">31.关于 OceanBase 事物引擎一致性特点，描述正确的是：保证主键唯一等一致性约束</span><br><span class="line">32.关于 OceanBase 资源隔离，以下说法正确的是     OceanBase采用租户隔离</span><br><span class="line">33.管理员通过哪条命令创建资源池create resource pool</span><br><span class="line">34.OceanBase 是靠哪种基础架构实现写入高性能的 LSM-TTREE</span><br><span class="line">35.如果一个集群有 3 个 Zone，每个 Zone 有 5 台 OBServer，一个租户对应的资源池的 Unit Num=4,最终该集群有多少个服务器中有该租户的资源单元呢。    3*4=12 个</span><br></pre></td></tr></table></figure><h2 id="感谢OceanBase"><a href="#感谢OceanBase" class="headerlink" title="感谢OceanBase"></a>感谢OceanBase</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724163848260.png" alt="image-20230724163848260"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OceanBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Cryptography</title>
      <link href="/2023/06/29/Sercet/"/>
      <url>/2023/06/29/Sercet/</url>
      
        <content type="html"><![CDATA[<h1 id="基础密码学"><a href="#基础密码学" class="headerlink" title="基础密码学"></a>基础密码学</h1><p>密码学是研究信息的保密性、完整性和认证性的学科。它在现代通信和计算机系统中起着关键作用，保护着敏感数据的安全。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密是一种加密方法，其中使用相同的密钥进行加密和解密。以下是一些常见的对称加密算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>DES</td><td>数据加密标准，使用56位密钥</td></tr><tr><td>AES</td><td>高级加密标准，使用128、192或256位密钥</td></tr><tr><td>3DES</td><td>三重数据加密标准，对数据进行三次加密</td></tr><tr><td>RC4</td><td>流密码算法，适用于嵌入式设备</td></tr></tbody></table><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密使用不同的密钥进行加密和解密。它包括公钥和私钥，其中公钥用于加密，私钥用于解密。以下是一些常见的非对称加密算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>RSA</td><td>基于大素数分解的加密算法</td></tr><tr><td>Diffie-Hellman</td><td>密钥交换算法，用于安全地共享密钥</td></tr><tr><td>ECC</td><td>椭圆曲线密码学，使用较短的密钥提供相同的安全性</td></tr></tbody></table><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数将输入数据转换为固定长度的哈希值。它的主要特点是输入的任何小改变都会导致输出值的巨大改变。以下是一些常见的哈希函数和特点：</p><table><thead><tr><th>函数</th><th>特点</th></tr></thead><tbody><tr><td>MD5</td><td>128位哈希值，易于碰撞攻击</td></tr><tr><td>SHA-1</td><td>160位哈希值，被认为不够安全</td></tr><tr><td>SHA-256</td><td>256位哈希值，广泛用于数字签名和认证</td></tr></tbody></table><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名用于验证消息的完整性和来源。它使用私钥对消息进行签名，然后使用公钥进行验证。以下是一些常见的数字签名算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>RSA</td><td>基于大素数分解的加密算法</td></tr><tr><td>DSA</td><td>数字签名算法，用于确保消息的完整性和认证</td></tr><tr><td>ECDSA</td><td>椭圆曲线数字签名算法，提供相同安全性下较短的密钥长度</td></tr></tbody></table><h2 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h2><p>密钥交换是在通信双方之间安全地共享密钥的过程。以下是一些常见的密钥交换协议和特点：</p><table><thead><tr><th>协议</th><th>特点</th></tr></thead><tbody><tr><td>Diffie-Hellman</td><td>公钥密码学协议，双方通过交换信息生成共享密钥</td></tr><tr><td>RSA 密钥交换</td><td>基于RSA算法的密钥交换协议</td></tr><tr><td>ECDH</td><td>基于椭圆曲线密码学的密钥交换协议，提供较短的密钥长度</td></tr></tbody></table><h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>消息认证码（Message Authentication Code，MAC）用于验证消息的完整性和真实性，以防止消息被篡改。以下是一些常见的消息认证码算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>HMAC</td><td>基于散列函数和密钥的消息认证码算法</td></tr><tr><td>CMAC</td><td>基于块密码的消息认证码算法</td></tr><tr><td>Poly1305</td><td>使用特殊的多项式计算的消息认证码算法</td></tr></tbody></table><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书用于验证实体的身份和确保通信的安全。它包含了实体的公钥和其他身份信息，并由数字证书颁发机构（Certificate Authority，CA）签名。以下是一些与数字证书相关的概念和术语：</p><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>公钥证书（Public Key Certificate）</td><td>包含公钥和实体身份信息的数字证书</td></tr><tr><td>数字签名（Digital Signature）</td><td>用于验证数字证书的完整性和真实性的签名</td></tr><tr><td>证书链（Certificate Chain）</td><td>由一系列数字证书组成的链，用于验证数字证书的信任链条</td></tr></tbody></table><h2 id="密码协议"><a href="#密码协议" class="headerlink" title="密码协议"></a>密码协议</h2><p>密码协议用于在不安全的通信环境中实现安全通信。它们定义了通信双方之间的消息格式、加密算法、密钥交换协议等。以下是一些常见的密码协议：</p><table><thead><tr><th>协议</th><th>特点</th></tr></thead><tbody><tr><td>SSL/TLS</td><td>安全套接层/传输层安全协议，用于保护Web通信</td></tr><tr><td>IPSec</td><td>用于保护IP网络通信的协议</td></tr><tr><td>SSH</td><td>安全外壳协议，用于远程登录和安全文件传输</td></tr></tbody></table><h2 id="抗量子密码学"><a href="#抗量子密码学" class="headerlink" title="抗量子密码学"></a>抗量子密码学</h2><p>随着量子计算机的发展，传统密码学算法的安全性受到了挑战。抗量子密码学致力于设计抵抗量子计算攻击的密码算法。以下是一些抗量子密码学的概念和算法：</p><table><thead><tr><th>概念/算法</th><th>解释</th></tr></thead><tbody><tr><td>Post-Quantum Cryptography（PQC）</td><td>用于抵抗量子计算攻击的密码学算法</td></tr><tr><td>Lattice-Based Cryptography</td><td>基于格的密码学，利用数学问题的困难性提供安全性</td></tr><tr><td>Code-Based Cryptography</td><td>基于编码的密码学，利用编码理论提供安全性</td></tr></tbody></table><h2 id="密码学应用"><a href="#密码学应用" class="headerlink" title="密码学应用"></a>密码学应用</h2><p>密码学在各个领域有广泛的应用。以下是一些常见的密码学应用和场景：</p><table><thead><tr><th>应用</th><th>描述</th></tr></thead><tbody><tr><td>数据加密</td><td>用于保护敏感数据的机密性，例如在存储和传输过程中进行加密</td></tr><tr><td>身份认证</td><td>用于验证用户的身份，例如使用密码、数字证书或生物特征识别</td></tr><tr><td>虚拟私人网络</td><td>通过加密和隧道技术实现安全的远程访问和通信</td></tr><tr><td>数字版权保护</td><td>用于保护数字内容的版权和防止非法复制和分发</td></tr><tr><td>安全电子支付</td><td>用于保护在线交易的机密性和完整性，例如使用加密货币和数字签名</td></tr></tbody></table><h2 id="密码破解与密码强度"><a href="#密码破解与密码强度" class="headerlink" title="密码破解与密码强度"></a>密码破解与密码强度</h2><p>密码破解是试图通过暴力猜测或使用各种技术手段来获取密码的过程。密码强度是衡量密码抵御密码破解攻击的程度。以下是一些与密码破解和密码强度相关的概念：</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>字典攻击</td><td>使用预先生成的密码列表进行猜测的攻击方式</td></tr><tr><td>彩虹表攻击</td><td>使用预先计算的哈希值与密码对应表进行猜测的攻击方式</td></tr><tr><td>密码策略</td><td>设定密码要求和规则的策略，如密码长度、复杂性和更改频率等</td></tr><tr><td>双因素认证</td><td>使用两个或多个不同的身份验证因素来增强安全性，如密码+OTP令牌</td></tr></tbody></table><h2 id="密码学应用-1"><a href="#密码学应用-1" class="headerlink" title="密码学应用"></a>密码学应用</h2><p>密码学在各个领域有广泛的应用。以下是一些常见的密码学应用和场景：</p><table><thead><tr><th>应用</th><th>描述</th></tr></thead><tbody><tr><td>数据加密</td><td>用于保护敏感数据的机密性，例如在存储和传输过程中进行加密</td></tr><tr><td>身份认证</td><td>用于验证用户的身份，例如使用密码、数字证书或生物特征识别</td></tr><tr><td>虚拟私人网络</td><td>通过加密和隧道技术实现安全的远程访问和通信</td></tr><tr><td>数字版权保护</td><td>用于保护数字内容的版权和防止非法复制和分发</td></tr><tr><td>安全电子支付</td><td>用于保护在线交易的机密性和完整性，例如使用加密货币和数字签名</td></tr></tbody></table><h2 id="密码破解与密码强度-1"><a href="#密码破解与密码强度-1" class="headerlink" title="密码破解与密码强度"></a>密码破解与密码强度</h2><p>密码破解是试图通过暴力猜测或使用各种技术手段来获取密码的过程。密码强度是衡量密码抵御密码破解攻击的程度。以下是一些与密码破解和密码强度相关的概念：</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>字典攻击</td><td>使用预先生成的密码列表进行猜测的攻击方式</td></tr><tr><td>彩虹表攻击</td><td>使用预先计算的哈希值与密码对应表进行猜测的攻击方式</td></tr><tr><td>密码策略</td><td>设定密码要求和规则的策略，如密码长度、复杂性和更改频率等</td></tr><tr><td>双因素认证</td><td>使用两个或多个不同的身份验证因素来增强安全性，如密码+OTP令牌</td></tr></tbody></table><h2 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h2><p>密码管理是指有效管理和保护个人或组织的密码。以下是一些常见的密码管理实践和工具：</p><table><thead><tr><th>实践/工具</th><th>描述</th></tr></thead><tbody><tr><td>密码管理器</td><td>用于安全存储和生成密码的应用程序，如LastPass和1Password等</td></tr><tr><td>多因素身份验证</td><td>在登录过程中要求提供多个验证因素，增加账户安全性</td></tr><tr><td>定期更改密码</td><td>定期更改密码以减少密码泄露和破解的风险</td></tr><tr><td>强密码生成</td><td>使用随机字符、数字和符号生成强密码，避免使用弱密码</td></tr><tr><td>社会工程学防范</td><td>提高对社会工程学攻击的意识，避免将密码泄露给不信任的来源</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模型-行为型模式</title>
      <link href="/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA/"/>
      <url>/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-行为型"><a href="#设计模式-行为型" class="headerlink" title="设计模式-行为型"></a>设计模式-行为型</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>定义了对象之间一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新</li></ul><h3 id="模式组合"><a href="#模式组合" class="headerlink" title="模式组合"></a>模式组合</h3><table><thead><tr><th>角色</th><th>描述</th></tr></thead><tbody><tr><td>Subject</td><td>被观察者接口，定义了注册、移除和通知观察者的方法</td></tr><tr><td>Observer</td><td>观察者接口，定义了接收被观察者通知并进行更新的方法</td></tr><tr><td>ConcreteSubject</td><td>具体的被观察者类，实现Subject接口，维护观察者列表，当状态变化时通知观察者</td></tr><tr><td>ConcreteObserver</td><td>具体的观察者类，实现Observer接口，定义了接收通知后进行更新操作的方法</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230626152258117.png" alt="image-20230626152258117"></p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被观察者接口</span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void registerObserver(Observer observer);</span><br><span class="line">    void removeObserver(Observer observer);</span><br><span class="line">    void notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者接口</span><br><span class="line">interface Observer &#123;</span><br><span class="line">    void update(float temperature, float humidity, float pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的被观察者类</span><br><span class="line">class WeatherData implements Subject &#123;</span><br><span class="line">    private List&lt;Observer&gt; observers;</span><br><span class="line">    private float temperature;</span><br><span class="line">    private float humidity;</span><br><span class="line">    private float pressure;</span><br><span class="line">    </span><br><span class="line">    public WeatherData() &#123;</span><br><span class="line">        observers = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void registerObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void measurementsChanged() &#123;</span><br><span class="line">        // 当天气数据发生变化时调用该方法</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setMeasurements(float temperature, float humidity, float pressure) &#123;</span><br><span class="line">        this.temperature = temperature;</span><br><span class="line">        this.humidity = humidity;</span><br><span class="line">        this.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的观察者类</span><br><span class="line">class WeatherDisplay implements Observer &#123;</span><br><span class="line">    private float temperature;</span><br><span class="line">    private float humidity;</span><br><span class="line">    private float pressure;</span><br><span class="line">    </span><br><span class="line">    public void update(float temperature, float humidity, float pressure) &#123;</span><br><span class="line">        this.temperature = temperature;</span><br><span class="line">        this.humidity = humidity;</span><br><span class="line">        this.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void display() &#123;</span><br><span class="line">        // 更新天气展示板上的数据显示</span><br><span class="line">        System.out.println(&quot;当前天气情况：温度 &quot; + temperature + &quot;℃，湿度 &quot; + humidity + &quot;%，气压 &quot; + pressure + &quot;Pa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">public class ObserverPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WeatherData weatherData = new WeatherData();</span><br><span class="line">        </span><br><span class="line">        WeatherDisplay display1 = new WeatherDisplay();</span><br><span class="line">        WeatherDisplay display2 = new WeatherDisplay();</span><br><span class="line">        </span><br><span class="line">        weatherData.registerObserver(display1);</span><br><span class="line">        weatherData.registerObserver(display2);</span><br><span class="line">        </span><br><span class="line">        // 模拟天气数据变化</span><br><span class="line">        weatherData.setMeasurements(28.5f, 70.2f, 1013.2f);</span><br><span class="line">        </span><br><span class="line">        // 移除一个观察者</span><br><span class="line">        weatherData.removeObserver(display2);</span><br><span class="line">        </span><br><span class="line">        // 再次模拟天气数据变化</span><br><span class="line">        weatherData.setMeasurements(30.2f, 65.8f, 1012.5f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模式特征"><a href="#模式特征" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>松耦合：被观察者和观察者之间是松耦合的关系，它们之间相互独立，可以独立地进行扩展和修改，一方的变化不会影响到另一方。 </li><li>可扩展性：可以轻松地增加新的观察者和被观察者，使系统具有更好的可扩展性。</li><li>随时通知：被观察者状态发生变化时，会立即通知所有观察者，观察者可以及时作出响应。</li><li>解耦：观察者模式将观察者和被观察者解耦，使它们之间的依赖关系降低，符合面向对象设计的原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加了复杂性：在使用观察者模式时，需要维护观察者列表并确保正确的通知顺序，这增加了系统的复杂性。</li><li>更新通知顺序：观察者的更新通知顺序是不确定的，这可能导致观察者之间的依赖关系问题。</li><li>观察者数量过多：当观察者数量过多时，被观察者通知所有观察者的时间和性能开销会增加。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>定义了一组算法类，将每个算法封装到单独的类中，并使他们可以相互替换，而不影响客户端的代码</li></ul><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色</th><th>描述</th></tr></thead><tbody><tr><td>环境类（Context）</td><td>包含对策略的引用，可在运行时切换不同的策略。将具体的算法委托给策略对象执行。</td></tr><tr><td>抽象策略类（Strategy）</td><td>定义了通用的策略接口，所有具体策略类都必须实现该接口。通常是抽象类或接口，包含一个或多个用于执行策略的方法。</td></tr><tr><td>具体策略类（Concrete Strategy）</td><td>实现策略接口，提供具体的算法实现。每个具体策略类封装了一种特定的算法，可根据需要添加、删除或替换。</td></tr></tbody></table><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/%E5%8C%85%20Strategy.png" alt="包 Strategy"></p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 环境类（Context）</span><br><span class="line">class Context &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void executeStrategy(int num1, int num2) &#123;</span><br><span class="line">        int result = strategy.doOperation(num1, num2);</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象策略类（Strategy）</span><br><span class="line">interface Strategy &#123;</span><br><span class="line">    int doOperation(int num1, int num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略类（Concrete Strategy）</span><br><span class="line">class AddStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int doOperation(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略类（Concrete Strategy）</span><br><span class="line">class SubtractStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int doOperation(int num1, int num2) &#123;</span><br><span class="line">        return num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略类（Concrete Strategy）</span><br><span class="line">class MultiplyStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int doOperation(int num1, int num2) &#123;</span><br><span class="line">        return num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line"></span><br><span class="line">        // 使用加法策略</span><br><span class="line">        context.setStrategy(new AddStrategy());</span><br><span class="line">        context.executeStrategy(5, 3); // Output: Result: 8</span><br><span class="line"></span><br><span class="line">        // 使用减法策略</span><br><span class="line">        context.setStrategy(new SubtractStrategy());</span><br><span class="line">        context.executeStrategy(5, 3); // Output: Result: 2</span><br><span class="line"></span><br><span class="line">        // 使用乘法策略</span><br><span class="line">        context.setStrategy(new MultiplyStrategy());</span><br><span class="line">        context.executeStrategy(5, 3); // Output: Result: 15</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模式特征-1"><a href="#模式特征-1" class="headerlink" title="模式特征"></a>模式特征</h4><h5 id="策略模式的优点："><a href="#策略模式的优点：" class="headerlink" title="策略模式的优点："></a>策略模式的优点：</h5><p>可扩展性：策略模式使得新增或修改算法变得简单，通过添加新的具体策略类，可以轻松地扩展系统的功能。</p><p>灵活性：客户端可以根据需要在运行时选择不同的策略，无需修改原有的代码，提供了更高的灵活性和可定制性。</p><p>代码复用：策略模式利用了面向对象的多态特性，可以让多个具体策略类共享相同的接口或抽象类，提高了代码的复用性。</p><p>解耦合：策略模式将算法的选择与使用算法的客户端代码解耦，客户端只需要关注如何使用策略，而无需关注具体的算法实现细节，降低了代码的耦合度。</p><h6 id="策略模式的缺点："><a href="#策略模式的缺点：" class="headerlink" title="策略模式的缺点："></a>策略模式的缺点：</h6><p>增加类的数量：每个具体策略类都需要一个对应的类，当策略较多时，会增加类的数量，导致代码结构复杂。</p><p>客户端需要了解不同策略的区别：客户端在选择具体策略时需要了解不同策略的特点和适用场景，增加了客户端的理解和学习成本。</p><p>策略的切换开销：在运行时切换策略时，可能需要重新设置环境类的策略，会带来一定的切换开销，尤其是在需要频繁切换策略时。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>允许多个对象依次处理请求，形成一个处理请求的链条，每个对象都有机会处理请求，但具体是哪个对象处理请求由运行时决定。<h3 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h3></li></ul><table><thead><tr><th>组成部分</th><th>描述</th></tr></thead><tbody><tr><td>抽象处理者（Abstract Handler）</td><td>定义处理请求的接口，包含一个指向下一个处理者的引用。</td></tr><tr><td>具体处理者（Concrete Handler）</td><td>实现抽象处理者接口，并决定自己能处理的请求类型，如果可以处理就进行处理，否则将请求传递给下一个处理者。</td></tr><tr><td>客户端（Client）</td><td>发起请求的对象，将请求发送给第一个处理者。</td></tr></tbody></table><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230626161056453.png" alt="image-20230626161056453"></p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 抽象处理者</span><br><span class="line">abstract class Handler &#123;</span><br><span class="line">    protected Handler successor; // 下一个处理者</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(Handler successor) &#123;</span><br><span class="line">        this.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleRequest(int request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者A</span><br><span class="line">class ConcreteHandlerA extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(int request) &#123;</span><br><span class="line">        if (request &gt;= 0 &amp;&amp; request &lt; 10) &#123;</span><br><span class="line">            System.out.println(&quot;ConcreteHandlerA 处理请求：&quot; + request);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request); // 传递给下一个处理者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者B</span><br><span class="line">class ConcreteHandlerB extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(int request) &#123;</span><br><span class="line">        if (request &gt;= 10 &amp;&amp; request &lt; 20) &#123;</span><br><span class="line">            System.out.println(&quot;ConcreteHandlerB 处理请求：&quot; + request);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request); // 传递给下一个处理者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者C</span><br><span class="line">class ConcreteHandlerC extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(int request) &#123;</span><br><span class="line">        if (request &gt;= 20 &amp;&amp; request &lt; 30) &#123;</span><br><span class="line">            System.out.println(&quot;ConcreteHandlerC 处理请求：&quot; + request);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request); // 传递给下一个处理者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Handler handlerA = new ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = new ConcreteHandlerB();</span><br><span class="line">        Handler handlerC = new ConcreteHandlerC();</span><br><span class="line"></span><br><span class="line">        handlerA.setSuccessor(handlerB);</span><br><span class="line">        handlerB.setSuccessor(handlerC);</span><br><span class="line"></span><br><span class="line">        int[] requests = &#123; 2, 12, 25, 30 &#125;;</span><br><span class="line"></span><br><span class="line">        for (int request : requests) &#123;</span><br><span class="line">            handlerA.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式特征-2"><a href="#模式特征-2" class="headerlink" title="模式特征"></a>模式特征</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>责任链模式将发送者和接收者解耦，发送者无需知道具体的接收者，只需将请求发送给责任链的起始点即可，由责任链负责将请求传递给合适的接收者进行处理。<br>灵活性和可扩展性：责任链模式允许动态地添加、移除或重新排列处理者，可以根据需求对责任链进行灵活的组织和调整，而无需修改客户端代码。<br>可以确保请求被处理：由于责任链中的每个处理者都有机会处理请求，可以确保请求最终会被处理，而不会被忽略或丢失。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>性能问题：如果责任链过长或者处理者的判断逻辑过于复杂，可能会导致性能下降，因为每个请求都要依次经过链中的所有处理者。<br>请求的处理不一定成功：由于责任链模式并不保证请求一定会被处理，如果没有合适的处理者或者处理者链配置错误，请求可能会被忽略或丢失。<br>可能导致调试困难：责任链模式中请求的处理路径是动态确定的，可能会导致在调试时难以确定请求的具体处理路径。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li>将请求封装成一个对象，该对象会包含了执行操作的方法，发送者将命令对象传递给调用者，并在需要执行操作的时候触发命令并执行相应操作。</li></ul><h3 id="模式组成-2"><a href="#模式组成-2" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>模式组成</th><th>描述</th></tr></thead><tbody><tr><td>命令接口</td><td>定义命令的执行方法，通常包括一个执行操作的方法。</td></tr><tr><td>具体命令</td><td>实现命令接口，持有一个接收者对象，并将请求委托给接收者执行具体的操作。</td></tr><tr><td>接收者</td><td>知道如何实施与执行一个请求相关的操作。</td></tr><tr><td>调用者</td><td>将命令对象传递给调用者，并可选择性地触发命令执行。</td></tr></tbody></table><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p>当然，以下是一个简单的 Java 实例来演示命令模式：</p><p>首先，我们定义一个命令接口 <code>Command</code>，它包含了一个执行操作的方法 <code>execute()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个具体命令类 <code>ConcreteCommand</code>，它实现了 <code>Command</code> 接口，并持有一个接收者对象，用于执行具体的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.performAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个接收者类 <code>Receiver</code>，它知道如何实施与执行请求相关的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver: Performing action...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个调用者类 <code>Invoker</code>，它将接收到的命令对象传递给调用者，并在需要的时候触发命令的执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以在客户端代码中配置和使用命令模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建接收者对象</span></span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建具体命令对象并设置接收者</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用者对象并设置命令</span></span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        invoker.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702220522678.png" alt="image-20230702220522678"></p><h3 id="模式特征-3"><a href="#模式特征-3" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>解耦发送者和接收者：命令模式将请求封装成对象，使得发送者和接收者之间解耦。发送者不需要知道接收者的具体实现细节，只需通过命令对象来执行请求。</li><li>容易扩展和修改：由于命令模式将请求封装成独立的对象，因此可以很容易地添加新的命令或修改现有命令，而不会对其他部分产生影响。这种可扩展性使得系统更加灵活和可维护。</li><li>支持撤销和重做：命令模式可以记录命令的历史，从而支持撤销和重做操作。通过保存命令的执行历史，可以在需要时回溯执行，实现撤销操作。</li><li>支持命令的排队和调度：命令模式可以将命令对象进行排队或者调度，从而实现更高级的控制和管理。可以按照特定的顺序执行命令，或者延迟执行命令。</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>类的增加：在使用命令模式时，每个具体命令都需要一个独立的类，这可能会导致类的数量增加，增加了系统的复杂性。</li><li>可能导致系统过于细粒度：如果系统中有大量的命令对象，每个对象都只封装了一个操作，可能会导致系统过于细粒度，增加了管理和维护的成本。</li><li>可能引入额外的开销：命令模式需要创建额外的对象来封装请求，可能会引入一定的开销。但在大多数情况下，这种开销是可以接受的。</li></ol><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>通过将不同状态抽象为独立的类，并将其与主对象关联，实现状态之间的切换和行为的动态变化。</li></ul><h3 id="模式组成-3"><a href="#模式组成-3" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成要素</th><th>描述</th></tr></thead><tbody><tr><td>环境（Context）</td><td>环境类持有一个状态对象的引用，可以定义和维护对象的内部状态。它将状态相关的操作委托给当前状态对象，并在状态发生改变时更新当前状态对象。</td></tr><tr><td>抽象状态（State）</td><td>定义一个接口或抽象类，声明各个具体状态类共同的方法，这些方法可以是环境在某个特定状态下要执行的行为。</td></tr><tr><td>具体状态（Concrete State）</td><td>实现抽象状态接口或继承抽象状态类，具体状态类封装了特定状态下的行为。每个具体状态类负责处理与其状态相关的操作，并在必要时切换到其他状态。</td></tr></tbody></table><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：新订单状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewOrderState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理新订单...&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行新订单状态下的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：已支付状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaidOrderState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理已支付订单...&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行已支付订单状态下的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：已发货状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShippedOrderState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理已发货订单...&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行已发货订单状态下的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderState currentState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认初始状态为新订单状态</span></span><br><span class="line">        currentState = <span class="keyword">new</span> <span class="title class_">NewOrderState</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(OrderState state)</span> &#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatePatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理新订单</span></span><br><span class="line">        order.processOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换为已支付状态</span></span><br><span class="line">        order.setState(<span class="keyword">new</span> <span class="title class_">PaidOrderState</span>());</span><br><span class="line">        order.processOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换为已发货状态</span></span><br><span class="line">        order.setState(<span class="keyword">new</span> <span class="title class_">ShippedOrderState</span>());</span><br><span class="line">        order.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，抽象状态类<code>OrderState</code>定义了一个<code>processOrder()</code>方法，具体状态类<code>NewOrderState</code>、<code>PaidOrderState</code>和<code>ShippedOrderState</code>分别实现了这个方法，封装了不同状态下的具体行为逻辑。<code>Order</code>类作为环境类，维护了当前状态对象的引用，并在<code>processOrder()</code>方法中委托给当前状态对象执行相应的行为。</p><p>客户端代码创建了一个订单对象<code>order</code>，初始状态为新订单状态，然后依次处理订单并切换状态，观察不同状态下的行为执行情况。</p><h4 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702225657156.png" alt="image-20230702225657156"></p><h3 id="模式特征-4"><a href="#模式特征-4" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>状态模式将对象的状态和行为进行了解耦，使得状态的变化可以独立于对象的行为变化。这提高了代码的可维护性和扩展性。</li><li>状态模式遵循开闭原则，可以通过添加新的具体状态类来增加新的状态，而无需修改现有的代码。</li><li>状态模式使得状态转换变得更加明确和可控。状态的切换逻辑集中在具体状态类中，不会分散在对象的各个方法中，使得代码更易理解和调试。</li><li>状态模式使得对象的状态变化可见，可以方便地观察和记录对象的状态变化历史。</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>状态模式增加了系统中类的数量，特别是在具体状态类较多的情况下，可能会导致类的数量增加，增加了系统的复杂性。</li><li>如果状态转换较为复杂，可能会导致状态模式的实现变得复杂，需要维护大量的状态类和状态转换逻辑。</li><li>当状态较少且简单时，引入状态模式可能会带来不必要的复杂性，增加了代码的理解和维护成本。</li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>用于将数据结构和对数据结构的操作分离开来，允许定义新的操作而无需修改已有的数据结构。</li></ul><h3 id="模式组成-4"><a href="#模式组成-4" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成部分</th><th>描述</th></tr></thead><tbody><tr><td>元素（Element）</td><td>表示数据结构中的对象。它定义了一个接受访问者对象的方法，让访问者可以对自身进行操作。</td></tr><tr><td>具体元素（Concrete Element）</td><td>实现了元素接口的具体类。每个具体元素类都会实现自己的接受访问者的方法，并在其中调用访问者对象的操作方法。</td></tr><tr><td>访问者（Visitor）</td><td>定义了对元素进行操作的接口，其中包含了为每个具体元素类定义的操作方法。</td></tr><tr><td>具体访问者（Concrete Visitor）</td><td>实现了访问者接口的具体类。每个具体访问者类都会实现对应的操作方法，以便对具体元素进行相应的操作。</td></tr><tr><td>对象结构（Object Structure）</td><td>存储元素对象并提供访问者访问的接口。它可以是一个集合、列表、树或其他数据结构。</td></tr></tbody></table><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitConcreteElementA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteElementA operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitConcreteElementB(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteElementB operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitConcreteElementA</span><span class="params">(ConcreteElementA elementA)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitConcreteElementB</span><span class="params">(ConcreteElementB elementB)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitConcreteElementA</span><span class="params">(ConcreteElementA elementA)</span> &#123;</span><br><span class="line">        elementA.operationA();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteVisitor visits ConcreteElementA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitConcreteElementB</span><span class="params">(ConcreteElementB elementB)</span> &#123;</span><br><span class="line">        elementB.operationB();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteVisitor visits ConcreteElementB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(Element element)</span> &#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具体元素对象</span></span><br><span class="line">        <span class="type">ConcreteElementA</span> <span class="variable">elementA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteElementA</span>();</span><br><span class="line">        <span class="type">ConcreteElementB</span> <span class="variable">elementB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteElementB</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建对象结构并添加元素</span></span><br><span class="line">        <span class="type">ObjectStructure</span> <span class="variable">objectStructure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStructure</span>();</span><br><span class="line">        objectStructure.addElement(elementA);</span><br><span class="line">        objectStructure.addElement(elementB);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建具体访问者对象</span></span><br><span class="line">        <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteVisitor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象结构接受访问者访问</span></span><br><span class="line">        objectStructure.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702232125374.png" alt="image-20230702232125374"></p><h3 id="模式特征-5"><a href="#模式特征-5" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><p>当讨论访问者模式时，可以列举一些其优点和缺点，以便全面评估该模式的适用性和潜在的问题。</p><p>优点：</p><ul><li>分离关注点：访问者模式可以将数据结构和操作分离开来，使得操作可以独立变化而不影响元素类的结构。这种分离可以提高代码的可维护性和可扩展性。</li><li>增加新操作更容易：通过定义新的访问者类，可以很容易地增加新的操作，而无需修改元素类的代码。这符合开闭原则，使系统更灵活。</li><li>集中相关操作：访问者模式可以将相关操作集中到访问者类中。这样，当需要对元素进行某个操作时，只需调用相应的访问者方法，而不需要在元素类中编写重复的操作代码。</li><li>增加新元素相对容易：如果需要增加新的元素类，只需创建相应的具体元素类并实现接受访问者的方法即可。无需修改现有的访问者类。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加新元素困难：在访问者模式中，如果需要增加新的访问者类，需要修改所有已有的元素类，为它们添加接受新访问者的方法。这可能会导致元素类的修改和代码的重复。</li><li>违反封装原则：访问者模式需要将具体元素类的内部结构暴露给访问者类，以便访问者能够进行操作。这可能违反了封装原则，降低了元素类的封装性。</li><li>增加系统复杂性：引入访问者模式会增加系统中的类和接口数量，增加了代码的复杂性和理解难度。这可能使得系统变得更加复杂，特别是对于简单的数据结构而言，使用访问者模式可能过于繁琐。</li></ul><h2 id="模块方法模式"><a href="#模块方法模式" class="headerlink" title="模块方法模式"></a>模块方法模式</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li>定义了一个操作中的算法的骨架。将一些步骤延迟到子类中实现。模板方块使得子类可以在不改变算法结构的情况下重新定义算法中某些步骤<h3 id="模式组成-5"><a href="#模式组成-5" class="headerlink" title="模式组成"></a>模式组成</h3></li></ul><table><thead><tr><th>模式组成</th><th>描述</th></tr></thead><tbody><tr><td>模板方法（Template Method）</td><td>定义了算法的骨架，将算法的步骤定义为一系列抽象操作或具体操作的调用顺序。这个方法可以包含预定义的操作和钩子方法。</td></tr><tr><td>具体方法（Concrete Method）</td><td>在模板方法中定义的具体操作，是算法的固定部分。</td></tr><tr><td>抽象方法（Abstract Method）</td><td>在模板方法中定义的抽象操作，由子类实现。这些方法可以有不同的实现，以满足特定的需求。</td></tr><tr><td>钩子方法（Hook Method）</td><td>在模板方法中定义的具体操作，子类可以选择性地覆盖或扩展。这些方法在模板方法中有默认实现，但可以在子类中进行修改。</td></tr><tr><td>抽象类（Abstract Class）</td><td>包含模板方法和抽象方法的抽象类。它定义了算法的骨架，并规定了具体操作和抽象操作的调用顺序。</td></tr><tr><td>具体类（Concrete Class）</td><td>继承抽象类并实现其中的抽象方法，完成算法的具体步骤。它可以覆盖钩子方法来定制算法的行为。</td></tr></tbody></table><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 抽象类</span><br><span class="line">abstract class AbstractClass &#123;</span><br><span class="line">    // 模板方法</span><br><span class="line">    public void templateMethod() &#123;</span><br><span class="line">        // 调用抽象方法</span><br><span class="line">        operation1();</span><br><span class="line">        // 调用具体方法</span><br><span class="line">        operation2();</span><br><span class="line">        // 调用钩子方法</span><br><span class="line">        if (hookMethod()) &#123;</span><br><span class="line">            operation3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 抽象方法</span><br><span class="line">    protected abstract void operation1();</span><br><span class="line"></span><br><span class="line">    // 具体方法</span><br><span class="line">    protected void operation2() &#123;</span><br><span class="line">        // 具体操作的实现</span><br><span class="line">        System.out.println(&quot;执行具体操作2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 钩子方法</span><br><span class="line">    protected boolean hookMethod() &#123;</span><br><span class="line">        // 默认实现，子类可以选择性地覆盖该方法</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 抽象方法</span><br><span class="line">    protected abstract void operation3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体类A</span><br><span class="line">class ConcreteClassA extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作1（来自具体类A）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void operation3() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作3（来自具体类A）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体类B</span><br><span class="line">class ConcreteClassB extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作1（来自具体类B）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean hookMethod() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void operation3() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作3（来自具体类B）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractClass instanceA = new ConcreteClassA();</span><br><span class="line">        instanceA.templateMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line"></span><br><span class="line">        AbstractClass instanceB = new ConcreteClassB();</span><br><span class="line">        instanceB.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702234441116.png" alt="image-20230702234441116"></p><h3 id="模式特征-6"><a href="#模式特征-6" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>提供了一种框架或模板，用于定义算法的骨架，使得算法的具体步骤可以在子类中实现，提高了代码的可扩展性和复用性。</li><li>将算法的通用部分封装在模板方法中，具体实现延迟到子类中，使得算法的具体步骤可以灵活变化，而不影响算法的整体结构。</li><li>通过钩子方法，允许子类选择性地覆盖或扩展父类中的某些操作，从而实现个性化定制。</li><li>提高了代码的可维护性和可读性，将重复的代码逻辑放在模板方法中，避免了代码的重复编写。</li></ol><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ol><li>引入了抽象类和具体类之间的继承关系，增加了系统的复杂性。如果继承关系设计不当，可能会导致类的层次结构变得复杂，难以维护。</li><li>由于模板方法已经定义了算法的骨架，因此在一定程度上限制了子类的自由度，子类只能实现父类定义好的抽象方法。</li><li>如果算法的变化点过多，可能需要定义大量的抽象方法，增加了子类的实现工作量。</li><li>模板方法模式的设计初衷是为了定义算法的骨架，对于一些具有多个算法簇的情况，可能会导致类的爆炸性增长，不利于系统的扩展和维护。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MP</title>
      <link href="/2023/05/06/mybatis/"/>
      <url>/2023/05/06/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a>MyBatis Plus</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li>损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li>强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li>支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li>支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li>支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li>分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作<h4 id="什么是MyBatisPlus"><a href="#什么是MyBatisPlus" class="headerlink" title="什么是MyBatisPlus"></a>什么是MyBatisPlus</h4></li><li>MyBatis是一款优秀的持久层框架，用于简化JDBC开发</li><li>MyBatisPlus是基于MyBatis框架基础上开发的增强型工具，皆在<strong>简化开发，提高效率</strong></li></ul><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><ul><li>负责将数据保存倒数据库那一层代码</li><li>JavaEE三层架构：表现层，业务层，持久层</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>框架就是一个半成品软件，是一套可重用的，通用的，软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效，规范，通用，可扩展</li></ul><h3 id="入门案列"><a href="#入门案列" class="headerlink" title="入门案列"></a>入门案列</h3><ul><li>SpringBoot整合MyBatis开发过程<ul><li>创建SpringBoot工程</li><li>勾选配置使用的技术</li><li>设置dataSource相关属性（JDBC参数）</li><li>定义数据层接口映射配置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/mybatisplus_db?serverTimezone = UTC</span></span><br><span class="line">    username: ？</span><br><span class="line">    password: ？</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;?&gt;&#123;</span><br><span class="line"><span class="meta">@select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><h5 id="创建SpringBoot工程"><a href="#创建SpringBoot工程" class="headerlink" title="创建SpringBoot工程"></a>创建SpringBoot工程</h5><pre><code>![image-20230503171102161](https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230503171102161.png)</code></pre><h5 id="添加依赖MySQL-Driver"><a href="#添加依赖MySQL-Driver" class="headerlink" title="添加依赖MySQL Driver"></a>添加依赖MySQL Driver<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230503171325952.png" alt="image-20230503171325952"></h5><h5 id="打开xml文件，手动添加mybatis-plus-boot-start依赖"><a href="#打开xml文件，手动添加mybatis-plus-boot-start依赖" class="headerlink" title="打开xml文件，手动添加mybatis-plus-boot-start依赖"></a>打开xml文件，手动添加mybatis-plus-boot-start依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="mybatis-plus-boot-start"><a href="#mybatis-plus-boot-start" class="headerlink" title="mybatis-plus-boot-start"></a>mybatis-plus-boot-start</h6><p>这是Maven依赖，用于引入MyBatis Plus框架的快速启动器。MyBatis Plus是一个增强版的MyBatis框架，提供了许多MyBatis没有的方便实用的功能，例如自动代码生成、分页插件、多数据源支持、性能优化等。</p><p>在pom.xml中引入了这个依赖后，就可以开始使用MyBatis Plus。可以在配置文件中添加MyBatis Plus的配置，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  typeAliasesPackage: com.example.demo.entity</span><br><span class="line">  mapperLocations: classpath:/mapper/*.xml</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      column-underscore: true</span><br><span class="line">      id-type: auto</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，typeAliasesPackage是指实体类所在的包，mapperLocations是指MyBatis mapper XML文件的位置，global-config是MyBatis Plus的全局配置，在这里修改了ID的生成策略和开启了下划线到驼峰命名的自动转换。</p><p>然后，可以像平常一样编写MyBatis mapper XML文件和DAO接口，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- demo.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.dao.DemoDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.demo.entity.DemoEntity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listByParam&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from demo</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> and name = #&#123;name&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span> and age = #&#123;age&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的SQL语句... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// DemoDAO.java</span><br><span class="line">@Mapper</span><br><span class="line">public interface DemoDAO extends BaseMapper<span class="tag">&lt;<span class="name">DemoEntity</span>&gt;</span> &#123;</span><br><span class="line">    List<span class="tag">&lt;<span class="name">DemoEntity</span>&gt;</span> listByParam(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编写DAO接口时，可以继承MyBatis Plus提供的BaseMapper&lt; T &gt;接口，该接口提供了许多便捷的CRUD方法。此外，也可以编写自定义SQL语句，既具有MyBatis的灵活性，又能充分利用MyBatis Plus提供的便利性。最后，在使用DAO接口时，可以像平常一样使用Spring的@Autowired注解来注入DAO对象，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private DemoDAO demoDAO;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    QueryWrapper<span class="tag">&lt;<span class="name">DemoEntity</span>&gt;</span> queryWrapper = new QueryWrapper<span class="tag">&lt;&gt;</span>();</span><br><span class="line">    queryWrapper.eq(&quot;name&quot;, &quot;张三&quot;).eq(&quot;age&quot;, 25);</span><br><span class="line">    demoDAO.selectList(queryWrapper);</span><br><span class="line">    // TODO: 使用查询到的数据进行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打开xml文件，手动添加com-baomidou依赖"><a href="#打开xml文件，手动添加com-baomidou依赖" class="headerlink" title="打开xml文件，手动添加com.baomidou依赖"></a>打开xml文件，手动添加com.baomidou依赖</h6><p>这是Maven依赖，用于引入MyBatis Plus框架的快速启动器。MyBatis Plus是一个增强版的MyBatis框架，提供了许多MyBatis没有的方便实用的功能，例如自动代码生成、分页插件、多数据源支持、性能优化等。</p><p>在pom.xml中引入了这个依赖后，就可以开始使用MyBatis Plus。可以在配置文件中添加MyBatis Plus的配置，如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">typeAliasesPackage:</span> <span class="string">com.example.demo.entity</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">column-underscore:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><p>在这里，typeAliasesPackage是指实体类所在的包，mapperLocations是指MyBatis mapper XML文件的位置，global-config是MyBatis Plus的全局配置，在这里修改了ID的生成策略和开启了下划线到驼峰命名的自动转换。</p><p>然后，可以像平常一样编写MyBatis mapper XML文件和DAO接口，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- demo.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.dao.DemoDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.demo.entity.DemoEntity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listByParam&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from demo</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> and name = #&#123;name&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span> and age = #&#123;age&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的SQL语句... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DemoDAO.java</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoDAO</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;DemoEntity&gt; &#123;</span><br><span class="line">    List&lt;DemoEntity&gt; <span class="title function_">listByParam</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写DAO接口时，可以继承MyBatis Plus提供的BaseMapper&lt; T &gt;接口，该接口提供了许多便捷的CRUD方法。此外，也可以编写自定义SQL语句，既具有MyBatis的灵活性，又能充分利用MyBatis Plus提供的便利性。</p><p>最后，在使用DAO接口时，可以像平常一样使用Spring的@Autowired注解来注入DAO对象，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DemoDAO demoDAO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;DemoEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>).eq(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    demoDAO.selectList(queryWrapper);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 使用查询到的数据进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis Plus提供了许多易用的API，通过使用它们可以大大提升代码的开发效率。</p><h5 id="配置resources"><a href="#配置resources" class="headerlink" title="配置resources"></a>配置resources</h5><ol><li>添加datasource<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisplus?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">?</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">?</span></span><br></pre></td></tr></table></figure><h5 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上图为例</span></span><br><span class="line">ackage domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="comment">//这里用到了lombok，后续会讲</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><table><thead><tr><th>操作类型</th><th>方法调用示例</th><th>SQL示例</th></tr></thead><tbody><tr><td>插入操作</td><td><code>mapper.insert(entity);</code></td><td><code>INSERT INTO table (column1, column2, ...) VALUES (?, ?, ...);</code></td></tr><tr><td>更新操作</td><td><code>mapper.updateById(entity);</code></td><td><code>UPDATE table SET column1=?, column2=?, ... WHERE id=?;</code></td></tr><tr><td>删除操作</td><td><code>mapper.deleteById(1);</code></td><td><code>DELETE FROM table WHERE id=?;</code></td></tr><tr><td>查询单个对象</td><td><code>mapper.selectById(1);</code></td><td><code>SELECT * FROM table WHERE id=?;</code></td></tr><tr><td>查询多个对象</td><td><code>mapper.selectList(null);</code></td><td><code>SELECT * FROM table;</code></td></tr><tr><td>条件查询</td><td><code>mapper.selectList(queryWrapper);</code></td><td><code>SELECT * FROM table WHERE column1=value1 AND column2&gt;value2;</code></td></tr><tr><td>分页查询</td><td><code>mapper.selectPage(page, queryWrapper);</code></td><td><code>SELECT COUNT(1) FROM table; SELECT * FROM table WHERE column1=value1 LIMIT startIndex, pageSize;</code></td></tr></tbody></table><h3 id="实体类开发工具lombok"><a href="#实体类开发工具lombok" class="headerlink" title="实体类开发工具lombok"></a>实体类开发工具lombok</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依赖导入</span></span><br><span class="line">&lt;!-- Lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.18</span><span class="number">.20</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>以下是 Lombok 常用的注解和对应的方法：</p><table><thead><tr><th>注解</th><th>解释</th><th>方法示例</th></tr></thead><tbody><tr><td>@Data</td><td>自动生成各种方法，包括 getter/setter/toString/hashCode/equals</td><td><code>@Data class T &#123;private String name;&#125;</code></td></tr><tr><td>@Getter/@Setter</td><td>自动生成 getter/setter 方法</td><td><code>@Getter @Setter private String name;</code></td></tr><tr><td>@ToString</td><td>自动生成 toString 方法</td><td><code>@ToString(of = &#123;&quot;name&quot;, &quot;age&quot;&#125;) class T &#123;private String name; private int age;&#125;</code></td></tr><tr><td>@EqualsAndHashCode</td><td>自动生成 hashCode 和 equals 方法</td><td><code>@EqualsAndHashCode(of = &#123;&quot;name&quot;, &quot;age&quot;&#125;) class T &#123;private String name; private int age;&#125;</code></td></tr><tr><td>@NoArgsConstructor</td><td>自动生成无参构造方法</td><td><code>@NoArgsConstructor class T &#123;&#125;</code></td></tr><tr><td>@RequiredArgsConstructor</td><td>自动生成必须参数的构造方法</td><td><code>@RequiredArgsConstructor class T &#123; private final String name; private final int age; &#125;</code></td></tr><tr><td>@AllArgsConstructor</td><td>自动生成全参构造方法</td><td><code>@AllArgsConstructor class T &#123; private String name; private int age; &#125;</code></td></tr><tr><td>@Builder</td><td>自动生成建造者模式方法，用于链式调用</td><td><code>@Builder class T &#123;private String name; private int age;&#125;</code></td></tr><tr><td>@Slf4j</td><td>自动生成 log 变量，方便日志输出</td><td><code>@Slf4j class T &#123;private static final Logger log = LoggerFactory.getLogger(T.class);&#125;</code></td></tr></tbody></table><p>使用 Lombok 可以大大简化 POJO 类编写的过程。不需要手动编写重复的 getter/setter/toString/hashCode/equals 等方法，可以提高开发效率。同时，Builder 注解生成的建造者模式方法可以使代码更加简洁易读。</p><h3 id="标准分页功能"><a href="#标准分页功能" class="headerlink" title="标准分页功能"></a>标准分页功能</h3><h4 id="boot配置日志开启"><a href="#boot配置日志开启" class="headerlink" title="boot配置日志开启"></a>boot配置日志开启</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line"> configuration:</span><br><span class="line">  log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>下面是 <code>IPage&lt;T&gt;</code> 接口中常用的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>List&lt;T&gt; getRecords()</code></td><td>获取当前页数据</td></tr><tr><td><code>long getTotal()</code></td><td>获取总记录数</td></tr><tr><td><code>IPage&lt;T&gt; setTotal(long total)</code></td><td>设置总记录数，并返回当前对象</td></tr><tr><td><code>long getSize()</code></td><td>获取当前页大小</td></tr><tr><td><code>IPage&lt;T&gt; setSize(long size)</code></td><td>设置当前页大小，并返回当前对象</td></tr><tr><td><code>long getCurrent()</code></td><td>获取当前页数</td></tr><tr><td><code>IPage&lt;T&gt; setCurrent(long current)</code></td><td>设置当前页数，并返回当前对象</td></tr><tr><td><code>long getPages()</code></td><td>获取总页数</td></tr><tr><td><code>IPage&lt;T&gt; setPages(long pages)</code></td><td>设置总页数，并返回当前对象</td></tr><tr><td><code>List&lt;OrderItem&gt; orders()</code></td><td>获取排序字段信息</td></tr><tr><td><code>IPage&lt;T&gt; setOrders(List&lt;OrderItem&gt; orders)</code></td><td>设置排序字段信息，并返回当前对象</td></tr><tr><td><code>boolean optimizeCountSql()</code></td><td>是否进行 count SQL 优化</td></tr><tr><td><code>IPage&lt;T&gt; setOptimizeCountSql(boolean optimizeCountSql)</code></td><td>设置 count SQL 优化标识，并返回当前对象</td></tr><tr><td><code>boolean isSearchCount()</code></td><td>是否进行 count SQL 查询</td></tr><tr><td><code>IPage&lt;T&gt; setSearchCount(boolean isSearchCount)</code></td><td>设置 count SQL 查询标识，并返回当前对象</td></tr><tr><td><code>Map&lt;String, Object&gt; condition()</code></td><td>获取查询条件信息</td></tr><tr><td><code>IPage&lt;T&gt; setCondition(Map&lt;String, Object&gt; condition)</code></td><td>设置查询条件信息，并返回当前对象</td></tr><tr><td><code>List&lt;T&gt; getRecords(boolean optimizeCountSql, boolean isSearchCount)</code></td><td>获取当前页数据，并选择是否进行 count SQL 优化和 count SQL 查询</td></tr><tr><td><code>IPage&lt;T&gt; convert(Function&lt;? super T, ? extends U&gt; converter)</code></td><td>转换当前 <code>IPage&lt;T&gt;</code> 为 <code>IPage&lt;U&gt;</code></td></tr></tbody></table><h4 id="MP拦截器"><a href="#MP拦截器" class="headerlink" title="MP拦截器"></a>MP拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于一个插件功能，但是不实现的话就可能实现不了分页功能</span></span><br><span class="line"><span class="keyword">package</span> com.example.mybatisplus.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mpInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义MP拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mpInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2.添加具体拦截器</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同样能够实现上面的方法</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sql语句打印配置，运行日志"><a href="#sql语句打印配置，运行日志" class="headerlink" title="sql语句打印配置，运行日志"></a>sql语句打印配置，运行日志</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h4 id="杀掉多余得数据显示"><a href="#杀掉多余得数据显示" class="headerlink" title="杀掉多余得数据显示"></a>杀掉多余得数据显示</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">logback.xml</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//在Spring工程生成原生得xml进行配置</span><br><span class="line">  global-config:</span><br><span class="line">    banner: false</span><br><span class="line">  main:</span><br><span class="line">    banner-mode: off</span><br></pre></td></tr></table></figure><h3 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h3><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li>MyBatisPlus将书写复杂的SQL查询条件进行封装<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230504224141560.png" alt="image-20230504224141560"></li><li>其中Wrapper&lt; T &gt;就是对查询条件的封装</li></ul><h4 id="添加QueryWrapper对象"><a href="#添加QueryWrapper对象" class="headerlink" title="添加QueryWrapper对象"></a>添加QueryWrapper对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">qw.lt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>解释</th></tr></thead><tbody><tr><td><code>eq()</code></td><td>等于</td></tr><tr><td><code>ne()</code></td><td>不等于</td></tr><tr><td><code>gt()</code></td><td>大于</td></tr><tr><td><code>ge()</code></td><td>大于等于</td></tr><tr><td><code>lt()</code></td><td>小于</td></tr><tr><td><code>le()</code></td><td>小于等于</td></tr><tr><td><code>between()</code></td><td>在两个值之间</td></tr><tr><td><code>notBetween()</code></td><td>不在两个值之间</td></tr><tr><td><code>like()</code></td><td>模糊查询</td></tr><tr><td><code>notLike()</code></td><td>不匹配某个值的模糊查询</td></tr><tr><td><code>isNull()</code></td><td>为空</td></tr><tr><td><code>isNotNull()</code></td><td>不为空</td></tr><tr><td><code>in()</code></td><td>包含在某个集合中</td></tr><tr><td><code>notIn()</code></td><td>不包含在某个集合中</td></tr><tr><td><code>groupBy()</code></td><td>分组</td></tr><tr><td><code>orderByAsc()</code></td><td>升序排序</td></tr><tr><td><code>orderByDesc()</code></td><td>降序排序</td></tr></tbody></table><h4 id="lambda格式按条件查询"><a href="#lambda格式按条件查询" class="headerlink" title="lambda格式按条件查询"></a>lambda格式按条件查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其一</span></span><br><span class="line">QueryWrapper&lt; User &gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt; User &gt;();</span><br><span class="line">qw.lamda().lt(User::getAge,<span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其二</span></span><br><span class="line">LambadQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">qw.lambda().lt(User::getAge,<span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h4 id="null值处理"><a href="#null值处理" class="headerlink" title="null值处理"></a>null值处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserQuery</span> <span class="variable">uq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserQuery</span>();</span><br><span class="line">uq.setAge2(<span class="number">30</span>);</span><br><span class="line">lqw.lt(<span class="literal">null</span>!=uq.getAge2,User::getAge,uq.getAge2());</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h3 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通</span></span><br><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">lqw.select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LanbdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(User::getId,User::getName,User::getAge);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h3 id="查询投影-1"><a href="#查询投影-1" class="headerlink" title="查询投影"></a>查询投影</h3><p>MyBatisPlus 查询投影是一种查询方式，主要用于查询部分实体类属性（字段），而不是整个实体类的所有属性。它提高了查询效率，并减少了网络传输和内存消耗。下面是 MyBatisPlus 查询投影的总结：</p><ol><li><p>查询投影可以通过在实体类中定义一个 VO（View Object）类来实现。这个 VO 类只包含我们需要查询的那些属性，而不是整个实体类。</p></li><li><p>MyBatisPlus 提供了多种查询方式来实现投影查询，包括普通查询、条件构造器查询、Lambda 表达式查询等。</p></li><li><p>在使用 MyBatisPlus 进行查询时，可以使用 <code>selectOne()</code>、<code>selectList()</code>、<code>selectMaps()</code> 等方法实现投影查询。</p></li><li><p>在投影查询中，我们可以使用 <code>select()</code> 方法指定要查询的字段，也可以使用 <code>excludeColumns()</code> 方法排除要查询的字段。</p></li><li><p>投影查询可以使用 <code>@SqlParser(filter = true)</code> 注解来关闭逻辑删除功能。这个注解告诉 MyBatisPlus 不要将逻辑删除的行返回给查询结果列表。</p></li><li><p>对于投影查询结果的处理方式，我们可以选择将结果直接映射到实体类中，或者将结果映射到 Map 对象中。</p></li></ol><h3 id="查询条件设置"><a href="#查询条件设置" class="headerlink" title="查询条件设置"></a>查询条件设置</h3><p>MyBatisPlus 提供了多种设置查询条件的方式，以下是 MyBatisPlus 查询条件设置的总结：</p><ol><li><p>使用实体类作为查询条件。MyBatisPlus 可以自动地将实体类中的非空字段作为查询条件生成 SQL 语句，并将查询结果映射到实体类中。如果存在多个非空字段，它们之间的默认关系是 <code>AND</code>，可以通过注解方式更改其关系为 <code>OR</code>。</p></li><li><p>使用 <code>Wrapper</code> 对象作为查询条件。<code>Wrapper</code> 类是 MyBatisPlus 提供的一种条件构造器，它可以实现 SQL 语句中常见的条件设置操作，例如 <code>eq()</code>（等于）、<code>ne()</code>（不等于）、<code>like()</code>（模糊查询）等。可以使用 Lambda 表达式来构造 <code>Wrapper</code> 对象，也可以直接使用传统的 SQL 片段。</p></li><li><p>使用 <code>QueryWrapper</code> 类作为查询条件。<code>QueryWrapper</code> 是 MyBatisPlus 提供的一种常用条件构造器，可以用于设置 <code>WHERE</code> 条件、排序条件、分组条件等。它支持的查询方式比 <code>Wrapper</code> 更加灵活，例如支持 <code>in()</code>（包含）、<code>between()</code>（在两个值之间）等操作。</p></li><li><p>使用 <code>UpdateWrapper</code> 类作为更新条件。<code>UpdateWrapper</code> 可以用于设置 <code>SET</code> 条件，与 <code>QueryWrapper</code> 类似，也支持 Lambda 表达式和传统的 SQL 片段。</p></li><li><p>使用 <code>LambdaQueryWrapper</code>、<code>LambdaUpdateWrapper</code> 等 Lambda 类型的查询方式，实现更加简洁的条件设置，例如 <code>lambdaQuery().eq(User::getId, 1)</code>。</p></li></ol><h3 id="映射匹配兼容性"><a href="#映射匹配兼容性" class="headerlink" title="映射匹配兼容性"></a>映射匹配兼容性</h3><p>MyBatisPlus 映射匹配兼容性主要指 MyBatisPlus 在进行映射操作时，与传统 MyBatis XML 映射文件的兼容性问题。以下是 MyBatisPlus 映射匹配兼容性的总结：</p><ol><li><p>MyBatisPlus 支持与传统 MyBatis XML 映射文件共存，并且支持使用 <code>@MapperScan</code> 注解扫描所有的 Mapper 接口。</p></li><li><p>MyBatisPlus 中内置了多种自动映射配置方式，包括 <code>AUTO</code>（自动按列名匹配）、<code>FULL</code>（自动映射所有实体属性）、<code>NONE</code>（不进行自动映射）等。</p></li><li><p>MyBatisPlus 还支持自定义类型处理器、全局配置、实体类表名映射、字段名映射等灵活的映射配置方式。</p></li><li><p>在使用 MyBatisPlus 进行开发时，需要注意一些 XML 映射文件中的配置不能与 MyBatisPlus 的自动映射方式冲突，例如 <code>resultMap</code>、<code>association</code>、<code>collection</code> 等配置，需要进行合理的调整。</p></li><li><p>对于一些特殊场景，例如需要进行多表关联查询、复杂的查询构造，或者需要使用 MyBatis 动态 SQL 等功能时，可以继续使用传统的 XML 映射文件进行开发。</p></li></ol><table><thead><tr><th>注解名称</th><th>说明</th><th>应用举例</th></tr></thead><tbody><tr><td><code>@TableId</code></td><td>主键字段的映射注解，用于标注实体类中主键字段</td><td><code>@TableId(value = &quot;id&quot;, type = IdType.AUTO)</code> 表示将 <code>id</code> 字段设置为自增长主键</td></tr><tr><td><code>@TableField</code></td><td>字段映射注解，在实体类字段上使用，用于设置字段与数据库表中列的映射关系</td><td><code>@TableField(value = &quot;name&quot;, exist = true, update = &quot;false&quot;)</code> 表示将 <code>name</code> 字段映射到数据库表的 <code>name</code> 列上，且为非更新字段</td></tr><tr><td><code>@TableName</code></td><td>表名映射注解，用于标注实体类对应的数据库表名</td><td><code>@TableName(&quot;user&quot;)</code> 表示将实体类 <code>User</code> 映射到数据库表 <code>user</code> 上</td></tr><tr><td><code>@KeySequence</code></td><td>序列映射注解，用于标注主键对应的序列名称</td><td><code>@KeySequence(value = &quot;myseq&quot;, clazz = Integer.class)</code> 表示将主键对应的序列名称设为 <code>myseq</code>，并指定序列类型为 <code>Integer</code></td></tr></tbody></table><h3 id="id生成策略"><a href="#id生成策略" class="headerlink" title="id生成策略"></a>id生成策略</h3><table><thead><tr><th>ID 生成策略</th><th>说明</th></tr></thead><tbody><tr><td><code>ASSIGN_ID</code></td><td>自定义 ID 生成器，需要在代码中自行生成 ID 值</td></tr><tr><td><code>ASSIGN_UUID</code></td><td>UUID 生成器，使用 JDK 自带的 <code>UUID.randomUUID()</code> 方法生成 UUID</td></tr><tr><td><code>ASSIGN_ID_WORKER</code></td><td>雪花算法 ID 生成器，使用 Twitter 的 Snowflake 算法生成全局唯一的 ID</td></tr><tr><td><code>IDENTITY</code></td><td>基于数据库的自增长 ID 生成器，数据库类型需要支持自增长</td></tr><tr><td><code>NONE</code></td><td>未设置 ID 生成器</td></tr><tr><td><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230506120115982.png" alt="image-20230506120115982"></td><td></td></tr></tbody></table><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法（Snowflake）是一种唯一ID生成算法。它由Twitter公司开发，用于生成全局唯一的ID。雪花算法的核心思想是在64位的ID中，对不同的部分按照规定的位数进行位移和组合，并使用timestamp作为序列的一部分，可以保证生成的ID全局唯一，且越小的timestamp的序列号越小。</p><p>雪花算法的ID格式如下：</p><p>其中：</p><p>第1位（最高位）未使用，可以根据需求使用，一般为0；<br>第2<del>42位表示timestamp，精确到毫秒级别，总共可以表示2^41-1个数字，约69年；<br>第43</del>52位是机器ID，用于表示生成ID的机器，最多支持2^10=1024个机器；<br>第53~64位是序列号，用于表示同一毫秒内生成的不同ID，支持每毫秒生成2^12-1个ID。<br>使用雪花算法生成的ID具有很高的性能和稳定性，适合用于分布式系统中，例如分布式ID生成、分布式锁等场景。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230506115329072.png" alt="image-20230506115329072"></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ol><li>在表中添加版本控制字段</li></ol><p>首先，需要在表中添加一个版本控制字段，例如在 User 表中添加一个 version 字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> version <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol><li>在实体类中添加版本控制字段</li></ol><p>接下来，在实体类中添加版本控制字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Version</span> <span class="comment">// 添加版本控制注解</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实体类中，需要添加 <code>@Version</code> 注解，来标识该字段为版本控制字段。</p><ol><li>在 Mapper 文件中使用乐观锁</li></ol><p>在 Mapper 文件中进行更新操作时，可以利用 MyBatisPlus 提供的 <code>@Version</code> 注解自动实现乐观锁功能。以下是一个更新 User 表的简单示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name&#125;,</span><br><span class="line">        age = #&#123;age&#125;,</span><br><span class="line">        email = #&#123;email&#125;,</span><br><span class="line">        version = version + 1</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line">      and version = #&#123;version&#125; <span class="comment">&lt;!-- 添加乐观锁判断 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MyBatisPlus代码生成器"><a href="#MyBatisPlus代码生成器" class="headerlink" title="MyBatisPlus代码生成器"></a>MyBatisPlus代码生成器</h3><p>MyBatisPlus 提供了一个便捷的代码生成器，可以通过该生成器自动生成 Entity、Mapper、Service 和 Controller 等基础代码，从而加快开发速度，提高效率。以下是 MyBatisPlus 代码生成器的简要总结：</p><ol><li>配置生成器</li></ol><p>在 <code>pom.xml</code> 文件中，添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，在 <code>application.yml</code> 或 <code>application.properties</code> 配置文件中，添加自己的数据库连接信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_name?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置代码生成器参数</li></ol><p>在项目中创建一个 <code>generator</code> 包，并创建一个 <code>CodeGenerator</code> 类，用于配置代码生成器参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码生成器相关配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">authorName</span> <span class="operator">=</span> <span class="string">&quot;your name&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] tables = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;table_name&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packagePath</span> <span class="operator">=</span> <span class="string">&quot;com.example&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据源配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_name&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        gc.setAuthor(authorName);</span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);</span><br><span class="line">        gc.setEntityName(<span class="string">&quot;%s&quot;</span>);</span><br><span class="line">        gc.setMapperName(<span class="string">&quot;%sMapper&quot;</span>);</span><br><span class="line">        gc.setXmlName(<span class="string">&quot;%sMapper&quot;</span>);</span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);</span><br><span class="line">        gc.setServiceImplName(<span class="string">&quot;%sServiceImpl&quot;</span>);</span><br><span class="line">        gc.setControllerName(<span class="string">&quot;%sController&quot;</span>);</span><br><span class="line">        gc.setSwagger2(<span class="literal">false</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(url);</span><br><span class="line">        dsc.setDriverName(driverName);</span><br><span class="line">        dsc.setUsername(username);</span><br><span class="line">        dsc.setPassword(password);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        pc.setParent(packagePath);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setXml(<span class="string">&quot;mapper.xml&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">&quot;service.impl&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        strategy.setTablePrefix(<span class="string">&quot;t_&quot;</span>);</span><br><span class="line">        strategy.setInclude(tables);</span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行生成</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们可以通过配置相关参数来指定生成器的输出路径、作者名、表名、数据源信息、包路径、策略配置等。在执行 <code>AutoGenerator</code> 对象的 <code>execute()</code> 方法后，MyBatisPlus 就会自动生成相应的 Entity、Mapper、Service 和 Controller 等基础代码，生成的文件都可以在指定的输出路径中找到。</p>]]></content>
      
      
      <categories>
          
          <category> Study Note </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023425</title>
      <link href="/2023/04/25/2023425%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/25/2023425%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="身高排序"><a href="#身高排序" class="headerlink" title="身高排序"></a>身高排序</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组names,和一个由<strong>互不相同</strong> 的正整数组成的数组heights.两个数组的长度均为n.对每个下标 i,name[i]和heights[i] 表示第i个人的名字和身高.降序返回对应的名字数组names.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在 HashMap 中存储了身高和人名信息。接下来，利用 entrySet() 方法获取映射关系集合，并将这个集合转换成 List 类型的 entryList。接着调用了 Collections.sort() 方法来对 entryList 进行排序。通过 getKey() 和 getValue() 方法分别获取身高和人名信息，最终按照从小到大排序存储到字符串数组 result 中并返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] sortPeople(String[] names, <span class="type">int</span>[] heights) &#123;</span><br><span class="line">    HashMap&lt;Integer,String&gt; storage = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> names.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        storage.put(Integer.valueOf(heights[i]),names[i]);  <span class="comment">// 将身高和对应的人名信息存储到 HashMap 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序 HashMap，输出结果</span></span><br><span class="line">    List&lt;Map.Entry&lt;Integer, String&gt;&gt; entryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;Integer, String&gt;&gt;(storage.entrySet());</span><br><span class="line">    Collections.sort(entryList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, String&gt; o1, Map.Entry&lt;Integer, String&gt; o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.getKey() - o1.getKey();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    String[] result = <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : entryList) &#123;</span><br><span class="line">        result[i++] = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections是怎么对List里面的Map进行排序的"><a href="#Collections是怎么对List里面的Map进行排序的" class="headerlink" title="Collections是怎么对List里面的Map进行排序的."></a>Collections是怎么对List里面的Map进行排序的.</h2><ol><li>Collections.sort()方法可以对实现Comparable接口或使用自定义比较器Comparator的类进行排序.由于List中的元素是Map,我们需要使用Comparator来指定排序规则.<br>如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map1.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">map1.put(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">listMap.add(map1);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">map2.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line">listMap.add(map2);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map3.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">map3.put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">listMap.add(map3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匿名内部类 Comparator 进行排序</span></span><br><span class="line">Collections.sort(listMap, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map&lt;String, Object&gt; o1, Map&lt;String, Object&gt; o2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> (<span class="type">int</span>) o1.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age2</span> <span class="operator">=</span> (<span class="type">int</span>) o2.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age1 - age2; <span class="comment">// 正序排列</span></span><br><span class="line">        <span class="comment">// return age2 - age1; // 倒序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">for</span> (Map&lt;String, Object&gt; map : listMap) &#123;</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;：&quot;</span> + map.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Exercises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模型-结构型模式</title>
      <link href="/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
      <url>/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-结构型模式"><a href="#设计模式-结构型模式" class="headerlink" title="设计模式-结构型模式"></a>设计模式-结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</li><li>适配器模式，定义一个包装类，用于包装不兼容接口的对象</li><li>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。适配器的模式的形式分别：为类的适配器和对象的适配器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包装类=适配器Adapter</span><br><span class="line">被包装类对象 = 适配器Adaptee = 被适配的类</span><br></pre></td></tr></table></figure></li></ul><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>原版由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>透明简单，客户端可以调用同一个接口，因而对客户端来说是透明的</li><li>复用性，需要实现现有的类，此类的接口不符合系统的需要，那么通过适配器模式可以让这些功能得到更好的复用</li><li>扩展性，实现适配器功能的时候，通过调用自己开发的功能，从而自然的扩展系统的功能</li><li>解耦性，将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改源码</li><li>符合开闭原则，同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改适配类。<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303272341418.png" alt="img"></p><h3 id="举例实例"><a href="#举例实例" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SpecificRequest</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPattern</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">mAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>()；</span><br><span class="line">        mAdapter.Request（）;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>过多的使用适配器会让系统非常凌乱，不易整体进行把握。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>系统需要复用现有类，而该类接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的类一起工作。</li><li>多个组件功能类似，接口不统一且可能会经常切换时候，可以使用适配器模式，使得客户端额可以统一的接口使用他们。</li></ul><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>抽象部分与它的实现部分分离，使它们都可以独立的变化。</li><li>抽取其中一个维度并使之成为独立的类层次</li><li>在某个类中添加一个指向某一属性对象的引用成员变量。</li></ul><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成</th><th>作用</th></tr></thead><tbody><tr><td>抽象类</td><td>定义抽象类的接口，定义了一个Implementor实现类接口的对象斌可以维护其对象</td></tr><tr><td>提炼抽象类</td><td>扩充抽象类定义的接口，通常属于具体类，实现抽象类中声明的抽象业务方法，在提炼抽象类中，能够调用在实现类接口的业务方法</td></tr><tr><td>实现类接口</td><td>这个接口不一定要与抽象类的接口完全一致，事实上这两个接口可以完全不同，可以仅仅提供基本操作，而抽象类接口可以实现更多复杂的操作。</td></tr><tr><td>具体实现类</td><td>具体实现实现类接口，在不同的具体实现类中提供基本操作的不同实现，在程序运行时候，具体实现类的对象将会替换其父类对象，提供给抽象类具体的业务操作方法。</td></tr></tbody></table><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>提高系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</li><li>有的时候类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，而且多继承的结构类中的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li></ul><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303272227473.png" alt="在这里插入图片描述"></p><h3 id="举例实例-1"><a href="#举例实例-1" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于画各种颜色的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">protected</span> ColorAPI colorAPI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDrawAPI</span><span class="params">(ColorAPI colorAPI)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.colorAPI = colorAPI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;长方形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//创建一个圆形</span></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="comment">//给圆形蓝色的颜料</span></span><br><span class="line">shape.setDrawAPI(<span class="keyword">new</span> <span class="title class_">BlueColorAPI</span>());</span><br><span class="line"><span class="comment">//上色</span></span><br><span class="line">shape.draw();</span><br><span class="line"><span class="comment">//创建一个长方形</span></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"><span class="comment">//给长方形上红色的颜料</span></span><br><span class="line">shape1.setDrawAP(<span class="keyword">new</span> <span class="title class_">RedColorAPI</span>());</span><br><span class="line"><span class="comment">//上色</span></span><br><span class="line">shape1.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个时候客户需要一个绿色的三角形那么只需要新增一个三角形类即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;绿色&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line">shape.setDrawAPI(<span class="keyword">new</span> <span class="title class_">GreenColorAPI</span>());</span><br><span class="line">shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li>桥接模式的引入会增加系统的理解与设计的难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计以及编程</li><li>桥接模式要求正确的识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>不改变现有对象结构的情况下，动态地给对象增加一些职责的模式，它属于对象结构型模式</li></ul><h3 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态地给一个对象扩展功能，即插即用。</li><li>通过不用装饰类以及这些装饰类的排列组合，可以实现不同效果</li><li>装饰器模式完全遵守开闭原则</li></ul><h3 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th align="left">组成</th><th>作用</th></tr></thead><tbody><tr><td align="left">抽象构件</td><td>定义一个抽象接口以规范准备接收附加责任的对象</td></tr><tr><td align="left">具体构件</td><td>实现抽象构件，通过装饰角色为其添加一些职责</td></tr><tr><td align="left">抽象装饰</td><td>继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</td></tr><tr><td align="left">具体装饰</td><td>实现抽象装饰的相关方法，并给具体构件对象添加附加责任。</td></tr></tbody></table><h3 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303290039331.png" alt="image-20230329003915296"></p><h3 id="举例实例-2"><a href="#举例实例-2" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul><li>装饰器模式会增加许多子类，过度使用会增加程序的复杂性。<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3></li><li>为其他对象提供一种代理以控制这个对象的访问。</li></ul><h3 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>职责清晰</li><li>高扩展，只要实现了接口，都可以用代理</li><li>智能化，动态代理。</li></ul><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303290100829.png" alt="image-20230329010025796"></p><h3 id="举例实例-3"><a href="#举例实例-3" class="headerlink" title="举例实例"></a>举例实例</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ol><li>以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个提供了租房方法的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义租房的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RentHouse</span> <span class="keyword">implements</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租了一间房子。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租房找中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntermediaryProxy</span> <span class="keyword">implements</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IRentHouse rentHouse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntermediaryProxy</span><span class="params">(IRentHouse irentHouse)</span>&#123;</span><br><span class="line">        rentHouse = irentHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;交中介费&quot;</span>);</span><br><span class="line">        rentHouse.rentHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;中介负责维修管理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义租房</span></span><br><span class="line">        <span class="type">IRentHouse</span> <span class="variable">rentHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RentHouse</span>();</span><br><span class="line">        <span class="comment">//定义中介</span></span><br><span class="line">        <span class="type">IRentHouse</span> <span class="variable">intermediary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntermediaryProxy</span>(rentHouse);</span><br><span class="line">        <span class="comment">//中介租房</span></span><br><span class="line">        intermediary.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3>又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，他创建了对象组的树形结构<h3 id="模式组成-2"><a href="#模式组成-2" class="headerlink" title="模式组成"></a>模式组成</h3></li></ol><table><thead><tr><th>角色</th><th>解释</th></tr></thead><tbody><tr><td>抽象构件</td><td>为树叶构件和树枝构件声明公共接口，实现默认行为</td></tr><tr><td>树叶构件</td><td>没有子节点，用于继承或实现抽象构件，是树状结构最底层。</td></tr><tr><td>树枝构件</td><td>有子节点，是组合中的分支节点。</td></tr></tbody></table><h3 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>一致处理单个对象和组合对象，无须关心处理的是单个对象还是组合对象。</li><li>容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码。</li></ul><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul><li>设计复杂，需要一定时间理清层次关系</li><li>不容易限制容器中的构件</li><li>不容易用继承的方法来增加构件的新功能</li></ul><h3 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用接口或者抽象类都可以的</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Region</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前节点下面的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知，上面下个政策一级一级的传递，一般都有一个动作方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树叶地区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafRegion</span> <span class="keyword">extends</span> <span class="title class_">Region</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeafRegion</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span> &#123;</span><br><span class="line"><span class="comment">//叶子节点没有下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span> &#123;</span><br><span class="line"><span class="comment">//叶子节点没有下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//叶子节点没有下级</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最底层的接到了通知</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树枝地区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositeRegion</span> <span class="keyword">extends</span> <span class="title class_">Region</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来盛放子节点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Region&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">        children.add(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">        children.remove(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*通知下级所有的部门，下级如果是树枝的话继续通知，这是个递归操作*/</span></span><br><span class="line">        <span class="keyword">for</span> (Region child : children) &#123;</span><br><span class="line">            child.notice();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使得这一子系统更加容易使用</li></ul><h3 id="模式组成-3"><a href="#模式组成-3" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色类型</th><th>作用解释</th></tr></thead><tbody><tr><td>外观(Facade)</td><td>封装系统底层功能，为客户端提供简单易用的接口</td></tr><tr><td>子系统类(SubSystem)</td><td>提供系统底层的具体实现细节</td></tr><tr><td>客户端(Client)</td><td>调用外观对象提供的简单接口，使用系统底层功能而无需了解其具体实现</td></tr></tbody></table><h3 id="解决问题-5"><a href="#解决问题-5" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>降低访问复杂系统的内部子系统时的复杂度，简化个护短之间的接口。</li><li>减少系统的互相依赖，提高灵活性，提高安全性。<h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3></li><li>不符合开闭原则</li></ul><h3 id="举例实现-1"><a href="#举例实现-1" class="headerlink" title="举例实现"></a>举例实现</h3><ol><li>假设你现在需要购买一台电脑，在购买这个过程中，有很多不同的步骤需要完成，如选择操作系统、购买CPU、选择显示屏尺寸等等。然而，如果你并不关心电脑内部如何工作，而只关注它的整体性能和使用方式，那么外观模式就可以被用来简化这个过程。</li></ol><p>具体地说，一个电脑厂商可能会实现一个电脑购买外观(Facade)，它将 CPU 购买、内存配置、显示器选择、操作系统安装等操作封装在一起，提供一个简单易用的接口让用户来购买电脑。对于客户端而言，只需要调用外观对象提供的购买接口就可以了，而不必了解具体的硬件和软件实现细节，大大简化了购买电脑的流程。当内部实现发生变化时，只需修改外观类即可，对客户端代码没有影响。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerPurchaseFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> Display display;</span><br><span class="line">    <span class="keyword">private</span> OS os;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComputerPurchaseFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        display = <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        os = <span class="keyword">new</span> <span class="title class_">OS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyComputer</span><span class="params">(<span class="type">int</span> cpuType, <span class="type">int</span> memorySize, <span class="type">int</span> displaySize, <span class="type">int</span> osType)</span> &#123;</span><br><span class="line">        cpu.selectCPU(cpuType);</span><br><span class="line">        memory.setMemorySize(memorySize);</span><br><span class="line">        display.selectDisplay(displaySize);</span><br><span class="line">        os.installOS(osType);</span><br><span class="line">        System.out.println(<span class="string">&quot;Your computer has been purchased!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCPU</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择不同种类的CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemorySize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置内存大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDisplay</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择不同尺寸的显示器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installOS</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">// 安装不同类型的操作系统</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerPurchaseFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerPurchaseFacade</span>();</span><br><span class="line">        facade.buyComputer(<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>为一个复杂的子系统提高逻辑支持</li><li>调用多个子系统完成逻辑</li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li>有两类对象：共享的享元对象和非共享的外部状态对象。享元对象包含内部状态和外部状态两部分，其中内部状态是不变的，可以被多个享元对象共享；外部状态是变化的，不能被共享，每个对象都需要单独维护。</li><li>将原本需要大量创建的相似对象合并为较少的共享对象，这样可以节省内存空间，并提高程序的运行效率。</li></ul><h3 id="解决问题-6"><a href="#解决问题-6" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>减少系统内部资源开销，通过对象共享，减少系统创建对象的数量，降低内存的开销</li><li>提高系统性能，减少垃圾回收机制的次数</li></ul><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><ul><li>对象共享会导致程序逻辑复杂化。原来对象自己拥有的内部状态和外部状态现在需要从外部导入。</li><li>对象共享是有限制的，即那些可以共享的对象需要满足一定的条件，否则无法实现对象的共享。</li></ul><h3 id="模式组成-4"><a href="#模式组成-4" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色类型</th><th>作用解释</th></tr></thead><tbody><tr><td>抽象享元角色（Flyweight）</td><td>定义享元对象的接口及需要缓存的数据，充当所有具体享元类的基类。</td></tr><tr><td>具体享元角色（ConcreteFlyweight）</td><td>实现抽象享元角色所定义的接口，同时需要为内部状态增加存储空间。并且可以接受外部状态（容易变化的状态），并根据外部状态进行相应的业务逻辑处理。</td></tr><tr><td>非共享具体享元角色（UnsharedConcreteFlyweight）</td><td>通常不会出现单独的非共享具体享元角色，因为非共享具体享元角色与单纯的享元模式没有什么区别。</td></tr><tr><td>享元工厂角色（FlyweightFactory）</td><td>提供一个用于管理享元对象的工厂类。主要用于享元对象的创建和缓存，实现对象的复用，减少对象的创建次数，节省内存空间。</td></tr><tr><td>客户端角色（Client）</td><td>通过享元工厂角色获取具体的享元角色，并访问具体享元角色中的相关业务方法。</td></tr></tbody></table><h3 id="举例实现-2"><a href="#举例实现-2" class="headerlink" title="举例实现"></a>举例实现</h3><ol><li>我们正在开发一个棋类游戏，游戏中有大量的棋子需要被使用。不同的棋子有不同的颜色和形状，但是棋子的功能（如移动、吃子等）都是一样的。我们可以复用相同颜色和形状的棋子对象，避免重复创建棋子导致内存资源的浪费，提高系统的性能。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋子的共享接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护了颜色和形状的内部状态，位置等可变状态外部传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteChessPiece</span> <span class="keyword">implements</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String shape;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteChessPiece</span><span class="params">(String color, String shape)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Set position for %s %s chess to (%d,%d)&quot;</span>, color, shape, x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Draw %s %s chess&quot;</span>, color, shape));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理棋子对象并进行复用。</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChessPiece <span class="title function_">getChessPiece</span><span class="params">(String color, String shape)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> color + shape;</span><br><span class="line">        <span class="keyword">if</span> (chessPieces.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chessPieces.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ChessPiece</span> <span class="variable">piece</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteChessPiece</span>(color, shape);</span><br><span class="line">            chessPieces.put(key, piece);</span><br><span class="line">            <span class="keyword">return</span> piece;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">ChessPiece</span> <span class="variable">piece</span> <span class="operator">=</span> ChessPieceFactory.getChessPiece(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;circle&quot;</span>);</span><br><span class="line">    piece.setPosition(i, <span class="number">0</span>);</span><br><span class="line">    piece.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalyan的训练计划</title>
      <link href="/2023/04/20/Kalyan%E7%9A%84%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/20/Kalyan%E7%9A%84%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="胸"><a href="#胸" class="headerlink" title="胸"></a>胸</h2><h3 id="训练计划"><a href="#训练计划" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210444548.png" alt="image-20230423210444548"></p><h3 id="蝴蝶肌夹胸"><a href="#蝴蝶肌夹胸" class="headerlink" title="蝴蝶肌夹胸"></a>蝴蝶肌夹胸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002229315.png" alt="image-20230423002229315"></p><h3 id="平板卧推"><a href="#平板卧推" class="headerlink" title="平板卧推"></a>平板卧推</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002522177.png" alt="image-20230423002522177"></p><h3 id="上斜哑铃飞鸟"><a href="#上斜哑铃飞鸟" class="headerlink" title="上斜哑铃飞鸟"></a>上斜哑铃飞鸟</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002305022.png" alt="image-20230423002305022"></p><h3 id="杠铃上斜卧推"><a href="#杠铃上斜卧推" class="headerlink" title="杠铃上斜卧推"></a>杠铃上斜卧推</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002830127.png" alt="image-20230423002830127"></p><h3 id="龙门架夹下胸"><a href="#龙门架夹下胸" class="headerlink" title="龙门架夹下胸"></a>龙门架夹下胸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423003136604.png" alt="image-20230423003136604"></p><h3 id="双杠臂屈伸"><a href="#双杠臂屈伸" class="headerlink" title="双杠臂屈伸"></a>双杠臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423003029827.png" alt="image-20230423003029827"></p><h2 id="背"><a href="#背" class="headerlink" title="背"></a>背</h2><h3 id="训练计划-1"><a href="#训练计划-1" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210334836.png" alt="image-20230423210334836"></p><h3 id="高位下拉"><a href="#高位下拉" class="headerlink" title="高位下拉"></a>高位下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423164327463.png" alt="image-20230423164327463"></p><h3 id="坐姿划船"><a href="#坐姿划船" class="headerlink" title="坐姿划船"></a>坐姿划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205735398.png" alt="image-20230423205735398"></p><h3 id="直臂下拉"><a href="#直臂下拉" class="headerlink" title="直臂下拉"></a>直臂下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205851519.png" alt="image-20230423205851519"></p><h3 id="窄距高位下拉"><a href="#窄距高位下拉" class="headerlink" title="窄距高位下拉"></a>窄距高位下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205942885.png" alt="image-20230423205942885"></p><h3 id="俯身划船"><a href="#俯身划船" class="headerlink" title="俯身划船"></a>俯身划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210151270.png" alt="image-20230423210151270"></p><h3 id="宽距坐姿划船"><a href="#宽距坐姿划船" class="headerlink" title="宽距坐姿划船"></a>宽距坐姿划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210236422.png" alt="image-20230423210236422"></p><h2 id="腿"><a href="#腿" class="headerlink" title="腿"></a>腿</h2><h3 id="训练计划-2"><a href="#训练计划-2" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211817734.png" alt="image-20230423211817734"></p><h3 id="坐姿腿屈伸"><a href="#坐姿腿屈伸" class="headerlink" title="坐姿腿屈伸"></a>坐姿腿屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210829948.png" alt="image-20230423210829948"></p><h3 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210950628.png" alt="image-20230423210950628"></p><h3 id="倒蹬机腿举"><a href="#倒蹬机腿举" class="headerlink" title="倒蹬机腿举"></a>倒蹬机腿举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211530323.png" alt="image-20230423211530323"></p><h3 id="俯卧腿弯举（腰部不用力，屁股不撅）"><a href="#俯卧腿弯举（腰部不用力，屁股不撅）" class="headerlink" title="俯卧腿弯举（腰部不用力，屁股不撅）"></a>俯卧腿弯举（腰部不用力，屁股不撅）</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211715526.png" alt="image-20230423211715526"></p><h2 id="肩"><a href="#肩" class="headerlink" title="肩"></a>肩</h2><h3 id="训练计划-3"><a href="#训练计划-3" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212631090.png" alt="image-20230423212631090"></p><h3 id="史密斯推肩"><a href="#史密斯推肩" class="headerlink" title="史密斯推肩"></a>史密斯推肩</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212110581.png" alt="image-20230423212110581"></p><h3 id="哑铃侧平举"><a href="#哑铃侧平举" class="headerlink" title="哑铃侧平举"></a>哑铃侧平举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212222249.png" alt="image-20230423212222249"></p><h3 id="蝴蝶机反向飞鸟"><a href="#蝴蝶机反向飞鸟" class="headerlink" title="蝴蝶机反向飞鸟"></a>蝴蝶机反向飞鸟</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212320016.png" alt="image-20230423212320016"></p><h3 id="绳索前平举"><a href="#绳索前平举" class="headerlink" title="绳索前平举"></a>绳索前平举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212411999.png" alt="image-20230423212411999"></p><h3 id="绳索面拉"><a href="#绳索面拉" class="headerlink" title="绳索面拉"></a>绳索面拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212537833.png" alt="image-20230423212537833"></p><h2 id="小臂"><a href="#小臂" class="headerlink" title="小臂"></a>小臂</h2><h3 id="训练计划-4"><a href="#训练计划-4" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213030936.png" alt="image-20230423213030936"></p><h3 id="哑铃手腕弯举"><a href="#哑铃手腕弯举" class="headerlink" title="哑铃手腕弯举"></a>哑铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212818644.png" alt="image-20230423212818644"></p><h3 id="反向哑铃手腕弯举"><a href="#反向哑铃手腕弯举" class="headerlink" title="反向哑铃手腕弯举"></a>反向哑铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212903715.png" alt="image-20230423212903715"></p><h3 id="站姿体后杠铃手腕弯举"><a href="#站姿体后杠铃手腕弯举" class="headerlink" title="站姿体后杠铃手腕弯举"></a>站姿体后杠铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212958122.png" alt="image-20230423212958122"></p><h2 id="二三头"><a href="#二三头" class="headerlink" title="二三头"></a>二三头</h2><h3 id="训练计划-5"><a href="#训练计划-5" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423214003078.png" alt="image-20230423214003078"></p><h3 id="杠铃弯举"><a href="#杠铃弯举" class="headerlink" title="杠铃弯举"></a>杠铃弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213308228.png" alt="image-20230423213308228"></p><h3 id="直杠臂屈伸"><a href="#直杠臂屈伸" class="headerlink" title="直杠臂屈伸"></a>直杠臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213746793.png" alt="image-20230423213746793"></p><h3 id="哑铃颈后臂屈伸"><a href="#哑铃颈后臂屈伸" class="headerlink" title="哑铃颈后臂屈伸"></a>哑铃颈后臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213730391.png" alt="image-20230423213730391"></p><h3 id="牧师椅杠铃弯举"><a href="#牧师椅杠铃弯举" class="headerlink" title="牧师椅杠铃弯举"></a>牧师椅杠铃弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213700395.png" alt="image-20230423213700395"></p><h3 id="绳索颈后臂屈伸"><a href="#绳索颈后臂屈伸" class="headerlink" title="绳索颈后臂屈伸"></a>绳索颈后臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213846270.png" alt="image-20230423213846270"></p><h3 id="练前篇"><a href="#练前篇" class="headerlink" title="练前篇"></a>练前篇</h3><ul><li>训练前一小时,一勺蛋白粉</li><li>训练前半小时上氮泵和肌酸</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2023/04/18/JDBC/"/>
      <url>/2023/04/18/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC学习笔记"><a href="#JDBC学习笔记" class="headerlink" title="JDBC学习笔记"></a>JDBC学习笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC(Java DataBase Connectivity)是Java编程语言中连接数据库的一种标准规范, 其提供了访问许多不同类型数据库的标准化方法，使得Java程序员能够很容易地使用数据库和执行SQL查询，从而方便地与任何数据库进行交互。</p><ul><li>本质上JDBC就是用来操作关系型数据库的一套API。</li></ul><p>JDBC API包含两个级别：</p><ul><li><p>JDBC API：Java应用程序通过这个API与JDBC管理器通信。</p></li><li><p>JDBC 驱动程序API：这个API定义了Java应用程序和JDBC驱动程序之间的协议。</p></li><li><p>JDBC可以为所有主流数据库提供统一的访问方式，从而有助于加快Java开发者的工作效率。</p></li></ul><p>下面是个使用java语言操作关系型数据库的一套API</p><h3 id="导入jar"><a href="#导入jar" class="headerlink" title="导入jar"></a>导入jar</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304172257201.png" alt="image-20230417225731159"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304172258423.png" alt="image-20230417225839387"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Connected to database successfully!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: unable to load driver class!&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: failed to connect to database!&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304172301062.png" alt="image-20230417230155033"></p><h2 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ul><li>驱动管理类1.注册驱动2.获取数据库连接</li><li>与各种关系型数据库进行通信。</li></ul><p>以下部分方法：</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>getConnection()</td><td>连接到指定的数据库，并返回一个连接对象</td></tr><tr><td>getDriver()</td><td>返回一个具体的驱动</td></tr><tr><td>setLogWriter()</td><td>设置当前应用程序的日志Writer对象</td></tr><tr><td>getLogWriter()</td><td>获取当前应用程序的日志Writer对象</td></tr></tbody></table><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li>表示与特定的数据库进行连接。</li><li>一旦获得一个Connection对象，就可以使用它来执行SQL语句。</li></ul><table><thead><tr><th align="left">方法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">createStatement()</td><td align="left">创建一个 Statement 对象，用于执行静态 SQL 语句并返回其生成的结果。</td></tr><tr><td align="left">prepareStatement(String sql)</td><td align="left">创建一个 PreparedStatement 对象，用于将参数化的 SQL 语句发送到数据库。</td></tr><tr><td align="left">setAutoCommit(boolean autoCommit)</td><td align="left">设置是否启用自动提交模式。如果启用，每个 SQL 语句默认作为事务处理。</td></tr><tr><td align="left">commit()</td><td align="left">使自上次提交以来所做的所有更改成为永久性更改，并释放 Transaction 对象当前持有的所有锁。</td></tr><tr><td align="left">rollback()</td><td align="left">撤销自上次提交以来所做的所有更改，并释放 Transaction 对象当前持有的所有锁。</td></tr><tr><td align="left">close()</td><td align="left">关闭此 Connection 对象并释放与之关联的所有资源。</td></tr></tbody></table><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><ul><li>能够执行静态的SQL语句，并返回产生结果。</li><li>代表在数据库上执行的SQL语句的接口</li></ul><table><thead><tr><th align="left">方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">executeQuery(String sql)</td><td align="left">执行给定的 SQL 语句，它返回一个 ResultSet 对象。</td></tr><tr><td align="left">executeUpdate(String sql)</td><td align="left">执行给定的 SQL 语句，它可能会影响数据库中的任何数据。executeUpdate() 方法返回受影响的行数。</td></tr><tr><td align="left">execute(String sql)</td><td align="left">执行给定的 SQL 语句，该语句可能会返回多个结果。execute() 方法返回一个 boolean 值，指示第一个结果是否是 ResultSet 类型。</td></tr><tr><td align="left">addBatch(String sql)</td><td align="left">将给定的 SQL 语句添加到当前对象的批处理命令列表中。</td></tr><tr><td align="left">clearBatch()</td><td align="left">从此 Statement 对象的当前命令列表中删除所有命令。</td></tr><tr><td align="left">executeBatch()</td><td align="left">提交一批更新命令到数据库。executeBatch() 方法返回一个 int 数组，它表示批处理中每个命令影响的行数。</td></tr><tr><td align="left">close()</td><td align="left">释放此 Statement 对象使用的所有资源。</td></tr></tbody></table><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul><li>执行查询后返回的对数据库的结果集表示。ResultSet是一个接口，它包含了一个表的所有行以及每个行的各个列的值</li></ul><table><thead><tr><th align="left">方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">next()</td><td align="left">将结果集中的光标移到下一行。</td></tr><tr><td align="left">getInt(int columnIndex) 和 getInt(String columnName)</td><td align="left">获取指定列的 int 类型的值。</td></tr><tr><td align="left">getDouble(int columnIndex) 和 getDouble(String columnName)</td><td align="left">获取指定列的 double 类型的值。</td></tr><tr><td align="left">getString(int columnIndex) 和 getString(String columnName)</td><td align="left">获取指定列的 String 类型的值。</td></tr><tr><td align="left">getDate(int columnIndex) 和 getDate(String columnName)</td><td align="left">获取指定列的 java.sql.Date 类型的值。</td></tr><tr><td align="left">getTime(int columnIndex) 和 getTime(String columnName)</td><td align="left">获取指定列的 java.sql.Time 类型的值。</td></tr><tr><td align="left">getTimestamp(int columnIndex) 和 getTimestamp(String columnName)</td><td align="left">获取指定列的 java.sql.Timestamp 类型的值。</td></tr><tr><td align="left">getObject(int columnIndex) 和 getObject(String columnName)</td><td align="left">获取指定列的 java.lang.Object 类型的值。</td></tr><tr><td align="left">wasNull()</td><td align="left">如果上一次获取的值为空，返回 true。</td></tr><tr><td align="left">close()</td><td align="left">释放资源，关闭 ResultSet 对象。</td></tr></tbody></table><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><ul><li>继承Statement接口，但能够提供高程序的性能和安全性，对SQL语句进行了预编译处理，并且可以通过参数化查询来防止SQL注入攻击。</li></ul><table><thead><tr><th align="left">方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">setString(int parameterIndex, String x)</td><td align="left">给指定的参数设置 String 类型的值。</td></tr><tr><td align="left">setInt(int parameterIndex, int x)</td><td align="left">给指定的参数设置 int 类型的值。</td></tr><tr><td align="left">setDouble(int parameterIndex, double x)</td><td align="left">给指定的参数设置 double 类型的值。</td></tr><tr><td align="left">setFloat(int parameterIndex, float x)</td><td align="left">给指定的参数设置 float 类型的值。</td></tr><tr><td align="left">setLong(int parameterIndex, long x)</td><td align="left">给指定的参数设置 long 类型的值。</td></tr><tr><td align="left">setDate( int parameterIndex, Date x )</td><td align="left">给指定的参数设置 java.sql.Date 类型的值。</td></tr><tr><td align="left">setTime(int parameterIndex, Time x)</td><td align="left">给指定的参数设置 java.sql.Time 类型的值。</td></tr><tr><td align="left">setTimestamp(int parameterIndex, Timestamp x)</td><td align="left">给指定的参数设置 java.sql.Timestamp 类型的值。</td></tr><tr><td align="left">setObject(int parameterIndex, Object x)</td><td align="left">给指定的参数设置 Object 类型的值。</td></tr><tr><td align="left">setNull(int parameterIndex, int sqlType)</td><td align="left">给指定的参数设置 null 值。</td></tr><tr><td align="left">executeQuery()</td><td align="left">执行带参数的查询并返回 ResultSet 对象。</td></tr><tr><td align="left">executeUpdate()</td><td align="left">执行带参数的更新语句。</td></tr><tr><td align="left">addBatch()</td><td align="left">添加一个批处理命令。</td></tr><tr><td align="left">clearBatch()</td><td align="left">清除所有之前添加的批处理命令。</td></tr><tr><td align="left">executeBatch()</td><td align="left">执行所有添加的批处理命令。</td></tr><tr><td align="left">close()</td><td align="left">释放资源，关闭 PreparedStatement 对象。</td></tr></tbody></table><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul><li>常见的数据库漏洞，攻击者利用应用程序对输入数据的过滤和验证不严格，将恶意代码插入SQL语句中，获取到未授权的数据或者执行恶意操作。</li><li>SQL注入是一种比较隐蔽的攻击方式，因为它可以绕过应用程序的认证和访问控制，进而直接利用存在漏洞的SQL语句进行数据库操作。</li></ul><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><ul><li>在实际开发，为了管理连接池和数据源，可以用一些第三方连接池框架，比如C3P0和Druid等</li><li>DataSource作为一个轻量级的数据库连接池，可以大大提高系统的性能，扩展和维护性。使用DataSource时，需要先配置驱动类名，URL，用户名，密码，初始化连接数量，最大连接数量，超时时间等。当应用程序需要连接数据库时候，可以从数据源中获取连接来执行相应操作。</li></ul><h3 id="DataSource的获取与释放"><a href="#DataSource的获取与释放" class="headerlink" title="DataSource的获取与释放"></a>DataSource的获取与释放</h3><ul><li>通过JNDI获取DataSource对象时，通常需要进行初始化，创建一个InitialContext对象，将相关的参数信息放入Context中然后查找数据源。使用后，需要将连接释放会连接池。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化Context对象。</span></span><br><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialConrext</span>();、</span><br><span class="line"><span class="comment">//根据JNDI名称查找DataSource对象。</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource)ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/mydb&quot;</span>);</span><br><span class="line"><span class="comment">//从数据源中获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"><span class="comment">//使用连接进行数据操作</span></span><br><span class="line"><span class="comment">// ..........</span></span><br><span class="line"><span class="comment">//释放连接</span></span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据源的配置方式"><a href="#数据源的配置方式" class="headerlink" title="数据源的配置方式"></a>数据源的配置方式</h3><ul><li>DataSource 可以通过XML或Properties文件进行配置。对Spring框架等，也支持java代码的配置方式来获取数据源</li></ul><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><ol><li>为每个线程创建单独的Connection对象。可以使用ThreadLocal对象来保证每个线程都有自己的对象</li><li>连接池管理连接资源，能够对连接对象进行有效的监控和管理，从而避免了多个线程竞争同一个Connection对象的问题。允许线程取走，但是使用后归还连接池，供其他复用。</li><li>确保事务的独立性，每个线程会开启事物，提交或回滚事物，可以保证多个线程之间不会干扰彼此。</li></ol><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>将多个命令按照顺序集成在一个文件中，批量执行的技术。通过一系列脚本或命令来完成。</li></ul><h3 id="Statement处理"><a href="#Statement处理" class="headerlink" title="Statement处理"></a>Statement处理</h3><ol><li>使用Statement对象进行批处理，通过addBatch()将多个SQL命令添加到一个批处理中去，并使用executeBatch()方法来执行批处理。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">statement.addBatch(<span class="string">&quot;INSERT INTO user(name,age) values(&#x27;Lily&#x27;,18)&quot;</span>);</span><br><span class="line">statement.addBatch(<span class="string">&quot;INSERT INTO user(name,age) values(&#x27;Tom&#x27;,20)&quot;</span>);</span><br><span class="line">statement.addBatch(<span class="string">&quot;UPDATE user SET age=&#x27;19&#x27; WHERE id=&#x27;1&#x27;&quot;</span>);</span><br><span class="line"><span class="type">int</span>[] count = statement.executeBatch(); <span class="comment">//批量执行SQL语句</span></span><br><span class="line">connection.commit();<span class="comment">// 提交事务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PreparedStatement处理"><a href="#PreparedStatement处理" class="headerlink" title="PreparedStatement处理"></a>PreparedStatement处理</h3><p>同上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">INSERT_SQL</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user(name,age) values(?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(INSERT_SQL);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">18</span>);</span><br><span class="line">pstmt.addBatch();</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">pstmt.addBatch();</span><br><span class="line"><span class="type">int</span>[] count = pstmt.executeBatch();</span><br><span class="line">connection.commit();<span class="comment">// 提交事务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Spring批处理实现大规模数据库操作"><a href="#Spring批处理实现大规模数据库操作" class="headerlink" title="Spring批处理实现大规模数据库操作"></a>Spring批处理实现大规模数据库操作</h3><ol><li>一般要创建Job，Step，ItemReader,ItemProcessor,ItemWriter</li></ol><p>Job：批处理的最顶层组件，表示一个或多个并行 Step 的顺序运行。可以将其视为一个顶级容器，可包含多个 Step。</p><p>Step：是 Batch 处理的主要单位，表示一个任务步骤。可以对每一个步骤进行配置，比如设置读取文件、处理逻辑、验证等。</p><p>ItemReader：用于读取数据，通常从文件或数据库中读取数据。每次读取一条数据进行处理。</p><p>ItemProcessor：对 ItemReader 返回的数据进行进一步处理，可以对数据进行过滤、转换等操作，比如将一定格式的文本转化成 Java 对象。</p><p>ItemWriter：根据需要将读取到的数据写入到指定位置，如写入到数据库、写入到文件等。</p><ol start="2"><li><p>配置Job和Step<br>需要创建job和step的配置类，这些将负责配置Batch的核心组件，数据源，事务和监听器，通过XML文件或Java Config 进行配置，实现Batch批处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobBuilderFactory jobs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StepBuilderFactory steps;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Step <span class="title function_">step1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> steps.get(<span class="string">&quot;step1&quot;</span>)</span><br><span class="line">            .&lt;String, String&gt;chunk(<span class="number">10</span>)</span><br><span class="line">            .reader(reader())</span><br><span class="line">            .processor(processor())</span><br><span class="line">            .writer(writer())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Job <span class="title function_">job</span><span class="params">(Step step1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.get(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">            .incrementer(<span class="keyword">new</span> <span class="title class_">RunIdIncrementer</span>())</span><br><span class="line">            .flow(step1)</span><br><span class="line">            .end()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义具体的 Reader、Processor、Writer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>定义 ItemProcessor、ItemReader 和 ItemWriter<br>Batch 模块提供了大量优秀的处理器和读写器，这些对象可以快速地实现批处理任务。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络管理员</title>
      <link href="/2023/04/15/%E5%88%9D%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98/"/>
      <url>/2023/04/15/%E5%88%9D%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ccf35bf09b0b55d6ca9e165c47ef22fbae1915021c4ae5c17b2c2d97c4797a08">bf490c8d2c5f5e906426eca9095b23328bdb3b4fa6556d344fad61b74f847d66c15a3e5e1272591eb66b63959944d545105c950a88924570f27073ec08909cfcff3296c492adca76cdbceb0b4d7270563bd44778d4f9627864d33ece6fb1a5604283600248583d3b4973e163e3ee6a6b394a084b11b7d49492a9e5e5bef1cf4af5cd32511c16d7df2fb8541b4ff064bb4500b93fb2ff8ce77a3331a05f1ac068534a656afb4eefdb76ba565743a491775150ed603c0ae8ef156ba742526a90dc84e93be61921e6709a47a743d2c66e07236c1ffb1597484dec727ea4ce12af9fcb019fba3c3baa189216c6e0e3f562246dc5aa906e221fb6ce287c7ed49c70976d77e54fc64cca7336ba5b691ae916cfca9f97bdc53e9010026b70d97816b6e50a515433dfb7c45ab18f7e2c9d416c4a4abe2b50260cd3ed186e8a723f9810643b8d2b474cf3906b04a1611f6b6cc9c48ece0c3010e7bbc343833f60c0515669a013172060c2e38f863fd58371278cfc145e8f03fe869e2df3200d0c588fa68ecee983037f3dd676ac9742d02fadedad79701ea19c28e70558b8dea789b27194736757f0c84fe9850b3165b22976d5bf71cc075809084202cf51f1ce25e6ab77ff9f68b268b283c93d3af196752851a3fdf03b50104f0339401f24442919b5cbfc56681048bf5df4c3d5daad494e1a1ff09b89bc09fc7ff59c11d901ea1149b9489c285c9911175b08b3f0bbf0e527fd96d7d7f2e86ca33219ebdf4135a55db5d882940cd4b4ff06d7959fb560c0eccdb0e94bae1a876952a38f4e0d5e580f2dc85a845681f5166b9cdd029404321949bed2d6b6ae43f5e27f495f030671fd2938fa113233dedd01e2a8b9b138f016ffc9075b3835ca637131eb193110783f52c03dd6a4c694cfc58b91d57039832c75da02218979d7e6d1ff788fbd9259155d5bbb1bf1e27ca86c57294f7d479044d7f22554991c74e3d254107554a49ef9541c1d4a94bc5781f7b49b194f188d8e4a85d18eb25ca0e7fb56f9a81299933742eb854ff4b1f61519c26477f0159cd9c1327c16b5b149b30c9694f4bf1b72900f6a2c9d7bb73f77a88593ab5150644afa579974cbd935b11c8910132b4d8d5e3f842852746eccc7ea3cdfe9c7797aad259e2a5f7013aec8070ac0831078693ab1e09be63cce57c881638df0c5282c3a6e106ef4c1ce9b381002423c533f7639b5d131b5d5c50c0aeaf52250e4b0fc7d83bcb81cd91d2a7d035733c404f0f86167a396a23c0fe230f0fffc1e099dbcd77d20dccf56abc805d981d2d13f22656f443bfc52fabd36ad7685c990253706905aecb4f7719fb6cdcf75eb25a7d1f26ceab97cb2b3827d4855afad34ecf3cb27de93ed4976727275734ab450f52a5642828006380bb4892b509de42e770bf5175b957861f25657bd80523d77696e4873474718a92d686aafe234b6fa6c279b5865979676932626a9af89d3a6207798b09d8050968160493ea95a2d170ba61944a0420c75e2dbc20ff3decb3c1dd053dcb8434321d5ac23ae89a26bffa14d25d797a244a2cd014d220c3dff645c34273803d0589e1f78b0caee7156c2076d3f286d7ec718b28c69bd2d3dc7a7a41d06a8d43f40bc4ffcfde99908bb0e627679a3c457c7dcf580d4449e643cb4b5d587a82ba3cf7054758f21acb528b74b77bf6dfc362333660c72070741ef7c159cc0efbd76fd53864776ed38e1d6fa6b8826e912f55c063d9d7af31421986ac10dc567387d848a18263b325033b00ab627983cb0eb5a1f2ed06128a38aa0fc2b732335b79ae72b1082d7c276f14b0a1cd1a6322ce85991bfd5c17c591e33e985b6251993607de707ab83d825cf5e6fb67b45307a6ab3eb3e40cd9a649807274cbcd68c23a91bae0c993d1481474a5868c99f1b31fb3b3d3da5bf588dc14565ffea0d91b0fc7051e713ada0edf1aabd8152d1560dd3ad84617365af3063d19a8e022b9fe91fe2b010c1a9a772dd2615e67c277a7e74eb6c15f67ce4f81ba74187d2ec4ce52ac39863dcff17f19045d9b7e541d9ac1074c5da939a294a796b1a68fec193e52c8ec4eb2f34de95cdb91dc2290414fb61166352b331571c8cc0d9f9947ba56ed0db24c8818c023562862a0d0ef649b09c6d4a9b0a5eb17a5cd45159b071afa925accec519bfe508dac73962522e2a3e08d56875e89dde7e6d7d4a2bbd18aed2309fb1847a2cd6ca00a25a1a7a832935e66500a220edeba1347e0b5ad736ea8c2954df8b07f293657a3fe0575cfba766a1acb77280b3a966296b00bcdbffc5b161bf8e48d78c14717fe76a76ca8e17415ece26a3429174674c572d12c4f4867d83649c1f24db17714d6dd24568edbd3543f32ac5719a57dfdab1f5c5b61eaa1f0637a34fa9679edaef758a453009eb66e1649858982e58da38af1a1b469f6d3ab36c2b21f317f41c9b2dc0a97eb1e94b82e11715858f2ad2a3354cfac58e44d1e533c6e4b59f45467fa22cf90fa33e97386a2cddc961693451a2b6e120094b5d4bb09a6779c68573cb062591225eb81e46fd487153ef258a011e0815506c44e95b8dcf253a9084c4d1c7cc92c42298713aa4094ae6d11689f5d819bacc3a5ad19013365ffead5f9c1323e897272921ae0b4a6d3f309ee9331294ca93dd1c2f187e6b0f4f008ddbdbf5f0add9b05ee91133243e19eb765a34e0c5bf7d18c77860ace1382e876c2f9fe9c40fcc9c3a42c27ed5442e674ab0442baaac3c6bce41010c299603c0b7564f63ab5b4ade8a820fafbe9fe4962e6860bafc6cbc750289ad18112833c4f4982cabe3e829db31c5ae3f1b50ef848c123a09d5fb1faabc71e848323e14bbbd37726d91d811961f73064aaaa08b6abed2d5aa8eb8aa1968ad646e30dd6f697b8f9c6f8e9207cf275094be07d3e5d16c92849d60df887854d2438245da18280fe8977cc4e382b8e9a86a5e66eb4a04303effdf826429957f42f9a96da88cfec36423924b713a5fcefd6e25c81a5aef9fda83c4093b7971ae68d2f1e6336e92f206064242a77be29c88749db8651a6dba05801f79aa9a893796dc4bd2200ed4264a295459e358e6da97227e1cbb554386c734be35580d6ca0e90c8a5416402125496310c166017033f1a34c5265d8bd70ea371bcdde51390f31193c635a67d346659609919b4e578bae061b83286750627bac66c98418730f795d8b59f4ea8f33d7b1c74abbfa8b223dd3fb6a605ab1b08626e0a5464d0df7deb02196ec587c9c858cf8cf5d9f795fffa40194f9a1a5886208d48d86cdc9ef5e102bf6f39435aa4653aa6f283310f5381326d84bb95693fb5cfb5faa4d9de564ea0836174f9431e5e842038d88ed9f8cbed5ed164f7dbaedcc4e7035d7eb0dddea665297b0b8a9d5b32361c0b16fd9e43ebc492474464944f079a119b9021890ea3fb84bc19684343783af38cbf848012d10392960a89e1c9b850fbfbe27c07eefc76870c1082d9fbc9415e9b261f966944b18ca694d348d2c9b13f25bba68ba534892f5934828c1b0b640fd9cfcc9dad4ee11e2425e07b4c7d6b3ce789256eceda466bc26885dcc04936d9df8c9cc1bb54c9113cd1373ebcaba4cd38cb00b93b31cc840db50c8d946533301be2faed513854b190e0deeb396ad37cc73ce1d60792a8308301852a7fe6be84c068c79c527686781d4e219f305961fb0dfe3b019d01b613799f57779400625457c4fa3949fa0c6ba67bf6bec90e745a038ad74362c0f3befd137ce2ec6b6def5228db7661935157749ab6ac5baa7ddab2aee72cc7bea7cd1fae0910e480a56f4269d32d33f2ec0f869471ad0b7281e419a3d678ee96c80d8e0a5d90903c95f944f0ab1f0a0c00529f40e3cf3777731faaebf3c90f37e6d32bfadb40c3f5a03113deab42c527ac8e36932da62ae4e5215f2da16ad83347ba120a17a2a0eec0e43596bbe1339126b9bca34ce741a29c809e357963102879ac6374348aadaaff83bb143a6528462efef0ec6591a7ac327fb6bf4514dbc26693cb1f28f67e9cf9b604f89cadc66462ebec5e476867c35643976bf2e3c0332f9c67f71d75901c21fd7ef9dc43f6e0fe257cc7c50969478492d2baaa5625a33d5b48897e3f5603689b5130960084fafb420a9d4fd959ddf9191e610908d0c33cdd3c383b6a0b9df770c6bbc05a8d653a79be973c71012d2f11a4cc792d3b15c3a4ba5b1a0843713fce57c90d4e67283ecef332964909a3aadb9e2ce74fa888ef0e5ba95af2c8e64a634eae0952fb7d9e9fc521f9269bfbf99fee27b19dab8c6e2542ee54dd808095c0511476db285460d28fbed5eef12ce0cce14f9d5aef7c4f211530faf0399503c768076c23d6cd7115b969d171055ccdccc2116e459d437dc7afdd2fe4d8a4561aefe3669beb1b5dcd57cb3a857ce497d3cc790c3ce7493741696d228524556eb35ad8714fc3777584b4dcb63b682cf34328be37a79db839ab1e8f1bbb8fc62bce98447db0f3d24a21b3f4ec3a3e6c4de596cfd16d861b564870363a2ef458a014f3d89fbdbee17a5c0120ca1cae872bece7cb9423489a811543e25141a062e2b09830ed5e381a294c375b77cca76b1e4d078e3c77d4f4be8e79ba828b81ea7212a0577da3a096fec4cc3390d8d8d747088000f899f00d3a2053c6774dcfeff71a103b8e3528f9b3b29d42342f26fd8ce12d049108dead93b80930f37df16f4ffc2e55e55cfd37c70ccafaf1f2d8c0be7073fb6b92820ef9355f91f16c768182f151d22cf38a30ce9eed07ebb0169b4a9f39ac47f1793e5923670a2f10ca57a33eedab112f433795a9f3c68d0c2e3322c6d053e4abeb4bceed0e45123232b624c7d5296110c82a0e91a56146ac093ca23dec1fd5d587d04453cae9c3f8d91218ea3ab7b80d3aed681d05414e633a3dde9326dff01b38f7d141dab76357d7eacc221bdc2ee0847ccd3fa9c11a142af346ff8ecc9ba29b2dc91de50fec909f5fcc11df880f64f55b6689297ee64c9eec7628447709ed0c24e2b7baf1ae66d7d6fda1c27d076ec25eef1fb74a6808f8e1dc5c5a5b3fd402f77e06bbe49c769b0db30e405990b5831c0849d1a0a2067deaaa02453424d4c49bcf4773bc8e2e4b4fb776b61fab12fda1815c4e361aee8514ccf745fa29de856cdb18363a43e3efdbfd9b4a10c5e96df3a7adc71017023ef8264a98c90a4271c43347b32ee98b49d3c607c7a18995734ed073df1a4097dbcf0486f3e48e74c353e34765338b1ba4a6e5e5984907a0b6931ca16a9765e751f4cf634f84f0c0616eabe7c4800fff15f8f4614b253174979b3fa3183e04086018de8392802a583cba9ef5a13aab696ca2c0aa558b8c0be0e0dcbc8c5548250e04bbaf3fd2f12efba40fb27f694aa1ac109f52408ba22cd9b15b269bf6e8636a4632025f2a8a1e16f3f6c89888b7cc15c55c7eeb878c8e7d0d5bab88bc8eca2f7708945dd599b236f55d42179e0b2b081b53acb1670ab895c753b6a1fb18fec5d29db68a345659ae2114a85e870eda374c0e17940d9f0a2b523d8bd119ba6839c025791738a7ba991a61ad91f5011cd62e5451fbfe107541ad3633b69a689daed6e3b61b10c23c3f6d3fccdce1f99457265847e021f0db5e7569df06b99c15493ee37cd4f0828107c4b46bf472a9f55b50dbac9a25254f59567c9691047e7b3b81fa097747a5b85195983e076f208725b39111fc6a85783623dd9df555beca49db42d38ff0ab43f54afb0ca411ad42b8e72085751e66568a8cfbe40fe03024f96f39a2a8f14070bff5cae4ce5fcd641aec8e89b37bacb052347bb8891fc44899bcd473b0cfa066e6e5f0e40c672b2c0139223830ee4887aa1e9e1c2931c20a8a887b8da7f424760896e992c041543667a82d0634882b5c8ac1a3f7dcde296a9864be2b8b7b466ec4df6143f6c699ec85cfd5ca08867a4efb2bad9f0d9cd4b097491e0208900e125b24c2d2592ee4e378bc5de1a2a3433f8810ff50bff45f6a547ae6112763e6f9e414bc6aac4952800b37c775c198819aa43c2365d9255dfdfeabc01db285d880c24d7d40775a22283c750380489c5074e2417a7d749c4f036b59104228b568e79108344053f6310c2f6f01def5761550cd298dcddb515db4134ffc4889a9db8531177c482e92c6b40f598a83911179d47c8e35be0bd4c40788c41420363f22c9615ae38d0b9c232ef6dc68696316be350abc4846abf95dd755c2269001bcc99050e543f183e98baff3eff11a3700d8389bbc4d3d5351f637ac531e054192b91024b066acc933fefba296297977ace08b6d91c303045adc07bf404f38ed879a753dfeedb006541d8eb7e477ff6fda79eacd3f00f954713ade561ac994895f03fcb9f5469c5733dc7df9036149ef10f2f5cbae3ca5152b86a3f8adc0aba638f72d481df656c7aedfd6cbe262ad95184244d0e32afc543802310674abc56db9c8883848b13cd4696230ac184675df83488a878bfb4463df36ccd442d54bf829efbd183a3641308085384d254cd7d7e12b4ccd7dec7eba06868a0bd388a99ad63cf62fff2d3b05b8fb99262e4c595636f1e2b2e673209aaf4fe2e2239765dc1bf1de44ef5e5eb2523900370c6e908802af967ead54bc18e4852f1241612b2c34f006a90f153f712af6a5dad3ac97b5a7616ca0465a75dd6fa8e0ee4e23b2704be01756d34f5809dfd61f43fe9962503160b6b8ce9a3f8156800f4d1f9450cc210e5c39cdd54bf55e105d115eb910452e28d067ebeb1f28bf29e2762d58e7785f0d35bce952c645b5f8392bd0036b515102b5b9838b51de9bf384743da21d1a85b7c4d9a1e52ccb4dd241d1cb2828a42ef237a3dbfaf555c19eecdc157aae6f98db8fe47bed656f4c10e5bd0c0e5315c6a9ec25e5715edfdbc1f04e666a101368f531b2a6fef2a9ac1b5f7546796486ab77d868b5046b749bebcb95ae554e42f862e7f36439a68c9029416bd9be445b894a6c076578a829207d863d42fcdae19426c8683a6189c3439dcb68f4d9ec6f41f3586cd274ee550865f16b4159fd9a1c6b65267de36357cc512534b8573283d5a84a990b1a78b10e5f2a4877ce6eb63f009bf2ea689155ff7cf640bdedcfbbad811ed2178fa09b1daaa132e906730bc24d044f55d1da02ad613fc41089bc734d9d71e3e6a1ffb03ab551e699bd0764c562c3dbe5da7f3b8c8302af5c2700002fc3a775bb606568d757eee8498c648a6744167a61e4a13042c31c3186f53e9e3452851f4489069866283b010d4a91bb2e3f29bcafb4f1b8cfc702b7d5115137844523a9c2c665b6ca6419b0358ca008e24f99ab00292c792d7f05fb0013c00ea39cfa9ab1c87fde45bec2588d8fabd7ab80ad925c4e2a9b0ad3d5b57377ea132da1279d642c637ca2e6b5aad813c7f565ef14e42db698788d3d0a614cc93d05d90c95ffa1985c35056c3f62620345b49962f8a4a1aefdd29d06e844426fc81db938b4276f42870b1c40d7b379058576d226e4416fadfc7216e18ad18ce35a4e0c1407833857383c42c5053c39ed9e1a8dccb70ae26131570ec530c7bea01852384a38a6f8038caec9ac5d141bad949bc540484cbf25aaa84c9f2156a3d850db228d2c6cf5c630ceb087738a869e505ac8b0e0fb67acbf1d9e18d3b255544facdc7dc67d419346d390a1f7ac1fe39f99c977d46a48d2c96c93ac81a8fd8a43df30f9904984c5994eda15ca691d6900e46e7203b5fb98f30ae9806d5b04ceb0d997a6df1c34f95c9e48fa499d2e7cc6f3b9bc1da4dd104b3152579d4a59ca6481cc4a568c6e4d0cf5f7da8b7e43ce65adcb5dbfc83da03722e186204d129933b7631db384e817ffa6351c87cfb882fe4c4284c12c9877a090e1d2c5246270bcd51ed3b52b9fe9cdd3cc24cb6b8cb16f59a886cbba082d6643388057e4a27d6a34ff3783b561efa147c4c9bd4f5bc35343e79fee8578bcd69e4f9fc7e8d25bb4ba2d0871be956f22c72df812339dd3b8681b126a55239dab9ec8f40361852c3f282d08871f740a15ec309ed792a994ac4583143c06673a8f7f3e72b1f33821a00c9cde9507538bcb22d59c529a746ba9b5fe44dac8ef3185260a50d0122de931852d9b4dccd3a6ad7e8d85fbf39327985e97182efd2236b5345f5f4c2d4169ca6375526468e20dbc3a92a98fcc812d251887b4930ff7e819db8cfb247900237e07bd558690879d06040e5757d2da128df10d4c7d65ab765cb534ab1f84bae9cac0dcd49cea9d9bb715e81667537e8656d154f63aa345fc081f0a41988ade094dab474eeade2433c19f1b600d590d6fa0dc616ecdd9e5dc4569245e6ba02e3bb0999898919b9b8c1c828b8c358b3141c781b1b6f375e0cc45dc8cf3ef8c8237e4a7a0c84baa7ec78af573f8bf12131b5fb7af031ebead0bbeb20b52972dde4173ed6f9373d7614032641311c802b3ecdc16422b8422e4045cf686ccb5ecdf8ed2f444dca0621a36b0593c847ca7b04954d8af7065699e0669ec5b34567e024f9b0fed859a4f361155230c51fc27f5d5eaabd91c13f93156d4e7d5cc0f27df3fe8a6785b71a23e683ca0dc5e54d6212d41cf3b9e38ad38255bcf8dba20e941bbff4ca3bd02ce9bb9f7a8ce6d8668914d66a2e4f753babcf424268e66fa05935d5c84eacd8578c328377e0665c8274edc77bd68909161a5c2c37ee806ccb8b7a13608a2b0e375f9281c0fee4de36e0d9f485a80e7fa9d0bf9169eb0e71bb9d18993277395d967d63e93e8d1a8a4943ee5da394e982c893c268bfb4a502e39f896b24f3228bba7b8ec826daeebbba4f3101261231ee450932704642f612931e13d1066866dcc973bd9d667947edf792b1f764bf9da9332f427f50ae2ce6005e7f2dea187437da28ea2be542dc01184ea534abfe41926df7bb917c7ea7eb97a4c4a64a6111325788add22700551704c853c3a476bcb6872bbb3964e78e145364e07c99a72fb3d3a8df536c9faabd31af689a554be0b3ff04dfa69c135969ff39d580a0945254852003328cfca3aa9cb7fb9ecfae091da6807b921bdf830b340238cd401d9a945b71e82ace9a1bc2cb9de0972003524e9b01ed647d212c7760c86eba18db1fa9933049d453e10ab56ad5248fa5826358a9a0a28b2639c3cdca26bce8f6413bbfdefd3cd2e065b9fe04658526134bac25ebd3e9773b6d9bae78820a561c92b650d3934dd73e54bcf2a51cee52c1cc8ee9401f55a9e30cf4c8fa4af121e808c3769bb7ffcbb1e3cfd25b498a99d6fefc2a22eab3441fc2cdf6f6a4c45ea63c35f6db544ac929f46b355871bcf3558dabe9e9b46a169ac09b20a0ed2bfb69f2b38a4c54c28c32df7a101f48342003cc31d21d2ad38651ebd3e6502c81b64336d87be290f0c8fbf77cdceec2261f6e857285938a0876ad836c8f9d865871713f47958ae37a1b9944526f0a4f311afde4043f787ef3116f0ffb97a1d1c07d7cd5550f9a0671613d19367b013a85b407041e0fcf8bef13c87c33d34e25909e4c8c7bacbc5e585886341b5b3dfc1ad7309763707f4aedc9962d096bbfedf5d41cf99e4c549b51e05d92496053cdf7ba41a7d5ecdcaaaf5e7c165b466e82e2f46bf6c5224117d402051f146663b24dbff9c0a74943bb77d0cb70a7c312c931f903d99957f396c2a29d8fabfda23e67c6a01e99bc3dc9b848bf5d5e5112c3e0b68bdfecd91c7c6b783b07d908ad2779f19e6728f4fadcb87cd4236ac38d4fb2829032248cc5a9326182cf942739e9915e0d143d70430c518de21d1c4045af631573544eb16a6b01429995e7487fdf06bcf58e536d709beb702617a7c5503a4a90eda1860ba3720a5f9424d2a9124b495ca88dc4bf1741030d8441ea9c5bf85f8a3a432be0e9cafe2661d5868b16bc0871c8ed13a88ab30146573ff21ababca2411d4523555a86bbc9f80c421ef0b9d6aa6e780ca5acfd3389e9c15039ce60e590cf21914874bdd27e18e5cdc3dbec49e5e4f7cc31cf737837a9ce12ff651d3be5f3fb12e5fa90b62db92dd73c5b1ebc2731802eec195330b112ea329f2c335bdf9108588adec6172b490edcb140966ecdcf7d263366137e94a5f9e46524214f052360e190f88b9666376b7f5c4102014b0c392b6873de61b5fa1e07d2748d77796b620fa7e7d2d970134888c206b61a8a2c6dd2fabae85b702c8bde0bafbed97a93c21fea096afd7498bb23022876501768821591d5a9039c8ace64ad74398be2befbe40aba753c1997ae81e8eaae08ac58a0f795a3568d2a695e37c14d8e46295b687df6309ed37a42bb05e99d00366342fdf1e3ca0e422eb9082c7fa71355045ef7bd903614361f1c9f92de67933f953580069f42dcf9041ef188856507090b8f4ca1fa1202f3e1e86b1e8f61a2d3c7bf82a74b96b7599a4a8675a73a477476f1e6fbdf1900a04b47ca2c1d6513b745d62de57fb5f0fbf517c158f854b3dc90bec727ceda5754c877563b6db06eeddd965d3dedfbeff245f56f234df5c68bb00c94fdcfcbbfb499339cd03dc566715748dbc02bb9639f734e79c0ff2d5ea93dd52e95ca0cb95de56e58cb9880b6a05d4f4adebbdcf0a0e5e08b6566236713896b5ed14207d79bbe5f54c82a2edc93e28324b197cee10f891dba16f52c7bae4542b77fb0f39ff36059f6507697e7b9d3f12bb4a073833714c6d34358d5c6f3b13afd9c9491a96e1f84f608fd93702b609c0daabfca6f2168d7d8d0b65b833e3b5d60d3d5c38623c964211ccfc4bdc6b4fe5e73761173a9dd04b42e8bd466786cb0b3e767dcf62d0d122ab3498efe51cc9eabebe64fa31008aa252d2a0c682f5bfff6640d4ffb83fceef75bf2fdf37ba1c8404f18819d90904812a31f9468709e61439394a848a385f58cab277ec2d7c97699c608be995d7841d033a4499ccf05bdb988a77a8f93d677147010792767a23e6162418c4761f57f0f076ba8deb932e84a56e693b61403c37ae4339256359f03180ebcbbc39d6d0edf63131e443155042b8318263abeb64b3532fcb1dd6fbd798067eb02b1441b68f01b79035f0ebc37f5e7b98776a486715bce202ff1d7c791afec3af782eb2544bdb55bb32b483e2110873eac4e7e6a0615835cf5f0c07896fd6f285480b8957c12639ddada77ef1237a0d173e34764dc79fdaf40bf59eeffc2637aef377d282a89b4893b94bd131cfab0ae4208b69158b67d07e55810df86a8fb9bf599ee0f8e773e37286e2141c26e5ef8d4ddf7afd6ffd63d4776b31c85c7ed3c11ef49914b515b1668f2f98f7f702897bf12206233e94d5bbc926af9cd8c2a83b94316294ae8e45bcfe7d280d33100a75cd482c4dd405dc7e0d8939d53ed46806f70856731955f7b225065b6613de7370b10b608b7bce87a33f79fd32c63a00480eb61bd2c3e7446b645bd7116c0552de336885ad10bbb934d63cdcf103909d865c55f7e2731df5d5842b9ffb35aed76754ef7f4474172190951880ca1b1f33527447fc689d9085c807bb19c7da63f98bbd201ec5ff3752b9c963e77946acc45b42ba7985b3da2e3d30b58780eee00c615ca972e4147acd21a939363290e18bd120a34f8ea9b59b5253a886b4425fa73fd174fd2c4b016adaf1fa79ad170455d6674e372b2387f1fae5f1d17b624bc85f710d049b3bd84cc012bd3d4251b9725a50a314aab898cb50aa82eec7ed43e02259f2af7cde288b7de83d2b086d5db39e3548fd86211ada87b3a3086201ed3abef7828775387b0e1252d753e6bf71cf2a071ec8b64957fc6065c0a9629e79f7c97212c8a70cacd980c0f4602fab03d6abf628241d61c7a4b6f8c09df8237d724c954be8909d8438424587a143b5ef5cb553106ce654751508255ec5f5768b6c8ec2bb1f8881f5fc041bc342c6c34c604375644063b1ab426ae4e47c0f794eddbe0fa76025bf6e8fbf29aac8a6dd94f1186493687a0ac82ebaf7867207f8c2eae7241aef8624f978a7711a0a9d1dfbec548f947eedbe08b35d852778ad79f3c66a1d00b970a875acc8bb63b279ab0d0a4ec79e7f9dedebcac14528a9f4113292c120331281e5028e3456e11beeb5e16c124d7c12eb35daebf50f3016706dfb7d08c73957d843d55b78cfdc1bb8542731df13eee89926ab0c9a2a719d3e52618808d0ac138d96601c901008f3d2bddff6ede1e9791e87cb1b67e6c2d1d99c10a317af1f8885eb43fb89048d8acb69e3ee702a4a2dbf2c9d7e5b24c5f066202fdb980e21391ed547be94efc2cfe088864f01f287d848648d9ed9f39c32e6f7a77e64e110ad7ba24905247978a56791efd1fd57e6549ec4d7a26caa8d8bd6a534d52fc85527da923d6e30cba358abf9235a6cdeea4816061a4e57aca9debf1de94fcc52e095f9615194b29c6a9e5cddf25fd3f125e05e140b940db1f78b4647611377f121bafbeaf9af517e4f4762ffe13842abe4538ed301c5d435c9ef6a5d08a2b1a13f29b86fdffe7bd127214e6bc2025012e550c40596aadb13b0e70b29a03919bb3a0200826cd4fd2206b6d8b7416a77f7a43b0197492422998daee3669ee5689b4919dc2bda27c47cc4699cc3a3cf875728e793c90d2e8d609841e2f7905bc24a355a18cd6b306f31ddf1072bb904cd849d3188e8f3b46df5e872ebc9e21755af688497f4f53216fddeae9187f1aa82793a22244b7617effb31d9b4f4a677fdff5fa7a01fcfc620d78e195508dc8ffe23f75b19826bb3f741c26fde24676dcb3e3c0418ada77e8dad12f60d4b995e4e0f503944881061d1894db271ca7971c70e5edc047634667c91f2fc3ac7a96e9e6a367ebd9c80b307fa9caec630311213d47ba1558983344632f24f6c0c60623f61bea2d3b554837d9f8abbbe55f531bfc9927f430258397ecdb030ee5e9b519ecb3401938a66d96410cfa3e82009416568b17b0e9ffe84098bfdbc70a03582553ef7a5894c30b11eb209c185fd1541a78aea1754944961554b77291ce0a6ebbe57c0e06ba9e4439f23c15b1291d180757a2a1d50bfc2f7a1e63a02cee60101aa0950cac31c4522a379879cfffdda41da423125eb473680ff09afc1780166f775e84900bff2652ee4b192b69965d1bbda267f27bd9e7eb016efb7027a2119eedc07a9233cd852539c88b34bfc990d05d8b0842ce9a1ddeae951c249b6a72786aeb354479e9e96ca2faab5d07b4095dc22315fdff18c6971e5ed9d33f7bd8c22b468b89aee3dfc4a0a1efc8a1d2869415a0ad7723c1f8a4871ea50ff5dc07b7f0500f7b54e2947c78da6e73771013396b63d3e22e369e60cbc87ee9ad7853e25828d14f92998512a08f7dc8b8d76fbc8f696b1e19074b6789336835dcb3faecd6a78d31715f7cf04d310818e5e5d20e5861e718c5b3ffed6e96a024a9ad8767134be8e8516dde785769e0ab7cbd3595ff420ee61981c5817785ed03564e3f6acb821071b0879e40a5ecb4c3d520dd5c2411042694b077b8ad54b609585da1ff940e3a49cdd63809b398a8df69c38c4b3283fe91a4e689bb4f6c15b772dc988870f48066ba22efd3658f784c3d5b09ae4e785ad01431ea827d6a5643c2238739dc02f36d8a37da07efb11ca5c4eb76d6766b6a695129bc04d72d163e88cf9674b8cbd85572bb719117e47c32c37dec40e5a663ca4605e1d464e64e50344c5996de0dcfa179cc379c77d359431a0f38adbb42f33d698cdbb9ff09c15f0decc40b48147fdc843d3e37eebbbc329517c148d68a22113d95e0a9c96800f0afeb6eba268a384910dc17f6ce695c21579191117fcbe3916d3aae2596b386ae76f2f4f850ad6361c17c8632bc48dda58d7c6e977a441660cbd023f2d2b16fdb5332ed3946709a2547af9382737f19b42424a32a1f0cdb89a17a0593d529cc028eaff03e5ac474762268fcc11c6c36598cf495c67b0dff4b756a04458e2e4df99e2e2b12b6ff723718d3c270fa55b5a54e9a4bca2a96ad8cdf36037d760e6fa2d72af79d3e1b5a7e39cf0d25252203c30dbd75e0165035e47c7594d85a331a2f53f3c1091f85e9d54c7d8d55118abd90233a4927276dcfb2fe12a4b493761d4f31680cf3cba20b4ff87496898e90a79dbef93ca1a99d7716ba319b21cea87ce8882533d382ad5ed46171f14e4a8ea88b49928f82032ba481a27897b3a0b99e053f27ce42bb46a61adf395742bd88836786440f437e379a6c08ed42cf128257c7da58d5ff0370ad69a136d5343f1a9f02a688e690bcefa383422403fc918f0483274837c53d7ecccaaa49836b54616764908e91e90eca25f495d2646537dc5341a1ec1c0967b1275a15bb804b755b104fd27627b58fcfba970ab368f888f13fa6a71cbeade0943f15f5f85e1f140b31f297899a925ec3c8d035dc7142ef152b99c47bc96f47e98fdb4ecde6df1f818fc6a274575c73c0a5f45977151c1122c1b6cdf75e7836ce262e6187c8255e9092d594c7df20e90f966708f39828573e7faeb0b78d0e85c5b9c5f5aefcc0c8351670c62bdd37753877dfb9f46dc8b65caa81e75c6b74edbd697883d09ae275ad7166663a868a8e2fd6730f28af5e2251f3d595f5d9aba86a1fc4a276678d08beef3fe5c116166ea70b1e746b6244dfc2d6773c3cd46f12acffb56260617da506409659342bd34f8ad62648908819f75b238f717b7b6df1de7d21e53b48c321e70544488762a3824292c8cbbb235d78c368c6f10f0a9f772f1aa72b811336ff019de24f9604b97e22aad3586a33eac8a89157602d54f9564c267d0f3f749820f6b35b32889bcd8ddc75632882d6a445500c6a752d4a94be4289c32c632161a8b8f951e23acc76172c36eeedadd85ac7969a7727f9fb65a5f5d997d67b10265a562dd8d8c50ec4a721110e10822d0fcde937a1155fd2741e105331e78db7e16aa7d849ba204410d1cf684db89b6978facf7fb736cc53cb7038e810f58e01df5fcbae78763aa9af7e557365dda6014831471341f565dc58a7819f631774683fcc1721bd8441bc0f516f9acc41d21ad156985a32f20461ce5efcd950b1d4eab1158d70fd0e9aad0c3efcc6859a2edd1149a1ea8a3b7626af294dc003e17af55bbfc7d43c5ee960a7884edc7fc46907d3671dead3823b131140a1e8b356a9bcb182259986cf8c48aab626fe09e49e124de831202479f24def9dde6d92ccb8ecbb86594f56309694d6db9119b1ca04a9dfe54e7a4b00969919d7bd381baace3d9cd221c1c5c47be6dbe74328f5d26119cd0687532073729582ce8e71c292c6d5b028e01d08782cac5da224c28c535b6690f584fd31ab66bbcd3cf63bf9ec92dc3c7f347d6b0b03d3aa93d3201091472fe62b0a74e295c64eb050d56d7553539082d4b11aea08ea172d09d4ae4aa24236cee6423ce3179d87f24f9ef8258df2d6ac24851919248f22f0bcc0ce7725fb105f4f6888273b735d256cc33907d0627b9e1db2cc989943187ed4f6ee398d51a9937b845cc9ea02a07dd53f150dbbd9a99e943256f8f1d4388cd6c02885c25ec9bac5dba2e58de1e4934b4362db4d919f4f71310d1dc24845abf338e03c88f44774ff21403ddb100885242181969870335c9cfe6faf9f423530cdd8fbae96def1fc914e95c9388cf8afb6143c04611e56f4b8fcd441936452d88735f50b651572d48d7d4c227c91f0d0a385e6a0b7a7a407bf8f3dcc66d320ab9206e6db1e8083af21bde7f03ab1c68ca72ab8113983dc9951626983b9d1d9ab2ffc67593c51d0c197352f082e8c5a3e83f261205b3cbcd34b4d61cd8524d67f0ee33c9aca437b6e7280e66ae486eee70f661eaa1fbd7a228c3750953d176b5618bedf8c42a5ca086334a983557f07d47744ed58929998605da266c10116f7b55d1ecda84c6638e5f23ba6fae437aa6f65f0015fdb149965cecb67701386d23bf96195c85bfe4069a2513595da2828a810293f4e268d0cd9c31e663d917e00d872c03852203a7fbd45db77feb4037fe3f94b59f7d00b55a94b8b9fc82f85adfb86a417150a7cf2a2817d98500a2b1f6b90dedbc7cd86e10a291a17dcd3856ad3f18d6bde101bf737eaf7ed15df37e6e4180000b21676ed29957fc512ec8e81ec65530589d5296ce8a8d5e812f3d7919931d9ea8487aba1c01867f4e56a3fe61d06c37b20baff4973ae9adb61011075c67af1492bf142201b1c0ae167c1612b61f39a7e82a3f6cb51dab6d64d8fadf0ae6ce568f06a40e0de16ef7509cf4c42e8b5d8858a0ff5920e00b7ab2c0b0d9d33c09608918c06b67ba231941a1aad3a35a3a620d09eeed10d75cd6c984741d937fcc7ed44827b7cd7082990ae8ab109afe07e242c99e8741ac40665ef02eddf1494ba84808a1b3e1ba1f9d880a2f50de88fd4cb17f0079bfb7ec4c748abf172dacc6c0c79bfc57263ad46db75b465d506e8549f5ec7197dd57dd65953483032c261c0b24447be805cb2cfcbb6344c89069dff60d8bad389bbbe361f04db3ab147099fe0ab9eaba6ff944bb9be958a15be73bf7b3643ffb94e0f1bb5ee3daa4fee11e4f351aaf21e6b7797e7475766f4f14af9f202c45aadebc9c2c02dd6e140e9720da1ba3bc8f05a1fa9b9386f4c26d8de5edb39367faf7f70a78d4934e1a18da5bdf162b2bff7691726db35c0f9e081970e0f148341d5d64bcd58c42c60e52180755be69d61dc4bab52b62538efce69b8fa96b3eed7243308c75ab1c3397fccdce50c919b03ebea57df4cbebaee3b89e7c8144dc9992f3c1228585c1cf53710436cc6b40250a1fe846a6aaed1ca03873ede750af1d6b461279144916e6cbd0330de3db3c74d30aaab961ebf57ff76f68ffd3a6e677dc5fb69c4bc07665eaaf296d830f5dbcfe624e10e10a897b9ababfddf0b7b3df38224d943b827d24f841ca2fec79780ad11f48b7e7d324e253ff8adce5581ea5d6e404b844cf3c27401d0f7edeaca1ac2654af2317576fd85c6d20ebdf45da8fc693802bbebe2761c0f0e3beb034df96b1f22bb3a1403e8b7bf1d10fe4c17c24a366f5db2e4a9d6919d49fe01c95a5702d4241a3d2698233481988b62c1e8eb21ded37a41ec9489112204eb26417a01c9f80b74a2c0ea6981198adbd6e19cdf16a5ea9e8c2fa214222ff617e5ffbd3df7919187425c06fa76c121bb1a60bc7b8b44b6e3f62339716cf83f6fc716bb0847ddc2f45b96744ec38ceec21293ee915d54138c3dd75c3012d044ec4920baff35265f6ed4b7933a81fdbacefb52ac82d5fe56ae7da7851003b90a4b89d7a3b5911cf183a168b21dac31bdcc6b60d7e96c4552dcc3effbec8281ed4be22985b284db0b32e3bcc53ddfb6ba4222327afa7a9239197b28ef2ca3b5e458d75c19a3c66ad723e2409936f5d3dc6674af96c80d4c51f4643cd48118fe555a958d34d6d3d97ef85a426f4222f7a4a7522b15a6dd1b18a441f4fdf164f6ca01378e5be7567af4f2115c3c934dea18b725c43bbea1bc6ce7399594948760fe0ce3d133cd513a7bc2c2d7ad6b7f932db099f8c6c0b7bd9d2d4bfdbabc5bc93480e97e4368ab94376114c546a761bb7caef5ce981d6006571661acda6c858591ec12913b4488c3c6380151ccc6c16e5db0fe5513e4bb91526500b4ff60eacd2db1d3a550ab6e9da9a687c3fcdf6b0a9c69c19570656e839a1a8377c3f0395a07205d311ca721acaf5f151c41f76f2d1206146303be9224d672f5b0cfd6c5c93c78857c9f52c703a4d5edbabe7fa9ef1d6f598db71e2b08a7d720d3ed0f8e04b0fd2ea014ab75a6afba962db7b5394160cc6ef858672e18075a8966329994c271a8afed29e6793e3737f771e91e0c015ce176349563117329a346f0513867ada05957016de38e01ad92e6bc93348cb71bd8ab2a26fc2dbc84283002c3a3db380367f46568c4f6a1d70e7e534ecacc98fbe6d0e5688b8e576ca2129b3f54681e3b04ad06732790cbc6ef8ff4f55ef4440d2f8a20db7d8dce01783f4223857962448e5e0b3ed0e9c8b07ad9fbdd1248345926ca9378286cc1404d505b31e944d8de29a3f07d468dae2bd2e194b9f880e1373c4d3be9e271cc272bd991b7ac4c8c7c487377754a7245a4ab538914fdaae3b2dbe805d5c0a84e116a8bcf782284f905646e9f2a3e54eed9b091114452777c129b7fd286cc6580ed81037b0aa0bbf61bea8c36bacc3b568b134799e29d2f052abc3b6ecf1d1ce4cf8899de6ded2035fadadc39432144abd8cbd814a8290954a00341a123b4474b80d07cc393353aba78337eca838b567cf41d23ba7f90f950fbee40056e460956e11e5c80390fa610a0d6df82327e36c2a599ec893499e9ceeb68ff30cb62641ce7ae2fbc3fef11fd8719741ff7e39bb0bfab5065f12a7aabfa571d4ffd939ba24a404b6f711a90cb3a47f10ff3eee88b77727b4073fef3fa9c14f41076361381970096267d13bb6351535e031c7eca0cf872d616f8ad791bc91ac2b4260e38de9400bec5219ecfd72da4ec762dffb71b6d91eff99de97f9ecb53849e4d9b146fb4bee506d788518a411d935c359261cbb884abc7bc7e9ad89081bb03428f0a2a756291718c84909b67cb67c44f3c45f6401ae3e624f1ff9a4e39fa08606a826b6c7f059cb5c20a1535d8a379935a57c16fd6fd88f13ba0c6f008c24ddde616b721bc94bb42455d3c201ff6b20df6640dd501f3a242060bd67af484e5f7241d06898a5d35f8e77d3e3c988e0e072808bbf3a8c38a7c4ac3d6775c986a3180b0fd6016aff0a27bc824ed8f0f392ba453dc147fe4dc6ae3d60b4242e106fe4bd2221410285b70e27315265d1d882be7674a104532383cf4e190b4433388eb4301c4ccfc6337abcae3c023c2ab7ebcc88371a9c5f8310edbd712b911fd7fda3479ef8ce49441f49a68e2f0e55e92cb7b582f315b3b73def9e0f630a7bc1466e41198f533470302bf5f72008cb4e67a8672a3c98a851065c7351bac87a6cd9cfc3ea9cfa89035db9c759a5faf09d2dc49d362d5e887276682b7b46a5621d607a8e3b90595e7aaa836b25b2529d6edf0bceecd47e9a424258035a34d493059fef3f3504bb5d344471b14ae5ddb32af5adfaa7698e8df9b28aa440538809a513f2d78dfa8693a1dedc04902614e5f0251bb5f47fca22b341f4e30f0ed09170a40b3119d770027428554474b94d506efb0c42e0d8f86282dc58aaec07160dbe2a51286ad69471a0ee347d7b58de264e96d4c1d0def971fff578eea6c8cc45246c702219a086b5ea4a5c97b88172d2e226a4ebb89a8d40c2dac346d04919ca1d464244715fc7bab4844566d4905628f42b5c80361a769ca7c7d2d2c1f91d462ff9313d515f12fffe6aff20092824b14c9bad1c9b6ac2260e9a44cb963327aa58acbe3efdf5e670007c8a7ea4a928947fd17997048a4f6c6ac385ba302d74c40088c5f64e7a42c4bf419aca67c995cf2928eed86776911067032911a77b15859cad906050fc72a73c9ef5cc54a80d7a1874bf40ffd9ba2264fc967fdbc740db009681c8eb9299fbd1ddcea85a44ccee036b12ade3a70a16a6840db055abbefb3ff2cb7f05c17dab76999aefe1d4dacce2c09005605eb6888b527912b4d9058c685754b80c5512194d25084cae187c44c3c81667c7b912b354f8ff76e5edf66cfba82fcb824515ce0cae46de18790c039f8f6efed0238fe5cd75fbd3f123fd6c187be24e6f29b11700c5652fa14960953a451e59f4267f854be07be77d3d72653ba3c3ce495f25d7724a5d2215091620f318e4728f083d79979675989abff144c831e51cb95d29f258ec84dc5515ccd366ab307fcad4e819322ea75bc31966296c87a2ae4a58c362c7b62d645663ad39198c983fdec5e2c12f5a7fe6af9ff215237d458d6e1c438e98b4b1824c70c7aba82e307becc0f94450a129e794d56c8d9f14c1557c17c899d148f4c6789b562dd90e042963a610cb8d2c2b5a226b12f01971833414c7eae7839ec245ff447d76c260cf33ad8e77b893b7da9b76e55191b0195405a5e2c8ca5e2edd116922bcb5c487678bbe64009cfba28e366d50f647fc36130dff99c47e71863eddc3f86fcb5b1288894108bee2f6a3735c642a9638422fdc69544540a597221eb7ae7c07c1c835644c7224a786039117d4089a13adc81c79e895e2a3d0df15aa5a61fb22083324d11cb546afe6df07786f69539af7f0599fe84b661801ad58a65c31a9df7a8e2e67bef8d719320b42f88e19d4f0ae43d148698301e0df1e6d72ce5dc081569d504d0a72050a9a0ee46416a61dec6876f0d7bd6fda0d46906cca322eeacf402b34645a141baf859403a164c2c36ca5eb38aaf6d6a1cc53326db459eac6002239d347edb99b0cfd88620b8b2af1ca631ce263e5f4f99717f7a83bd935dac735245b8207038dcee8c6746b57a95036ffe47784d8ae00b1f754f7fbffcf321ebeb6ae7a1c6aa3e3ef58163ca2eecfbb9a97490414566665b44af41b6e99c78250a3375e2c0840b67f3b22c47f9990ac376608760678da5e0f590bbdafd60506a103abb4f76b9dfb1f107194f4a363ed7b95fdd8e240d89347563da2933e826b69d35700163fad63bca03672383cccefc90de8f168313faf855d825a9ed8a5954faf6982a2807edaf2954defafe735cf08dcfb9dc4c42d1b9009eaf4f9a0be0b1b64bb6cc63f0c8fa5f83a7cd92102b9a4511ef62a1a0ce2abc248078e292c7d0767cd3a3613d4416063ecec5772f9bc2334802b3d2ef966b2f79eae28537e4169706571696a4f3fb957b18c45a9aa7794ad71e8d8257f3b81c6f91897882a52a5dfa19810d6a98706474ca1560e567f2c0f5d5321aa6755a3a4097d8f327a615db12adadc958ac76eb7bf06918e0f885712f741789a25ef7f3a1f576d1fc6a5d4e0b9fd29b7f8a215d512803c96f2c1093976de06abf86b49e5898da65aa09ca58d7be16774eeac1dfc68e39cf61aa71e9bf6e36ae342346d91492abc01e24ec87dc952a130c899a82a0aaaf2be49722386974e0f228b00234708b94429a621fa805c5366fdd8cfdd3d6031a5c6b3cd48a92ed4f4990a83bf51e21ee7c641b1b035414ee6111079b5348eb38e20436bf4712f5009df281f21203d19c1b00f0f32f10afa67e6f574a5096c607945b12d1d6b9dc26b9cae240fed81767b768efffcb5ede1b103649afe4cc3cc932e03513832c84f700960c6ab0c5fc6703ac2e624e3e4b0946e464136c397acd20eefa6a1cc36722033eeb0e920f696dfa3e05717d1f343f35b739c6256c26d0de14a447970b3ccfa3016db0432eaf78f467057190a5af7f7239db76adc7b3b644b8abe91c4d9787180c6f43a1f33dd59bdc47d737a4a92aa8a6db1cdc8ab0b6c2dd38fb12adb13a62ab3779d42ceae8991d6240cef77b6de62aef100e7827680c9e813283b054f5311a6bd2b05f7473b2cb2ee80948335a80927dcf714def138440e56e34ffa4efe00eda44ba9feaa6917693c16a4cc72efd92cdfa4955d9da2337ae5671bf4f17ac41436d5fc8e573dacb8c0ce62bfa1a47311107ca5a917d2f50dcc8841a4ca9eaf8fc69082743cc02e0279ff7aa5f615c3928fa46d0429e89aedef81a05ec88130d708d62c6335a9574d15bdd8c2c266c4ad3c1cb96850ed6792dcef6edd816fe1674249e3d000e63369e35117d3e419fe03a93378dd81c8eacb8313ad4a52268b198ae5a3f4a8a2c48ed21367b8608ce3468355a5fa8cd88acf05c66aaf156c2a7d3e8400704c3496fb436fa1805c0ac74fc169c122d53fa5dae6c9e5fed54d72a8cc1d71ef9ccf70ed2c6485e7555731524c58f101ceff953140c9d9564496c65112a71d2d77426da53b770b38f15c9212ece7e1ecadeef90cd8c9dc3b1eabf3f21c578d93e7ad6add7659c4290268a3dfe178f6ee48a1432deb4e40fbd8f216593d772862e4a123a6a6b30cabf1be90574f6a480af41514df5543a325b69b2863930bd24cbf006c4f8dd611d32dc636daba8a61dfb1c94747e8151036df9d8165b5152a223608b00f0c57bb40ee6ea40fdc482a2c81a68763f3ce2ef32b29fc740236b0f6ebcecac339a3e3c46beb6f6716cef2bb4e988cbad3b26b475dd52cdde6cb9b81d64dadaee794a2d9b9c3a1d950f9296cdd66c385717e3cba5a134ed345dd525e9e021de28e2614cfec439c7ce12c2dad4270eee63f9e895fe8bf7a58f71d8f4a889c12bf99d00261845ea2178228b8263d3cba530b0a6e79d3351b4c5d0e025ecda1643146d0231d470d9f93736782cd8d42a98805ccd45b4f25278713a3d5b18de5655c75bd0de3a6add8ce2fa663cc4824428d27a6ecabbea2ab202c71064898f9535b496b29742f4f77edf3d459d2997ca07670035d6f24d79ce853e1ef822b599372a2ebd5a615fc28b5c4ba791ef055fe82a1f89f93e9a85ee22ed2a1c3ab5286b18eef3320d589394dc4dfd6fcb50760ab3a71bbb829c7df5796fcec8cfc55939e7d828603332e4bacda053cc79b720d5a21b7bc401efe2620acb7aaf68c0b73f5336ed07a1415a84d5b916ef3361be7be2fdee5a7fcdb993f91599cb975f0379e99f0c0c30294b2e9e88d298b9ae137ee2223a92e7b161d54b864b7033bbe6063b60d7ca5c9714eea9cbddad86fd1dbc279db373bae0b0a03b95bbf8c90bd11b2ee97c187d44d55ebc47d581df7554dbcf93c8fe56096dc835d0c2faf9d6e251486c133fd4476f68dcae6ccfc86166694472f2ec617ffc10935504f91cc69b4074fbc35af7ae403efb0938549899726e8e6ec1ad7e4b27dee583d97c831a818bbb92f4d724b20e42faeb6f37367e0b15c6fc1106cca6faaed1317d119979e0600ef8d425fbe2f929773e9628d586952d532c2226ef5dee77a8f6881411cb4801d85436c854791cae1a38630b889abbe574bb0aefeba5c513e91f8d939e9aa5f2b19d43e89c5ce8ba1efd251db9837fde0c21f523b6d86f6cea9d157e6c250778d1ec732885c0fd951c143115a9970334ea344e8efe3db65d774ff893fbfc5d17531c23ea82046f76801d1f74365426fd76d4d63d25918f33139ad4bd2adf960669fb278226a35f6e1e1acd17bc1f35c5c9bf58011b68d11ca8bff5407d9803d9d10b2029f04448f0c23add57d94fb9daeec61c85ce16323bcba1e03c046e75d76fa18c9e357611495e7d04c54e08690834251149fd836aa28d3d838b606bc2533182d6f731f4961571d9c326f1446fc191bbb64249c363f787523d4a7bfaa5e8c24bf9c4d54343df04d49f0b62ea3a7c424fea47cb384958e8cf2184023432698b313762e1a3c532a356dfc80a38d01c86367e899d1e6c5f86130b89adb40a52077ec4b754e8c84df06bb0b2f0ef4eb46de1de893ecaafc5a719b76583fbaf2df0746fcf54ca80b511662ded20a047af10e6fdda1ce1beb7fbb1cf420fe6207004a78fba09af0399d92b4c6c33aac157a32cb0391dfb32db5147b385a2d74f24c98dcd1f45155c0e2ec4c914303ed6ded2f585f72cde7fe9800f571dd5a1864fdcb89e2e2b5759a496c099e1f7aed9dba7ad09e9776d467449aad742a6e35edd21728fd1b94e1ee189354d65a07674c519108c0597572937e71c66ffe1c4d4564e09810ad47f181f3199c9fe05af7c1280f2578e6ce81b034663ac8c6129be317bb9f041d6386557c2614677cdb1edda9d4e8f4d54f24347e26dbc00411d5d38c88ce8037eff6013a730d59d0fd326cb5032032399ab478763c16d989dc9ea285d0f5cdd58654263bb2d6149de90b3c12ea0410d7dbe92751a25c4e102a5ab74e99030a03dafc158bcc6fd5b4945da7ba25caebe69aabefab067f6d621ff31b85ba02a62ee7a123271177fa64c6accf48ee0cfbfc662c6c1a7a3562ec7c9b7bb330021d76d0d8e394ba134e256c731889ea662f830644d84619502a4b5ad601053fccaed859a420e795991d6c321ea5a96f0e1cf50ca921a4cb89e7c830b574f10697872e8c3b6d9243379c3dc2c48977ecc0da21332aba33d70762f462047dd455278309908084fcf830fe796537fe95e5ca01e44e849d180d02b00f6748e61124cefc27f54ca1babaac252d1884dfb3194af747001a1ebc977f7e84613358a2ea7211c0085fb1c8395e28fef7f7dbe54c718586c3424789b57f499bae40abc1883f61b5e1cd85f147c887f84044ffe34b66fbd9d1eac04ac20fe48251c4a7d53dd1c72386efaff453a2c0333cdd61048a15fae4206ba80f25862d11e7078e58dff2c82f0db31c7a2971a147024ce0c3a4344e00f12bc6f69fcd47e8a39111ab9bd569efa5354fa3d8e8df66884cde81c39a85247a16e8413a0dd3e09e29246fe68e2576cd57a5bbe14c9eb0154e7278efd1a052bac39b420e39decd8e33fd8369fb73f2924fb3f30d5f872b1bee8d94693894df1822166b162c029792cfcaedd3d693ef4acdbdd8c3c45dc45c243a98a16ff45f55f58e4507b014d92de7da4f4e2e1480f1f3a4fa28d21b693079b245bde2152e606018919c0de7d23aab15201bfc9ef867bb0e711ea104e5c8c88b8180f72f478263074bd6ae968daf886b7b2ba8aa08069ebf0ec17dd6d7dd0b3fede421658582e2dc8ed044efa51529f616b8b92af636043c2680d9f51f9d4837107fc4357ab57cca514ed87db56e512b7bfc0ea3eaccf2a92f361539a337d75b3cade1f4342aabd5e2d408141c1eeddb86069ebfaaa41c66b9d4a77ca03bc22691d7a2b57085693a79e209f43ce51b4974588bedb4a9034240678c2225698da3b624d1e902ec5faac88a0d495ed412da608c2657d101438cc01ad4b7278cc0891ce008ccfc212a9a22c73ae1bcd68f649e1d2ae3238c70b06dc830c5ba0bc9ada605a9ae1e74a39cd84f5d7f9b6b7935ecd04945957b5c0162369eb2dedacf2377251851fa25f67cb124ea81a338ab0fc6108e2ed5c1471812d7830d093175ba579ad8b5a7f8bb8d51ed5a2bc0acaa022ffbf07cf8d6ff2b0f072842e948657601718ae7614a2fc8cda6f6982693e0f83e2f854593662faa24268a1115a7ed404d22cd3067a8ef7a2c241e4aad595d1581a54f8fca21536e7d5dcc6de3f1500c0179bd5c542bf4add0b0e5d87f9ac404fe26a64250da6f910fbe7dea33bf8f9e1b6a4f713cab738d2ff317a008f7eb364b0a4dd34a71b4a34899de35a30991f5ba456deece6a6018dbef05bbc74e16876dedd1c3e3bba19978f61500c40d4d3e9ca082cd537889fb9a23105dc26b3f53257415bf69761f1fc1a92de5ff231f0522ee58c55da5b98cc25b84f7a1eff3145cf3407cdd22b6d14e1027eb063289eda4507a94646c10810c3aeee97dcc60c4bb963b8e491fa9336f56a5d63dfee910b3aeed56aad18cf9bf8659affde8f63b6875c825fe015e98703db656acfd60e65851510accb5e3d7d98aaa40361ca0dd2f0311abbe44716ee0d79b32228909791ba22125fb22ff632bf3a30e12c5db363f14ed1deeabcdbc787395f3b9ba82c986e7deda828b549cdd5de9a308df75d15b121a7860677dbb1c571ef530a79d343ddc4d9bbf86590196fa8118d8fdee7ff1995aec163cd86acb48167b85e74a004c06fae373df4e12e11acc3e530c1b5173a3549107ddc0e5c612ca83129523ff84a2f832418f1b6f9d3006d3ede4d89d78f214ffc33e8d59218d71f6276bce8a1e4ec0793ed40786edb2cf16a9428b9abfe7325b50bd029b85ba879750c22f1cfb1e2b815ddac4cc434935b64cc4fea03425544402d0fe1b8bb0e26a4e8ebcb94db9e4c3b909c9579087e9e182d0d68097ffdfa86dbc4a3bb56548979eadd4a837c4b4544b297b45e22a8b1fc9fe3ff57506891fd5abe16cac6f60a65d38f7392492b293d0464553ee6988de03796a5724524bd452d331ea8f8fb99187fded0df8ddbda638541c58a40a334bd346c07ef4ab11cc674adb5fb2dae64a27f1298da70523729a856b1e511b2bc43f5b75311305a1fd51ef82558fa32438b50e67efec530253a23087eb4bef598f4d07416c39e92551332b2401faa6dd514b1841cd12f9b76299139684791387d8e0d29a1ff6bd53fefe83aa80e08360b6ec738a3aff7c3de5ad19b4ddf9b7e2c8e49bf548bb184dc963e3405243e660695e7ecca66a16668f2fd8ab67beff740bae6f81deb3d1d5433c553fd6695c23d0596bd5ea307a3fca551c8fc93b7dffc5c8a4779634098133662bdbb664a5a9a24dbdf2013b1f9cb596c5de35bf119d6b01c8e2cc643cd841dd2dbc383c3748d9dd7f8fb394e82299283c578e846b38280aff60c542ed81ba3d1133df646cd7a9c5fd531970032b2a600d61af37b818e7bb3ec4242e4cb429774cf5437540b8882a58339e0bc5a38f3c4a6dad4f946b0e39ce9fffae7bfbdf0418c56ce54a35918b149445a66fa46caedb310ad68318048110420285caca9e0100c11e597fe50dcbe86f24e110cbb9cde22b090c26e3e3ff2103f234731c4084917bf22524025716ea9f08f2d77678be973c3a8caae9bd3b85ffad654ac162965bce16688731270f2e031d891a9494f8d29a5fa2552fc35c40b854f9beec463731624bde9182fee004af12db807bb4139dd25a8888e136fa6c438bab13516257d5d581aa06f3c44589a6d9b60c97740303a4010e127ac8fd3b21e77f9e6c8bd9c8f2926437e9634ee68d56e4ffd499c9fe7217a9932b8f65a56a609c6a62da16f3358294256acbe61464a7e2e5896fbdec9d45d26948063d827b3b9ce0b55db4ba4d841aa007d88d395d8af26d5f1021fcf8831f43adf93d3ebae9459c3ab75b14ca97806956de95533e38970a7c3b64b64bf99f161d2f74458afda74747ff684a75b79ad40ecf6954ac6f5dcde9f930f86fbb7bbc01f3685547fd241577a6bcd487d3d4ea7c5d6ecad5b3f7b4d82b0eb0a930ce259fe93cca1e7c336b6b26af4531a41673f54045c81f00e5b3c9085eb2a33fb13249328c18e081ec7a9c3a8e50a99438a178366486a94ecf0e216a7231978bb254c8c7ecaab30a8ff2e44f89d610fa7ed64f67c8cbb5931dc2a5f1d5a0e5af53f64a772259abd8e03c2a2fee3ac2c00750c9fbec48514b23de54e2116f78880ea7e146fc2414e0100a5743444b1ff0281151d87ac8e8ed439204df819c1844f2f5f7ba89730ca49f8bbd52ec6202dd6484c55ed9395bd22445d6470ab418316a72ecbffe427ddefb0245b641f2f93ae26358b48896ec230fa71f9d2043d5135786dc4816d0a9e2c8b46d68bf47dc71cfce11538bed5cb6d4d8b0543a141fb95e4fa63f3de45d534152b139bc76bad2ebc9c6f96370900ed67fc7938390cf5a8aab791a104dac9a2013eb1b1c742167a83ea01fa2962455c16cd8eafa40f1fc19f72e38231f9abe2bb49e81ea36075c0dfb19863cccc9a760837d979c0cee36a4c1f74578c617a35f0768882adea7840f0b751328b760397af2987c1326ac0a0fd33c6b1cacf000530a44a770889eb4b390216c49863a32e768dd6c7a055ce5ed626beed4f9c7dca5d05a75cce6c04b6f9025ec550c562b786fa231bba6f2c928cfc283686bf70153f5187c9da81562ae8fa376d7a47101bb3751b6fc14daad843650de0563feb81eb1a1ea7103cd3f85248231d748916f65c1024cf983718744779a835b3756249292315750ff0c734db5570f8c8eb97ac0df7911c5181ae53dace07fafeb532fccbfea5476ee631c7416fea7693eaaec5d370954817fa6f8a3b5b060b990fe9482faab3849dfa718c41f5790c6e63e5714273b3fa69fb191a65bbe0287527178aede69ae11ef7c86cbe2c16c5ac7e723978d2aa5da873b59a510ca853b8fe5edec2f22b5b7faf468a6dc46b1da1d0ca64778fd64441fb944570e415b1d5a83eb06dd2b0708931fef8dbebcb8632d58707401a08552f4c0a1b85bdd3c836e324b448858580e0aa7c9c5cc5f25fe9eb120efba3f4c759e75373ca306a3af317c350ea19de043e2f2451f4f4ff02f02cec437aebdd55576accef1c9a17f3e98fa27511d3fa0b8a559d7be222e21853e8072e72cf944e935a0b427b9547dfd8471128a8cd0db4d1a8348e8e3e165404cef17c993426a20b55dfdf1d1370119242418d09fe604f442ac450c85479d584e0150b40d54c719afb02a7aba1ab12adb5aac3c191c5aec80d24125251b0da104941f381c54b53f708ca9d99a1c6c35a8eecaebf1e40fd0902967b43234746a8ff121b88c545feb7a3c32c4bac48a89c5efa9ab53757c479eca4533482601c3114467b204fff090a5c966c61fe9601fc76495a5d562ab076b8a3e1370880c7245edaa5057ddfd11f6f34925d1028bb126ab02266123c49bdf900a4561bce5e2bac96ed5507ccbc32c8835de4bbcd40e2378f3d12f57fd211bbf29fc4b084b550162af7430dc973810e3279ea4b48750c75d3ccb9aa9076c07e437538beaa76ab98ab54c29d7f16cdfbaf8bcb50f0431433a5537b2674878817164fe324b96948241dd162533f61397d626f887dd2deb895a3b1cf70ec008302dab0774d5a21b7738ca3d1aa0c77f69ef8c416013d83a8adcdd095c96407e10c1ac7c76834c3e6abe47a2d5322c98b1d28b82464058b6bf849491fcca030e8a9190b2f4bb9f3cf720256d69cd1be19581437d60cb844c78a0e98aff53c8c241e657af62151c1efd216fb999ca5a916d33b5e4dba52f8f9af09a7811c744304c9193ef11552ff4d802025c8c9bff29400394502616f21e74ac2370dc042c5ea054d20fa40d4d51caf77a6f7ab5cfe1fd3503d986d14f4171c24c56c94403bd0d061a73431c0222010b6ee085783fb165928152c874fcbb1900ea3b2594cf0560a065c4b55f01b04a0dc7a757ab16382ca2eddd8b2e27265e5e819c2da2b1f30693a2e1500745e7506f488527328231b8252a4640599b084a57f155d03d6412e732c4096541cc80fe8a38bdafb860eb63c2c96c2ecf17fc5f71a9c68bff63626c36d6620e8d870812aea3e089f4efa154137f5de5770d3b75e165fce48dc4de34fdcf39c3ffb9c87093459839a63f8874272acd1ed89886ed0049462f23ed50b4cb6b4d42ea0a13adec101e18f355a525388b2f27b4898b22bfc46d785cf6f9d72e3b435fd0d5007cc200590c943b9273f1baf3f5a93e708cbb5f48149f9e2312f375f19ac93f0aed69203d12ba80678c096c180a1f6b34f5760175df5e4fe1b81f0f13592365aaeacb9a1cdcc07663194717e5dd86d7ec67a0a01c75fc2a82a994f187fe39e1a3ef533bcdfe99c6a922542c50fdb36b9db10de5fd4053da7e43d7b5232b9713223350f3a630bb65f2c3c93c68f0714b6c437a7bfbad7ca2956d16f5c142f50554ec66b91bf1d13ad8fedf451f8f078fdca58c01d73d9bb308544655d2c6031656e5a578e052bb0a5e4f3fd342c45f2423442970acbe413cb39e30ee267035eed13fa67903878e4d137680e0c936ee3863ba748444207ada905356b50799b5a09017312263d22e54a1abc3fd484218f5e6cdc1db7ac2505a28bd8938df269032cb8dd9994ecf77c50ac90ea6cd193853ff67fad86d3e39601cee8022598bd2b9f23debe15cdc330b0ecc5443eb994efc99334e538b7d2e54aa7cf82b2b66562c82d49202f60c14d2b7fabcf00d504c2fc0c13b18db9efb52296249898b9b5092be764b86d9783936563274991d72a7827d7bdf293d4b20bc368f1263878c095cd44bfb29207f7fc35389a41a07e2dd77440b9846cacffa68d7e4364961cc387cd79339e801c41bb9ee25f32d9b32cf595136216ad15ecd0ad4076d060a174b968a6cf6e516b9fb681da9d4403dbe1718b44c97368e4252c8454ec8d0eb46028178dabe2158acbb4f43a0ca4b8daec10cb546276e60e04e1608aa7ff88c7b29b4b70ac9e9c14fcb2838eef59b0fcc49b76f888e398342361fa27a75bb17090f20697d1e8dbca334f76c2cfccd08229ff5011303df9a9ff38132d81409268aba821adc39ac22b8fb42922b8cf974b938d5534aa7038b229d231632f1125685dd74eaba3c9cf08ace0716d823f4dac33aafdd689141fd2433df2984cbae0cd25721033dd06575e4b5cf4a78059a3010bc23264080cd452f5e10dd5c36e491a5d63f85b51455abd68598a8da794f7f37d8d7be3c46eb2d5264e9a9003987f76db86894afeac93795e8394a8bd12beb38ce0bc684bffbad89017a6c6e3d06322e11080a473a2453afd0dce62c82733c92945ad0d53d88aed174bc93ea62521e3d9a4852f53cdcec0af954233fe0d214a2900f9eecd8d7b5b9fde17cd6b6f03f2e7685ef9421ac74f27a2a5015d65129e81ecedb003de151c537b555e447cf3bbd8371786064fcfb505d30a14d4dcab4c438185cfa239b46a565878d2805ca432df909c17c987284dde705194ba55a9d5fd31eb9dfb793d80b58f2d1db8f1eed8f6ab28e754c750c27c8eab644bea3b12ee2908501e27dbba082801177dcc832fb8bef7a3a50f3d0597e486d7b59285abac0b350ec0930888a503d939567ed6570e032777635aa3c6f2c68b488517024a1199c1e48e19a5128e4b10c5a1f415d023529b4c11777e2c9f003cdccce2d4435ac75eb004136184a759a973d32bdfbe7970b30ced21d0d2778d84c0a79f3cb966f49f1788065c65678870d432afb3c86fdd415c69a9a7a91fc0f9d05e71d18abcbb7e30688d35a9a369bd3842bdbbbf77ad3f3669f0b805f27d75faf1b9860732e682d6413165cb8065c5c0a9d33881dca6718240aa783caa93606a38bfd92d8313caea1d85e5062ce92d9bb671eaf1208b62db138417d952fa0f469f47f702beaab6126dd6099da00c43eca5a64bfe841d072655e1c344f59e0150223eb1f4b433cc04d2658d0ebb43bbb7168f520809635f0875f6bf3023e0e35c48c1c4c83a352a747dcf09dabd91724487b504a956675c090efadcbb0c2fe5184c0d6262477abc2937766db4ddcea0972e6d9a64fa9be23e7d7961f1a020bd2ff47dc729b15e4ddec3200c808063ae0106413c4faf5621fe993a76dc36504687e525d0a1b579131f6518a685ffc7269f1d71f3802927f6aed428ad83eb63a9742b6305d26fe16147a605ffb596683a690af37768982c64e4b250b0f540aa048b7257642a22c900b8f8e2277150825dbe408fed85873df3badd7be7226d216885eba7253e0a94de58142343b0dfef03857f6cfe8d36ffdd856ef88a1784b2eebecae872d63c473a1c6b25c92858d583a1062ee6c946344b7eedfcd27c7b0995b58dad51af7a1a4fc6a70c8673ed8e7e6782254c483044d16eb0777b2d0d83667c353a832ef6248417135e4d15424398fccede4fbc7c1515d32a36a697c114a589a738b364cedab7da19241df8d66b80c3fd333c47de0ad0c17ec24a890c4ecfe3e28ee5d0d19cd6ef901f4c25aeb7d12d807dff8157eee382c68752951cfeaed4121179557519fa6e265e77afe81bcb70daaa41446ba72d091eca6770f8eb83965fdf5063b8a156501e03639af2422d5f10e1e758480ee626758ad1907a61c641768a1de1b564f8058359b84f61ec2a7837b5f81c0c869a06e3fcee151d9846ed02815f273d9446a1332f638f2de2407db62716418b9a90ff7bff9905eeca5ad0b2e6d31902926e44e084476d3652f842ab7e792d1c245fd27eac17f7ffc92d8a5744e865250efaf81f6ce682d805c8b6f89da49b93b8376890079f4d73993183365c18755dbc0d681e63a922ffae8a71c7d88fe6405b1884e6ab130a577301948c8f84ccafb2fe19f74b39f202eede68a6ca1050d4f4c542086c9b8a356883647c5ee1f877d26a3c7648ebb42f6c2dc3b32854cd150da231a9f66f42fb49262de8dc19f4627de03869036bd7b4a83eb8257c7ae3586e913c53ce92d707b760c29bc4d23a3c39f6e820e6562509563320ef00e364c077693fc6b5c63c568e470c579712e906f6d7d0b55f7ffbbe77fd2f3458800a02ac339a4b6148e7d95c12d1122f1359bad965e765e5c6dbbd4522b590730bb4c06c663512bf81a62b3eb8e288d9d1c9826b1d9dedcc9fe487769c43c06e1e68fbf568516403fdd5a82b8c76d6a28d39f2238f9370b80e7fac480458ef1438993e9de46ee42da14558446c89cbc613464f79127fc69472683fad54a67816609318a33c909224f9bd800c1e0f4576d27158b94c25350b9bff91fa9c02ebc0da102aaeff9a04be502e30cf056ad4c52a6c54a61400958395ec7ceada14a53d1320fc9dcc0c59464c746582fdca974819607601c7d0e0e113d39b37fadbba4c4223fd6de994cdcb911cf60ef7886100ff400b0afd728c10478221d0b66a6bf86542ba2245fd1ad746a1137b447fe1ac703c2f4e1cde1a61809eeae42075b3984c0f9db3c1f784e3acba81a3af9538b1d4277eb98ccdfe5d63fc3eb6baf6d60a42298890b301d039d051e0145769478e920a746e622df4059d5d3503f7c708254b695e375a59384423f8e529ac24efaafcd1e69049a4fc5779a1092ef8c18a75d1dc0c9871ba38e63d7af61649931fe9a6efab422a6d76b29007fea31d506cfa0ac952e3305c60f1f7708e2b5de32bf9c1d4512d667a869a0da104895ea46ca3d2bfb608ad9a35a95c70442e13e2f5c726e0e64c91f25859355d1a05842cda966d82ff12c94573fad332adec3eabda6c77da72f634fe367178328765c11bae7c0dae36d0ba80510f465ad14910556a90a516d2954a8fdc4730d98fd34e179947209be80fb2f7f25fda1a15246eafc1f50cc0471b5033a1464454078fdb571cde95bc8fadb32ac3389322085aec47beca95a56dafdc1552600ae82ddf1c6fd16c3f809beb1bea7fc8117f6dd2b0d82d541e4f57b4815e5146fed420cd449f9bd83bc7fddc99ad0745ca76648b681147acc06600067465aa50fe4ba089e77b56c89411f05ec4229ed773be63610a015e7b33177c595873432c68a26cad58b9a603ebfa7e922e1dbb880dcaf13ebd0a32d5dfb6a4c1bab89379fb6bd11082ed89631fa7ba11e8d25f4a8642c10027180b4d9ab656516473b7ec37e4f137b1b2dfd9fb29c43cd13fbd63967f48eb2840dda277adc40f8675d2e42574dd5c02e3c7a8895bc150f8d8088e383ef3b9a02917a0002c620830965a122fb29aac8963b922a155a69ce194a95776693edf9b04d067bebcab6a562d328c310e29755267f159ba00579b42835478d65c30c0bd1b3071fb38869197c5376f1daccdb9d7b170550cc6169ad4da233c76cace57bdc9e395cf02605f39eadcac25433331479f9ac07f35322585069ef1cf37adbabbe438feceb598f57ed79874a44925d20a05ef852e2e2374b023016ccdfb404dc4eb3923351a9ee7b7e2f61c4966f0267f9339ba306c6ab5420b7ff3bf992ceb476ff038d791b1d391ea5078b31508f4480eae5799a0bf390d9be566894de6aeb50785f4376af2c7ca3fa40858a9e8c97844bfcde1f4fa5f901f26914c4250ff88c47ce20fe67bbaa2498f40bbf67ae4d08f77298f3c9e51d841dc1e6bae7749afce50f07b78ce3866fd349bb06ff56fde7b681658d704fa25da0acb8454eb2b87a24b16f8b8e29b08f7ac314920e0c6e18688179bc3a9eb9c3aac587ecd929c3f9d253705f22d56ab9784a7db49838d520f6147b3e751cd182ffa9672576ff6dbcef81852bae831b272967f35f5b46e22aa45695fefe3a35cad03c6fe3d1214e4d1d1570b62a99f8609b4b68b13e1547bfe2da9910285706ef601318dc18d6099813658f9fd1fe3ad12af79270ee0f38004db3591cf88e641e602f033f4506264c75d1667bdf056544b3cdc5ebc8ac4bfe88a394b2ad8820b96bce64bef7b5c3e15543fd21e2aaa0f827fb42fcf20cd172cb79aa8fc18614590a7bafa2123ae8efaa246f9ed9d0ddb7b46f1bbc6f04a771ce17c7cf49236ee7e57c84070a3aca4eccf5ffc1c3f7319f0aee97576acc9659f1006c8d5a234dc8a154de65a1ed38e6ee6e9b916aecda4df5f6e1b66d0f052aec219b620d79ffedf560eaed84dbc7ab09a2e39a38c095b333cdfb91a8a0e62d7acd13c23618a38d4a792ecbaa527313144c631f552d404a90f6f59d85a964d07d4984038afe62509627f0aee7345bcfffe7d5bd48320820ecac7aaa274c2980f5eea20a8effea0aa2a38d6e0010dbf7c41a2d2afe8c72fd00fb2264a4ed338512d1c1305e3f74ba26babc05bbcdcc8c47ce6994d69f1b89b792d452c81d7a4d9874f7bc972ef60fd5abb26c6e9517ef3b4fef10c0f6a00a4ae226d318bfbdd139ff14fe93ed5039f2f8a9eb6657dd91baddaa7cc9e17db0e97c284a9c3a07d8fd11c11f9ce9030c6d76d03fbadddc3c09e8a2a27333394536f8e095416eff025e7fdd92255207509ef522f4f0eb31f4df92e233067cb71239952b1b34de73bbfb89e01b92acce1979cba59627e725b030e01cefe37dc42eca3416d9d6ce272ef49c79353868ff5690088654ad40dd17df7da1e9e5ea3290229eb06b79c78662da68d81f48c67577b2e9a5bda1715b0328bddf12c8ee7209bb077e5c120721cef986dad76d14f2110afc0db22ee31c007f3b72ff8e377638b91d2452e914027b2c3f590d9f28a667d9aa014c2b37b65b5098295dc00b79aaa2f9e5e6b0e09baddbf773dfab8b7a35e9ee4c34bf937023c29caf8d43ed185f63ab45038f3f64497d220419f8d4725fc66b03c1633435ed8417c048b208a5d06d18e82c1dc19045c71e5079b577af8b9487fd2631e7a716d1bf903b5f321842d6d12d71420baccf408a13ed183c5ce1c33552aa69752e693796a7411cd208d16a741f6bf740d021c5164ad630578ffe13d61c53fca22d7df73e1e0a8d394dbbceb67eb7778ff0eb22bd84d5d7d21dbff10068f09270a2b1f7ddef00ab8932533168eb3b88835551f0c90507e86b9abfc612c0b51b65c4d0fd3cde1de9d964b272eaa37e5997e7e36573aa6b58cd187ef1420949d06ea330b9c520e3c770728e24a04f40eec891ff441a025e921f723610f992a25f47c2399b471aa86439c71dd38952c13b03361a4a4a950664ad42c89c1bb593bccfe778a284eb96b7cca0d3cb410405f9cef6db28db4cd04041b69d1275a982957040535785dab321a6dc59e1e01891551043035e65fa970dbb15693abc3ad32d089f9ea52af4a5811e08f435c7b6229efd2138f5792e1b855a774df2e370897c90cc7a625263df24965ccd13a8517285fa0d07da124e0bb0eeda90ce3bd6da56c9e70c3f7ff3aac31a2dce654ca799fdfa13dcbdafca822bdb46225ad736d12dd8ca8b8814e7dd0d0df62ee83849a0e6e7a1e49761733b31f1f005108e6c85777c2260427b08c2ba9b9a2476580ff9f12ef9ea3c51cf494817395b513ec65e0d2698d8bc69477f3595249baa0f2052f7242d8f7c6fba5e4c046ea33dcaf3487cadcbe9eb92ed54b0d906c6c12e70e32d9c4ec8006ab0ec16fc08bdb9dd5aeed062521cff5d67bffa6a8b4f42d1cd99a7a63b593e24a0f0d791bed55fbebda6c9c75b45d8a2b4871d93cda0e27a2b2550f1889e5d2bfaa002904fedf6a850373eff7e0a9286a89f2b7fd0108c416ec60f4cf47a0690f8e1b65f46740a8155e2747e970cdbb95a78e7910f7414764dcf43a96fc90244a8c71f813bca8827a0f51191b7345088185f6a7b58459169a73792b09c08a99c34580de6375101c521f02e103f7391cb819666b746335c513c9007fa619aa11d8d95a3e78c381aa1140d772a9430e244877fa60adb3ce9d0ae7ab85f5521680e33856b524d7e7f7d9dceec1ed780b868308b3ffa7dc2c9e356bb192c432863278f5c6a7278160c7d73d535fec8ce1751e333bec547e5c97ed2df2e84255b6145d212e5b1e11899a0ed7c45c33fc5bbca4eccc51ad88d54f7bb8ab4f9dbe3f4f3b9bec5f20f6046da99086ef09fd97f3e149b7cc14549b7474068d185d3fa68f4819740955697c16b5eccbb056be69aefb0dac53ceaff25c5a012e3431191826350ef524f3e79efabc86170ed434b9db557ff410985a260bc1e52d19a8c2c46823ec70ca68079de1d1f8cf61050fb4905a05a61d6ff64a83392012ba9bc511b395104696a773be09aa67bd3b80b48551e37844a709e40bc643c3998cc106ce13302bc788bf1c5e99e654b78406ffb36c7c78ee50f89a58ebdf55672ad64e4758b2b52803826b85b9e715faa055c73b2d9112e3f61f5aa6defcf697b06060227b13041bf1b462aa79c74e755e1160ea290886bcf1ae15816716c368c7954361abe157b6fc88a62d0903a4d41597637a6cf5f0be721af25a6a298bdbe05ee65f6d4a42338411fe32cf4808d85d0b7601528e6bf5caddcde614780b0398d6b0e49b7f44c77f1a42f609eb920a18565ba6f2c8eca6513f938cd6a2e41fcab80c7f77fb9f797fe93c824c1fb659d19fdd391ecf842ccdaca8245e873e2daa3ea210ef85358aa06b8af67c014e57352e657999a9527492fe394e69770fcc976ddaa0753020ed04d1719b345b29bfa882dec7f890f32866501c3eceab6fc6c84d69e464e4ad649070ff3e78748c1de6c31e448dfdf4520a60de176643fe4a1885c1a43b605bd4763914a61226895cbd3d86b2dbaca78547f4203085e51430fdb657dc4fc5d17561061ff5f7d0a613acbb40c8256c6d905a0cf0682f5a2821770a46059f0e124d1e48a5a21d5f96313cc02fa4b9f40524b360c06d1610a3f56aa4cc9cd82f1ae21a7eeafa86b8b300d13150045dac038f6432a9f0dbbd7ed90b1c298835ceae3c1749142a2084ff1a449faf8ad84dfcd4c3e12581086d73d72ef0318c1349f71cf4dc983dbacf60737433c570a4310f2a1128090df001a77f9661ad03af3f665cf2f9809101ba997f0617a3465bfef8079d583c9bb6ecb90b00bf0c53a092cf223c948cfab4ff902ef98efa4a0ac091c129100b25ec4083b49679fbde33debbf76bd0922fba801663c3833896c8fbdd3bb6778b2fbabdc346122082777201527151fd90f8a1c1cb00ab38d229d95f638413ba2cd4b809a4eda7d5bb9db733968130c9558ab0486ad4aa2eaf3a1461a29b1b37e7bd4a145288dea656570ef5b8ea8da91ad5b4790eb9315e8c3a7fd0a05b913bac1e6d8fa49fd9b4518edf0d79ade7ae5648aea47e423fbed0ed4976d943aedd9bb4c9c813e50ca025c495e45c04093c6139fc7f1655d0adb8992f774323cfadf0b8edc507b7ae84e982fe703e8c2ad9d1f7c765b43c1145206616be5ed9bf8d2975dc8b1c1d85053abec274218559d22e3fa8a6b819679cb3e7fc5b5e3e61056277e9d5a8f26bbd3871b1030e5a2485ed40844d4b39666beb098d5a908f46c84aebd201bd3c2dd24a9cc4e5a749cac522b3af10225708b2d0fc5c5c695da692a2b69964da9fe303591ce49eaa1dad6c70936ea5d3fe007ea04442a0bdfef6c5749e86de53d3d419c7d8d4ab3ed9d25e45cb21f8408b2de7ea1a227f267f8e5932781cff68fa6a1cafb2841ae2953eceadb5320cbdf13f878016b89ca9ec298186f939f2df11e98b7f1599ce24e21314c09ebd90188919e9ac9561b245951595d6049795b9fddb06bdf922388968a297a5648fcf5d2c96e2fe79df610b0405a9e14e1b9a381a7e6bde028192f20ed7273591dec536f719e30ec2405b6df5bdfb779dde55ec92f932663cdb321a80b2ec3d629bdc0d12ee1a73b00ceb660c85c314dbc08431439ffc09e5c8a34eec76a9decf43de995d088e471f789a12098f89daaeb39792acc85beadefea3041d70f04e9aea044d90cac09eb37d75b114a14c22e01fb97d5a775ce1e2785b9fe3470d1e054034d612a516183c787c92c5e41cf694dac05c3f8841358a391460bbf431dce8000a6ce03597b6b054fd09cad87e0dc9fc711046793e9006f09551725d00b3ad2881aa06eff1c290b5b6e9ac37d6510b58ba752c8a4b8de25e1868a81d4c5e0cb202cda39b448f0c2072cd6bb6b86b7848af0d5d615c6cb3f80afdd78b7c0f883946d912f39a7ff88292f1caf7977cd09b97293583ccb8c0542a50e15ce40cf569f9752024ce33fd2c5e985a418b351f1d2feae0a4abefd574138499303ee7bb69e81f4ffb464e5407a7cf28f64dc742ba5bdafdc0a24e689deeb1b4d6af76092195b0481b73e8dd83874a8caf27f6b101cae01a3e6bdbbaad22693790adb0d2313bd073ef8f201f976887d035ef160a12fca4cd0a14b187ee50bec303c375ece58120ea706dec9a7d0c66f10feb083574397869d30857a585de43d3cefae704c6106da87d27630501482dc9d322a2191b6315122806e4eaba5bbf86a99b6f43f5bd13ce016f7516b3ee42caccc822fd57afbd87e105ab0675958608bdd7c455636008608ea612029949568961ea967706e424bc1d1bd93e9b41b78f0429bf0d4303d1653cb7daa7a5f5a5eb84c4329d993dc217e603515f9962cb556f8d4dfb5bfd5eb314ac9a05365da6b989cf3c6795c0a0241ef7b51e88e0df672fc42f92c616e135ff8ceb8730639626fdc9f4635fbf0920ca229134672d25468cf6a4e6c6854bdb4800ea6f6cea0166ea1888e4c5b27da4562a8be5cb6ac4fd97e4ed413719a1b78ac4223e512fe398763bafee6d0d39a7f88f805455ac1147a2aba123c52cb6f8860d38d16126f14ebe178b0eb72f1b3714d860bcdf7a2e2b40d2c2550fa3fbee7355c680d0c27e2a1f1073e3a45a16e969a28c6f24b93d3f3f6d681b1a1da30a169b443b27dede92e8328102d412ef4ce1bbbf65090859ea429df0887c51ee1f9ae67293602996442e8e6e1a581cca4c67a70a16bc1564f1b21248a0fd2a6a0a08375f7881976bb20538db66dac2f8e71a4c1404db78676afaa8f516088f320cca648fac492c0cf782b1d0f041d9bf5195d03b053bcc0b12eb22f2da608767ae25d44355d36a6b9640b885b06662b32dd054d48a2434dfce95c1b0d55aaceac045bac560bade3d199f69a15e8852adfba5f81d8416923018a9f726e748ad3aad54225618db6f3617cf4cb9e261e552d3cfc98926b23bcb35108878217496a4edbc9ea357d59b3bdcd49326b9c429ac476478a1848c0533ee1b29202a0771cf3ce939d0ff8ca3ba5af04a63eb7c0f23c5278bf3e60c59c77f4920af3af4ad353afae27063db24bbca71a9baaa45c993b89131d2f746dd6c77071fa53489ba34a6bd313463175cc800dd0978d625277bfbad76d34a614cb8909252784e1f7cb494601360b22416b585e0b3bcd552340163dbc65438fb963894102180fc5a67e3b53bf59f6e749e250ce9ad2a3cad059a7c78255045081aba0f603558d001978bcb4133e11c3efe04a0e18a1a6b042d968242a46d5ccd6b7db3702a598fc23704cb635a837b6457287b0f660dfb3e93df73c9b47cd6904211bffcdca50d598163afb52e21d7b85885bace0bc90457a60caed9d4af21ee31be182707720af8f5f98857f92ca0f0d1f83150d683bb9160eac70650f079c6268c8b06a94ddd5ab25fb76f51851856132911d04893a2a6a6f3a58ea5e1c156eea9fc85fb9ab304c37c916afcb1c7b8fabca5bd334a7499f14f2e8d9d34bd030a0e9bff2c7c0d1e520d62ed2783a201bbb8a05db9ed28925747c4c2960891e0961a5a67a57fcb8807652245958ad0510dc655c0b49da40e1d6aeac8dcf81ac002db63bf294ba3cdcff8a0d338f54866f4fb1274947bceb7072d6957ccc4fd1d763375e5d8489f08e0001b467c214ba2733c15c3aab9b78e14e0dcf6ac3ef26bb7c88c6b6fb3fb5576cd8416bbabfe176d7f26ca917672c350db6ec9b90d94b5b80846f711d3bcdeb5548957ecb1a05612f3ea54a00daf40d58faa30b464a6d2034b25ffbc0663e9427eabf61c40d6b847dc5bd441cf3ccb8bf305ae318026de91643108193884e7f96c4228393d1bf8b2fb8b46b08f44cf8254f3d7329c722ea84cc3a267e64f274542f407bdced1bc7a48c802891a04ecec7c068ce9e8c6026fd03c50a8ef474cbc76cfaedd1fddbb3002fe4c83855142786bcfb1824e205092236dcd52c152b9540573d50a7564b38a34d400725342bfc4fd5a886854f736d394d728984aa637515c8a9e7402464f2cf5ed4b3344540ff8a23af96a6a8a1e491e64c99a8785b5e0dff815d7778bd209c7c21ab4d9851f01ad9273eed6167e11f8bd6276cca38e656718f614fab2ef7b203104ab14f96f1bc747ebecdea9224b1f9d6b305e69260412ed39585dc657d369877e96a69674f8af168cf1c7e621d1c96b300dfe26e58ace49f49cd50d270c9a323b7eb74792fc3b0806cb19fca74e354956bf7fa64210c53eace543c77a9d41daf3c8035886fa921967282087bb8435440ef988f865987d9588f04c77745bc31c29794125acf178bb8534f23d1e92aaed857b161ee10a74d19435331ae41e4985c758478a2403228324aa6b163b15b25e98cf7fa35393d87273b55622e9589032084a43e47203da72239d882c01ce9559b96e49a1a9475be34fb6b07f7d1b2bbc288379160d07c7182580582fbc0c598255b9d07ae3230a0142a47b0dd09d295a96923567d5da81602d04c49a11e6490c2fb453947028ac4bebed08e635e0e560dc7f7127eab3b3fcb14247ccf11fb510d385c6507a31d6bc582f9e0ecc46c7d60b9cbff245d12b507e92275e185dc5af71338df6947e29933b59b426f21b0a926e0377d9e2757b54e46630d638c08f5c40320d81389f3f51d4962d4f2cef4beb2b4bc5e7babf14a537f152a6375102f1340849c184234e150d34a81d5eeac07120beb47a58f1d94301039ca5c4e68a0d5c66fb2a208d3489d42cc9642444c20937dab588e782bb27432925ceac70a48a347b8f7d286aeb2fce377ad79d83208f6005aa62074cd3a41ed88f89cb49d3ed9ab70f34f7d71d0b94e76f5249da29e94063308e10d82c118f126943349b833db179ed4817488acadfc83fa616546ec949c20cccf5374dd190c448afa2c3a6ab70512d44ee8ca428ad6492b3544a0f4464e024d970c30bb1449ba626c5a5481fd0e21d2c10b4658e00dcf7648ae3d5e4ffcd48ccb8414cbdcf15dd3be481f06c3f4e0bfdcf176b18bedcc55745af43662f81f20ad8eb8b90060333ba267e413051c4a5d0982cd69042f5c1eb2e01fd20eeedb67d65678119fa7375c3bcf495cb31fb65fc0b5e0ea758dfdc8c9f0b44eaf84bd0c3d9189f72edb8298e47112f2117f78fbd0c7695bd6611f43ea625ba3e6a8cc974daa9299b820be56fdc5551c4a3d4801fa47126660047b97cdc0c5fbd8d53100a8f83064e93601caa105d8e2542e7a490ea79b21a532579e1485cfc55a1aa7fd36dd477b6ba8f462ece0a8c8e39628f71afb2574b811c6c291086eb2baa248a1e5d4676f9f7bcfcb7cd624192b084b84fe886722e9592e5376290009feb73f5cf79a7aeb4ba068e6d66f26acdcea3a44c7e32a20ab9bcbdcb12a303ff20899c7160e58c68afb59df18bd27e9489336fe747706d80cbc35c167df3e5a5ee00178db126e9ab6e03ad15681de6f4cc4ee2fc096caca68802800d68de82a2e2578c30bda968620c57fae44949b4de9a76fc7a10f7ac27908a3c047fe623fc2d131882863301193577d04f87558d4efc952d0a1fcf2a45e27ec4cb90d78b1666723daf72c571fb66b52935bd7949ca5a03061814b7aae2fe8a7a6ea0defa083007a85b2a9aa193468a88d34be40c8bee60ceb00b661f319cb742f7fa1b2ac9c80815e6d3a4232b29dcd8c5cf24cff8dd97bc50c7c9f59f5b1acdbe618a5f3fa7aa5d9887cfa215be3191f9dbb2a410103b8ac7f8cbc787d040ad625edb8820afed9d39a77cad01ab666704fbda36fc346c1fa95434e5fc130f5a4dd8ddb5d51340be0507567b7de5cbd72bd3a105d4d1573ebcc5adb7335c7345d48e00b8a7594e6b373332ffb65de95a43705afa9e3db105cca76e9da88c02f5c05efbd96d798ecb0343d4b95d79a61f85c626d5f840fba365ea4830a6eb5bc21b09c6ef8ee7be6d03cdbe127b1683e4acfeea7f9fa7192d58dcfb55609fe767bc5c32656830d1b16e69bda448c1233d48d33394f3ac0141b014d6f7db1bf1863054d60e9f02f6437a027b6988ac6de6da9a799ccab793c822f0286dd81dc55bba1bee3a4b4ee338c190562a1332ceba615b6b619ad43f3f84d67d2dfe2b4c995ea087494d0db6b835712212a770bd7df4cd3b1db690647a694fb8b76bbec342e8ab6e3b49f730e47e4f488f94b97bef92e6ad26abae718704a441f81f3cde52cc1508eeb6356a435c2efe9167e620475ffa9059648429d5a0c13a180183f105c32ff921950e08b158ce0656744e0b9d1158ba90d84d95859ebc90c3d488589501d8ef343060807c234e4f5bb1e9015ed8df7bb9683e2d67a1cdc204e565367d3a25f46218d3f23a951fb1ca64b5d052285f585a9556276e6d780ec561b79d19411c4c2d8b09bf4865916d4fa706c2d09a9e7b88c8a3e0c8bd2cc3f62397f96d72e2bf95a2d93458d34688636447e603659678ba258e546680405e1f23f06994a04847fbfcc020959890201623aa6ae5e0690570aa0d3045ee222f76d1fcaa7c6e71c36e3b3ea0287e3e7e4a959bc8574846a593bcd59d1011c360ec973a61a420650e6d47ee19b51d2118d5c1e64b90a897e5efc1ea30a3e8cc4ae5fb51ea4eb16bd73c3ab36610fc5153aafac96d19b56c9e3e70822b5b880aba6014204ae1f7dd436dd185e65aef278d55167a6cf1e8b20f836d62afca17011e1f309d694a88ca08e0ca4ba8b9957bab5cec16d3838edf205aa32df176844a3e8f10c3db68f0ed29a3cfb0f03b23bc04669d05d851f5ed7e8806d3f4cd1a951c56d153e4caeb31d0398bb09a62b16324182b183b00b760dfc5f02243142c5585c706a7ddd0416d61077b2d808999c031ef7b896f9c6a951d11c531f34cd3160de9a97bd708be82a10e38892b602daad549cd3a7fc970af3c5c59bd149093f03969486a7c782cabe8d4eb3cd8052bc7ae70a700928b8a5569484685418e4231a4e5d95d7fc1eecc9d73d92db8b372a2790959a85b0c59a91eaac158ec8e623b51b925903bb083057be116d2c4f55e54206064c7992a8b2c90079a3ff1365dbc24a97baf6a08684bf6f19c687842adc169fdc6c21aa02d507a50707cfdb0c13c5653fd1df1ca2b0542ff39dbadcafaaf5d2c40768440911507152043abb3a033aeabf80cedeff9ae60d65818b1ed7819743bd3ce9ab9bba7461a0f7bace9005828ad764093e4e0560163978a4f7d77db6f5d2b2482a69c6b7e1e310b76a03f5a97e9cba206207d2905f0e9eca538803b8b6f3a0a5cd28d685fc0779efea28c8fe13340186d34efd5aeff4c6c1526bf9c40bc348cbc203f7508598cc7c826fc474efd36b64c6096c963971915355e80ecfb44d91508ce53a600224945933b10861f4a8a99feb6419982205415d451683c90f3647ff2c3f7bb61725049a9e6be176f6cae3efdb3c436f87a9b864446f5704e642977870fce63afd30b58b3995f117ec667ad9afcff234ffe821755baeed382165e1638d6c680c86e20e38674c94b0f85328671ef9d2add0c348d6872b4e00fa5c07182e0523ca00a98f2b43758819b5afea485d5aa06a8df252c2b6a27860d42df71f251fa30cfdd5e4e42d3f15ed00801b63717e77e34345f8a64a8284b1c1f3f96dffee2eab8bd17208794df41e08cba750013578b02f90f36d7257ca99841314d2fc5f95345017e104ebd2407921cefd2c3cdc64ed644c49aab93134f08fc80aa52790b18a749cbbd5c3977128efc147db50313bf86eeb1f0ac905181a87878c2f5042ed8a38084c624551948158b754cdb641f6099c5b1e6fbc417d620047337016dfda6bc6f61b4892fecce79f536bb2a19d2f925e56251a71133179457544d5e51146331e6bc0dd7ab009a7345d9a440c1da23c55c864b808508b146e8a564e548ae0287bc2859b209893b178c14fb5457ff83f894938b838bf9a99877fe01aee46c912066f8afeece32aaa0151a0b58f14d1795de3e0070701eea345f0e4fe43b40292f2546eedd26926d858b902ae8e4c48bdb72f0d7d2ee9c0097ca4557c90aebf13cac23c381c03293ceeedd0d34b06c04b086dd9119357217379c6552a03ed13da64a9d637d692ef5dd91f93b62be9353548a49b04422580b1a5b7407be351932d0e8c50df970bede961e4d147934d1c87c6f76f26a35f239daee198434ebe5c7d50c778a995d91f0a241b9b66ac151c0180654561ae61583bd75e681bf51ee657288077b789bf9e6a55c5a0c2931c86c30ae51b6b6eda6be9669c7de2ccc5b443e707704e087086529234e62db7bb7e6acb12ae5a503909179fc4eefa712e58ff9e2cc750c19b004ee21c0f362219e379816100bbc3d9c8ccd0631ac1425ba4911bd4e309e53f45ec257f283eb6544b143895526368fbe8744a1d2a5e7cd92df81a9efe934a5cf215270c9a48a93a234f6049dc12faae999b709e17a71d7e5bcf2add95ed4cde679dbfff66aebf27904b05f633271f93f7e899e0d435702a5c72b3a70c218fbc30732f1cc058a8932d16bd431d74e5a6a7a3fb76e3aab8326d45c23be2d367173c2157fe2bec56fbcee404210c048c37e5b0be5abd4eaefa51c6439a5154081d8324a441fd3e649570ae0c5e09302c9da248e6c0f4d83e7bfe7136c1ce4d83f8d5a0b214b675b7d18ab1808b58cb766d0d96fd5b3062d990349b542b9c689c5051653aaba973d6eb23f78f8e6550700fec466f9a85346868a07d66db938c0e3887b325183b8882c312e60fc0d10715c957641fd9fc627973a03079efbb18d1002574fd38952b9c46e0dcbaf52bfd90ee2979cee47a7b9e8947c0d91f0a5a16c049ccc25801dde5cdb5ddaebc179df2eb7676116ef9e449d1d143202b863d4a8d7f0820275cbbc44e164da8c6845a2039f3b7f49481f04469381662548f87cdc5193f2d8a767ae2c03438881c542380b645a8def0328d2ad55a2d439884485142dcfdbbb07d7404b9e4362ea5823c17115f1fa6419436b63211ce2bc017fd8f6feb38f1e90da00d88ac5afadb6af3ed2b2775880678171fa616d63293610dd1880467d0c9438ed9f94c66aab294ed62435910ff8d191ec845f82ab5656d5a7ee2bb5b0534dc532ef18215b8594f93fbb76cfd47b1f8c398b3db2e4bff4d541de0e0983b7e9b482aafd9500bc3b7ed2139ee3d74ec2bfa4596078420241869feb123d0a6aa85490b03daab7ae60e7e1eb3bb88e2b29cb097bf52373b9e4153448f704bb4838b40d615e56dc2a432d0029cc22196933a93869c9a6453444f05bf460bb6e02d5d5fb51f4dc42f23ecabb5d6f292170c8c532aef7456b7ea4c1bb2fa66b8fe62331e3a5f17c467160f2052bc90dbce98fc3e7b65ae0217759b4151adf540887301b50a4b99f88125ed81a18098a4bf0849492acb4c43b0a7b5cd7f207f4914166831046ed1d62feb07f741d673cbd12c143a86dc84388c37a387372c32c2588864bd39621a6573ece9e5902ae56570d25950dc2bd248768450ae36d6dabd4e1770ebce52179076b820c32d649101a2e9086297749d9bd05b4f5b31b2d53461533aee57a856ff59d5a5f4002d41ff7d5d9d953f4895d96fe93bc846ba63fed691faad05cf2a2030f9d9abab7725818289d86b54fa477a9ee023c60789f4df2913709d385ff1b59bc133b69fdcdf1536becefd23a196c531cce9fab2e2b076a236bbe9373a164ffa72133a88f6f31d27360fbd466969a88c077a79084473c7594d31e502fad2651203eadde44cb184ead57692e12e234870c494e55c110729f68ebe1bd697dac3e5acc62f8ee9149b15affbd8c79aec19a9c2e7688e8ee7fbbb8ed324cd55dfe1586a814c1cd37e5826be9b47178598519d5d10819dca07f690088bd080a98625d33f50220b3618c476da0f6789ef247f719645367c9806cb6f815b0f8c89b29c9cdaf0cf2ba21631d0b3126a45d68052358308dee9660a39bdcdfb7a8433e0a797a35a6131122faa2d0164557bd7a033d5c0bc0dd0e0947d9cc4ac22fb33f8a8474a60f0e9534e4512080f32e5d3338a9ea1cf71179b891d7085cc81972d57554cf80f1182aa7372dc4ccd6eaa2937a6a1aef35269f06c2662f5fefe96b20f8bf76a90ddddf5218ff59c377bcd10d3fb997bb5f23d4fe8489ad06adb65c6957e99c08918ebf72ffdca59b74ae38e5469161b6f789c4291c2d3b21e632a354733beb1eb467aa4ff5eb3a34c239dafd8eafeb32ab195a7baf4bd138cb1b702d0f626dfb427202243e2a23ec8644ff90e47f6a1b34fc4183e5dd2a162f91b36be3bb03c597dcf94586c48a0ea5682c2e5245bb9b050cc7344334446c3e60dcc64344eadd6d93a13a12a1fd8e6bb5a6d2e6a97b18aa04d60991026614b9ae338b9b0234d804812733d11164e1d9e118564a3da52c729074de130c6a7e81136398508da7f4a2f29b723fc0886318cc98a4a187afccb0c95002be612adf2adfed7abe2622747a306c46aac21b4f654a8a736dbe0bd04359b41993966203c179277974fa8330e1dcd073e557f98c8a32477a18f7a185636354bc87a63b7e1b3181980aa459e72cd205da29408be1af9527ce33b1e73b32fa0b0c31ef282e485a84cbb12226704ebd6eb7bd9358879f37f59e0be4c90fd826bff10795ab7e064e019427367b6b4ad16c9b09d58bc4f98d6db58634cd8e43eeccbba564d8f91f3a83ab8afad5feb0217ea06af1297499b68ed919431d2c03795abca59d26d54155468790464979dec91e0609edd6e998d02d005ad2035e9cf48a9d2369b93bd3a82ed6129eade58f0c0f59f86fea9f31e2997eabe986052aa4bb64d3d0031a8ae37860f25be4db76fcff1858b4ddef54fcb98ea3a640fdbf217647911c034afc87e50c7c839dae735695c59eab86c35e6e7d13f97f922746297524fbf90ac3633e9be88f4b8ec028b8c36e87857990666d0bf168bbf1523cd399a52d5993b621bfdbeb336b4ad999e622a7fa7f3042d987792d2b1f6e9d99373e97b719fb584184eec67ab8dc1194bb9d6bbf549a6b8342ccb83bbf3d147132c154d13ac71b132a6192e8825cabca15790fbaa8ca606a57060217dc391c5b8383641d2c2539a28adb2b26bd9968d3ee83692f89a7ccb37b5d9165704c21d842f62ffa939a2570c75708093d410b5e8403a483e294b67730b56344e1e1f5fac41abc51a085b597c65b49cdaa8defe94ab3fa2f45bf19a87efbb794954cd630a0fe97af5a5492d41b435cf63391fade5cc26c57927b2061f2b51b25abb841f35432ef55392e5287029e7478a32bf33e0c84973d34357f5c207f6462ac691de36c61f63fc96b06aacc99b37d8c48bd8550d61ad7630e897967f5e8869f630eb9153e5a39b94d596c1f9b08763c1d3ce5acbaf6d11d1b5d9cb3ea19920cd9e002105825c608f6b36c67c6240cfa7b27b5d504e0d952508bf8902b0a79e38c482230ce98491d3a3259471c4cc963f5d1ffce0519fb0bf8ce8a6737cda79a7489d351a3410616bb9b38c1039bcc414c700d4b8bc3bffc0869a981906134387962191ca1ef4dd34bd8569674e11b47484dbfd0a9ee6ba3d5e700aa0399029e717e4612f79127d222f47b57947c5cfa34ba6e96266c5be0271a3304ab45c9a5eac541fecd7c4e915f79a6dbeffd890d05b4aeb72b440bd632c58c2ebade0d2d644d0b959b1b3b60ef5d511375b09be4d67227ccee47b327ece9e0c5483f34b0adc6183ca1a863c45aed8eefa8139b19e524fc44cb2b616f5d7703a2f2f8fe4a37bd34c180868e0aabfadac680ac14976093d52dba7eb73f8817cbed0aa7e1ecd2d01ee4f5765fa48eadc0166933630695df4e1b8143f1419fbda5bcadc460251c72ec5a65f48e90244dda5618092b01de380632bbf1ba73a0fb0b75a87407eb09bcfa86adba31d1a14395046b1205f27be6e8cb2460ef2e5b95a61974a5f60139d96bb0a17b2bb301c667a3719d73613f90d695fd08bfedc79a8afa8d296ef58f8c59e55c9a88ee53aa0caf9e5ba8d9a18fdb44a1bfa1b4c588f2f9194908696c7a3f192d45bb4cc316710ab8b8656bdc25a1f5fd440235da2ccec8d7cafe415a9677f88ade178ec597c715f8d88216f4f1c7e14853df35fd4d82ed8d6b4bc0783f646692a0f7900a8a65704fec04993ca1536d0222983452216e4047984a67970093cbc17990570a5de6d9211675d88fba9f0020a7837566968211be16793311db05465471c00b1b0e12f43b56e3de7a5612a2a2ed4bbf242c576e5d02e13843bad9c1d5810512c533ccaa8085e235c10cfc6c96340b674367783be32fa64780fe1b0a1cd9627a2c4f37a06b399443ddd87107d96ad57fe887b734f39d5749045b081f6024f6aaae516b5a956d09e9278ccc57fef27a2f47d49c5ecbdcc662dd66be181a5dbecf149815a96aa0480e1b80a37c6422dc0d1a24fba1b67dd56b812929b540c1cf47edef0853c61d2bae83da8852944ccb6bff025b1d9e4a74512307de978919cfca6e536d630966e94bb092faee5101195be07261320b2736e34114244c8a5a3c0cef9588131c8518be7ce49287e419e6d0a473e35d2cb2a3cd7b67ef3d2515db90bd9653bc4cd1fd1b67f6f4f7382b4534ade33c4de3bfd2596c5460288d003f63abbbf43f51950692b250ff99ff0248cc8f5c7a21c017e1b82de2ee3e33deef02b1d48c92a78d2ba4510c111b6412877d8b928771f4e7aa05a4aaf9b5ca6c579e6319b40eda0a782c194c213f9cd0a89fd7ae289d784de655b106f539e26c1004e98f1b50b0aac06e220a7643329498dbbbf142a030afd376a4949f9e88b801f7b12522f90945816e9be417f175d6cf8fd051268586b1db6f9fde5240ec4f42985e6fa4ffd493ec5ab4e46d1a97db349568d2276b2cacfdbae593124633bc74c005e810b17cdbd90f2de23db460c3667405c7b2d7474b0591350f334e460cd43845fae27971830e4b5dcefa9b7f78098e91c4ae47e8ce5463b2da61e99bc51e01edd154baef439dc8e28aec6c334c496332c879b33e918c56c1ff3f1de2990e9d3c2fe27c92d9e95964e9e9340a2762088dcbd18c48654c0513d0a3eb3a4e0ac3f69f5e92f40d62985e4d0b4866cdd121746a73271b1f25e39572ad400fd82d86783c2c4c452d5b82cd0a9cf55b72a3ea522ec472ee8576a83435b84c50d68fb1276e45d81a67b88742514cef9cba38c2155c7a97a6fbf6fffaf1b18e29ca2616fc8d18228a3448a1d310e9ddfb74f49cccdabc30f415fb5993f52f97e2176c1c18cc0c2cec3b7722c6ae941422e4a4e94d444e862907f17e07f565b550175b0b57492565d9b4b00ab49cdd50e201e9d8c8e30ed7e83eecbe9178a6a8ed9b650aedfaecc4b45d171429ae9cbf621e590454d41e1a271d8546889d980b77ec6e31017fcdfe21818d6b725f55d4d8d230fb9e493d9d35100c8a8bba14e9161d72ed08b85794a985821df8eec27fe40de2b6dac52c62be78619a3f82cebe4cb6d6c291d37168fdf9500280d87893137a1f9488d89a3d782133f2356502052f8602714221f15459d5dd13ab010ad52e9be8efc7c5e6e2bd6670473593faacc6eb428612a5e98c9382a738c9ff8c404a9e25f3197bfd591978435e6fe7aa2ee2f4abd2de0b381160ced58575bb90a55f72d32b3b0bb395610fb22595ebfa5af0d7233a80a4e0db67525bd2d4096594f4f68fcbf035fd2852afd396977dd4cd088603daf0e82287bb88f0fa9684856d431a634f86a46dbcf4e82bc247cbfe96a6b7f49d43fc64cf09c7ac99225cdd52211a1e2d63f72350bd8e98b7bffa5814587552317213e68791452aa2147575d0b264b8c8586b1df0b49a79abd3620e47fb3961d717c178995fef75505dcd839cd011a862a784211546d8eb05dbf342213efd44801fd5a9612521fa78680e7bdd827496b22816ecbaa6274d5adb7d8d2a17f05756e4f54c35b5c1cd174aad1699458f7a0922f00f6ed5273f3bf90845976dedf249da8617d75608c488409d1f8d656a67a378da18f4a5729d19f5aa8e4bbfdbe698f7c8e4529dedf25eae2fd189fb042d66eba9b1da533676858af66727dd259ea0062c5b3047d8430151d21dcf7d5268b4d5b6407c3d4646d5d2da14e4933a45a3c2e8251f0e0348908e7c8013d818ce326ebf1533cebea48cc6e3d697059b73581f2ce40b7238d54887c55dd4b6f5c27bc49bcb85a80ac6b1c311cd81bcf35bb8caaa5a769cc025d93922db7d3ee3ce84736308dcfe82c41a50f08c5990aae39b0314dc29bd666e540371776f8ab4451725b5e7bc0b43228127a22c9717535975a9b90f3ce01cb6f44f32ea9b8f4e4feff7560917825910bf029b4c8d35373879f2623078d66e52050e98ae36e28b55f15e93e9d7249b5cd823ab17cc9a2fbb7fa891781ee712a6e12371f5fe5cb3b2c9ef42345e165d8ffdc6e257a715e911a44d5c6aa880f3a86c302d6a2fd341477373610ec28a3375ee0f99e98342bdba647df2dba62c074d4c66f68c3c0362498aedda25e4881370566efbe3f955bb68946d40d51d039e4549543e6f7e5da2ce8fa4b5ea81b4de605bf5e4f48ca73d234159fa33ffb99f60e8e9cad35a0a72d722b2b86dd5f02604b95a0c9a13d44dc0c004ce3c7c51e479ab940a8428a0744c2d0d3cc55dbf0bd51d986aa6993e898f0ee02ae6edcfbf8716702faa3f7085365d0941cb8adccf20e47db5d48d7c9e990cd0172b5ea3a789e816165506e7488cacdf7998667c5bf0c30e08973d40c1b02dc7261ceef4486b009a3130dc1e05162b7d60a90a6a5db88d57e1745374c24b808b8ba79e7c15179173c9f51f687aa2e0a0a035f48e2cfa206400e40165977290b337329ce0f38646082f20c64eff1b52625041af20a1a7440e6b1368a7ad56f8f2cde372368ebf5d1e33e14b7fed534904ee11297b3060d9d55a3e2f0d337a2345987e88120fbb1c543dca490e7c11de8e6d610259674ca63124bbb94d20e915b1245c9f296e299bcf0d90f5fd170856955cfb99daa391f93442369db04b3cafbe1f7053c66db7dd0ade7888f9c3ff9e83c1339c434d4e1869e45bdc21818015c80a5dcaf5e3345c6550baf93ced233a0cfe909f5c04431afdb7870f7014dbf823d170c93de2c9c34ed5b01c9cc4afe1d0e810add0ff5bf3e68fc389f88ec66669f411fd8543f655db31331bbdc865cfd08f4a0cdb08b5ea797d6b3e9a20ede7b25d4d18965796d4e42d639470c68f18a6b03590e87de51d54b7fb8a7b6706b84d93db6fa79e0a4aff2df51d71d30c5e0904f95e67ec5d17272b8cb377c4c6294367599c11815ed0ed7a3f0c4d222c962abee65abffda59bdb9fba41cd53f8ec64f4864167aae95a05beb9e172d9ed0866d38ff0aef3294c7c8d48762b3b449cd9b271229524a9a8e56305b70ef56e4881386c43b1fe1c1d834c4084f711fd49079c748fc33b91024baa7a75be1134e028e6b506e2030194b80fab45d53ed37b9bb00a481ee9336d166ac85ad912cbd08f68d70997ee475ff832c40f7efc39378be9b2456f6d88e0724819e8eec86f65c4530fe4f797650f514aebdd33276f0873f5f323e305349b42671061b7209ed795111e6a24ca06f8c45777e5106b7a6f38934d036a85ebaa72d3592a160aa275a1b433fa32ee363c5b4b8cdfd9f23c9d4dea1a7dbad3db154c19fe5ecd97c5ba9113a42e7c8332edd7f0b994e4509cf37c0b0c11e9b2d8fc9be99130329f9e994c1d9ebca05d64a4c867107f289aeaa1e7858935054622365e909130fe96bd16ddfc68de2ed606efe67c81c01612ac7c4092fc3c059b516b7db8becb22ae3cbfcefc21bb8814ac45d3ed5a133b7d86d17ed5b0b4985331658111d6592b5c3a760cfded1c9cc04a30537f3206e772972697f91bca0f38d2ec6c41f982b3529b492ac5fc01a4e88543cd2487fedfde4810eb414834d6ee49a917af0c451dd7336a82c5029366833e1e3ad265b506bb968b9a6b1618b1f0a7ec393587274e800a5182f9645472c232b345a886656d34269043854dd2d42035b39ef1f0899a69060422531bf782103d3afef638a474c66a4772e20feda6dd24090579a8e87e9cf06761fa9e4af3fbb9d67e877ca6fb1237dc6ba94dca58d6ad61b3e6f0087f87e056221fff2e135b60639fbdf64073fa7776ef42bb9a3c616178a9409b26da1912197e5778abb46f4b772d7e058fd324106584c90dc3c2ed7c9ea160cd4363c42d057aabdfc52f42a2c5db83cb1ce8329f522b4f3597c329101691db6539894d1e2a7b5b515f889a710baa443ae35f35ed77903112f11f7954acffa379fe4dbc9c26e917a8caeb66e7256557bf052f096a348de79223aac030c468ae59208c27ae32571193cdd928aa8575f2ee94a9042669fb1de300a3f39ff93ac1ec66c5245ceed7cf8b25ee28f15cb78e5edda8340d9572a0ed290fe96bca127495d7f862b98d98ae1eea24b867da3487fb4558ee256b2a6d7a5b1b011ffcdd6c739e9bc6fc75a21585dae3d96841c380dbebbe159415db86ab922283926eb1e693b08190239e3dcaa0a4706509d77f40ac1ed3a393d5bc9de3adc953000dd5831bfc5e27fd589a700a3c67980cac9492691f4026a3b11e5129402d3309f0609c017c22130a07a79b1a68b3a3d743a480f7c52131823380c51e11265c1dd11be366dd048b4f4471236bc52c51cc1561afc23cf5692e66f78a7bac29bfde0a65369db151657cc731618d964f32fd092f9a905d62d684aa1193e9f80e47d4ec34e8af07c09f36300fd4df7ec042123d3eb7e6d6f5413c3a996c1e74c080fea69bafe0633a47c1139480d1882ac705cb4e9e58c4b024dd68a629fab2bc788bcbc4c7b04c13f96179f689b8f81f7dbc1c026bca1beda57aaa0badb99d1e21c85a81ee729874c7219636f076f2b2f0f8d53cea4691529196eb2e9ac9b922f1cd833d8b9efad8390eb2f0cb32ec129ebfb828a2168611d1575c1f40921ea4532b68b9020dc873c6db9f414152045d911984cbc340ebbb4380fa3e18154f7f66370f0be6edb9470ac22a80a3676b2be5740cb27f6a549125a0466f27fcf30f63615d9c50afa25c3e44f29d9c87f0d3a0c1bc4029b1fb31d1b4531a46c710397c28eaa78e68ac737ae685253b81d24d2679be189c93608535a40cb11079627543fd5d9e2f6f9da78188d5fa4b41c56f1ef6ab9185ff6b873d74773d0308b50306691250db59f016d77aacb4edbac06f246b23f3bee63d791126250dc79162913df5ccc4818ec6a3817c556357b2929341a3a497d7f6f7ec5b49c296192b6d6bd2c35848e771b678bb6275b90f8b93498a469a4bd6e95448e35104c7ed600a48702745c14465e5a2a59e1fef8a3b910d260cbce3bfef9b4338dee42522ff7e1ea1eac59c81cdb60995451cf33f5260a36b78ed3d66daa3bd081b7a5c1501b4512b97164107e9f47d091068831882746a43a6f263a4ec1f61cbed1d11b95281737654c149684202a0115a593f9fe8b1291e7044f690fa44454a24f18a65bf34ea7fbb0d26d243f8f484a91b3965e454479deb3d853e4adad767714117a5cbeb3a284fadc0a49b4414f2f65b4b2e518dab9fd4958d739fc799181fbb0dbc2a00572ed0da57107affa08458ba6b8dd2cd292f733f346c615c642f3595fe309fe50aefabba2af831fdb45053c19b84fdb381b5909ddb90256baf30b85d29c61fad0e43342be3f6afb3bc8b50a9c0c1f8886929fbb220485911c6a55def8678ad0e4cddb68e6bc9b4a2dccfb95189c8431aa4445f077ae9b71431e09595d3a15d9f53eb6cc31268194657ba1bd45517c22aa292756e055470eae61a05ebeb2a9f7b1e838174f304854727890f856b89bcfc4c95b204ca9931ba994a5944da813442a77aedac37de0c07f6e6d57ab529093999df2e0a8aa199dd1ca3f7e505e83a4e385c38e92b8d4369e0128458ed8048e222a897f024973158d6966a390fb7c7895921995730f1e79d23acf1750a164f28548db972a4cd2f9a517b9a74b6ad24ea5fb39dc4b357190f1281aaa27d89b6564dbd170b67922c700547ace46fbbb6a9abbd84d8b8818d932adc77513b9ea79d1c72514f1e1c31cd442150ad516a05b87c2af9519ecf60d571496c5790150f831ead5eb33143196aad9eb51adba27c6e5ec8706855bc3fca610ad0269e8b49a1ac9c76a75d6fbf57896f7d8e2be923c3c6f66411c798969119ddaa53d443a2c9fc4518ad171e9b054522be563616c34abaa6e8c247af3024833924be9baa2c870a5073f12d5140733d95b04f9d27db45808984c3c02b73bf40c0f731e5bc0bb4cbab8359bb889de617b5d416a39ace88473b319a9b689b7b9a312aa645ce27e23e6aa642392254ad96abf32be84daf49deed52c0b4e0fcdffdd9c45c22317701b25ab1604b7e7af56ad74428786eb78c62d1d386f367a55acd1d8e561de08282fde8595be546ee54e18eaedd79ef6ed739e193a9d37ca1fd0eb4bfa4a257db399bfe7ac3284d0bd8c36a0f7ea4e9ab6cbc0c310392c7aad3bb177a160c9e03c2067d3ba0e3212efccb7b395d2ac514c30dd519c64f826c7146ba524e28615b44b441ad1661d5330d1c385ce4809b29cde532a210a497a538f80d2713d420d5058700db9fe585160e6160e3a4e6fb2b7605b338b32440219b601273db88308cf575f8e0a111332f4644ab629f23879136e27b618247d074496700e6e241e0b866759fc85e9aff234cfff14c4901fde10d6f8ac5415f5fb1c592120fcee70d899276f2b9baf98798cc5e310f3cd6ef134b55e042c4273455b2472d4be5b4e47c5eaca87fdf35365a24e826216c06b55260cf5aba04b0da42a4a07063c369ef8289bf85bb0fa11885592897173b0574b0f09fd056607c777384c6f7584fe55d9041759a9924fcf8e9fcd670c110966e4d194c6a2e6bb2cbab158a2c0d1659446fd38ca0af1cb5b3edfc081a2dac953385369d324f199efb5328a2a7a2179745dfcc97eec2eaa891542d62773a052a40b057f6e084295f6f473a5e5d4ff8da26e517ad2b3dbef0a4d4a1ccbd2fca27712e9da4691faa7a374ccf092b25fdfead1a9949d720d8b51b0d64316a3e6da0d46530ecef19c787849d5a22ac42c1ea43a9af6bc2d73a8b974d857706c561108ea458ac806e256554d561515798c1047a759f7d8b6a92ff8859b793408df6bb1242d691c08ca605cda37fad97a296bcc5f245cbfa57a17c95fd5661fc5afc6fcb97ed28f00d5afc3cd22939fd11a1d4f2ca80711d5ed6c67938bc29c05affa521cc1209a82e599e711b182ce093a548d232eda24fb009b9a98044f5838d9c0a51f04839ed8b9d46d575b4822eaed7d5d01abe4b2f93af2cbcd2bd384c7ffe667b1e2a4af1f871ac9aaea162e6f2a9c224762b39caa6fda9ac20bf503f976934753260bb2b3f22c42c3e2d1c2b03ce96da2c6d3e818dd6874ca8a8004305f5e4a564c517d95a65a3874c462f4e0a83513b274a49e7e9f7f9ae8a94e2c5ec2876fe1c06a3a2213f578f93096568702c89bb8b84c337c7f1818e97011f4d744784d13dd087b514181b484013f4381d46c789420aac08e8696d74fb9518efbac195cee4db582ded9b40854031a839d99cc09947d5b09d087efa957213ea4162ca7fda620001d1ba96a3d10a1bcd3d79ce8ffb42726344f1a1b7c190d8fa245810c188e21d4c1389003128959d01c2c31427adb428757b149e549b938bfa952eb82bb1c69c2f15f0533ae8a6cc71d9af149e6c48799903bc7274db4fd56c8f0270c601dff1945ffd5341175e51b43d7b6f91ffc7d7927a2b6bcf83484077499a141d3f63c35f895de201bea34fc0d22d16eafca84697591a95645a78b30f5261b8644879e87acb6cb806c4e2c72bce12f80f87af8e4870bd577ce980cb05089662271397be05f8a263d74ec94aa61255a1ec7363f3fd0091d35b400be2194aa32556b09d21a531cc01ba78cb12d4265f1e3278e0d2055b48d7c2362a943a8eee2f9a03e57d3fb021162ed4f77dcb68e5533dd58b5171b6aa45481b4d128cbe5dcbe9246c7a129a9e5bca6e5e047cf06afcf266357b0012b33151673f2c7480656ba9de10b9eb5b7137d99bcfdcae0513d7ca6c2d8e0cd8785ea7c248e9bf956707e1013a54b7f1421f6425187cf7da7e48dab1924866f4372c873fdf5084becdc9702801acc6a2ea9003f40d87cd8d4ab919f740d463a110a1b2eb6ec9f714ee1d65124f2eb39c582d4ed06b06ccede6395d65be005f05ff293b20e690277301205528e8f18b39b7cb3c7f0cac0c13620ef8a0ffc3b1206d21f558c9a4947be641353ebe93f252b3544b34a24324fcfe05a1cb18599960383a1192b641b863236e1184ddc408226ece108243b19c89cae2ec17d90fd9ab0027c3f7b19f4276693e2cff0df8a741c8526d312e912a77057b27df9255db1e5a3783b852f9d2160a8f692d7a5bb94b30b1b18b044f6b7a23955070f8e565db13e1f477e627fb8d7c192d9dcfcb0cfb22a0c5c472fbfd6798e5575271a9a30a67707b6babca00a2e6ce5ea17a390f6900ee71a3f5c4b6fbe06060fcd689cb23065a19ffa30c915d9727c2d29ca962adcac77e7b69ea0e0acb19cd8e5c0836cc30cedd90480b8d9f1857c231b85f6bb66a43adcac4a8b6642aa45cfcc5a5458567049638b2597531e7da168a2144492c6a75ee322bf40649103e54cf1130ee0237a984eed109b09acaee57bf49f9eff8992c8ad3144514af96b60a184d24b3d99c1d3eb90cea96833dfea2a18ae86e6898d7ff1530be376ef6959d8e1c1d7a3ab942e4caef9c5c274820d493ea01c6a3563ebef6f2767ad52d52504c18cbb4f9a7cdb1509cd3002ffdd185acbe329ca82d0ecf5cd9bfaca2b6a1d114fb1abf4cf77d11aad1ebc516b61eb5a961b1fd7020254212f775c337618aced3fef0852c97127227950ab2d07e878cc73bf0cb6d6e6fade9382af126f733dcf49fc360e15023715406a17946d4b5083ba6ad8a9c8dc3de49c8e1bf0dbbfc05203c99b90b76d6069aa2d4396d516a78fccd92d32929a8d8fdae2ceac3270de865c1921da4a76ce6b33bc6f2dd3a75c2afdaebab222eb78aedc23a709a64f9266eee3edc42f417fb07d9d8072e9bd25eec24444e395d32f200801d51445dde08024cc60862226ec61c73fccde3643e7892310a6fb90f40f37f102fc016eae847d1389f7064b6e62544d912f1639581aa6a265ea33f6f58ccee1f57662f957cfca4f7941d7e7a0f14612b279c5ff5cfb40f8da3eca12dfdf72e713b6cc811e86d46d7175adb96c27ddcb6e6ff27610a1443771c214fe61d16e573c27d77e4a6d43dcb5b6b94a325d562604d5f8b428b784ead0ab2abb98171c979cc59819771a0a6618eb43818d5b78205c9c49457026890bdbf39fe76162371fac2f30754d1ebcc4f75cfd4a59c1b8cd8fec70fd2a9797eba3586638a8ab5b51ac2d86bc6363264487e590744e82fade3714dd9f0e06aad94160f32012e7ab88723ad26d0e413dbaf1ee16c8823428844d314da8b5b00f6657b0e7f304f2bc628b2e6bcfd645cb60e96fa4f7c80ea7b5bb8b43bf304ffdfcdeeb3121d5481acb55e8a6227e34bd00236c4b22c5c26332a05663983dba5450495dafc30cab5c3293f51b3d0b087c81cb25033da72df0eca92bc6d4fde0e6b76b1add914232d49812bd44ef55179fb4c63b74ed8a7335fa75ffddec822a66055e2ff36fc4e70904aff7aa400d2240af63534749433ebc19f9f28f1a89a0182b01c232120f5e46831879df137b42106e8199d0eb0bc93dbafa9a297aecbe29adf1ede2587861241a16dfdc3dda8f438120fb8775d673d8f569cd10cc5dcec9152a7c6463b2792fab15542759c97b28f686f1f0483504c7e29aabee507ab3ae142c86cd45ff11469f9281ae1e86d920eafc425801ecdf4763c00743f7603f4a9e5309d148f110008d9638a4cde34d0aeb1e41680891845acea539fa745e0da12dce2aea20b13f0cfdb2d44468b456a51b6aa51fedbb4829bdd407128945405bd90ac7d7b03ab9d2627a44cd86b32088dbcd6bb450aa557b70c4adeab1d15bf345a317ad74099d0dda643d060022433c566eeb5bc79ef05a574bdb7aa6fb0ecd0c2e4b595bd6a3a2f61b5d076eae01d5e567000719c1c0f9f57dceb58cf3626ff9b5079c9c6a6d4de8c7260a089ca585867a8e529db8d29f9e3d30601954c3c5424dd042977fdb4ef32dfb82944e2fd0fb289e55b228e5dee22aea903d1a3d1ef0af73045491470cb7264e6543f43d7116cd0a33dd66b47503d8baa165467c3e45299109eb05617c4264f07de7e42bd8e3cb907c7f58e39169704843ec5dd36f4c43d73688dc3dcd70fcdff5ccbb5510f3b803137a516cf05ccb2cb94f5fbd0c7df3bd04fd42a8ceba1f363d2ed5fe134606ac8763c74945796d6751525d172cdb21b58b59b950745a2ff0f072fc72c9fe233ad38506fa311bc091e70ed4800b76caba36f08f17d107ba214453e71f4e17ad386a78ca6432dfa3f8fe1e24538ad2b806f8c8b987b5fd2e14cd1d3f59e854c23e175c9f3eecb79778fffe3bd2b9915a7529d3b35572247ed353e5c0b7cf6cc1abb4104202aec1d2a381cfb73c2d58ea9a8d76e75966fbee0cf15d122c56bd663661b192eb9d96112a5ccc3f16665d9aef2b85a9796f7a4855faadb29e16885e45359077f398dc44ba553714bece74465dc7e536f396e285377f8e58e98f39dfc87508f97dc009ca15de8ce72db2eb496f08db40911f3a476ca3cabfcd3f6013121127838f6768fa24e81d3c231ba0b9c98119b4d26243e87dc4df7da7b108726edd458367e35c5b0085aa1fe5ccda0c0144bb1de0e080bf985cecf0c3e4250d619ef9af1605a6ca83b5b2cea8f5a65c7d3759035b1fa74f3a16b0ec7269b53f2b03325f99e6af0212ff20f6d8495af71bfc7c2ef51ddd40fec1958d15395bfc3afa63c4fbc86ed1abcabcc66758d973ff6f09d4abbfd8243d5ed8925a678a8d52d536e2096d7890a8062715346a19c485836d55bd3d18b5b1662b516142315868e171a66d9f7d303a1cea4837f4bafa97855359d12d25456304c99a6843867b493638a35d66b9441a762f717d75b61379e8f249d1febf0059857f5d471caad4cd106c8ef1d33c688143d3c630fd264502dba9f7284f86d14db9265c8a3f9e50fcd722179dce158ca95814a57760e4bfdf5cbaa9c06b2244eca48ac9ba234d72f2fbd63ac07d14f3a8e4ffeb4f61afb6a8b0f7816f5062b8e818df25d8ce8296ebc03f3e847d37bca677e694f205fb10a7b2a84404461685bafc5cf6cda7cfec5dec6f87eeb401a6cec346004411b75662e568a76268d6faf7e039ae88268f9e48dd7cafec08229b2d9081b205f68fa101d253c05dc8ef4b00b390624cb8fc303c0e7e9edbe6eeff352f738d4543bee05c1b462717e17e28eacc47be0a15dba55de7cba35961f665c77042b7d4abc2c61778abc57c23e1f638991f265dc23619d7de549bd06933f52a224d1c66a093e520b4947aeff1f29d6dc2beccbc4d90c8efd8a307ad7417640e2957148670cfa73ea34d4219a7ae97b0dc63cddb2cefadb8d62b9eb5a84d334085c94668a5075c1943ee86e3ac08868721fc399b37097285b2e591887f907c1424cd2be3ba04965e90b7ee49407f4401c5e9f36df00c46ea54794d49aecf22c7a5d24ffebe3e25036e79a861f85d68eae24741a08d78e2a82393cdb042a556bb7d94c45426b310c41d5d7ebc4da4b854b2dfdc0edb3fc2b249e175457f0f7b2f2b25cc564e939b0307f1f8fbfaf128e486fc20946915cf21d81e4da7323f9cb29fbeb51fa5077c0316b525f93753a2411c52de3e30baee7669c9322e6708735c600ee441ea5f9e43dd60285897058a8b980a57c1677e0b314dc45c542b1bef27bd111ae2e940cc459da6f831c121cf7df90d418eb8e1c2623ce8a43942792c47ec87d98123842acc18de5bdfd717317bb4488ff695ce5af5a292291cb06fb53d39883d8525e06534b5bc72e65d5904521dfe6eb5a07f24ebb5ad2171e578875f7ddec32353a376bfc30e4f5d7f0bbb9ae5c6b852caa9279ed4e1bfb81be373a679b88fef835b60a1b7d267223c90f4af7883a0a718b57819d13f2a5a47b73d4773cad4d1f4a88170b9082b7091a441f874cf63efa02505d65567513ea690dd9b16563e4f754c044dd4217a5c70db19c7aad28eeffc33297a3699db86b2497df5cbfb5892c9f434ca4b353d8980863d7633f45a9483451cfcd4bc4e4ecce212f09d9e67c62caa335d46c45b8ebda30901f6672f29bb94884e0adba8a3a6779b87dcb83ae8c156dfe96d4ca25800a5e2dd396cfa419160121621d793fd6e115d3329e367e6f98331cf936d2d0a1549538220eabe92d9fcac8a8be2e3485f261b6bfd609ff1b19d8cab57c5df231df422a3932f0bb27a4e08da4e338fbe14ce48dc8cd1e2c5a673dbd0eb3bca7d00f38b695b1a3725ac6a3bc616fb132b4607a099dafdf45ffa9410844eab8992657301848ea6b827c21d10714fb2757f7d533fbb9faa23bdcafb7ed529e0b4bc1f6426b756a92c824a0ba52471636e030ae35c6b2919076ac3facac9e6b4b83d2c13f9f1f77a69a1c9354bdfa0d7b2a0016ecf11e0aacd26a785e9a1fbc3a1b7f9b56ffffddb70e4bf4425c1a9b80fbe85bdc0ef31da0885c8e8f0b954a404505594d12785470f5fe93512156c2ca70d73166210ffa4bf446d88671555ac5416ea5af1dc368407bfa2f9a36e7f7974fca229740d2b48793328b8b1abba0570028db51bcee091ca176ea2dcd4841c017bfb43682d5e6a06fc577786dd6ef6f05030ba9ffca78a2d36c5cb089b5f951278a47cb46ba029773f50055b1ca072905200366a3d841be8d2d5860699b9affaf098cb8ccf2a6fe7f7bbcb4d071326748227b3b83521bcaae75ecd9673d45270373ff23b4c81148629935fb3b2f5deded792500c5826c20171b358a99ac79370cd6be20a21df4eb699300b8e764b1556b73fe92c1c1de79e444871c9976722354d2062f056a8489a184412e97cdfe21eda6740cccfea97fc4e7be5efdd0e5e64501f36ff363505a8bed3d94b001c228e8e9354687b5255331787206810b8c50cac8479eb4f75de61ba75d5f8cbca95ae8c136d3ae570a745baa1579afb75a3f51d927c01ec0d2292ea064c15809636ceb4a09da7602bc34e2286fb0cca6313782c9843990927c1d034d1be0442f57fe2fbf025e8f79866034137dfad223448c8775f5fe90b844564079606b06acb8251fa84c6af3ee24c5ca677a06ae570b11a69280d5a8c841481c730427933182497e39cfcb41940ce61564609f481901b208a9a70e8ef9a724bdcb4fec356ab7d0f9bcca7abe114ecac784867ea19618c836bb4bd62f720b6e3ee734df3384f3cc1bea73b10c35f58e349210950ce7864aadc2eff631b1a5479b495c23dc365c68a802ac286eac2d9379742631be0d245b0bedf354d8ebaa0a76f6a1801a097dd8ab6e879f9962759c3fbcb0b0a5e701cadd7bc2dbd2ee7a2ccf7626c0c01178319e0a782617230651c4744d810906bb9f5285040fe9b22a43927810d3efc400b672a8954632949045dba1d542dbcf390314deca4d11ff2b80071481b3ebf0b9eed32f7da4e07bd044c806ccc857ba5339a2ec0dd25b8070b72bdb0227a339ae45ef5e1dbb3118da0402b2049099564ed7071b9067b1be6a0b94e8cadd8ed11593496386ab5e71d6f71a369e572dc11a07b59dbcd0bc754fac90506aff9f802b0ee59e29306314d42d44f55d061bb16e9c515af0023875f4d1b5dd82057032cd438814eb490854671c9d4518efd9df59be83dfb16a5acecc1e2d499584086d73bb66ec362dffb6501955211b79e6e4083bc9cf4d1594fe3492329009f162d49392857f52923fdc2e5e457d21d5182baf8cab8e4569376086c0c191cd5f7dffd2ccbc303d6405611bb3bf4524552ad13e9f46e2d5bb430ef41b07819259aa21fc02de8027b1e7c72218c6773dc7ab790912908d5604cec4377b8a9323e4b1e7af2fda63d66492017fc7f4af17011c29cff71e24f35087125607a55016150fa660b0a8c6911f896cfe039e86350a693400ba9bb1c493f3896943d87b18869ac6a151b820474c38d2a906cfb69e111ce29e558c843e73746f4901741e235145e6e955ad2790b5df835ef30c8ad8bfe8e8f709cad44cd4d47dc452aee892f22e51fb50b61b11cf24de0ff2b302566f4a28ad9219dfd5dd4bb6ed04d40a7fabd7bee7d710d491564f511599deb0e08400345048a6250d223990993a78fac0bc06a4ca40d602ccc56f1cd64977ee6af52242335756e2cce46976ce4bf1fa3ad896cadcbd8d7a20642736b7dcc8684c3fbcbd97933aaadddbbe8a99ef70eaae2922998b0965e69555ba0e3f90b3e019c26b6ab991e3b84fbe1fdf2272b774b7ab026527d040c1e398cf9ac81d74e0b353554b0361588d378d146bfc97bbc049a2fdf16492a73549a73af9c36b336d6c1a610ed232cdbf9b8157183b61f59261bf9257f93c1731cb2c18751684a599e69da56c1b602ad3931d9c0616aea39b192b18f9598265a71174ffeb369b3901afe11d1085fea37a000a9ed816269ce95f80cbf044591c432915aa89767682e98b9612204426433b727181103c7188736df0f841f2383dfe575d23e748d004e55da2bbe5bd435d2001a5416f7fcb7f530ea051580799a9532d54237553a082f3ba2a8c1a49c5e875f28eaa39201095d8d123d7f7b4cfc0b355414ac8902fd032dd2eab1e7aaade3c7a6db0ba8aa2395b9474a3fdd0ea24035fe48af8364436c814d89a36f53de73337949813681311fec3299703a386d992098c21e9f2d9e01355886573bbe74b6bd7ead87134db59b221fb55ca4337e53f656fd165f1e39e4a0aff694d45a94e3ba14572c93c730507be5f524b5476b7e74a9e844968e4709644a9044a6bb1fcfe1474e01d216e4c48b7fc4f7c685a50af1b70aed8dbcc6868eb33fec2c81168f0355a58e10894e2f09c677e7aa423fc7b464f713e8f5caeadf130704b3b54418545e8bf17f02b8917dc1e32bdcabdaf6bc278756e6160d8e3555846d891cb8715b0644ba57878c49a1d9b4011d981ca090709c6af0dd5d847aad7250c697f99c73e0c0066c60b8f255ba123eaa032835b41303eefbec17800faee972a514f47b4960fc7ae28d799b1ce704173059032a67fa9fedb54955df008c1cbbe031dbd055aebaee9fd20212f2c4fcaa97b2ae05b6791d187ef000b231b4edb28e6ddc75e9c3f37e0c8e037a9341ef0fa9327bdcab6b79abdbe0a901b5cddd6cc2b7cb650aa243da82e41ae35022c47d7ef395ba56d53cbf6243a43034705245d974c0d661cd182b18af0de55a0ff1b35c607cac2b4ebf07888dea9df1cd2db5aa76a73c86e4e0d1ce0e58fc92a463ca15d585e5de7a1ca70895f8e74c57c74bc0272ddc70f5dbab86b45f9d6802fe7e14085d08a667d1c9661d85b81127b697376fab248dcece99463b1f7b09407536865f1e041b591ffda82aaa0ae633e499f5c76072ed040f5f9d78a7c4d91c79351bfb911f19a7195c27aac93b948bf4ed888176a072eafb202a939bfe9485664e4b0b3cdd9ff036ed02da59fdebddf28db807833b7b5948f97a50f90a66029b0c9dbbd3cb36baf3936744e52793dc47509b6091993c22014c9662aef789d774b0ca3ac776daf8b563c48dc19b346839b30bb3fb7f6f560f8bcfc0943571be709de5e04e56afafcfb7f66240d97bef844eb0b6f8c78cbcc970f86ced48341699a2afeccf67a31222db899d2ab637b61902fd33c82c2e4174dae2bf67c64031e8e4c53ba9301cb77129c9d90b54fcd9b2c2e50fbeb2f01e8818a11b7eada6c2118896e9fc29f060f918272d7d6159c9f8d17cac8dac6ab8d7ccaf247575b9dc58e24904f8fa31152a5afc4331b430a39d4274d03a83223c13dbea6aeb9a70666b2a3eac8236f2f41914c638b40066fb54c5d9cf17fa86f4f320eae59d516eff1ef58b4f7f6c2059b3c9fef6d427f749c76a7e0af68ce6a69c9bde6dc89028f1f32ded9af382adf3a60212fa7c2c185e325f34fd401e7a4648c053f85ed7f622bb81a30a5322bd5ea625226e4ce2fffe199d61a059a5904e3a0d0a1a0b833202ab31bc9f177dbce4755abf34c754fce54638575e8cb0921bd0e8265ee9c6174102cebcb94cca92c0fe5cfb50e0b8f03dfcfd608273ca9da6914d28d43df3bfe8555e91382a3a4991d127434cd6881f675de0c07f30cc0c2ef96c2c18863d90ef74ad506ea1272da35da1edd7c23c08e095657b141b35d6d53386202cebdb97f4b150603790370f1dba467e3c633ed617836eecfde2e43fb076e389d2437e3d769a964483fc6e8b1b3ff60569ab49690b3d34a2103f3f892eca648bce98f90366a1e371d5d047eefa1fb6fb792b6e2cb849cd36dad72a3cabac8da4329e9e84a587eb5acc2f9b4b44cd9f0732ded45791df2a28eaec397803dab3d3beeca936b2728500027934e25196e6fcb0d5f21f859b32e562d6c36b6a7d37afc3648a2a4bd30476d78b85f6e5a7a7bed703c32381c078940095b7f996afa54de060e3ee478a79fa2b836c2a46defbf8f5a93688e6f52f1abb22a8c010e026a55bb6c010a6547ce4d48eb6035b4a7c6ac5c4e4a2666a43db1871464d6584bdc84c7c7fd122e861aa9f368eea6271018d82df166ef922b243629bb3c4bfa41cb01f710430f8f2f5a5e1b2a8b78f4d778c3075b139f9398be76653cc6acbeb20b328b2f42e03ffb2cd7b20d9dc66426defff85e7ce1d17b55ccc678a5641b5243d34cd19f243256370b2633eb9dc5052f5ca3d533ad41cd2fabbea1d61101b21d948c73774ac5eaf18f9dc5e06949396301b61900fc1f60f625d7722a6ae0c1d27bc17582537e5aaed2faf49de3714db9e0a3b250db6810cd309f22a7724a5df51da1bc4126e653d90d4d01b1ee597f8dfcc2decda78b9e748697a2f93d27b303cdbd63db8d0dbda370b1a510b82ba0c1d836e7d61a66fa292b1f750c31aaf574aa22d412c3eb9eb4bf8745ca1a399eca7811fe093ba19393120b2f782d6f2876e41e6f5405b6500edc14286f2e47b9d0799cb99faab12d19d2e7f95fa00b77c77c254b0362cada7c5fec9e0654756c73ee3c5d06dfb87eec648d129683c23d06705153a34b746adb0368f118104fec7e95b3289e5044fb719b580b9238f1eb5f4c40ec0ab79a46a9d4f518b421c7b02628c6c084498a9fd04ef0beeb4f0b9a15efe1342e1b1d8c06d31d243e14ef14a726ae2a8189efaa8dbe837c6ce730104eaa8430d59ad54d92048f675a4944ecd929d69940d9cad74b55d57da4a3aaebd6a39621d6f9b203d5b4c84d5e351008faf61a6fbecbb3d193a02086fa3ff24c2fe0ffcbd948f25580e32d9c4a77b646c55f97917608d715c6705c2d05fd93b1fb27aa7f255306fe81d399089f1359001d9c0bc663e0c4cf9a52a33445dde3d4bee4cb2f6269a0194f71a72f53ee4de4b0b94a8bca769a01a2f31b9bcf55494f30ae8acbc7c1186f79b1d03aec94347e9673e03add7cb5e1013cdec84b12d27a6cba5979ee0a65816d4e690242c21d32ea5a396d56c22543eba3030da146ef93fe4183d8de442f166557c196ed5c82d9fd2aae056ebba668391fb838697b084ec31ed39c71c7a2ae63520761764d347a4bdb425cd9cd2d6bfd461a37c3a08d6952b99836045894653985d131e98c7828cdff9c80f7e8d3e5dde7bed5e8d1e861569f260857b646c47e7607b110486d91b36e8367ef463d11241f19470bf80a4a96450126a755e54657a0437e0c6aa82370b4c81a5cdc7bf3ed09a5a7a61af6b41aad0f9f0ceb411884aa268656532b7dcb03e2e49e5348badd83a1ee55475a542d60e1015f71d80b04bce1d6c3b138ed365889c6f787e794202d9e0d468f7e8f2e9f141ab85edf36811d53690173351561e9ce6898d7372eaf3b369a132e3b914f3701cfdffaca59c762fee3ffa0273478c9508fcf0120970a6767efbfbfc95ffa8a9f84b11247a4c35d2ff62fbc377e07815c3375807469277f6beec02aaeedaa98f0c8e957108c76d2d496f19257f9fe9f9fc8bbe6818f727fd7a77d63dd4c23bd1c35535a7ee1979577c5fff2699578afc46055d133a347088da4538daeeaf387e893ff4579edcb1e552538335a6679e1a1b8c94e8b09dbab7148df21081b360b147646f35a9b9237c6a46eb0b934355f687303aacf6bc434c003eca1bf2d5c6aeed8281fb676a8d8dc59153233dad8356a412a17575f0bc157bca371d530309ec9ce896f522f8c195daca0f277c6f79e26d980955be18ef36589339460b31e4a156bca51f5ae28392bb65503909b25d83c7fdbfa0d947835108ff5a353ff1f34de213d351ed54e172dfa2df594922e7b19f4328753487799e6deaf42846671ae712f5784eddda61b10dd113dac7190167a4ba73550ada3e65e72d64e314bd2ef7f41b5ff3eee321a91adee76db9043ae310ded6b6b43bbd65fb05e998ee47ab792be89140be4e128fffc63cea5ea0ca1bd15da404a2c6604f11055da1bed8f7edf4d3c0887c94624eae68f35b832fa3704c9bc55bfdb6f5f0f84afc1a465b2fe02d66f452896c32986e77f9eb2efcf836cab595bd0c9ee8229902c78d4efa172c73e8c6585d720457a15b64bbcc66102d5939fdb224e65132a6c8e443c3aeb8edf0e6732816791b1ac2ce22f04dfd6eb4267b9a6db13774505782912fa7160f8bb446d603e9211dae43b93999926f69d0e10b0d8d2d36dc3a147f1d1005f502864841856c73ff94377efda13cab83a51d55318f38b8d9200d6c49e122517cfac896039fd9c5cbeea31b0111164289a2fd8123f1be356c673bbd79c0cbae090042997bb0e0f4357e64e6e2460b41045ccd746adccf2252d2d88ab89dfe9cd5051658aa2f6933de512459a9a18ac48cf941882a9e481984b6b3f3351e9e5f164780207c1dc961d600486e7c720f24486e1862dd07c28bf2891a166d8f90980597a4078a83326d198f3bc7c2c006dc70542bacb2d0021a24c6f2793a2f5490373ce74cee5bffd6cef4fe01430617cf124d9f3815445c5e1bf914382c5d397de78c12b90d4f0ce6bf2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 网络管理 </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2023/04/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/04/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dynamic programming，简称DP。通过把原问题分解为相对简单得子问题得方式求解复杂问题的方法。动态规划常常适用于有重叠子问题喝最优子结构性质的问题。一般这些子问题很相似，可以通过函数关系递推出来，然后动态规划致力于解决每一个子问题一次。减少重复计算，如斐波那契数列可以看做入门级的经典动态规划。主要大的基本思想就是一个记住过去，来就现在求值。</p><h2 id="动态规划的青蛙跳阶问题。"><a href="#动态规划的青蛙跳阶问题。" class="headerlink" title="动态规划的青蛙跳阶问题。"></a>动态规划的青蛙跳阶问题。</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。</p><p>具体思路就是，在跳上n格的时候，你必须柯一是跳上n-1格子的次数，然后再跳上n格。<br>所以说需要的是记住之前的所有值来计算最新的值。从而达到在计算第n个格时候，能够以较快的速度知道。跳到n个的次数。</p><p>那么就有了斐波那契数列的应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(10) = f(9) + f(8)</span><br><span class="line">f(9) = f(8) + f(7)</span><br><span class="line">f(8) = f(7) + f(6)</span><br><span class="line">f(7) = f(6) + f(5)</span><br><span class="line">f(6) = f(5) + f(4)</span><br><span class="line">···</span><br><span class="line">f(3) = f(2) + f(1)</span><br><span class="line"></span><br><span class="line">通用的公式为f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><p>然后就可以用递归来解决这个问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Solution&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numWays(n-<span class="number">1</span>) + numWays(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是用递归的方法，耗时就很大，但计算f(10)的时候，就需要先计算出子问题f(9)和f(8)然后计算f(9),又要先算出子问题f(8) 和 f(7),以此类推。一直到f(2)和f(1),递归树才结束。所以就有有了：</p><ul><li>递归复杂度 = 解决一个子问题时间* 子问题个数</li><li>一个人子问题时间 = f（n-1）+f（n-2），所以复杂度是O（1）；</li><li>问题个数 = 递归树节点的总数，递归树的总节点 = 2^n-1，所以复杂度是O（2 ^ n）</li></ul><p>因此青蛙跳阶的递归解法的时间复杂度 = O(1)*O(2 ^ n) = O(2 ^ n) ,然后你会发现回过头来，有大量的重复计算，比如f(8) 被计算了两次，f（7）被重复计算了3次…..所以这个递归算法低效就是这样的原因。</p><h3 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h3><p>既然发现了存在大量的重复计算，那么就有了一个思想，我们能把重复计算的值给记录下来，当到了可以使用的时候就可以把它重新取出来使用，这样就不用有重复的计算了。所以这里又引出了一个新的问题，用什么的数据类型或者数据结构去记录这个重复的值。</p><ul><li>一般都会想到使用一个数组或者一个哈希Map充当这个备忘录。</li></ul><p>子问题个数 = 树节点数=n，解决一个子问题还是O（1）,所以带备忘录的递归算法的时间复杂度是O（n）。接下来呢，就用备忘录的递归算法去些代码。来解决青蛙的超时问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="comment">//使用哈希map，充当备忘录的作用</span></span><br><span class="line">Map&lt;Integer,Integer&gt; tempMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numways</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">// n = 0 也算一种</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先判断有没有计算过，即看看备忘录有没有</span></span><br><span class="line"><span class="keyword">if</span>(tempMap.containsKey(n))&#123;</span><br><span class="line"><span class="comment">//备忘录有，计算过，直接返回</span></span><br><span class="line"><span class="keyword">return</span> tempMap.get(n);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//备忘录没有，即没有计算过，执行递归计算，并且把结果保存到备忘录map中，对100000007取余</span></span><br><span class="line">tempMap.put(n,(numWays(n-<span class="number">1</span>)+numWays(n-<span class="number">2</span>)) % <span class="number">1000000007</span>);</span><br><span class="line"><span class="keyword">return</span> tempMap.get(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>思路上基本和带着备忘录的递归解法是一致的，都是减少重复计算，时间复杂度也都是差不多，但是：</p><ul><li>备忘录的递归，是从f(10)往f(1)方向延伸求解的，所以称为<strong>自顶向下</strong>的解法。</li><li>动态规划从较小问题的解，有交叠性质，逐步决策出较大问题的解，它是从f(1)往f(10)方向往上推求解，所以称为<strong>自底向上</strong>的解法。</li><li>动态规划有几个典型得特征，最优子结构，状态转移方程，边界，重叠子问题。</li></ul><p>例如：</p><ul><li>f(n-1)和f(n-2) 称为 f(n) 的最优子结构</li><li>f(n)= f（n-1）+f（n-2）就称为状态转移方程</li><li>f(1) = 1, f(2) = 2 就是边界啦</li><li>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            temp = (a + b)% <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h2><ol><li><p>在问题中，可以把所有可能穷举出来，发现有重叠子问题得存在，就可以考虑动态规划。</p></li><li><p>一些求最值得场景，比如最长递增子序列，最小编辑距离，背包问题，凑零钱问题等，都是经典得动态规划的经典应用场景</p></li><li><p>核心就是拆分子问题，记住过往，减少重量计算，总结思路就是：</p><ul><li>穷举分析</li><li>确认边界</li><li>找出规律，确定最优子结构</li><li>写出状态转移方程</li></ul><ol><li><p>穷举分析</p></li><li><p>确定边界<br>通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n&gt;=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。</p></li><li><p>确定最优子结构<br>n&gt;=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：一道动态规划问题，其实就是递推问题。假设当前决策结果是f(n),则最优子结构就是要让f(n-k)最优，最优子结构性质就是能让转移到n的状态最优的，并且与后面的决策没有关系，即让后面的决策安心的使用前面的局部最优解的一种性质.</p></li><li><p>写出状态转移方程<br>通过前面3步，穷举分析，确定边界，最优子结构，得出状态转移方程：</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = 边界值</span><br><span class="line"><span class="keyword">for</span>(状态<span class="number">1</span> ：所有状态<span class="number">1</span>的值)&#123;</span><br><span class="line"> <span class="keyword">for</span>(状态<span class="number">2</span> ：所有状态<span class="number">2</span>的值)&#123;</span><br><span class="line">     <span class="keyword">for</span>(...)&#123;</span><br><span class="line">       <span class="comment">//状态转移方程</span></span><br><span class="line">       dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>给你一个整数数组nums，找到其中最长严格递增子序列的长度。<br>输入：nums=[10,9,2,5,3,7,101,18];<br>输出：4<br>解释：最长递增子序列是[2,3,7,101],因此长度为</p><h3 id="穷举分析"><a href="#穷举分析" class="headerlink" title="穷举分析"></a>穷举分析</h3><p>这里观察规律，显然是有关系的，我们还是遵循动态规划自底向上的原则，基于示例1的数据，从数组只有一个元素开始分析。</p><ul><li>当nums只有一个元素10时，最长递增子序列是[10],长度是1.</li><li>当nums需要加入一个元素9时，最长递增子序列是[10]或者[9],长度是1。</li><li>当nums再加入一个元素2时，最长递增子序列是[10]或者[9]或者[2],长度是1。</li><li>当nums再加入一个元素5时，最长递增子序列是[2,5],长度是2。</li><li>当nums再加入一个元素3时，最长递增子序列是[2,5]或者[2,3],长度是2。</li><li>当nums再加入一个元素7时，,最长递增子序列是[2,5,7]或者[2,3,7],长度是3。</li><li>当nums再加入一个元素101时，最长递增子序列是[2,5,7,101]或者[2,3,7,101],长度是4。</li><li>当nums再加入一个元素18时，最长递增子序列是[2,5,7,101]或者[2,3,7,101]或者[2,5,7,18]或者[2,3,7,18],长度是4。</li><li>当nums再加入一个元素7时,最长递增子序列是[2,5,7,101]或者[2,3,7,101]或者[2,5,7,18]或者[2,3,7,18],长度是4.</li></ul><h3 id="分析找规律，拆分子问题。"><a href="#分析找规律，拆分子问题。" class="headerlink" title="分析找规律，拆分子问题。"></a>分析找规律，拆分子问题。</h3><p>如果新加入一个元素nums[i], 最长递增子序列要么是以nums[i]结尾的递增子序列，要么就是nums[i-1]的最长递增子序列。nums[i]的最长递增子序列，不就是从以数组num[i]每个元素结尾的最长子序列集合，取元素最多（也就是长度最长）。可以用dp[i]表示以num[i]这个数结尾的最长递增子序列的长度</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230422155700534.png" alt="image-20230422155700534"></p><p>nums[i]结尾的自增子序列，只要找到比nums[i]小的子序列，加上nums[i] </p><h3 id="最简单边界情况"><a href="#最简单边界情况" class="headerlink" title="最简单边界情况"></a>最简单边界情况</h3><p>当nums数组只有一个元素时候，最长递增子序列的长度dp(1) = 1,当nums数组有两个元素时，dp(2) =2或者1， 因此边界就是dp(1)=1。</p><h3 id="确定最优子结构"><a href="#确定最优子结构" class="headerlink" title="确定最优子结构"></a>确定最优子结构</h3><p>max(dp(j)) 就是最优子结构。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp(i) =max(dp(j))+<span class="number">1</span>，存在j属于区间[<span class="number">0</span>，i-<span class="number">1</span>],并且num[i]&gt;num[j]。</span><br></pre></td></tr></table></figure><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>通过前面分析，我们就可以得出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">最长递增子序列 =max(dp[i])</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//初始化就是边界情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//自底向上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//从下标0到i遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">//找到前面比nums[i]小的数nums[j],即有dp[i]= dp[j]+1</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="comment">//因为会有多个小于nums[i]的数，也就是会存在多种组合了嘛，我们就取最大放到dp[i]</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求出dp[i]后，dp最大那个就是nums的最长递增子序列啦</span></span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Study Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创新型模式</title>
      <link href="/2023/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-创新型模式"><a href="#设计模式-创新型模式" class="headerlink" title="设计模式-创新型模式"></a>设计模式-创新型模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>设计模式是软件开发中的一种通用解决方案，它们是经过实践证明的、被广泛接受的最佳实践。设计模式提供了一种可重用的设计思想，可以帮助开发人员解决常见的设计问题，提高代码质量和可维护性。</p><p>设计模式通常包含以下元素：</p><ol><li><p>模式名称：用于描述模式的名称。</p></li><li><p>问题描述：描述模式所解决的问题，包括场景和限制条件。</p></li><li><p>解决方案：描述模式的解决方案，包括结构、参与者、协作方式和责任。</p></li><li><p>优点和缺点：描述模式的优点和缺点，包括可维护性、可扩展性、可重用性等方面。</p></li><li><p>适用性：描述模式适用的场景和限制条件。</p></li><li><p>实现方式：描述模式的实现方式，包括代码示例和实现细节。</p></li></ol><h2 id="创新型模式"><a href="#创新型模式" class="headerlink" title="创新型模式"></a>创新型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）<br>现实生活中，工厂是负责生产产品的；</li><li>同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</li></ul><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。即使用者可直接消费产品而不需要知道其生产的细节。</li><li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li><li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</li></ul><h4 id="模式原理"><a href="#模式原理" class="headerlink" title="模式原理"></a>模式原理</h4><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>工厂</td><td>被外界调用</td><td>根据传入不同参数从而创建不同具体产品类的实例</td></tr></tbody></table><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261441166.png" alt="img"></p><h4 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductA</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductB</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductC</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">Manufacture</span><span class="params">(String ProductName)</span>&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。</span></span><br><span class="line">        <span class="keyword">switch</span> (ProductName)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductC</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">mFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例</span></span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;A&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;B&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品C</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;C&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品D</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;D&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产出了产品A</span><br><span class="line">生产出了产品C</span><br><span class="line">生产出了产品C</span><br><span class="line">没有这一类产品</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li><li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li><li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul><li>工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</li><li>将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。</li></ul><h4 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点</li><li>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li><li>符合单一职责原则,每个具体工厂类只负责创建对应的产品</li><li>不使用静态工厂方法，可以形成基于继承的等级结构。简单工厂模式的工厂类使用静态工厂方法</li></ul><h4 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h4><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述具体产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>抽象工厂</td><td>具体工厂的父类</td><td>描述具体工厂的公共接口</td></tr><tr><td>具体工厂</td><td>抽象工厂的子类；被外界调用</td><td>描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td></tr></tbody></table><h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261447429.png" alt="image-20230326144728389"></p><h4 id="实例举例"><a href="#实例举例" class="headerlink" title="实例举例"></a>实例举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">Manufacture</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体产品A类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductA</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品B类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductB</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂A类 - 生产A类产品</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">Manufacture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂B类 - 生产B类产品</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">Manufacture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">mFactoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        mFactoryA.Manufacture().Show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">mFactoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        mFactoryB.Manufacture().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产出了产品A</span><br><span class="line">生产出了产品C</span><br></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度</li><li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>当一个类不知道它所需要的对象的类时，在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li><li>当一个类希望通过其子类来指定创建对象时，在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><ul><li>抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</li><li>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类</li><li>允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。</li></ul><h4 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>降低耦合，抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；</li><li>更符合开-闭原则，新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可</li></ul><h4 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h4><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品族</td><td>抽象产品的父类</td><td>描述抽象产品的公共接口</td></tr><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述具体产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>抽象工厂</td><td>具体工厂的父类</td><td>描述具体工厂的公共接口</td></tr><tr><td>具体工厂</td><td>抽象工厂的子类；被外界调用</td><td>描述具体工厂；实现工厂方法创建产品的实例</td></tr></tbody></table><h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261459666.png" alt="img"></p><h4 id="举例实例"><a href="#举例实例" class="headerlink" title="举例实例"></a>举例实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">ManufactureContainer</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">ManufactureMould</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProduct</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器产品抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContainerProduct</span> <span class="keyword">extends</span> <span class="title class_">AbstractProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模具产品抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MouldProduct</span> <span class="keyword">extends</span> <span class="title class_">AbstractProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器产品A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerProductA</span> <span class="keyword">extends</span> <span class="title class_">ContainerProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了容器产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器产品B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerProductB</span> <span class="keyword">extends</span> <span class="title class_">ContainerProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了容器产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模具产品A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouldProductA</span> <span class="keyword">extends</span> <span class="title class_">MouldProduct</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了模具产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模具产品B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouldProductB</span> <span class="keyword">extends</span> <span class="title class_">MouldProduct</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了模具产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A厂 - 生产模具+容器产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ContainerProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureMould</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MouldProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B厂 - 生产模具+容器产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ContainerProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureMould</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MouldProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">mFactoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">mFactoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        <span class="comment">//A厂当地客户需要容器产品A</span></span><br><span class="line">        mFactoryA.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//A厂当地客户需要模具产品A</span></span><br><span class="line">        mFactoryA.ManufactureMould().Show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B厂当地客户需要容器产品B</span></span><br><span class="line">        mFactoryB.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//B厂当地客户需要模具产品B</span></span><br><span class="line">        mFactoryB.ManufactureMould().Show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产出了容器产品A</span><br><span class="line">生产出了容器产品B</span><br><span class="line">生产出了模具产品A</span><br><span class="line">生产出了模具产品B</span><br></pre></td></tr></table></figure><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><ul><li>抽象工厂模式很难支持新种类产品的变化</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><ul><li>实现1个类只有1个实例化对象 &amp; 提供一个全局访问点</li><li>从上面可看出：工人类操作的明显不是同一个仓库实例，而全部工人希望操作的是同一个仓库实例，即只有1个实例</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的，要是想实现一个类只有一个实例化对象。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261501938.png" alt="img"></p><h4 id="举例实现-1"><a href="#举例实现-1" class="headerlink" title="举例实现"></a>举例实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建私有变量 ourInstance（用以记录 Singleton 的唯一实例）</span></span><br><span class="line"><span class="comment">//2. 内部进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 把类的构造方法私有化，不让外部调用构造方法实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4. 定义公有方法提供该类的全局唯一访问点</span></span><br><span class="line"><span class="comment">//5. 外部通过调用getInstance()方法来返回唯一的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="情景代入"><a href="#情景代入" class="headerlink" title="情景代入"></a>情景代入</h4><p>背景：小成有一个塑料生产厂，但里面只有一个仓库。<br>目的：想用代码来实现仓库的管理<br>现有做法： 建立仓库类和工人类     其中，仓库类里的quantity=商品数量；工人类里有搬运方法MoveIn(int i)和MoveOut(int i)。</p><h5 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仓库类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreHouse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuantity</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQuantity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搬货工人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Carrier</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> StoreHouse mStoreHouse;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Carrier</span><span class="params">(StoreHouse storeHouse)</span>&#123;</span><br><span class="line">        mStoreHouse = storeHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货进仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveIn</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货出仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveOut</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工人搬运测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglePattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreHouse</span>();</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreHouse</span>();</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse1);</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;两个是不是同一个？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mStoreHouse1.equals(mStoreHouse2))&#123;<span class="comment">//这里用equals而不是用 == 符号，因为 == 符号只是比较两个对象的地址</span></span><br><span class="line">            System.out.println(<span class="string">&quot;是同一个&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是同一个&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搬运工搬完货物之后出来汇报仓库商品数量</span></span><br><span class="line">        Carrier1.MoveIn(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier1.mStoreHouse.getQuantity());</span><br><span class="line">        Carrier2.MoveOut(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier2.mStoreHouse.getQuantity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例实现"><a href="#单例实现" class="headerlink" title="单例实现"></a>单例实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scut.designmodel.SingletonPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例仓库类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreHouse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仓库商品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//自己在内部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StoreHouse</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreHouse</span>();;</span><br><span class="line">    <span class="comment">//让外部通过调用getInstance()方法来返回唯一的实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StoreHouse <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封闭构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StoreHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuantity</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQuantity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//搬货工人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Carrier</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> StoreHouse mStoreHouse;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Carrier</span><span class="params">(StoreHouse storeHouse)</span>&#123;</span><br><span class="line">        mStoreHouse = storeHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货进仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveIn</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货出仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveOut</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工人搬运测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglePattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse1</span> <span class="operator">=</span> StoreHouse.getInstance();</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse2</span> <span class="operator">=</span> StoreHouse.getInstance();</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse1);</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;两个是不是同一个？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mStoreHouse1.equals(mStoreHouse2))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是同一个&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是同一个&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搬运工搬完货物之后出来汇报仓库商品数量</span></span><br><span class="line">        Carrier1.MoveIn(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier1.mStoreHouse.getQuantity());</span><br><span class="line">        Carrier2.MoveOut(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier2.mStoreHouse.getQuantity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多种单例模式实现方式"><a href="#多种单例模式实现方式" class="headerlink" title="多种单例模式实现方式"></a>多种单例模式实现方式</h4><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><ul><li>依赖JVM类加载机制，保证单例只会被创建一次，即线程安全</li><li>JVM在类的初始化阶段，会执行类的初始化</li><li>在执行类的初始化的时候，JVM会去获取一个锁，这个所可以同步多个线程对同一个类的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 加载该类时，单例就会自动被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">    <span class="comment">// 原因：禁止他人创建实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通过调用静态方法获得创建的单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5></li><li>根据枚举类型的下述特点，满足单例模式所需的创建单例，线程安全，实现简介的需求</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261509469.jpeg" alt="img"></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义1个枚举的元素，即为单例类的1个实例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏了1个空的、私有的 构造方法</span></span><br><span class="line">    <span class="comment">// private Singleton () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例的方式：</span></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br></pre></td></tr></table></figure><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><ul><li>单例创建时机可控，有需要的时候才手动创建单例</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 类加载时，先不自动创建单例</span></span><br><span class="line">   <span class="comment">//  即，将单例的引用先赋值为 Null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">    <span class="comment">// 原因：禁止他人创建实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 需要时才手动调用 newInstance（） 创建 单例   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">    <span class="keyword">if</span>( ourInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">        ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><ul><li>对于懒汉会存在线程不安全的时候，特别是在多线程时候会出现以下问题</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261512668.png" alt="img"></li></ul><h4 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h4><ul><li>使用同步锁synchronized，锁住创建单例的方法，防止多个线程同时调用，从而避免造成单例被多次创建</li><li>getInstance（）方法块只能运行在一个线程中</li><li>倘若此段代码已在一个线程中运行，则另外一个线程试图运行该块代码，则会被一直阻塞二一直等待。<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 类加载时，先不自动创建单例</span></span><br><span class="line">    <span class="comment">//  即，将单例的引用先赋值为 Null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">    <span class="comment">// 原因：禁止他人创建实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3. 加入同步锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">        <span class="keyword">if</span> ( ourInstance == <span class="literal">null</span> )</span><br><span class="line">            ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="comment">// 该写法的作用与上述写法作用相同，只是写法有所区别</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 加入同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h4><ul><li>在同步锁的基础上，添加多一层if判断，若单例已经创建，则不需要执行加锁操作就可以获取实例，从而提高性能</li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 加入双重校验锁</span></span><br><span class="line">    <span class="comment">// 校验锁1：第1个if</span></span><br><span class="line">    <span class="keyword">if</span>( ourInstance == <span class="literal">null</span>)&#123;  <span class="comment">// ①</span></span><br><span class="line">     <span class="keyword">synchronized</span> (Singleton.class)&#123; <span class="comment">// ②</span></span><br><span class="line">      <span class="comment">// 校验锁2：第2个 if</span></span><br><span class="line">      <span class="keyword">if</span>( ourInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">          ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 校验锁1：第1个if</span></span><br><span class="line"><span class="comment">// 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作</span></span><br><span class="line"><span class="comment">// 即直接跳到执行 return ourInstance</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验锁2：第2个 if </span></span><br><span class="line"><span class="comment">// 作用：防止多次创建单例问题</span></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line">  <span class="comment">// 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance()</span></span><br><span class="line">  <span class="comment">// 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕</span></span><br><span class="line">  <span class="comment">// 3. 当线程A释放同步锁时，单例已创建，即instance已非空</span></span><br><span class="line">  <span class="comment">// 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例</span></span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul><li>更具静态内部类的特性，同步解决按需加载，线程安全的问题，同时实现简洁</li><li>在静态内部类中创建单例，在装载该内部类的时候才会去创建单例</li><li>线程安全：类是由JVM加载，而JVM只会加载一遍，保证只有一个单例</li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">       <span class="comment">// 在静态内部类里创建单例</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>()；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延迟加载、按需创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton2.ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用过程说明：</span></span><br><span class="line">      <span class="comment">// 1. 外部调用类的newInstance() </span></span><br><span class="line">      <span class="comment">// 2. 自动调用Singleton2.ourInstance</span></span><br><span class="line">       <span class="comment">// 2.1 此时单例类Singleton2得到初始化</span></span><br><span class="line">       <span class="comment">// 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例；</span></span><br><span class="line">       <span class="comment">// 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性</span></span><br><span class="line">      <span class="comment">// 3. 最终只创建1个单</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261537777.png" alt="img"></p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li><li>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</li><li>建造者模式负责按照是顺序创建复杂对象（把内部的建造过程和细节隐藏藏匿起来）</li></ul><h4 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>方便用户创建复杂的对象</li><li>代码复用性以及封装性（将对象构建过程和细节进行封装以及复用）</li><li>方便解耦，方便控制对象的创建，方便于拓展。</li></ul><h4 id="UML类图-3"><a href="#UML类图-3" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303270853304.png" alt="img"></p><h4 id="模式讲解"><a href="#模式讲解" class="headerlink" title="模式讲解"></a>模式讲解</h4><ol><li>指挥者直接和客户进行需求沟通</li><li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求</li><li>将各个部件的建造请求委派到具体的建造者</li><li>各个具体建造者负责进行产品部件的构建</li><li>最终构建成具体产品。</li></ol><h4 id="情景代入-1"><a href="#情景代入-1" class="headerlink" title="情景代入"></a>情景代入</h4><ul><li>背景：小成希望去电脑城买一台组装的台式主机</li><li>过程：   </li></ul><ol><li>电脑城老板（Diretor）和小成（Client）进行需求沟通（买来打游戏？学习？看片？）</li><li>了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）</li><li>指挥装机人员（ConcreteBuilder）去构建组件；</li><li>将组件组装起来成小成需要的电脑（Product）；</li></ol><h5 id="举例实例-1"><a href="#举例实例-1" class="headerlink" title="举例实例"></a>举例实例</h5><ol><li>定义组装的过程：组装电脑的过程<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line"><span class="comment">//第一步：CPU</span></span><br><span class="line"><span class="comment">//声明为抽象方法，具体由子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildCPU</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//第二步：装主板</span></span><br><span class="line"><span class="comment">//声明为抽象方法，具体由子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildMainboard</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//第三步：装硬盘</span></span><br><span class="line"><span class="comment">//声明为抽象方法，具体由子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildHD</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//返回产品的方法：获得组装好的电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title function_">GetCompputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>电脑城老板委派任务给装机人员<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span>&#123;</span><br><span class="line"><span class="comment">//指挥装机人员组装的电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Construct</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">builder.BuildCPU();</span><br><span class="line">builder.BuildMainboard();</span><br><span class="line">builder.BuuildHD();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建具体的建造者：装机人员<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品实例</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装产品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildCPU</span><span class="params">()</span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;组装CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuilMainboard</span><span class="params">()</span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;组装主板&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildHD</span><span class="params">()</span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;组装硬盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回组装成功的电脑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">GetComputer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义具体产品类：电脑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="comment">//电脑组件的集合</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//用于将组件组装到电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Add</span><span class="params">(String part)</span>&#123;</span><br><span class="line">part.add (part);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;&lt;part.size();i++)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;组件&quot;</span>+part.get(i)+<span class="string">&quot;装好了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;电脑组装完成，请验收&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端调用-小成到电脑找了老板买电脑</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Builder</span> Pattern&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逛了很久终于发现一家合适的电脑店</span></span><br><span class="line"><span class="comment">//找到该店的老板和装机人员</span></span><br><span class="line">  <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line">  <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//沟通需求后，老板叫装机人员去装电脑</span></span><br><span class="line">director.Construct(builder);</span><br><span class="line"></span><br><span class="line"><span class="comment">//装完后，组装人员搬来组装好的电脑</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> builder.GetComputer();</span><br><span class="line"><span class="comment">//组装人员展示电脑给小成看</span></span><br><span class="line">computer.Show()；</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><ul><li>它允许通过复制现有的对象来创建新的对象，而不是通过创建新的实例并初始化它们来创建对象。这种模式通常用于创建具有相同属性的多个对象，以避免重复的初始化过程。在原型模式中，原型对象是创建新对象的模板，新对象是通过复制原型对象来创建的。原型模式的实现通常需要实现 Cloneable 接口或者使用序列化和反序列化来实现对象的复制。</li></ul><h4 id="UML类图-4"><a href="#UML类图-4" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303271043974.png" alt="image-20230327104312924"></p><h4 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>逃避构造函数的约束。</li></ul><h4 id="举例实例-2"><a href="#举例实例-2" class="headerlink" title="举例实例"></a>举例实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line">   <span class="keyword">protected</span> String type;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         clone = <span class="built_in">super</span>.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span>&#123;</span><br><span class="line">     type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">()</span>&#123;</span><br><span class="line">     type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">     type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeCache</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap </span><br><span class="line">      = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;String, Shape&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeId)</span> &#123;</span><br><span class="line">      <span class="type">Shape</span> <span class="variable">cachedShape</span> <span class="operator">=</span> shapeMap.get(shapeId);</span><br><span class="line">      <span class="keyword">return</span> (Shape) cachedShape.clone();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">   <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">   <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadCache</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      circle.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      shapeMap.put(circle.getId(),circle);</span><br><span class="line"> </span><br><span class="line">      <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">      square.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      shapeMap.put(square.getId(),square);</span><br><span class="line"> </span><br><span class="line">      <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      rectangle.setId(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ShapeCache.loadCache();</span><br><span class="line"> </span><br><span class="line">      <span class="type">Shape</span> <span class="variable">clonedShape</span> <span class="operator">=</span> (Shape) ShapeCache.getShape(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape.getType());        </span><br><span class="line"> </span><br><span class="line">      <span class="type">Shape</span> <span class="variable">clonedShape2</span> <span class="operator">=</span> (Shape) ShapeCache.getShape(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape2.getType());        </span><br><span class="line"> </span><br><span class="line">      <span class="type">Shape</span> <span class="variable">clonedShape3</span> <span class="operator">=</span> (Shape) ShapeCache.getShape(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape3.getType());        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><ul><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很男</li><li>必须实现Cloneable接口</li></ul><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul><li>资源优化</li><li>类初始化需要消化很多资源</li><li>一个对象多个修改者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goal解析以及进阶练习</title>
      <link href="/2023/01/06/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A33/"/>
      <url>/2023/01/06/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A33/</url>
      
        <content type="html"><![CDATA[<h1 id="goal解析"><a href="#goal解析" class="headerlink" title="goal解析"></a>goal解析</h1><p>请你设计一个可以解释字符串 command 的 Goal 解析器 。</p><ul><li>command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。</li><li>Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</li><li>给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。</li></ul><h2 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h2><p>又是偷懒的一天，直接用库函数了</p><ol><li>需要注意的是下面的括号是要转义的，不然会识别成null。</li><li>此方法的时间复杂度会较大，个人猜测是函数内部的循环或条件语句分析相对O-题解比较复杂。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">interpret</span><span class="params">(String command)</span> &#123;</span><br><span class="line">    command = command.replace(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    command = command.replaceAll(<span class="string">&quot;\\(\\)&quot;</span>,<span class="string">&quot;o&quot;</span>);</span><br><span class="line">    command = command.replaceAll(<span class="string">&quot;\\(al\\)&quot;</span>,<span class="string">&quot;al&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li>本题只会出现”G”,”()”以及”(al)”所以不符合”（）”与”G”的条件一律可以按照”（al）”处理。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interpret</span><span class="params">(String command)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; command.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                res.append(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (command.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    res.append(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.append(<span class="string">&quot;al&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetccode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyURL 的加密与解密</title>
      <link href="/2023/01/05/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A32/"/>
      <url>/2023/01/05/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A32/</url>
      
        <content type="html"><![CDATA[<h1 id="TinyURL-的加密与解密"><a href="#TinyURL-的加密与解密" class="headerlink" title="TinyURL 的加密与解密"></a>TinyURL 的加密与解密</h1><ol><li>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a> 。请你设计一个类来加密与解密 TinyURL 。</li></ol><ul><li>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。<br>实现 Solution 类：</li><li>Solution() 初始化 TinyURL 系统对象。</li><li>String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。</li><li>String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。</li></ul><h2 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h2><p>其实我第一时间想到的就只有异或运算而已</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> syscode(longUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> syscode(shortUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">syscode</span><span class="params">(String index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">        <span class="type">char</span> mixcode[] = index.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mixcode.length;i++)&#123;</span><br><span class="line">            mixcode[i] = (<span class="type">char</span>)(mixcode[i]^key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(mixcode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h2><h3 id="来源leetcode"><a href="#来源leetcode" class="headerlink" title="(来源leetcode)"></a>(来源leetcode)</h3><h3 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h3><p>建立哈希表，用自增的id作为URL的键，每次接收一个URL都会使id递增，从而将键值对database进行存储，然后返回带有id的字符串作为shorURL。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; dataBase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        id++;</span><br><span class="line">        dataBase.put(id, longUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> shortUrl.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> Integer.parseInt(shortUrl.substring(p));</span><br><span class="line">        <span class="keyword">return</span> dataBase.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希生成"><a href="#哈希生成" class="headerlink" title="哈希生成"></a>哈希生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">K1</span> <span class="operator">=</span> <span class="number">1117</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">K2</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; dataBase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; urlToKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (urlToKey.containsKey(longUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + urlToKey.get(longUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; longUrl.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> longUrl.charAt(i);</span><br><span class="line">            key = (<span class="type">int</span>) ((key + (<span class="type">long</span>) c * base) % K2);</span><br><span class="line">            base = (base * K1) % K2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dataBase.containsKey(key)) &#123;</span><br><span class="line">            key = (key + <span class="number">1</span>) % K2;</span><br><span class="line">        &#125;</span><br><span class="line">        dataBase.put(key, longUrl);</span><br><span class="line">        urlToKey.put(longUrl, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> shortUrl.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> Integer.parseInt(shortUrl.substring(p));</span><br><span class="line">        <span class="keyword">return</span> dataBase.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetccode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据给定数字划分数组</title>
      <link href="/2023/01/03/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3/"/>
      <url>/2023/01/03/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="根据给定数字划分数组"><a href="#根据给定数字划分数组" class="headerlink" title="根据给定数字划分数组"></a>根据给定数字划分数组</h2><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你将 nums 重新排列，使得以下条件均成立：</p><ul><li>所有小于 pivot 的元素都出现在所有大于 pivot 的元素 之前 。</li><li>所有等于 pivot 的元素都出现在小于和大于 pivot 的元素 中间 。</li><li>小于 pivot 的元素之间和大于 pivot 的元素之间的 相对顺序 不发生改变。<ul><li>更正式的，考虑每一对 pi，pj ，pi 是初始时位置 i 元素的新位置，pj 是初始时位置 j 元素的新位置。对于小于 pivot 的元素，如果 i &lt; j 且 nums[i] &lt; pivot 和 nums[j] &lt; pivot 都成立，那么 pi &lt; pj 也成立。类似的，对于大于 pivot 的元素，如果 i &lt; j 且 nums[i] &gt; pivot 和 nums[j] &gt; pivot 都成立，那么 pi &lt; pj 。</li></ul></li></ul><h3 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h3><p>总体来说时空都是比较占优的空间损耗也不大</p><ol><li>双指针left从0开始递增以及right从数组后置位开始递减，分别用作于比较大于pivot以及小于pivot的，优点在于能够按照原本的次序在新的数组里面安排位置。</li><li>其实等于pivot可以不做比较，可以在新数组的所有元素填满pivot值，然后通过与原数组比较前后开始占位变值。</li><li>其实这里的时间复杂度应该是O（N）的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span>length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> newNum[] = <span class="keyword">new</span> <span class="title class_">int</span> [length];</span><br><span class="line">    Arrays.fill(newNum,pivot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> min=<span class="number">0</span>,max=length-<span class="number">1</span>;left&lt;length&amp;&amp;right&gt;=<span class="number">0</span>;left++,right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;pivot)&#123;</span><br><span class="line">            newNum[min++]=nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]&gt;pivot)&#123;</span><br><span class="line">            newNum[max--]=nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h3><h4 id="简单的三次遍历"><a href="#简单的三次遍历" class="headerlink" title="简单的三次遍历"></a>简单的三次遍历</h4><p>时间较快，空间损耗相对大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] &lt; pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] == pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] &gt; pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="划分以及拼接"><a href="#划分以及拼接" class="headerlink" title="划分以及拼接"></a>划分以及拼接</h4><p>运行时间可以说是题解里最长的了，而且空间也不是最优秀的。可能是因为增强for循环的或者计算长度的原因，比上面多一次循环的方法时间还要久。</p><ol><li>三个数据类型为Integer的ArrayList对象，分别储存三个不同的情况的数值</li><li>计算所有List的长度，建立新的数组，增强循环来依次输入顺序数值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) </span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x: nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            a.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            b.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.size() + b.size() + c.size();</span><br><span class="line">    <span class="type">int</span> [] res = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : b)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : c)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetccode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程耗时计算</title>
      <link href="/2023/01/01/%E8%A1%8C%E7%A8%8B%E8%80%97%E6%97%B6%E8%AE%A1%E6%97%B6/"/>
      <url>/2023/01/01/%E8%A1%8C%E7%A8%8B%E8%80%97%E6%97%B6%E8%AE%A1%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="进程耗时计算"><a href="#进程耗时计算" class="headerlink" title="进程耗时计算"></a>进程耗时计算</h1><p>这是一个能够计算运行进程的包。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">fmt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String title,Task task)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (title==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        title = (title==<span class="literal">null</span>)?<span class="string">&quot;&quot;</span>:(<span class="string">&quot;【&quot;</span>+title+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">        System.out.println(title);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始:&quot;</span>+fmt.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        task.execute();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束:&quot;</span>+fmt.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">double</span> <span class="variable">delta</span> <span class="operator">=</span> (end - begin)/<span class="number">1000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时:&quot;</span>+delta+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>在自建的软件包内建立一个TimeTool文件。</li><li>同包导入<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 软件包名字.TimeTool.Task;</span><br></pre></td></tr></table></figure></li><li>调用方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeTool.check(<span class="string">&quot;此处填写此次进程测试的名字（随便起个名字，方便对比区分）&quot;</span>,<span class="keyword">new</span> <span class="title class_">Task</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//放入你需要测试的进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树（持续更新中）</title>
      <link href="/2022/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h3><p>1.把左右根交换即可</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212190900221.png" alt="image-20221219090003177"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出克隆二叉树中的相同节点"><a href="#找出克隆二叉树中的相同节点" class="headerlink" title="找出克隆二叉树中的相同节点"></a>找出克隆二叉树中的相同节点</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212051005239.png" alt="image-20221205100529196"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TreeNode <span class="title function_">getTargetCopy</span><span class="params">(<span class="keyword">final</span> TreeNode original, <span class="keyword">final</span> TreeNode cloned, <span class="keyword">final</span> TreeNode target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (original == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (original == target) <span class="keyword">return</span> cloned;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> getTargetCopy(original.left, cloned.left, target);</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> getTargetCopy(original.right, cloned.right, target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HomeWork"><a href="#HomeWork" class="headerlink" title="HomeWork"></a>HomeWork</h2><h3 id="自定义树结点"><a href="#自定义树结点" class="headerlink" title="自定义树结点"></a>自定义树结点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">char</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">char</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">char</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="1-先根序列构造二叉树：A-B-null-D-null-null-C-null-null"><a href="#1-先根序列构造二叉树：A-B-null-D-null-null-C-null-null" class="headerlink" title="1. 先根序列构造二叉树：A B null D null null C null null"></a>1. 先根序列构造二叉树：A B null D null null C null null</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个全局变量，其实缺点也会很多，对于后面的方法均需要一个计时器，还有一种就是放在方法内的局部变量，跟着方法递归增加</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//题目给的是字符串，可以用toCharArray()变换字符数组</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">CteateTree</span><span class="params">(<span class="type">char</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; arr.length) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">val</span> <span class="operator">=</span> arr[count++];</span><br><span class="line">        <span class="comment">//当val值不等于空，这里把^当成空，就把新的带有val的节点赋值给真正意义上的根节点，往后的都是左右子树</span></span><br><span class="line">        <span class="keyword">if</span> (val != <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            node.left = CteateTree(arr);</span><br><span class="line">            node.right = CteateTree(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这道题你也简单点理论上可以直接把^也带入结点,不做空值处理,起码在我这里是这样,上面的自定义树节点的基本存储数据类型是用了char.这样好像也可以节省后面遍历的空值处理问题</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对于1中生成的二叉树进行前序、中序、后序遍历。"><a href="#2-对于1中生成的二叉树进行前序、中序、后序遍历。" class="headerlink" title="2.对于1中生成的二叉树进行前序、中序、后序遍历。"></a>2.对于1中生成的二叉树进行前序、中序、后序遍历。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrderTravera(node.left);</span><br><span class="line">        preOrderTravera(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        inOrderTravera(node.left);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrderTravera(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        postOrderTravera(node.left);</span><br><span class="line">        postOrderTravera(node.right);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-计算1中生成的二叉树结点总数。"><a href="#3-计算1中生成的二叉树结点总数。" class="headerlink" title="3. 计算1中生成的二叉树结点总数。"></a>3. 计算1中生成的二叉树结点总数。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老样子,静态全局变量,你也可以局部变量,像下面一样,充当一个计数器的作用,只需要在实例方法中输入从0开始,效果是一样的,局部变量的好处就是当你使用完方法后会释放内存,也就是会比一直存在占用内存static全局变量更节省空间.</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//思路很简单,遇到非空值计数器就+1.考虑到前面提到的^直接带入结点,这里还可能要加上值不为^</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">TreeNodeNum</span><span class="params">(TreeNode node,<span class="comment">/*，int num */</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">        TreeNodeNum(node.left);</span><br><span class="line">        TreeNodeNum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算1中生成二叉树的高度"><a href="#4-计算1中生成二叉树的高度" class="headerlink" title="4. 计算1中生成二叉树的高度"></a>4. 计算1中生成二叉树的高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目的主要问题是怎么在众多的左右子树中找出最大的根深度也就是普遍说的树高</span></span><br><span class="line"><span class="comment">//思路:递归判断,当这个结点为空的时候,则返回0,每次的递归都需要一次深度比较,找出最大的深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNode</span> <span class="operator">=</span>maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> rightNode=maxDepth(root.right);</span><br><span class="line">        <span class="comment">//这里的+1是因为是根节点并没有参与计算,因此需要+上根结点</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftNode,rightNode)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。"><a href="#5-计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。" class="headerlink" title="5.计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。"></a>5.计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总的思路就是判断左右指针的三种情况即可1.均为空 2.左空右不空(左不空右空)3.均不为空</span></span><br><span class="line"><span class="comment">//叶子结点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LeafNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+LeafNodeCount(root.left)+LeafNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LeafNodeCount(root.left) + LeafNodeCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">OneNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span> || root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+OneNodeCount(root.left)+OneNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OneNodeCount(root.left) + OneNodeCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">DoubleNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+DoubleNodeCount(root.left) + DoubleNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DoubleNodeCount(root.left) + DoubleNodeCount(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-按照下面两个序列生成二叉树：先序：ABHFDECKG-；中序：HBDFAEKCG"><a href="#6-按照下面两个序列生成二叉树：先序：ABHFDECKG-；中序：HBDFAEKCG" class="headerlink" title="6.按照下面两个序列生成二叉树：先序：ABHFDECKG ；中序：HBDFAEKCG"></a>6.按照下面两个序列生成二叉树：先序：ABHFDECKG ；中序：HBDFAEKCG</h3><p>前序+中序构造二叉树<br>先序:根 [左子树]  [右子树]<br>中序:[左子树] 根 [右子树]</p><p>思路:只要遍历中序找到根节点,利用双指针确认左右子树遍历结果的长度,再利用先序方式构造即可</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211221135621.png" alt="image-20221122113530560"></p><p>循环寻界+递归构造树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTrees</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">char</span> [] in)</span> &#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    TreeNode root=buildTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主体</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">int</span> PreLeft,<span class="type">int</span> PreRight,<span class="type">char</span> [] in,<span class="type">int</span> inLeft,<span class="type">int</span> inRight)</span> &#123;</span><br><span class="line"><span class="comment">//如果越界则表示结点为空</span></span><br><span class="line">      <span class="keyword">if</span>(PreLeft&gt;PreRight||inLeft&gt;inRight)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//开始构造,声明新结点</span></span><br><span class="line">   TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[PreLeft]);</span><br><span class="line"><span class="comment">//循环寻找中序的根节点,还能够确认左右子树边界</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=inLeft;i&lt;=inRight;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[PreLeft])&#123;</span><br><span class="line"><span class="comment">//先序构造树,指针就定义为左右子树的区间,构造左子树             </span></span><br><span class="line">    root.left=buildTree(pre,PreLeft+<span class="number">1</span>,PreLeft+i-inLeft,in,inLeft,i-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//变化右子树边界,构造右子树</span></span><br><span class="line">     root.right=buildTree(pre,i-inLeft+PreLeft+<span class="number">1</span>,PreRight,in,i+<span class="number">1</span>,inRight);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表优化循环子过程"><a href="#哈希表优化循环子过程" class="headerlink" title="哈希表优化循环子过程"></a>哈希表优化循环子过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过程几乎与上面的方法一样，只不过不需要每次递归后又进行循环来找到边界。</span></span><br><span class="line"><span class="comment">//提前把中序的所有遍历用哈希表储存起来即可。后面的取根直接依靠对应值来寻找序号，用来定界</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTreeTwo</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">char</span> [] in)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">PreLen</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">InLen</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(PreLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;InLen;i++)&#123;</span><br><span class="line">            map.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeTwo(pre,<span class="number">0</span>,PreLen-<span class="number">1</span>,map,<span class="number">0</span>,InLen-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTreeTwo</span><span class="params">(<span class="type">char</span>[]pre,<span class="type">int</span> PreLeft,<span class="type">int</span> PreRight,Map&lt;Character,Integer&gt; map,<span class="type">int</span> InLeft,<span class="type">int</span> InRight)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(PreLeft&gt;PreRight||InLeft&gt;InRight)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">val</span> <span class="operator">=</span> pre[PreLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);</span><br><span class="line">        root.left=buildTreeTwo(pre,PreLeft+<span class="number">1</span>,index-InLeft+PreLeft,map,InLeft,index-<span class="number">1</span>);</span><br><span class="line">        root.right=buildTreeTwo(pre,index-InLeft+PreLeft+<span class="number">1</span>,PreRight,map,index+<span class="number">1</span>,InRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="栈方法迭代"><a href="#栈方法迭代" class="headerlink" title="栈方法迭代"></a>栈方法迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] preorder, <span class="type">char</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preorderVal</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                inorderIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="建立树节点"><a href="#建立树节点" class="headerlink" title="建立树节点"></a>建立树节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">TreeNode()&#123;&#125;</span><br><span class="line">TreeNOde(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="type">this</span> <span class="variable">val</span> <span class="operator">=</span> val;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode(<span class="type">int</span> val,TreeNode left,TreeNode right)&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.left=left;</span><br><span class="line"><span class="built_in">this</span>.right=right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">preOrderTraveral(node.left);</span><br><span class="line">preOrderTraveral(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">inOrderTraveral(node.left);</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">inOrderTraveral(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">postTraveral(node.left);</span><br><span class="line">postTraveral(node.right);</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leverOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//声明一个队列对象</span></span><br><span class="line">        Queue&lt;TreeNode&gt; storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 根节点为空，返回空值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把结点拉入队列</span></span><br><span class="line">        storage.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!storage.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//把队列首部拉出输出值并且访问左右子树结点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> storage.poll();</span><br><span class="line">            System.out.print(cur.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//若左指针不为空，就把左子树拉入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                storage.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若右指针不为空，就把右子树拉入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">                storage.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p><a href="https://zitiu.top/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/">https://zitiu.top/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/</a></p><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><h3 id="总思路"><a href="#总思路" class="headerlink" title="总思路"></a>总思路</h3><ol><li><p>只要提到树的话就几乎都会涉及到递归和回溯.</p></li><li><p>比较常用的算法思想就是深度和广度优先搜索</p><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3></li><li><p> 这道题我的思路很简单,就是递归遍历,进行创新节点的操作</p></li><li><p>可以分三种情况</p><ul><li>两个节点均为null值</li><li>一个节点为null,一个不为null值</li><li>两个节点都不是null值</li></ul></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121621158.png" alt="image-20221112162114118"></p><p>实现1:深度优先搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">merageTrees</span><span class="params">(TreeNode r1,TreeNode r2)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(r1==<span class="literal">null</span>) <span class="keyword">return</span> r2;</span><br><span class="line">   <span class="keyword">if</span>(r2==<span class="literal">null</span>) <span class="keyword">return</span> r1;</span><br><span class="line">   <span class="type">TreeNode</span> <span class="variable">metaTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(r1.val+r2.val);</span><br><span class="line">   metaTree.left = merageTrees(r1.left,r2.left);</span><br><span class="line">   metaTree.right= merageTrees(r1.right,r2.right);</span><br><span class="line">   <span class="keyword">return</span> metaTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现2:广度优先搜索</p><ol><li>主要实现:构建三个队列分别储存3颗树的每个节点</li></ol><ul><li>每次从队列种取出一个节点,判断两个原始树的结点是否为空<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t1 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> t2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> t1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      queue.offer(merged);</span><br><span class="line">      queue1.offer(t1);</span><br><span class="line">      queue2.offer(t2);</span><br><span class="line">      <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;</span><br><span class="line">          <span class="keyword">if</span> (left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                  node.left = left;</span><br><span class="line">                  queue.offer(left);</span><br><span class="line">                  queue1.offer(left1);</span><br><span class="line">                  queue2.offer(left2);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.left = left1;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.left = left2;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                  node.right = right;</span><br><span class="line">                  queue.offer(right);</span><br><span class="line">                  queue1.offer(right1);</span><br><span class="line">                  queue2.offer(right2);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.right = right1;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  node.right = right2;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121840333.png" alt="image-20221112184055309"></p><ol><li>树的递归判断</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp;q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">null</span>||q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(p.val!=q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> isSameTree(p,left,q.left)&amp;&amp;isSameTree(p.right,q.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121844717.png" alt="image-20221112184440687"></p><ol><li>基本和相同树的判断思想是一样的，只要把左右两个孩子分别当作新的结点进行比较</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span>  isSameTree(root,root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode leftnode,TreeNode rightnode)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(leftnode==<span class="literal">null</span>&amp;&amp;rightnode==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftnode==<span class="literal">null</span>||rightnode==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> leftnode.val==rightnode.val&amp;&amp;isSameTree(leftnode.left,rightnode.right)&amp;&amp;isSameTree(leftnode.right,rightnode.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121849830.png" alt="image-20221112184924806"> </p><ol><li>思路也是十分的简单，像数组的位置变换一样，定义一个辅助变量，而这边定义一个新的树对象来储存。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思想十分像数组的辅助变量位置变换的方法</span></span><br><span class="line">       <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 声明一个新的对象，先是储存右孩子的数据</span></span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> root.right;</span><br><span class="line">           root.right = invertTree(root.left);</span><br><span class="line">           root.left = invertTree(rightTree);</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><ol><li>做法几乎于最大深度差不多，只是把max改成min罢了</li><li>但是要注意的是空节点是不需要比较的。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211131358958.png" alt="image-20221113135809932"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubilc <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+minDepth(root.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+minDepth(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><ol><li>我第一反应是一定要用到层次遍历，那么每层的结点个数我是应该怎么确定呢？</li><li> 然而实际上确实需要用到层次遍历的思想，而且还需要一个计数器</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211231913942.png" alt="image-20221123191353894"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Double&gt; storage = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">       Queue&lt;TreeNode&gt; stoge = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">       stoge.offer(root);</span><br><span class="line">       <span class="keyword">while</span>(!stoge.isEmpty())&#123;</span><br><span class="line">           <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stoge.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">               root = stoge.poll();</span><br><span class="line">               sum += root.val;</span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stoge.offer(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stoge.offer(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       storage.add(sum/size);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> storage;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>步骤解析<ol><li>在while之前把根结点代入队列。</li><li>开始while循环，重置sum值，目的是为了把每层的的结点总值区分开添入List中</li><li>获取队列的长度，队列的长度在这里其实就是这层结点的总数</li><li>比如代入root后，然后元素出队，因为此时的队列中只有root一个元素，所以出队root后，队列为空，停止循环，然后计算sum值，sum值得计算是用for循环本层得结点数得次数后得到得，然后把sum/size添加入List中</li><li>判断，那么两个if语句为了让下一个左右结点得入队，空则不入，不空则入。</li></ol></li></ol><h3 id="404-左子叶之和"><a href="#404-左子叶之和" class="headerlink" title="404.左子叶之和"></a>404.左子叶之和</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211251049323.png" alt="image-20221125104925282"></p><ol><li>首先需要的是找到叶子节点，如果是就回溯到上一个结点输出左子叶，如果不是的话就往下递归。<ol><li>递归<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root.left!=<span class="literal">null</span>&amp;&amp;root.left.right==<span class="literal">null</span>&amp;&amp;root.left.left==<span class="literal">null</span>)&#123;</span><br><span class="line">           sum += root.left.val;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right)+sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>队列（广度优先搜索）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    storage.offer(root);</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!storage.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> storage.poll();</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left.right==<span class="literal">null</span>&amp;&amp;node.left.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                sum+=node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                storage.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(node.right.left==<span class="literal">null</span>&amp;&amp;node.right.right==<span class="literal">null</span>))&#123;</span><br><span class="line">                storage.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
          <category> 持续更新中 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-传输层</title>
      <link href="/2022/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2022/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>UDP是无连接的，减少开销和发送数据之前的时延</li><li>UDP使用最大努力交付，即不保证可靠交付</li><li>面向报文，适合一次性传输少量的数据的网络应用</li><li>没有拥塞控制，适合多实时应用</li><li>首部开销晓，8B，Tcp208<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211151804590.png" alt="image-20221115180421539"></li></ol><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><ol><li>UDP长度是指UDP用户数据报的整个长度</li><li>UDP检验和是用来检测整个UDP数据报是否有错，错就丢弃</li><li>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161119442.png" alt="image-20221116111919394"></li></ol><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><ol><li>伪首部只有在计算机检验和时才出现，不向下传送也不向上递交。</li><li>17：封装UDP报文的IP数据报首部协议字段17。</li><li>UDP长度：UDP首部8B+数据部分长度（不包括伪首部）。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161132390.png" alt="image-20221116113239359"><br>在发送端上会存在：</li><li>填上伪首部</li><li>全0填充检验和字段</li><li>全0填充数据部分（UDP数据报要看称许多4B的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入检验和字段</li><li>去掉伪首部，发送<br>在接收端上会存在：</li><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告</li></ol><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ol><li>TCP是面向连接的传输层协议。</li><li>TCP只能有两个端点，每一条TCP连接只能是点对点的（因此没办法运用多播和广播的通讯方式）</li><li>TCP提供可靠交付的服务，无差错，不丢失，不重复，按序到达</li><li>提供全双工通讯（有发送缓存和接收缓存 ）</li><li>TCP面向字节流：TCP把应用程序交下来的数据看成一连串无结构的字节流</li></ol><h3 id="报文段的首部格式"><a href="#报文段的首部格式" class="headerlink" title="报文段的首部格式"></a>报文段的首部格式</h3><ol><li>序号：在一个TCP连接中传送的字节流中的每一个字节都在按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号</li><li>确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1位置的所有数据都已正确收到。</li><li>数据偏移：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即一个数组是4B。</li><li>6个控制位<ul><li>紧急位URG：URG=1时，标明此报文段中有紧急数据，是最高优先级的数据，应该尽快传送，不用在缓存中排队，配合紧急指针字段使用（发送方）。</li><li>确认位ACK：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li>推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位RST：RST=1时，标明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li>同步位SYN：SYN=1时，表明是一个连接请求/连接接受报文。</li><li>终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul></li><li>窗口：发送本报文段的一方接受窗口，即现在允许对方发送的数据量</li><li>检验和：检验首部+数据，检验时加上12B的伪首部，第四个字段为6.</li><li>紧急指针：URF=1时才有意义，指出本报文段中紧急数据的字节数</li><li>选项：最大报文段长度MSS，窗口扩大，时间戳，选择确认</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161310156.png" alt="image-20221116131046116"></p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><ol><li>TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器</li><li>假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用一下步骤与服务器中的TCP建立一条TCP连接<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211171124294.png" alt="image-20221117112431243"><ol><li>客户端发送连接请求报文段，无应用层数据SYN=1，seq=x（随机）</li><li>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。SYN=1，ACK=1，seq=y（随机），ack=x+1</li><li>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据SYN=0，ACK=1，seq=x+1,ack=y+1。</li></ol></li></ol><h3 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h3><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者会发送TCP SYN，SYN就是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，而那个TCP连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><p>1.参与一条TCP连接的两个进程中的任何一个都能终止连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。</p><ol><li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接FIN=1，seq=u</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了–半关闭状态ACK=1，seq=v,ack=u+1。</li><li>服务端发完数据，就发送连接释放报文段，主动关闭TCP连接。FIN=1，ACK=1，seq=w,ack=u+1</li><li>客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。ACK=1，seq=u+1，ack=w+1</li></ol><h3 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h3><ol><li>保证接受方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。也就是说明了数据帧在传输过程中既不能丢失，也不能受影响。<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4></li></ol><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><ol><li><p>一个字节占用一个序号</p></li><li><p>序号字段指的是一个报文段第一个字节的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211202009218.png" alt="image-20221120200930161"></p><h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4></li><li><p>发送方会保存一个TCP缓存报文段</p></li><li><p>接收方会在收到报文段后会发送确认报文段，当然接收方也可发送数据与确认报文段发去给发送方</p></li><li><p>若报文段在传输过程中丢失了，TCP会使用累计确认的方法，接收方会返回一个丢失报文段后的第一个字节的确认号报文段</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211202017088.png" alt="image-20221120201732026"></p><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><ol><li><p>超时重传，若在规定时间内发送方没有接收到接收方的确认数据报，就会进行重传。</p></li><li><p>TCP动态改变重传的规定时间RTTs（加权平均往返时间）</p></li><li><p>冗余ACK（冗余确认）每当期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。例子：发送方已发送1，2，3，4，5报文段</p></li></ol><ul><li>接收方收到1，返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到3，仍然返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到4，仍返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到5，仍返回给1的确认（确认号为2的第一个字节）<br>如果发送方收到了3个对于报文段1的冗余ACK就会认为报文段丢失，重传2号报文段，快速重传。</li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><ol><li>利用滑动窗口机制实现流量控制</li><li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212052140044.png" alt="image-20221205214003915"></li><li>TCP会为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就会启动持续计时器</li><li>若持续计时器设置的时间到期，就会发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值</li><li>若窗口仍然是0，那么发送方会重新设置持续计时器</li></ol><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>问题：当资源需求的总和大于可用资源的总和就会出现拥塞的条件，那么会有许多资源同时呈现供应不足就会导致网络性能变坏然后网络的吞吐量将会随输入负荷增大而下降</p><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>传输轮次：发送了一批报文段并收到了他们的确认的时间，也可以指的是往返的时延RTT</p><ol><li><p>探测网络拥塞程度后，提升拥塞窗口的数量</p></li><li><p>ssthresh的初始值指的是慢开始的值（不会再以指数增长的形式增长），会以加法的形式来增加，这就叫拥塞避免</p></li><li><p>当遇到网络拥塞的时候，就会执行断崖式减少，拥塞窗口会跌到cwnd=1，重新开始增加</p></li><li><p>在这过程中，可能会重新更新ssthresh，当遇到网络控制的时候，会把发送拥塞的cwnd值马上除以2生成新的ssthresh值，那么下一轮次的慢开始会从新的ssthresh开始。</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303271128126.png" alt="image-20221205221100217"></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>1.快重传就是等于冗余ack的算法是一致的，当某个报文段的确认帧并没有被发送方收到时候，后面发送的报文段返回的始终是还未收到的确认报文，当积累到三次的时候就会重传。<br>2.快恢复是和上面的ssthresh值是有关联的，当发送网络拥塞的时候，cwnd并不会直接降落到1，而是会降落到ssthresh值上直接进行慢开始。这样能够减少cwnd的变化幅度从而优化了速度。但是ssthresh值还是需要根据发送网络拥塞的cwnd来决定的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2022/11/15/Http/"/>
      <url>/2022/11/15/Http/</url>
      
        <content type="html"><![CDATA[<h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>超文本传输协议(Hyper Text Transfer Protocol，Http)是一个简单的请求-响应协议，它通常运行在TCP之上，它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求何响应消息的头以ASCII形式给出；而消息内容则具有了MIME格式。所有的WWW文件都必须遵守这个标准</li><li>Http是一个基于TCP/IP通信协议来传递数据的（HTML文件，信息，结果等）</li></ul><h2 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h2><ul><li>Http是从万维网服务器传输超文本到本地浏览器的传送协议</li><li>Https是一种通过计算机网络进行的安全通信的传输协议</li><li>端口不一样Http的URL是默认使用端口80，而Https的是默认使用端口443<h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3></li><li>Https是通过Http进行通信，利用SSL/TLS来加密数据包，Https开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私和完整性<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4></li><li>1.TCP三次同步握手</li><li>2、客户端验证服务器数字证书</li><li>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>4、SSL 安全加密隧道协商完成</li><li>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210221158748.jpeg" alt="img"></p><h5 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h5><ul><li><p>SYN</p><ul><li>指的是<strong>同步序列编号</strong>，是T<strong>CP/IP</strong>建立连接时使用的握手信号。在客户端与服务器之间建立正常的<strong>TCP网络</strong>连接时，客户机首先发出一个<strong>SYN</strong>消息，服务器使用<strong>SYN+ACK</strong>应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起<strong>可靠的TCP连接</strong>，<strong>数据</strong>才可以在客户机和服务器之间传递。</li></ul></li><li><p>MIME</p><ul><li>多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该<strong>扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</strong>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</li></ul></li><li><p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号）客户端进入<strong>SYN_SEND</strong></p></li><li><p>第二次握手，服务器接收客户端syn包并且确认，同时向客户端发送一个SYN包，即SYN+ACK包，此时服务器处于<strong>SYN_RECV状态</strong></p></li><li><p>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入了<strong>ESTABLISHED状态</strong></p><h3 id="Http的工作原理"><a href="#Http的工作原理" class="headerlink" title="Http的工作原理"></a>Http的工作原理</h3></li><li><p>HTTP协议工作与客户端-服务端架构上</p></li><li><p>浏览器作为客户端通过URL向服务端发送所有请求</p></li><li><p>Web的服务端有Apache服务器，IIS服务器</p></li><li><p>需要注意的是</p><ul><li>HTTP是无连接，无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，断开连接以达到节省传输时间</li><li>它是一个媒体独立的，意味着，客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的MiME-type内容类型</li><li>它是无状态的：指的是对于事务的处理它是没有记忆能力的，这就说明如果后续需要处理前面的信息的话，必须得重新传输，导致每次连接的数据量增大。 </li></ul></li></ul><h3 id="Https-1"><a href="#Https-1" class="headerlink" title="Https"></a>Https</h3><ul><li>能够在不安全的网络上创建一个安全通道，并且可以使用适当的加密包和服务器证书验证且可被信任</li><li>当以下情况达成时可被信任</li><li>浏览器正确的实现了HTTPS且操作系统中安装了正确且受信任的证书颁发机构；</li><li>次协议的加密层也就是SSL./TLS能够有效的提供认证和高强度的加密</li></ul><h2 id="Http的消息结构"><a href="#Http的消息结构" class="headerlink" title="Http的消息结构"></a>Http的消息结构</h2><ul><li><p>客户端一般发送一个HTTP请求到服务器的请求消息包括以下格式：请求行，请求头部，空行和请求数据四个部分组成。</p><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210221316880.png" alt="image-20221022131636849"></li></ul></li><li><p>服务器响应也是四个部分组成，分别是：状态行，消息报头，空行和响应正文</p></li></ul><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><table><thead><tr><th>number</th><th>method</th><th>descrition</th></tr></thead><tbody><tr><td>1.</td><td>GET</td><td>请求指定的页面信息，返回实体主体</td></tr><tr><td>2.</td><td>HEAD</td><td>返回的响应中没有具体内容，用于获取报头</td></tr><tr><td>3.</td><td>POST</td><td>向指定的资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能导致新的资源的建立和/或已有的资源的修改</td></tr><tr><td>4.</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档内容</td></tr><tr><td>5.</td><td>DELETE</td><td>请求服务器伤处指定画面</td></tr><tr><td>6.</td><td>CONNECT</td><td>预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>7.</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>8.</td><td>PATCH</td><td>对PUT方法的补充，用来对已知资源进行局部更新</td></tr><tr><td>9.</td><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr></tbody></table><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><table><thead><tr><th>状态码</th><th>英文对应名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图存结构</title>
      <link href="/2022/11/15/%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/15/%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）"><a href="#基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）" class="headerlink" title="基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）"></a>基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）</h2><h3 id="什么是图存储结构"><a href="#什么是图存储结构" class="headerlink" title="什么是图存储结构"></a>什么是图存储结构</h3><ul><li>根据有向和无向线来连接每个顶点间的关系<ul><li>有向图：如果元素之间存在单向的联系，那么这样的图结构称为有向图.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210270950517.png" alt="image-20221027095058466"></li><li>无向图：各个元素之间的联系都是双向的，这样的图存结构称为无向图。<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210270952151.png" alt="image-20221027095201129"></li></ul></li></ul><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>1.弧头和弧尾</p><ul><li>有向图中，无箭头的一端的顶点通常被称为“初始点”或“弧尾”，箭头的一段被称为“终端点”或“弧头”。</li></ul><p>2.入度和出度</p><ul><li>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。</li></ul><p>3.(V1,V2)和&lt;V1,V2&gt;的区别</p><ul><li><strong>无向图中描述两顶点V1和V2之间的关系可以用(V1,V2)来表示；有向图中描述从V1到V2的“单向”关系可以用&lt;V1,V2&gt;来表示</strong></li><li>由于图存储结构中顶点之间的关系是可以用线来表示的，因此(V1,V2)还可以用来表示无向图中连接V1和V2的线，又称为边;同样&lt;V1,V2&gt;也可用来表示有向图中从V1到V2带方向的线，又称为弧。</li></ul><p>4.集合VR</p><ul><li>图中习惯用VR表示图中所有顶点之间的关系的集合，例如，上图无向图的集合VR={(V1,V2),(V1,V4),(V1,V3),(V3,V4)}。有向图的集合 VR={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。</li></ul><p>5.路径和回路</p><ul><li>无论是无向图还是有向图，从一个顶点到另一个顶点途径的所有顶点组成的序列（包括起点和终点），称为一条路径。若路径中的<strong>某个顶点能够最后回到自己身上</strong>，那么这个路径称为<strong>环</strong>或者<strong>回路</strong></li></ul><p>6.权和网</p><ul><li>在一些图中，可能为每条边赋值一个实数表示一定的含义，这种与边（或弧）相互匹配的实数被称为“权”，而带权的图通常称为网。例如，图4就是一个网结构:<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271035591.png" alt="image-20221027103555566"></li></ul><p>7.子图</p><ul><li>指的是由图中一部分顶点和边构成的图称为原图的子图</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h4><ul><li>每个顶点都有与除开自身外的其他顶点有直接关系</li><li>若有n个顶点的完全图，则图中边的数量为n(n-1)/2;而对于具有n个顶点的有向完全图，图中的弧的数量为n(n-1)。<h4 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h4></li><li><strong>如果图中从一个顶点到达另外一个顶点，至少有一条路径，那么这两个顶点是连通着的。</strong>例如图中，虽然V1和V3没有直接关联，但从V1到V3存在两条路径，分别是V1-V2-V3和V1-V4-V3，因此称V1和V2之间是连通的<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271101163.png" alt="image-20221027110110138"><br>上面用的是无向图的例子，其实有向图也是基本差不多的啦，自己揣摩哦！！！！<h5 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h5></li><li>在有向图中两个顶点彼此都有至少有一条通路，那么这有向图为强连通图。</li><li>除此之外，若有向图不是强连通图，但其中包含的是最大连通子图具有强连通的性质，则称该子图为强连通分量<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271112764.png" alt="image-20221027111223735"></li></ul><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><ul><li>其实对连通图的遍历的过程中就已经是生成树的过程了<br>1.如图：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271122665.png" alt="image-20221027112213637"><br>2.需要注意的是连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。<br>3.连通图中的生成树必须满足以下 2 个条件：<ul><li>包含连通图中所有的顶点；</li><li>任意两顶点之间有且仅有一条通路；</li></ul></li></ul><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><h3 id="图的顺序存储结构"><a href="#图的顺序存储结构" class="headerlink" title="图的顺序存储结构"></a>图的顺序存储结构</h3><ul><li>虽然图结构的数据元素存在多对多关系，但是同样可以采用顺序储存，能够使用数组有效的储存图</li><li>需要注意的是：数组储存图时，需要一个数组存放图中顶点本身的数据（最好是一维数组），另外一个数组存储的是各顶点之间的关系（这时候就要是二维数组了）<h4 id="邻接矩阵无向图"><a href="#邻接矩阵无向图" class="headerlink" title="邻接矩阵无向图"></a>邻接矩阵无向图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixNDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//图顶点个数</span></span><br><span class="line">    <span class="type">char</span>[] vertexs;<span class="comment">//图顶点名称</span></span><br><span class="line">    <span class="type">int</span>[][] matrix;<span class="comment">//图关系矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixNDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        matrix=<span class="keyword">new</span> <span class="title class_">int</span>[size][size];<span class="comment">//设定图关系矩阵大小</span></span><br><span class="line">        <span class="built_in">this</span>.vertexs=vertexs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;<span class="comment">//设置矩阵值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(c[<span class="number">0</span>]);<span class="comment">//根据顶点名称确定对应矩阵下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(c[<span class="number">1</span>]);</span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>;<span class="comment">//无向图，在两个对称位置存储</span></span><br><span class="line">            matrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的遍历输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据顶点名称获取对应的矩阵下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i]==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line">        MatrixNDG pG;</span><br><span class="line">        <span class="comment">// 自定义&quot;图&quot;(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">// 采用已有的&quot;图&quot;</span></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">MatrixNDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接矩阵有向图"><a href="#邻接矩阵有向图" class="headerlink" title="邻接矩阵有向图"></a>邻接矩阵有向图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixDG</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">char</span>[] vertexs;</span><br><span class="line">    <span class="type">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        matrix=<span class="keyword">new</span> <span class="title class_">int</span>[size][size];</span><br><span class="line">        <span class="built_in">this</span>.vertexs=vertexs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和邻接矩阵无向图差别仅仅在这里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(c[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i]==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line">        MatrixDG pG;</span><br><span class="line">        <span class="comment">// 自定义&quot;图&quot;(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">//pG = new MatrixUDG();</span></span><br><span class="line">        <span class="comment">// 采用已有的&quot;图&quot;</span></span><br><span class="line">        pG = <span class="keyword">new</span> <span class="title class_">MatrixDG</span>(vexs, edges);</span><br><span class="line"></span><br><span class="line">        pG.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表无向表"><a href="#邻接表无向表" class="headerlink" title="邻接表无向表"></a>邻接表无向表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    Vertex[] vertexLists;<span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>&#123;<span class="comment">//邻接表节点类，单链表数据结构</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Vertex next;</span><br><span class="line"></span><br><span class="line">        Vertex(<span class="type">char</span> ch)&#123;<span class="comment">//初始化方法</span></span><br><span class="line">            <span class="built_in">this</span>.ch=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span>&#123;<span class="comment">//加到链表尾</span></span><br><span class="line">            Vertex node=<span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="keyword">new</span> <span class="title class_">Vertex</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line"></span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexLists=<span class="keyword">new</span> <span class="title class_">Vertex</span>[size];<span class="comment">//确定邻接表大小</span></span><br><span class="line">        <span class="comment">//设置邻接表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexLists[i]=<span class="keyword">new</span> <span class="title class_">Vertex</span>(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储边信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">           <span class="type">int</span> p1=getPosition(c[<span class="number">0</span>]);</span><br><span class="line">           vertexLists[p1].add(c[<span class="number">1</span>]);</span><br><span class="line">           <span class="type">int</span> p2=getPosition(c[<span class="number">1</span>]);</span><br><span class="line">           vertexLists[p2].add(c[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟据顶点名称获取链表下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].ch==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历输出邻接表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Vertex temp=vertexLists[i];</span><br><span class="line">           <span class="keyword">while</span>(temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.print(temp.ch+<span class="string">&quot; &quot;</span>);</span><br><span class="line">               temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListNDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">ListNDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接有向表"><a href="#邻接有向表" class="headerlink" title="邻接有向表"></a>邻接有向表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDG</span> &#123;</span><br><span class="line">    Vertex[] vertexLists;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>&#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Vertex next;</span><br><span class="line"></span><br><span class="line">        Vertex(<span class="type">char</span> ch)&#123;</span><br><span class="line">            <span class="built_in">this</span>.ch=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">            Vertex node=<span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="keyword">new</span> <span class="title class_">Vertex</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line"></span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexLists=<span class="keyword">new</span> <span class="title class_">Vertex</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexLists[i]=<span class="keyword">new</span> <span class="title class_">Vertex</span>(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">           <span class="type">int</span> p=getPosition(c[<span class="number">0</span>]);</span><br><span class="line">           vertexLists[p].add(c[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].ch==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Vertex temp=vertexLists[i];</span><br><span class="line">           <span class="keyword">while</span>(temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.print(temp.ch+<span class="string">&quot; &quot;</span>);</span><br><span class="line">               temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">ListDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li><p>所谓图的遍历，简单理解就是逐个访问图中的顶点，确保每个顶点都只访问一次</p></li><li><p>深度优先搜索算法遍历图1无向图的过程:<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271413712.png" alt="image-20221027141315660"></p></li></ul><p>1.初始状态下，无向图中的所有顶点都是没有被访问过的，一次可以任选一个顶点出发，遍历整个无向图，假设从V1顶点开始，先访问V1顶点。</p><p>2.紧邻V1的顶点有两个，分别是V2和V3，它们都没有被访问过，从它们中任选一个，这里选择V2</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271530315.png" alt="image-20221027153049261"></p><p>3.紧邻V2的顶点三个，分别是V1，V4，V5，尚未被访问的有V4，V5，从它们中任选一个，比如访问V4，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531571.png" alt="image-20221027153105528"></p><p>4.紧邻 V4 的顶点有两个，分别是 V2 和 V8，只有 V8 尚未被访问，因此访问 V8，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531449.png" alt="image-20221027153116398"></p><p>5.紧邻 V8 的顶点有两个，分别是 V4 和 V5，只有 V5 尚未被访问，因此访问 V5，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531351.png" alt="image-20221027153133306"></p><p>6.和 V5 相邻的顶点有两个，分别是 V2 和 V8，它们都已经访问过了。也就是说，此时从 V5 出发，找不到任何未被访问的顶点了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531438.png" alt="image-20221027153147389"></p><p>7.这种情况下，深度优先搜索算法会回退到之前的顶点，查看先前有没有漏掉的、尚未访问的顶点：</p><ul><li>从 V5 回退到 V8，找不到尚未访问的顶点；</li><li>从 V8 回退到 V4，还是找不到尚未访问的顶点；</li><li>从 V4 回退到 V2，也还是找不到尚未访问的顶点；</li><li>从 V2 回退到 V1，发现 V3 还没有被访问。<br>于是，下一个要访问的顶点就是 V3，如下图所示：</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271532746.png" alt="image-20221027153201697"></p><p>8.紧邻 V3 的顶点有三个，分别是 V1、V6 和 V7，尚未访问的有 V6 和 V7，因此从它们中任选一个，比如访问 V6，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271532529.png" alt="image-20221027153214477"></p><p>9.紧邻 V6 的顶点有两个，分别是 V3 和 V7，只有 V7 还没有访问，因此访问 V7，如下图所示：</p><p>10.紧邻 V7 顶点有 V6 和 V3，但它们都已经访问过了，此时面临的情况和第 6 步完全一样，深度优先搜索算法的解决方法也是一样的：</p><ul><li>从 V7 回退到 V6，依然找不到尚未访问的顶点；</li><li>从 V6 回退到 V3，依然找不到尚未访问的顶点；</li><li>从 V3 回退到 V1，依然找不到尚未访问的顶点；</li><li>V1 是遍历图的起始顶点，回退到 V1 还找不到尚未访问的顶点，意味着以 V1 顶点为突破口，能访问的顶点全部已经访问完了。这种情况下，深度优先搜索算法会从图的所有顶点中重新选择一个尚未访问的顶点，从该顶点出发查找尚未访问的其它顶点。<br>从图 9 可以看到，图中已经没有尚未访问的顶点了，此时深度优先搜索算法才执行结束。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-物理层</title>
      <link href="/2022/11/14/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2022/11/14/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><ul><li>数据：传送信息的实体，通常时有意义的符号序列</li><li>信号：数据的电气/电磁的表现，时数据传输过程中的存在形式</li><li>信源：产生和发送数据的源头</li><li>信宿：接收数据的终点</li><li>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114805.png" alt="image-20221106163817766"></li></ul><h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道</li><li>半双工通信：通信的双方都可以发送或接收消息，但任何一方都不能同时发送和接收，需要两条信道</li><li>全双工通信：通信双方可以同时发送和接收信息，也需要两条信道</li></ol><h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><ul><li>串行传输<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114004.png" alt="image-20221106165443091"></li><li>并行传输<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114090.png" alt="image-20221106165454936"></li></ul><h3 id="并口"><a href="#并口" class="headerlink" title="并口"></a>并口</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114190.png" alt="image-20221106165557385"></p><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><ol><li>指的时一个固定时长的信号波形（数字脉冲）代表不同离散数值的基本波形（码元是一个信号）</li><li>数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，该时长称为码元宽度</li><li>当码元的离散状态右M（M&gt;2）时，此时码元为M进制码元</li><li>1个码元可以携带多个比特信息量。</li></ol><ul><li>举例子：</li></ul><ol><li><p>当码元的<strong>离散状态有四种时</strong>，那么就对应了四种不同的码元<strong>00，01，11，10</strong>。每个码元都对应着自己的电平也就是<strong>数字信号。</strong></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114665.png" alt="image-20221108160327118"></p></li></ol><h3 id="速率（数据率）匹配"><a href="#速率（数据率）匹配" class="headerlink" title="速率（数据率）匹配"></a>速率（数据率）匹配</h3><ol><li>数据的传输速率，单位时间内传输的数据量</li></ol><h4 id="传输速率和传播速率的区别"><a href="#传输速率和传播速率的区别" class="headerlink" title="传输速率和传播速率的区别"></a>传输速率和传播速率的区别</h4><p>前者主要针对主机，链路开端方面的数据，即把数据发送到链路的速度。<br>后者是指数据在整个信道上，链路上传播的速度</p><h4 id="码元传输速率（波形速率，调制速率，符号速率）"><a href="#码元传输速率（波形速率，调制速率，符号速率）" class="headerlink" title="码元传输速率（波形速率，调制速率，符号速率）"></a>码元传输速率（波形速率，调制速率，符号速率）</h4><ol><li>表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud），一波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的。</li></ol><h4 id="信息传输速率（信息速率，比特率）"><a href="#信息传输速率（信息速率，比特率）" class="headerlink" title="信息传输速率（信息速率，比特率）"></a>信息传输速率（信息速率，比特率）</h4><ol><li>单位时间内数字通信系统传输的二进制码元个数（比特数），单位是比特/秒（1s传输多少比特）</li></ol><h4 id="码元传输和信息传输的关系"><a href="#码元传输和信息传输的关系" class="headerlink" title="码元传输和信息传输的关系"></a>码元传输和信息传输的关系</h4><ol><li>若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M X n bit/s。</li></ol><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><ol><li>表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”</li><li>表示网络的通信线路所能传输数据的能力。（b/s）</li></ol><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><ol><li>现实中的信道会有带宽受限以及噪音等干扰<h4 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h4></li><li>震动的速度和频率太快了，以至于接收端区别不了码元之间的清晰界限的现象。<h5 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h5></li><li>是信道能通过的最高频率和最低频率之差</li></ol><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><ol><li>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud,W是信道带宽，单位是Hz。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114527.png" alt="image-20221108164817649"></p><ol start="2"><li>码元传输当然是有上限速率的。传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能</li><li>信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。（也就是W越大）</li><li>奈氏准则给出了码元的传输速率的限制，但并没有对信息传输速率给出限制</li><li>由于码元的传输速率受奈氏准则的制约，所以提高数据的传输速率，就必须设法使每个码元携带跟多个比特的信息量，这就需要采用多元制的调制方法</li></ol><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><ol><li>噪声的随机产生会使接收端一段时间失去对码元的判断能力。</li><li>因为噪声和信号是相对的，因此引入了一个信噪比的量</li><li>信噪比=信号的平均功率/噪声的平均功率。</li></ol><ul><li>香农定理： 在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值</li></ul><ol><li>信噪比越大，极限传输速率越高</li><li>只有有传输带宽以及信噪比，就能够确定信息传输速率的上限</li><li>只要信息的传输速率低于极限值，就有可能完成无差错的传输</li><li>实际的信道传输速率会比极限值低很多<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114164.png" alt="image-20221108170535322"></li></ol><h2 id="编码和调制以及其基础知识"><a href="#编码和调制以及其基础知识" class="headerlink" title="编码和调制以及其基础知识"></a>编码和调制以及其基础知识</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><ol><li>信道：是信号的传输媒介，一般用来表示向某个方向传送信息介质。所以会包含一根发送信道和接收信道</li><li>信道又会根据传输信号和传输介质分为模拟信道（传送模拟信号）/数字信道和无线信道/有线信道<h4 id="基带信号"><a href="#基带信号" class="headerlink" title="基带信号"></a>基带信号</h4></li></ol><ul><li>将数字信号1，0采用不同的电压表示，再送到链路上。来自于信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。直接表达了要传输信息的信号（不加任何东西）</li></ul><h4 id="宽带信号"><a href="#宽带信号" class="headerlink" title="宽带信号"></a>宽带信号</h4><ul><li>将基带信号也就是01010的数字信号进行调制形成的频分复用模拟信号，再送到模拟信道上。</li><li>宽带利用的是载波调制，信号频分，把信号放在较高频段来传输。</li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101232481.png" alt="image-20221110123237415"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101131784.png" alt="image-20221110113137741"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101132385.png" alt="image-20221110113206340"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101143934.png" alt="image-20221110114311908"></p><h5 id="非归零编码【NRZ】"><a href="#非归零编码【NRZ】" class="headerlink" title="非归零编码【NRZ】"></a>非归零编码【NRZ】</h5><ol><li>高1低0,编码容易实现,但没有检错功能,而且没法判断一个码元的开始和结束.两端的难以保持同步 </li><li>需要一个信道来发送这条信号的周期和速度,以达到发送与接收同步<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101142456.png" alt="image-20221110114258427"></li></ol><h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a><strong>曼彻斯特编码</strong></h5><ol><li>前高后低为1,前低后高为0.当然也可以反着来使用</li><li>曼彻斯特能够实现<strong>自同步接收</strong>,因为它把码元分为了<strong>两个相同的间隔</strong></li><li>编码会在码元的时间中间发生跳变,来告诉接收方时钟信号,并且还能作为数据信号传输</li><li>在一个码元时间内信号变化两次也就是进行了2次脉冲</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101151216.png" alt="image-20221110115150189"></p><h5 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a><strong>差分曼彻斯特编码</strong></h5><ol><li>同1异0,简单来说就是后半段电平的下一位遇到0的话就变化,遇到1则不变</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101159529.png" alt="image-20221110115928497"></p><h5 id="归零编码【RZ】"><a href="#归零编码【RZ】" class="headerlink" title="归零编码【RZ】"></a>归零编码【RZ】</h5><ol><li>信号的电平在每一个码元后都要恢复到0的状态</li><li>需要信道来传输时钟信号</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101146390.png" alt="image-20221110114621361"></p><h5 id="反向不归零编码【NRZI】"><a href="#反向不归零编码【NRZI】" class="headerlink" title="反向不归零编码【NRZI】"></a>反向不归零编码【NRZI】</h5><ol><li>信号的电平翻转表示0,不变表示1.也就是说遇到0就翻转一次电平,遇到1就不变</li><li>需要信道来传输时钟信号</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101148118.png" alt="image-20221110114824090"></p><h5 id="4B-5B编码"><a href="#4B-5B编码" class="headerlink" title="4B/5B编码"></a>4B/5B编码</h5><ol><li>在一个比特流中插入额外的比特来打破一连串的01数据流,就是用5个比特来编码4个比特的数据,之后再传给接收方.</li><li>每个4比特的不同排序都会对应不同排序的5比特.</li><li>剩下的5比特排序会留给作为<strong>数据的控制码,<strong>也就是</strong>定界</strong>一样的作用</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101205953.png" alt="image-20221110120535909"></p><h4 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101214059.png" alt="image-20221110121407005"></p><h4 id="模拟数据编码为数字信号（举例：音频数字化）"><a href="#模拟数据编码为数字信号（举例：音频数字化）" class="headerlink" title="模拟数据编码为数字信号（举例：音频数字化）"></a>模拟数据编码为数字信号（举例：音频数字化）</h4><ol><li><p>抽样：对模拟信号周期性扫描，把时间上的连续的信号变成时间上离散的信号（定理：f<del>采样频率</del>&gt;=2f<del>信号最高频率</del>）</p></li><li><p>量化：把取得的电平幅值分级标度转化为对应的数字值，并取整数，这就把连续的电平变为离散的数字量</p></li><li><p>编码：量化结果变为二进制编码</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101222807.png" alt="image-20221110122251757"></p></li></ol><h4 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h4><ol><li>可以使用频分复用技术，充分利用带宽资源。</li><li>模拟的声音数据是加载到模拟的载波信号中进行传输。</li></ol><h2 id="传输介质及分类"><a href="#传输介质及分类" class="headerlink" title="传输介质及分类"></a>传输介质及分类</h2><ol><li>传输介质也称传输媒体/传输媒介，它是数据传输系统中在发送设备和设备之间的<strong>物理通路</strong></li><li>它是在物理层下面的并不是物理层，有时候会把传输媒体称为体系结构的第0层</li></ol><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><ol><li>需要依赖物理媒介<h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4></li></ol><ul><li>两根采用一定的规则进行并排绞合的，相互绝缘的铜导线组成。能够减少对相邻导线的电磁干扰<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141730472.png" alt="image-20221114173045429"></li></ul><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141736886.png" alt="image-20221114173620742"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141739188.png" alt="image-20221114173936067"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141740893.png" alt="image-20221114174024782"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><h4 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h4><ul><li>信号向所有方向传播</li><li>较强的穿透能力，可远距离传输，多用于手机通信</li></ul><h4 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h4><ul><li>信号固定方向传播</li><li>微波通信频率较高，频段范围宽，因此数据率很高<h5 id="卫星通信"><a href="#卫星通信" class="headerlink" title="卫星通信"></a>卫星通信</h5></li><li>通信容量大，距离远，覆盖广，广播通信和多址通信</li><li>传播时延较长，受气候影响大，误码率高，成本高</li></ul><h4 id="红外线，激光"><a href="#红外线，激光" class="headerlink" title="红外线，激光"></a>红外线，激光</h4><ul><li>信号固定方向传播</li><li>把要传输的信号分别转换为各自的信号格式，即红外信号和激光信号在空间中传播。</li></ul><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141851879.png" alt="image-20221114185153756"></p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141852692.png" alt="image-20221114185248596"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基本操作学习笔记</title>
      <link href="/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
      <url>/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库SQL"><a href="#数据库SQL" class="headerlink" title="数据库SQL"></a>数据库SQL</h1><h2 id="数据库数据定义"><a href="#数据库数据定义" class="headerlink" title="数据库数据定义"></a>数据库数据定义</h2><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n),character(n)</td><td>长度为n的定长字符串</td></tr><tr><td>varchar(n),charactervarying(n)</td><td>最大长度为n的变长字符串</td></tr><tr><td>clob</td><td>字符串大对象</td></tr><tr><td>blob</td><td>二进制大对象</td></tr><tr><td>smallint</td><td>短整数（2B）</td></tr><tr><td>int，integet</td><td>长整数（4B）</td></tr><tr><td>bigint</td><td>大整数（8B）</td></tr><tr><td>numberic(p,d)</td><td>定点数，由p位数字（不包括符号，小数点）组成，小数点后面有d位数字</td></tr><tr><td>decimal（p，d）,dec(p,d)</td><td>同上面NUMBERIC(p,d)</td></tr><tr><td>real</td><td>取决于机器精度的单精度浮点数</td></tr><tr><td>double precision</td><td>取决于机器精度的双精度点数</td></tr><tr><td>float(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr><td>boolean</td><td>逻辑布尔量</td></tr><tr><td>date</td><td>日期，包含年，月，日，格式为YYYY—MM—DD</td></tr><tr><td>time</td><td>时间，包含一日的时，分，秒，格式为HH：MM：SS</td></tr><tr><td>timestamp</td><td>时间戳类型</td></tr><tr><td>interval</td><td>时间间隔类型</td></tr></tbody></table><h3 id="大对象简介"><a href="#大对象简介" class="headerlink" title="大对象简介"></a>大对象简介</h3><p>1.用来存储大型数据，图片，视频，音乐<br>2.可用于存储二进制数据，字符数据，引用外部文件的指针的数据类型</p><ul><li><p>大对象的4种类型</p><ul><li><p>BLOB数据类型</p><ul><li>1.它是用来存储二进制数据</li><li>2.可以存储的最大数据量（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>CLOB数据类型</p><ul><li>1.存储字符数据</li><li>2.可以存储的最大数据量（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>NCLOB数据类型</p><ul><li>1.用来存储多字节字符的数据，一般用于非英文的字符</li><li>2.可以存储的最大数据量是（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>BFILE数据类型</p><ul><li><p>1.存储文件指针</p></li><li><p>2.数据文件可以存储再数据库之外，数据库存储对该文件的引用</p></li><li><p>3.其最多也可以存储4GB的数据   </p></li></ul></li></ul></li></ul><h3 id="一些重要的SQL语句"><a href="#一些重要的SQL语句" class="headerlink" title="一些重要的SQL语句"></a>一些重要的SQL语句</h3><ul><li>SELECT - 从数据库中提取数据</li><li>UPDATE - 更新数据库中的数据</li><li>DELETE - 从数据库中删除数据</li><li>INSERT INTO - 向数据库中插入新数据</li><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h2 id="SQL基本命令"><a href="#SQL基本命令" class="headerlink" title="SQL基本命令"></a>SQL基本命令</h2><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 datatype,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY( <span class="keyword">one</span> <span class="keyword">or</span> more columns )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><ul><li>select column_name, column_name from table_name</li></ul><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><ul><li>有时候一个列会包含多个重复值，有时候你也是只想列出不同的值而已</li><li>也就是只列出一个种类值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> column_name, column_name <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><ul><li>提取满足指定条件的记录</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> column_name operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><ul><li>注意：如果是搜索字符串的话，请注意内容的大小写，这不属于数据库SQL无视大小写字母的范畴</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>搜索某种模式</td></tr><tr><td>in</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h5 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h5><h6 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h6><ul><li>And与同时满足两个条件的值 ，查询表中数值范围内的值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span><span class="operator">*</span><span class="keyword">from</span> emp sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">and</span> sal <span class="operator">&lt;</span><span class="number">3000</span></span><br></pre></td></tr></table></figure><ul><li>逻辑运算的优先级</li></ul><table><thead><tr><th>（）</th><th>not</th><th>and</th><th>or</th></tr></thead></table><h6 id="特殊条件"><a href="#特殊条件" class="headerlink" title="特殊条件"></a>特殊条件</h6><ul><li>空值判断</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>查询表中的comm中的空值</p><ul><li>between and</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>查询范围内的值</p><ul><li>in</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span>(<span class="number">5000</span>,<span class="number">3000</span>,<span class="number">1500</span>)</span><br></pre></td></tr></table></figure><p>查询表中与值相同的值</p><ul><li>like</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;M%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询emp表中有M的值，上面为模糊信息</p><ul><li>%：表示多个字值，_表示一个字符</li><li>M%：为能配符，正则表达式，表示的意思是为模糊查询信息为M开头的</li><li>%M%：查询包含M的所有内容</li><li>%M_：表示查询以M在倒数第二位的所有内容<h2 id="AND-amp-OR-运算符"><a href="#AND-amp-OR-运算符" class="headerlink" title="AND &amp; OR 运算符"></a>AND &amp; OR 运算符</h2></li></ul><p>1.如果两个条件同时成立，则AND运算符显示一条记录<br>2.如果两个条件中只有一个条件成立，则OR运算符显示一条记录</p><h3 id="AND运算符实例"><a href="#AND运算符实例" class="headerlink" title="AND运算符实例"></a>AND运算符实例</h3><p>表示查询出表中名字叫fuck而且性别男的信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;fuck&#x27;</span> <span class="keyword">AND</span> sex <span class="operator">=</span> <span class="string">&#x27;man&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="OR运算符实例"><a href="#OR运算符实例" class="headerlink" title="OR运算符实例"></a>OR运算符实例</h3><p>表示查询出表中名字叫fuck或者性别男的信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;fuck&#x27;</span> <span class="keyword">OR</span> sex <span class="operator">=</span> <span class="string">&#x27;man&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ORDER-BY-关键字"><a href="#ORDER-BY-关键字" class="headerlink" title="ORDER BY 关键字"></a>ORDER BY 关键字</h2><ul><li>用于对结果集按照一个列或者多个列进行排序</li><li>默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，你可以使用DESC关键字<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>在表中查询信息并且按照升序或降序排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name,column_name <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h2>该语句用于插入新的记录</li></ul><ol><li>不用指定插入数据的列名，只需要提供被插入的信息即可<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">values</span>(value1,value2,value3,...)</span><br></pre></td></tr></table></figure></li><li>需要指明列名以及被插入的信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...)</span><br></pre></td></tr></table></figure></li><li>无需指定的多表插入<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">values</span></span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3);</span><br></pre></td></tr></table></figure><h2 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h2></li></ol><ul><li>更新表中的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">set</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">where</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> site <span class="keyword">set</span> pre <span class="operator">=</span> <span class="string">&#x27;kalyan&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101105753.png" alt="image-20221110110519707"></p><h2 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h2><p>用来删除表中的行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><h2 id="SELECT-TOP，LIMIT，ROWNUM子句"><a href="#SELECT-TOP，LIMIT，ROWNUM子句" class="headerlink" title="SELECT TOP，LIMIT，ROWNUM子句"></a>SELECT TOP，LIMIT，ROWNUM子句</h2><p>1.SELECT TOP 子句用于规定要返回的记录的数目<br>2.SELECT TOP子句对于拥有数千条记录的大型表来说，是非常有用的<br>3.需要注意的是不是所有数据库系统都支持select top语句。mysql支持limit语句来选取指定的条数数据，Oracle可以使用rownum来选取</p><ul><li>SQL server/MS Access语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top number<span class="operator">|</span><span class="keyword">percent</span> column_name(s) <span class="keyword">from</span> table_name LIMIT nember</span><br></pre></td></tr></table></figure></li><li>MySQL语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name limit number</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> persons limit <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li>Oracle语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> rownwm<span class="operator">&lt;=</span>number</span><br></pre></td></tr></table></figure></li></ul><h2 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h2><ul><li>ALTER TABLE语句使用与在已有表中添加，修改，删除列</li></ul><ol><li>添加<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">add</span> column_name datatype;</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> column_name;</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name datatype;</span><br></pre></td></tr></table></figure></li></ol><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>替代0个或多个字符</td></tr><tr><td>_</td><td>替代一个字符</td></tr><tr><td>[charlist]</td><td>字符列中的任何单一字符</td></tr><tr><td>[^charlist]或[!charlist]</td><td>不在字符列中的任何单一字符</td></tr></tbody></table><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>通过使用SQL，可以为表名称或者列名称修改成为你喜欢的名字<br>这能够让你的表格根据有阅览性</p><ul><li>列的SQL别名语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">AS</span> alians_name <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li>表的SQL别名语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">AS</span> alias_name</span><br></pre></td></tr></table></figure></li></ul><h2 id="连接-JOIN"><a href="#连接-JOIN" class="headerlink" title="连接(JOIN)"></a>连接(JOIN)</h2><ul><li><p>join用于把两个或者多个表结合起来。</p></li><li><p>下面有相关的七种用法<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101103442.png" alt="image-20221110110358365"></p></li><li><p>inner join:如果表中有至少一个匹配，则返回行</p></li><li><p>left join：即使右表中没有匹配，也从左表返回所有的行</p></li><li><p>right join：即使左表中没有匹配，也从右表返回所有的行</p></li><li><p>full join：只要其中一个表中存在匹配，则返回行</p></li></ul><h3 id="SQL连接查询"><a href="#SQL连接查询" class="headerlink" title="SQL连接查询"></a>SQL连接查询</h3><ul><li><p>连接查询是关系数据表中最主要的查询，主要包括内连接，外连接以及交叉连接</p></li><li><p>在关系数据库管理系统中，表建立时各数据之间的关系不一定需要确定，经常把一个实体的所有信息放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息</p></li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><ul><li>内连接是一种最常用的连接类型。内连接查询实际上是一种任意条件的查询。使用内连接时，如果两个表的相关字段满足连接条件，就从这两个表中提取数据并组合成新的记录，也就是在内连接查询中，只有满足条件的元组才能出现在结果关系中</li><li>指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--例如：要查询每个已经选课的学生的情况，查询语句为</span></span><br><span class="line"><span class="comment">--等值连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> S.Sno <span class="operator">=</span> SC.Sno</span><br><span class="line"><span class="comment">--实际使用中常常省略 inner join</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student,SC <span class="keyword">WHERE</span> S.Sno <span class="operator">=</span> SC.Sno</span><br><span class="line"></span><br><span class="line"><span class="comment">--自然连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> S.Sno <span class="operator">=</span> SC.Sno</span><br></pre></td></tr></table></figure><h5 id="左连接left-join"><a href="#左连接left-join" class="headerlink" title="左连接left join"></a>左连接left join</h5></li><li>即使右表中没有匹配，也从左表返回所有的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name A <span class="keyword">left</span> <span class="keyword">join</span> table_name B <span class="keyword">on</span> A.column_name <span class="operator">=</span> B.column_name; </span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> Monggo m <span class="keyword">left</span> <span class="keyword">join</span> site s <span class="keyword">on</span> s.pre <span class="operator">=</span> m.pre;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101104378.png" alt="image-20221110110450327"></p><h5 id="右连接right-join"><a href="#右连接right-join" class="headerlink" title="右连接right join"></a>右连接right join</h5><ul><li>原理同上</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><ul><li>左边表数据行全部保留，右边表保留符合连接条件的行。<br>双表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure>三表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTC</span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTC.A</span><br></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5></li><li>右边表数据行全部保留，左边表保留符合连接条件的行。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure><h5 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h5></li><li>左外连接 union 右外连接。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">FULL</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB</span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="SQL-CREATE-VIEW语句"><a href="#SQL-CREATE-VIEW语句" class="headerlink" title="SQL CREATE VIEW语句"></a>SQL CREATE VIEW语句</h3><ul><li>简化数据访问，让复杂的 SQL 语句简单化。用户只需要对视图写简单的代码就能返回需要的数据，一些复杂的逻辑放在视图中完成。</li><li>防止敏感的字段被选中，同时仍然提供对其它重要数据的访问。</li><li>可以对视图添加一些额外的索引，来提高查询的效率。</li><li>在SQL中，视图时基于SQL语句的结果集的可视化的表</li><li>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段</li></ul><h3 id="SQL-CREATE-VIEW基本格式"><a href="#SQL-CREATE-VIEW基本格式" class="headerlink" title="SQL CREATE VIEW基本格式"></a>SQL CREATE VIEW基本格式</h3><ul><li>视图显示的是最新的数据，每当用户查询视图时候，数据库引擎通过使用视图的SQL语句重建数据。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span> column1，column2....</span><br><span class="line"><span class="keyword">from</span> table_name <span class="keyword">where</span>[<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h3><ul><li><p>SQL CREATE OR REPLACE VIEW语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure></li><li><p>添加</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> [<span class="keyword">current</span> product list] <span class="keyword">AS</span> <span class="keyword">select</span> productID,productName,Category <span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> discontinued<span class="operator">=</span><span class="keyword">no</span></span><br></pre></td></tr></table></figure></li><li><p>在server上</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> [ schema_name . ] view_name [ ( <span class="keyword">column</span> [ ,...n ] ) ] </span><br><span class="line">[ <span class="keyword">WITH</span> <span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> [ ,...n ] ] </span><br><span class="line"><span class="keyword">AS</span> select_statement </span><br><span class="line">[ <span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION ] [ ; ]</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> ::<span class="operator">=</span> </span><br><span class="line">&#123; </span><br><span class="line">    [ ENCRYPTION ]</span><br><span class="line">    [ SCHEMABINDING ]</span><br><span class="line">    [ VIEW_METADATA ]     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL-基本函数-以下均用SQL-server"><a href="#SQL-基本函数-以下均用SQL-server" class="headerlink" title="SQL 基本函数(以下均用SQL server)"></a>SQL 基本函数(以下均用SQL server)</h2><h3 id="AVG（）"><a href="#AVG（）" class="headerlink" title="AVG（）"></a>AVG（）</h3><ul><li>返回数组列的平均值<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;平均值&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102731.png" alt="image-20221108094247557"></p><h3 id="COUNT（）"><a href="#COUNT（）" class="headerlink" title="COUNT（）"></a>COUNT（）</h3><ul><li><p>返回函数匹配指定条件的值得数目</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(site_id) <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&lt;</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102230.png" alt="image-20221108095113965"></p><h3 id="FIRST（）（SQL-server-TOP-1）"><a href="#FIRST（）（SQL-server-TOP-1）" class="headerlink" title="FIRST（）（SQL server/TOP 1）"></a>FIRST（）（SQL server/TOP 1）</h3><ul><li>返回指定得列中得第一个记录的值<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site  <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102449.png" alt="image-20221108100159623"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102570.png" alt="image-20221108100426725"></li></ol><h3 id="LAST（）（SQL-server-TOP-1-DESC）"><a href="#LAST（）（SQL-server-TOP-1-DESC）" class="headerlink" title="LAST（）（SQL server/TOP 1 + DESC）"></a>LAST（）（SQL server/TOP 1 + DESC）</h3><ul><li><p>返回指定列中的最后一个记录的值(找TOP 1 的倒序)</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&lt;</span><span class="number">100</span> <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102522.png" alt="image-20221108101150100"></p><h3 id="MAX（）"><a href="#MAX（）" class="headerlink" title="MAX（）"></a>MAX（）</h3><ul><li><p>返回指定列的最大值</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(column_name)<span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;最大值&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101148.png" alt="image-20221108102303157"></p><h3 id="MIN（）"><a href="#MIN（）" class="headerlink" title="MIN（）"></a>MIN（）</h3><ul><li><p>返回指定列的最小值</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MIN</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MIN</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;最小值&#x27;</span> <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101304.png" alt="image-20221108103744764"></p><h3 id="SUM（）"><a href="#SUM（）" class="headerlink" title="SUM（）"></a>SUM（）</h3><ul><li><p>返回返回数值列的总数</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例 </p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101932.png" alt="image-20221108104354535"></p><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li>语句用于结合聚合函数（以上的基本函数就是聚合函数），根据一个或多个列队结果集进行分组<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,aggregate_function(column_name) </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> site_id,<span class="built_in">sum</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site <span class="keyword">group</span> <span class="keyword">by</span> site_id;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101973.png" alt="image-20221108111402398"></p><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li>能够与聚合函数一起使用，用于筛选分组后的各组数据<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,aggregate_function(column_name) </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br><span class="line"><span class="keyword">Having</span> aggregate_function(column_name) operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> site_id,<span class="built_in">sum</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site <span class="keyword">group</span> <span class="keyword">by</span> site_id <span class="keyword">having</span>  <span class="built_in">sum</span>(count) <span class="operator">&lt;</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101257.png" alt="image-20221108112038865"></p><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><ul><li><p>判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">450</span>);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101930.png" alt="image-20221108114028592"></p><h3 id="UCASE（）-UPPER（）"><a href="#UCASE（）-UPPER（）" class="headerlink" title="UCASE（）(UPPER（）)"></a>UCASE（）(UPPER（）)</h3><ul><li><p>把字段的值转为大写</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">UPPER</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(pre) <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101226.png" alt="image-20221108121304926"></p><h3 id="LCASE（）-LOWER（）"><a href="#LCASE（）-LOWER（）" class="headerlink" title="LCASE（）/LOWER（）"></a>LCASE（）/LOWER（）</h3><ul><li><p>把字段的值转换为小写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">LOWER</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">LOWER</span>(pre) <span class="keyword">from</span> site ;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101100031.png" alt="image-20221108122014010"></p><h3 id="MID（）-并不存在SQL-Server"><a href="#MID（）-并不存在SQL-Server" class="headerlink" title="MID（）(并不存在SQL Server)"></a>MID（）(并不存在SQL Server)</h3><ul><li>用于文本字段中提取字符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> MID(column_name,statr,[,length]) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LEN（）"><a href="#LEN（）" class="headerlink" title="LEN（）"></a>LEN（）</h3><ul><li>返回文本中字段的长度<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LEN(column_name)<span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li> 实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LEN(pre) <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101100544.png" alt="image-20221108122515385"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KALI之arp欺骗</title>
      <link href="/2022/11/05/KALI%E4%B9%8Barp%E6%AC%BA%E9%AA%97/"/>
      <url>/2022/11/05/KALI%E4%B9%8Barp%E6%AC%BA%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<h1 id="KALI-arp欺骗"><a href="#KALI-arp欺骗" class="headerlink" title="KALI -arp欺骗"></a>KALI -arp欺骗</h1><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ul><li>kali linux</li><li>nmap</li><li>arpspoof</li><li>ettercap</li><li>driftnet</li></ul><h2 id="欺骗原理"><a href="#欺骗原理" class="headerlink" title="欺骗原理"></a>欺骗原理</h2><ol><li><p>ARP的全称是Address Resolution Protocol，翻译而成就是地址解析，需要注意的是这是针对以太网地址解析协议的一种攻击技术，通过欺骗局域网内访问者的PC的网关MAC地址，使访问者PC错以为攻击者的MAC地址才是网关的地址，导致被攻击者的网络不同。甚至可以修改被攻击者的数据报。</p></li><li><p>总的来说改攻击手法并不是让局域网的网络瘫痪而是直接切断所有主机的所有请求和所有该收取的响应。</p></li></ol><h2 id="个人步骤"><a href="#个人步骤" class="headerlink" title="个人步骤"></a>个人步骤</h2><ol><li>用netdiscover -p嗅探局域网内的存活的主机</li><li>一般第一步是很难达到你想要的目标，那么可以改用mrt工具，它可以直接检测目标地址的路由设备。</li><li>那么既然已经找到了路由，就可以通过路由fping自己的ip，这是用自己的ip地址来发出请求嗅探报文，如果有响应的话那么能知道局域网里面哪些ip是存活的，当然也会存在自己无法嗅探到的主机</li><li>既然确定了目标的ip就可以用arpspoof工具进行攻击</li></ol><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><ol><li>目标主机：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101050888.png" alt="image-20221105195940111"></li><li>他急了<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101050924.png" alt="image-20221105200011172"></li></ol>]]></content>
      
      
      <categories>
          
          <category> KALI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kali linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-链路层</title>
      <link href="/2022/11/05/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2022/11/05/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul><li>数据链路层在物理层提供服务的基础上向<strong>网络层提供服务</strong> </li><li>主要作用是加强物理层传输原始比特流的功能，将物理层上提供可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li></ul><h2 id="封装成帧-帧定界"><a href="#封装成帧-帧定界" class="headerlink" title="封装成帧/帧定界"></a>封装成帧/帧定界</h2><ul><li>就是在一段数据前后添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流就可以识别到比特流的开始和结束。简称为”帧定界”</li></ul><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><ul><li>接受方应当能从接收到的二进制比特流中区分出帧的起始和终止。</li><li>组帧的四种方法：1.字符计数法  2.字符填充法  3.零比特填充法  4.违规编码法</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>在链路层上你不可能知道传输的是什么样的比特组合或者什么样类型的数据</li><li>字符计数法<ul><li>帧的首部使用的是一个计数字段来标明帧内字符数</li><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101049727.png" alt="image-20221014152411083"></li><li> 每个帧上的第一个数字代表了帧内有几个字节，但凡哪一个帧第一个字节出错了，整个也就错误了</li></ul></li><li>字符填充法<ul><li>以比特组合来判别帧边界,但传送的帧最好是由文本组成（因为文本文件的字符都是由键盘输入的，都是ASCLL码）</li><li>如果传送的帧是非ASCLL码的文本文件组成时（二进制代码的程序或图像等）。就要采用字符填充的方法来实现透明传输。  </li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161553200.png" alt=" "></li></ul></li><li>零比特填充法<ul><li>  <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161555764.png" alt="image-20221016155534713">理解就可以pass，总结就是5110.</li></ul></li><li>违规编码法<ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161558795.png" alt="image-20221016155820755"></li></ul></li></ul><h2 id="差错控制（检错编码）"><a href="#差错控制（检错编码）" class="headerlink" title="差错控制（检错编码）"></a>差错控制（检错编码）</h2><h3 id="差错怎么来的"><a href="#差错怎么来的" class="headerlink" title="差错怎么来的"></a>差错怎么来的</h3><ul><li>差错总的概括可以说是因为线路本身电气特性所产生的随机噪声（热噪声），是固有的且随机存在的<h3 id="差错类型"><a href="#差错类型" class="headerlink" title="差错类型"></a>差错类型</h3><h4 id="位错"><a href="#位错" class="headerlink" title="位错"></a>位错</h4></li><li>比特位出错，1和0的变化<h4 id="帧错"><a href="#帧错" class="headerlink" title="帧错"></a>帧错</h4>现有[#1]-[#2]-[#3];</li><li>丢失：[#1]-[#3]；</li><li>重复：[#1]-[#2]-[#2]-[#3]；</li><li>失序：[#1]-[#3]-[#2]；</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>差错控制（比特位）</p><h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><ul><li>奇偶校验码（1个校验元和n-1个信息元）<ul><li>奇校验码：”1”的个数为奇数，而且错误是奇数个检验错误</li><li>偶校验码：”1”的个数为偶数 ，错误是偶数个检验错误</li></ul></li><li>CRC循环冗余码<ul><li>发送端：最终发送的数据等于要发送的数据+帧检验序列FCS</li><li>计算冗余码：1.加0   2.模2除法：数据加0后处于多项式，余数就是为冗余码FCS</li><li>发送端顺序：<ul><li>1.接受发送的数据</li><li>2.采用CRC校验</li><li>3.生成多项式</li><li>4.计算冗余码</li><li>5.把发送数据加上冗余码如”1101011011”+”1110”=”11010110111110”</li></ul></li><li>接收端顺序：<ul><li>收到的每一个帧都除以同样的除数，然后检查得到的余数R。</li><li>1.余数为0，无错，接受 2.余数不为0，有错，丢弃 <h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><h5 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h5></li></ul></li></ul></li><li>注意：海明码是能发现双比特错误，但是只能纠正单比特错误。</li><li>工作流程=确认校验码位数r+确认校验码和数据的位置+求出校验码的值+检错并纠错<h5 id="确认校验码位数r"><a href="#确认校验码位数r" class="headerlink" title="确认校验码位数r"></a>确认校验码位数r</h5></li><li>海明不等式： 2^r^&gt;=k+r+1(r为冗余信息位，k为信息位)</li><li>列子：发送数据101101。数据位是6位，那么根据公式r则最小的是4位，那么海明码的位数就需要是6+4=10位，其中的原数据是6位，校验码是4位。</li></ul><h5 id="确认校验码和数据的位置"><a href="#确认校验码和数据的位置" class="headerlink" title="确认校验码和数据的位置"></a>确认校验码和数据的位置</h5><ul><li><p>校验码只能放在2的几次方上的位置</p></li><li><p>先计算好总的数据位，然后先安排校验码的放入，最后把数据按序填满</p></li><li><p>例子：<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210170854928.png" alt="image-20221017085425891"></p></li><li><p>P类为校验码，D类为数据位</p></li><li><p>看P<del>1</del>的第一位是1，所以所有第一位为一数据位和校验码都得一起异或为0，这样就能求出P<del>1</del>的值</p></li><li><p>以此类推求出其他的P值</p></li></ul><h5 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h5><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210170924679.png" alt="s"></li><li>以上图为例子数据位是101101，则加上海明码后收到的是0010111101。</li><li>令所有要校验的位继续异或运算得出的二进制序列0101恰好对应十进制的5，所以出错的位置就是5并且改为反码<h4 id="数据链路层和物理层的数据编码的区别"><a href="#数据链路层和物理层的数据编码的区别" class="headerlink" title="数据链路层和物理层的数据编码的区别"></a>数据链路层和物理层的数据编码的区别</h4></li><li>物理层针对的是单个比特，解决传输过程中比特的同步等问题，列如曼彻斯特编码</li><li>数据链路层</li></ul><h4 id="冗余编码"><a href="#冗余编码" class="headerlink" title="冗余编码"></a>冗余编码</h4><ul><li>在数据发送之前，先按某种关系附加上一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时。相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否符合原规则，从而判断是否出错。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>较高的发送速度和较低的接受能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</li><li>数据链路层的流量控制是点对点的，而传输层是端到端的</li><li>数据链路层流量控制手段：接收方收不下就不回复确认</li><li>传输层流量控制手段：接收端给发送端一个窗口公告。</li></ul><h2 id="流量控制的方法"><a href="#流量控制的方法" class="headerlink" title="流量控制的方法"></a>流量控制的方法</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><ul><li><p>每发送一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧</p></li><li><p>发送窗口大小=1，接收窗口大小=1</p><h4 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h4></li><li><p>丢包：物理线路故障，设备故障，病毒攻击，路由信息错误等原因，会导致数据包的丢失</p><h5 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210251501765.png" alt="image-20221025150130693"></p><h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h5><h6 id="数据帧丢失或检测到帧出错"><a href="#数据帧丢失或检测到帧出错" class="headerlink" title="数据帧丢失或检测到帧出错"></a>数据帧丢失或检测到帧出错</h6></li><li><p>数据帧丢失或检测到帧出错，所有会存在一个超时计时器：每发送一个帧就启动一个计时器，但超时计时器设置的重传实践应当比帧的传输的平均RTT更长一些</p></li><li><p>发完一个帧后，必须保留它的副本。数据帧和确认帧必须编号</p></li></ul><h6 id="ACK确认帧的丢失或迟到"><a href="#ACK确认帧的丢失或迟到" class="headerlink" title="ACK确认帧的丢失或迟到"></a>ACK确认帧的丢失或迟到</h6><ul><li><p>丢失</p><ul><li>发送方在超时后，会重传数据帧</li><li>接收方会收到后会丢弃重传的数据帧，然后重新发送确认帧</li></ul></li><li><p>迟到</p><ul><li>如果发送方发了一个1号数据帧，1号确认帧却迟到到下一个2号帧发送后才被发送方接收到，这时候发送方会把1号的确认帧直接丢弃<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4></li></ul></li><li><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期地比率</p><h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3></li><li><p>发送窗口大小&gt;1，接收窗口大小=1</p></li><li><p>流水线技术，需要增加序号范围</p></li><li><p>发送方需要缓存多个分组</p><h4 id="GBN中的滑动窗口"><a href="#GBN中的滑动窗口" class="headerlink" title="GBN中的滑动窗口"></a>GBN中的滑动窗口</h4></li><li><p>发送窗口：发送方维持一组连续的允许发送的帧的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261712772.png" alt="image-20221026171201711"></p></li><li><p>接收窗口：接受方维持一组连续允许接收帧的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261712878.png" alt="image-20221026171237832"></p><h5 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h5></li><li><p>上层的调用</p><ul><li>上层要发送数据时候，需要先查看发送方的窗口是否已满，未满则生成一个帧并且发送，若已满的， 发送方会缓存数据，等窗口空闲之后发送</li></ul></li><li><p>对ACK确认帧的响应</p><ul><li>GBN协议中，对n号的确认采用的是累积确认的方式，标明接收方已经收到了n号帧和它之前的全部帧 </li><li>累积确认：如果接收方收到了3号帧的确认帧，也就是说他已经收到了0到2号的所有帧，并且发送了确认帧</li></ul></li><li><p>超时事件 </p><ul><li>来源于出现丢失或者时延过长帧时发送方的行为。也会存在一个计时器再次用户恢复数据或者确认帧丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。<h5 id="接收方需要干的b事"><a href="#接收方需要干的b事" class="headerlink" title="接收方需要干的b事"></a>接收方需要干的b事</h5></li></ul></li><li><p>正确并且按序收到n号帧，那么会发送n号确认帧，并且把数据交付于上层</p></li><li><p>只要不是按照顺序收到的帧都会丢弃掉，并且会为需要接收的序号帧发送ACK，接收方不需要做任何缓存，只需要维护信息的有序性（比如现在我要收的是1号帧，如果其他帧来了的话，一律丢弃）</p></li></ul><h5 id="滑动窗口的长度"><a href="#滑动窗口的长度" class="headerlink" title="滑动窗口的长度"></a>滑动窗口的长度</h5><ul><li>根据n个比特对帧编号，窗口尺寸应满足：1&lt;=w&lt;=2^n^-1</li></ul><h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a><strong>选择重传协议（SR）</strong></h3><ul><li>发送窗口大小&gt;1，接收窗口大小&gt;1</li><li>GBN因为有按序列的需求，所以后面本来能够传到的数据帧都得重新传输</li></ul><h4 id="选择重传的滑动窗口"><a href="#选择重传的滑动窗口" class="headerlink" title="选择重传的滑动窗口"></a>选择重传的滑动窗口</h4><ul><li>发送方：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261909294.png" alt="image-20221026190921230"></li><li>上层调用<ul><li>大致与GBN一样，收到数据后，如果没有窗口空闲，要么将数据缓存，要么就返回上层</li></ul></li><li>ACK<ul><li>如果收到了一个ACK，确认后，发送方可以将那个帧标记为已经接收。那么等到前面的序号帧确认完毕后，可以直接把窗口移到未确定的序号帧。比如我现在可以发送序号1，2，3帧，我的1号帧是未确定的，2号帧是已经确定的，3号帧是未发生的。那么等到1号帧确认完毕后，就可以直接把窗口跳到3号帧，不必再在2号帧逗留。</li></ul></li><li>超时事件<ul><li>每个帧都有自己的计时器，一个超时事件发生后只能重传一个帧 </li></ul></li></ul><ul><li>接收方：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261916895.png" alt="image-20221026191658841"></li><li>在窗口内的所有帧来者不拒<ul><li>只要接收到窗口内的帧，就直接载入缓存并且返回一个ACK确认帧，只要在窗口内的有连续的帧都已经收到后就可以将窗口移出该连续帧前进。</li><li>但是如果接收方收到了窗口以外的序号帧，第一种情况时小于窗口序号的，只要在窗口长度内的所有已确定帧再次收到传来的帧就会返回一个ACK确认帧回去。第二种情况就是大于窗口序号的，就直接不接受。 </li></ul></li></ul><h4 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h4><ul><li>发送窗口最好等于接收窗口。</li><li>当有n个比特对帧编号时候，就可有2^(n-1)^个发送窗口。</li></ul><h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><h3 id="点对点链路"><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h3><ul><li><p>两个相邻的节点通过一个链路相连，没有第三者。应用：PPP协议，常用于广域网</p><h3 id="广播式链路"><a href="#广播式链路" class="headerlink" title="广播式链路"></a>广播式链路</h3></li><li><p>应用范围比较小的局域网，通信范围比较大，所有主机共享通信介质。常用于无线局域网。</p></li><li><p>典型的拓扑结构：总线型，星型也就是逻辑总线型</p></li><li><p>分别对应下图：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021411550.png" alt="image-20221102141117479"></p><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><h4 id="静态划分信道–信道划分介质访问控制"><a href="#静态划分信道–信道划分介质访问控制" class="headerlink" title="静态划分信道–信道划分介质访问控制"></a>静态划分信道–信道划分介质访问控制</h4></li><li><p>概述：将使用介质的每个设备与来自于同一信道上的其他设备通信分隔开，把时域和频域资源合理地分配给网络上的设备</p></li><li><p>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高资源信道利用率。把一条广播信道，逻辑上分成几条用于两个节点之间通信互不干扰的子信道，实际就是把广播信道转变为点对点信道。</p><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021434326.png" alt="image-20221102143430276"></p></li><li><p>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</p></li><li><p>充分利用传输介质，系统效率较高。</p><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021441005.png" alt="image-20221102144128959"></p></li><li><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用着固定序号的时隙，所有用户轮流占用信道</p></li><li><p>举个很简单的例子：我们把<strong>TDM帧想象成一个洗澡间</strong>，现有四个人可以使用这个洗澡间洗澡，但是他们需要彼此间<strong>拿个序号</strong>分别为A，B，C，D。按照<strong>排序来轮流</strong>使用这个洗澡间。</p></li><li><p>TDM帧是在物理层传送的比特流所划分的帧，标志着一个周期。</p></li><li><p>因为大家都要轮流使用这个TDM帧，所以固定有个周期，那么某个主机需要使用信道时候，必须要等待其他三个都处于休息状态，那么信道利用率就会比较低。</p><h6 id="时分复用TDM-MAX高效率版–统计时分复用STDM"><a href="#时分复用TDM-MAX高效率版–统计时分复用STDM" class="headerlink" title="时分复用TDM MAX高效率版–统计时分复用STDM"></a>时分复用TDM MAX高效率版–统计时分复用STDM</h6></li><li><p>其实也就多了一个集中器，功能就是收集多个用户的数据一起发送到外面</p></li><li><p>注意了STDM帧并不是链路层的帧，是物理层比特流上划分的帧</p></li><li><p><strong>STDM帧中的时隙数小于连接在集中器上的用户数。</strong>用户一有数据就可以<strong>随时发往集中器中缓存</strong>，集中器再根据<strong>顺序扫描输入缓存</strong>，再放入到STDM帧中。<strong>达到了一定的时隙数就会发送一个STDM帧。</strong>当然STDM帧的时隙数并不是固定的，而是按<strong>照需求来分配时隙</strong>的，但是可以肯定地是它是会小于这个TDM帧上的用户数。</p><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h5></li><li><p>其实就是用光的频分多路复用，在一个光纤中传输多种不同地波长地光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h5></li><li><p>码分多址CDMA，1个比特分为多个码片/芯片，每个站点会制定一个唯一地m位地芯片序列。</p></li><li><p>发送1时站点发送芯片序列，发送0时则发送他的反码（通常把0写成-1）。</p></li><li><p>那么他们怎么不打架呢。多个站点同时发送数据的时候，要求各个站点芯片序列相互正交（对位相乘然后相加除以m位，等于0的话就可以一起发送）。</p></li><li><p>那么他们怎么合并呢，各路数据再信道中被线性相加（对应位置相加）</p></li><li><p>那么怎么分离呢，合并数据和源站规格化内积（对应位置相乘相加，处于总和）。</p></li></ul><h4 id="动态分配信道"><a href="#动态分配信道" class="headerlink" title="动态分配信道"></a>动态分配信道</h4><h5 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h5><h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h6><ul><li>每个局域网会有一个老大主机叫主结点，它会轮流邀请从属结点发送数据。</li><li>被邀请的主机可以选择要不要发数据，要则发不要则跳过，在老大询问主机时，其他主机均不具备发数据的能力，因为要没被邀请到。</li><li>因此它是不会发生冲突，而且还能占用全部的带宽。</li><li>1.那么就会有轮询开销，等待延迟，单点故障<h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h6></li><li>令牌：一个特殊格式的MAC控制帧，不含有任何信息。只有手持令牌的主机才能进行数据操作，能够控制信道的使用，确保同一时刻只有一个结点独占信道。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031144247.png" alt="image-20221103114405194"></p><ul><li>主机得到令牌后如果需要进行数据发送的话，那么就需要吃下令牌，并对标志位进行修改，把令牌从空闲状态转变为繁忙状态。</li><li>主机会把自己需要发送的数据和令牌结合构成一个数据帧，发送到一个目标主机处</li><li>目标主机发现<strong>数据帧（其实就是带着数据的令牌）</strong>是给自己的，那么目标主机会把数据帧copy一份缓存，然后再把数据帧发还给源主机。</li><li>源主机收到自己的数据帧后会<strong>检查是否出错</strong>，如果出错了会进行重传，没有则会回收。并把令牌空闲下来。</li><li>那么就会存在，令牌开销（令牌可能丢失），等待延迟（其他主机需要等待发送），单点故障（因处于在星型网状网络，若一个主机宕机，那么环形将受到破坏）</li></ul><h5 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h5><h6 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h6><ul><li>纯ALOHA协议<ul><li>不会监听信道，不按时间槽发送，随机重发。想发就发。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021540073.png" alt="image-20221102154037015"></li><li>冲突检测：接收方能够检测出差错，然后不确认，发送方在一定时间内收不到确认帧，那么就判定为冲突。</li></ul></li><li>时隙ALOHA协议<ul><li>把时间分为若干相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片再发送<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021558989.png" alt="image-20221102155832935"><h6 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h6></li></ul></li><li>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机再发送数据</li><li>当几个站同时再总线上发送数据时候，总线上的信号电压摆动值将会增大，当一个站检测出信号电压摆动值超过他们设定的一个门限值后，就认为总线上至少有两个站同时发送数据，表明产生了碰撞，即发生了冲突 </li><li>MA：多点接入，表示许多计算机以多点接入的方式连接再一根总线上</li><li>总的思想就是监听信道，信道空闲就发生，忙就推迟发送，<ul><li>1- 坚持CSMA思想，监听信道，一直监听到信道不忙为止，能够在第一时间发现媒体空闲，马上发送。但是如果有两个或者两个以上的站点需要发送，那么很有可能发生冲突</li><li>非坚持CSMA思想，监听信道，信道不空闲的话，会等待一个随机时间再进行监听，能够减少冲突发生的可能性。</li><li>p-坚持CSMA，监听信道，空闲则以p概率直接传输，不等待，概率1-p等到下一个时间槽再传输。忙的话等待一个随机时间再监听，减少冲突。但是，发生冲突后还是会坚持把数据帧都发送完，造成浪费。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021617521.png" alt="image-20221102161719454"><h6 id="载波监听多点接入-碰撞检测CSMA-CD"><a href="#载波监听多点接入-碰撞检测CSMA-CD" class="headerlink" title="载波监听多点接入/碰撞检测CSMA/CD"></a>载波监听多点接入/碰撞检测CSMA/CD</h6>CD:碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，一边判断自己在发送数据时其他站点是否也发送数据。<br>####### 传播时延对载波监听的影响</li></ul></li><li>单程端到端的传播时延：t<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031217333.png" alt="image-20221103121744238"></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031219305.png" alt="image-20221103121939250"></p><p>####### 截断二进制指数规避算法</p><ul><li>确定基本退避(推迟)时间为争用期2tao</li><li>定义参数k，它等于重传次数，但k不超过10，即k=min[重传次数，10]。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，k就不再增大而一直等于10。</li><li>从离散的整数集合[0，1，2<del>k</del>-1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rtao</li><li>当重传大16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li><li>如果连续多次发生冲突，表明可能有很多站参与数据交流。 </li></ul><p>####### 最小帧长问题</p><ul><li>帧的传输时延至少要两倍于信号在总线中的传播时延</li><li>最小帧长=总线传播时延 x 数据传输速率 x 2。</li><li>以太网规定最短帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧。 <h6 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h6></li><li>CA：碰撞避免，主要应用于无线局域网</li><li>发送数据前，监听信道是否空闲</li><li>空闲则发出RTS，RTS包括发射端的地址，接收端的地址，下一份数据将持续发送的时间等信息;信道忙则等待。</li><li>接收端收到RTS后，将响应CTS。</li><li>发送端收到CTS后，开始发送数据帧（同时：预约信道：发送方告知其他站点自己要用多久时间去传输）</li><li>接收端收到数据后，会用CRC来检验数据帧是否正确，正确则响应ACK帧</li><li>发送方收到ACK帧就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）</li><li>1.预约信道，2. ACK帧，3. RTS/CTS帧（可选）</li></ul><h2 id="局域网基本概念及体系结构"><a href="#局域网基本概念及体系结构" class="headerlink" title="局域网基本概念及体系结构"></a>局域网基本概念及体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><ul><li>简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</li><li>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>特点2：使用专门铺设的传输介质(双绞线，同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s)。</li><li>特点3：通信延迟时间短，误码率低，可靠性较高</li><li>特点4：各站为平等关系，共享传输信道</li><li>特点5：多采用分布式控制和广播式通信，能进行广播和组播</li><li>决定局域网的主要因素：网络拓扑，传输介质，介质访问控制方法</li></ul><h3 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031505307.png" alt="image-20221103150550233"></p><ul><li>星型拓扑：中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构形简单，建网容易，便于控制和管理。但这种网络系统，网络可靠性低，网络共享能力差，有单点故障问题。</li><li>总线型拓扑：网络可靠性高，网络节点间响应速度快，共享资源能力强，设备投入量少，成本低，安装使用方便，当某个工作站节点出现故障时，对整个网络系统影响小。 </li><li>环形拓扑：系统中通信设备和线路比较节省。有单点故障问题；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低</li><li>树型拓扑：易于拓展，易于隔离故障，也容易有单点故障。</li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><ul><li>CSMA/CD常用于总线型局域网，也用于树型网络</li><li>令牌总线常用于总线型局域网，他把总线型的各个工作站按一定顺序按接口地址大小排列成一个逻辑环 ，只有令牌持有者才能控制总线，才有发送信息的权力</li><li>令牌环，用于环形局域网，如令牌环网 </li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ol><li><p>概述：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps），快速以太网，千兆以太网和10G以太网，他们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA/CD。</p></li><li><p>令牌环网：物理上采用了星型拓扑结构</p></li><li><p>FDDI网 ：物理上采用了双拓扑结构，逻辑上是环形拓扑结构</p></li><li><p>ATM网：较新型的单元交换技术，使用53字节固定长度的单元进行交换。</p></li><li><p>无线局域网：采用IEEE 802.11标准</p></li></ol><h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><ul><li>是IEEE 802 LAN/MAN标准委员会制定的局域网，城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网，令牌环，无线局域网等。这一系列标准中的每一个子标准都有委员会的一个专门工作组负责。</li></ul><p>IEEE 802.1 ：局域网体系结构、寻址、网络互联和网络</p><p>IEEE 802.1A：概述和系统结构</p><p>IEEE 802.1B：网络管理和网络互连</p><p>IEEE 802.2 ：逻辑链路控制子层（LLC）的定义。</p><p>IEEE 802.3 ：以太网介质访问控制协议 （CSMA/CD）及物理层技术规范 [1]  。</p><p>IEEE 802.4 ：令牌总线网（Token-Bus）的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.5 ：令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。</p><p>IEEE 802.7 ：宽带技术咨询组，提供有关宽带联网的技术咨询。</p><p>IEEE 802.8 ：光纤技术咨询组，提供有关光纤联网的技术咨询。</p><p>IEEE 802.9 ：综合声音数据的局域网（IVD LAN）介质访问控制协议及物理层技术规范。</p><p>IEEE 802.10：网络安全技术咨询组，定义了网络互操作的认证和加密方法。</p><p>IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.11，1997年，原始标准（2Mbit/s，播在2.4GHz）。</p><p>IEEE 802.11a，1999年，物理层补充（54Mbit/s，播在5GHz）。</p><p>IEEE 802.11b，1999年，物理层补充（11Mbit/s播在2.4GHz）。</p><p>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</p><p>IEEE 802.11d，根据各国无线电规定做的调整。</p><p>IEEE 802.11e，对服务等级（Quality of Service, QoS）的支持。</p><p>IEEE 802.11f，基站的互连性（IAPP，Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</p><p>IEEE 802.11g，2003年，物理层补充（54Mbit/s，播在2.4GHz）。</p><p>IEEE 802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</p><p>IEEE 802.11i，2004年，无线网络的安全方面的补充。.</p><p>IEEE 802.11j，2004年，根据日本规定做的升级。</p><p>IEEE 802.11l，预留及准备不使用。</p><p>IEEE 802.11m，维护标准；互斥及极限。</p><p>IEEE 802.11n，更高传输速率的改善，基础速率提升到72.2Mbit/s，可以使用双倍带宽40MHz，此时速率提升到150Mbit/s。支持多输入多输出技术（Multi-Input Multi-Output，MIMO）。</p><p>IEEE 802.11k，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</p><p>IEEE 802.11p，这个通信协定主要用在车用电子的无线通信上。它设置上是从IEEE 802.11来扩充延伸，来符合智能型运输系统（Intelligent Transportation Systems，ITS）的相关应用。</p><p>IEEE 802.11ac，802.11n的潜在继承者,更高传输速率的改善，当使用多基站时将无线速率提高到至少1Gbps，将单信道速率提高到至少500Mbps。使用更高的无线带宽(80MHz-160MHz)(802.11n只有40MHz),更多的MIMO流(最多8条流),更好的调制方式(QAM256)。目前是草案标准(draft)，预计正式标准于2012年晚些时间推出。Quantenna公司在2011年11月15日推出了世界上第一只采用802.11ac的无线路由器。Broadcom公司于2012年1月5日也发布了它的第一支支持802.11ac的芯片。</p><p>IEEE 802.11ae-2012</p><p>IEEE 802.12 ： [1]  [2-3]  需求优先的介质访问控制协议（100VG AnyLAN）。</p><p>IEEE 802.13 ：(未使用 )【不吉利的数字，没有人愿意使用它—查自《计算机网络-Andrew S. Tanebaum》 Page 63 - 1.6.2 国际标准领域中最有影响的组织】</p><p>IEEE 802.14：采用线缆调制解调器(Cable Modem)的交互式电视介质访问控制协议及网络层技术规范。</p><p>IEEE 802.15：采用蓝牙技术的无线个人网（Wireless Personal Area Networks，WPAN）技术规范。</p><p>IEEE 802.15.1：无线个人网络。</p><p>IEEE 802.15.4：低速无线个人网络</p><p>IEEE 802.16：宽带无线连接工作组，开发2~66GHz的无线接入系统空中接口。</p><p>IEEE 802.17：弹性分组环 （Resilient Packet Ring，RPR）工作组，制定了单性分组环网访问控制协议及有关标准。</p><p>IEEE 802.18：宽带无线局域网技术咨询组（Radio Regulatory）。</p><p>IEEE 802.19：多重虚拟局域网共存（Coexistence）技术咨询组。</p><p>IEEE 802.20：移动宽带无线接入（ Mobile Broadband Wireless Access ，MBWA）工作组，制定宽带无线接入网的解决 。</p><p>IEEE 802.21：媒介独立换手（Media Independent Handover）。</p><p>IEEE 802.22： [4]  无线区域网（Wireless Regional Area Network）</p><p>IEEE 802.23：紧急服务工作组 （Emergency Service Work Group）</p><h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><ul><li><p>LLC负责识别网络层协议，然后对他们进行封装，LLC报头会告诉这个数据链路层一旦帧被接收了，应当对数据包做什么处理。为网络层提供服务：无确认无连接，面向连接，带确认无连接，高速传送。</p></li><li><p>MAC子层的主要功能包括数据帧的封装和卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性</p></li></ul><h2 id="以太网（802-3局域网）"><a href="#以太网（802-3局域网）" class="headerlink" title="以太网（802.3局域网）"></a>以太网（802.3局域网）</h2><ul><li>以太网使用CSMA/CD（载波监听多路访问及冲突检测）技术。</li><li>两个标准<ul><li>DIX Ethernet V2：第一个局域网产品规约</li><li>IEEE802.3：IEEE802委员会802.3工作组指定的第一个IEEE的以太网标准</li></ul></li></ul><h3 id="无连接，不可靠服务"><a href="#无连接，不可靠服务" class="headerlink" title="无连接，不可靠服务"></a>无连接，不可靠服务</h3><ul><li>无连接：发送方和接收方之间无“握手过程”</li><li>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</li><li>以太网只实现无差错接收，不实现可靠传输</li></ul><h3 id="以太网传输介质与拓扑结构的发展"><a href="#以太网传输介质与拓扑结构的发展" class="headerlink" title="以太网传输介质与拓扑结构的发展"></a>以太网传输介质与拓扑结构的发展</h3><ul><li>粗同轴电缆到细同周电缆到双绞线+集线器。</li><li>集线器的以太网的逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。</li><li>以太网拓扑：逻辑上总线型，物理上星型。</li></ul><h3 id="10ASE-T以太网"><a href="#10ASE-T以太网" class="headerlink" title="10ASE-T以太网"></a>10ASE-T以太网</h3><ul><li>10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE—T采用的是无屏蔽双绞线（UTP），物理上是采用星型拓扑，逻辑上总线型，每段双绞线最长为100m，用的是曼彻斯特编码</li></ul><h3 id="适配器（网卡）和MAC地址"><a href="#适配器（网卡）和MAC地址" class="headerlink" title="适配器（网卡）和MAC地址"></a>适配器（网卡）和MAC地址</h3><ul><li>计算机与外界有局域网的连接时通过通信适配器的</li><li>网络接口板，网络接口卡NIC</li><li>NOW，不再使用单独网卡</li><li>适配器上装有处理器和储存器</li><li>ROM上有计算机硬件地址MAC地址。</li><li>在局域网中，硬件地址又称为物理地址或MAC地址</li><li>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家（IEEE规定，后24位厂家自己规定，常用6个十六进制数表示）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211032141205.png" alt="image-20221103214140094"></li></ul><h3 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h3><ul><li>MAC帧最常用的是以太网V2的格式<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051442023.png" alt="image-20221105144230956"></li></ul><h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051455378.png" alt="image-20221105145531318"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051500542.png" alt="image-20221105150008469"></p><h3 id="无线局域网分类"><a href="#无线局域网分类" class="headerlink" title="无线局域网分类"></a>无线局域网分类</h3><h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051702001.png" alt="image-20221105170215891"></p><ul><li>AP<del>1</del>，AP<del>2</del>，都是这个基本服务集BSS中的一个基站</li><li>在这个基本服务集内的所有主机都可以进行数据分享</li><li>那么夸服务集交流数据的话，那么就要通过基站与基站之间交流来达到跨网传输</li></ul><h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><ul><li>各节点的地位相同，可以发送数据也可以接收数据</li><li>自己组成网络，自由度比较高</li></ul><h2 id="PPP协议和HDLC协议"><a href="#PPP协议和HDLC协议" class="headerlink" title="PPP协议和HDLC协议"></a>PPP协议和HDLC协议</h2><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><ul><li><p>通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨，几个大洲提供远距离通信，形成国际性的远程网络</p></li><li><p>通信子网主要使用分组交换技术。广域网的通信子网可以利用公网分组交换网，卫星通信网和无线分组交换网，它将分布在不同地区局域网或计算机系统互连起来，达到资源共享的目的，如因特网是世界上范围内最大的广域网。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051721183.png" alt="image-20221105172105114"></p><h3 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h3><ul><li>点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般使用PPP协议</li><li>不用需要任何纠错以及序号和流量控制</li><li>封装成帧，透明传输</li><li>多种网络层协议，封装的IP数据报可以采用多种协议</li><li>多种类型链路：串行/并行，同步/异步，电与光。</li><li>差错检测，错就丢弃</li><li>检测连接状态，链路是否能够正常工作</li><li>网络层地址协商 知道通信双方的网络层地址</li><li>数据压缩</li></ul><h4 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h4><ol><li>一个将IP数据报封装到串行链路的方法</li><li>链路控制协议LCP：建立并且维护数据链路连接，身份验证</li><li>网络层控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li></ol><h4 id="PPP协议的状态图"><a href="#PPP协议的状态图" class="headerlink" title="PPP协议的状态图"></a>PPP协议的状态图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051748583.png" alt="image-20221105174847515"></p><h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051749395.png" alt="image-20221105174951330"></p><ol><li>F/7E（十六进制）（八进制01111110）:标志字段也就是帧定界符</li><li>转义字符详细见透明传输</li><li>A:地址字段</li><li>C:控制字段</li><li>协议部分（IP数据报，LCP数据，网络控制数据）</li><li>PPP协议是面向字节的协议</li></ol><h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h4><ol><li><p>高级数据链路控制，是一个同步网上传输数据，面向比特的数据链路层协议，它是由国际化标准化组织ISO根据IBM公司的SDLC协议扩展开发而成</p></li><li><p>数据报文可以透明传输，用的是零比特插入法，能够便于硬件实现</p></li><li><p>采用的帧检验方法是CRC检验，对信息帧进行顺序编号，防止漏收或重份，传输可靠性高</p></li></ol><h4 id="HDLC站"><a href="#HDLC站" class="headerlink" title="HDLC站"></a>HDLC站</h4><ol><li>主站的主要功能是发送命令帧，接收响应帧，负责对整个链路的控制系统的初启，流程的控制，差错检测或恢复等。</li><li>从站的主要功能是接收由主站发来的命令帧，向主站发出响应帧，并且配合主站参与差错恢复等链路控制</li><li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制</li></ol><h4 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051805237.png" alt="image-20221105180545174"></p><ul><li>信息帧(I)第一位为0，用来传输数据信息，或使用捎带技术对数据进行确认</li><li>监督帧(S)10，用于流量控制和差错控制，执行对信息帧的确认，请求重发和请求暂停发送等功能</li><li>无编号帧(U)11，用于提供对链路的建立，拆除等多种控制功能。</li></ul><h4 id="PPP与HDLC协议的区别"><a href="#PPP与HDLC协议的区别" class="headerlink" title="PPP与HDLC协议的区别"></a>PPP与HDLC协议的区别</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051812956.png" alt="image-20221105181204864"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Articles in English#3</title>
      <link href="/2022/10/26/Englishwork(3)/"/>
      <url>/2022/10/26/Englishwork(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Most-Unforgettable-Person-I-Ever-Know"><a href="#The-Most-Unforgettable-Person-I-Ever-Know" class="headerlink" title="The Most Unforgettable Person I Ever Know"></a>The Most Unforgettable Person I Ever Know</h1><p>​    In my main,the most unforgettable person I ever know is Stephen William Hawking. I was touched by both his achievements and difficult stories</p><p>​    In 1963, at the age of 21, Hawking developed muscular wasting lateral sclerosis (Lou Gehrig’s disease), paralyzed, unable to speak, and had only three fingers on his hands to move. From 1979 to 2009, Lucas Professor of Mathematics, his main research areas are cosmology and black holes, proving the singularity theorem of general relativity and the area theorem of black holes, proposing the theory of black hole evaporation and the boundaryless Hawking cosmological model, and taking an important step in unifying the two basic theories of physics in the 20th century, Einstein’s theory of relativity and Planck’s quantum mechanics. He has received honors such as CH (British Honorary Lord), CBE (Commander of the Order of the British Empire), FRS (Fellow of the Royal Society), FRSA (Fellow of the Royal Society of Arts).</p><p>​      In the 21st episode of the fifth season of the hit American drama “The Big Bang Theory” broadcast on April 6, 2012, Stephen Hawking starred in a cameo. In 2017, he recorded the documentary “Exploring the New Earth” for the British BBC. [1] In November of the same year, Hawking said that technology is expected to reverse some of the harm caused by industrialization to the planet and help eradicate disease and poverty, but artificial intelligence needs to be controlled [2] , and predicted that the earth may become a “fireball” in 2600 years when energy consumption increases.</p><p>​     On March 14, 2018, Hawking passed away at the age of 76. After Hawking’s death, it caused mourning from all walks of life around the world.</p><p>​    The legend of his life is really memorable and fascinating</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇的Morris遍历</title>
      <link href="/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/"/>
      <url>/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>一种遍历二叉树的方式，并且时间复杂度O(N)，额外空间复杂度O(1)。<strong>通过利用原树中大量空闲右指针的方式，达到节省空间的目的</strong>。</li><li>Morris的本质是线索二叉树（Threaded Bianry Tree）。本质是利用二叉树中n+1个指向NULL的指针。</li><li>Morris遍历的关键<ul><li><strong>利用一棵树上大量的右指针空闲空间</strong></li></ul></li><li>Morris遍历细节<ul><li>假如现在有个当前节点cur，开始时cur再root的位置</li><li>1.如果cur没有左孩子，cur向右移动</li><li>2.如果cur有左孩子，找到左子树上最右的节点 mostRight<ul><li>a.如果mostRight.right为null，就让其指向cur，也就是mostRight.right=cur,然后cur向左移动cur=cur.left。</li><li>b.如果mostRight.right=cur,则让其指向null，然后cur向右移动cur=cur.right.</li><li>3.cur为空时遍历停止。</li></ul></li></ul></li><li>morris序<ul><li>任何结点只要有左树，都会来两次，而且是在遍历完左树后，第二次回到这个结点；如果某个结点没有左树，只会到一次。</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Morris-先序遍历"><a href="#Morris-先序遍历" class="headerlink" title="Morris 先序遍历"></a>Morris 先序遍历</h3><ul><li>思路：对于能回到自己两次的结点，在第一次到的时候就处理;对于只会到达一次的结点，就直接处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; stoge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">       TreeNode mostRight=<span class="literal">null</span>;</span><br><span class="line">       TreeNode cur=root;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> stoge;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">           mostRight=cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur)&#123;</span><br><span class="line">                   mostRight=mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                   stoge.add(cur.val);</span><br><span class="line">                   mostRight.right=cur;</span><br><span class="line">                   cur=cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   mostRight.right=<span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   stoge.add(cur.val);</span><br><span class="line">               &#125;</span><br><span class="line">               cur=cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> stoge;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Morris-中序遍历"><a href="#Morris-中序遍历" class="headerlink" title="Morris 中序遍历"></a>Morris 中序遍历</h3><ul><li>思路：对于能回到自己两次的结点，在第二次到的时候就处理；对于只会到达一次的结点就直接处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; storage = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; visit = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!visit.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">               visit.push(cur);</span><br><span class="line">               cur=cur.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               cur=visit.pop();</span><br><span class="line">               storage.add(cur.val);</span><br><span class="line">               cur=cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> storage;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Morris-后序遍历"><a href="#Morris-后序遍历" class="headerlink" title="Morris 后序遍历"></a>Morris 后序遍历</h3><ul><li>思路：把处理的时机放在能回到自己两次的结点，并且是第二次回到自己的时候，但是不打印自己，而是逆序打印自己左子树的右边界。最后，Morris遍历完后，逆序打印整棵树的右边界。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; stoge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; visit = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root,mostRight =<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> stoge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            mostRight=cur.left;</span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur)&#123;</span><br><span class="line">                    mostRight=mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right=cur;</span><br><span class="line">                    cur=cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mostRight.right=<span class="literal">null</span>;</span><br><span class="line">                    addPath(stoge,cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(stoge,root);</span><br><span class="line">        <span class="keyword">return</span> stoge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPath</span><span class="params">(List&lt;Integer&gt;stoge,TreeNode node)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            stoge.add(node.val);</span><br><span class="line">            node=node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stoge.size()-count,right = stoge.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stoge.get(left);</span><br><span class="line">            stoge.set(left,stoge.get(right));</span><br><span class="line">            stoge.set(right,temp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul><li><p>问题1：逆序打印一棵树的右边界，是不是一定得用到栈呢？？？</p><ul><li>答：其实还有一种方法，那就是链表反转。</li></ul></li><li><p>问题2：Morris遍历它的每到一个结点，都会遍历该结点左子树的右边界两次，那么它的时间复杂度还会使O(n)吗？</p><ul><li>答：所有的左子树的右边界都是不重复的，也就是说，所有结过它左子树的有边界的时间复杂度也就是整棵树的规模而已。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记-网络层</title>
      <link href="/2022/10/13/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E6%B5%85%EF%BC%89/"/>
      <url>/2022/10/13/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E6%B5%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><h2 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h2><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101048607.png" alt="image-20221009151537340" style="zoom:50%;" /></li><li>IP数据报主要格式 <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047278.png" alt="image-20221009151618409"></li><li>首先发送的是首部，首部分为固定部分以及可变部分<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047494.png" alt="image-20221009151748549"  /></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047029.png" alt="image-20221009151849391"><ul><li> 版本字段：IPv4/IPv6？</li><li> 首部长度： 单位是4B，最小为5，实际会被填充成四的倍数</li><li> 区分服务：期望获得哪种类型服务</li><li> 总长度： 首部+数据，单位是1B</li><li> 生存时间（TTL）：IP分组的保质期，经过一个路由器-1，变为0则丢弃，防止无法交付的数据报无限地兜圈子。防止消耗网络资源。</li><li>协议：数据部分的协议<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047422.png" alt="image-20221009152639531"><ul><li>TCP:面向连接的服务  </li><li>UDP：不是面向连接，不建立连接是有可能产生丢包现象的</li></ul></li><li>首部检验和：只检验首部（检验首部数据是否变化或者出错） </li><li> 源地址以及IP地址：32位</li><li> 可选字段：支持排错，测量以及安全等措施</li><li> 填充：，全0，把首部补全成4B的整数倍<h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><h3 id="MTU最大传送单元"><a href="#MTU最大传送单元" class="headerlink" title="MTU最大传送单元"></a>MTU最大传送单元</h3></li></ul></li><li>链路层数据帧可封装数据的上限<ul><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047011.png" alt="image-20221009155352562"></li></ul></li><li>以太网的MTU是1500字节</li><li>过长就会分片，不分则不传递，返回ICMP的差错报文</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047353.png" alt="image-20221009161328524"><ul><li> 标识：同一数据报的分片使用同一标识</li><li>标志：只有两位有意义<ul><li>中间位DF，DF=1（禁止分片），DF=0（允许分片）</li><li>最低位MF，MF=1（后面还有分片），MF=0（代表最后一片/没分片）（只有经过DF=0的前提下才能进行）</li></ul></li><li>片位移：指出较长分组分片后，某片在原分组中的相对位置。以8B为单位。<ul><li>离开头0字节的距离/8;  <h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2></li></ul></li></ul></li><li>全世界唯一的32位/4字节标识符</li><li>组成{&lt;网络号&gt;,&lt;主机号&gt;}</li><li>采用点分十进制 </li><li>网桥：不能分割广播域，仍然是一个局域网以及一个网络号 <h3 id="分类的地址"><a href="#分类的地址" class="headerlink" title="分类的地址"></a>分类的地址</h3><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101046452.png" alt="image-20221009163738683"><h3 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h3></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101046300.png" alt="image-20221009165513754"><h3 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h3><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045404.png" alt="image-20221009170129863"><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3></li><li>在传用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全国IP地址<h3 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a>子网划分与子网掩码</h3></li><li>分类的IP地址的弱点：</li></ul><p>1.IP地址空间的利用率有时很低<br>2.两级IP地址不够灵活</p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ul><li>三级IP地址组成<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045548.png" alt="image-20221010121507901"></li><li>某单位划分子网后，对外仍然表现为一个网络，即本单位外的网络看不见本单位内的子网的划分<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4></li><li>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045323.png" alt="image-20221010123420588">橙色的代表网络号，蓝色代表主机号</li><li>两级与三级的IP地址的子网掩码很简单，只要是网络号全是1，只要是主机号就是全0.</li><li>怎么识别发送数据报的目标IP地址：子网掩码与IP地址<strong>相与</strong>，得到的就是子网的网络地址</li></ul><h2 id="无分类编址CIDR（超网）"><a href="#无分类编址CIDR（超网）" class="headerlink" title="无分类编址CIDR（超网）"></a>无分类编址CIDR（超网）</h2><ul><li>无分类域间路由选择CIDR：<ul><li>1.消除了传统的A类，B类和C类地址以及划分子网的概念</li><li>2.CIDR记法：IP地址后加上/，然后写上网络前缀（可以任意长度）的位数</li><li>3.融合子网地址与子网掩码，方便了子网划分</li></ul></li><li>CIDR地址块<ul><li>只要网络前缀都相同的连续IP地址就同属于一个地址块 </li></ul></li><li>构成超网：将多个子网聚合成一个较大的子网或叫路由聚合<ul><li>方法：将网络前缀缩短。</li></ul></li><li>最长前缀匹配<ul><li>使用CIDR时候，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由</li><li>前缀越长，地址块越小，路由越具体</li></ul></li></ul><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><ul><li>发送数据的过程<ul><li>ARP高速缓存（IP地址与MAC地址的映射）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045967.png" alt="image-20221011144044073"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101044761.png" alt="image-20221011144024726"></li><li>除此之外还得价格目的地址的MAC地址</li><li>首先广播一个ARP请求（先封装成数据帧）<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101044249.png" alt="image-20221011144140528"><ul><li>当交换机收到广播端口，会把它从所有端口发出。</li><li>其实说白了就是MAC1地址在寻找MAC3地址的一个过程</li></ul></li><li>当目的MAC地址收到请求消息则会返回一个单播ARP响应分组<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042483.png" alt="image-20221011144437812"><ul><li>其实就是和源地址说明我在哪个位置。<br>注意：以上都是一个子网内的方法</li></ul></li></ul></li><li>如果IP1想发送分组到IP5，</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101044074.png" alt="image-20221011145058836"><ul><li>1.还是先储存源地址和目的地址的信息以及MAC1地址</li><li><ol start="2"><li>因为是一个跳网段的传输，因此首先会查询自己默认网关的目的地址。</li></ol></li><li>3.所以下一跳，一定先跳到默认网关上，也就是寻找MAC6而不是MAC5</li><li>4.所以响应分组先是由默认网关返回</li><li>然后会被封装成<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042554.png" alt="image-20221011150015189"></li><li>如上图就是说源地址与目的地址并没有变化，但物理地址缺发生了变化。</li><li>到达MAC8后再封装成<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042780.png" alt="image-20221011150307293"></li><li>继续发送ARP请求分组寻找MAC5<br>最终的总局：</li></ul></li><li>IP1 &gt; IP5(始终不变)</li><li>Mac1 &gt; Mac 6           Mac7&gt;Mac8     Mac9&gt;Mac5</li></ul><p><strong>总结：</strong></p><ul><li>由于在实际网络的链路上传送数据帧时候，最终必须使用MAC地址</li><li>ARP协议：完成主机或路由器IP地址到MAC地址的映射。</li><li>ARP协议使用过程：<ul><li>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能 收到该请求。</li><li>目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存</li><li>ARP协议4种经典情况：<ul><li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址；</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址；</li><li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址</li><li>路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。</li></ul></li></ul></li></ul><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><ul><li><p>动态主机配置协议DHCP是<strong>应用层协议</strong>，使用的是<strong>客户/服务器方式</strong>，客户端和服务端通过<strong>广播</strong>方式进行交互，基于UDP。</p></li><li><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址，子网掩码，默认网关，DNS服务器名称与IP地址，且允许地址重用，支持移动用户加入网络，支持在用地址续租。</p></li><li><p>主要流程：</p><ul><li>主机进入后会寻找DHCP服务器，广播一个DHCP发现报文</li><li>DHCP服务器广播DHCP提供报文</li><li>主机广播DHCP请求报文</li><li>DHCP服务器广播DHCP确认报文</li></ul></li></ul><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><ul><li>ICMP差错报告报文（5种）<ul><li>1.终点不可达：当路由器或者主机不能交付数据报时候就向源点发送终点不可达报文。</li><li>2.时间超过：但路由器收到生存事件TTL=0的数据报时候，除了丢弃该数据报以外，还要向源点发送事件超过报文。当终点再预先规定的时间内不能收到一个数据报全部的数据报片时，就把已经收到的数据报片都丢弃掉，并向源点发送时间超过报文。</li><li>3.参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确，就丢弃该数据报，并向源点发送参数问题报文。</li><li>4.改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发给另外的路由器（可通过更好的路由）。</li><li>5.源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率缓慢（注意：很多都已经停止使用了）</li></ul></li><li>ICMP差错报告报文数据字段<ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042268.png" alt="image-20221011160932524"></li></ul></li><li>不应该发送ICMP差错报文<ul><li>ICMP差错报告报文不再发送ICMP差错报告报文。（因为ICMP差错报告报文也是一个IP数据报）</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错数据报文</li></ul></li><li>ICMP询问报文 、<ul><li>1.回送请求和回答报文：主机或路由器向特定目的主机发送的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。（测试目的站是否可达以及了解其相关状态）</li><li>2.时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。（用来进行时钟同步和测量时间） </li></ul></li><li>ICMP应用<ul><li>PING：测试 两个主机之间的连通性，使用了ICMP回送请求和回答报文</li><li>Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul><li>IPv6数据报格式</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041253.png" alt="image-20221011200337302"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041407.png" alt="image-20221011213629483"><ul><li>优先级： 区分数据报的类别和处理优先级</li><li>流标签：“流”是互联网上从特定源点到特定终点的一系列数据报，所有属于同一个流的数据报都具有同样的流标签</li><li>有效载荷长度：（扩展首部+数据）的大小</li><li>下一个首部：标识下一个扩展首部或上层协议首部</li><li>跳数限制：类似于生存时间TT，不过依然是返回一个ICMP差错报文</li></ul></li></ul><h2 id="IPv4与IPv6区别"><a href="#IPv4与IPv6区别" class="headerlink" title="IPv4与IPv6区别"></a>IPv4与IPv6区别</h2><ul><li><p>IPv6将地址从32位扩大到128位，扩展了更大的地址空间</p></li><li><p>IPv6将IPv4的校验和字段彻底删除，以减少每跳的处理时间</p></li><li><p>加快了路由器的处理效率</p></li><li><p>IPv6支持了即插即用的自动配置，不需要了DHCP协议</p></li><li><p>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍</p></li><li><p>IPv6只能在主机处分片，IPv4可以在路由器以及主机上分片</p></li><li><p>但IPv6的分组过大就会返回一个附加报文：ICMPv6</p></li><li><p>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用</p></li><li><p>IPv6取消了协议字段，改成了下一个首部字段</p></li><li><p>IPv6取消了总长度字段，改用有效载荷长度字段</p></li><li><p>IPv6取消了服务类型字段</p></li><li><p>IPv6地址表示形式</p><ul><li>冒号十六进制记法<br> +<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041906.png" alt="image-20221011220335686"></li></ul></li><li><p>IPv6基本地址类型</p><ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul></li><li><p>IPv6向IPv4的过渡</p><ul><li>双栈协议：<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041422.png" alt="image-20221011221301471"></li><li>隧道技术： <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041985.png" alt="image-20221011221311689"></li></ul></li></ul><h2 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a>RIP协议及距离向量算法</h2><ul><li><p>路由选择协议</p><ul><li>1.内部网关协议IGP：一个AS内使用的RIP，OSPF</li><li>2.外部网关协议EGP：AS之间使用的是BGP </li><li>RIP使用的是距离向量：面对较小的网络</li><li>OSPF使用的是链路状态：面对较大的网络</li></ul></li><li><p>RIP协议</p><ul><li>是一种分布式的基于距离向量的路由选择协议。 </li><li>要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录</li></ul></li><li><p>距离（俗称跳数）</p><ul><li>从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1.</li><li>RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达</li></ul></li><li><p>RIP协议交换 </p><ul><li>仅能和相邻的路由器交换消息</li><li>路由器交换的信息是自己的路由表</li><li>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。</li><li>如果超过了180s后，没有收到邻居路由器的通告，则判定为邻居已经死了，并且更新自己的路由表</li></ul></li><li><p>收敛</p><ul><li>经过多次更新后，所有的路由器最终都会知道到达本自治体系任何一个网络的最短距离和下一跳路由器的地址</li></ul></li><li><p>距离向量算法</p><ul><li>1.对地址为X的相邻路由器发来的RIP报文。修改此报文中的所有项目：把下一跳字段中的地址改为X，并把所有的“距离”字段+1.</li><li>对修改后的RIP报文中的每一个项目，进行一下步骤：</li><li>R1路由表中没有Net3，则把该项目填入R1路由表中</li><li>R1路由表中若没有Net3，则查看下一跳的路由器地址：若下一跳是X。则用收到的项目替换路由表中的项目；若没有，原来距离比从X走的距离远则更新，否则不处理</li><li>若180s还没有收到路由器的X的更新路由表，则把X记为不可达路由器，即把距离设置为16.</li></ul></li><li><p>RIP协议的报文格式</p><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041843.png" alt="image-20221012165443308"></li></ul></li></ul><h2 id="OSPF协议以及链路状态算法"><a href="#OSPF协议以及链路状态算法" class="headerlink" title="OSPF协议以及链路状态算法"></a>OSPF协议以及链路状态算法</h2><ul><li><p>OSPF协议</p><ul><li>路由器会使用类似于广播的叫做洪泛法向自治系统内所有路由器发送信息。</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态。</li><li>只有当链路状态发生变化时候，路由器才向所有路由器洪泛发送信息。</li></ul></li><li><p>链路状态路由算法</p><ul><li>1.路由器会向邻居发送<strong>Hello问候分组</strong>，并且了解邻居节点的网络地址</li><li>2.设置它邻居的成本度量metric</li><li>3.构造一个<strong>DD数据库描述分组</strong>，向邻居给出自己的链路状态数据库中的所有链路信息</li><li>4.如果数据库里面的摘要，自己都有的话，则不会做出任何处理。如果没有的话则会请求更新发送<strong>LSR链路状态请求分组</strong>请求得到自己没有的信息</li><li>如果一个路由器收到了LSR分组以后，他会发送<strong>LSU链路状态更新分组</strong>进行更新</li><li>更新后，邻居会和你说<strong>LSAsk链路状态确认分组</strong>进行确认</li></ul></li><li><p>只要有一个路由器变化：</p><ul><li>洪泛发送<strong>LSU链路状态更新分组</strong>进行更新</li><li>更新后,其他站返回一个<strong>LSAsk链路状态确认分组</strong>进行确认</li><li>使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径</li></ul></li><li><p>OSPF分组的格式</p></li><li><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041419.png" alt="image-20221012173536847"></p><ul><li>OSPF直接使用的是IP数据报的格式传送。 </li></ul></li><li><p>特点</p><ul><li>每隔30min，刷新一次数据库的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离响亮协议RIP要好的。</li><li>OSPF协议不存在坏消息传的慢，他的收敛速度很快。</li></ul></li></ul><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><ul><li><p>BGP可以是一个AS边缘路由器</p></li><li><p>它会与其他AS的邻站BGP发言人交换信息</p></li><li><p>交换是网络可达性信息，即到达某个网络所要经过的一系列AS</p></li><li><p>发生变化时候更新有变化的部分</p></li><li><p>BGP协议报文格式</p><ul><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041196.png" alt="image-20221012213451408"></li><li> 一个BGP发言人与其他自治系统中的BGP发言人要求交换路由信息，就要建立TCP连接，即通过TCP传送，然后在此链接上交换BGP报文以建立BGP会话，利用BGP会话交换路由信息</li><li> BGP是应用层协议，借助TCP传送</li></ul></li><li><p>特点</p><ul><li>BGP支持CIDR </li><li>节省网络资源</li></ul></li><li><p>BGP-4四种报文</p><ul><li>OPEN报文：用来与相邻的另一个BGP发言人建立关系，并认证发送者</li><li>UPDATE报文：通告新路径或撤销源路径</li><li>KEEPALIVE报文：在无UPDATE时，周期性证实邻站的连通性；作为OPEN的确认</li><li>NOTIFICATION报文：报告先前报文的差错：也被用于关闭连接</li></ul></li></ul><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><ul><li>IP数据报的三种传输方式<ul><li>单播：用于发送数据包到单个目的地，且每发一份单播报文都用一个单播IP地址作为目的地址，是点对点传输方式</li><li>广播：发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式</li><li>组播：仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点的传输方式</li></ul></li><li>特点<ul><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</li><li>对组播数据报不产生ICMP差错报文。</li><li>并非所有D类地址都可以作为组播地址 </li></ul></li></ul><h2 id="IGMP网际组管理协议"><a href="#IGMP网际组管理协议" class="headerlink" title="IGMP网际组管理协议"></a>IGMP网际组管理协议</h2><ul><li>IGMP协议让路由器知道本局域网上是否有主机（的进程）参加或退出某个组播组。</li><li>1.某主机想要加入组播组时，该主机会向组播组发送一个IGMP报文，声明自己要成为改组成员本地收到IGMP报文后，利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器</li><li>2.本地组播组路由器周期查询本地局域网上的主机，清楚这些主机是否还是该组播组成员，只要有一个主机对某个分组响应，则该组播组会认定该主机是活跃的，如果没有组播路由器则认定网络上没有这个组播组的主机。因此不会再把这组的成员关系发给其他组播路由器。</li></ul><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><ul><li>相关术语<ul><li>移动结点：具有永久的IP地址的移动设备</li><li>移动IP技术：以固定的网络IP地址，实现跨越不同网段的漫游功能，并且保证了基于网络IP的网络权限在漫游过程中不发生任何改变</li><li>归属代理（本地代理）：一个移动结点拥有的“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理</li><li>外部代理（外地代理）：在外部网络中帮助移动节点完成移动管理功能得实体称为外部代理</li><li>永久地址：移动站点在归属网络中得原始地址</li><li>转交地址：移动结点在外部网络使用的临时地址</li></ul></li><li>移动IP通信过程<ul><li>A刚进入外地网络<ul><li>1.在外部代理登记获得一个转交地址，离开时候注销</li><li>2.外部代理向本地代理登记转交地址。</li></ul></li><li>B给A发送数据报<ul><li>1.本地代理截获数据报</li><li>2.本地代理再封装数据报，新的数据报目的地址是转交地址，发送给外部代理（隧道）</li><li>3.外部代理拆封数据报并发给A</li></ul></li><li>A给B发送数据报<ul><li>A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址 </li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grammarly</title>
      <link href="/2022/10/10/Grammarly/"/>
      <url>/2022/10/10/Grammarly/</url>
      
        <content type="html"><![CDATA[<h1 id="分享一个比较好用的英语文章润色工具"><a href="#分享一个比较好用的英语文章润色工具" class="headerlink" title="分享一个比较好用的英语文章润色工具"></a>分享一个比较好用的英语文章润色工具</h1><h2 id="Grammarly"><a href="#Grammarly" class="headerlink" title="Grammarly"></a>Grammarly</h2><h3 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h3><ul><li><p>打开网址<br><a href="https://www.grammarly.com/">https://www.grammarly.com/</a></p><ul><li>Grammarly有三种形式</li><li>1.可以放在手机上</li><li>2.可以下载在视窗上，无论你在哪个窗口都可以识别你的英语字段</li><li>3.网页版，把文档上传自动润色提醒<h3 id="高级版本"><a href="#高级版本" class="headerlink" title="高级版本"></a>高级版本</h3></li></ul></li><li><p>高级版可支持句子润色替换</p></li><li><p>打开网址<a href="https://www.linkstricks.com/cookies/grammarly-cookies/">https://www.linkstricks.com/cookies/grammarly-cookies/</a></p><ul><li><p>1.下载Cookie-Editor<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053924.png" alt="image-20221010100120460"></p></li><li><p>一般在Chrome应用商店能搜的到</p></li><li><p>2.下载工作语法Cookie如果一个不行换第二个</p></li></ul><p> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053069.png" alt="image-20221010100312864"></p><ul><li>3.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053196.png" alt="image-20221010100432487">右上角复制代码</li><li>4.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053371.png" alt="img">在网页右上角点cookie，点垃圾桶删除(是要进入Grammarly网页进行操作)</li><li>点击import，把刚刚复制的代码黏贴下去</li><li>6.刷新 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Articles in English#2</title>
      <link href="/2022/10/09/Englishwork%20(2)/"/>
      <url>/2022/10/09/Englishwork%20(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="Do-we-Need-Never-give-up？"><a href="#Do-we-Need-Never-give-up？" class="headerlink" title="Do we Need Never give up？"></a>Do we Need Never give up？</h1><p>Quite a few people think that Never giving up is the attitude of life, But is this really the case? I encounter many citizens who use them as an excuse, though they stay on this path and make a great contribution. But practically, they cannot profit    anything. Not only wasting their time ,but also paying out their energy.</p><p>In our dailylife, we can find something which we want to pay more attention to it.But we need to contrast habits and work. This thing you love may only be what you need for a while. When enthusiasm subsides,you will find it not your love things. So,The reality is harsh, you must ensure you have some gifts in what you want to do.</p><p>Life is hard to avoid, you must try doing something again and again. Utill you seek you can stand on it firmly. It means that you need to relinquish something and pick something back. Fail is not lose face, when you hit a wall that you really cannot get over,you have to stop and look elsewhere.</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="/2022/10/08/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2022/10/08/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p><strong>应用层协议：每个应用层协议都是为了解决一类应用问题，而解决问题需要通过位于不同主机的多个应用进程之间的通信和协同来完成，应用层的具体内容就是定义这些通信规则</strong></p></li><li><p>**应用层的具体内容就是规定应用进程在通讯时候所遵循的协议</p><ul><li><strong>客户/服务器（C/S，Client/Server）方式</strong></li><li>**对等（P2P，Peer to Peer）方式</li></ul></li></ul><h3 id="应用进程"><a href="#应用进程" class="headerlink" title="应用进程"></a>应用进程</h3><p>   <strong>为解决具体应用问题而彼此通信的进程</strong></p><hr><h2 id="应用进程的通讯方式"><a href="#应用进程的通讯方式" class="headerlink" title="应用进程的通讯方式"></a>应用进程的通讯方式</h2><h3 id="①客户-服务器（C-S-Client-Server）方式"><a href="#①客户-服务器（C-S-Client-Server）方式" class="headerlink" title="①客户/服务器（C/S, Client/Server）方式"></a><strong>①客户/服务器（C/S, Client/Server）方式</strong></h3><ul><li><strong>应用层的许多协议是基于C/S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端</strong><ul><li><strong>客户(client)和服务器(server)是指通信中所涉及的2个应用进程</strong></li><li><strong>客户/服务器方式描述的是应用进程之间服务和被服务的关系</strong></li><li><strong>客户是服务请求方（主动请求服务，被服务</strong></li><li><strong>服务器是服务提供方（被动接受服务请求，提供服务）</strong></li></ul></li><li><strong>C/S方式可以是面向连接的，也可以是无连接的</strong></li><li><strong>面向连接时，C/S通信关系一旦建立，通信就是双向的，双方地位平等，都可发送和接收数据</strong></li></ul><h4 id="客户进程的特点"><a href="#客户进程的特点" class="headerlink" title="客户进程的特点"></a>客户进程的特点</h4><ul><li>在进行通信时临时成为客户，它也可以在本地进行其他的计算</li><li>用户计算机上运行，在打算通信时主动向远地服务器发起通信</li><li><strong>客户方必须知道服务器所在的主机的IP地址才能发出服务请求</strong></li><li>需要时可以与多个服务器进行通信</li></ul><h4 id="服务器进程的特点"><a href="#服务器进程的特点" class="headerlink" title="服务器进程的特点"></a>服务器进程的特点</h4><ul><li>专门用来提供某种服务的程序，可同时处理多个远地和本地客户的请求</li><li><strong>必须始终处于运行状态才有可能提供服务</strong></li><li>通信开始之前服务器进程不需要知道客户进程所在的IP地址，无论客户请求来自哪里，服务器进程被动等待服务请求的到来即可</li><li>通常是当系统启动时即自动调用并一直运行着。某些服务器程序也可以由用户或其他的进程在通信前启动</li><li>被动等待并接受来自多个客户的通信请求</li></ul><h3 id="②对等（P2P，Peer-to-Peer）方式"><a href="#②对等（P2P，Peer-to-Peer）方式" class="headerlink" title="②对等（P2P，Peer to Peer）方式"></a><strong>②对等（P2P，Peer to Peer）方式</strong></h3><ul><li>对等方式是指两个进程在通讯时并不区分服务的请求方和服务的提供方。<ul><li>只要两个主机都运行P2P软件，那么就可以进行平等，对等的通信。</li><li>如果权限允许的话，双方都可以下载彼此存储在硬盘中的共享文件。</li></ul></li><li>音频以及视频应用推动了P2P的对等通信方式的发展（BitTorrent）。</li><li>音频以及视频流量已经是占主要比。</li><li>P2P方式从本质上看仍然是使用了C/S方式，但强调的是通信过程中的对等，<strong>这时每一个P2P进程是客户的同时也是服务器</strong>。</li></ul><h2 id="服务器进程-工作方式"><a href="#服务器进程-工作方式" class="headerlink" title="服务器进程 工作方式"></a>服务器进程 工作方式</h2><ul><li>循环方式(iterative mode)<ul><li>一次只运行一个服务器</li><li>当有多个客户进程请求服务时,服务进程就会按照请求的先后顺序来依次做出响应**(阻塞方式)**</li><li>并发方式(concurrent mode)</li><li>可以同时运行多个服务器进程,</li><li>每个服务器进程都对某个特定的客户进程进行响应(非阻塞方式)</li></ul></li><li>无连接循环方式服务<ul><li>使用无连接的UDP服务进程通常都工作在循环方式,即一个服务器进程在同一时间只能向一个客户进程提供服务.(顺序服务)</li><li>服务器进程收到客户进程的请求后,会发送UDP用户数据报响应该客户</li><li>对其他客户进程发送的请求则暂时不予理睬,这些请求都在服务端的队列中排队等候服务进程的处理</li><li>当服务进程处理完一个请求时,会从队列中读取来自下一个客户进程的请求,然后继续处理 </li></ul></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702104216597.png" alt="图1.1"></p><ul><li><strong>面向链接的并发方式服务</strong><ul><li>面向连接的<strong>TCP服务进程</strong>通常都在工作在并发服务方式,服务进程可在同一时间同时向多个客户进程提供服务(<strong>并发服务</strong>)</li><li>在TCP服务进程与多个客户进程之间必须建立多条TCP连接,每条TCP连接在其数据传送完毕后释放</li><li>一个TCP连接对应一个(熟知)服务端口</li><li>主服务进程在熟知端口等待客户进程发送请求,一旦接受到客户进程的请求,就会创建一个从属服务进程,并指明从属服务进程使用临时的套接字与该客户建立TCP连接,然后主服务进程会继续在熟知端口等待其他客户进程的请求.</li></ul></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702104304442.png" alt="在这里插入图片描述"></p><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>域名系统：</strong>是互联网使用的命名系统，用来便于人们使用的机器名字转换为IP地址<br>许多应用层软件进程使用域名系统DNS，但是计算机的用户只是间接而不是直接使用DNS。<br>互联网采取层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS。DNS使大多数的名字放在本地分析，仅留下少量的解析需要互联网上通信。</p><h3 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a><strong>域名的解析过程</strong></h3><p>首先是把主机名字<strong>解析成为IP地址</strong>，然后应用进程会调用解析程序，并且<strong>成为DNS的一名客户</strong>，把待解析的域名放在DNS的请求报告中，<strong>以UDP用户数据报方式</strong>发给本地域名服务器，本地域名服务器在查找域名后，会<strong>把IP地址</strong>放在回答报文中<strong>返回</strong>，应用进程<strong>获得</strong>目的主机的<strong>IP地址</strong>后即<strong>可通信</strong>。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/2021070210481257.png" alt="在这里插入图片描述"></p><hr><h4 id="域名的递归查询"><a href="#域名的递归查询" class="headerlink" title="域名的递归查询"></a><strong>域名的递归查询</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702105147777.png" alt="在这里插入图片描述"></p><hr><h4 id="域名的迭代查询"><a href="#域名的迭代查询" class="headerlink" title="域名的迭代查询"></a><strong>域名的迭代查询</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702105303958.png" alt="在这里插入图片描述"></p><h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><ul><li>互联网是采取层次结构的命名方法</li><li>任何一个连接在互联网的主机或路由器都有一个唯一的层次结构名字，即域名。</li><li>域时名字空间中可以被管理的划分，域还可以被划分成子域，而子域还能继续划分</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702104833729.png" alt="在这里插入图片描述"></p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议"><a href="#简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议" class="headerlink" title="简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议"></a>简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议</h3><ul><li>最终交付(邮件访问)<br> +第三版邮局协议 POP3<ul><li>Internet邮件访问协议 IMAP</li><li>基于Web的电子邮件 Webmail（HTTP）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702105700634.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="Webmail"><a href="#Webmail" class="headerlink" title="Webmail"></a>Webmail</h3><ul><li>提供电子邮件服务的IMAP和SMTP替代方案</li><li>使用Web作为界面，用户代理就是普通的浏览器</li><li>用户以及其远程邮件之间的通信通过HTTP进行</li></ul><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><h3 id="HTTP服务器与客户端"><a href="#HTTP服务器与客户端" class="headerlink" title="HTTP服务器与客户端"></a>HTTP服务器与客户端</h3><ul><li><p>服务器</p><ul><li>Web页面（HTML文档）：包含多种对象或者连接</li><li>Web对象（包含：静态对象以及动态对象）：可以是HTML文档，视频文件，音频文件，图像文件以及脚本文件等</li><li>对象用URL（统一资源定位符）编址：协议类型：//主机名：端口//路径和文件名</li></ul></li><li><p>客户端</p><ul><li>发出请求，接收响应，解析HTML文档并显示</li><li>有些对象需要浏览器安装插件</li><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702110058685.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="www协议"><a href="#www协议" class="headerlink" title="www协议"></a>www协议</h3><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702110204885.png" alt="在这里插入图片描述"></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>超文本传输协议HTTP在传输层通常使用TCP协议，缺省使用TCP的80端口</li><li>HTTP为无状态协议：服务器端不保留之前请求的状态信息<ul><li>无状态协议：效率低，但简单</li><li>有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出翔故障时，需要保持状态的一致性等。</li></ul></li></ul><h2 id="Web安全隐私：Cookie"><a href="#Web安全隐私：Cookie" class="headerlink" title="Web安全隐私：Cookie"></a>Web安全隐私：Cookie</h2><p>HTTP无状态协议，服务器用cookies保持用户状态</p><ul><li>HTTP在响应的首部行里面使用一个关键字Set-cookie：选择的cookie号具有唯一性</li><li>后继的HTTP请求中使用服务器响应分配的cookie</li><li>Cookie文件保存在用户的主机之中，内容是服务器返回的附加消息，由用户的主机的浏览器管理</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702111728805.png" alt="在这里插入图片描述"></li></ul><h2 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul><li>流媒体概念<ul><li>连续媒体（音视频）经压缩编码，数据打包后，经过网络发送给接收方</li><li>接受方对数据进行重组，解码和播放</li></ul></li><li>流媒体的特性<ul><li>端到端时延约束</li><li>时序性约束：流媒体数据必须按照一定的顺序连续播放</li><li>具有一定程度的容错性：丢失部分数据包也可以完成基本功能</li></ul></li><li>流媒体面临的挑战<ul><li>网络特性（宽带有限，动态变化，延迟与抖动，丢失，异构性）</li><li>目标：流媒体服务质量要素（画质，启动延迟，平滑，交互性）</li></ul></li></ul><h3 id="流媒体动态自适应传输"><a href="#流媒体动态自适应传输" class="headerlink" title="流媒体动态自适应传输"></a>流媒体动态自适应传输</h3><ul><li>DASH<ul><li>动态自适应流媒体协议DASH，由MPEG组织制定的标准</li><li>类似协议：苹果HTTP Live Streaming；Adobe的HTTP Dynamic Streaming,微软的Microsoft Smooth Streaming</li></ul></li><li>基本思想<ul><li>完整视频被拆分为固定时长的视频片段，每段提供不同码率</li><li>视频片段与其对应的元文件（URL）一同存放于DASH服务器</li><li>客户端基于网络条件，缓冲大小等，对每个视频片段，自适应选择合适的视频码率来下载</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Articles in English#1</title>
      <link href="/2022/10/08/Englishwork/"/>
      <url>/2022/10/08/Englishwork/</url>
      
        <content type="html"><![CDATA[<h1 id="How-to-balance-work-and-leisure"><a href="#How-to-balance-work-and-leisure" class="headerlink" title="How to balance work and leisure"></a>How to balance work and leisure</h1><p>Currently, quite a few citizens will choose to take their hearts into work and learning because they are increasingly competitive in society. As a consequence, more people will make themselves more knowledgeable. It can enrich the quality of life.</p><p>But sometimes, you should get a good balance of work and leisure. It can make your life more comfortable and efficient. Somebody thinks it better work time less than 6 hours. And then the brain enters a state of exhaustion.</p><p>But how do you kill the rest of the time? You can do the best sports you like, or read a book quietly with soothing music. In addition, you can raise a pet to accompany you. In a word, doing something that can make you happy. Someone found a very novel method which calls the Pomodoro technique. It can improve your focus during one working time.</p><p>Hold the view that the best method to balance work and leisure. It depends on your mind. Somebody will consider the work is regarded as a pleasure. So they tend to enjoy it. The most important is what attitude you keep. Suppose you maintain an active mind. You will have inexhaustible power.</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
