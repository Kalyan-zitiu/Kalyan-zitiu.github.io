<!DOCTYPE html><html lang="zh-TW" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CKA基础预览 | Kalyan的小书房</title><meta name="keywords" content="K8s"><meta name="author" content="Kalyan,3148862192@qq.com"><meta name="copyright" content="Kalyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="K8s ad">
<meta property="og:type" content="article">
<meta property="og:title" content="CKA基础预览">
<meta property="og:url" content="https://kalyan-zitiu.github.io/2023/11/30/K8s/index.html">
<meta property="og:site_name" content="Kalyan的小书房">
<meta property="og:description" content="K8s ad">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://kalyan-zitiu.github.io/img/WallPaper%20(53).jpg">
<meta property="article:published_time" content="2023-11-30T07:00:00.000Z">
<meta property="article:modified_time" content="2023-12-01T01:48:06.864Z">
<meta property="article:author" content="Kalyan">
<meta property="article:tag" content="K8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kalyan-zitiu.github.io/img/WallPaper%20(53).jpg"><link rel="shortcut icon" href="/img/%E9%A1%B6%E9%83%A8%E6%A0%87%E7%AD%BE(2).jpg"><link rel="canonical" href="https://kalyan-zitiu.github.io/2023/11/30/K8s/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CKA基础预览',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 09:48:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Kalyan的小书房" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">34</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/WallPaper%20(53).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kalyan的小书房</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CKA基础预览</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2023-11-30T07:00:00.000Z" title="發表於 2023-11-30 15:00:00">2023-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2023-12-01T01:48:06.864Z" title="更新於 2023-12-01 09:48:06">2023-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Basic/">Basic</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Basic/Study-Note/">Study Note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CKA基础预览"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="CKA"><a href="#CKA" class="headerlink" title="CKA"></a>CKA</h1><h2 id="集群架构，安装和配置（25-）"><a href="#集群架构，安装和配置（25-）" class="headerlink" title="集群架构，安装和配置（25%）"></a>集群架构，安装和配置（25%）</h2><h3 id="管理基于角色的访问控制（RBAC）"><a href="#管理基于角色的访问控制（RBAC）" class="headerlink" title="管理基于角色的访问控制（RBAC）"></a>管理基于角色的访问控制（RBAC）</h3><p>Kubernetes（K8s）的基于角色的访问控制（RBAC）是一种用于管理对Kubernetes资源的访问权限的机制。它通过定义角色（Roles）和集群角色（ClusterRoles）来管理用户和进程的权限。</p>
<h4 id="1-角色（Role）和集群角色（ClusterRole）"><a href="#1-角色（Role）和集群角色（ClusterRole）" class="headerlink" title="1. 角色（Role）和集群角色（ClusterRole）"></a>1. 角色（Role）和集群角色（ClusterRole）</h4><ul>
<li><strong>角色（Role）</strong>：在命名空间内定义了一组权限。它指定了在该命名空间内可以执行的操作，比如读取Pod或创建Deployment。</li>
<li><strong>集群角色（ClusterRole）</strong>：在整个集群范围内定义了一组权限。它用于需要跨多个命名空间访问的资源，比如节点（Nodes）。</li>
</ul>
<h4 id="2-角色绑定（RoleBinding）和集群角色绑定（ClusterRoleBinding）"><a href="#2-角色绑定（RoleBinding）和集群角色绑定（ClusterRoleBinding）" class="headerlink" title="2. 角色绑定（RoleBinding）和集群角色绑定（ClusterRoleBinding）"></a>2. 角色绑定（RoleBinding）和集群角色绑定（ClusterRoleBinding）</h4><ul>
<li><strong>角色绑定（RoleBinding）</strong>：将角色的权限分配给用户、组或服务账户。它只在角色所在的命名空间内有效。</li>
<li><strong>集群角色绑定（ClusterRoleBinding）</strong>：将集群角色的权限分配给用户、组或服务账户，但这些权限在整个集群范围内都有效。</li>
</ul>
<h4 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h4><h5 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这个角色名为<code>pod-reader</code>，它允许用户在默认命名空间内对Pod执行读取（get）、观察（watch）和列出（list）操作。</p>
<h5 id="创建角色绑定"><a href="#创建角色绑定" class="headerlink" title="创建角色绑定"></a>创建角色绑定</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>这个角色绑定将<code>pod-reader</code>角色分配给用户Jane。</p>
<h5 id="创建集群角色"><a href="#创建集群角色" class="headerlink" title="创建集群角色"></a>创建集群角色</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># &quot;name&quot; is the name of the ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这个集群角色名为<code>secret-reader</code>，它允许用户对整个集群的Secrets执行读取（get）、观察（watch）和列出（list）操作。</p>
<h5 id="创建集群角色绑定"><a href="#创建集群角色绑定" class="headerlink" title="创建集群角色绑定"></a>创建集群角色绑定</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>这个集群角色绑定将<code>secret-reader</code>角色分配给用户Jane，使她能在整个集群中读取Secrets。</p>
<h3 id="使用Kubeadm安装基本集群"><a href="#使用Kubeadm安装基本集群" class="headerlink" title="使用Kubeadm安装基本集群"></a>使用Kubeadm安装基本集群</h3><p>Kubernetes 的安装和配置可以通过多种方式进行，其中一种流行的方法是使用 Kubeadm。Kubeadm 是一个工具，用于快速搭建 Kubernetes 集群。</p>
<h4 id="1-Kubeadm-安装概览"><a href="#1-Kubeadm-安装概览" class="headerlink" title="1. Kubeadm 安装概览"></a>1. Kubeadm 安装概览</h4><ul>
<li><strong>预先条件</strong>：需要在所有机器上安装 Docker 或其他容器运行时，以及 kubeadm、kubelet 和 kubectl。确保网络配置允许各节点间的相互通信。</li>
<li><strong>初始化主节点</strong>：使用 kubeadm 初始化 Kubernetes 主节点。</li>
<li><strong>加入工作节点</strong>：将工作节点添加到集群中。</li>
<li><strong>部署 Pod 网络</strong>：在集群中安装 Pod 网络插件。</li>
</ul>
<h4 id="2-步骤详解"><a href="#2-步骤详解" class="headerlink" title="2. 步骤详解"></a>2. 步骤详解</h4><h5 id="步骤-1-安装-Docker-和-Kubeadm"><a href="#步骤-1-安装-Docker-和-Kubeadm" class="headerlink" title="步骤 1: 安装 Docker 和 Kubeadm"></a>步骤 1: 安装 Docker 和 Kubeadm</h5><p>在所有节点上安装 Docker 和 Kubeadm。安装方法取决于操作系统，例如在基于 Debian 的系统上，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y docker.io</span><br><span class="line">sudo apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="string">deb https://apt.kubernetes.io/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<h5 id="步骤-2-初始化主节点"><a href="#步骤-2-初始化主节点" class="headerlink" title="步骤 2: 初始化主节点"></a>步骤 2: 初始化主节点</h5><p>在主节点上运行 kubeadm init 命令。这将初始化 Kubernetes 控制平面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init</span><br></pre></td></tr></table></figure>

<p>初始化完成后，按照命令行提示设置 kubectl 访问：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h5 id="步骤-3-安装-Pod-网络"><a href="#步骤-3-安装-Pod-网络" class="headerlink" title="步骤 3: 安装 Pod 网络"></a>步骤 3: 安装 Pod 网络</h5><p>在主节点上安装 Pod 网络插件。例如，使用 Calico：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>

<h5 id="步骤-4-将工作节点加入集群"><a href="#步骤-4-将工作节点加入集群" class="headerlink" title="步骤 4: 将工作节点加入集群"></a>步骤 4: 将工作节点加入集群</h5><p>在每个工作节点上运行 kubeadm join 命令。这个命令会在 <code>kubeadm init</code> 输出中给出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm <span class="built_in">join</span> [your unique string from the kubeadm init output]</span><br></pre></td></tr></table></figure>

<h4 id="3-验证集群状态"><a href="#3-验证集群状态" class="headerlink" title="3. 验证集群状态"></a>3. 验证集群状态</h4><p>一旦所有节点都加入了集群，您可以在主节点上运行以下命令来验证集群状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>这将列出所有节点和它们的状态，确保它们都是“Ready”状态。</p>
<h3 id="管理高可用性的Kubernetes集群"><a href="#管理高可用性的Kubernetes集群" class="headerlink" title="管理高可用性的Kubernetes集群"></a>管理高可用性的Kubernetes集群</h3><p>在 Kubernetes 中，创建一个高可用性（High Availability, HA）的集群意味着确保集群的关键组件在发生故障时能够持续运行。这通常涉及到多个主节点的设置，以及对网络和存储的适当配置。</p>
<h4 id="Kubernetes-高可用性集群关键点"><a href="#Kubernetes-高可用性集群关键点" class="headerlink" title="Kubernetes 高可用性集群关键点"></a>Kubernetes 高可用性集群关键点</h4><ol>
<li><strong>多个主节点</strong>：至少需要三个主节点来保证控制平面的高可用性。</li>
<li><strong>负载均衡器</strong>：前端负载均衡器用于分发流量到不同的主节点。</li>
<li><strong>数据存储的高可用性</strong>：etcd，作为 Kubernetes 的数据存储，需要配置为高可用模式。</li>
<li><strong>网络</strong>：确保所有节点之间的网络连接稳定。</li>
<li><strong>故障转移和恢复</strong>：自动或手动处理节点故障。</li>
</ol>
<h4 id="实际操作步骤"><a href="#实际操作步骤" class="headerlink" title="实际操作步骤"></a>实际操作步骤</h4><h5 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h5><ul>
<li><strong>节点要求</strong>：至少需要三个主节点，和一个或多个工作节点。</li>
<li><strong>网络和存储</strong>：确保所有节点之间网络互通，以及etcd数据存储的高可用性配置。</li>
</ul>
<h5 id="2-安装-Kubernetes-和-etcd"><a href="#2-安装-Kubernetes-和-etcd" class="headerlink" title="2. 安装 Kubernetes 和 etcd"></a>2. 安装 Kubernetes 和 etcd</h5><p>在所有节点上安装 Docker、kubelet、kubeadm 和 kubectl。对于 etcd，可以使用 kubeadm 或单独安装。</p>
<h5 id="3-设置负载均衡器"><a href="#3-设置负载均衡器" class="headerlink" title="3. 设置负载均衡器"></a>3. 设置负载均衡器</h5><p>在主节点之前设置一个外部负载均衡器。它将 API Server 的请求分发给所有的主节点。</p>
<h5 id="4-初始化第一个主节点"><a href="#4-初始化第一个主节点" class="headerlink" title="4. 初始化第一个主节点"></a>4. 初始化第一个主节点</h5><p>在第一个主节点上执行 <code>kubeadm init</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --control-plane-endpoint <span class="string">&quot;LOAD_BALANCER_DNS:LOAD_BALANCER_PORT&quot;</span> --upload-certs</span><br></pre></td></tr></table></figure>

<p>这里的 <code>LOAD_BALANCER_DNS</code> 和 <code>LOAD_BALANCER_PORT</code> 是负载均衡器的地址和端口。</p>
<h5 id="5-加入其他主节点"><a href="#5-加入其他主节点" class="headerlink" title="5. 加入其他主节点"></a>5. 加入其他主节点</h5><p>使用在初始化第一个主节点时生成的命令和证书密钥，将其他主节点加入集群。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> LOAD_BALANCER_DNS:LOAD_BALANCER_PORT --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;<span class="built_in">hash</span>&gt; --control-plane --certificate-key &lt;certificate-key&gt;</span><br></pre></td></tr></table></figure>

<h5 id="6-加入工作节点"><a href="#6-加入工作节点" class="headerlink" title="6. 加入工作节点"></a>6. 加入工作节点</h5><p>工作节点加入集群的步骤与单主节点集群相同，使用 <code>kubeadm join</code> 命令。</p>
<h5 id="7-验证和测试"><a href="#7-验证和测试" class="headerlink" title="7. 验证和测试"></a>7. 验证和测试</h5><p>验证集群状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>进行故障转移测试，例如关闭一个主节点，看是否还能正常访问 Kubernetes API。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>确保负载均衡器的配置正确，它是高可用集群的关键组件。</li>
<li>etcd 的高可用配置同样重要，它可以在 Kubernetes 集群内部或独立运行。</li>
<li>监控和日志记录对于维护高可用性集群至关重要。</li>
<li>为了确保数据一致性和网络稳定性，最好将主节点分布在不同的物理服务器或云区域上。</li>
</ul>
<h3 id="设置基础架构以部署Kubernetes集群"><a href="#设置基础架构以部署Kubernetes集群" class="headerlink" title="设置基础架构以部署Kubernetes集群"></a>设置基础架构以部署Kubernetes集群</h3><p>要在基础架构上部署 Kubernetes 集群，您需要关注几个关键方面，包括硬件资源、网络配置、操作系统的选择和设置、以及 Kubernetes 组件的安装和配置。</p>
<h4 id="1-硬件资源"><a href="#1-硬件资源" class="headerlink" title="1. 硬件资源"></a>1. 硬件资源</h4><h5 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h5><ul>
<li><strong>CPU</strong>: 至少 2 核。</li>
<li><strong>内存</strong>: 至少 2 GB。</li>
<li><strong>存储</strong>: 依赖于应用需求。</li>
</ul>
<h5 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h5><ul>
<li><strong>CPU</strong>: 取决于应用负载。</li>
<li><strong>内存</strong>: 取决于应用负载。</li>
<li><strong>存储</strong>: 取决于应用负载。</li>
</ul>
<h4 id="2-网络配置"><a href="#2-网络配置" class="headerlink" title="2. 网络配置"></a>2. 网络配置</h4><ul>
<li>确保所有节点之间的网络互通。</li>
<li>规划 Pod 网络和服务网络的 CIDR 块，以避免与现有网络冲突。</li>
</ul>
<h4 id="3-操作系统和环境设置"><a href="#3-操作系统和环境设置" class="headerlink" title="3. 操作系统和环境设置"></a>3. 操作系统和环境设置</h4><ul>
<li>选择一个兼容 Kubernetes 的操作系统（例如 Ubuntu、CentOS 等）。</li>
<li>确保所有节点的系统时间同步。</li>
<li>安装和配置容器运行时（如 Docker）。</li>
<li>禁用交换分区（swap）。</li>
</ul>
<h4 id="4-安装-Kubernetes-组件"><a href="#4-安装-Kubernetes-组件" class="headerlink" title="4. 安装 Kubernetes 组件"></a>4. 安装 Kubernetes 组件</h4><ul>
<li>安装 <code>kubeadm</code>、<code>kubectl</code> 和 <code>kubelet</code>。</li>
</ul>
<h5 id="示例代码（以-Ubuntu-为例）"><a href="#示例代码（以-Ubuntu-为例）" class="headerlink" title="示例代码（以 Ubuntu 为例）:"></a>示例代码（以 Ubuntu 为例）:</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">sudo apt-get install -y docker.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Docker 开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用 Swap</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line">sudo sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Kubernetes 源</span></span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="string">deb https://apt.kubernetes.io/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 kubeadm, kubelet 和 kubectl</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 kubelet 开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>

<h4 id="5-初始化-Kubernetes-集群"><a href="#5-初始化-Kubernetes-集群" class="headerlink" title="5. 初始化 Kubernetes 集群"></a>5. 初始化 Kubernetes 集群</h4><p>在主节点上执行 <code>kubeadm init</code> 命令来初始化集群。</p>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init</span><br></pre></td></tr></table></figure>

<h4 id="6-配置-kubectl"><a href="#6-配置-kubectl" class="headerlink" title="6. 配置 kubectl"></a>6. 配置 kubectl</h4><p>将集群配置复制到您的用户目录下，以便 <code>kubectl</code> 命令可以找到并与集群通信。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h4 id="7-安装-Pod-网络插件"><a href="#7-安装-Pod-网络插件" class="headerlink" title="7. 安装 Pod 网络插件"></a>7. 安装 Pod 网络插件</h4><p>选择并安装一个 Pod 网络插件，如 Calico 或 Flannel。</p>
<h5 id="示例代码（安装-Calico）"><a href="#示例代码（安装-Calico）" class="headerlink" title="示例代码（安装 Calico）:"></a>示例代码（安装 Calico）:</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>

<h4 id="8-将工作节点加入集群"><a href="#8-将工作节点加入集群" class="headerlink" title="8. 将工作节点加入集群"></a>8. 将工作节点加入集群</h4><p>在每个工作节点上运行 <code>kubeadm join</code> 命令来加入集群。</p>
<h3 id="使用Kubeadm在Kubernetes集群上执行版本升级"><a href="#使用Kubeadm在Kubernetes集群上执行版本升级" class="headerlink" title="使用Kubeadm在Kubernetes集群上执行版本升级"></a>使用Kubeadm在Kubernetes集群上执行版本升级</h3><p>使用 kubeadm 在 Kubernetes 集群上执行版本升级是一个详细且需要谨慎操作的过程。下面是详细步骤和相关操作代码：</p>
<h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><ul>
<li><strong>备份</strong>: 在开始之前，确保备份了 etcd 数据和任何重要配置。</li>
<li><strong>检查版本</strong>: 确定当前版本和要升级到的版本。不建议直接跳过多个版本进行升级。</li>
<li><strong>阅读发行说明</strong>: 查看新版本的发行说明，了解任何重大更改或特定注意事项。</li>
</ul>
<h4 id="2-升级步骤"><a href="#2-升级步骤" class="headerlink" title="2. 升级步骤"></a>2. 升级步骤</h4><h5 id="步骤-1-升级-kubeadm"><a href="#步骤-1-升级-kubeadm" class="headerlink" title="步骤 1: 升级 kubeadm"></a>步骤 1: 升级 kubeadm</h5><p>在所有主节点和工作节点上更新 kubeadm。以 Ubuntu 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新软件仓库并安装最新版本的 kubeadm</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y --allow-change-held-packages kubeadm=1.XX.0-00</span><br></pre></td></tr></table></figure>

<p>将 <code>1.XX.0-00</code> 替换为目标版本号。</p>
<h5 id="步骤-2-确认可以升级"><a href="#步骤-2-确认可以升级" class="headerlink" title="步骤 2: 确认可以升级"></a>步骤 2: 确认可以升级</h5><p>在主节点上检查可升级的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade plan</span><br></pre></td></tr></table></figure>

<p>这将显示可升级的版本和一些警告或建议。</p>
<h5 id="步骤-3-升级主节点"><a href="#步骤-3-升级主节点" class="headerlink" title="步骤 3: 升级主节点"></a>步骤 3: 升级主节点</h5><p>选择一个主节点开始升级。首先升级其控制平面组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade apply v1.XX.0</span><br></pre></td></tr></table></figure>

<p>将 <code>v1.XX.0</code> 替换为目标版本号。</p>
<h5 id="步骤-4-升级-kubelet-和-kubectl"><a href="#步骤-4-升级-kubelet-和-kubectl" class="headerlink" title="步骤 4: 升级 kubelet 和 kubectl"></a>步骤 4: 升级 kubelet 和 kubectl</h5><p>在同一个主节点上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y --allow-change-held-packages kubelet=1.XX.0-00 kubectl=1.XX.0-00</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<h5 id="步骤-5-验证主节点升级"><a href="#步骤-5-验证主节点升级" class="headerlink" title="步骤 5: 验证主节点升级"></a>步骤 5: 验证主节点升级</h5><p>检查升级后的节点状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>确认节点状态为 <code>Ready</code>。</p>
<h5 id="步骤-6-升级其他主节点"><a href="#步骤-6-升级其他主节点" class="headerlink" title="步骤 6: 升级其他主节点"></a>步骤 6: 升级其他主节点</h5><p>重复步骤 3 到 5，逐个升级其他主节点。</p>
<h5 id="步骤-7-升级工作节点"><a href="#步骤-7-升级工作节点" class="headerlink" title="步骤 7: 升级工作节点"></a>步骤 7: 升级工作节点</h5><p>对于工作节点，首先将其从服务中逐出，以防止在升级过程中调度新的 Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl drain &lt;node-name&gt; --ignore-daemonsets</span><br></pre></td></tr></table></figure>

<p>然后在工作节点上重复步骤 1 和 4。</p>
<p>在升级后重新加入工作节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl uncordon &lt;node-name&gt;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-8-验证集群状态"><a href="#步骤-8-验证集群状态" class="headerlink" title="步骤 8: 验证集群状态"></a>步骤 8: 验证集群状态</h5><p>确保所有节点都已升级并处于 <code>Ready</code> 状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>


<h3 id="实施etcd备份和还原"><a href="#实施etcd备份和还原" class="headerlink" title="实施etcd备份和还原"></a>实施etcd备份和还原</h3><p>在 Kubernetes 中，etcd 存储了所有集群数据，包括 Pod、服务和配置数据，因此对 etcd 的备份和还原至关重要。以下是详细的 etcd 备份和还原步骤，包括操作代码。</p>
<h4 id="etcd-备份"><a href="#etcd-备份" class="headerlink" title="etcd 备份"></a>etcd 备份</h4><h5 id="1-确定-etcd-数据目录"><a href="#1-确定-etcd-数据目录" class="headerlink" title="1. 确定 etcd 数据目录"></a>1. 确定 etcd 数据目录</h5><p>首先，您需要知道 etcd 数据的存储位置。这通常可以在 etcd 的启动脚本或 Kubernetes 主节点的 <code>kube-apiserver</code> 配置中找到。常见的路径是 <code>/var/lib/etcd</code>。</p>
<h5 id="2-使用-etcdctl-备份"><a href="#2-使用-etcdctl-备份" class="headerlink" title="2. 使用 etcdctl 备份"></a>2. 使用 etcdctl 备份</h5><p><code>etcdctl</code> 是一个命令行工具，用于与 etcd 交互和管理。进行备份前，需要设置环境变量以匹配 etcd 配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 ETCDCTL 环境变量</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line"><span class="built_in">export</span> ETCDCTL_CACERT=<span class="string">&quot;/path/to/ca.crt&quot;</span>  <span class="comment"># etcd CA 证书路径</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_CERT=<span class="string">&quot;/path/to/etcd.crt&quot;</span>  <span class="comment"># etcd 证书路径</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_KEY=<span class="string">&quot;/path/to/etcd.key&quot;</span>   <span class="comment"># etcd 密钥路径</span></span><br></pre></td></tr></table></figure>

<p>备份命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl snapshot save /path/to/snapshot.db</span><br></pre></td></tr></table></figure>

<p>这里 <code>/path/to/snapshot.db</code> 是备份文件的存储路径。</p>
<h5 id="3-验证备份"><a href="#3-验证备份" class="headerlink" title="3. 验证备份"></a>3. 验证备份</h5><p>使用以下命令验证备份文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl --write-out=table snapshot status /path/to/snapshot.db</span><br></pre></td></tr></table></figure>

<h4 id="etcd-还原"><a href="#etcd-还原" class="headerlink" title="etcd 还原"></a>etcd 还原</h4><h5 id="1-停止-kube-apiserver"><a href="#1-停止-kube-apiserver" class="headerlink" title="1. 停止 kube-apiserver"></a>1. 停止 kube-apiserver</h5><p>在进行还原之前，需要在所有主节点上停止 kube-apiserver。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop kube-apiserver</span><br></pre></td></tr></table></figure>

<h5 id="2-还原-etcd-数据"><a href="#2-还原-etcd-数据" class="headerlink" title="2. 还原 etcd 数据"></a>2. 还原 etcd 数据</h5><p>使用 <code>etcdctl snapshot restore</code> 命令还原数据。您需要指定一个新的 etcd 数据目录，以免覆盖现有数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl snapshot restore /path/to/snapshot.db \</span><br><span class="line">  --data-dir=/path/to/new/data-dir</span><br></pre></td></tr></table></figure>

<h5 id="3-更新-etcd-的配置"><a href="#3-更新-etcd-的配置" class="headerlink" title="3. 更新 etcd 的配置"></a>3. 更新 etcd 的配置</h5><p>更新 etcd 配置，指向新的数据目录。这通常涉及到修改 etcd 的启动脚本或服务文件。</p>
<h5 id="4-重新启动-etcd-和-kube-apiserver"><a href="#4-重新启动-etcd-和-kube-apiserver" class="headerlink" title="4. 重新启动 etcd 和 kube-apiserver"></a>4. 重新启动 etcd 和 kube-apiserver</h5><p>在所有主节点上重启 etcd 服务和 kube-apiserver 服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start etcd</span><br><span class="line">sudo systemctl start kube-apiserver</span><br></pre></td></tr></table></figure>

<h5 id="5-验证集群状态"><a href="#5-验证集群状态" class="headerlink" title="5. 验证集群状态"></a>5. 验证集群状态</h5><p>一旦 etcd 和 kube-apiserver 重启完成，使用 <code>kubectl get nodes</code> 和 <code>kubectl get pods -A</code> 检查集群状态和所有 Pod 的状态。</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>在执行备份和还原操作时，确保您有适当的访问权限。</li>
<li>确保在安全的地方存储备份文件。</li>
<li>在进行还原之前，最好在测试环境中验证备份文件的完整性和可用性。</li>
<li>备份和还原操作可能会导致 Kubernetes 集群的短暂不可用，因此建议在维护时间窗口内进行。</li>
</ul>
<h2 id="工作负载和调度（15-）"><a href="#工作负载和调度（15-）" class="headerlink" title="工作负载和调度（15%）"></a>工作负载和调度（15%）</h2><h3 id="了解部署以及如何执行滚动更新和回滚"><a href="#了解部署以及如何执行滚动更新和回滚" class="headerlink" title="了解部署以及如何执行滚动更新和回滚"></a>了解部署以及如何执行滚动更新和回滚</h3><p>在 Kubernetes 中，滚动更新（Rolling Update）是一种用于更新应用程序的方法，它逐步替换旧版本的 Pod 实例为新版本，而不是同时停止和启动所有实例。这种方式可以确保服务在更新过程中仍然可用。而回滚（Rollback）是在更新过程中出现问题时撤销更改的过程。</p>
<h4 id="部署与滚动更新"><a href="#部署与滚动更新" class="headerlink" title="部署与滚动更新"></a>部署与滚动更新</h4><h5 id="1-创建或更新部署"><a href="#1-创建或更新部署" class="headerlink" title="1. 创建或更新部署"></a>1. 创建或更新部署</h5><p>首先，您需要一个 Kubernetes 部署。这可以通过 <code>kubectl create</code> 或 <code>kubectl apply</code> 命令来完成。例如，创建一个简单的部署：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>kubectl apply</code> 部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure>

<h5 id="2-执行滚动更新"><a href="#2-执行滚动更新" class="headerlink" title="2. 执行滚动更新"></a>2. 执行滚动更新</h5><p>当你需要更新应用程序时（例如，更换 Docker 镜像版本），只需更改部署配置文件中的镜像版本，然后再次运用该配置文件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 deployment.yaml</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.16.1</span>  <span class="comment"># 更新镜像版本</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>kubectl apply</code> 应用更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure>

<p>Kubernetes 会自动进行滚动更新，逐步替换旧版本的 Pod。</p>
<h5 id="3-监控更新状态"><a href="#3-监控更新状态" class="headerlink" title="3. 监控更新状态"></a>3. 监控更新状态</h5><p>可以使用以下命令监控更新进度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<h4 id="回滚更新"><a href="#回滚更新" class="headerlink" title="回滚更新"></a>回滚更新</h4><p>如果更新后的应用程序出现问题，可以执行回滚到之前的版本。</p>
<h5 id="1-检查部署的修订版本"><a href="#1-检查部署的修订版本" class="headerlink" title="1. 检查部署的修订版本"></a>1. 检查部署的修订版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<p>这将列出所有的部署修订版本和更改详情。</p>
<h5 id="2-回滚到指定版本"><a href="#2-回滚到指定版本" class="headerlink" title="2. 回滚到指定版本"></a>2. 回滚到指定版本</h5><p>如果确定需要回滚，可以选择回滚到特定的修订版本。例如，回滚到上一个版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<p>或者回滚到特定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure>

<p>这里的 <code>2</code> 是要回滚到的修订版本号。</p>
<h5 id="3-验证回滚结果"><a href="#3-验证回滚结果" class="headerlink" title="3. 验证回滚结果"></a>3. 验证回滚结果</h5><p>再次使用 <code>kubectl rollout status</code> 和 <code>kubectl get pods</code> 检查部署的状态和 Pod 的情况。</p>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>在执行滚动更新之前，确保您的应用程序支持平滑重启和无状态操作。</li>
<li>滚动更新的速度可以通过调整部署的 <code>strategy</code> 字段来控制。</li>
<li>在执行更新或回滚时，务必监控应用程序的性能和日志，以便及时发现问题。</li>
<li>对于关键应用，建议在测试环境中先行验证更新过程。</li>
</ul>
<h3 id="使用ConfigMaps和Secrets配置应用程序"><a href="#使用ConfigMaps和Secrets配置应用程序" class="headerlink" title="使用ConfigMaps和Secrets配置应用程序"></a>使用ConfigMaps和Secrets配置应用程序</h3><p>在 Kubernetes 中，ConfigMaps 和 Secrets 是两种用于存储配置数据的资源类型，允许您将配置与容器镜像和 Pod 模板解耦。ConfigMaps 通常用于存储非敏感数据，如应用配置文件，而 Secrets 用于存储敏感信息，如密码、密钥或令牌。</p>
<h4 id="使用-ConfigMaps-配置应用程序"><a href="#使用-ConfigMaps-配置应用程序" class="headerlink" title="使用 ConfigMaps 配置应用程序"></a>使用 ConfigMaps 配置应用程序</h4><h5 id="1-创建-ConfigMap"><a href="#1-创建-ConfigMap" class="headerlink" title="1. 创建 ConfigMap"></a>1. 创建 ConfigMap</h5><p><strong>方法一：</strong> 使用 <code>kubectl create configmap</code> 命令直接从字面值创建 ConfigMap：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create configmap my-config --from-literal=key1=value1 --from-literal=key2=value2</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 从文件创建 ConfigMap：</p>
<p>假设有一个配置文件 <code>app-config.properties</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key1=value1</span><br><span class="line">key2=value2</span><br></pre></td></tr></table></figure>

<p>使用该文件创建 ConfigMap：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create configmap my-config --from-file=app-config.properties</span><br></pre></td></tr></table></figure>

<h5 id="2-在-Pod-中使用-ConfigMap"><a href="#2-在-Pod-中使用-ConfigMap" class="headerlink" title="2. 在 Pod 中使用 ConfigMap"></a>2. 在 Pod 中使用 ConfigMap</h5><p>您可以将 ConfigMap 挂载为卷，或者将 ConfigMap 的数据作为环境变量传入容器。</p>
<p><strong>作为环境变量：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mycontainer</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEY1</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">my-config</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">key1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEY2</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">my-config</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">key2</span></span><br></pre></td></tr></table></figure>

<p><strong>作为卷挂载：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mycontainer</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">my-config</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-Secrets-配置应用程序"><a href="#使用-Secrets-配置应用程序" class="headerlink" title="使用 Secrets 配置应用程序"></a>使用 Secrets 配置应用程序</h4><h5 id="1-创建-Secret"><a href="#1-创建-Secret" class="headerlink" title="1. 创建 Secret"></a>1. 创建 Secret</h5><p><strong>方法一：</strong> 使用 <code>kubectl create secret</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic my-secret --from-literal=key1=value1 --from-literal=key2=value2</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 从文件创建 Secret：</p>
<p>假设有一个文件 <code>secret-data.txt</code>，内容包含密钥数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic my-secret --from-file=secret-data.txt</span><br></pre></td></tr></table></figure>

<h5 id="2-在-Pod-中使用-Secret"><a href="#2-在-Pod-中使用-Secret" class="headerlink" title="2. 在 Pod 中使用 Secret"></a>2. 在 Pod 中使用 Secret</h5><p>与 ConfigMap 类似，Secret 也可以作为环境变量或卷挂载到 Pod 中。</p>
<p><strong>作为环境变量：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mycontainer</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_KEY1</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">secretKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">key1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_KEY2</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">secretKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">key2</span></span><br></pre></td></tr></table></figure>

<p><strong>作为卷挂载：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mycontainer</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/secret</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">my-secret</span></span><br></pre></td></tr></table></figure>

<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>ConfigMap 和 Secret 都不提供加密存储。对于 Secret，虽然内容是以 Base64 编码存储，但不应被视为安全的加密方法。</li>
<li>使用 Secrets 存储敏感信息时，应该限制对其的访问，并遵循最佳安全实践。</li>
<li>确保在应用程序中正确处理这些配置数据，特别是对于敏感数据。</li>
<li>在更新 ConfigMap 或 Secret 后，可能需要重启引用它们的 Pod，因为更新不会自动传播到已运行的 Pod。</li>
</ul>
<h3 id="了解如何扩展应用程序"><a href="#了解如何扩展应用程序" class="headerlink" title="了解如何扩展应用程序"></a>了解如何扩展应用程序</h3><p>在 Kubernetes 中，扩展应用程序通常指的是增加或减少运行应用程序的 Pods 的数量，以应对不同的负载需求。这可以通过手动扩展或使用自动扩展器（如 Horizontal Pod Autoscaler）来实现。以下是手动扩展和自动扩展应用程序的详细步骤和操作代码。</p>
<h4 id="手动扩展应用程序"><a href="#手动扩展应用程序" class="headerlink" title="手动扩展应用程序"></a>手动扩展应用程序</h4><h5 id="1-查看当前部署状态"><a href="#1-查看当前部署状态" class="headerlink" title="1. 查看当前部署状态"></a>1. 查看当前部署状态</h5><p>首先，查看当前部署的状态，以了解应用程序目前运行的 Pods 数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure>

<h5 id="2-手动更改-Pods-数量"><a href="#2-手动更改-Pods-数量" class="headerlink" title="2. 手动更改 Pods 数量"></a>2. 手动更改 Pods 数量</h5><p>使用 <code>kubectl scale</code> 命令来更改部署的副本数（replicas）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;num-replicas&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;deployment-name&gt;</code>: 部署的名称。</li>
<li><code>&lt;num-replicas&gt;</code>: 你想要的 Pods 数量。</li>
</ul>
<p>例如，如果你的部署名为 <code>my-app</code>，并且你想要扩展到 5 个副本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment my-app --replicas=5</span><br></pre></td></tr></table></figure>

<h5 id="3-验证扩展结果"><a href="#3-验证扩展结果" class="headerlink" title="3. 验证扩展结果"></a>3. 验证扩展结果</h5><p>使用 <code>kubectl get</code> 命令来验证更改是否生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployment &lt;deployment-name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="自动扩展应用程序"><a href="#自动扩展应用程序" class="headerlink" title="自动扩展应用程序"></a>自动扩展应用程序</h4><p>自动扩展（Horizontal Pod Autoscaler，HPA）可以根据 CPU 使用率或其他选择的度量自动扩展 Pod 的数量。</p>
<h5 id="1-创建或更新部署-1"><a href="#1-创建或更新部署-1" class="headerlink" title="1. 创建或更新部署"></a>1. 创建或更新部署</h5><p>确保你已经有一个运行的部署。如果没有，可以参考前面的手动扩展步骤来创建一个部署。</p>
<h5 id="2-创建-HPA-资源"><a href="#2-创建-HPA-资源" class="headerlink" title="2. 创建 HPA 资源"></a>2. 创建 HPA 资源</h5><p>使用 <code>kubectl autoscale</code> 命令创建一个新的 HPA。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl autoscale deployment &lt;deployment-name&gt; --min=&lt;min-replicas&gt; --max=&lt;max-replicas&gt; --cpu-percent=&lt;target-percentage&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;deployment-name&gt;</code>: 部署的名称。</li>
<li><code>&lt;min-replicas&gt;</code>: 最小副本数。</li>
<li><code>&lt;max-replicas&gt;</code>: 最大副本数。</li>
<li><code>&lt;target-percentage&gt;</code>: 目标 CPU 使用率百分比。</li>
</ul>
<p>例如，创建一个 HPA 以保持 <code>my-app</code> 部署的 CPU 使用率约为 50%，副本数在 1 到 10 之间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl autoscale deployment my-app --min=1 --max=10 --cpu-percent=50</span><br></pre></td></tr></table></figure>

<h5 id="3-验证-HPA"><a href="#3-验证-HPA" class="headerlink" title="3. 验证 HPA"></a>3. 验证 HPA</h5><p>查看 HPA 的状态，以确保它正在正确监控你的部署。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get hpa</span><br></pre></td></tr></table></figure>

<h4 id="4-监控应用程序和-HPA"><a href="#4-监控应用程序和-HPA" class="headerlink" title="4. 监控应用程序和 HPA"></a>4. 监控应用程序和 HPA</h4><p>持续监控你的应用程序和 HPA 的状态，确保它根据负载正确地自动扩展。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get hpa -w</span><br></pre></td></tr></table></figure>

<h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>扩展时，确保集群有足够的资源来支持更多的 Pods。</li>
<li>自动扩展依赖于度量数据（如 CPU 使用率），这些数据来自 Kubernetes 集群的度量服务器（如 Metrics Server）。</li>
<li>HPA 需要一定时间来收集数据和作出扩展决策，所以它对于突发流量的响应可能不是实时的。</li>
<li>在使用 HPA 之前，最好了解应用程序的性能特征和负载模式，以正确配置 HPA 参数。</li>
</ul>
<h3 id="了解用于创建健壮的、自修复的应用程序部署的原语"><a href="#了解用于创建健壮的、自修复的应用程序部署的原语" class="headerlink" title="了解用于创建健壮的、自修复的应用程序部署的原语"></a>了解用于创建健壮的、自修复的应用程序部署的原语</h3><p>在 Kubernetes 中创建健壮且自修复的应用程序涉及使用多个 Kubernetes 原语（Primitives）。这些原语包括部署（Deployments）、服务（Services）、健康检查（Probes）等，它们共同工作以确保应用程序的高可用性和稳定性。以下是使用这些原语的详细步骤和操作代码。</p>
<h4 id="1-创建部署（Deployment）"><a href="#1-创建部署（Deployment）" class="headerlink" title="1. 创建部署（Deployment）"></a>1. 创建部署（Deployment）</h4><p>部署是 Kubernetes 中用于管理 Pod 和 ReplicaSet 的原语。它可以确保指定数量的 Pod 副本始终运行。</p>
<h5 id="示例部署"><a href="#示例部署" class="headerlink" title="示例部署"></a>示例部署</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">my-app-image:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/ready</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>my-app-deployment</code> 将确保始终有三个 <code>my-app</code> 的副本在运行。同时，它定义了活动探针（Liveness Probe）和就绪探针（Readiness Probe）来检查应用程序的健康状态。</p>
<h5 id="创建部署"><a href="#创建部署" class="headerlink" title="创建部署"></a>创建部署</h5><p>使用以下命令创建部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure>

<h4 id="2-创建服务（Service）"><a href="#2-创建服务（Service）" class="headerlink" title="2. 创建服务（Service）"></a>2. 创建服务（Service）</h4><p>服务是 Kubernetes 中的一个抽象层，它定义了如何访问 Pod。</p>
<h5 id="示例服务"><a href="#示例服务" class="headerlink" title="示例服务"></a>示例服务</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure>

<p>这个服务定义了一个负载均衡器，它将外部请求分发到 <code>my-app</code> 的 Pod。</p>
<h5 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h5><p>使用以下命令创建服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml</span><br></pre></td></tr></table></figure>

<h3 id="3-实施健康检查"><a href="#3-实施健康检查" class="headerlink" title="3. 实施健康检查"></a>3. 实施健康检查</h3><p>在部署中定义健康检查，包括活动探针（Liveness Probes）和就绪探针（Readiness Probes）。这些探针帮助 Kubernetes 了解何时应重启容器（自修复）以及何时将流量路由到特定 Pod（负载均衡）。</p>
<ul>
<li><strong>活动探针（Liveness Probe）</strong>: 确定容器何时处于活动状态。</li>
<li><strong>就绪探针（Readiness Probe）</strong>: 确定容器何时准备好接受流量。</li>
</ul>
<p>在上面的部署示例中已经包含了这两种探针的配置。</p>
<h4 id="4-自动扩展（可选）"><a href="#4-自动扩展（可选）" class="headerlink" title="4. 自动扩展（可选）"></a>4. 自动扩展（可选）</h4><p>使用水平 Pod 自动扩展器（HPA）自动根据 CPU 使用率或其他指标扩展或缩减 Pod 数量。</p>
<h5 id="创建-HPA"><a href="#创建-HPA" class="headerlink" title="创建 HPA"></a>创建 HPA</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-app-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>这个 HPA 将根据 CPU 使用率自动调整 <code>my-app-deployment</code> 的副本数。</p>
<h5 id="创建-HPA-1"><a href="#创建-HPA-1" class="headerlink" title="创建 HPA"></a>创建 HPA</h5><p>使用以下命令创建 HPA：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f hpa.yaml</span><br></pre></td></tr></table></figure>



<h3 id="了解资源限制如何影响Pod调度"><a href="#了解资源限制如何影响Pod调度" class="headerlink" title="了解资源限制如何影响Pod调度"></a>了解资源限制如何影响Pod调度</h3><h4 id="设置资源限制对-Pod-调度的影响"><a href="#设置资源限制对-Pod-调度的影响" class="headerlink" title="设置资源限制对 Pod 调度的影响"></a>设置资源限制对 Pod 调度的影响</h4><p>在 Kubernetes 中，为 Pod 设置资源限制是确保集群健康和效率的重要做法。资源限制影响 Pod 调度，主要是因为 Kubernetes 调度器会根据节点上的可用资源来决定是否可以在该节点上启动一个 Pod。</p>
<h5 id="1-资源请求和限制的基本概念"><a href="#1-资源请求和限制的基本概念" class="headerlink" title="1. 资源请求和限制的基本概念"></a>1. 资源请求和限制的基本概念</h5><ul>
<li><strong>资源请求（Requests）</strong>: 表示 Pod 启动时最小需要的资源量。调度器用这个值来决定在哪个节点上放置 Pod。</li>
<li><strong>资源限制（Limits）</strong>: 表示 Pod 运行时能够使用的最大资源量。如果 Pod 超过这个限制，它可能会被终止。</li>
</ul>
<h5 id="2-定义资源请求和限制"><a href="#2-定义资源请求和限制" class="headerlink" title="2. 定义资源请求和限制"></a>2. 定义资源请求和限制</h5><p>在 Pod 定义中，您可以为每个容器指定资源请求和限制。</p>
<h6 id="示例-Pod-定义"><a href="#示例-Pod-定义" class="headerlink" title="示例 Pod 定义"></a>示例 Pod 定义</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-app-image</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>app-container</code> 请求至少 64 MiB 内存和 0.25 CPU 核心来启动，最多可以使用 128 MiB 内存和 0.5 CPU 核心。</p>
<h5 id="3-资源限制对调度的影响"><a href="#3-资源限制对调度的影响" class="headerlink" title="3. 资源限制对调度的影响"></a>3. 资源限制对调度的影响</h5><ul>
<li>如果 Pod 请求的资源超过了节点上的可用资源，Pod 将不会被调度到该节点上。</li>
<li>如果集群中没有任何节点能满足 Pod 的资源请求，Pod 将处于未调度状态，直到有资源可用。</li>
<li>如果一个正在运行的 Pod 超过了其资源限制，它可能会被终止并重新调度到其他节点，这取决于资源限制类型和集群配置。</li>
</ul>
<h5 id="4-应用-Pod-资源配置"><a href="#4-应用-Pod-资源配置" class="headerlink" title="4. 应用 Pod 资源配置"></a>4. 应用 Pod 资源配置</h5><p>使用 <code>kubectl</code> 应用这个配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-definition.yaml</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>pod-definition.yaml</code> 是包含上面示例的文件名。</p>
<h5 id="5-监控-Pod-资源使用情况"><a href="#5-监控-Pod-资源使用情况" class="headerlink" title="5. 监控 Pod 资源使用情况"></a>5. 监控 Pod 资源使用情况</h5><p>监控 Pod 的资源使用是理解和优化 Kubernetes 调度的关键。</p>
<ul>
<li>使用 <code>kubectl describe pod</code> 命令查看 Pod 的资源使用情况。</li>
<li>考虑使用 Kubernetes 集群的监控工具（如 Prometheus）来跟踪资源使用。</li>
</ul>
<h5 id="6-调整策略"><a href="#6-调整策略" class="headerlink" title="6. 调整策略"></a>6. 调整策略</h5><p>基于监控数据和应用性能，您可能需要调整 Pod 的资源请求和限制。</p>
<ul>
<li>对于频繁被杀死的 Pod，考虑增加资源限制。</li>
<li>对于利用率低的 Pod，考虑减少资源请求。</li>
</ul>
<h3 id="了解清单管理和通用模板工具"><a href="#了解清单管理和通用模板工具" class="headerlink" title="了解清单管理和通用模板工具"></a>了解清单管理和通用模板工具</h3><h4 id="理解-Kubernetes-清单管理和通用模板工具"><a href="#理解-Kubernetes-清单管理和通用模板工具" class="headerlink" title="理解 Kubernetes 清单管理和通用模板工具"></a>理解 Kubernetes 清单管理和通用模板工具</h4><p>在 Kubernetes 环境中，管理大量资源清单（Manifests）可能变得复杂和混乱。为了解决这个问题，出现了一些工具和技术，用于简化清单管理和模板化。其中最著名的工具包括 Helm 和 Kustomize。</p>
<h5 id="1-Helm：Kubernetes-的包管理器"><a href="#1-Helm：Kubernetes-的包管理器" class="headerlink" title="1. Helm：Kubernetes 的包管理器"></a>1. Helm：Kubernetes 的包管理器</h5><p>Helm 被认为是 Kubernetes 的包管理器。它允许你定义、安装和升级甚至是最复杂的 Kubernetes 应用。</p>
<h6 id="Helm-的基本用法"><a href="#Helm-的基本用法" class="headerlink" title="Helm 的基本用法"></a>Helm 的基本用法</h6><ul>
<li><p><strong>安装 Helm</strong>:<br>Helm 安装可以通过下载其二进制文件或使用包管理器来完成。</p>
</li>
<li><p><strong>创建新 chart</strong>:<br>Chart 是 Helm 管理的应用程序包。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm create my-chart</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>自定义 Chart</strong>:<br>编辑 <code>my-chart</code> 目录下的文件来自定义应用程序。</p>
</li>
<li><p><strong>安装 Chart</strong>:<br>将 Chart 部署到你的 Kubernetes 集群。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install my-release my-chart</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>更新和回滚</strong>:<br>使用 <code>helm upgrade</code> 和 <code>helm rollback</code> 来管理已部署的应用。</li>
</ul>
<h5 id="2-Kustomize：Kubernetes-的原生配置管理"><a href="#2-Kustomize：Kubernetes-的原生配置管理" class="headerlink" title="2. Kustomize：Kubernetes 的原生配置管理"></a>2. Kustomize：Kubernetes 的原生配置管理</h5><p>Kustomize 介绍了一种新的方法来自定义 Kubernetes 对象，通过声明式的配置文件来管理修改。</p>
<h6 id="Kustomize-的基本用法"><a href="#Kustomize-的基本用法" class="headerlink" title="Kustomize 的基本用法"></a>Kustomize 的基本用法</h6><ul>
<li><strong>创建基本配置</strong>:<br>创建一个包含 Kubernetes 清单的目录。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建 kustomization 文件</strong>:<br>在同一目录下创建一个 <code>kustomization.yaml</code> 文件，指定资源列表和修改。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deployment.yaml</span></span><br><span class="line"><span class="attr">patchesStrategicMerge:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">patch.yaml</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用配置</strong>:<br>使用 kubectl 结合 Kustomize 修改和部署资源。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -k .</span><br></pre></td></tr></table></figure>

<h5 id="3-选择合适的工具"><a href="#3-选择合适的工具" class="headerlink" title="3. 选择合适的工具"></a>3. 选择合适的工具</h5><p>选择 Helm 还是 Kustomize 取决于你的需求：</p>
<ul>
<li>如果需要一个包管理器来处理复杂的应用部署和生命周期管理，使用 Helm。</li>
<li>如果需要更细粒度的控制和原生 Kubernetes 支持，使用 Kustomize。</li>
</ul>
<h2 id="服务和网络（20-）"><a href="#服务和网络（20-）" class="headerlink" title="服务和网络（20%）"></a>服务和网络（20%）</h2><h3 id="了解集群节点上的主机网络配置"><a href="#了解集群节点上的主机网络配置" class="headerlink" title="了解集群节点上的主机网络配置"></a>了解集群节点上的主机网络配置</h3><h4 id="理解-Kubernetes-集群节点上的主机网络配置"><a href="#理解-Kubernetes-集群节点上的主机网络配置" class="headerlink" title="理解 Kubernetes 集群节点上的主机网络配置"></a>理解 Kubernetes 集群节点上的主机网络配置</h4><p>在 Kubernetes 集群中，节点（Node）的网络配置对于确保 Pod 能够正确、高效地进行通信至关重要。理解和配置主机网络涉及几个关键方面，包括网络插件、Pod 网络、服务网络以及可能的网络策略。</p>
<h5 id="1-选择网络插件"><a href="#1-选择网络插件" class="headerlink" title="1. 选择网络插件"></a>1. 选择网络插件</h5><p>Kubernetes 本身不提供网络实现，而是通过 CNI（容器网络接口）插件来提供网络服务。根据您的需求和环境，您可能会选择不同的网络插件，如 Calico、Flannel、Weave 等。</p>
<h6 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h6><p>以 Calico 为例，您可以通过应用其 YAML 文件来安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>

<p>这个命令会部署 Calico 的所有必要组件到您的集群。</p>
<h5 id="2-配置-Pod-网络"><a href="#2-配置-Pod-网络" class="headerlink" title="2. 配置 Pod 网络"></a>2. 配置 Pod 网络</h5><p>在 Kubernetes 集群中，每个 Pod 都有自己的 IP 地址。这意味着您需要为集群配置一个 Pod 网络，以确保 Pods 能够互相通信。</p>
<h6 id="定义-Pod-网络-CIDR"><a href="#定义-Pod-网络-CIDR" class="headerlink" title="定义 Pod 网络 CIDR"></a>定义 Pod 网络 CIDR</h6><p>当初始化集群时（使用 kubeadm），您需要指定一个 CIDR 范围用于 Pod 网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>这个 CIDR 范围应该是私有的、集群内部的，并且与您集群中的任何现有网络不冲突。</p>
<h5 id="3-配置服务网络"><a href="#3-配置服务网络" class="headerlink" title="3. 配置服务网络"></a>3. 配置服务网络</h5><p>Kubernetes 服务（Service）是一种抽象，它定义了一种访问 Pod 的方法。服务有自己的虚拟 IP 地址，您需要为服务定义一个 CIDR 范围。</p>
<h6 id="定义服务网络-CIDR"><a href="#定义服务网络-CIDR" class="headerlink" title="定义服务网络 CIDR"></a>定义服务网络 CIDR</h6><p>这通常在 Kubernetes API 服务器的启动参数中定义。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kube-apiserver --service-cluster-ip-range=10.96.0.0/12</span><br></pre></td></tr></table></figure>

<p>这个范围应该唯一且不与 Pod 网络和主机网络冲突。</p>
<h5 id="4-网络策略"><a href="#4-网络策略" class="headerlink" title="4. 网络策略"></a>4. 网络策略</h5><p>网络策略允许您控制哪些 Pod 可以相互通信。在默认情况下，Pods 通常是不受限的，可以自由通信。</p>
<h6 id="应用网络策略"><a href="#应用网络策略" class="headerlink" title="应用网络策略"></a>应用网络策略</h6><p>以下是一个基本的网络策略示例，它限制了特定命名空间中的流量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure>

<p>这个策略允许标记为 <code>frontend</code> 的 Pod 访问标记为 <code>db</code> 的 Pod，并允许 <code>db</code> Pod 访问 <code>backend</code> Pod。</p>
<h3 id="理解Pods之间的连通性"><a href="#理解Pods之间的连通性" class="headerlink" title="理解Pods之间的连通性"></a>理解Pods之间的连通性</h3><h4 id="理解-Kubernetes-中-Pods-之间的连通性"><a href="#理解-Kubernetes-中-Pods-之间的连通性" class="headerlink" title="理解 Kubernetes 中 Pods 之间的连通性"></a>理解 Kubernetes 中 Pods 之间的连通性</h4><p>在 Kubernetes 中，Pods 之间的连通性是通过集群内部的网络实现的。理解和确保 Pods 之间可以正确通信，是 Kubernetes 网络管理的一个重要方面。</p>
<h5 id="1-Kubernetes-网络模型"><a href="#1-Kubernetes-网络模型" class="headerlink" title="1. Kubernetes 网络模型"></a>1. Kubernetes 网络模型</h5><p>Kubernetes 网络模型有几个基本要求：</p>
<ul>
<li>所有 Pod 都必须在不需要 NAT 的情况下相互通信。</li>
<li>所有节点必须能够与所有 Pod 相互通信。</li>
<li>每个 Pod 都有自己的 IP 地址。</li>
</ul>
<h5 id="2-测试-Pod-之间的连通性"><a href="#2-测试-Pod-之间的连通性" class="headerlink" title="2. 测试 Pod 之间的连通性"></a>2. 测试 Pod 之间的连通性</h5><h6 id="创建测试-Pods"><a href="#创建测试-Pods" class="headerlink" title="创建测试 Pods"></a>创建测试 Pods</h6><p>首先，创建两个简单的 Pods 来测试它们之间的连通性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test-pod-1.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod-1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test-pod-2.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里，<code>test-pod-1</code> 是一个运行 nginx 的简单 Pod，而 <code>test-pod-2</code> 是一个运行 busybox 的 Pod，用于测试网络连通性。</p>
<h6 id="部署-Pods"><a href="#部署-Pods" class="headerlink" title="部署 Pods"></a>部署 Pods</h6><p>使用以下命令部署这两个 Pods：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f test-pod-1.yaml</span><br><span class="line">kubectl apply -f test-pod-2.yaml</span><br></pre></td></tr></table></figure>

<h6 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h6><p>通过进入一个 Pod，并尝试 ping 另一个 Pod 的 IP 地址来测试它们之间的连通性。</p>
<p>首先，获取 <code>test-pod-1</code> 的 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod test-pod-1 -o wide</span><br></pre></td></tr></table></figure>

<p>然后，进入 <code>test-pod-2</code> 并尝试 ping <code>test-pod-1</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -ti test-pod-2 -- ping &lt;test-pod-1-ip&gt;</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>&lt;test-pod-1-ip&gt;</code> 是你从上一个命令中获得的 <code>test-pod-1</code> 的 IP 地址。</p>
<h5 id="3-理解服务（Service）的作用"><a href="#3-理解服务（Service）的作用" class="headerlink" title="3. 理解服务（Service）的作用"></a>3. 理解服务（Service）的作用</h5><p>在 Kubernetes 中，服务（Service）是一个抽象层，它定义了一种访问一组特定 Pods 的方法，通常用于内部负载均衡和服务发现。</p>
<h6 id="创建服务-1"><a href="#创建服务-1" class="headerlink" title="创建服务"></a>创建服务</h6><p>以下是一个简单的服务定义示例，它将流量路由到标记为 <code>app=nginx</code> 的 Pods。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx-service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>部署服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-service.yaml</span><br></pre></td></tr></table></figure>

<p>通过这个服务，您可以使用服务的名称或 IP 在集群内部访问 nginx Pod，而无需知道 Pod 的具体 IP。</p>
<h3 id="了解ClusterIP、NodePort、LoadBalancer服务类型和端点"><a href="#了解ClusterIP、NodePort、LoadBalancer服务类型和端点" class="headerlink" title="了解ClusterIP、NodePort、LoadBalancer服务类型和端点"></a>了解ClusterIP、NodePort、LoadBalancer服务类型和端点</h3><h4 id="理解-Kubernetes-服务类型：ClusterIP、NodePort、LoadBalancer-及端点"><a href="#理解-Kubernetes-服务类型：ClusterIP、NodePort、LoadBalancer-及端点" class="headerlink" title="理解 Kubernetes 服务类型：ClusterIP、NodePort、LoadBalancer 及端点"></a>理解 Kubernetes 服务类型：ClusterIP、NodePort、LoadBalancer 及端点</h4><p>在 Kubernetes 中，服务（Service）是一种抽象，它定义了如何访问一组特定的 Pods。Kubernetes 提供了几种类型的服务，包括 ClusterIP、NodePort 和 LoadBalancer，它们各自适用于不同的场景。</p>
<h5 id="1-ClusterIP-服务"><a href="#1-ClusterIP-服务" class="headerlink" title="1. ClusterIP 服务"></a>1. ClusterIP 服务</h5><ul>
<li><strong>定义</strong>：ClusterIP 是默认的 Kubernetes 服务类型，它为服务在集群内部提供一个内部 IP 地址，使得只能在集群内部访问这个服务。</li>
<li><strong>用途</strong>：常用于集群内部的服务间通信。</li>
</ul>
<h6 id="创建-ClusterIP-服务"><a href="#创建-ClusterIP-服务" class="headerlink" title="创建 ClusterIP 服务"></a>创建 ClusterIP 服务</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clusterip-service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-clusterip-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>selector</code> 定义了这个服务将会路由到哪些 Pod。</li>
<li><code>port</code> 定义了服务的端口号。</li>
<li><code>targetPort</code> 是 Pod 上的端口号。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f clusterip-service.yaml</span><br></pre></td></tr></table></figure>

<h5 id="2-NodePort-服务"><a href="#2-NodePort-服务" class="headerlink" title="2. NodePort 服务"></a>2. NodePort 服务</h5><ul>
<li><strong>定义</strong>：NodePort 服务是一种可以从集群外部访问的服务。它在每个节点的相同端口上暴露服务。</li>
<li><strong>用途</strong>：当需要从集群外部访问服务时使用。</li>
</ul>
<h6 id="创建-NodePort-服务"><a href="#创建-NodePort-服务" class="headerlink" title="创建 NodePort 服务"></a>创建 NodePort 服务</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nodeport-service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nodeport-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30007</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>type: NodePort</code> 指定服务类型为 NodePort。</li>
<li><code>nodePort</code> 是集群外部用来访问此服务的端口号。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nodeport-service.yaml</span><br></pre></td></tr></table></figure>

<h5 id="3-LoadBalancer-服务"><a href="#3-LoadBalancer-服务" class="headerlink" title="3. LoadBalancer 服务"></a>3. LoadBalancer 服务</h5><ul>
<li><strong>定义</strong>：LoadBalancer 服务是一种为服务提供外部 IP 以直接从外部访问的服务。它通常由云提供商提供。</li>
<li><strong>用途</strong>：在需要直接从互联网访问服务时使用。</li>
</ul>
<h6 id="创建-LoadBalancer-服务"><a href="#创建-LoadBalancer-服务" class="headerlink" title="创建 LoadBalancer 服务"></a>创建 LoadBalancer 服务</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loadbalancer-service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-loadbalancer-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>type: LoadBalancer</code> 指定服务类型为 LoadBalancer。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f loadbalancer-service.yaml</span><br></pre></td></tr></table></figure>

<h5 id="4-端点（Endpoints）"><a href="#4-端点（Endpoints）" class="headerlink" title="4. 端点（Endpoints）"></a>4. 端点（Endpoints）</h5><ul>
<li><strong>定义</strong>：Endpoints 是 Kubernetes 服务的一个组件，它维护了服务选择器匹配的 Pod 的 IP 地址和端口的列表。</li>
<li><strong>用途</strong>：当服务选择器无法直接匹配 Pod 时使用。</li>
</ul>
<h6 id="查看服务的端点"><a href="#查看服务的端点" class="headerlink" title="查看服务的端点"></a>查看服务的端点</h6><p>每当您创建一个服务时，Kubernetes 自动创建相应的 Endpoints 对象。</p>
<p>查看 Endpoints：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get endpoints my-service</span><br></pre></td></tr></table></figure>








<h3 id="了解如何使用入口控制器和入口资源"><a href="#了解如何使用入口控制器和入口资源" class="headerlink" title="了解如何使用入口控制器和入口资源"></a>了解如何使用入口控制器和入口资源</h3><h4 id="理解-Kubernetes-中的-Ingress-控制器和-Ingress-资源"><a href="#理解-Kubernetes-中的-Ingress-控制器和-Ingress-资源" class="headerlink" title="理解 Kubernetes 中的 Ingress 控制器和 Ingress 资源"></a>理解 Kubernetes 中的 Ingress 控制器和 Ingress 资源</h4><p>Kubernetes 的 Ingress 是管理外部访问集群内服务的 API 对象，提供 HTTP 和 HTTPS 路由规则。Ingress 控制器则负责实现 Ingress，通常是一个负载均衡器。</p>
<h5 id="1-Ingress-控制器"><a href="#1-Ingress-控制器" class="headerlink" title="1. Ingress 控制器"></a>1. Ingress 控制器</h5><ul>
<li><strong>定义</strong>：Ingress 控制器是一种守护进程，它监视集群的 Ingress 资源，并根据定义的规则，更新负载均衡器的配置。</li>
<li><strong>常见的 Ingress 控制器</strong>：包括 Nginx Ingress、Traefik、HAProxy 等。</li>
</ul>
<h6 id="安装-Ingress-控制器"><a href="#安装-Ingress-控制器" class="headerlink" title="安装 Ingress 控制器"></a>安装 Ingress 控制器</h6><p>以 Nginx Ingress 控制器为例，安装步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 Helm 安装 Nginx Ingress 控制器</span></span><br><span class="line">helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-nginx ingress-nginx/ingress-nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令添加了 Nginx Ingress 控制器的 Helm 仓库，更新了仓库列表，并安装了 Ingress 控制器。</li>
</ul>
<h5 id="2-Ingress-资源"><a href="#2-Ingress-资源" class="headerlink" title="2. Ingress 资源"></a>2. Ingress 资源</h5><ul>
<li><strong>定义</strong>：Ingress 资源是一个描述路由规则集合的对象，以便外部用户可以访问 Kubernetes 集群内的服务。</li>
</ul>
<h6 id="创建-Ingress-资源"><a href="#创建-Ingress-资源" class="headerlink" title="创建 Ingress 资源"></a>创建 Ingress 资源</h6><p>创建一个 Ingress 资源以定义外部访问的规则。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my-ingress.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个 Ingress 资源为 <code>www.example.com</code> 创建了路由规则，将所有到根路径 <code>/</code> 的请求路由到名为 <code>my-service</code> 的服务的 80 端口。</li>
</ul>
<p>应用 Ingress 资源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f my-ingress.yaml</span><br></pre></td></tr></table></figure>

<h5 id="3-测试-Ingress-路由"><a href="#3-测试-Ingress-路由" class="headerlink" title="3. 测试 Ingress 路由"></a>3. 测试 Ingress 路由</h5><p>一旦 Ingress 资源被应用，可以通过配置的域名来测试访问。</p>
<ul>
<li>使用 <code>curl</code> 或浏览器访问 <code>http://www.example.com</code>。</li>
<li>确保您的 DNS 设置或 <code>/etc/hosts</code> 文件已经正确配置以解析域名。</li>
</ul>
<h5 id="4-配置-TLS-SSL"><a href="#4-配置-TLS-SSL" class="headerlink" title="4. 配置 TLS/SSL"></a>4. 配置 TLS/SSL</h5><p>为了启用 HTTPS，需要在 Ingress 资源中添加 TLS 相关的配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加到 my-ingress.yaml</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">example-tls</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>secretName</code> 引用了一个包含 TLS 证书和私钥的 Kubernetes Secret。</li>
</ul>
<p>创建 Secret：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls example-tls --cert=path/to/cert/file --key=path/to/key/file</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令创建了一个包含 TLS 证书和私钥的 Secret，供 Ingress 控制器使用。</li>
</ul>
<h3 id="了解如何配置和使用CoreDNS"><a href="#了解如何配置和使用CoreDNS" class="headerlink" title="了解如何配置和使用CoreDNS"></a>了解如何配置和使用CoreDNS</h3><h4 id="理解-Kubernetes-中如何配置和使用-CoreDNS"><a href="#理解-Kubernetes-中如何配置和使用-CoreDNS" class="headerlink" title="理解 Kubernetes 中如何配置和使用 CoreDNS"></a>理解 Kubernetes 中如何配置和使用 CoreDNS</h4><p>CoreDNS 是 Kubernetes 集群中的标准 DNS 服务器，用于 DNS 名称解析和服务发现。它是集群内部的重要组件，允许 Pods 通过服务名进行通信。</p>
<h5 id="1-CoreDNS-概述"><a href="#1-CoreDNS-概述" class="headerlink" title="1. CoreDNS 概述"></a>1. CoreDNS 概述</h5><ul>
<li><strong>作用</strong>：CoreDNS 在 Kubernetes 集群中提供命名解析服务，允许 Pods 相互发现并通过服务名进行通信。</li>
<li><strong>部署</strong>：在使用 kubeadm 创建集群时，CoreDNS 通常作为一个自动部署的插件启动。</li>
</ul>
<h5 id="2-验证-CoreDNS-运行状态"><a href="#2-验证-CoreDNS-运行状态" class="headerlink" title="2. 验证 CoreDNS 运行状态"></a>2. 验证 CoreDNS 运行状态</h5><p>确保 CoreDNS Pod 正在运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令列出了 <code>kube-system</code> 命名空间下的所有 Pods，包括 CoreDNS。</li>
</ul>
<h5 id="3-配置-CoreDNS"><a href="#3-配置-CoreDNS" class="headerlink" title="3. 配置 CoreDNS"></a>3. 配置 CoreDNS</h5><p>CoreDNS 的配置可以通过 ConfigMap 来修改。</p>
<h6 id="查看当前-CoreDNS-配置"><a href="#查看当前-CoreDNS-配置" class="headerlink" title="查看当前 CoreDNS 配置"></a>查看当前 CoreDNS 配置</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get configmap coredns -n kube-system -o yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>此命令获取当前的 CoreDNS 配置。</li>
</ul>
<h6 id="修改-CoreDNS-配置"><a href="#修改-CoreDNS-配置" class="headerlink" title="修改 CoreDNS 配置"></a>修改 CoreDNS 配置</h6><p>若要修改配置，先将 ConfigMap 导出到一个文件中，进行修改后再应用更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get configmap coredns -n kube-system -o yaml &gt; coredns-config.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>coredns-config.yaml</code> 文件以更改 DNS 解析规则或添加新的插件。</li>
</ul>
<p>应用更新的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f coredns-config.yaml</span><br></pre></td></tr></table></figure>

<h5 id="4-使用-CoreDNS-进行服务发现"><a href="#4-使用-CoreDNS-进行服务发现" class="headerlink" title="4. 使用 CoreDNS 进行服务发现"></a>4. 使用 CoreDNS 进行服务发现</h5><p>在 Kubernetes 集群中，可以通过服务名进行 DNS 查询，CoreDNS 会解析这些服务名到相应的 IP 地址。</p>
<h6 id="示例：解析服务名"><a href="#示例：解析服务名" class="headerlink" title="示例：解析服务名"></a>示例：解析服务名</h6><p>如果集群中有一个名为 <code>my-service</code> 的服务，在任何 Pod 内部可以通过 <code>my-service</code> 进行 DNS 查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup my-service</span><br></pre></td></tr></table></figure>

<ul>
<li>这将返回 <code>my-service</code> 的集群内部 IP 地址。</li>
</ul>
<h5 id="5-高级配置：自定义-DNS-规则"><a href="#5-高级配置：自定义-DNS-规则" class="headerlink" title="5. 高级配置：自定义 DNS 规则"></a>5. 高级配置：自定义 DNS 规则</h5><p>通过修改 CoreDNS 的 ConfigMap，可以添加自定义的 DNS 规则，例如重定向特定的域名到指定的 IP 地址。</p>
<p>在 <code>coredns-config.yaml</code> 中添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">Corefile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    .:53 &#123;</span></span><br><span class="line"><span class="string">        # 现有的配置...</span></span><br><span class="line"><span class="string">        rewrite name example.com my-service.default.svc.cluster.local</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个配置将 <code>example.com</code> 的 DNS 请求重写到内部服务 <code>my-service</code>。</li>
</ul>
<p>应用更新的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f coredns-config.yaml</span><br></pre></td></tr></table></figure>






<h3 id="选择适当的容器网络接口插件"><a href="#选择适当的容器网络接口插件" class="headerlink" title="选择适当的容器网络接口插件"></a>选择适当的容器网络接口插件</h3><h4 id="选择-Kubernetes-的适当容器网络接口-CNI-插件"><a href="#选择-Kubernetes-的适当容器网络接口-CNI-插件" class="headerlink" title="选择 Kubernetes 的适当容器网络接口 (CNI) 插件"></a>选择 Kubernetes 的适当容器网络接口 (CNI) 插件</h4><p>在 Kubernetes 中，容器网络接口 (CNI) 插件负责在 Pod 之间建立网络连接。选择合适的 CNI 插件对于集群的网络性能和可靠性至关重要。</p>
<h5 id="1-了解常见的-CNI-插件"><a href="#1-了解常见的-CNI-插件" class="headerlink" title="1. 了解常见的 CNI 插件"></a>1. 了解常见的 CNI 插件</h5><ul>
<li><strong>Calico</strong>: 提供了丰富的网络安全策略选项，适合需要高级网络策略的场景。</li>
<li><strong>Flannel</strong>: 简单易用，适合初学者或小型集群。</li>
<li><strong>Weave Net</strong>: 提供了自动网络拓扑发现和管理，适合动态或变化的环境。</li>
<li><strong>Cilium</strong>: 使用 BPF 来提供网络安全，适合需要高性能和高安全的场景。</li>
</ul>
<h5 id="2-考虑选择-CNI-插件的因素"><a href="#2-考虑选择-CNI-插件的因素" class="headerlink" title="2. 考虑选择 CNI 插件的因素"></a>2. 考虑选择 CNI 插件的因素</h5><ul>
<li><strong>网络性能</strong>: 选择能够满足应用带宽和延迟要求的 CNI。</li>
<li><strong>安全需求</strong>: 如果需要复杂的网络策略和隔离，选择支持这些功能的 CNI。</li>
<li><strong>易用性和社区支持</strong>: 选择有良好文档和社区支持的 CNI，尤其是在初次部署 Kubernetes 时。</li>
<li><strong>集群规模和复杂性</strong>: 对于大型或复杂的集群，选择能够提供高级网络功能的 CNI。</li>
</ul>
<h5 id="3-安装-CNI-插件"><a href="#3-安装-CNI-插件" class="headerlink" title="3. 安装 CNI 插件"></a>3. 安装 CNI 插件</h5><p>以下步骤演示了如何安装 Calico 作为示例。</p>
<h6 id="安装-Calico"><a href="#安装-Calico" class="headerlink" title="安装 Calico"></a>安装 Calico</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令从 Calico 的官方文档中下载并应用了 Calico 的配置文件。</li>
<li>安装过程将在集群中创建所需的 DaemonSet、Deployment、ConfigMap 等资源。</li>
</ul>
<h5 id="4-验证-CNI-插件的安装"><a href="#4-验证-CNI-插件的安装" class="headerlink" title="4. 验证 CNI 插件的安装"></a>4. 验证 CNI 插件的安装</h5><p>安装完成后，您需要验证 CNI 插件是否正确运行。</p>
<h6 id="检查-Pod-状态"><a href="#检查-Pod-状态" class="headerlink" title="检查 Pod 状态"></a>检查 Pod 状态</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令列出了 <code>kube-system</code> 命名空间下的所有 Pods，包括 CNI 插件的 Pods。</li>
<li>确保相关的 Pods 状态为 <code>Running</code>。</li>
</ul>
<h5 id="5-调试网络问题"><a href="#5-调试网络问题" class="headerlink" title="5. 调试网络问题"></a>5. 调试网络问题</h5><p>如果遇到网络问题，您可能需要检查 CNI 插件的日志和配置。</p>
<h6 id="查看-CNI-日志"><a href="#查看-CNI-日志" class="headerlink" title="查看 CNI 日志"></a>查看 CNI 日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs -n kube-system &lt;calico-pod-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;calico-pod-name&gt;</code> 是 Calico Pod 的名称。</li>
<li>这个命令将显示 Calico Pod 的日志，有助于诊断网络问题。</li>
</ul>
<h2 id="存储（10-）"><a href="#存储（10-）" class="headerlink" title="存储（10%）"></a>存储（10%）</h2><h3 id="了解存储类、持久卷"><a href="#了解存储类、持久卷" class="headerlink" title="了解存储类、持久卷"></a>了解存储类、持久卷</h3><h4 id="理解-Kubernetes-中的存储类-StorageClass-和持久卷-Persistent-Volume"><a href="#理解-Kubernetes-中的存储类-StorageClass-和持久卷-Persistent-Volume" class="headerlink" title="理解 Kubernetes 中的存储类 (StorageClass) 和持久卷 (Persistent Volume)"></a>理解 Kubernetes 中的存储类 (StorageClass) 和持久卷 (Persistent Volume)</h4><p>在 Kubernetes 中，存储类 (StorageClass) 和持久卷 (Persistent Volume, PV) 提供了一种方式来存储和管理持久化数据。</p>
<h5 id="1-存储类-StorageClass"><a href="#1-存储类-StorageClass" class="headerlink" title="1. 存储类 (StorageClass)"></a>1. 存储类 (StorageClass)</h5><ul>
<li><strong>定义</strong>：存储类提供了一种描述存储的类型和配置的方法，它使管理员能够定义存储的类别。</li>
<li><strong>作用</strong>：存储类用于动态地配置和提供持久卷。</li>
</ul>
<h6 id="创建-StorageClass"><a href="#创建-StorageClass" class="headerlink" title="创建 StorageClass"></a>创建 StorageClass</h6><p>例如，创建一个基于 AWS EBS 的存储类：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aws-storageclass.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-aws-storageclass</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/aws-ebs</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">gp2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>provisioner</code> 指定了用于创建卷的插件。</li>
<li><code>parameters</code> 中定义了特定于存储提供者的配置。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f aws-storageclass.yaml</span><br></pre></td></tr></table></figure>

<h5 id="2-持久卷-Persistent-Volume-PV"><a href="#2-持久卷-Persistent-Volume-PV" class="headerlink" title="2. 持久卷 (Persistent Volume, PV)"></a>2. 持久卷 (Persistent Volume, PV)</h5><ul>
<li><strong>定义</strong>：持久卷是一种由管理员预先配置的存储资源，或者由存储类动态配置的资源。</li>
<li><strong>作用</strong>：PV 提供应用程序使用的存储资源。</li>
</ul>
<h6 id="创建-Persistent-Volume"><a href="#创建-Persistent-Volume" class="headerlink" title="创建 Persistent Volume"></a>创建 Persistent Volume</h6><p>假设您有一个预先存在的网络存储系统，如 NFS，您可以创建一个指向这个 NFS 服务器的 PV。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs-persistentvolume.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nfs-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">nfs-server.example.com</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>capacity</code> 定义了卷的大小。</li>
<li><code>accessModes</code> 定义了卷支持的访问模式。</li>
<li><code>nfs</code> 指定了 NFS 服务器的地址和路径。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nfs-persistentvolume.yaml</span><br></pre></td></tr></table></figure>

<h5 id="3-持久卷声明-Persistent-Volume-Claim-PVC"><a href="#3-持久卷声明-Persistent-Volume-Claim-PVC" class="headerlink" title="3. 持久卷声明 (Persistent Volume Claim, PVC)"></a>3. 持久卷声明 (Persistent Volume Claim, PVC)</h5><ul>
<li><strong>定义</strong>：PVC 是用户对存储资源的请求。</li>
<li><strong>作用</strong>：PVC 让用户可以请求特定大小和访问模式的存储资源。</li>
</ul>
<h6 id="创建-Persistent-Volume-Claim"><a href="#创建-Persistent-Volume-Claim" class="headerlink" title="创建 Persistent Volume Claim"></a>创建 Persistent Volume Claim</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">my-aws-storageclass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>accessModes</code> 和 <code>resources</code> 指定了请求的存储类型和大小。</li>
<li><code>storageClassName</code> 引用了之前定义的存储类。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pvc.yaml</span><br></pre></td></tr></table></figure>



<h3 id="了解卷模式、访问模式和卷回收策略"><a href="#了解卷模式、访问模式和卷回收策略" class="headerlink" title="了解卷模式、访问模式和卷回收策略"></a>了解卷模式、访问模式和卷回收策略</h3><h4 id="理解-Kubernetes-的卷模式、访问模式和卷回收策略"><a href="#理解-Kubernetes-的卷模式、访问模式和卷回收策略" class="headerlink" title="理解 Kubernetes 的卷模式、访问模式和卷回收策略"></a>理解 Kubernetes 的卷模式、访问模式和卷回收策略</h4><p>在 Kubernetes 中，了解卷（Volume）的不同模式、访问模式和回收策略对于正确配置和管理存储至关重要。</p>
<h5 id="1-卷模式"><a href="#1-卷模式" class="headerlink" title="1. 卷模式"></a>1. 卷模式</h5><ul>
<li><strong>定义</strong>：卷模式定义了持久卷 (Persistent Volume, PV) 如何被暴露给 Pod。</li>
<li><strong>类型</strong>：<ul>
<li><strong>Filesystem</strong>：默认模式，PV 以文件系统的形式挂载到 Pod 上。</li>
<li><strong>Block</strong>：PV 以原始块设备的形式挂载到 Pod 上。</li>
</ul>
</li>
</ul>
<h6 id="创建具有特定卷模式的-PV"><a href="#创建具有特定卷模式的-PV" class="headerlink" title="创建具有特定卷模式的 PV"></a>创建具有特定卷模式的 PV</h6><p>创建一个以文件系统模式挂载的 NFS 持久卷示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs-pv-filesystem.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nfs-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">nfs-server.example.com</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>volumeMode: Filesystem</code> 指定了卷模式为文件系统。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nfs-pv-filesystem.yaml</span><br></pre></td></tr></table></figure>

<h5 id="2-访问模式"><a href="#2-访问模式" class="headerlink" title="2. 访问模式"></a>2. 访问模式</h5><ul>
<li><strong>定义</strong>：访问模式定义了 PV 被 Pod 访问的方式。</li>
<li><strong>类型</strong>：<ul>
<li>**ReadWriteOnce (RWO)**：卷可以被一个节点以读写的方式挂载。</li>
<li>**ReadOnlyMany (ROX)**：卷可以被多个节点以只读的方式挂载。</li>
<li>**ReadWriteMany (RWX)**：卷可以被多个节点以读写的方式挂载。</li>
</ul>
</li>
</ul>
<h6 id="指定访问模式的-PVC"><a href="#指定访问模式的-PVC" class="headerlink" title="指定访问模式的 PVC"></a>指定访问模式的 PVC</h6><p>创建一个请求 RWX 访问模式的 PVC：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvc-rwx.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>accessModes: - ReadWriteMany</code> 指定 PVC 请求 RWX 访问模式。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pvc-rwx.yaml</span><br></pre></td></tr></table></figure>

<h5 id="3-卷回收策略"><a href="#3-卷回收策略" class="headerlink" title="3. 卷回收策略"></a>3. 卷回收策略</h5><ul>
<li><strong>定义</strong>：回收策略定义了在 PVC 被删除时，与之相关联的 PV 的处理方式。</li>
<li><strong>类型</strong>：<ul>
<li><strong>Retain</strong>：保留 PV，即使 PVC 被删除，PV 也不会被自动删除。</li>
<li><strong>Delete</strong>：删除 PV，当 PVC 被删除时，PV 和外部存储上的数据也会被删除。</li>
<li><strong>Recycle</strong>：废弃（在大多数新版本的 Kubernetes 中不再支持）。</li>
</ul>
</li>
</ul>
<h6 id="指定回收策略的-PV"><a href="#指定回收策略的-PV" class="headerlink" title="指定回收策略的 PV"></a>指定回收策略的 PV</h6><p>创建一个具有特定回收策略的 PV：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pv-retain.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/mnt/data&quot;</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>persistentVolumeReclaimPolicy: Retain</code> 指定了 PV 的回收策略为保留。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pv-retain.yaml</span><br></pre></td></tr></table></figure>



<h3 id="理解持久容量声明原语"><a href="#理解持久容量声明原语" class="headerlink" title="理解持久容量声明原语"></a>理解持久容量声明原语</h3><h4 id="理解-Kubernetes-中的持久卷声明-Persistent-Volume-Claim-PVC-原语"><a href="#理解-Kubernetes-中的持久卷声明-Persistent-Volume-Claim-PVC-原语" class="headerlink" title="理解 Kubernetes 中的持久卷声明 (Persistent Volume Claim, PVC) 原语"></a>理解 Kubernetes 中的持久卷声明 (Persistent Volume Claim, PVC) 原语</h4><p>在 Kubernetes 中，持久卷声明 (PVC) 是一种原语，用于从用户的角度申请存储资源。PVC 与持久卷 (PV) 相关联，它抽象了底层存储细节，使用户能够轻松请求所需大小和访问模式的存储。</p>
<h5 id="1-持久卷声明的作用"><a href="#1-持久卷声明的作用" class="headerlink" title="1. 持久卷声明的作用"></a>1. 持久卷声明的作用</h5><ul>
<li><strong>定义</strong>：PVC 是对存储的一种声明式请求，它描述了所需的存储大小和访问模式。</li>
<li><strong>与 PV 的关系</strong>：PVC 与 PV 之间的绑定允许 Pods 使用存储资源而无需关心具体的存储细节。</li>
</ul>
<h5 id="2-创建-PVC"><a href="#2-创建-PVC" class="headerlink" title="2. 创建 PVC"></a>2. 创建 PVC</h5><p>创建 PVC 的过程包括定义 PVC 的大小、访问模式和可选的存储类。</p>
<h6 id="示例-PVC-定义"><a href="#示例-PVC-定义" class="headerlink" title="示例 PVC 定义"></a>示例 PVC 定义</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>accessModes</code> 指定了 PVC 的访问模式。</li>
<li><code>resources.requests.storage</code> 指定了所请求的存储大小。</li>
</ul>
<p>应用 PVC：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f my-pvc.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这条命令创建了一个名为 <code>my-pvc</code> 的持久卷声明。</li>
</ul>
<h5 id="3-使用-PVC"><a href="#3-使用-PVC" class="headerlink" title="3. 使用 PVC"></a>3. 使用 PVC</h5><p>在 Pod 定义中引用 PVC 以使用分配的存储资源。</p>
<h6 id="示例-Pod-使用-PVC"><a href="#示例-Pod-使用-PVC" class="headerlink" title="示例 Pod 使用 PVC"></a>示例 Pod 使用 PVC</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pod-using-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/var/www/html&quot;</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-storage</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-storage</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">my-pvc</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>volumeMounts</code> 指定了挂载卷的路径。</li>
<li><code>volumes.persistentVolumeClaim.claimName</code> 引用了 PVC 的名称。</li>
</ul>
<p>应用 Pod 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-using-pvc.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令将创建一个使用 <code>my-pvc</code> PVC 的 Pod。</li>
</ul>
<h5 id="4-监控-PVC-状态"><a href="#4-监控-PVC-状态" class="headerlink" title="4. 监控 PVC 状态"></a>4. 监控 PVC 状态</h5><p>一旦 PVC 创建，可以监控其状态，确保它已成功绑定到 PV。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pvc my-pvc</span><br></pre></td></tr></table></figure>

<ul>
<li>这条命令显示了 <code>my-pvc</code> 的状态，包括是否已经成功绑定到一个 PV。</li>
</ul>
<h3 id="了解如何配置具有持久性存储的应用程序"><a href="#了解如何配置具有持久性存储的应用程序" class="headerlink" title="了解如何配置具有持久性存储的应用程序"></a>了解如何配置具有持久性存储的应用程序</h3><h4 id="配置-Kubernetes-中具有持久性存储的应用程序"><a href="#配置-Kubernetes-中具有持久性存储的应用程序" class="headerlink" title="配置 Kubernetes 中具有持久性存储的应用程序"></a>配置 Kubernetes 中具有持久性存储的应用程序</h4><p>在 Kubernetes 中配置具有持久性存储的应用程序涉及几个关键步骤：创建持久卷 (PV)、创建持久卷声明 (PVC)、配置应用程序以使用这些卷。</p>
<h5 id="1-创建持久卷-PV"><a href="#1-创建持久卷-PV" class="headerlink" title="1. 创建持久卷 (PV)"></a>1. 创建持久卷 (PV)</h5><ul>
<li><strong>定义</strong>：持久卷是一种集群级别的资源，它封装了存储的细节，可以被 Pod 使用。</li>
<li><strong>步骤</strong>：创建一个 PV，指定存储大小、访问模式和存储类型。</li>
</ul>
<h6 id="示例：创建-NFS-类型的-PV"><a href="#示例：创建-NFS-类型的-PV" class="headerlink" title="示例：创建 NFS 类型的 PV"></a>示例：创建 NFS 类型的 PV</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs-pv.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nfs-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">nfs-server.example.com</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/mnt/data&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>capacity.storage</code> 指定了存储的大小。</li>
<li><code>accessModes</code> 指定了 PV 的访问模式。</li>
<li><code>nfs</code> 指定了 NFS 服务器的地址和路径。</li>
</ul>
<p>应用配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nfs-pv.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令将创建一个指向 NFS 服务器的持久卷。</li>
</ul>
<h5 id="2-创建持久卷声明-PVC"><a href="#2-创建持久卷声明-PVC" class="headerlink" title="2. 创建持久卷声明 (PVC)"></a>2. 创建持久卷声明 (PVC)</h5><ul>
<li><strong>定义</strong>：PVC 是对 PV 的声明性请求，它指定了存储的大小和访问模式。</li>
<li><strong>步骤</strong>：创建一个 PVC，指定请求的存储大小和访问模式。</li>
</ul>
<h6 id="示例：创建-PVC"><a href="#示例：创建-PVC" class="headerlink" title="示例：创建 PVC"></a>示例：创建 PVC</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>spec.accessModes</code> 和 <code>spec.resources.requests.storage</code> 分别指定了 PVC 的访问模式和请求的存储大小。</li>
</ul>
<p>应用 PVC：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f my-pvc.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令创建了一个 PVC，它将寻找一个匹配其请求的 PV 并绑定。</li>
</ul>
<h5 id="3-在应用程序中使用-PVC"><a href="#3-在应用程序中使用-PVC" class="headerlink" title="3. 在应用程序中使用 PVC"></a>3. 在应用程序中使用 PVC</h5><ul>
<li><strong>步骤</strong>：在应用程序的 Pod 定义中引用 PVC 作为卷。</li>
</ul>
<h6 id="示例：配置应用程序使用-PVC"><a href="#示例：配置应用程序使用-PVC" class="headerlink" title="示例：配置应用程序使用 PVC"></a>示例：配置应用程序使用 PVC</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app-deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">my-pvc</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>volumeMounts</code> 指定了在容器内挂载卷的路径。</li>
<li><code>volumes</code> 中的 <code>persistentVolumeClaim.claimName</code> 引用了 PVC。</li>
</ul>
<p>应用部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f app-deployment.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令创建了一个部署，其中的 Pod 使用 PVC 作为存储。</li>
</ul>
<h2 id="故障排除（30-）"><a href="#故障排除（30-）" class="headerlink" title="故障排除（30%）"></a>故障排除（30%）</h2><h3 id="评估集群和节点日志"><a href="#评估集群和节点日志" class="headerlink" title="评估集群和节点日志"></a>评估集群和节点日志</h3><h4 id="评估-Kubernetes-集群和节点日志"><a href="#评估-Kubernetes-集群和节点日志" class="headerlink" title="评估 Kubernetes 集群和节点日志"></a>评估 Kubernetes 集群和节点日志</h4><p>在 Kubernetes 中，有效地评估集群和节点的日志是关键的运维活动，它帮助您诊断问题、监控集群健康状况以及优化性能。</p>
<h5 id="1-获取集群日志"><a href="#1-获取集群日志" class="headerlink" title="1. 获取集群日志"></a>1. 获取集群日志</h5><ul>
<li><strong>定义</strong>：集群日志包括 Kubernetes 控制平面组件的日志，例如 kube-apiserver、kube-scheduler 和 kube-controller-manager。</li>
</ul>
<h6 id="示例：获取控制平面组件的日志"><a href="#示例：获取控制平面组件的日志" class="headerlink" title="示例：获取控制平面组件的日志"></a>示例：获取控制平面组件的日志</h6><p>假设控制平面组件运行在 Master 节点上，您可以直接通过 SSH 登录到 Master 节点来获取这些日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录到 Master 节点</span></span><br><span class="line">ssh user@master-node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 kube-apiserver 日志</span></span><br><span class="line">sudo journalctl -u kube-apiserver</span><br></pre></td></tr></table></figure>

<ul>
<li><code>journalctl -u kube-apiserver</code> 显示 kube-apiserver 服务的日志。</li>
</ul>
<h5 id="2-获取节点日志"><a href="#2-获取节点日志" class="headerlink" title="2. 获取节点日志"></a>2. 获取节点日志</h5><ul>
<li><strong>定义</strong>：节点日志包括 kubelet 和容器运行时（如 Docker）的日志。</li>
</ul>
<h6 id="示例：获取-kubelet-日志"><a href="#示例：获取-kubelet-日志" class="headerlink" title="示例：获取 kubelet 日志"></a>示例：获取 kubelet 日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录到工作节点</span></span><br><span class="line">ssh user@worker-node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 kubelet 日志</span></span><br><span class="line">sudo journalctl -u kubelet</span><br></pre></td></tr></table></figure>

<ul>
<li><code>journalctl -u kubelet</code> 显示 kubelet 服务的日志。</li>
</ul>
<h5 id="3-获取-Pod-日志"><a href="#3-获取-Pod-日志" class="headerlink" title="3. 获取 Pod 日志"></a>3. 获取 Pod 日志</h5><ul>
<li><strong>步骤</strong>：使用 <code>kubectl logs</code> 命令来获取特定 Pod 的日志。</li>
</ul>
<h6 id="示例：获取-Pod-日志"><a href="#示例：获取-Pod-日志" class="headerlink" title="示例：获取 Pod 日志"></a>示例：获取 Pod 日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;pod-name&gt;</code> 是要获取日志的 Pod 名称。</li>
<li><code>-n &lt;namespace&gt;</code> 指定 Pod 所在的命名空间，如果 Pod 在默认命名空间，则可以省略这部分。</li>
</ul>
<h5 id="4-使用日志收集工具"><a href="#4-使用日志收集工具" class="headerlink" title="4. 使用日志收集工具"></a>4. 使用日志收集工具</h5><ul>
<li><strong>定义</strong>：对于大型集群或生产环境，推荐使用日志收集和聚合工具，如 ELK 栈（Elasticsearch、Logstash、Kibana）或 Fluentd。</li>
</ul>
<h6 id="示例：使用-Fluentd-收集日志"><a href="#示例：使用-Fluentd-收集日志" class="headerlink" title="示例：使用 Fluentd 收集日志"></a>示例：使用 Fluentd 收集日志</h6><ol>
<li><p><strong>部署 Fluentd</strong>：在集群中部署 Fluentd 以收集日志。</p>
<p>使用 Helm 安装 Fluentd：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add fluent https://fluent.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-fluentd fluent/fluentd</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>配置 Fluentd</strong>：配置 Fluentd 以将日志转发到日志存储/分析系统，如 Elasticsearch。</p>
</li>
<li><p><strong>查看和分析日志</strong>：使用日志分析工具，如 Kibana，来查看和分析日志。</p>
</li>
</ol>
<h5 id="5-定期检查和监控日志"><a href="#5-定期检查和监控日志" class="headerlink" title="5. 定期检查和监控日志"></a>5. 定期检查和监控日志</h5><ul>
<li><strong>重要性</strong>：定期检查集群和节点的日志对于早期发现问题至关重要。考虑设置日志监控和警报机制。</li>
</ul>
<h3 id="了解如何监视应用程序"><a href="#了解如何监视应用程序" class="headerlink" title="了解如何监视应用程序"></a>了解如何监视应用程序</h3><h4 id="监视-Kubernetes-中的应用程序"><a href="#监视-Kubernetes-中的应用程序" class="headerlink" title="监视 Kubernetes 中的应用程序"></a>监视 Kubernetes 中的应用程序</h4><p>在 Kubernetes 中，监视应用程序涉及收集和分析各种指标，如性能、资源使用情况、网络流量等。这通常通过一系列工具和服务来实现。</p>
<h5 id="1-使用-Prometheus-和-Grafana-监视应用程序"><a href="#1-使用-Prometheus-和-Grafana-监视应用程序" class="headerlink" title="1. 使用 Prometheus 和 Grafana 监视应用程序"></a>1. 使用 Prometheus 和 Grafana 监视应用程序</h5><ul>
<li><strong>Prometheus</strong>：是一个开源监控系统，广泛用于收集和存储应用程序和集群的性能指标。</li>
<li><strong>Grafana</strong>：是一个开源的指标分析和可视化工具，经常与 Prometheus 配合使用。</li>
</ul>
<h6 id="安装-Prometheus-和-Grafana"><a href="#安装-Prometheus-和-Grafana" class="headerlink" title="安装 Prometheus 和 Grafana"></a>安装 Prometheus 和 Grafana</h6><ol>
<li><strong>部署 Prometheus</strong>：使用 Helm 安装 Prometheus。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-prometheus prometheus-community/prometheus</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令将 Prometheus 添加到 Helm 仓库，然后安装它。</li>
</ul>
<ol start="2">
<li><strong>部署 Grafana</strong>：使用 Helm 安装 Grafana。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add grafana https://grafana.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-grafana grafana/grafana</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令将 Grafana 添加到 Helm 仓库，然后安装它。</li>
</ul>
<h5 id="2-配置-Prometheus-以监视应用程序"><a href="#2-配置-Prometheus-以监视应用程序" class="headerlink" title="2. 配置 Prometheus 以监视应用程序"></a>2. 配置 Prometheus 以监视应用程序</h5><ul>
<li><strong>步骤</strong>：配置 Prometheus 以收集应用程序和集群的性能指标。</li>
</ul>
<h6 id="示例：配置-Prometheus-监控目标"><a href="#示例：配置-Prometheus-监控目标" class="headerlink" title="示例：配置 Prometheus 监控目标"></a>示例：配置 Prometheus 监控目标</h6><ol>
<li><strong>编辑 Prometheus 配置</strong>：定位到 Prometheus 的配置文件（通常位于 <code>values.yaml</code>），并添加您的应用程序作为监控目标。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-pods&#x27;</span></span><br><span class="line">    <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">pod</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这段配置使 Prometheus 从所有 Kubernetes Pods 收集指标。</li>
</ul>
<ol start="2">
<li><strong>应用配置更新</strong>：更新 Prometheus 的配置以包含新的监控目标。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade my-prometheus prometheus-community/prometheus -f values.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令将更新 Prometheus 的配置。</li>
</ul>
<h5 id="3-使用-Grafana-可视化监控数据"><a href="#3-使用-Grafana-可视化监控数据" class="headerlink" title="3. 使用 Grafana 可视化监控数据"></a>3. 使用 Grafana 可视化监控数据</h5><ul>
<li><strong>步骤</strong>：使用 Grafana 创建仪表板以可视化收集的监控数据。</li>
</ul>
<h6 id="示例：配置-Grafana-仪表板"><a href="#示例：配置-Grafana-仪表板" class="headerlink" title="示例：配置 Grafana 仪表板"></a>示例：配置 Grafana 仪表板</h6><ol>
<li><strong>登录 Grafana</strong>：首先获取 Grafana 的访问凭证。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret --namespace default my-grafana -o jsonpath=<span class="string">&quot;&#123;.data.admin-password&#125;&quot;</span> | <span class="built_in">base64</span> --decode ; <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令获取 Grafana 管理员密码。</li>
</ul>
<ol start="2">
<li><p><strong>访问 Grafana UI</strong>：在浏览器中访问 Grafana UI 并使用上述凭证登录。</p>
</li>
<li><p><strong>添加 Prometheus 数据源</strong>：在 Grafana 中添加 Prometheus 作为数据源。</p>
</li>
<li><p><strong>创建或导入仪表板</strong>：创建新的仪表板或导入现有的仪表板模板以可视化监控数据。</p>
</li>
</ol>
<h5 id="4-设置警报规则"><a href="#4-设置警报规则" class="headerlink" title="4. 设置警报规则"></a>4. 设置警报规则</h5><ul>
<li><strong>步骤</strong>：在 Prometheus 中设置警报规则，以便在检测到异常行为时发送通知。</li>
</ul>
<h6 id="示例：设置-Prometheus-警报规则"><a href="#示例：设置-Prometheus-警报规则" class="headerlink" title="示例：设置 Prometheus 警报规则"></a>示例：设置 Prometheus 警报规则</h6><ol>
<li><strong>编辑警报规则文件</strong>：在 Prometheus 的配置中添加警报规则。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">localhost:9093</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;alerts.yml&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>定义警报规则</strong>：在 <code>alerts.yml</code> 文件中定义具体的警报条件。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">HighMemoryUsage</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">(node_memory_Active_bytes</span> <span class="string">/</span> <span class="string">node_memory_MemTotal_bytes)</span> <span class="string">&gt;</span> <span class="number">0.8</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">warning</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">High</span> <span class="string">Memory</span> <span class="string">Usage</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个规则定义了内存使用率超过 80% 持续 5 分钟时的</li>
</ul>
<p>警报。</p>
<h3 id="管理容器标准输出和标准错误日志"><a href="#管理容器标准输出和标准错误日志" class="headerlink" title="管理容器标准输出和标准错误日志"></a>管理容器标准输出和标准错误日志</h3><h4 id="管理-Kubernetes-容器的标准输出和标准错误日志"><a href="#管理-Kubernetes-容器的标准输出和标准错误日志" class="headerlink" title="管理 Kubernetes 容器的标准输出和标准错误日志"></a>管理 Kubernetes 容器的标准输出和标准错误日志</h4><p>在 Kubernetes 中，容器的标准输出 (stdout) 和标准错误 (stderr) 日志是诊断容器运行状况的重要信息源。管理这些日志涉及收集、访问和可能的日志转发。</p>
<h5 id="1-访问-Pod-日志"><a href="#1-访问-Pod-日志" class="headerlink" title="1. 访问 Pod 日志"></a>1. 访问 Pod 日志</h5><p>Kubernetes 提供了 <code>kubectl logs</code> 命令来直接访问 Pod 的标准输出和标准错误日志。</p>
<h6 id="获取-Pod-日志"><a href="#获取-Pod-日志" class="headerlink" title="获取 Pod 日志"></a>获取 Pod 日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;pod-name&gt;</code> 是目标 Pod 的名称。</li>
<li>这条命令返回 Pod 中所有容器的日志。</li>
</ul>
<p>如果 Pod 包含多个容器，指定容器名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-c &lt;container-name&gt;</code> 指定要获取日志的容器。</li>
</ul>
<h5 id="2-实时跟踪日志"><a href="#2-实时跟踪日志" class="headerlink" title="2. 实时跟踪日志"></a>2. 实时跟踪日志</h5><p>实时跟踪日志可以帮助您实时监控容器活动。</p>
<h6 id="跟踪-Pod-日志"><a href="#跟踪-Pod-日志" class="headerlink" title="跟踪 Pod 日志"></a>跟踪 Pod 日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs -f &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-f</code> 参数使 <code>kubectl logs</code> 命令以“跟踪”模式运行，类似于 <code>tail -f</code>。</li>
</ul>
<h5 id="3-导出和存储日志"><a href="#3-导出和存储日志" class="headerlink" title="3. 导出和存储日志"></a>3. 导出和存储日志</h5><p>对于长期存储和分析，可能需要将日志导出到文件或日志管理系统。</p>
<h6 id="导出日志到文件"><a href="#导出日志到文件" class="headerlink" title="导出日志到文件"></a>导出日志到文件</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt; &gt; pod-logs.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>这条命令将 Pod 的日志输出重定向到本地文件 <code>pod-logs.txt</code>。</li>
</ul>
<h5 id="4-集成日志收集工具"><a href="#4-集成日志收集工具" class="headerlink" title="4. 集成日志收集工具"></a>4. 集成日志收集工具</h5><p>对于大型集群，建议使用专业的日志收集和管理工具，如 Fluentd、Elasticsearch 和 Kibana（ELK 栈）。</p>
<h6 id="示例：使用-Fluentd-收集日志-1"><a href="#示例：使用-Fluentd-收集日志-1" class="headerlink" title="示例：使用 Fluentd 收集日志"></a>示例：使用 Fluentd 收集日志</h6><ol>
<li><p><strong>部署 Fluentd</strong>：在集群中部署 Fluentd 来收集日志。</p>
<p>使用 Helm 安装 Fluentd：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add fluent https://fluent.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install my-fluentd fluent/fluentd</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令将 Fluentd 添加到 Helm 仓库并安装。</li>
</ul>
</li>
<li><p><strong>配置 Fluentd</strong>：修改 Fluentd 配置以收集并转发日志到日志分析系统。</p>
</li>
</ol>
<h5 id="5-日志轮换和清理"><a href="#5-日志轮换和清理" class="headerlink" title="5. 日志轮换和清理"></a>5. 日志轮换和清理</h5><p>Kubernetes 自动处理容器日志的轮换和清理，以防止日志文件过大。这通常由 kubelet 管理，且其行为可以通过 kubelet 的配置参数进行调整。</p>
<h3 id="解决应用程序故障"><a href="#解决应用程序故障" class="headerlink" title="解决应用程序故障"></a>解决应用程序故障</h3><h4 id="解决-Kubernetes-中应用程序故障"><a href="#解决-Kubernetes-中应用程序故障" class="headerlink" title="解决 Kubernetes 中应用程序故障"></a>解决 Kubernetes 中应用程序故障</h4><p>在 Kubernetes 环境中，应用程序故障可能由多种原因引起，包括配置错误、资源限制、网络问题等。以下是解决应用程序故障的详细步骤和相应操作。</p>
<h5 id="1-检查-Pod-状态"><a href="#1-检查-Pod-状态" class="headerlink" title="1. 检查 Pod 状态"></a>1. 检查 Pod 状态</h5><p>第一步是检查应用程序的 Pod 状态，以确定是否存在明显的错误。</p>
<h6 id="获取-Pod-状态"><a href="#获取-Pod-状态" class="headerlink" title="获取 Pod 状态"></a>获取 Pod 状态</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<ul>
<li>此命令列出所有 Pods，以及它们的状态和重启次数。</li>
</ul>
<p>如果发现 Pod 处于 <code>CrashLoopBackOff</code> 或其他非正常状态，这通常是故障的第一个迹象。</p>
<h5 id="2-查看-Pod-日志"><a href="#2-查看-Pod-日志" class="headerlink" title="2. 查看 Pod 日志"></a>2. 查看 Pod 日志</h5><p>检查 Pod 日志，可以帮助您理解 Pod 为什么失败或表现异常。</p>
<h6 id="获取特定-Pod-的日志"><a href="#获取特定-Pod-的日志" class="headerlink" title="获取特定 Pod 的日志"></a>获取特定 Pod 的日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;pod-name&gt;</code> 是出现问题的 Pod 名称。</li>
<li>这个命令显示了 Pod 的标准输出和标准错误日志。</li>
</ul>
<p>如果 Pod 包含多个容器，需要指定容器名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-c &lt;container-name&gt;</code> 用于指定特定的容器。</li>
</ul>
<h5 id="3-检查-Pod-描述"><a href="#3-检查-Pod-描述" class="headerlink" title="3. 检查 Pod 描述"></a>3. 检查 Pod 描述</h5><p>Pod 描述提供了关于 Pod 配置和状态的更详细信息。</p>
<h6 id="描述-Pod"><a href="#描述-Pod" class="headerlink" title="描述 Pod"></a>描述 Pod</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令提供了关于 Pod 的详细信息，包括事件、配置和状态。</li>
</ul>
<h5 id="4-检查资源限制"><a href="#4-检查资源限制" class="headerlink" title="4. 检查资源限制"></a>4. 检查资源限制</h5><p>资源限制问题（如内存不足）可能导致 Pod 故障。</p>
<h6 id="检查节点资源使用情况"><a href="#检查节点资源使用情况" class="headerlink" title="检查节点资源使用情况"></a>检查节点资源使用情况</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl top nodes</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令显示每个节点的资源使用情况。</li>
</ul>
<h6 id="检查-Pod-资源使用情况"><a href="#检查-Pod-资源使用情况" class="headerlink" title="检查 Pod 资源使用情况"></a>检查 Pod 资源使用情况</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl top pod</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令显示每个 Pod 的资源使用情况。</li>
</ul>
<h5 id="5-检查网络问题"><a href="#5-检查网络问题" class="headerlink" title="5. 检查网络问题"></a>5. 检查网络问题</h5><p>网络配置错误可能导致 Pod 无法通信。</p>
<h6 id="检查服务和入口配置"><a href="#检查服务和入口配置" class="headerlink" title="检查服务和入口配置"></a>检查服务和入口配置</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc</span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令分别列出了服务和入口的配置，帮助您检查是否正确配置了网络访问。</li>
</ul>
<h5 id="6-应用和配置问题"><a href="#6-应用和配置问题" class="headerlink" title="6. 应用和配置问题"></a>6. 应用和配置问题</h5><p>检查应用程序的配置，比如环境变量、配置卷、秘密（Secrets）等。</p>
<h6 id="查看应用配置"><a href="#查看应用配置" class="headerlink" title="查看应用配置"></a>查看应用配置</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get configmap</span><br><span class="line">kubectl get secret</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令帮助您检查应用所依赖的配置和秘密是否正确。</li>
</ul>
<h5 id="7-调试-Pod"><a href="#7-调试-Pod" class="headerlink" title="7. 调试 Pod"></a>7. 调试 Pod</h5><p>如果以上步骤都无法定位问题，您可以尝试进入 Pod 内部进行调试。</p>
<h6 id="进入-Pod-进行调试"><a href="#进入-Pod-进行调试" class="headerlink" title="进入 Pod 进行调试"></a>进入 Pod 进行调试</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod-name&gt; -- /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令允许您进入 Pod 并启动一个交互式 shell。</li>
</ul>
<h3 id="对群集组件故障进行故障排除"><a href="#对群集组件故障进行故障排除" class="headerlink" title="对群集组件故障进行故障排除"></a>对群集组件故障进行故障排除</h3><h4 id="对-Kubernetes-集群组件故障进行故障排除"><a href="#对-Kubernetes-集群组件故障进行故障排除" class="headerlink" title="对 Kubernetes 集群组件故障进行故障排除"></a>对 Kubernetes 集群组件故障进行故障排除</h4><p>在 Kubernetes 环境中，对集群组件（如 kube-apiserver、etcd、kubelet）的故障排除是维护集群稳定性和性能的关键部分。</p>
<h5 id="1-检查-Kubernetes-控制平面组件状态"><a href="#1-检查-Kubernetes-控制平面组件状态" class="headerlink" title="1. 检查 Kubernetes 控制平面组件状态"></a>1. 检查 Kubernetes 控制平面组件状态</h5><p>控制平面组件包括 kube-apiserver、etcd、kube-controller-manager 和 kube-scheduler。这些组件的故障可能导致集群整体问题。</p>
<h6 id="检查控制平面组件状态"><a href="#检查控制平面组件状态" class="headerlink" title="检查控制平面组件状态"></a>检查控制平面组件状态</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br></pre></td></tr></table></figure>

<ul>
<li>此命令显示了 Kubernetes 控制平面组件的健康状况。</li>
</ul>
<h5 id="2-检查-kubelet-状态"><a href="#2-检查-kubelet-状态" class="headerlink" title="2. 检查 kubelet 状态"></a>2. 检查 kubelet 状态</h5><p>kubelet 在每个工作节点上运行，负责启动和管理 Pod。kubelet 故障可能导致节点上的 Pod 问题。</p>
<h6 id="检查特定节点上的-kubelet-状态"><a href="#检查特定节点上的-kubelet-状态" class="headerlink" title="检查特定节点上的 kubelet 状态"></a>检查特定节点上的 kubelet 状态</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;node-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;node-name&gt;</code> 是目标节点的名称。</li>
<li>这个命令提供了关于节点的详细信息，包括 kubelet 的状态和最近的事件。</li>
</ul>
<h5 id="3-查看-Kubernetes-系统日志"><a href="#3-查看-Kubernetes-系统日志" class="headerlink" title="3. 查看 Kubernetes 系统日志"></a>3. 查看 Kubernetes 系统日志</h5><p>系统日志可以提供关于组件故障的详细信息。</p>
<h6 id="查看-kube-apiserver-日志"><a href="#查看-kube-apiserver-日志" class="headerlink" title="查看 kube-apiserver 日志"></a>查看 kube-apiserver 日志</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录到 Master 节点</span></span><br><span class="line">ssh user@master-node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 kube-apiserver 日志</span></span><br><span class="line">sudo journalctl -u kube-apiserver</span><br></pre></td></tr></table></figure>

<ul>
<li>这些命令从 Master 节点的 systemd 日志中获取 kube-apiserver 的日志。</li>
</ul>
<h5 id="4-检查网络连接"><a href="#4-检查网络连接" class="headerlink" title="4. 检查网络连接"></a>4. 检查网络连接</h5><p>Kubernetes 组件之间的网络问题可能导致各种故障。</p>
<h6 id="检查-etcd-集群状态"><a href="#检查-etcd-集群状态" class="headerlink" title="检查 etcd 集群状态"></a>检查 etcd 集群状态</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录到 etcd 节点</span></span><br><span class="line">ssh user@etcd-node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 etcd 集群状态</span></span><br><span class="line">etcdctl cluster-health</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令检查 etcd 集群的健康状况。</li>
</ul>
<h5 id="5-使用-Kubernetes-调试工具"><a href="#5-使用-Kubernetes-调试工具" class="headerlink" title="5. 使用 Kubernetes 调试工具"></a>5. 使用 Kubernetes 调试工具</h5><p>Kubernetes 提供了一些工具来帮助诊断集群问题。</p>
<h6 id="使用-kubectl-debug"><a href="#使用-kubectl-debug" class="headerlink" title="使用 kubectl debug"></a>使用 kubectl debug</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl debug node/&lt;node-name&gt; -it --image=busybox</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令在指定的节点上启动一个临时容器，用于调试。</li>
</ul>
<h5 id="6-检查资源使用情况"><a href="#6-检查资源使用情况" class="headerlink" title="6. 检查资源使用情况"></a>6. 检查资源使用情况</h5><p>资源不足（如 CPU、内存）可能导致 Kubernetes 组件故障。</p>
<h6 id="检查节点资源使用情况-1"><a href="#检查节点资源使用情况-1" class="headerlink" title="检查节点资源使用情况"></a>检查节点资源使用情况</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl top nodes</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令显示每个节点的资源使用情况。</li>
</ul>
<h5 id="7-分析-Kubernetes-事件"><a href="#7-分析-Kubernetes-事件" class="headerlink" title="7. 分析 Kubernetes 事件"></a>7. 分析 Kubernetes 事件</h5><p>Kubernetes 事件可以提供有关集群操作和问题的信息。</p>
<h6 id="获取-Kubernetes-事件"><a href="#获取-Kubernetes-事件" class="headerlink" title="获取 Kubernetes 事件"></a>获取 Kubernetes 事件</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get events --sort-by=<span class="string">&#x27;.lastTimestamp&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令按时间排序显示最近的 Kubernetes 事件。</li>
</ul>
<h3 id="排除网络故障"><a href="#排除网络故障" class="headerlink" title="排除网络故障"></a>排除网络故障</h3><h4 id="排除-Kubernetes-中的网络故障"><a href="#排除-Kubernetes-中的网络故障" class="headerlink" title="排除 Kubernetes 中的网络故障"></a>排除 Kubernetes 中的网络故障</h4><p>在 Kubernetes 中排除网络故障需要对集群的网络架构有深入理解。网络问题可能发生在 Pod 通信、服务暴露或数据流量路由等多个层面。</p>
<h5 id="1-验证网络配置"><a href="#1-验证网络配置" class="headerlink" title="1. 验证网络配置"></a>1. 验证网络配置</h5><ul>
<li><strong>步骤</strong>：首先，确认 Kubernetes 集群的网络配置是否正确，包括网络插件和相关的网络策略。</li>
</ul>
<h6 id="检查网络插件"><a href="#检查网络插件" class="headerlink" title="检查网络插件"></a>检查网络插件</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<ul>
<li>这条命令列出了 <code>kube-system</code> 命名空间下的所有 Pods，包括网络插件的 Pods（如 Calico、Flannel 等）。</li>
<li>确保网络插件的 Pods 状态为 <code>Running</code>。</li>
</ul>
<h5 id="2-测试-Pod-之间的网络通信"><a href="#2-测试-Pod-之间的网络通信" class="headerlink" title="2. 测试 Pod 之间的网络通信"></a>2. 测试 Pod 之间的网络通信</h5><ul>
<li><strong>步骤</strong>：测试不同 Pods 之间的网络通信，确保它们能够相互访问。</li>
</ul>
<h6 id="使用-kubectl-exec-进行测试"><a href="#使用-kubectl-exec-进行测试" class="headerlink" title="使用 kubectl exec 进行测试"></a>使用 <code>kubectl exec</code> 进行测试</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -ti &lt;pod-name&gt; -- ping &lt;destination-pod-ip&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;pod-name&gt;</code> 是进行测试的 Pod 名称。</li>
<li><code>&lt;destination-pod-ip&gt;</code> 是目标 Pod 的 IP 地址。</li>
<li>这条命令使用 ping 测试从一个 Pod 到另一个 Pod 的网络连接。</li>
</ul>
<h5 id="3-检查服务-Service-配置"><a href="#3-检查服务-Service-配置" class="headerlink" title="3. 检查服务 (Service) 配置"></a>3. 检查服务 (Service) 配置</h5><ul>
<li><strong>步骤</strong>：检查服务对象，确保它们正确配置，以允许流量路由到后端 Pods。</li>
</ul>
<h6 id="获取服务详情"><a href="#获取服务详情" class="headerlink" title="获取服务详情"></a>获取服务详情</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe service &lt;service-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;service-name&gt;</code> 是服务的名称。</li>
<li>这条命令提供了服务的详细信息，包括选择器、端口和端点。</li>
</ul>
<h5 id="4-分析网络策略"><a href="#4-分析网络策略" class="headerlink" title="4. 分析网络策略"></a>4. 分析网络策略</h5><ul>
<li><strong>步骤</strong>：检查和分析应用于 Pods 或命名空间的网络策略。</li>
</ul>
<h6 id="获取网络策略列表"><a href="#获取网络策略列表" class="headerlink" title="获取网络策略列表"></a>获取网络策略列表</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get networkpolicies --all-namespaces</span><br></pre></td></tr></table></figure>

<ul>
<li>这条命令列出了所有命名空间中的网络策略。</li>
</ul>
<h5 id="5-使用网络诊断工具"><a href="#5-使用网络诊断工具" class="headerlink" title="5. 使用网络诊断工具"></a>5. 使用网络诊断工具</h5><ul>
<li><strong>步骤</strong>：使用 Kubernetes 网络诊断工具，如 <code>netshoot</code>，帮助诊断网络问题。</li>
</ul>
<h6 id="部署-netshoot-工具"><a href="#部署-netshoot-工具" class="headerlink" title="部署 netshoot 工具"></a>部署 netshoot 工具</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run --generator=run-pod/v1 tmp-shell --<span class="built_in">rm</span> -i --<span class="built_in">tty</span> --image nicolaka/netshoot</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令在集群中临时部署了一个名为 <code>tmp-shell</code> 的 Pod，使用了 <code>netshoot</code> 镜像，这是一个用于网络故障排查的工具集。</li>
</ul>
<p>在 <code>netshoot</code> Pod 内，您可以使用各种网络工具（如 <code>ping</code>、<code>nslookup</code>、<code>traceroute</code>）来测试和诊断网络问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://kalyan-zitiu.github.io">Kalyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章連結: </span><span class="post-copyright-info"><a href="https://kalyan-zitiu.github.io/2023/11/30/K8s/">https://kalyan-zitiu.github.io/2023/11/30/K8s/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 許可協議。轉載請註明來自 <a href="https://kalyan-zitiu.github.io" target="_blank">Kalyan的小书房</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/K8s/">K8s</a></div><div class="post_share"><div class="social-share" data-image="/img/WallPaper%20(53).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/24/saa%E9%A2%98%E5%BA%93/"><img class="prev-cover" src="/img/WallPaper%20(55).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">practise for SAA(updating)</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/22/Bash%20Basic/"><img class="next-cover" src="/img/WallPaper%20(52).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Bash for Begginners</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%A4%B4.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kalyan</div><div class="author-info__description">晚来天欲雪，能饮一杯无</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kalyan-zitiu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.douyin.com/user/MS4wLjABAAAA7q-IFMvdT163sFGcjg26o0XaCDYW4pJOLWdkgoDUz10" target="_blank" title="TikTok"><i class="fa-brands fa-tiktok"></i></a><a class="social-icon" href="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211122041246.jpg" target="_blank" title=""><i class="fa-regular fa-user"></i></a><a class="social-icon" href="https://chat.zitiu.top/" target="_blank" title="ChatGPT"><i class="fa-solid fa-robot"></i></a><a class="social-icon" href="https://auto.kalyan-dao.space/" target="_blank" title="AutoGPT"><i class="fa-solid fa-shuttle-space"></i></a><a class="social-icon" href="https://chat.zhile.io/" target="_blank" title="FakeGPT"><i class="fa-brands fa-kickstarter"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Everybody pay attention, I'm the boss</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CKA"><span class="toc-number">1.</span> <span class="toc-text">CKA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%8825-%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">集群架构，安装和配置（25%）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%88RBAC%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">管理基于角色的访问控制（RBAC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A7%92%E8%89%B2%EF%BC%88Role%EF%BC%89%E5%92%8C%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2%EF%BC%88ClusterRole%EF%BC%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1. 角色（Role）和集群角色（ClusterRole）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A%EF%BC%88RoleBinding%EF%BC%89%E5%92%8C%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A%EF%BC%88ClusterRoleBinding%EF%BC%89"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2. 角色绑定（RoleBinding）和集群角色绑定（ClusterRoleBinding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3. 示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">创建角色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">创建角色绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">创建集群角色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A"><span class="toc-number">1.1.1.3.4.</span> <span class="toc-text">创建集群角色绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Kubeadm%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用Kubeadm安装基本集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Kubeadm-%E5%AE%89%E8%A3%85%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1. Kubeadm 安装概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2. 步骤详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1-%E5%AE%89%E8%A3%85-Docker-%E5%92%8C-Kubeadm"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">步骤 1: 安装 Docker 和 Kubeadm</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">步骤 2: 初始化主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3-%E5%AE%89%E8%A3%85-Pod-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">步骤 3: 安装 Pod 网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4-%E5%B0%86%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">步骤 4: 将工作节点加入集群</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3. 验证集群状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">管理高可用性的Kubernetes集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E9%9B%86%E7%BE%A4%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Kubernetes 高可用性集群关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">实际操作步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">1. 准备环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85-Kubernetes-%E5%92%8C-etcd"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">2. 安装 Kubernetes 和 etcd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">3. 设置负载均衡器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.3.2.4.</span> <span class="toc-text">4. 初始化第一个主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%8A%A0%E5%85%A5%E5%85%B6%E4%BB%96%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.3.2.5.</span> <span class="toc-text">5. 加入其他主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%8A%A0%E5%85%A5%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.3.2.6.</span> <span class="toc-text">6. 加入工作节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E9%AA%8C%E8%AF%81%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.3.2.7.</span> <span class="toc-text">7. 验证和测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%BB%A5%E9%83%A8%E7%BD%B2Kubernetes%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">设置基础架构以部署Kubernetes集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1. 硬件资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">工作节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2. 网络配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3. 操作系统和环境设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%89%E8%A3%85-Kubernetes-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">4. 安装 Kubernetes 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BB%A5-Ubuntu-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.1.4.4.1.</span> <span class="toc-text">示例代码（以 Ubuntu 为例）:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%9D%E5%A7%8B%E5%8C%96-Kubernetes-%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">5. 初始化 Kubernetes 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.1.4.5.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%85%8D%E7%BD%AE-kubectl"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">6. 配置 kubectl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AE%89%E8%A3%85-Pod-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">7. 安装 Pod 网络插件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E5%AE%89%E8%A3%85-Calico%EF%BC%89"><span class="toc-number">1.1.4.7.1.</span> <span class="toc-text">示例代码（安装 Calico）:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%B0%86%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">8. 将工作节点加入集群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Kubeadm%E5%9C%A8Kubernetes%E9%9B%86%E7%BE%A4%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7"><span class="toc-number">1.1.5.</span> <span class="toc-text">使用Kubeadm在Kubernetes集群上执行版本升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%87%E7%BA%A7%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2. 升级步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1-%E5%8D%87%E7%BA%A7-kubeadm"><span class="toc-number">1.1.5.2.1.</span> <span class="toc-text">步骤 1: 升级 kubeadm</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2-%E7%A1%AE%E8%AE%A4%E5%8F%AF%E4%BB%A5%E5%8D%87%E7%BA%A7"><span class="toc-number">1.1.5.2.2.</span> <span class="toc-text">步骤 2: 确认可以升级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3-%E5%8D%87%E7%BA%A7%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.5.2.3.</span> <span class="toc-text">步骤 3: 升级主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4-%E5%8D%87%E7%BA%A7-kubelet-%E5%92%8C-kubectl"><span class="toc-number">1.1.5.2.4.</span> <span class="toc-text">步骤 4: 升级 kubelet 和 kubectl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-5-%E9%AA%8C%E8%AF%81%E4%B8%BB%E8%8A%82%E7%82%B9%E5%8D%87%E7%BA%A7"><span class="toc-number">1.1.5.2.5.</span> <span class="toc-text">步骤 5: 验证主节点升级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-6-%E5%8D%87%E7%BA%A7%E5%85%B6%E4%BB%96%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.5.2.6.</span> <span class="toc-text">步骤 6: 升级其他主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-7-%E5%8D%87%E7%BA%A7%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.5.2.7.</span> <span class="toc-text">步骤 7: 升级工作节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-8-%E9%AA%8C%E8%AF%81%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.5.2.8.</span> <span class="toc-text">步骤 8: 验证集群状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%96%BDetcd%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">实施etcd备份和还原</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#etcd-%E5%A4%87%E4%BB%BD"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">etcd 备份</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A1%AE%E5%AE%9A-etcd-%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">1. 确定 etcd 数据目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-etcdctl-%E5%A4%87%E4%BB%BD"><span class="toc-number">1.1.6.1.2.</span> <span class="toc-text">2. 使用 etcdctl 备份</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E5%A4%87%E4%BB%BD"><span class="toc-number">1.1.6.1.3.</span> <span class="toc-text">3. 验证备份</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#etcd-%E8%BF%98%E5%8E%9F"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">etcd 还原</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%81%9C%E6%AD%A2-kube-apiserver"><span class="toc-number">1.1.6.2.1.</span> <span class="toc-text">1. 停止 kube-apiserver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%98%E5%8E%9F-etcd-%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.6.2.2.</span> <span class="toc-text">2. 还原 etcd 数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9B%B4%E6%96%B0-etcd-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.6.2.3.</span> <span class="toc-text">3. 更新 etcd 的配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8-etcd-%E5%92%8C-kube-apiserver"><span class="toc-number">1.1.6.2.4.</span> <span class="toc-text">4. 重新启动 etcd 和 kube-apiserver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.6.2.5.</span> <span class="toc-text">5. 验证集群状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E5%92%8C%E8%B0%83%E5%BA%A6%EF%BC%8815-%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">工作负载和调度（15%）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%92%8C%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">了解部署以及如何执行滚动更新和回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">部署与滚动更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">1. 创建或更新部署</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">2. 执行滚动更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%9B%91%E6%8E%A7%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.1.1.3.</span> <span class="toc-text">3. 监控更新状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">回滚更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5%E9%83%A8%E7%BD%B2%E7%9A%84%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">1. 检查部署的修订版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9B%9E%E6%BB%9A%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">2. 回滚到指定版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%BB%9A%E7%BB%93%E6%9E%9C"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">3. 验证回滚结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ConfigMaps%E5%92%8CSecrets%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用ConfigMaps和Secrets配置应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ConfigMaps-%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">使用 ConfigMaps 配置应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA-ConfigMap"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">1. 创建 ConfigMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8-Pod-%E4%B8%AD%E4%BD%BF%E7%94%A8-ConfigMap"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">2. 在 Pod 中使用 ConfigMap</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Secrets-%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">使用 Secrets 配置应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA-Secret"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">1. 创建 Secret</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8-Pod-%E4%B8%AD%E4%BD%BF%E7%94%A8-Secret"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">2. 在 Pod 中使用 Secret</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">了解如何扩展应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">手动扩展应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E9%83%A8%E7%BD%B2%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">1. 查看当前部署状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%94%B9-Pods-%E6%95%B0%E9%87%8F"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">2. 手动更改 Pods 数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E6%89%A9%E5%B1%95%E7%BB%93%E6%9E%9C"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">3. 验证扩展结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">自动扩展应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0%E9%83%A8%E7%BD%B2-1"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">1. 创建或更新部署</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA-HPA-%E8%B5%84%E6%BA%90"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">2. 创建 HPA 资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81-HPA"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">3. 验证 HPA</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%9B%91%E6%8E%A7%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C-HPA"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">4. 监控应用程序和 HPA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E3%80%81%E8%87%AA%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.2.4.</span> <span class="toc-text">了解用于创建健壮的、自修复的应用程序部署的原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E9%83%A8%E7%BD%B2%EF%BC%88Deployment%EF%BC%89"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1. 创建部署（Deployment）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">示例部署</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.4.1.2.</span> <span class="toc-text">创建部署</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%EF%BC%88Service%EF%BC%89"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2. 创建服务（Service）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">示例服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.2.2.</span> <span class="toc-text">创建服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E6%96%BD%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">1.2.5.</span> <span class="toc-text">3. 实施健康检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">4. 自动扩展（可选）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-HPA"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">创建 HPA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-HPA-1"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">创建 HPA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8DPod%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">了解资源限制如何影响Pod调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E5%AF%B9-Pod-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">设置资源限制对 Pod 调度的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E5%92%8C%E9%99%90%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">1. 资源请求和限制的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-number">1.2.6.1.2.</span> <span class="toc-text">2. 定义资源请求和限制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-Pod-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.6.1.2.1.</span> <span class="toc-text">示例 Pod 定义</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E5%AF%B9%E8%B0%83%E5%BA%A6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.2.6.1.3.</span> <span class="toc-text">3. 资源限制对调度的影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8-Pod-%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.6.1.4.</span> <span class="toc-text">4. 应用 Pod 资源配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%9B%91%E6%8E%A7-Pod-%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.2.6.1.5.</span> <span class="toc-text">5. 监控 Pod 资源使用情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%B0%83%E6%95%B4%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.6.1.6.</span> <span class="toc-text">6. 调整策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E6%B8%85%E5%8D%95%E7%AE%A1%E7%90%86%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.7.</span> <span class="toc-text">了解清单管理和通用模板工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E6%B8%85%E5%8D%95%E7%AE%A1%E7%90%86%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">理解 Kubernetes 清单管理和通用模板工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Helm%EF%BC%9AKubernetes-%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.2.7.1.1.</span> <span class="toc-text">1. Helm：Kubernetes 的包管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Helm-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.7.1.1.1.</span> <span class="toc-text">Helm 的基本用法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Kustomize%EF%BC%9AKubernetes-%E7%9A%84%E5%8E%9F%E7%94%9F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.7.1.2.</span> <span class="toc-text">2. Kustomize：Kubernetes 的原生配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Kustomize-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.7.1.2.1.</span> <span class="toc-text">Kustomize 的基本用法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.7.1.3.</span> <span class="toc-text">3. 选择合适的工具</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%BD%91%E7%BB%9C%EF%BC%8820-%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">服务和网络（20%）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">了解集群节点上的主机网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">理解 Kubernetes 集群节点上的主机网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">1. 选择网络插件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.1.1.1.1.</span> <span class="toc-text">安装网络插件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE-Pod-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">2. 配置 Pod 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-Pod-%E7%BD%91%E7%BB%9C-CIDR"><span class="toc-number">1.3.1.1.2.1.</span> <span class="toc-text">定义 Pod 网络 CIDR</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C"><span class="toc-number">1.3.1.1.3.</span> <span class="toc-text">3. 配置服务网络</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C-CIDR"><span class="toc-number">1.3.1.1.3.1.</span> <span class="toc-text">定义服务网络 CIDR</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.1.4.</span> <span class="toc-text">4. 网络策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.1.4.1.</span> <span class="toc-text">应用网络策略</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3Pods%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">理解Pods之间的连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E4%B8%AD-Pods-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">理解 Kubernetes 中 Pods 之间的连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Kubernetes-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">1. Kubernetes 网络模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95-Pod-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">2. 测试 Pod 之间的连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95-Pods"><span class="toc-number">1.3.2.1.2.1.</span> <span class="toc-text">创建测试 Pods</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-Pods"><span class="toc-number">1.3.2.1.2.2.</span> <span class="toc-text">部署 Pods</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.3.2.1.2.3.</span> <span class="toc-text">测试连通性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%EF%BC%88Service%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">3. 理解服务（Service）的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1-1"><span class="toc-number">1.3.2.1.3.1.</span> <span class="toc-text">创建服务</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3ClusterIP%E3%80%81NodePort%E3%80%81LoadBalancer%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%AB%AF%E7%82%B9"><span class="toc-number">1.3.3.</span> <span class="toc-text">了解ClusterIP、NodePort、LoadBalancer服务类型和端点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%EF%BC%9AClusterIP%E3%80%81NodePort%E3%80%81LoadBalancer-%E5%8F%8A%E7%AB%AF%E7%82%B9"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">理解 Kubernetes 服务类型：ClusterIP、NodePort、LoadBalancer 及端点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ClusterIP-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">1. ClusterIP 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-ClusterIP-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.3.1.1.1.</span> <span class="toc-text">创建 ClusterIP 服务</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-NodePort-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">2. NodePort 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-NodePort-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.3.1.2.1.</span> <span class="toc-text">创建 NodePort 服务</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-LoadBalancer-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">3. LoadBalancer 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-LoadBalancer-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.3.1.3.1.</span> <span class="toc-text">创建 LoadBalancer 服务</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%AB%AF%E7%82%B9%EF%BC%88Endpoints%EF%BC%89"><span class="toc-number">1.3.3.1.4.</span> <span class="toc-text">4. 端点（Endpoints）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AB%AF%E7%82%B9"><span class="toc-number">1.3.3.1.4.1.</span> <span class="toc-text">查看服务的端点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%85%A5%E5%8F%A3%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E5%85%A5%E5%8F%A3%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">了解如何使用入口控制器和入口资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E4%B8%AD%E7%9A%84-Ingress-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C-Ingress-%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">理解 Kubernetes 中的 Ingress 控制器和 Ingress 资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Ingress-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">1. Ingress 控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Ingress-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.4.1.1.1.</span> <span class="toc-text">安装 Ingress 控制器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Ingress-%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">2. Ingress 资源</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Ingress-%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.4.1.2.1.</span> <span class="toc-text">创建 Ingress 资源</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95-Ingress-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.3.4.1.3.</span> <span class="toc-text">3. 测试 Ingress 路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%85%8D%E7%BD%AE-TLS-SSL"><span class="toc-number">1.3.4.1.4.</span> <span class="toc-text">4. 配置 TLS&#x2F;SSL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8CoreDNS"><span class="toc-number">1.3.5.</span> <span class="toc-text">了解如何配置和使用CoreDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-CoreDNS"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">理解 Kubernetes 中如何配置和使用 CoreDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-CoreDNS-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.5.1.1.</span> <span class="toc-text">1. CoreDNS 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81-CoreDNS-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.5.1.2.</span> <span class="toc-text">2. 验证 CoreDNS 运行状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE-CoreDNS"><span class="toc-number">1.3.5.1.3.</span> <span class="toc-text">3. 配置 CoreDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D-CoreDNS-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.5.1.3.1.</span> <span class="toc-text">查看当前 CoreDNS 配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-CoreDNS-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.5.1.3.2.</span> <span class="toc-text">修改 CoreDNS 配置</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-CoreDNS-%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.3.5.1.4.</span> <span class="toc-text">4. 使用 CoreDNS 进行服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%90%8D"><span class="toc-number">1.3.5.1.4.1.</span> <span class="toc-text">示例：解析服务名</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89-DNS-%E8%A7%84%E5%88%99"><span class="toc-number">1.3.5.1.5.</span> <span class="toc-text">5. 高级配置：自定义 DNS 规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E7%9A%84%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.6.</span> <span class="toc-text">选择适当的容器网络接口插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-Kubernetes-%E7%9A%84%E9%80%82%E5%BD%93%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3-CNI-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">选择 Kubernetes 的适当容器网络接口 (CNI) 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E7%9A%84-CNI-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.6.1.1.</span> <span class="toc-text">1. 了解常见的 CNI 插件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%80%83%E8%99%91%E9%80%89%E6%8B%A9-CNI-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.3.6.1.2.</span> <span class="toc-text">2. 考虑选择 CNI 插件的因素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%89%E8%A3%85-CNI-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.6.1.3.</span> <span class="toc-text">3. 安装 CNI 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Calico"><span class="toc-number">1.3.6.1.3.1.</span> <span class="toc-text">安装 Calico</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%AA%8C%E8%AF%81-CNI-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.6.1.4.</span> <span class="toc-text">4. 验证 CNI 插件的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5-Pod-%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.6.1.4.1.</span> <span class="toc-text">检查 Pod 状态</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%B0%83%E8%AF%95%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.6.1.5.</span> <span class="toc-text">5. 调试网络问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-CNI-%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.6.1.5.1.</span> <span class="toc-text">查看 CNI 日志</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%EF%BC%8810-%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">存储（10%）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E6%8C%81%E4%B9%85%E5%8D%B7"><span class="toc-number">1.4.1.</span> <span class="toc-text">了解存储类、持久卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB-StorageClass-%E5%92%8C%E6%8C%81%E4%B9%85%E5%8D%B7-Persistent-Volume"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">理解 Kubernetes 中的存储类 (StorageClass) 和持久卷 (Persistent Volume)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E7%B1%BB-StorageClass"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">1. 存储类 (StorageClass)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-StorageClass"><span class="toc-number">1.4.1.1.1.1.</span> <span class="toc-text">创建 StorageClass</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8C%81%E4%B9%85%E5%8D%B7-Persistent-Volume-PV"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">2. 持久卷 (Persistent Volume, PV)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Persistent-Volume"><span class="toc-number">1.4.1.1.2.1.</span> <span class="toc-text">创建 Persistent Volume</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E-Persistent-Volume-Claim-PVC"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">3. 持久卷声明 (Persistent Volume Claim, PVC)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Persistent-Volume-Claim"><span class="toc-number">1.4.1.1.3.1.</span> <span class="toc-text">创建 Persistent Volume Claim</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%8D%B7%E6%A8%A1%E5%BC%8F%E3%80%81%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%B7%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">了解卷模式、访问模式和卷回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E7%9A%84%E5%8D%B7%E6%A8%A1%E5%BC%8F%E3%80%81%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%B7%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">理解 Kubernetes 的卷模式、访问模式和卷回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8D%B7%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">1. 卷模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%85%B7%E6%9C%89%E7%89%B9%E5%AE%9A%E5%8D%B7%E6%A8%A1%E5%BC%8F%E7%9A%84-PV"><span class="toc-number">1.4.2.1.1.1.</span> <span class="toc-text">创建具有特定卷模式的 PV</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">2. 访问模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E7%9A%84-PVC"><span class="toc-number">1.4.2.1.2.1.</span> <span class="toc-text">指定访问模式的 PVC</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8D%B7%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.1.3.</span> <span class="toc-text">3. 卷回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E7%9A%84-PV"><span class="toc-number">1.4.2.1.3.1.</span> <span class="toc-text">指定回收策略的 PV</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%8C%81%E4%B9%85%E5%AE%B9%E9%87%8F%E5%A3%B0%E6%98%8E%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.4.3.</span> <span class="toc-text">理解持久容量声明原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-Kubernetes-%E4%B8%AD%E7%9A%84%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E-Persistent-Volume-Claim-PVC-%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">理解 Kubernetes 中的持久卷声明 (Persistent Volume Claim, PVC) 原语</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">1. 持久卷声明的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA-PVC"><span class="toc-number">1.4.3.1.2.</span> <span class="toc-text">2. 创建 PVC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-PVC-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.3.1.2.1.</span> <span class="toc-text">示例 PVC 定义</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-PVC"><span class="toc-number">1.4.3.1.3.</span> <span class="toc-text">3. 使用 PVC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-Pod-%E4%BD%BF%E7%94%A8-PVC"><span class="toc-number">1.4.3.1.3.1.</span> <span class="toc-text">示例 Pod 使用 PVC</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%9B%91%E6%8E%A7-PVC-%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.3.1.4.</span> <span class="toc-text">4. 监控 PVC 状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%85%B7%E6%9C%89%E6%8C%81%E4%B9%85%E6%80%A7%E5%AD%98%E5%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">了解如何配置具有持久性存储的应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Kubernetes-%E4%B8%AD%E5%85%B7%E6%9C%89%E6%8C%81%E4%B9%85%E6%80%A7%E5%AD%98%E5%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">配置 Kubernetes 中具有持久性存储的应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%8C%81%E4%B9%85%E5%8D%B7-PV"><span class="toc-number">1.4.4.1.1.</span> <span class="toc-text">1. 创建持久卷 (PV)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA-NFS-%E7%B1%BB%E5%9E%8B%E7%9A%84-PV"><span class="toc-number">1.4.4.1.1.1.</span> <span class="toc-text">示例：创建 NFS 类型的 PV</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%8C%81%E4%B9%85%E5%8D%B7%E5%A3%B0%E6%98%8E-PVC"><span class="toc-number">1.4.4.1.2.</span> <span class="toc-text">2. 创建持久卷声明 (PVC)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA-PVC"><span class="toc-number">1.4.4.1.2.1.</span> <span class="toc-text">示例：创建 PVC</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-PVC"><span class="toc-number">1.4.4.1.3.</span> <span class="toc-text">3. 在应用程序中使用 PVC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-PVC"><span class="toc-number">1.4.4.1.3.1.</span> <span class="toc-text">示例：配置应用程序使用 PVC</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%EF%BC%8830-%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">故障排除（30%）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E9%9B%86%E7%BE%A4%E5%92%8C%E8%8A%82%E7%82%B9%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">评估集群和节点日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0-Kubernetes-%E9%9B%86%E7%BE%A4%E5%92%8C%E8%8A%82%E7%82%B9%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">评估 Kubernetes 集群和节点日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">1. 获取集群日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.1.1.</span> <span class="toc-text">示例：获取控制平面组件的日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">2. 获取节点日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%8E%B7%E5%8F%96-kubelet-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.2.1.</span> <span class="toc-text">示例：获取 kubelet 日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96-Pod-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.3.</span> <span class="toc-text">3. 获取 Pod 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%8E%B7%E5%8F%96-Pod-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.3.1.</span> <span class="toc-text">示例：获取 Pod 日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.1.1.4.</span> <span class="toc-text">4. 使用日志收集工具</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Fluentd-%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.4.1.</span> <span class="toc-text">示例：使用 Fluentd 收集日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%9A%E6%9C%9F%E6%A3%80%E6%9F%A5%E5%92%8C%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.1.1.5.</span> <span class="toc-text">5. 定期检查和监控日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E7%9B%91%E8%A7%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">了解如何监视应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E8%A7%86-Kubernetes-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">监视 Kubernetes 中的应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Prometheus-%E5%92%8C-Grafana-%E7%9B%91%E8%A7%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">1. 使用 Prometheus 和 Grafana 监视应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Prometheus-%E5%92%8C-Grafana"><span class="toc-number">1.5.2.1.1.1.</span> <span class="toc-text">安装 Prometheus 和 Grafana</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE-Prometheus-%E4%BB%A5%E7%9B%91%E8%A7%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">2. 配置 Prometheus 以监视应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%85%8D%E7%BD%AE-Prometheus-%E7%9B%91%E6%8E%A7%E7%9B%AE%E6%A0%87"><span class="toc-number">1.5.2.1.2.1.</span> <span class="toc-text">示例：配置 Prometheus 监控目标</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Grafana-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.2.1.3.</span> <span class="toc-text">3. 使用 Grafana 可视化监控数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%85%8D%E7%BD%AE-Grafana-%E4%BB%AA%E8%A1%A8%E6%9D%BF"><span class="toc-number">1.5.2.1.3.1.</span> <span class="toc-text">示例：配置 Grafana 仪表板</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AE%BE%E7%BD%AE%E8%AD%A6%E6%8A%A5%E8%A7%84%E5%88%99"><span class="toc-number">1.5.2.1.4.</span> <span class="toc-text">4. 设置警报规则</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%BE%E7%BD%AE-Prometheus-%E8%AD%A6%E6%8A%A5%E8%A7%84%E5%88%99"><span class="toc-number">1.5.2.1.4.1.</span> <span class="toc-text">示例：设置 Prometheus 警报规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.</span> <span class="toc-text">管理容器标准输出和标准错误日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86-Kubernetes-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">管理 Kubernetes 容器的标准输出和标准错误日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE-Pod-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">1. 访问 Pod 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Pod-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.1.1.1.</span> <span class="toc-text">获取 Pod 日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E6%97%B6%E8%B7%9F%E8%B8%AA%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">2. 实时跟踪日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA-Pod-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.1.2.1.</span> <span class="toc-text">跟踪 Pod 日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AD%98%E5%82%A8%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">3. 导出和存储日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E6%97%A5%E5%BF%97%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.3.1.3.1.</span> <span class="toc-text">导出日志到文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">4. 集成日志收集工具</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Fluentd-%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-1"><span class="toc-number">1.5.3.1.4.1.</span> <span class="toc-text">示例：使用 Fluentd 收集日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%97%A5%E5%BF%97%E8%BD%AE%E6%8D%A2%E5%92%8C%E6%B8%85%E7%90%86"><span class="toc-number">1.5.3.1.5.</span> <span class="toc-text">5. 日志轮换和清理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%95%85%E9%9A%9C"><span class="toc-number">1.5.4.</span> <span class="toc-text">解决应用程序故障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-Kubernetes-%E4%B8%AD%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%95%85%E9%9A%9C"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">解决 Kubernetes 中应用程序故障</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5-Pod-%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.4.1.1.</span> <span class="toc-text">1. 检查 Pod 状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Pod-%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.4.1.1.1.</span> <span class="toc-text">获取 Pod 状态</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B-Pod-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.4.1.2.</span> <span class="toc-text">2. 查看 Pod 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A-Pod-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.4.1.2.1.</span> <span class="toc-text">获取特定 Pod 的日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%A3%80%E6%9F%A5-Pod-%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.5.4.1.3.</span> <span class="toc-text">3. 检查 Pod 描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-Pod"><span class="toc-number">1.5.4.1.3.1.</span> <span class="toc-text">描述 Pod</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%A3%80%E6%9F%A5%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.5.4.1.4.</span> <span class="toc-text">4. 检查资源限制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%8A%82%E7%82%B9%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.5.4.1.4.1.</span> <span class="toc-text">检查节点资源使用情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5-Pod-%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.5.4.1.4.2.</span> <span class="toc-text">检查 Pod 资源使用情况</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.4.1.5.</span> <span class="toc-text">5. 检查网络问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%85%A5%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.4.1.5.1.</span> <span class="toc-text">检查服务和入口配置</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%BA%94%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.4.1.6.</span> <span class="toc-text">6. 应用和配置问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.4.1.6.1.</span> <span class="toc-text">查看应用配置</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%B0%83%E8%AF%95-Pod"><span class="toc-number">1.5.4.1.7.</span> <span class="toc-text">7. 调试 Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-Pod-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.4.1.7.1.</span> <span class="toc-text">进入 Pod 进行调试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BE%A4%E9%9B%86%E7%BB%84%E4%BB%B6%E6%95%85%E9%9A%9C%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.5.5.</span> <span class="toc-text">对群集组件故障进行故障排除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9-Kubernetes-%E9%9B%86%E7%BE%A4%E7%BB%84%E4%BB%B6%E6%95%85%E9%9A%9C%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">对 Kubernetes 集群组件故障进行故障排除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5-Kubernetes-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.5.1.1.</span> <span class="toc-text">1. 检查 Kubernetes 控制平面组件状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.5.1.1.1.</span> <span class="toc-text">检查控制平面组件状态</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A3%80%E6%9F%A5-kubelet-%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.5.1.2.</span> <span class="toc-text">2. 检查 kubelet 状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%89%B9%E5%AE%9A%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84-kubelet-%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.5.1.2.1.</span> <span class="toc-text">检查特定节点上的 kubelet 状态</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B-Kubernetes-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.5.1.3.</span> <span class="toc-text">3. 查看 Kubernetes 系统日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-kube-apiserver-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.5.1.3.1.</span> <span class="toc-text">查看 kube-apiserver 日志</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.5.1.4.</span> <span class="toc-text">4. 检查网络连接</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5-etcd-%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.5.1.4.1.</span> <span class="toc-text">检查 etcd 集群状态</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-Kubernetes-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.5.1.5.</span> <span class="toc-text">5. 使用 Kubernetes 调试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-kubectl-debug"><span class="toc-number">1.5.5.1.5.1.</span> <span class="toc-text">使用 kubectl debug</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%A3%80%E6%9F%A5%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.5.5.1.6.</span> <span class="toc-text">6. 检查资源使用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%8A%82%E7%82%B9%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5-1"><span class="toc-number">1.5.5.1.6.1.</span> <span class="toc-text">检查节点资源使用情况</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%88%86%E6%9E%90-Kubernetes-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.5.1.7.</span> <span class="toc-text">7. 分析 Kubernetes 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Kubernetes-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.5.1.7.1.</span> <span class="toc-text">获取 Kubernetes 事件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C"><span class="toc-number">1.5.6.</span> <span class="toc-text">排除网络故障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E9%99%A4-Kubernetes-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">排除 Kubernetes 中的网络故障</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.6.1.1.</span> <span class="toc-text">1. 验证网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">1.5.6.1.1.1.</span> <span class="toc-text">检查网络插件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95-Pod-%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.5.6.1.2.</span> <span class="toc-text">2. 测试 Pod 之间的网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-kubectl-exec-%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.6.1.2.1.</span> <span class="toc-text">使用 kubectl exec 进行测试</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1-Service-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.6.1.3.</span> <span class="toc-text">3. 检查服务 (Service) 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E8%AF%A6%E6%83%85"><span class="toc-number">1.5.6.1.3.1.</span> <span class="toc-text">获取服务详情</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.6.1.4.</span> <span class="toc-text">4. 分析网络策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.6.1.4.1.</span> <span class="toc-text">获取网络策略列表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.6.1.5.</span> <span class="toc-text">5. 使用网络诊断工具</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-netshoot-%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.6.1.5.1.</span> <span class="toc-text">部署 netshoot 工具</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/SAA%E6%8F%90%E7%BA%B2/" title="Basic for SAA"><img src="/img/WallPaper%20(54).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Basic for SAA"/></a><div class="content"><a class="title" href="/2023/12/24/SAA%E6%8F%90%E7%BA%B2/" title="Basic for SAA">Basic for SAA</a><time datetime="2023-12-24T12:00:00.000Z" title="發表於 2023-12-24 20:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/saa%E6%A6%82%E5%BF%B5/" title="Conspectus for SAA"><img src="/img/WallPaper%20(56).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Conspectus for SAA"/></a><div class="content"><a class="title" href="/2023/12/24/saa%E6%A6%82%E5%BF%B5/" title="Conspectus for SAA">Conspectus for SAA</a><time datetime="2023-12-24T12:00:00.000Z" title="發表於 2023-12-24 20:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/saa%E9%A2%98%E5%BA%93/" title="practise for SAA(updating)"><img src="/img/WallPaper%20(55).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="practise for SAA(updating)"/></a><div class="content"><a class="title" href="/2023/12/24/saa%E9%A2%98%E5%BA%93/" title="practise for SAA(updating)">practise for SAA(updating)</a><time datetime="2023-12-24T12:00:00.000Z" title="發表於 2023-12-24 20:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/30/K8s/" title="CKA基础预览"><img src="/img/WallPaper%20(53).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CKA基础预览"/></a><div class="content"><a class="title" href="/2023/11/30/K8s/" title="CKA基础预览">CKA基础预览</a><time datetime="2023-11-30T07:00:00.000Z" title="發表於 2023-11-30 15:00:00">2023-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/22/Bash%20Basic/" title="Bash for Begginners"><img src="/img/WallPaper%20(52).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bash for Begginners"/></a><div class="content"><a class="title" href="/2023/11/22/Bash%20Basic/" title="Bash for Begginners">Bash for Begginners</a><time datetime="2023-11-22T07:00:00.000Z" title="發表於 2023-11-22 15:00:00">2023-11-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/WallPaper%20(53).jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Kalyan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="淺色和深色模式轉換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直達評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.kalyan-dao.space/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.kalyan-dao.space/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>