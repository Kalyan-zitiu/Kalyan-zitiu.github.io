<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kalyan的小书房</title>
  <icon>https://www.gravatar.com/avatar/26add54e467101c6779c59a0ed4ee504</icon>
  <subtitle>Kalyan is working hard</subtitle>
  <link href="https://kalyan-zitiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://kalyan-zitiu.github.io/"/>
  <updated>2023-04-25T09:14:06.258Z</updated>
  <id>https://kalyan-zitiu.github.io/</id>
  
  <author>
    <name>Kalyan</name>
    <email>3148862192@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023425</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/25/2023425%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/25/2023425%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-25T08:50:04.000Z</published>
    <updated>2023-04-25T09:14:06.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="身高排序"><a href="#身高排序" class="headerlink" title="身高排序"></a>身高排序</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组names,和一个由<strong>互不相同</strong> 的正整数组成的数组heights.两个数组的长度均为n.对每个下标 i,name[i]和heights[i] 表示第i个人的名字和身高.降序返回对应的名字数组names.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在 HashMap 中存储了身高和人名信息。接下来，利用 entrySet() 方法获取映射关系集合，并将这个集合转换成 List 类型的 entryList。接着调用了 Collections.sort() 方法来对 entryList 进行排序。通过 getKey() 和 getValue() 方法分别获取身高和人名信息，最终按照从小到大排序存储到字符串数组 result 中并返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] sortPeople(String[] names, <span class="type">int</span>[] heights) &#123;</span><br><span class="line">    HashMap&lt;Integer,String&gt; storage = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> names.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        storage.put(Integer.valueOf(heights[i]),names[i]);  <span class="comment">// 将身高和对应的人名信息存储到 HashMap 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序 HashMap，输出结果</span></span><br><span class="line">    List&lt;Map.Entry&lt;Integer, String&gt;&gt; entryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;Integer, String&gt;&gt;(storage.entrySet());</span><br><span class="line">    Collections.sort(entryList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, String&gt; o1, Map.Entry&lt;Integer, String&gt; o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.getKey() - o1.getKey();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    String[] result = <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : entryList) &#123;</span><br><span class="line">        result[i++] = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections是怎么对List里面的Map进行排序的"><a href="#Collections是怎么对List里面的Map进行排序的" class="headerlink" title="Collections是怎么对List里面的Map进行排序的."></a>Collections是怎么对List里面的Map进行排序的.</h2><ol><li>Collections.sort()方法可以对实现Comparable接口或使用自定义比较器Comparator的类进行排序.由于List中的元素是Map,我们需要使用Comparator来指定排序规则.<br>如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map1.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">map1.put(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">listMap.add(map1);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">map2.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line">listMap.add(map2);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map3.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">map3.put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">listMap.add(map3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匿名内部类 Comparator 进行排序</span></span><br><span class="line">Collections.sort(listMap, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map&lt;String, Object&gt; o1, Map&lt;String, Object&gt; o2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> (<span class="type">int</span>) o1.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age2</span> <span class="operator">=</span> (<span class="type">int</span>) o2.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age1 - age2; <span class="comment">// 正序排列</span></span><br><span class="line">        <span class="comment">// return age2 - age1; // 倒序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">for</span> (Map&lt;String, Object&gt; map : listMap) &#123;</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;：&quot;</span> + map.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模型-结构型模式</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</id>
    <published>2023-04-24T14:00:00.000Z</published>
    <updated>2023-04-24T14:20:27.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-结构型模式"><a href="#设计模式-结构型模式" class="headerlink" title="设计模式-结构型模式"></a>设计模式-结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</li><li>适配器模式，定义一个包装类，用于包装不兼容接口的对象</li><li>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。适配器的模式的形式分别：为类的适配器和对象的适配器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包装类=适配器Adapter</span><br><span class="line">被包装类对象 = 适配器Adaptee = 被适配的类</span><br></pre></td></tr></table></figure></li></ul><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>原版由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>透明简单，客户端可以调用同一个接口，因而对客户端来说是透明的</li><li>复用性，需要实现现有的类，此类的接口不符合系统的需要，那么通过适配器模式可以让这些功能得到更好的复用</li><li>扩展性，实现适配器功能的时候，通过调用自己开发的功能，从而自然的扩展系统的功能</li><li>解耦性，将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改源码</li><li>符合开闭原则，同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改适配类。<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303272341418.png" alt="img"></p><h3 id="举例实例"><a href="#举例实例" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SpecificRequest</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPattern</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">mAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>()；</span><br><span class="line">        mAdapter.Request（）;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>过多的使用适配器会让系统非常凌乱，不易整体进行把握。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>系统需要复用现有类，而该类接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的类一起工作。</li><li>多个组件功能类似，接口不统一且可能会经常切换时候，可以使用适配器模式，使得客户端额可以统一的接口使用他们。</li></ul><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>抽象部分与它的实现部分分离，使它们都可以独立的变化。</li><li>抽取其中一个维度并使之成为独立的类层次</li><li>在某个类中添加一个指向某一属性对象的引用成员变量。</li></ul><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成</th><th>作用</th></tr></thead><tbody><tr><td>抽象类</td><td>定义抽象类的接口，定义了一个Implementor实现类接口的对象斌可以维护其对象</td></tr><tr><td>提炼抽象类</td><td>扩充抽象类定义的接口，通常属于具体类，实现抽象类中声明的抽象业务方法，在提炼抽象类中，能够调用在实现类接口的业务方法</td></tr><tr><td>实现类接口</td><td>这个接口不一定要与抽象类的接口完全一致，事实上这两个接口可以完全不同，可以仅仅提供基本操作，而抽象类接口可以实现更多复杂的操作。</td></tr><tr><td>具体实现类</td><td>具体实现实现类接口，在不同的具体实现类中提供基本操作的不同实现，在程序运行时候，具体实现类的对象将会替换其父类对象，提供给抽象类具体的业务操作方法。</td></tr></tbody></table><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>提高系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</li><li>有的时候类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，而且多继承的结构类中的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li></ul><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303272227473.png" alt="在这里插入图片描述"></p><h3 id="举例实例-1"><a href="#举例实例-1" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于画各种颜色的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">protected</span> ColorAPI colorAPI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDrawAPI</span><span class="params">(ColorAPI colorAPI)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.colorAPI = colorAPI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;长方形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//创建一个圆形</span></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="comment">//给圆形蓝色的颜料</span></span><br><span class="line">shape.setDrawAPI(<span class="keyword">new</span> <span class="title class_">BlueColorAPI</span>());</span><br><span class="line"><span class="comment">//上色</span></span><br><span class="line">shape.draw();</span><br><span class="line"><span class="comment">//创建一个长方形</span></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"><span class="comment">//给长方形上红色的颜料</span></span><br><span class="line">shape1.setDrawAP(<span class="keyword">new</span> <span class="title class_">RedColorAPI</span>());</span><br><span class="line"><span class="comment">//上色</span></span><br><span class="line">shape1.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个时候客户需要一个绿色的三角形那么只需要新增一个三角形类即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;绿色&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line">shape.setDrawAPI(<span class="keyword">new</span> <span class="title class_">GreenColorAPI</span>());</span><br><span class="line">shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li>桥接模式的引入会增加系统的理解与设计的难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计以及编程</li><li>桥接模式要求正确的识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>不改变现有对象结构的情况下，动态地给对象增加一些职责的模式，它属于对象结构型模式</li></ul><h3 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态地给一个对象扩展功能，即插即用。</li><li>通过不用装饰类以及这些装饰类的排列组合，可以实现不同效果</li><li>装饰器模式完全遵守开闭原则</li></ul><h3 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th align="left">组成</th><th>作用</th></tr></thead><tbody><tr><td align="left">抽象构件</td><td>定义一个抽象接口以规范准备接收附加责任的对象</td></tr><tr><td align="left">具体构件</td><td>实现抽象构件，通过装饰角色为其添加一些职责</td></tr><tr><td align="left">抽象装饰</td><td>继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</td></tr><tr><td align="left">具体装饰</td><td>实现抽象装饰的相关方法，并给具体构件对象添加附加责任。</td></tr></tbody></table><h3 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303290039331.png" alt="image-20230329003915296"></p><h3 id="举例实例-2"><a href="#举例实例-2" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul><li>装饰器模式会增加许多子类，过度使用会增加程序的复杂性。<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3></li><li>为其他对象提供一种代理以控制这个对象的访问。</li></ul><h3 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>职责清晰</li><li>高扩展，只要实现了接口，都可以用代理</li><li>智能化，动态代理。</li></ul><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303290100829.png" alt="image-20230329010025796"></p><h3 id="举例实例-3"><a href="#举例实例-3" class="headerlink" title="举例实例"></a>举例实例</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ol><li>以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个提供了租房方法的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义租房的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RentHouse</span> <span class="keyword">implements</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租了一间房子。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租房找中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntermediaryProxy</span> <span class="keyword">implements</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IRentHouse rentHouse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntermediaryProxy</span><span class="params">(IRentHouse irentHouse)</span>&#123;</span><br><span class="line">        rentHouse = irentHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;交中介费&quot;</span>);</span><br><span class="line">        rentHouse.rentHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;中介负责维修管理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义租房</span></span><br><span class="line">        <span class="type">IRentHouse</span> <span class="variable">rentHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RentHouse</span>();</span><br><span class="line">        <span class="comment">//定义中介</span></span><br><span class="line">        <span class="type">IRentHouse</span> <span class="variable">intermediary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntermediaryProxy</span>(rentHouse);</span><br><span class="line">        <span class="comment">//中介租房</span></span><br><span class="line">        intermediary.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3>又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，他创建了对象组的树形结构<h3 id="模式组成-2"><a href="#模式组成-2" class="headerlink" title="模式组成"></a>模式组成</h3></li></ol><table><thead><tr><th>角色</th><th>解释</th></tr></thead><tbody><tr><td>抽象构件</td><td>为树叶构件和树枝构件声明公共接口，实现默认行为</td></tr><tr><td>树叶构件</td><td>没有子节点，用于继承或实现抽象构件，是树状结构最底层。</td></tr><tr><td>树枝构件</td><td>有子节点，是组合中的分支节点。</td></tr></tbody></table><h3 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>一致处理单个对象和组合对象，无须关心处理的是单个对象还是组合对象。</li><li>容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码。</li></ul><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul><li>设计复杂，需要一定时间理清层次关系</li><li>不容易限制容器中的构件</li><li>不容易用继承的方法来增加构件的新功能</li></ul><h3 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用接口或者抽象类都可以的</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Region</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前节点下面的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知，上面下个政策一级一级的传递，一般都有一个动作方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树叶地区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafRegion</span> <span class="keyword">extends</span> <span class="title class_">Region</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeafRegion</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span> &#123;</span><br><span class="line"><span class="comment">//叶子节点没有下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span> &#123;</span><br><span class="line"><span class="comment">//叶子节点没有下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//叶子节点没有下级</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最底层的接到了通知</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树枝地区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositeRegion</span> <span class="keyword">extends</span> <span class="title class_">Region</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来盛放子节点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Region&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">        children.add(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">        children.remove(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*通知下级所有的部门，下级如果是树枝的话继续通知，这是个递归操作*/</span></span><br><span class="line">        <span class="keyword">for</span> (Region child : children) &#123;</span><br><span class="line">            child.notice();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使得这一子系统更加容易使用</li></ul><h3 id="模式组成-3"><a href="#模式组成-3" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色类型</th><th>作用解释</th></tr></thead><tbody><tr><td>外观(Facade)</td><td>封装系统底层功能，为客户端提供简单易用的接口</td></tr><tr><td>子系统类(SubSystem)</td><td>提供系统底层的具体实现细节</td></tr><tr><td>客户端(Client)</td><td>调用外观对象提供的简单接口，使用系统底层功能而无需了解其具体实现</td></tr></tbody></table><h3 id="解决问题-5"><a href="#解决问题-5" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>降低访问复杂系统的内部子系统时的复杂度，简化个护短之间的接口。</li><li>减少系统的互相依赖，提高灵活性，提高安全性。<h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3></li><li>不符合开闭原则</li></ul><h3 id="举例实现-1"><a href="#举例实现-1" class="headerlink" title="举例实现"></a>举例实现</h3><ol><li>假设你现在需要购买一台电脑，在购买这个过程中，有很多不同的步骤需要完成，如选择操作系统、购买CPU、选择显示屏尺寸等等。然而，如果你并不关心电脑内部如何工作，而只关注它的整体性能和使用方式，那么外观模式就可以被用来简化这个过程。</li></ol><p>具体地说，一个电脑厂商可能会实现一个电脑购买外观(Facade)，它将 CPU 购买、内存配置、显示器选择、操作系统安装等操作封装在一起，提供一个简单易用的接口让用户来购买电脑。对于客户端而言，只需要调用外观对象提供的购买接口就可以了，而不必了解具体的硬件和软件实现细节，大大简化了购买电脑的流程。当内部实现发生变化时，只需修改外观类即可，对客户端代码没有影响。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerPurchaseFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> Display display;</span><br><span class="line">    <span class="keyword">private</span> OS os;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComputerPurchaseFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        display = <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        os = <span class="keyword">new</span> <span class="title class_">OS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyComputer</span><span class="params">(<span class="type">int</span> cpuType, <span class="type">int</span> memorySize, <span class="type">int</span> displaySize, <span class="type">int</span> osType)</span> &#123;</span><br><span class="line">        cpu.selectCPU(cpuType);</span><br><span class="line">        memory.setMemorySize(memorySize);</span><br><span class="line">        display.selectDisplay(displaySize);</span><br><span class="line">        os.installOS(osType);</span><br><span class="line">        System.out.println(<span class="string">&quot;Your computer has been purchased!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCPU</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择不同种类的CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemorySize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置内存大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDisplay</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择不同尺寸的显示器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installOS</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">// 安装不同类型的操作系统</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerPurchaseFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerPurchaseFacade</span>();</span><br><span class="line">        facade.buyComputer(<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>为一个复杂的子系统提高逻辑支持</li><li>调用多个子系统完成逻辑</li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li>有两类对象：共享的享元对象和非共享的外部状态对象。享元对象包含内部状态和外部状态两部分，其中内部状态是不变的，可以被多个享元对象共享；外部状态是变化的，不能被共享，每个对象都需要单独维护。</li><li>将原本需要大量创建的相似对象合并为较少的共享对象，这样可以节省内存空间，并提高程序的运行效率。</li></ul><h3 id="解决问题-6"><a href="#解决问题-6" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>减少系统内部资源开销，通过对象共享，减少系统创建对象的数量，降低内存的开销</li><li>提高系统性能，减少垃圾回收机制的次数</li></ul><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><ul><li>对象共享会导致程序逻辑复杂化。原来对象自己拥有的内部状态和外部状态现在需要从外部导入。</li><li>对象共享是有限制的，即那些可以共享的对象需要满足一定的条件，否则无法实现对象的共享。</li></ul><h3 id="模式组成-4"><a href="#模式组成-4" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色类型</th><th>作用解释</th></tr></thead><tbody><tr><td>抽象享元角色（Flyweight）</td><td>定义享元对象的接口及需要缓存的数据，充当所有具体享元类的基类。</td></tr><tr><td>具体享元角色（ConcreteFlyweight）</td><td>实现抽象享元角色所定义的接口，同时需要为内部状态增加存储空间。并且可以接受外部状态（容易变化的状态），并根据外部状态进行相应的业务逻辑处理。</td></tr><tr><td>非共享具体享元角色（UnsharedConcreteFlyweight）</td><td>通常不会出现单独的非共享具体享元角色，因为非共享具体享元角色与单纯的享元模式没有什么区别。</td></tr><tr><td>享元工厂角色（FlyweightFactory）</td><td>提供一个用于管理享元对象的工厂类。主要用于享元对象的创建和缓存，实现对象的复用，减少对象的创建次数，节省内存空间。</td></tr><tr><td>客户端角色（Client）</td><td>通过享元工厂角色获取具体的享元角色，并访问具体享元角色中的相关业务方法。</td></tr></tbody></table><h3 id="举例实现-2"><a href="#举例实现-2" class="headerlink" title="举例实现"></a>举例实现</h3><ol><li>我们正在开发一个棋类游戏，游戏中有大量的棋子需要被使用。不同的棋子有不同的颜色和形状，但是棋子的功能（如移动、吃子等）都是一样的。我们可以复用相同颜色和形状的棋子对象，避免重复创建棋子导致内存资源的浪费，提高系统的性能。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋子的共享接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护了颜色和形状的内部状态，位置等可变状态外部传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteChessPiece</span> <span class="keyword">implements</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String shape;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteChessPiece</span><span class="params">(String color, String shape)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Set position for %s %s chess to (%d,%d)&quot;</span>, color, shape, x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Draw %s %s chess&quot;</span>, color, shape));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理棋子对象并进行复用。</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChessPiece <span class="title function_">getChessPiece</span><span class="params">(String color, String shape)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> color + shape;</span><br><span class="line">        <span class="keyword">if</span> (chessPieces.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chessPieces.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ChessPiece</span> <span class="variable">piece</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteChessPiece</span>(color, shape);</span><br><span class="line">            chessPieces.put(key, piece);</span><br><span class="line">            <span class="keyword">return</span> piece;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">ChessPiece</span> <span class="variable">piece</span> <span class="operator">=</span> ChessPieceFactory.getChessPiece(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;circle&quot;</span>);</span><br><span class="line">    piece.setPosition(i, <span class="number">0</span>);</span><br><span class="line">    piece.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-结构型模式&quot;&gt;&lt;a href=&quot;#设计模式-结构型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-结构型模式&quot;&gt;&lt;/a&gt;设计模式-结构型模式&lt;/h1&gt;&lt;h2 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;he</summary>
      
    
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kalyan的训练计划</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/20/Kalyan%E7%9A%84%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/20/Kalyan%E7%9A%84%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-20T04:30:34.000Z</published>
    <updated>2023-04-23T13:49:57.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="胸"><a href="#胸" class="headerlink" title="胸"></a>胸</h2><h3 id="训练计划"><a href="#训练计划" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210444548.png" alt="image-20230423210444548"></p><h3 id="蝴蝶肌夹胸"><a href="#蝴蝶肌夹胸" class="headerlink" title="蝴蝶肌夹胸"></a>蝴蝶肌夹胸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002229315.png" alt="image-20230423002229315"></p><h3 id="平板卧推"><a href="#平板卧推" class="headerlink" title="平板卧推"></a>平板卧推</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002522177.png" alt="image-20230423002522177"></p><h3 id="上斜哑铃飞鸟"><a href="#上斜哑铃飞鸟" class="headerlink" title="上斜哑铃飞鸟"></a>上斜哑铃飞鸟</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002305022.png" alt="image-20230423002305022"></p><h3 id="杠铃上斜卧推"><a href="#杠铃上斜卧推" class="headerlink" title="杠铃上斜卧推"></a>杠铃上斜卧推</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002830127.png" alt="image-20230423002830127"></p><h3 id="龙门架夹下胸"><a href="#龙门架夹下胸" class="headerlink" title="龙门架夹下胸"></a>龙门架夹下胸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423003136604.png" alt="image-20230423003136604"></p><h3 id="双杠臂屈伸"><a href="#双杠臂屈伸" class="headerlink" title="双杠臂屈伸"></a>双杠臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423003029827.png" alt="image-20230423003029827"></p><h2 id="背"><a href="#背" class="headerlink" title="背"></a>背</h2><h3 id="训练计划-1"><a href="#训练计划-1" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210334836.png" alt="image-20230423210334836"></p><h3 id="高位下拉"><a href="#高位下拉" class="headerlink" title="高位下拉"></a>高位下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423164327463.png" alt="image-20230423164327463"></p><h3 id="坐姿划船"><a href="#坐姿划船" class="headerlink" title="坐姿划船"></a>坐姿划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205735398.png" alt="image-20230423205735398"></p><h3 id="直臂下拉"><a href="#直臂下拉" class="headerlink" title="直臂下拉"></a>直臂下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205851519.png" alt="image-20230423205851519"></p><h3 id="窄距高位下拉"><a href="#窄距高位下拉" class="headerlink" title="窄距高位下拉"></a>窄距高位下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205942885.png" alt="image-20230423205942885"></p><h3 id="俯身划船"><a href="#俯身划船" class="headerlink" title="俯身划船"></a>俯身划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210151270.png" alt="image-20230423210151270"></p><h3 id="宽距坐姿划船"><a href="#宽距坐姿划船" class="headerlink" title="宽距坐姿划船"></a>宽距坐姿划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210236422.png" alt="image-20230423210236422"></p><h2 id="腿"><a href="#腿" class="headerlink" title="腿"></a>腿</h2><h3 id="训练计划-2"><a href="#训练计划-2" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211817734.png" alt="image-20230423211817734"></p><h3 id="坐姿腿屈伸"><a href="#坐姿腿屈伸" class="headerlink" title="坐姿腿屈伸"></a>坐姿腿屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210829948.png" alt="image-20230423210829948"></p><h3 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210950628.png" alt="image-20230423210950628"></p><h3 id="倒蹬机腿举"><a href="#倒蹬机腿举" class="headerlink" title="倒蹬机腿举"></a>倒蹬机腿举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211530323.png" alt="image-20230423211530323"></p><h3 id="俯卧腿弯举（腰部不用力，屁股不撅）"><a href="#俯卧腿弯举（腰部不用力，屁股不撅）" class="headerlink" title="俯卧腿弯举（腰部不用力，屁股不撅）"></a>俯卧腿弯举（腰部不用力，屁股不撅）</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211715526.png" alt="image-20230423211715526"></p><h2 id="肩"><a href="#肩" class="headerlink" title="肩"></a>肩</h2><h3 id="训练计划-3"><a href="#训练计划-3" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212631090.png" alt="image-20230423212631090"></p><h3 id="史密斯推肩"><a href="#史密斯推肩" class="headerlink" title="史密斯推肩"></a>史密斯推肩</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212110581.png" alt="image-20230423212110581"></p><h3 id="哑铃侧平举"><a href="#哑铃侧平举" class="headerlink" title="哑铃侧平举"></a>哑铃侧平举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212222249.png" alt="image-20230423212222249"></p><h3 id="蝴蝶机反向飞鸟"><a href="#蝴蝶机反向飞鸟" class="headerlink" title="蝴蝶机反向飞鸟"></a>蝴蝶机反向飞鸟</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212320016.png" alt="image-20230423212320016"></p><h3 id="绳索前平举"><a href="#绳索前平举" class="headerlink" title="绳索前平举"></a>绳索前平举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212411999.png" alt="image-20230423212411999"></p><h3 id="绳索面拉"><a href="#绳索面拉" class="headerlink" title="绳索面拉"></a>绳索面拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212537833.png" alt="image-20230423212537833"></p><h2 id="小臂"><a href="#小臂" class="headerlink" title="小臂"></a>小臂</h2><h3 id="训练计划-4"><a href="#训练计划-4" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213030936.png" alt="image-20230423213030936"></p><h3 id="哑铃手腕弯举"><a href="#哑铃手腕弯举" class="headerlink" title="哑铃手腕弯举"></a>哑铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212818644.png" alt="image-20230423212818644"></p><h3 id="反向哑铃手腕弯举"><a href="#反向哑铃手腕弯举" class="headerlink" title="反向哑铃手腕弯举"></a>反向哑铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212903715.png" alt="image-20230423212903715"></p><h3 id="站姿体后杠铃手腕弯举"><a href="#站姿体后杠铃手腕弯举" class="headerlink" title="站姿体后杠铃手腕弯举"></a>站姿体后杠铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212958122.png" alt="image-20230423212958122"></p><h2 id="二三头"><a href="#二三头" class="headerlink" title="二三头"></a>二三头</h2><h3 id="训练计划-5"><a href="#训练计划-5" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423214003078.png" alt="image-20230423214003078"></p><h3 id="杠铃弯举"><a href="#杠铃弯举" class="headerlink" title="杠铃弯举"></a>杠铃弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213308228.png" alt="image-20230423213308228"></p><h3 id="直杠臂屈伸"><a href="#直杠臂屈伸" class="headerlink" title="直杠臂屈伸"></a>直杠臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213746793.png" alt="image-20230423213746793"></p><h3 id="哑铃颈后臂屈伸"><a href="#哑铃颈后臂屈伸" class="headerlink" title="哑铃颈后臂屈伸"></a>哑铃颈后臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213730391.png" alt="image-20230423213730391"></p><h3 id="牧师椅杠铃弯举"><a href="#牧师椅杠铃弯举" class="headerlink" title="牧师椅杠铃弯举"></a>牧师椅杠铃弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213700395.png" alt="image-20230423213700395"></p><h3 id="绳索颈后臂屈伸"><a href="#绳索颈后臂屈伸" class="headerlink" title="绳索颈后臂屈伸"></a>绳索颈后臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213846270.png" alt="image-20230423213846270"></p><h3 id="练前篇"><a href="#练前篇" class="headerlink" title="练前篇"></a>练前篇</h3><ul><li>训练前一小时,一勺蛋白粉</li><li>训练前半小时上氮泵和肌酸</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;胸&quot;&gt;&lt;a href=&quot;#胸&quot; class=&quot;headerlink&quot; title=&quot;胸&quot;&gt;&lt;/a&gt;胸&lt;/h2&gt;&lt;h3 id=&quot;训练计划&quot;&gt;&lt;a href=&quot;#训练计划&quot; class=&quot;headerlink&quot; title=&quot;训练计划&quot;&gt;&lt;/a&gt;训练计划&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="分享" scheme="https://kalyan-zitiu.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="训练" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/18/JDBC/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/18/JDBC/</id>
    <published>2023-04-18T11:00:00.000Z</published>
    <updated>2023-04-22T08:14:23.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC学习笔记"><a href="#JDBC学习笔记" class="headerlink" title="JDBC学习笔记"></a>JDBC学习笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC(Java DataBase Connectivity)是Java编程语言中连接数据库的一种标准规范, 其提供了访问许多不同类型数据库的标准化方法，使得Java程序员能够很容易地使用数据库和执行SQL查询，从而方便地与任何数据库进行交互。</p><ul><li>本质上JDBC就是用来操作关系型数据库的一套API。</li></ul><p>JDBC API包含两个级别：</p><ul><li><p>JDBC API：Java应用程序通过这个API与JDBC管理器通信。</p></li><li><p>JDBC 驱动程序API：这个API定义了Java应用程序和JDBC驱动程序之间的协议。</p></li><li><p>JDBC可以为所有主流数据库提供统一的访问方式，从而有助于加快Java开发者的工作效率。</p></li></ul><p>下面是个使用java语言操作关系型数据库的一套API</p><h3 id="导入jar"><a href="#导入jar" class="headerlink" title="导入jar"></a>导入jar</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304172257201.png" alt="image-20230417225731159"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304172258423.png" alt="image-20230417225839387"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Connected to database successfully!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: unable to load driver class!&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: failed to connect to database!&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304172301062.png" alt="image-20230417230155033"></p><h2 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ul><li>驱动管理类1.注册驱动2.获取数据库连接</li><li>与各种关系型数据库进行通信。</li></ul><p>以下部分方法：</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>getConnection()</td><td>连接到指定的数据库，并返回一个连接对象</td></tr><tr><td>getDriver()</td><td>返回一个具体的驱动</td></tr><tr><td>setLogWriter()</td><td>设置当前应用程序的日志Writer对象</td></tr><tr><td>getLogWriter()</td><td>获取当前应用程序的日志Writer对象</td></tr></tbody></table><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li>表示与特定的数据库进行连接。</li><li>一旦获得一个Connection对象，就可以使用它来执行SQL语句。</li></ul><table><thead><tr><th align="left">方法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">createStatement()</td><td align="left">创建一个 Statement 对象，用于执行静态 SQL 语句并返回其生成的结果。</td></tr><tr><td align="left">prepareStatement(String sql)</td><td align="left">创建一个 PreparedStatement 对象，用于将参数化的 SQL 语句发送到数据库。</td></tr><tr><td align="left">setAutoCommit(boolean autoCommit)</td><td align="left">设置是否启用自动提交模式。如果启用，每个 SQL 语句默认作为事务处理。</td></tr><tr><td align="left">commit()</td><td align="left">使自上次提交以来所做的所有更改成为永久性更改，并释放 Transaction 对象当前持有的所有锁。</td></tr><tr><td align="left">rollback()</td><td align="left">撤销自上次提交以来所做的所有更改，并释放 Transaction 对象当前持有的所有锁。</td></tr><tr><td align="left">close()</td><td align="left">关闭此 Connection 对象并释放与之关联的所有资源。</td></tr></tbody></table><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><ul><li>能够执行静态的SQL语句，并返回产生结果。</li><li>代表在数据库上执行的SQL语句的接口</li></ul><table><thead><tr><th align="left">方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">executeQuery(String sql)</td><td align="left">执行给定的 SQL 语句，它返回一个 ResultSet 对象。</td></tr><tr><td align="left">executeUpdate(String sql)</td><td align="left">执行给定的 SQL 语句，它可能会影响数据库中的任何数据。executeUpdate() 方法返回受影响的行数。</td></tr><tr><td align="left">execute(String sql)</td><td align="left">执行给定的 SQL 语句，该语句可能会返回多个结果。execute() 方法返回一个 boolean 值，指示第一个结果是否是 ResultSet 类型。</td></tr><tr><td align="left">addBatch(String sql)</td><td align="left">将给定的 SQL 语句添加到当前对象的批处理命令列表中。</td></tr><tr><td align="left">clearBatch()</td><td align="left">从此 Statement 对象的当前命令列表中删除所有命令。</td></tr><tr><td align="left">executeBatch()</td><td align="left">提交一批更新命令到数据库。executeBatch() 方法返回一个 int 数组，它表示批处理中每个命令影响的行数。</td></tr><tr><td align="left">close()</td><td align="left">释放此 Statement 对象使用的所有资源。</td></tr></tbody></table><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul><li>执行查询后返回的对数据库的结果集表示。ResultSet是一个接口，它包含了一个表的所有行以及每个行的各个列的值</li></ul><table><thead><tr><th align="left">方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">next()</td><td align="left">将结果集中的光标移到下一行。</td></tr><tr><td align="left">getInt(int columnIndex) 和 getInt(String columnName)</td><td align="left">获取指定列的 int 类型的值。</td></tr><tr><td align="left">getDouble(int columnIndex) 和 getDouble(String columnName)</td><td align="left">获取指定列的 double 类型的值。</td></tr><tr><td align="left">getString(int columnIndex) 和 getString(String columnName)</td><td align="left">获取指定列的 String 类型的值。</td></tr><tr><td align="left">getDate(int columnIndex) 和 getDate(String columnName)</td><td align="left">获取指定列的 java.sql.Date 类型的值。</td></tr><tr><td align="left">getTime(int columnIndex) 和 getTime(String columnName)</td><td align="left">获取指定列的 java.sql.Time 类型的值。</td></tr><tr><td align="left">getTimestamp(int columnIndex) 和 getTimestamp(String columnName)</td><td align="left">获取指定列的 java.sql.Timestamp 类型的值。</td></tr><tr><td align="left">getObject(int columnIndex) 和 getObject(String columnName)</td><td align="left">获取指定列的 java.lang.Object 类型的值。</td></tr><tr><td align="left">wasNull()</td><td align="left">如果上一次获取的值为空，返回 true。</td></tr><tr><td align="left">close()</td><td align="left">释放资源，关闭 ResultSet 对象。</td></tr></tbody></table><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><ul><li>继承Statement接口，但能够提供高程序的性能和安全性，对SQL语句进行了预编译处理，并且可以通过参数化查询来防止SQL注入攻击。</li></ul><table><thead><tr><th align="left">方法名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">setString(int parameterIndex, String x)</td><td align="left">给指定的参数设置 String 类型的值。</td></tr><tr><td align="left">setInt(int parameterIndex, int x)</td><td align="left">给指定的参数设置 int 类型的值。</td></tr><tr><td align="left">setDouble(int parameterIndex, double x)</td><td align="left">给指定的参数设置 double 类型的值。</td></tr><tr><td align="left">setFloat(int parameterIndex, float x)</td><td align="left">给指定的参数设置 float 类型的值。</td></tr><tr><td align="left">setLong(int parameterIndex, long x)</td><td align="left">给指定的参数设置 long 类型的值。</td></tr><tr><td align="left">setDate( int parameterIndex, Date x )</td><td align="left">给指定的参数设置 java.sql.Date 类型的值。</td></tr><tr><td align="left">setTime(int parameterIndex, Time x)</td><td align="left">给指定的参数设置 java.sql.Time 类型的值。</td></tr><tr><td align="left">setTimestamp(int parameterIndex, Timestamp x)</td><td align="left">给指定的参数设置 java.sql.Timestamp 类型的值。</td></tr><tr><td align="left">setObject(int parameterIndex, Object x)</td><td align="left">给指定的参数设置 Object 类型的值。</td></tr><tr><td align="left">setNull(int parameterIndex, int sqlType)</td><td align="left">给指定的参数设置 null 值。</td></tr><tr><td align="left">executeQuery()</td><td align="left">执行带参数的查询并返回 ResultSet 对象。</td></tr><tr><td align="left">executeUpdate()</td><td align="left">执行带参数的更新语句。</td></tr><tr><td align="left">addBatch()</td><td align="left">添加一个批处理命令。</td></tr><tr><td align="left">clearBatch()</td><td align="left">清除所有之前添加的批处理命令。</td></tr><tr><td align="left">executeBatch()</td><td align="left">执行所有添加的批处理命令。</td></tr><tr><td align="left">close()</td><td align="left">释放资源，关闭 PreparedStatement 对象。</td></tr></tbody></table><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul><li>常见的数据库漏洞，攻击者利用应用程序对输入数据的过滤和验证不严格，将恶意代码插入SQL语句中，获取到未授权的数据或者执行恶意操作。</li><li>SQL注入是一种比较隐蔽的攻击方式，因为它可以绕过应用程序的认证和访问控制，进而直接利用存在漏洞的SQL语句进行数据库操作。</li></ul><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><ul><li>在实际开发，为了管理连接池和数据源，可以用一些第三方连接池框架，比如C3P0和Druid等</li><li>DataSource作为一个轻量级的数据库连接池，可以大大提高系统的性能，扩展和维护性。使用DataSource时，需要先配置驱动类名，URL，用户名，密码，初始化连接数量，最大连接数量，超时时间等。当应用程序需要连接数据库时候，可以从数据源中获取连接来执行相应操作。</li></ul><h3 id="DataSource的获取与释放"><a href="#DataSource的获取与释放" class="headerlink" title="DataSource的获取与释放"></a>DataSource的获取与释放</h3><ul><li>通过JNDI获取DataSource对象时，通常需要进行初始化，创建一个InitialContext对象，将相关的参数信息放入Context中然后查找数据源。使用后，需要将连接释放会连接池。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化Context对象。</span></span><br><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialConrext</span>();、</span><br><span class="line"><span class="comment">//根据JNDI名称查找DataSource对象。</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource)ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/mydb&quot;</span>);</span><br><span class="line"><span class="comment">//从数据源中获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"><span class="comment">//使用连接进行数据操作</span></span><br><span class="line"><span class="comment">// ..........</span></span><br><span class="line"><span class="comment">//释放连接</span></span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据源的配置方式"><a href="#数据源的配置方式" class="headerlink" title="数据源的配置方式"></a>数据源的配置方式</h3><ul><li>DataSource 可以通过XML或Properties文件进行配置。对Spring框架等，也支持java代码的配置方式来获取数据源</li></ul><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><ol><li>为每个线程创建单独的Connection对象。可以使用ThreadLocal对象来保证每个线程都有自己的对象</li><li>连接池管理连接资源，能够对连接对象进行有效的监控和管理，从而避免了多个线程竞争同一个Connection对象的问题。允许线程取走，但是使用后归还连接池，供其他复用。</li><li>确保事务的独立性，每个线程会开启事物，提交或回滚事物，可以保证多个线程之间不会干扰彼此。</li></ol><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>将多个命令按照顺序集成在一个文件中，批量执行的技术。通过一系列脚本或命令来完成。</li></ul><h3 id="Statement处理"><a href="#Statement处理" class="headerlink" title="Statement处理"></a>Statement处理</h3><ol><li>使用Statement对象进行批处理，通过addBatch()将多个SQL命令添加到一个批处理中去，并使用executeBatch()方法来执行批处理。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">statement.addBatch(<span class="string">&quot;INSERT INTO user(name,age) values(&#x27;Lily&#x27;,18)&quot;</span>);</span><br><span class="line">statement.addBatch(<span class="string">&quot;INSERT INTO user(name,age) values(&#x27;Tom&#x27;,20)&quot;</span>);</span><br><span class="line">statement.addBatch(<span class="string">&quot;UPDATE user SET age=&#x27;19&#x27; WHERE id=&#x27;1&#x27;&quot;</span>);</span><br><span class="line"><span class="type">int</span>[] count = statement.executeBatch(); <span class="comment">//批量执行SQL语句</span></span><br><span class="line">connection.commit();<span class="comment">// 提交事务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PreparedStatement处理"><a href="#PreparedStatement处理" class="headerlink" title="PreparedStatement处理"></a>PreparedStatement处理</h3><p>同上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">INSERT_SQL</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user(name,age) values(?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(INSERT_SQL);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">18</span>);</span><br><span class="line">pstmt.addBatch();</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">pstmt.addBatch();</span><br><span class="line"><span class="type">int</span>[] count = pstmt.executeBatch();</span><br><span class="line">connection.commit();<span class="comment">// 提交事务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Spring批处理实现大规模数据库操作"><a href="#Spring批处理实现大规模数据库操作" class="headerlink" title="Spring批处理实现大规模数据库操作"></a>Spring批处理实现大规模数据库操作</h3><ol><li>一般要创建Job，Step，ItemReader,ItemProcessor,ItemWriter</li></ol><p>Job：批处理的最顶层组件，表示一个或多个并行 Step 的顺序运行。可以将其视为一个顶级容器，可包含多个 Step。</p><p>Step：是 Batch 处理的主要单位，表示一个任务步骤。可以对每一个步骤进行配置，比如设置读取文件、处理逻辑、验证等。</p><p>ItemReader：用于读取数据，通常从文件或数据库中读取数据。每次读取一条数据进行处理。</p><p>ItemProcessor：对 ItemReader 返回的数据进行进一步处理，可以对数据进行过滤、转换等操作，比如将一定格式的文本转化成 Java 对象。</p><p>ItemWriter：根据需要将读取到的数据写入到指定位置，如写入到数据库、写入到文件等。</p><ol start="2"><li><p>配置Job和Step<br>需要创建job和step的配置类，这些将负责配置Batch的核心组件，数据源，事务和监听器，通过XML文件或Java Config 进行配置，实现Batch批处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobBuilderFactory jobs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StepBuilderFactory steps;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Step <span class="title function_">step1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> steps.get(<span class="string">&quot;step1&quot;</span>)</span><br><span class="line">            .&lt;String, String&gt;chunk(<span class="number">10</span>)</span><br><span class="line">            .reader(reader())</span><br><span class="line">            .processor(processor())</span><br><span class="line">            .writer(writer())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Job <span class="title function_">job</span><span class="params">(Step step1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.get(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">            .incrementer(<span class="keyword">new</span> <span class="title class_">RunIdIncrementer</span>())</span><br><span class="line">            .flow(step1)</span><br><span class="line">            .end()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义具体的 Reader、Processor、Writer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>定义 ItemProcessor、ItemReader 和 ItemWriter<br>Batch 模块提供了大量优秀的处理器和读写器，这些对象可以快速地实现批处理任务。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC学习笔记&quot;&gt;&lt;a href=&quot;#JDBC学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JDBC学习笔记&quot;&gt;&lt;/a&gt;JDBC学习笔记&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="java" scheme="https://kalyan-zitiu.github.io/categories/java/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>网络管理员</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/15/%E5%88%9D%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/15/%E5%88%9D%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98/</id>
    <published>2023-04-15T13:32:00.000Z</published>
    <updated>2023-04-22T08:10:29.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机硬件基础"><a href="#计算机硬件基础" class="headerlink" title="计算机硬件基础"></a>计算机硬件基础</h2><h3 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h3><h4 id="R进制"><a href="#R进制" class="headerlink" title="R进制"></a>R进制</h4><table><thead><tr><th>R进制</th><th></th><th></th></tr></thead><tbody><tr><td>二进制</td><td>0~1（整数）</td><td>（10）B (10)<del>2</del></td></tr><tr><td>八进制</td><td>0~7（整数）</td><td>（10）O (10)<del>8</del></td></tr><tr><td>十进制</td><td>0~9（整数）</td><td>（10）D (10)<del>10</del></td></tr><tr><td>十六进制</td><td>0~F（整数）</td><td>（10）H (10)<del>16</del></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><h5 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h5><ul><li>A+B，同0为0，否则为1</li></ul><h5 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h5><ul><li>A x B，同1为1，否则为0</li></ul><h5 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h5><ul><li>与A相反</li></ul><h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><ul><li>同为0，不同则为1。<h3 id="计算机结构（冯诺伊曼体系结构）"><a href="#计算机结构（冯诺伊曼体系结构）" class="headerlink" title="计算机结构（冯诺伊曼体系结构）"></a>计算机结构（冯诺伊曼体系结构）</h3></li><li>包含五个部件：输入设备，存储器，输出设备，运算器和控制器（统称为中央处理器CPU）</li><li>存储器：主存或内存，还未涉及到外存 </li><li>运算器：负责程序运算与逻辑判断等操作<ol><li>算术逻辑单元ALU：进行算术与逻辑运算。</li><li>累加寄存器ACC：暂时存放中间结果值。</li><li>数据缓冲寄存器：把主存与CPU交换的数据暂时放在此处。</li><li>状态条件寄存器：存储状态信息，异常。</li></ol></li><li>控制器：负责协调各周边组件与各单元间的工作<ol><li>程序计算器PC：存放指令的地址，在主存中取入CPU，取后进行PC+1。</li><li>指令寄存器IR：在主存中取出的指令会放在IR中。</li><li>指令译码器：将IR’中的指令转换为可执行的操作，以便在计算机中执行。</li><li>时序部件：指导CPU内数据通路执行各种操作的时序，以确保计算机各部件能够按预期的时间步骤相互协调工作。</li></ol></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032128353.png" alt="image-20230403212815294"></li></ul><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul><li>指令一般包含操作码和地址码<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032229744.png" alt="image-20230403222949707"><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4></li><li>操作数直接在指令中，速度快，灵活性差.不需要访问主存。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032232280.png" alt="image-20230403223249253"></li></ul><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><ul><li>指令中存放着操作数的地址</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032235448.png" alt="image-20230403223544423"></li></ul><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><ul><li>指令中存放一个地址，这个地址对应的内容式操作数的地址</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032237174.png" alt="image-20230403223747149"></li></ul><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><ul><li>寄存器存放操作数</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032239109.png" alt="image-20230403223924082"><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4></li><li>存放式操作数的地址。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304032241247.png" alt="image-20230403224121223"></li></ul><h4 id="Flynn弗林分类"><a href="#Flynn弗林分类" class="headerlink" title="Flynn弗林分类"></a>Flynn弗林分类</h4><table><thead><tr><th>体系结构类型</th><th>结构</th><th>关键特性</th><th>代表</th></tr></thead><tbody><tr><td>单指令流单数据流SISD</td><td>控制部分：1  处理器：1  主存模块：1</td><td></td><td>单处理器系统</td></tr><tr><td>单指令流多数据流SIMD</td><td>控制部分：1  处理器：多个 主存模块：多个</td><td>各处理器以异步的形式执行同一条指令</td><td>并行处理机，阵列处理机，超级向量处理机</td></tr><tr><td>多指令流单数据流MISD</td><td>控制部分：多个  处理器：1  主存模块：多个</td><td>被证明不可能至少是不实际</td><td>流水线计算机</td></tr><tr><td>多指令流多数据流MIMD</td><td>控制部分：多个  处理器：多个  主存模块：多个</td><td>能够实现作业任务，指令等各级全面并行</td><td>多处理机系统。多计算机</td></tr></tbody></table><h3 id="流水线计算"><a href="#流水线计算" class="headerlink" title="流水线计算"></a>流水线计算</h3><h4 id="未使用流水线执行指令"><a href="#未使用流水线执行指令" class="headerlink" title="未使用流水线执行指令"></a>未使用流水线执行指令</h4><ul><li>完成好一条指令的取出，分析和执行后再进行下一条</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304041645099.png" alt="image-20230404164540056"><h4 id="使用流水线执行指令"><a href="#使用流水线执行指令" class="headerlink" title="使用流水线执行指令"></a>使用流水线执行指令</h4></li><li>每个子任务可以并行处理，并且一旦完成，就可以传递给下一个子任务。这样可以大大提高计算机执行任务的效率。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304041646686.png" alt="image-20230404164612654"></li></ul><h4 id="执行时间"><a href="#执行时间" class="headerlink" title="执行时间"></a>执行时间</h4><ul><li>（t<del>1</del>+t<del>2</del>+t<del>3</del>）+ （n-1）t</li></ul><p><strong>注意：</strong>t是流水线周期，它表示执行时间最长的一段。</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><ol><li>若指令流水线把一条指令分为取指，分析和执行三部分，且三部分的时间分别是取指2ns，分析2ns，执行1ns。那么，流水线周期是？100条指令全部执行完毕需要的时间是？</li></ol><ul><li>a. 流水线周期表示的是执行时间最长的一段（令的处理涉及多个阶段，如取指、解码、执行、访存等。如果取指需要1个时钟周期，解码需要2个时钟周期，执行需要3个时钟周期，访存需要2个时钟周期，则流水线周期为最长的阶段周期，即3个时钟周期。也就是说，每个指令的执行时间至少需要3个时钟周期才能完成。）2ns.</li><li>b. (2+2+1)+(100-1)x2（流水线周期） = 203ns.</li></ul><p><strong>需要注意的是：</strong>按顺序和流水线方式执行的时间是不一样的 </p><h3 id="多级存储器结构"><a href="#多级存储器结构" class="headerlink" title="多级存储器结构"></a>多级存储器结构</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>寄存器：速度快，容量小，成本高（一般在CPU内）</li><li>高速缓存：按内容存取（CPU经常要读取主存的数据）</li><li>主存：RAM（随机存储，掉电丢失），ROM（只读存储器，如BIOS） <ol><li>CPU可能会和主存存在读取速率不匹配，所以会存在高速缓存。 </li><li>RAM又分为DRAM（动态随机存取存储器）和SRAM（静态随机存取存储器）</li><li>DRAM是能够在电脑中进行高速读取和写入数据的内存芯片，拥有着大容量低成本的优点，但相对来说，RAM内存的读写速度要慢于SRAM。</li><li>SRAM是一种更快的内存芯片。它工作时所需要的电源比DRAM内存低，SRAM芯片的存储容量较小而且成本较高，但是SRAM内存的读写速度更快。常用在高速缓存或者寄存器等需要快速数据存取场合。</li><li>刷新电路：在DRAM中，内部的存储电容需要不断刷新以保持数据的有效性。DRAM内部存储单元使用一个电容来存储每一位数据，所以DRAM需要定期进行刷新（称为“自刷新”），防止的是信息失效，消耗大量的能量，在使用DRAM之前必须初始化，并且内部要定期进行刷新。</li><li>刷新电路：在SRAM中是不存在刷新的，因为它使用的存储器电路来存储每一位数据，不需要维持电荷状态。<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><h5 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h5></li></ol></li></ul><p><strong>注意：</strong>1字节=8比特</p><ul><li>按字编址：存储体的存储单元是字存储单元，即最小寻址单位是一个字。</li><li>按字节编址：存储体的存储单元是字节存储单元，即最小寻址单位是一个字节。</li><li>无论是字节还是字，都指的是存储体的容量</li><li>根据存储器所需求的容量和选定的存储芯片的容量，可以计算出所需芯片的总数，即：总片数=总容量/每片的容量<h5 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h5></li></ul><ol><li><p>若内存地址区间为4000H~43FFH，每个存储单元可存储16位二进制数，该内存区域用4片存储器芯片构成，则构成该内存所用的存储器芯片的容量是多少。<br> 答： [3FFH - 4000H）+ 1] * 16bit = 4x;<br> ​                                       1K * 2B = 4x<br> ​                                                  x  = 0.5 KB<br> ​                                                         = 4 kb</p></li><li><p>在计算机系统中总线宽分为地址总线宽度和数据总线宽度。若计算机中地址总线的宽度为32位，则最多允许直接访问主存储器（）物理空间<br>  答：2^32^  = 4GB</p></li><li><p>设内存按字节编址，若8K * 8存储空间的起始地址为7000H，则该存储空间的最大地址编号为（）。<br> 答：（x - 7000H + 1） * 8bit  = 8K * 8bit。<br> ​                                             x + 1= 9000H<br> ​                                                  x = 8FFFH</p></li></ol><h4 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h4><ul><li>非格式化容量 = 位密度 * Π * 最内圈直径 * 总磁道数</li></ul><p><strong>注意：</strong>位密度是每道不同的，但每道的容量是相同的。0道是最外面的磁道，其位密度最小。</p><ul><li>格式化容量 = 每道扇区数 * 扇区容量 * 总磁道数</li><li>平均数据传输速率 = 每道扇区数 * 扇区容量 * 盘片转数</li><li>存取时间（平均访问时间） = 寻道时间+ 等待时间（平均定位时间+转动延迟）</li></ul><p><strong>注意：</strong>寻道时间是指磁头移动到磁道所需时间，等待时间为等待读写的扇区转到磁头下方所用的时间。 </p><ul><li>硬盘的性能指标包括磁盘转速，容量，平均寻道时间，平均访问时间=平均寻道时间+ 平均等待时间</li></ul><h4 id="主存-外存虚拟体系"><a href="#主存-外存虚拟体系" class="headerlink" title="主存-外存虚拟体系"></a>主存-外存虚拟体系</h4><ul><li>它是一种计算机存储器管理方式</li><li>操作系统通过虚拟内存技术将主存和外存组合了一个“虚拟”地址空间，并且提供了对外的访问支持，使得计算机可以像访问主存一样访问外存。</li><li>计算机虚拟地址空间被划分未一系列固定大小得“页面”，每个页面都是若干个字节的集合。当程序需要访问某个页面时，就会首先查询这个页面是否已经在主存中，如果有，便执行相关操作。如果页面不存在主存中，则需要将其从外存中取出，并且分配一个在主存中的空间，才进行相关操作。</li><li>主存的大小是有限的，而外存的大小相对较大，因此，虚拟内存技术是的计算机的存储容量的到很大的扩展，从而能够处理更大规模的数据和程序。<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4></li><li>以时间顺序进行存储，例如,磁带。</li><li>每个数据元素占据一个确定的存储空间，每个数据元素的存储位置是连续的。<h4 id="直接存储"><a href="#直接存储" class="headerlink" title="直接存储"></a>直接存储</h4></li><li>有地址，与位置有关，例如：硬盘，软盘，光盘</li><li>直接存储中的存储位置通常由记录的关键字直接映射计算得到，因此可以通过关键字的值快速地定位记录的存储位置。<h4 id="随机存储"><a href="#随机存储" class="headerlink" title="随机存储"></a>随机存储</h4></li><li>有地址，与位置无关，例如：内存，U盘</li><li>内存条，处理数据时候每次存储的位置可能不同。<h4 id="相联存储"><a href="#相联存储" class="headerlink" title="相联存储"></a>相联存储</h4></li><li>按内容存取，例如：Cache</li><li>也叫内容寻址存储，可以根据存储单元内容来访问的存储器。与传统存储器需要根据地址来访问不同，相联存储器可以根据存储单元中存储的数据来快速查找对应的存储位置。</li><li>常用于进行高速的查找和匹配操作，如在路由器中匹配IP地址，在数据库中查找关键字等。相对于传统存储器，相联村存储通常读写速度慢，成本较高，容量较小，但其可并行进行查找和匹配操作，能够大大提高系统的查找效率。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304052138628.png" alt="image-20230405213851572"><h5 id="布尔相联存储器"><a href="#布尔相联存储器" class="headerlink" title="布尔相联存储器"></a>布尔相联存储器</h5></li><li>将存储单元中的数据编码为布尔表达式（Boolean Expression），通过逻辑运算实现查找和匹配操作。</li><li>每个存储单元可以表示为一个布尔表达式，该表达式由逻辑操作符和变量组成，用来描述要查找的数据或状态。查找时，系统将所要查找或匹配的数据或状态，表示为一个布尔表达式，然后将其与存储单元中的布尔表达式进行逻辑运算，从而实现查找或匹配。</li><li>在一个路由器中，可以使用布尔相联存储器来匹配IP地址和掩码。那么每个存储单元中就可以编码为一个布尔表达式，用来描述要匹配的IP地址和掩码。当有一个新的IP地址需要匹配时，系统将它表示成一个布尔表达式，然后与存储单元中的布尔表达式进行逻辑运算，最终可以快速地找到匹配的存储单元。</li><li>逻辑简单、运算速度快、查找效率高等。缺点是存储单元中的数据格式比较特殊，难以支持一些通用的应用。此外，由于布尔相联存储器的实现方式比较复杂，所以成本较高。<h5 id="全相联存储器"><a href="#全相联存储器" class="headerlink" title="全相联存储器"></a>全相联存储器</h5></li><li>是一种相联存储器实现方式，它的主要特点是所有存储单元都可以用来存储任何数据，而不需要通过地址进行访问。</li><li>每个存储单元都有一个标记字段（Tag Field）和一个数据字段（Data Field）。标记字段用来记录存储单元中存储的数据的唯一标识，而数据字段则用来存储数据本身。当需要进行查找或匹配时，系统根据标记字段进行比较，找到匹配的存储单元，然后读取对应的数据字段中的数据。</li><li>优点是可以存储任意数据，具有很高的灵活性，而且查找效率也很高，因为存储单元与查找数据之间的关系是任意的。不过，全相联存储器的缺点是复杂度和成本比较高，易受到热点数据访问和容量限制的影响。<h5 id="直接映射存储器"><a href="#直接映射存储器" class="headerlink" title="直接映射存储器"></a>直接映射存储器</h5></li><li>简单的缓存映射方式之一。它将主存中的地址空间划分为若干个缓存块，每个缓存块只能映射到一个特定的缓存行。具体来说，在一个直接映射缓存中，主存的地址空间被划分为n个缓存块（或称为缓存片），缓存共有m个行（或称为缓存行），每个缓存块可以映射到1个缓存行，这个映射关系可以用一个简单的哈希函数实现。</li><li>优点是实现简单、硬件成本低，因为它仅仅需要一个简单的哈希函数来实现地址映射。缺点是容易出现冲突，即多个主存地址映射到同一个缓存行上，因此需要通过特定的策略选取替换方案来解决这个问题。<h5 id="组相联存储器"><a href="#组相联存储器" class="headerlink" title="组相联存储器"></a>组相联存储器</h5></li><li>也称为组关联存储器，是介于全相联存储器和直接映射存储器之间的一种常见的缓存映射方式。组相联存储器将主存地址空间划分为若干个组，每个组由几个缓存行组成。与直接映射缓存相比，组相联缓存中每个组可以映射到多个缓存行，不同组之间则通过哈希函数将主存地址映射到不同的组中。</li><li>假设有一个4路组相联缓存，总容量为16KB，缓存行大小为64B，主存地址空间为32KB。则该4路组相联缓存会将主存地址空间划分为8个组，每个组由4个缓存行组成，每个缓存行为64B，总缓存行数为256条。在缓存组内部的映射关系则由替换策略和缓存策略共同决定。</li><li>优点是比较灵活，可以在一定程度上缓解冲突问题，同时其硬件实现相对于全相联缓存也不需要太复杂。缺点是需要更多的硬件资源支持<h3 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h3></li><li>数字信号传输：数据通信中传输的信号都是数字信号，数字信号可以通过不同的线路或信道传输（如同同轴电缆，光纤，无线电波）</li><li>编码：数字信号需要经过编码才能传输，最常用的编码方式是二进制编码，将数据转化为二进制数进行传输。</li><li>数据传输模式：数据可以按照串行传输或并行传输两种模式进行传输。串行传输是逐位将数据传输，而并行传输是指多为数据同时进行传输。</li><li>调制和解调：在一些通信方式中，需要将数字信号转化为模拟信号进行传输，需要进行调制。接收方需要通过解调将接收到的信号转化为数字信号。</li><li>网络拓扑结构：网络中不同设备之间的链接方式叫做网络拓扑结构，常见的网络拓扑结构有星型，总线型，环型。</li><li>协议：数据通信中使用的协议制定了传输数据的格式，数据的传输方式，错误检测和修复等通信规则</li><li>电信号传播：电信号在传输过程中会遇到干扰和衰减，因此需要采取一些技术如中继，放大器等来保证信号质量。</li></ul><h3 id="香农定理与奈氏准则"><a href="#香农定理与奈氏准则" class="headerlink" title="香农定理与奈氏准则"></a>香农定理与奈氏准则</h3><ul><li>香农定理：C = Wlog<del>2</del>(1+S/N)(b/s)</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304112201060.png" alt="image-20230411220151989"></p><ul><li>奈氏准则：R = 2Wlong<del>2</del>V</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304112202303.png" alt="image-20230411220214256"></p><h4 id="需知"><a href="#需知" class="headerlink" title="需知"></a>需知</h4><ul><li><p>码元：一个固定时长的信号波形也可以是数字脉冲，是一种信号。</p></li><li><p>码元速度：一波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的。</p></li><li><p>信息传输速率（信息速率，比特率）：单位时间内数字通信系统传输的二进制码元个数（比特数），单位是比特/秒</p></li></ul><h3 id="调制技术-模拟信道传送数字数据"><a href="#调制技术-模拟信道传送数字数据" class="headerlink" title="调制技术-模拟信道传送数字数据"></a>调制技术-模拟信道传送数字数据</h3><table><thead><tr><th>调制技术</th><th>说明</th><th>码元种类</th><th>比特位</th><th>特点</th></tr></thead><tbody><tr><td>ASK</td><td>用恒定的载波振幅值表示一个数（通常是1），无载波表示另一个数</td><td>2</td><td>1</td><td>实现简单，但是抗干扰性差，效率低</td></tr><tr><td>FSK</td><td>由载波频率，附近两个频率，表示两个不同值，恰好为中值</td><td>2</td><td>1</td><td>抗干扰性较ASK更强，但占用带宽较大，典型熟读也是1200bps</td></tr><tr><td>PSK</td><td>用载波的相位偏移来表示数据值</td><td>2</td><td>1</td><td>抗干扰性最好。而且相位的变化可以作为定时信息来同步时钟</td></tr><tr><td>4DPSK</td><td>四差分相移键控</td><td>4</td><td>2</td><td>每90度表示一种状态</td></tr><tr><td>QPSK</td><td>正交相移键控</td><td>4</td><td>2</td><td>每90度表示一种状态</td></tr></tbody></table><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122145622.png" alt="image-20230412214520546"></p><h3 id="编码技术-数字信道传递模拟数据"><a href="#编码技术-数字信道传递模拟数据" class="headerlink" title="编码技术-数字信道传递模拟数据"></a>编码技术-数字信道传递模拟数据</h3><h4 id="PCM脉冲编码调制技术"><a href="#PCM脉冲编码调制技术" class="headerlink" title="PCM脉冲编码调制技术"></a>PCM脉冲编码调制技术</h4><ul><li>采样(奈奎斯采样定律):将连续的模拟信号在时间上进行离散化，即在一定的时间间隔内对信号进行抽样。采样的频率越高，离散化误差就越小。</li><li>量化:将采样到的信号离散化，每个采样值用一个数字表示。量化误差取决于量化精度，即一个采样值可以表示的数字数量。</li><li>编码:将量化后的数字信号转换成可传输或存储的二进制格式。</li></ul><h4 id="基本编码"><a href="#基本编码" class="headerlink" title="基本编码"></a>基本编码</h4><h5 id="单极性码"><a href="#单极性码" class="headerlink" title="单极性码"></a>单极性码</h5><ul><li>用高电平或低电平代表一个比特位</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122203402.png" alt="image-20230412220302361"><h5 id="极性码"><a href="#极性码" class="headerlink" title="极性码"></a>极性码</h5></li><li>用高低电平代表一个比特位0或1</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122203309.png" alt="image-20230412220315271"><h5 id="双极性码"><a href="#双极性码" class="headerlink" title="双极性码"></a>双极性码</h5></li><li>无电平表示0,遇到1进行电平翻转</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122204756.png" alt="image-20230412220404713"></li></ul><h5 id="归零码RZ"><a href="#归零码RZ" class="headerlink" title="归零码RZ"></a>归零码RZ</h5><ul><li>无论使用高低电平表示比特,最终都需要回归无电平位<h5 id="不归零码NRZ"><a href="#不归零码NRZ" class="headerlink" title="不归零码NRZ"></a>不归零码NRZ</h5></li></ul><ol><li>信号电压的一次翻转表示1,电平不变化表示0,并且表示完一个码元后,电压不需回到0</li><li>高电平表示1,低电平表示0<h5 id="双相码"><a href="#双相码" class="headerlink" title="双相码"></a>双相码</h5></li></ol><ul><li>在每一个比特时间内都有电平变化</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122219934.png" alt="image-20230412221919895"></li></ul><h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h5><ul><li>电压从高到低表示1,反之则表示0.定义也可以相反</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122220670.png" alt="image-20230412222019632"></li></ul><h5 id="差分曼彻斯特"><a href="#差分曼彻斯特" class="headerlink" title="差分曼彻斯特"></a>差分曼彻斯特</h5><ul><li>每个时间间隔的开始处,0使信号在时间间隔的开始处跳变,而1将会使信号保持它在前一个时间间隔尾部的取值.</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304122220024.png" alt="image-20230412222045985"></li><li>曼码常用于10M以太网,差分曼码常用于令牌环网,其编码效率只有50%.</li></ul><h4 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h4><table><thead><tr><th>编码方案</th><th>说明</th><th>效率</th><th>典型应用</th></tr></thead><tbody><tr><td>4B/5B</td><td>每次对4位数据进行编码,将其转为五位符号</td><td>1.25波特/位 即80%</td><td>100Base-FX,100Base-TX,FDDI</td></tr><tr><td>8B/10B</td><td>每次对8位数据位进行编码,将其转为10位符号</td><td>80%</td><td>千兆以太网</td></tr><tr><td>8B/6T</td><td>8bit映射为6个三进制位</td><td>0.75波特/位</td><td>100Base-T4</td></tr></tbody></table><h3 id="windows基本管理-网络配置命令"><a href="#windows基本管理-网络配置命令" class="headerlink" title="windows基本管理-网络配置命令"></a>windows基本管理-网络配置命令</h3><h4 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h4><h5 id="一般指令"><a href="#一般指令" class="headerlink" title="一般指令"></a>一般指令</h5><ul><li>ipconfig / all ：显示本机TCP/IP配置的详细信息</li><li>ipconfig / release：DHCP客户端手工释放IP地址</li><li>ipconfig / renew：DHCP客户端手工向服务器刷新请求</li><li>ipconfig / flushdns：清除本地DNS缓存内容</li><li>ipconfig / displaydns：显示本地DNS内容</li></ul><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>用来检测与另外一个网络设备之间的连通性。</li><li>测试网络带宽：ping命令可以通过测试从本地主机到目的主机的RTT来评估延迟和带宽</li><li>定位网络故障：ping命令能够快速识别网络拥塞，路由器故障，防火墙阻止请求。</li><li>测试主机性能，通过发送不同大小和数据类型的ping数据包，可以测试网路设备和服务器的性能和稳定性</li><li>在网络安全上，能够扫描网络中开放的主机和端口等潜在漏洞。大多数的操作系统都提供了关闭ping响应功能，以增加网络安全性。<h5 id="一般指令-1"><a href="#一般指令-1" class="headerlink" title="一般指令"></a>一般指令</h5></li><li>ping -t 目标ip/域名：持续ping，直到终止</li><li>ping -l 目标ip/域名：指定数据包大小（字节）</li><li>ping -a 目标ip/域名：ping的同时，解析目的主机名</li><li>ping -n 目标ip/域名：指定回显数据报的数目</li></ul><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><h5 id="一般指令-2"><a href="#一般指令-2" class="headerlink" title="一般指令"></a>一般指令</h5><ul><li>netstat /a：显示所有连接和监听端口</li><li>netstat /s：显示按协议统计信息</li><li>netstat /e：显示以太网统计信息</li><li>netstat /r：显示路由表</li><li>netstat /n：以数字形态显示地址和端口号</li><li>netstat /o：显示与每个连接相关的所属进程</li></ul><h4 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><ul><li>是一个网络诊断工具，可以用于追踪数据包在网络传输过程中<strong>经过的路由结点</strong>。</li></ul><h5 id="一般命令"><a href="#一般命令" class="headerlink" title="一般命令"></a>一般命令</h5><ul><li>tracert 目标ip/域名：路由跟踪<h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tracert www.googel.com</span><br><span class="line"></span><br><span class="line">Tracing route to www.google.com [172.217.174.196]over a maximum of 30 hops:</span><br><span class="line"></span><br><span class="line">1    &lt;1 ms    &lt;1 ms    &lt;1 ms  192.168.1.1</span><br><span class="line">2     5 ms     4 ms     4 ms  xxx.xxx.xx.xx</span><br><span class="line">3     9 ms     9 ms     8 ms  202.99.234.113</span><br><span class="line">4   **    Request timed out.**</span><br><span class="line">5    11 ms    10 ms    10 ms  202.99.234.254</span><br><span class="line">6    35 ms    35 ms    34 ms  202.97.53.29</span><br><span class="line">7    36 ms    35 ms    35 ms  72.14.215.199</span><br><span class="line">8    35 ms    35 ms    35 ms  108.170.232.15</span><br><span class="line">9    33 ms    33 ms    33 ms  209.85.247.12</span><br><span class="line">10    35 ms    35 ms    35 ms  209.85.251.1</span><br><span class="line">11    41 ms    42 ms    42 ms  172.253.66.41</span><br><span class="line">12    43 ms    42 ms    42 ms  216.239.47.93</span><br><span class="line">13    41 ms    41 ms    41 ms  172.217.174.196</span><br><span class="line"></span><br><span class="line">Trace complete.</span><br></pre></td></tr></table></figure><h4 id="Route-print"><a href="#Route-print" class="headerlink" title="Route print"></a>Route print</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5></li><li>能够显示本地路由表信息</li></ul><h5 id="举例演示"><a href="#举例演示" class="headerlink" title="举例演示"></a>举例演示</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route print</span><br><span class="line"></span><br><span class="line">Interface List</span><br><span class="line"> 11...00 ff 5c 01 34 3e ......Realtek PCIe GBE Family Controller</span><br><span class="line">  1...........................Software Loopback Interface 1</span><br><span class="line"> 12...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter</span><br><span class="line"></span><br><span class="line">IPv4 Route Table</span><br><span class="line">===========================================================================</span><br><span class="line">Active Routes:</span><br><span class="line">Network Destination        Netmask          Gateway       Interface  Metric</span><br><span class="line">          0.0.0.0          0.0.0.0    192.168.1.254    192.168.1.101     25</span><br><span class="line">      127.0.0.0        255.0.0.0         On-link         127.0.0.1    306</span><br><span class="line">      127.0.0.1  255.255.255.255         On-link         127.0.0.1    306</span><br><span class="line">127.255.255.255  255.255.255.255         On-link         127.0.0.1    306</span><br><span class="line">    169.254.0.0      255.255.0.0         On-link     192.168.1.101   9251</span><br><span class="line">  169.254.74.25  255.255.255.255         On-link     192.168.1.101   9251</span><br><span class="line">  169.254.255.255  255.255.255.255         On-link     192.168.1.101   9251</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>rourte print命令列出本地路由。首先是一个网络接口列表，然后IPv4路由表。每个路由数据元素都包括<strong>目标网络</strong>，<strong>子网掩码</strong>，网关，<strong>接口</strong>和<strong>度量值</strong>。</p><ul><li>Destination：目的网络或者子网地址。</li><li>Netmask：子网掩码，用于与目标地址进行“与”运算，以提取网络地址。</li><li>Gateway：下一跳网关的IP地址。</li><li>Interface：本地接口的IP地址。</li><li>Metric：到目的网络的跳数。<br>如果路由表没有针对特定网络的路由规则，则所有传输到其他网络的流量都将通过这个网关进行传输。</li></ul><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><ul><li>查询internet域名信息或DNS服务器上的域名解析信息。</li></ul><h5 id="演示举例"><a href="#演示举例" class="headerlink" title="演示举例"></a>演示举例</h5><p>在演示中，可以看到nslookup命令返回了一个非权威回答方式的解析结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup www.google.com</span><br><span class="line"></span><br><span class="line">Server:  UnKnown</span><br><span class="line">Address:  192.168.1.1</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    www.google.com</span><br><span class="line">Addresses:  2607:f8b0:4009:80f::2004</span><br><span class="line">          172.217.5.196</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Linux基本管理"><a href="#Linux基本管理" class="headerlink" title="Linux基本管理"></a>Linux基本管理</h4><h5 id="Linux常见目录及其说明"><a href="#Linux常见目录及其说明" class="headerlink" title="Linux常见目录及其说明"></a>Linux常见目录及其说明</h5><p>以下是Linux操作系统中常见的目录，以及它们的作用和含义：</p><h6 id="bin"><a href="#bin" class="headerlink" title="/bin"></a><code>/bin</code></h6><p><code>/bin</code>目录（短为“二进制”）包含大部分常规用户可用的命令程序和可执行文件。这些程序和文件可以在任何程序都还没有启动时被访问和执行，因为<code>/bin</code>目录在启动时就已经加载了。</p><h6 id="boot"><a href="#boot" class="headerlink" title="/boot"></a><code>/boot</code></h6><p><code>/boot</code>目录包含用于启动Linux系统的引导装载器（Boot loader）及其配置文件。该目录通常会被分配一定的空间，以确保内核始终能够被存储在那里，并能够从系统启动时访问。</p><h6 id="dev"><a href="#dev" class="headerlink" title="/dev"></a><code>/dev</code></h6><p><code>/dev</code>目录是一个虚拟文件系统，其中存储了与计算机硬件设备有关的文件，例如键盘、鼠标、打印机等等。这些文件可以在需要时被挂载到特定的目录中，并且在使用完成后则会被卸载。</p><h6 id="etc"><a href="#etc" class="headerlink" title="/etc"></a><code>/etc</code></h6><p><code>/etc</code>目录中包含了系统全局的配置文件，如常见的系统配置文件、网络配置参数、各类服务和守护程序的启动脚本等等。管理员可以通过编辑<code>/etc</code>目录下的配置文件来改变系统行为和功能。</p><h6 id="home"><a href="#home" class="headerlink" title="/home"></a><code>/home</code></h6><p><code>/home</code>目录是系统用户的主目录，可用于储存用户自己的文件和数据。每个用户有一个其自己的个人目录，该目录会在每个创建时相应被设置权限并拥有其所有权。</p><h6 id="lib-and-lib64"><a href="#lib-and-lib64" class="headerlink" title="/lib and /lib64"></a><code>/lib</code> and <code>/lib64</code></h6><p><code>/lib</code>目录（短为“库”）包含了许多基本的共享程序库，它们被许多其他程序所共享使用。此外，在64位系统上，还存在一个<code>/lib64</code>目录，其中包含与<code>/lib</code>目录相同的文件，只不过是由于支持64位程序所导致的。</p><h6 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a><code>/lost+found</code></h6><p>该目录维护系统的未分配扇区（unallocated sectors），并在系统崩溃时被用于恢复数据。</p><h6 id="media"><a href="#media" class="headerlink" title="/media"></a><code>/media</code></h6><p><code>/media</code>目录是一个临时的挂载点，用户可以将可移动虚拟媒体（如USB闪存驱动器、CD-ROM等）挂载到该目录中，以便能够在系统中访问这些媒体。</p><h6 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a><code>/mnt</code></h6><p><code>/mnt</code>目录也是一个用于挂载其他文件系统的目录，但通常只用于短期挂载。</p><h6 id="opt"><a href="#opt" class="headerlink" title="/opt"></a><code>/opt</code></h6><p><code>/opt</code>目录通常被用来存放第三方软件包（又称“可选软件”），而不是通过Linux发行版或官方软件库安装的东西。</p><h6 id="proc"><a href="#proc" class="headerlink" title="/proc"></a><code>/proc</code></h6><p><code>/proc</code>目录是一个动态的文件系统，它被用于在运行时动态地显示有关系统内核和硬件设备信息的虚拟文件系统。</p><h6 id="root"><a href="#root" class="headerlink" title="/root"></a><code>/root</code></h6><p>与<code>/home</code>类似，<code>/root</code>目录是系统管理员的主目录。该目录允许root用户（超级用户）访问自己的个人文件和数据。</p><h6 id="run"><a href="#run" class="headerlink" title="/run"></a><code>/run</code></h6><p><code>/run</code>目录是一个包含运行时临时文件的目录，例如进程ID（pid）文件、锁文件和套接字文件等。</p><h6 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a><code>/sbin</code></h6><p><code>/sbin</code>目录（短为“超级二进制”）中包含了在系统引导时会被执行的必需的系统管理程序。<code>/bin</code>中的程序通常可以由普通用户使用，而<code>/sbin</code>中的程序只能由管理员或超级用户使用。</p><h6 id="srv"><a href="#srv" class="headerlink" title="/srv"></a><code>/srv</code></h6><p><code>/srv</code>目录被用来存放服务相关的数据，例如网站内容或FTP服务器数据。</p><h6 id="sys"><a href="#sys" class="headerlink" title="/sys"></a><code>/sys</code></h6><p><code>/sys</code>目录是一个新的文件系统，它为Linux内核提供了对硬件和内核服务的接口。这个目录包含大量的内核相关信息，例如系统、电源管理和进程信息等等。</p><h6 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a><code>/tmp</code></h6><p><code>/tmp</code>目录是一个被用来临时储存文件和数据的目录，该目录中的内容通常在系统重启后被清空。</p><h6 id="usr"><a href="#usr" class="headerlink" title="/usr"></a><code>/usr</code></h6><p><code>/usr</code>目录储存了系统程序和文件，这些文件通常可以安全地共享给其他程序，并且不应该在引导时需要被引用。该目录下包括了许多其他子目录，如<code>/usr/bin</code>、<code>/usr/lib</code>等等。</p><h6 id="var"><a href="#var" class="headerlink" title="/var"></a><code>/var</code></h6><p><code>/var</code>目录是可变文件的父目录，包括了许多运行时产生的数据，如日志文件、缓存、数据库文件等等。此外，它还包括了包含所有可写入的目录，例如<code>/var/tmp</code>和<code>/var/mail</code>等等。</p><p>以上是Linux常见目录及其说明，这些目录的组合形成了Linux操作系统中重要的文件系统层次结构（Filesystem Hierarchy）。通过理解每个目录及其作用，您可以更好地管理和维护Linux系统。</p><h4 id="Linux-用户权限"><a href="#Linux-用户权限" class="headerlink" title="Linux-用户权限"></a>Linux-用户权限</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202304151725746.png" alt="image-20230415172558696"></p><table><thead><tr><th>Commands</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>adduser</code></td><td>添加用户账户</td><td><code>adduser 用户名</code></td></tr><tr><td><code>deluser</code></td><td>删除用户账户</td><td><code>deluser 用户名</code></td></tr><tr><td><code>passwd</code></td><td>更改用户密码</td><td><code>passwd 用户名</code></td></tr><tr><td><code>usermod</code></td><td>更改用户账户信息</td><td><code>usermod --shell /bin/bash 用户名</code></td></tr><tr><td><code>userdel</code></td><td>删除用户账户</td><td><code>userdel 用户名</code></td></tr><tr><td><code>useradd</code></td><td>添加用户账户</td><td><code>useradd -m -s /bin/bash 用户名</code></td></tr><tr><td><code>chgrp</code></td><td>更改文件或目录所属用户组</td><td><code>chgrp 用户组 文件名</code></td></tr><tr><td><code>chown</code></td><td>更改文件或目录所有者</td><td><code>chown 用户名 文件名</code></td></tr><tr><td><code>chmod</code></td><td>更改文件或目录权限</td><td><code>chmod 权限 文件名</code></td></tr><tr><td><code>su</code></td><td>切换用户账户</td><td><code>su root</code></td></tr></tbody></table><p><strong>说明:</strong></p><ol><li><code>adduser</code>和<code>useradd</code>命令可以将新用户添加到系统中。如果您使用<code>adduser</code>命令，则指定的用户名将创建一个新的主目录和默认的组，而<code>useradd</code>则不会。</li><li><code>deluser</code>和<code>userdel</code>命令用于删除用户账户，这两个命令之间的主要区别是<code>deluser</code>会自动删除用户的主目录，而<code>userdel</code>则不会。</li><li><code>passwd</code>命令用于更改用户账户的密码。</li><li><code>usermod</code>命令用于更改用户账户信息，例如主目录路径、登录shell等。</li><li><code>chgrp</code>命令更改文件或目录所属的用户组，<code>chown</code>命令则更改文件或目录的所有者。</li><li><code>chmod</code>命令用于更改文件或目录的权限，例如添加/删除读、写和执行权限等。</li><li><code>su</code>命令可以让用户从一个账户切换到另一个账户，常见的用法是切换到root用户。</li></ol><p>以上是Linux基本管理用户权限的所有内容。理解这些命令及其功能，可以使您更好地管理和维护Linux系统，并确保系统安全和稳定。</p><h4 id="网络管理体系"><a href="#网络管理体系" class="headerlink" title="网络管理体系"></a>网络管理体系</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul><li>配置管理：用于实现网络设备的配置和管理，主要包括设备初始化，维护和关闭网络设备或子系统等操作</li><li>故障管理：为了尽快发现故障，找出故障原因，以便即使采取补救措施，计算机网络中的问题或故障进行定位的过程</li><li>性能管理：持续的测评网络运行中的主要性能指标，以检验网络服务是否达到预定水平，找出已经发送或潜在的网络瓶颈，报告网络性能的变化趋势，为网络管理决策提供依据</li><li>计费管理：根据网络管理部门指定的计费策略，按用户对网络资源的使用情况收取费用。目的是控制和监测网络操作的费用和代价</li><li>安全管理：保证网络资源不被非法使用，防止网络资源由于入侵者攻击而遭受到破坏。安全管理需要维护计算机和网络关于保密性，数据完整性，可用性3方面性能</li></ul><h5 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h5><table><thead><tr><th>网络管理体系</th><th>说明</th></tr></thead><tbody><tr><td>CMIP</td><td>全称是通信网络管理信息协议，是目前应用最广泛的网络管理协议之一，适合于大型分布式网络环境下进行网管操作。</td></tr><tr><td>SNMP</td><td>全称是简单网络管理协议，是一种网络管理协议，适合于小型网络环境下进行网管操作。</td></tr><tr><td>MIB</td><td>全称是管理信息库，是一种组织管理信息的方式，包含了网络上各种设备的管理信息。</td></tr><tr><td>RMON</td><td>全称是远程监视，是一种网络监视协议，可以对网络中的流量、速率、负载等指标进行实时监测。</td></tr><tr><td>Syslog</td><td>是一种系统日志规范，可以记录网络设备的操作日志，并提供告警功能。</td></tr><tr><td>NetFlow</td><td>是一种网络流量监控技术，可以对网络传输的数据流量进行实时监测和分析。</td></tr><tr><td>NAC</td><td>全称是网络准入控制，是一种访问控制技术，可以对网络用户的身份、设备和行为进行识别和控制。</td></tr><tr><td>VPN</td><td>全称是虚拟专用网络，是一种加密通道技术，可以在公共互联网上建立一条安全的私有通道。</td></tr></tbody></table><h4 id="网络管理协议-模型"><a href="#网络管理协议-模型" class="headerlink" title="网络管理协议-模型"></a>网络管理协议-模型</h4><p>更新中……….</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机硬件基础&quot;&gt;&lt;a href=&quot;#计算机硬件基础&quot; class=&quot;headerlink&quot; title=&quot;计算机硬件基础&quot;&gt;&lt;/a&gt;计算机硬件基础&lt;/h2&gt;&lt;h3 id=&quot;数据运算&quot;&gt;&lt;a href=&quot;#数据运算&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="网络管理" scheme="https://kalyan-zitiu.github.io/categories/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-04-02T14:00:00.000Z</published>
    <updated>2023-04-22T08:04:48.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dynamic programming，简称DP。通过把原问题分解为相对简单得子问题得方式求解复杂问题的方法。动态规划常常适用于有重叠子问题喝最优子结构性质的问题。一般这些子问题很相似，可以通过函数关系递推出来，然后动态规划致力于解决每一个子问题一次。减少重复计算，如斐波那契数列可以看做入门级的经典动态规划。主要大的基本思想就是一个记住过去，来就现在求值。</p><h2 id="动态规划的青蛙跳阶问题。"><a href="#动态规划的青蛙跳阶问题。" class="headerlink" title="动态规划的青蛙跳阶问题。"></a>动态规划的青蛙跳阶问题。</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。</p><p>具体思路就是，在跳上n格的时候，你必须柯一是跳上n-1格子的次数，然后再跳上n格。<br>所以说需要的是记住之前的所有值来计算最新的值。从而达到在计算第n个格时候，能够以较快的速度知道。跳到n个的次数。</p><p>那么就有了斐波那契数列的应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(10) = f(9) + f(8)</span><br><span class="line">f(9) = f(8) + f(7)</span><br><span class="line">f(8) = f(7) + f(6)</span><br><span class="line">f(7) = f(6) + f(5)</span><br><span class="line">f(6) = f(5) + f(4)</span><br><span class="line">···</span><br><span class="line">f(3) = f(2) + f(1)</span><br><span class="line"></span><br><span class="line">通用的公式为f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><p>然后就可以用递归来解决这个问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Solution&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numWays(n-<span class="number">1</span>) + numWays(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是用递归的方法，耗时就很大，但计算f(10)的时候，就需要先计算出子问题f(9)和f(8)然后计算f(9),又要先算出子问题f(8) 和 f(7),以此类推。一直到f(2)和f(1),递归树才结束。所以就有有了：</p><ul><li>递归复杂度 = 解决一个子问题时间* 子问题个数</li><li>一个人子问题时间 = f（n-1）+f（n-2），所以复杂度是O（1）；</li><li>问题个数 = 递归树节点的总数，递归树的总节点 = 2^n-1，所以复杂度是O（2 ^ n）</li></ul><p>因此青蛙跳阶的递归解法的时间复杂度 = O(1)*O(2 ^ n) = O(2 ^ n) ,然后你会发现回过头来，有大量的重复计算，比如f(8) 被计算了两次，f（7）被重复计算了3次…..所以这个递归算法低效就是这样的原因。</p><h3 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h3><p>既然发现了存在大量的重复计算，那么就有了一个思想，我们能把重复计算的值给记录下来，当到了可以使用的时候就可以把它重新取出来使用，这样就不用有重复的计算了。所以这里又引出了一个新的问题，用什么的数据类型或者数据结构去记录这个重复的值。</p><ul><li>一般都会想到使用一个数组或者一个哈希Map充当这个备忘录。</li></ul><p>子问题个数 = 树节点数=n，解决一个子问题还是O（1）,所以带备忘录的递归算法的时间复杂度是O（n）。接下来呢，就用备忘录的递归算法去些代码。来解决青蛙的超时问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="comment">//使用哈希map，充当备忘录的作用</span></span><br><span class="line">Map&lt;Integer,Integer&gt; tempMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numways</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">// n = 0 也算一种</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先判断有没有计算过，即看看备忘录有没有</span></span><br><span class="line"><span class="keyword">if</span>(tempMap.containsKey(n))&#123;</span><br><span class="line"><span class="comment">//备忘录有，计算过，直接返回</span></span><br><span class="line"><span class="keyword">return</span> tempMap.get(n);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//备忘录没有，即没有计算过，执行递归计算，并且把结果保存到备忘录map中，对100000007取余</span></span><br><span class="line">tempMap.put(n,(numWays(n-<span class="number">1</span>)+numWays(n-<span class="number">2</span>)) % <span class="number">1000000007</span>);</span><br><span class="line"><span class="keyword">return</span> tempMap.get(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>思路上基本和带着备忘录的递归解法是一致的，都是减少重复计算，时间复杂度也都是差不多，但是：</p><ul><li>备忘录的递归，是从f(10)往f(1)方向延伸求解的，所以称为<strong>自顶向下</strong>的解法。</li><li>动态规划从较小问题的解，有交叠性质，逐步决策出较大问题的解，它是从f(1)往f(10)方向往上推求解，所以称为<strong>自底向上</strong>的解法。</li><li>动态规划有几个典型得特征，最优子结构，状态转移方程，边界，重叠子问题。</li></ul><p>例如：</p><ul><li>f(n-1)和f(n-2) 称为 f(n) 的最优子结构</li><li>f(n)= f（n-1）+f（n-2）就称为状态转移方程</li><li>f(1) = 1, f(2) = 2 就是边界啦</li><li>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            temp = (a + b)% <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h2><ol><li><p>在问题中，可以把所有可能穷举出来，发现有重叠子问题得存在，就可以考虑动态规划。</p></li><li><p>一些求最值得场景，比如最长递增子序列，最小编辑距离，背包问题，凑零钱问题等，都是经典得动态规划的经典应用场景</p></li><li><p>核心就是拆分子问题，记住过往，减少重量计算，总结思路就是：</p><ul><li>穷举分析</li><li>确认边界</li><li>找出规律，确定最优子结构</li><li>写出状态转移方程</li></ul><ol><li><p>穷举分析</p></li><li><p>确定边界<br>通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n&gt;=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。</p></li><li><p>确定最优子结构<br>n&gt;=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：一道动态规划问题，其实就是递推问题。假设当前决策结果是f(n),则最优子结构就是要让f(n-k)最优，最优子结构性质就是能让转移到n的状态最优的，并且与后面的决策没有关系，即让后面的决策安心的使用前面的局部最优解的一种性质.</p></li><li><p>写出状态转移方程<br>通过前面3步，穷举分析，确定边界，最优子结构，得出状态转移方程：</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = 边界值</span><br><span class="line"><span class="keyword">for</span>(状态<span class="number">1</span> ：所有状态<span class="number">1</span>的值)&#123;</span><br><span class="line"> <span class="keyword">for</span>(状态<span class="number">2</span> ：所有状态<span class="number">2</span>的值)&#123;</span><br><span class="line">     <span class="keyword">for</span>(...)&#123;</span><br><span class="line">       <span class="comment">//状态转移方程</span></span><br><span class="line">       dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>给你一个整数数组nums，找到其中最长严格递增子序列的长度。<br>输入：nums=[10,9,2,5,3,7,101,18];<br>输出：4<br>解释：最长递增子序列是[2,3,7,101],因此长度为</p><h3 id="穷举分析"><a href="#穷举分析" class="headerlink" title="穷举分析"></a>穷举分析</h3><p>这里观察规律，显然是有关系的，我们还是遵循动态规划自底向上的原则，基于示例1的数据，从数组只有一个元素开始分析。</p><ul><li>当nums只有一个元素10时，最长递增子序列是[10],长度是1.</li><li>当nums需要加入一个元素9时，最长递增子序列是[10]或者[9],长度是1。</li><li>当nums再加入一个元素2时，最长递增子序列是[10]或者[9]或者[2],长度是1。</li><li>当nums再加入一个元素5时，最长递增子序列是[2,5],长度是2。</li><li>当nums再加入一个元素3时，最长递增子序列是[2,5]或者[2,3],长度是2。</li><li>当nums再加入一个元素7时，,最长递增子序列是[2,5,7]或者[2,3,7],长度是3。</li><li>当nums再加入一个元素101时，最长递增子序列是[2,5,7,101]或者[2,3,7,101],长度是4。</li><li>当nums再加入一个元素18时，最长递增子序列是[2,5,7,101]或者[2,3,7,101]或者[2,5,7,18]或者[2,3,7,18],长度是4。</li><li>当nums再加入一个元素7时,最长递增子序列是[2,5,7,101]或者[2,3,7,101]或者[2,5,7,18]或者[2,3,7,18],长度是4.</li></ul><h3 id="分析找规律，拆分子问题。"><a href="#分析找规律，拆分子问题。" class="headerlink" title="分析找规律，拆分子问题。"></a>分析找规律，拆分子问题。</h3><p>如果新加入一个元素nums[i], 最长递增子序列要么是以nums[i]结尾的递增子序列，要么就是nums[i-1]的最长递增子序列。nums[i]的最长递增子序列，不就是从以数组num[i]每个元素结尾的最长子序列集合，取元素最多（也就是长度最长）。可以用dp[i]表示以num[i]这个数结尾的最长递增子序列的长度</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230422155700534.png" alt="image-20230422155700534"></p><p>nums[i]结尾的自增子序列，只要找到比nums[i]小的子序列，加上nums[i] </p><h3 id="最简单边界情况"><a href="#最简单边界情况" class="headerlink" title="最简单边界情况"></a>最简单边界情况</h3><p>当nums数组只有一个元素时候，最长递增子序列的长度dp(1) = 1,当nums数组有两个元素时，dp(2) =2或者1， 因此边界就是dp(1)=1。</p><h3 id="确定最优子结构"><a href="#确定最优子结构" class="headerlink" title="确定最优子结构"></a>确定最优子结构</h3><p>max(dp(j)) 就是最优子结构。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp(i) =max(dp(j))+<span class="number">1</span>，存在j属于区间[<span class="number">0</span>，i-<span class="number">1</span>],并且num[i]&gt;num[j]。</span><br></pre></td></tr></table></figure><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>通过前面分析，我们就可以得出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">最长递增子序列 =max(dp[i])</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//初始化就是边界情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//自底向上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//从下标0到i遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">//找到前面比nums[i]小的数nums[j],即有dp[i]= dp[j]+1</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="comment">//因为会有多个小于nums[i]的数，也就是会存在多种组合了嘛，我们就取最大放到dp[i]</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求出dp[i]后，dp最大那个就是nums的最长递增子序列啦</span></span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h</summary>
      
    
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创新型模式</title>
    <link href="https://kalyan-zitiu.github.io/2023/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kalyan-zitiu.github.io/2023/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-21T14:00:00.000Z</published>
    <updated>2023-03-27T03:06:06.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-创新型模式"><a href="#设计模式-创新型模式" class="headerlink" title="设计模式-创新型模式"></a>设计模式-创新型模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>设计模式是软件开发中的一种通用解决方案，它们是经过实践证明的、被广泛接受的最佳实践。设计模式提供了一种可重用的设计思想，可以帮助开发人员解决常见的设计问题，提高代码质量和可维护性。</p><p>设计模式通常包含以下元素：</p><ol><li><p>模式名称：用于描述模式的名称。</p></li><li><p>问题描述：描述模式所解决的问题，包括场景和限制条件。</p></li><li><p>解决方案：描述模式的解决方案，包括结构、参与者、协作方式和责任。</p></li><li><p>优点和缺点：描述模式的优点和缺点，包括可维护性、可扩展性、可重用性等方面。</p></li><li><p>适用性：描述模式适用的场景和限制条件。</p></li><li><p>实现方式：描述模式的实现方式，包括代码示例和实现细节。</p></li></ol><h2 id="创新型模式"><a href="#创新型模式" class="headerlink" title="创新型模式"></a>创新型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）<br>现实生活中，工厂是负责生产产品的；</li><li>同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</li></ul><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。即使用者可直接消费产品而不需要知道其生产的细节。</li><li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li><li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</li></ul><h4 id="模式原理"><a href="#模式原理" class="headerlink" title="模式原理"></a>模式原理</h4><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>工厂</td><td>被外界调用</td><td>根据传入不同参数从而创建不同具体产品类的实例</td></tr></tbody></table><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261441166.png" alt="img"></p><h4 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductA</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductB</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductC</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">Manufacture</span><span class="params">(String ProductName)</span>&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。</span></span><br><span class="line">        <span class="keyword">switch</span> (ProductName)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductC</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">mFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例</span></span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;A&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;B&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品C</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;C&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品D</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.Manufacture(<span class="string">&quot;D&quot;</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这一类产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产出了产品A</span><br><span class="line">生产出了产品C</span><br><span class="line">生产出了产品C</span><br><span class="line">没有这一类产品</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li><li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li><li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul><li>工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</li><li>将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。</li></ul><h4 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点</li><li>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li><li>符合单一职责原则,每个具体工厂类只负责创建对应的产品</li><li>不使用静态工厂方法，可以形成基于继承的等级结构。简单工厂模式的工厂类使用静态工厂方法</li></ul><h4 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h4><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述具体产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>抽象工厂</td><td>具体工厂的父类</td><td>描述具体工厂的公共接口</td></tr><tr><td>具体工厂</td><td>抽象工厂的子类；被外界调用</td><td>描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td></tr></tbody></table><h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261447429.png" alt="image-20230326144728389"></p><h4 id="实例举例"><a href="#实例举例" class="headerlink" title="实例举例"></a>实例举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">Manufacture</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体产品A类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductA</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品B类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ProductB</span> <span class="keyword">extends</span>  <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂A类 - 生产A类产品</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">Manufacture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂B类 - 生产B类产品</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">Manufacture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">mFactoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        mFactoryA.Manufacture().Show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">mFactoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        mFactoryB.Manufacture().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产出了产品A</span><br><span class="line">生产出了产品C</span><br></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度</li><li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>当一个类不知道它所需要的对象的类时，在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li><li>当一个类希望通过其子类来指定创建对象时，在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><ul><li>抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</li><li>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类</li><li>允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。</li></ul><h4 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>降低耦合，抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；</li><li>更符合开-闭原则，新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可</li></ul><h4 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h4><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品族</td><td>抽象产品的父类</td><td>描述抽象产品的公共接口</td></tr><tr><td>抽象产品</td><td>具体产品的父类</td><td>描述具体产品的公共接口</td></tr><tr><td>具体产品</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>抽象工厂</td><td>具体工厂的父类</td><td>描述具体工厂的公共接口</td></tr><tr><td>具体工厂</td><td>抽象工厂的子类；被外界调用</td><td>描述具体工厂；实现工厂方法创建产品的实例</td></tr></tbody></table><h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261459666.png" alt="img"></p><h4 id="举例实例"><a href="#举例实例" class="headerlink" title="举例实例"></a>举例实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">ManufactureContainer</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">ManufactureMould</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProduct</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器产品抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContainerProduct</span> <span class="keyword">extends</span> <span class="title class_">AbstractProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模具产品抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MouldProduct</span> <span class="keyword">extends</span> <span class="title class_">AbstractProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器产品A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerProductA</span> <span class="keyword">extends</span> <span class="title class_">ContainerProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了容器产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器产品B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerProductB</span> <span class="keyword">extends</span> <span class="title class_">ContainerProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了容器产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模具产品A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouldProductA</span> <span class="keyword">extends</span> <span class="title class_">MouldProduct</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了模具产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模具产品B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouldProductB</span> <span class="keyword">extends</span> <span class="title class_">MouldProduct</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出了模具产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A厂 - 生产模具+容器产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ContainerProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureMould</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MouldProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B厂 - 生产模具+容器产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ContainerProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">ManufactureMould</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MouldProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">mFactoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">mFactoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        <span class="comment">//A厂当地客户需要容器产品A</span></span><br><span class="line">        mFactoryA.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//A厂当地客户需要模具产品A</span></span><br><span class="line">        mFactoryA.ManufactureMould().Show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B厂当地客户需要容器产品B</span></span><br><span class="line">        mFactoryB.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//B厂当地客户需要模具产品B</span></span><br><span class="line">        mFactoryB.ManufactureMould().Show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产出了容器产品A</span><br><span class="line">生产出了容器产品B</span><br><span class="line">生产出了模具产品A</span><br><span class="line">生产出了模具产品B</span><br></pre></td></tr></table></figure><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><ul><li>抽象工厂模式很难支持新种类产品的变化</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><ul><li>实现1个类只有1个实例化对象 &amp; 提供一个全局访问点</li><li>从上面可看出：工人类操作的明显不是同一个仓库实例，而全部工人希望操作的是同一个仓库实例，即只有1个实例</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>在Java中，我们通过使用对象（类实例化后）来操作这些类，类实例化是通过它的构造方法进行的，要是想实现一个类只有一个实例化对象。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261501938.png" alt="img"></p><h4 id="举例实现-1"><a href="#举例实现-1" class="headerlink" title="举例实现"></a>举例实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建私有变量 ourInstance（用以记录 Singleton 的唯一实例）</span></span><br><span class="line"><span class="comment">//2. 内部进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 把类的构造方法私有化，不让外部调用构造方法实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4. 定义公有方法提供该类的全局唯一访问点</span></span><br><span class="line"><span class="comment">//5. 外部通过调用getInstance()方法来返回唯一的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="情景代入"><a href="#情景代入" class="headerlink" title="情景代入"></a>情景代入</h4><p>背景：小成有一个塑料生产厂，但里面只有一个仓库。<br>目的：想用代码来实现仓库的管理<br>现有做法： 建立仓库类和工人类     其中，仓库类里的quantity=商品数量；工人类里有搬运方法MoveIn(int i)和MoveOut(int i)。</p><h5 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仓库类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreHouse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuantity</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQuantity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搬货工人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Carrier</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> StoreHouse mStoreHouse;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Carrier</span><span class="params">(StoreHouse storeHouse)</span>&#123;</span><br><span class="line">        mStoreHouse = storeHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货进仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveIn</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货出仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveOut</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工人搬运测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglePattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreHouse</span>();</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreHouse</span>();</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse1);</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;两个是不是同一个？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mStoreHouse1.equals(mStoreHouse2))&#123;<span class="comment">//这里用equals而不是用 == 符号，因为 == 符号只是比较两个对象的地址</span></span><br><span class="line">            System.out.println(<span class="string">&quot;是同一个&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是同一个&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搬运工搬完货物之后出来汇报仓库商品数量</span></span><br><span class="line">        Carrier1.MoveIn(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier1.mStoreHouse.getQuantity());</span><br><span class="line">        Carrier2.MoveOut(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier2.mStoreHouse.getQuantity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例实现"><a href="#单例实现" class="headerlink" title="单例实现"></a>单例实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scut.designmodel.SingletonPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例仓库类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreHouse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仓库商品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//自己在内部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StoreHouse</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreHouse</span>();;</span><br><span class="line">    <span class="comment">//让外部通过调用getInstance()方法来返回唯一的实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StoreHouse <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封闭构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StoreHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuantity</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQuantity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//搬货工人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Carrier</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> StoreHouse mStoreHouse;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Carrier</span><span class="params">(StoreHouse storeHouse)</span>&#123;</span><br><span class="line">        mStoreHouse = storeHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货进仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveIn</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搬货出仓库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MoveOut</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        mStoreHouse.setQuantity(mStoreHouse.getQuantity()-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工人搬运测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglePattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse1</span> <span class="operator">=</span> StoreHouse.getInstance();</span><br><span class="line">        <span class="type">StoreHouse</span> <span class="variable">mStoreHouse2</span> <span class="operator">=</span> StoreHouse.getInstance();</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse1);</span><br><span class="line">        <span class="type">Carrier</span> <span class="variable">Carrier2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Carrier</span>(mStoreHouse2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;两个是不是同一个？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mStoreHouse1.equals(mStoreHouse2))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是同一个&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是同一个&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搬运工搬完货物之后出来汇报仓库商品数量</span></span><br><span class="line">        Carrier1.MoveIn(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier1.mStoreHouse.getQuantity());</span><br><span class="line">        Carrier2.MoveOut(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库商品余量：&quot;</span>+Carrier2.mStoreHouse.getQuantity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多种单例模式实现方式"><a href="#多种单例模式实现方式" class="headerlink" title="多种单例模式实现方式"></a>多种单例模式实现方式</h4><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><ul><li>依赖JVM类加载机制，保证单例只会被创建一次，即线程安全</li><li>JVM在类的初始化阶段，会执行类的初始化</li><li>在执行类的初始化的时候，JVM会去获取一个锁，这个所可以同步多个线程对同一个类的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 加载该类时，单例就会自动被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">    <span class="comment">// 原因：禁止他人创建实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通过调用静态方法获得创建的单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5></li><li>根据枚举类型的下述特点，满足单例模式所需的创建单例，线程安全，实现简介的需求</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261509469.jpeg" alt="img"></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义1个枚举的元素，即为单例类的1个实例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏了1个空的、私有的 构造方法</span></span><br><span class="line">    <span class="comment">// private Singleton () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例的方式：</span></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br></pre></td></tr></table></figure><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><ul><li>单例创建时机可控，有需要的时候才手动创建单例</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 类加载时，先不自动创建单例</span></span><br><span class="line">   <span class="comment">//  即，将单例的引用先赋值为 Null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">    <span class="comment">// 原因：禁止他人创建实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 需要时才手动调用 newInstance（） 创建 单例   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">    <span class="keyword">if</span>( ourInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">        ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><ul><li>对于懒汉会存在线程不安全的时候，特别是在多线程时候会出现以下问题</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261512668.png" alt="img"></li></ul><h4 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h4><ul><li>使用同步锁synchronized，锁住创建单例的方法，防止多个线程同时调用，从而避免造成单例被多次创建</li><li>getInstance（）方法块只能运行在一个线程中</li><li>倘若此段代码已在一个线程中运行，则另外一个线程试图运行该块代码，则会被一直阻塞二一直等待。<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 类加载时，先不自动创建单例</span></span><br><span class="line">    <span class="comment">//  即，将单例的引用先赋值为 Null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数 设置为 私有权限</span></span><br><span class="line">    <span class="comment">// 原因：禁止他人创建实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3. 加入同步锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">        <span class="keyword">if</span> ( ourInstance == <span class="literal">null</span> )</span><br><span class="line">            ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="comment">// 该写法的作用与上述写法作用相同，只是写法有所区别</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 加入同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h4><ul><li>在同步锁的基础上，添加多一层if判断，若单例已经创建，则不需要执行加锁操作就可以获取实例，从而提高性能</li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 加入双重校验锁</span></span><br><span class="line">    <span class="comment">// 校验锁1：第1个if</span></span><br><span class="line">    <span class="keyword">if</span>( ourInstance == <span class="literal">null</span>)&#123;  <span class="comment">// ①</span></span><br><span class="line">     <span class="keyword">synchronized</span> (Singleton.class)&#123; <span class="comment">// ②</span></span><br><span class="line">      <span class="comment">// 校验锁2：第2个 if</span></span><br><span class="line">      <span class="keyword">if</span>( ourInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">          ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 校验锁1：第1个if</span></span><br><span class="line"><span class="comment">// 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作</span></span><br><span class="line"><span class="comment">// 即直接跳到执行 return ourInstance</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验锁2：第2个 if </span></span><br><span class="line"><span class="comment">// 作用：防止多次创建单例问题</span></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line">  <span class="comment">// 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance()</span></span><br><span class="line">  <span class="comment">// 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕</span></span><br><span class="line">  <span class="comment">// 3. 当线程A释放同步锁时，单例已创建，即instance已非空</span></span><br><span class="line">  <span class="comment">// 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例</span></span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul><li>更具静态内部类的特性，同步解决按需加载，线程安全的问题，同时实现简洁</li><li>在静态内部类中创建单例，在装载该内部类的时候才会去创建单例</li><li>线程安全：类是由JVM加载，而JVM只会加载一遍，保证只有一个单例</li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">       <span class="comment">// 在静态内部类里创建单例</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">Singleton</span> <span class="variable">ourInstance</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>()；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延迟加载、按需创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton2.ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用过程说明：</span></span><br><span class="line">      <span class="comment">// 1. 外部调用类的newInstance() </span></span><br><span class="line">      <span class="comment">// 2. 自动调用Singleton2.ourInstance</span></span><br><span class="line">       <span class="comment">// 2.1 此时单例类Singleton2得到初始化</span></span><br><span class="line">       <span class="comment">// 2.2 而该类在装载 &amp; 被初始化时，会初始化它的静态域，从而创建单例；</span></span><br><span class="line">       <span class="comment">// 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性</span></span><br><span class="line">      <span class="comment">// 3. 最终只创建1个单</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303261537777.png" alt="img"></p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li><li>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</li><li>建造者模式负责按照是顺序创建复杂对象（把内部的建造过程和细节隐藏藏匿起来）</li></ul><h4 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>方便用户创建复杂的对象</li><li>代码复用性以及封装性（将对象构建过程和细节进行封装以及复用）</li><li>方便解耦，方便控制对象的创建，方便于拓展。</li></ul><h4 id="UML类图-3"><a href="#UML类图-3" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303270853304.png" alt="img"></p><h4 id="模式讲解"><a href="#模式讲解" class="headerlink" title="模式讲解"></a>模式讲解</h4><ol><li>指挥者直接和客户进行需求沟通</li><li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求</li><li>将各个部件的建造请求委派到具体的建造者</li><li>各个具体建造者负责进行产品部件的构建</li><li>最终构建成具体产品。</li></ol><h4 id="情景代入-1"><a href="#情景代入-1" class="headerlink" title="情景代入"></a>情景代入</h4><ul><li>背景：小成希望去电脑城买一台组装的台式主机</li><li>过程：   </li></ul><ol><li>电脑城老板（Diretor）和小成（Client）进行需求沟通（买来打游戏？学习？看片？）</li><li>了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）</li><li>指挥装机人员（ConcreteBuilder）去构建组件；</li><li>将组件组装起来成小成需要的电脑（Product）；</li></ol><h5 id="举例实例-1"><a href="#举例实例-1" class="headerlink" title="举例实例"></a>举例实例</h5><ol><li>定义组装的过程：组装电脑的过程<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line"><span class="comment">//第一步：CPU</span></span><br><span class="line"><span class="comment">//声明为抽象方法，具体由子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildCPU</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//第二步：装主板</span></span><br><span class="line"><span class="comment">//声明为抽象方法，具体由子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildMainboard</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//第三步：装硬盘</span></span><br><span class="line"><span class="comment">//声明为抽象方法，具体由子类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">BuildHD</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//返回产品的方法：获得组装好的电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title function_">GetCompputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>电脑城老板委派任务给装机人员<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span>&#123;</span><br><span class="line"><span class="comment">//指挥装机人员组装的电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Construct</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">builder.BuildCPU();</span><br><span class="line">builder.BuildMainboard();</span><br><span class="line">builder.BuuildHD();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建具体的建造者：装机人员<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品实例</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装产品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildCPU</span><span class="params">()</span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;组装CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuilMainboard</span><span class="params">()</span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;组装主板&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildHD</span><span class="params">()</span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;组装硬盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回组装成功的电脑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">GetComputer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义具体产品类：电脑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="comment">//电脑组件的集合</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//用于将组件组装到电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Add</span><span class="params">(String part)</span>&#123;</span><br><span class="line">part.add (part);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;&lt;part.size();i++)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;组件&quot;</span>+part.get(i)+<span class="string">&quot;装好了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;电脑组装完成，请验收&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端调用-小成到电脑找了老板买电脑</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Builder</span> Pattern&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逛了很久终于发现一家合适的电脑店</span></span><br><span class="line"><span class="comment">//找到该店的老板和装机人员</span></span><br><span class="line">  <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line">  <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//沟通需求后，老板叫装机人员去装电脑</span></span><br><span class="line">director.Construct(builder);</span><br><span class="line"></span><br><span class="line"><span class="comment">//装完后，组装人员搬来组装好的电脑</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> builder.GetComputer();</span><br><span class="line"><span class="comment">//组装人员展示电脑给小成看</span></span><br><span class="line">computer.Show()；</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><ul><li>它允许通过复制现有的对象来创建新的对象，而不是通过创建新的实例并初始化它们来创建对象。这种模式通常用于创建具有相同属性的多个对象，以避免重复的初始化过程。在原型模式中，原型对象是创建新对象的模板，新对象是通过复制原型对象来创建的。原型模式的实现通常需要实现 Cloneable 接口或者使用序列化和反序列化来实现对象的复制。</li></ul><h4 id="UML类图-4"><a href="#UML类图-4" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303271043974.png" alt="image-20230327104312924"></p><h4 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>逃避构造函数的约束。</li></ul><h4 id="举例实例-2"><a href="#举例实例-2" class="headerlink" title="举例实例"></a>举例实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line">   <span class="keyword">protected</span> String type;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         clone = <span class="built_in">super</span>.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span>&#123;</span><br><span class="line">     type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">()</span>&#123;</span><br><span class="line">     type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">     type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeCache</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap </span><br><span class="line">      = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;String, Shape&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeId)</span> &#123;</span><br><span class="line">      <span class="type">Shape</span> <span class="variable">cachedShape</span> <span class="operator">=</span> shapeMap.get(shapeId);</span><br><span class="line">      <span class="keyword">return</span> (Shape) cachedShape.clone();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">   <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">   <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadCache</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      circle.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      shapeMap.put(circle.getId(),circle);</span><br><span class="line"> </span><br><span class="line">      <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">      square.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      shapeMap.put(square.getId(),square);</span><br><span class="line"> </span><br><span class="line">      <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      rectangle.setId(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ShapeCache.loadCache();</span><br><span class="line"> </span><br><span class="line">      <span class="type">Shape</span> <span class="variable">clonedShape</span> <span class="operator">=</span> (Shape) ShapeCache.getShape(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape.getType());        </span><br><span class="line"> </span><br><span class="line">      <span class="type">Shape</span> <span class="variable">clonedShape2</span> <span class="operator">=</span> (Shape) ShapeCache.getShape(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape2.getType());        </span><br><span class="line"> </span><br><span class="line">      <span class="type">Shape</span> <span class="variable">clonedShape3</span> <span class="operator">=</span> (Shape) ShapeCache.getShape(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape3.getType());        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><ul><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很男</li><li>必须实现Cloneable接口</li></ul><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul><li>资源优化</li><li>类初始化需要消化很多资源</li><li>一个对象多个修改者</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-创新型模式&quot;&gt;&lt;a href=&quot;#设计模式-创新型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-创新型模式&quot;&gt;&lt;/a&gt;设计模式-创新型模式&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Goal解析以及进阶练习</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/06/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A33/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/06/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A33/</id>
    <published>2023-01-06T07:00:04.000Z</published>
    <updated>2023-01-06T07:33:07.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="goal解析"><a href="#goal解析" class="headerlink" title="goal解析"></a>goal解析</h1><p>请你设计一个可以解释字符串 command 的 Goal 解析器 。</p><ul><li>command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。</li><li>Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</li><li>给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。</li></ul><h2 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h2><p>又是偷懒的一天，直接用库函数了</p><ol><li>需要注意的是下面的括号是要转义的，不然会识别成null。</li><li>此方法的时间复杂度会较大，个人猜测是函数内部的循环或条件语句分析相对O-题解比较复杂。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">interpret</span><span class="params">(String command)</span> &#123;</span><br><span class="line">    command = command.replace(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    command = command.replaceAll(<span class="string">&quot;\\(\\)&quot;</span>,<span class="string">&quot;o&quot;</span>);</span><br><span class="line">    command = command.replaceAll(<span class="string">&quot;\\(al\\)&quot;</span>,<span class="string">&quot;al&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li>本题只会出现”G”,”()”以及”(al)”所以不符合”（）”与”G”的条件一律可以按照”（al）”处理。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interpret</span><span class="params">(String command)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; command.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                res.append(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (command.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    res.append(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.append(<span class="string">&quot;al&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;goal解析&quot;&gt;&lt;a href=&quot;#goal解析&quot; class=&quot;headerlink&quot; title=&quot;goal解析&quot;&gt;&lt;/a&gt;goal解析&lt;/h1&gt;&lt;p&gt;请你设计一个可以解释字符串 command 的 Goal 解析器 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;comman</summary>
      
    
    
    
    <category term="leetccode" scheme="https://kalyan-zitiu.github.io/categories/leetccode/"/>
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TinyURL 的加密与解密</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/05/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A32/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/05/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A32/</id>
    <published>2023-01-05T09:40:04.000Z</published>
    <updated>2023-01-05T11:31:21.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TinyURL-的加密与解密"><a href="#TinyURL-的加密与解密" class="headerlink" title="TinyURL 的加密与解密"></a>TinyURL 的加密与解密</h1><ol><li>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a> 。请你设计一个类来加密与解密 TinyURL 。</li></ol><ul><li>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。<br>实现 Solution 类：</li><li>Solution() 初始化 TinyURL 系统对象。</li><li>String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。</li><li>String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。</li></ul><h2 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h2><p>其实我第一时间想到的就只有异或运算而已</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> syscode(longUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> syscode(shortUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">syscode</span><span class="params">(String index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">        <span class="type">char</span> mixcode[] = index.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mixcode.length;i++)&#123;</span><br><span class="line">            mixcode[i] = (<span class="type">char</span>)(mixcode[i]^key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(mixcode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h2><h3 id="来源leetcode"><a href="#来源leetcode" class="headerlink" title="(来源leetcode)"></a>(来源leetcode)</h3><h3 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h3><p>建立哈希表，用自增的id作为URL的键，每次接收一个URL都会使id递增，从而将键值对database进行存储，然后返回带有id的字符串作为shorURL。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; dataBase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        id++;</span><br><span class="line">        dataBase.put(id, longUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> shortUrl.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> Integer.parseInt(shortUrl.substring(p));</span><br><span class="line">        <span class="keyword">return</span> dataBase.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希生成"><a href="#哈希生成" class="headerlink" title="哈希生成"></a>哈希生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">K1</span> <span class="operator">=</span> <span class="number">1117</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">K2</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; dataBase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; urlToKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (urlToKey.containsKey(longUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + urlToKey.get(longUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; longUrl.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> longUrl.charAt(i);</span><br><span class="line">            key = (<span class="type">int</span>) ((key + (<span class="type">long</span>) c * base) % K2);</span><br><span class="line">            base = (base * K1) % K2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dataBase.containsKey(key)) &#123;</span><br><span class="line">            key = (key + <span class="number">1</span>) % K2;</span><br><span class="line">        &#125;</span><br><span class="line">        dataBase.put(key, longUrl);</span><br><span class="line">        urlToKey.put(longUrl, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> shortUrl.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> Integer.parseInt(shortUrl.substring(p));</span><br><span class="line">        <span class="keyword">return</span> dataBase.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TinyURL-的加密与解密&quot;&gt;&lt;a href=&quot;#TinyURL-的加密与解密&quot; class=&quot;headerlink&quot; title=&quot;TinyURL 的加密与解密&quot;&gt;&lt;/a&gt;TinyURL 的加密与解密&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;TinyURL 是一种 URL </summary>
      
    
    
    
    <category term="leetccode" scheme="https://kalyan-zitiu.github.io/categories/leetccode/"/>
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>根据给定数字划分数组</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/03/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/03/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3/</id>
    <published>2023-01-03T10:20:04.000Z</published>
    <updated>2023-01-05T09:35:45.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据给定数字划分数组"><a href="#根据给定数字划分数组" class="headerlink" title="根据给定数字划分数组"></a>根据给定数字划分数组</h2><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你将 nums 重新排列，使得以下条件均成立：</p><ul><li>所有小于 pivot 的元素都出现在所有大于 pivot 的元素 之前 。</li><li>所有等于 pivot 的元素都出现在小于和大于 pivot 的元素 中间 。</li><li>小于 pivot 的元素之间和大于 pivot 的元素之间的 相对顺序 不发生改变。<ul><li>更正式的，考虑每一对 pi，pj ，pi 是初始时位置 i 元素的新位置，pj 是初始时位置 j 元素的新位置。对于小于 pivot 的元素，如果 i &lt; j 且 nums[i] &lt; pivot 和 nums[j] &lt; pivot 都成立，那么 pi &lt; pj 也成立。类似的，对于大于 pivot 的元素，如果 i &lt; j 且 nums[i] &gt; pivot 和 nums[j] &gt; pivot 都成立，那么 pi &lt; pj 。</li></ul></li></ul><h3 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h3><p>总体来说时空都是比较占优的空间损耗也不大</p><ol><li>双指针left从0开始递增以及right从数组后置位开始递减，分别用作于比较大于pivot以及小于pivot的，优点在于能够按照原本的次序在新的数组里面安排位置。</li><li>其实等于pivot可以不做比较，可以在新数组的所有元素填满pivot值，然后通过与原数组比较前后开始占位变值。</li><li>其实这里的时间复杂度应该是O（N）的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span>length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> newNum[] = <span class="keyword">new</span> <span class="title class_">int</span> [length];</span><br><span class="line">    Arrays.fill(newNum,pivot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> min=<span class="number">0</span>,max=length-<span class="number">1</span>;left&lt;length&amp;&amp;right&gt;=<span class="number">0</span>;left++,right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;pivot)&#123;</span><br><span class="line">            newNum[min++]=nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]&gt;pivot)&#123;</span><br><span class="line">            newNum[max--]=nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h3><h4 id="简单的三次遍历"><a href="#简单的三次遍历" class="headerlink" title="简单的三次遍历"></a>简单的三次遍历</h4><p>时间较快，空间损耗相对大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] &lt; pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] == pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] &gt; pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="划分以及拼接"><a href="#划分以及拼接" class="headerlink" title="划分以及拼接"></a>划分以及拼接</h4><p>运行时间可以说是题解里最长的了，而且空间也不是最优秀的。可能是因为增强for循环的或者计算长度的原因，比上面多一次循环的方法时间还要久。</p><ol><li>三个数据类型为Integer的ArrayList对象，分别储存三个不同的情况的数值</li><li>计算所有List的长度，建立新的数组，增强循环来依次输入顺序数值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) </span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x: nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            a.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            b.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.size() + b.size() + c.size();</span><br><span class="line">    <span class="type">int</span> [] res = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : b)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : c)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;根据给定数字划分数组&quot;&gt;&lt;a href=&quot;#根据给定数字划分数组&quot; class=&quot;headerlink&quot; title=&quot;根据给定数字划分数组&quot;&gt;&lt;/a&gt;根据给定数字划分数组&lt;/h2&gt;&lt;p&gt;给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你</summary>
      
    
    
    
    <category term="leetccode" scheme="https://kalyan-zitiu.github.io/categories/leetccode/"/>
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>进程耗时计算</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/01/%E8%A1%8C%E7%A8%8B%E8%80%97%E6%97%B6%E8%AE%A1%E6%97%B6/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/01/%E8%A1%8C%E7%A8%8B%E8%80%97%E6%97%B6%E8%AE%A1%E6%97%B6/</id>
    <published>2023-01-01T08:45:04.000Z</published>
    <updated>2023-01-01T09:04:09.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程耗时计算"><a href="#进程耗时计算" class="headerlink" title="进程耗时计算"></a>进程耗时计算</h1><p>这是一个能够计算运行进程的包。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">fmt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String title,Task task)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (title==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        title = (title==<span class="literal">null</span>)?<span class="string">&quot;&quot;</span>:(<span class="string">&quot;【&quot;</span>+title+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">        System.out.println(title);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始:&quot;</span>+fmt.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        task.execute();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束:&quot;</span>+fmt.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">double</span> <span class="variable">delta</span> <span class="operator">=</span> (end - begin)/<span class="number">1000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时:&quot;</span>+delta+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>在自建的软件包内建立一个TimeTool文件。</li><li>同包导入<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 软件包名字.TimeTool.Task;</span><br></pre></td></tr></table></figure></li><li>调用方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeTool.check(<span class="string">&quot;此处填写此次进程测试的名字（随便起个名字，方便对比区分）&quot;</span>,<span class="keyword">new</span> <span class="title class_">Task</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//放入你需要测试的进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程耗时计算&quot;&gt;&lt;a href=&quot;#进程耗时计算&quot; class=&quot;headerlink&quot; title=&quot;进程耗时计算&quot;&gt;&lt;/a&gt;进程耗时计算&lt;/h1&gt;&lt;p&gt;这是一个能够计算运行进程的包。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;h</summary>
      
    
    
    
    <category term="工具" scheme="https://kalyan-zitiu.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://kalyan-zitiu.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>二叉树（持续更新中）</title>
    <link href="https://kalyan-zitiu.github.io/2022/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
    <id>https://kalyan-zitiu.github.io/2022/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0/</id>
    <published>2022-12-19T01:00:00.000Z</published>
    <updated>2022-12-19T01:02:27.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h3><p>1.把左右根交换即可</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212190900221.png" alt="image-20221219090003177"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出克隆二叉树中的相同节点"><a href="#找出克隆二叉树中的相同节点" class="headerlink" title="找出克隆二叉树中的相同节点"></a>找出克隆二叉树中的相同节点</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212051005239.png" alt="image-20221205100529196"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TreeNode <span class="title function_">getTargetCopy</span><span class="params">(<span class="keyword">final</span> TreeNode original, <span class="keyword">final</span> TreeNode cloned, <span class="keyword">final</span> TreeNode target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (original == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (original == target) <span class="keyword">return</span> cloned;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> getTargetCopy(original.left, cloned.left, target);</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> getTargetCopy(original.right, cloned.right, target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HomeWork"><a href="#HomeWork" class="headerlink" title="HomeWork"></a>HomeWork</h2><h3 id="自定义树结点"><a href="#自定义树结点" class="headerlink" title="自定义树结点"></a>自定义树结点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">char</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">char</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">char</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="1-先根序列构造二叉树：A-B-null-D-null-null-C-null-null"><a href="#1-先根序列构造二叉树：A-B-null-D-null-null-C-null-null" class="headerlink" title="1. 先根序列构造二叉树：A B null D null null C null null"></a>1. 先根序列构造二叉树：A B null D null null C null null</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个全局变量，其实缺点也会很多，对于后面的方法均需要一个计时器，还有一种就是放在方法内的局部变量，跟着方法递归增加</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//题目给的是字符串，可以用toCharArray()变换字符数组</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">CteateTree</span><span class="params">(<span class="type">char</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; arr.length) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">val</span> <span class="operator">=</span> arr[count++];</span><br><span class="line">        <span class="comment">//当val值不等于空，这里把^当成空，就把新的带有val的节点赋值给真正意义上的根节点，往后的都是左右子树</span></span><br><span class="line">        <span class="keyword">if</span> (val != <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            node.left = CteateTree(arr);</span><br><span class="line">            node.right = CteateTree(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这道题你也简单点理论上可以直接把^也带入结点,不做空值处理,起码在我这里是这样,上面的自定义树节点的基本存储数据类型是用了char.这样好像也可以节省后面遍历的空值处理问题</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对于1中生成的二叉树进行前序、中序、后序遍历。"><a href="#2-对于1中生成的二叉树进行前序、中序、后序遍历。" class="headerlink" title="2.对于1中生成的二叉树进行前序、中序、后序遍历。"></a>2.对于1中生成的二叉树进行前序、中序、后序遍历。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrderTravera(node.left);</span><br><span class="line">        preOrderTravera(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        inOrderTravera(node.left);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrderTravera(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        postOrderTravera(node.left);</span><br><span class="line">        postOrderTravera(node.right);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-计算1中生成的二叉树结点总数。"><a href="#3-计算1中生成的二叉树结点总数。" class="headerlink" title="3. 计算1中生成的二叉树结点总数。"></a>3. 计算1中生成的二叉树结点总数。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老样子,静态全局变量,你也可以局部变量,像下面一样,充当一个计数器的作用,只需要在实例方法中输入从0开始,效果是一样的,局部变量的好处就是当你使用完方法后会释放内存,也就是会比一直存在占用内存static全局变量更节省空间.</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//思路很简单,遇到非空值计数器就+1.考虑到前面提到的^直接带入结点,这里还可能要加上值不为^</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">TreeNodeNum</span><span class="params">(TreeNode node,<span class="comment">/*，int num */</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">        TreeNodeNum(node.left);</span><br><span class="line">        TreeNodeNum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算1中生成二叉树的高度"><a href="#4-计算1中生成二叉树的高度" class="headerlink" title="4. 计算1中生成二叉树的高度"></a>4. 计算1中生成二叉树的高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目的主要问题是怎么在众多的左右子树中找出最大的根深度也就是普遍说的树高</span></span><br><span class="line"><span class="comment">//思路:递归判断,当这个结点为空的时候,则返回0,每次的递归都需要一次深度比较,找出最大的深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNode</span> <span class="operator">=</span>maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> rightNode=maxDepth(root.right);</span><br><span class="line">        <span class="comment">//这里的+1是因为是根节点并没有参与计算,因此需要+上根结点</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftNode,rightNode)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。"><a href="#5-计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。" class="headerlink" title="5.计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。"></a>5.计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总的思路就是判断左右指针的三种情况即可1.均为空 2.左空右不空(左不空右空)3.均不为空</span></span><br><span class="line"><span class="comment">//叶子结点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LeafNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+LeafNodeCount(root.left)+LeafNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LeafNodeCount(root.left) + LeafNodeCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">OneNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span> || root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+OneNodeCount(root.left)+OneNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OneNodeCount(root.left) + OneNodeCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">DoubleNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+DoubleNodeCount(root.left) + DoubleNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DoubleNodeCount(root.left) + DoubleNodeCount(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-按照下面两个序列生成二叉树：先序：ABHFDECKG-；中序：HBDFAEKCG"><a href="#6-按照下面两个序列生成二叉树：先序：ABHFDECKG-；中序：HBDFAEKCG" class="headerlink" title="6.按照下面两个序列生成二叉树：先序：ABHFDECKG ；中序：HBDFAEKCG"></a>6.按照下面两个序列生成二叉树：先序：ABHFDECKG ；中序：HBDFAEKCG</h3><p>前序+中序构造二叉树<br>先序:根 [左子树]  [右子树]<br>中序:[左子树] 根 [右子树]</p><p>思路:只要遍历中序找到根节点,利用双指针确认左右子树遍历结果的长度,再利用先序方式构造即可</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211221135621.png" alt="image-20221122113530560"></p><p>循环寻界+递归构造树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTrees</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">char</span> [] in)</span> &#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    TreeNode root=buildTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主体</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">int</span> PreLeft,<span class="type">int</span> PreRight,<span class="type">char</span> [] in,<span class="type">int</span> inLeft,<span class="type">int</span> inRight)</span> &#123;</span><br><span class="line"><span class="comment">//如果越界则表示结点为空</span></span><br><span class="line">      <span class="keyword">if</span>(PreLeft&gt;PreRight||inLeft&gt;inRight)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//开始构造,声明新结点</span></span><br><span class="line">   TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[PreLeft]);</span><br><span class="line"><span class="comment">//循环寻找中序的根节点,还能够确认左右子树边界</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=inLeft;i&lt;=inRight;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[PreLeft])&#123;</span><br><span class="line"><span class="comment">//先序构造树,指针就定义为左右子树的区间,构造左子树             </span></span><br><span class="line">    root.left=buildTree(pre,PreLeft+<span class="number">1</span>,PreLeft+i-inLeft,in,inLeft,i-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//变化右子树边界,构造右子树</span></span><br><span class="line">     root.right=buildTree(pre,i-inLeft+PreLeft+<span class="number">1</span>,PreRight,in,i+<span class="number">1</span>,inRight);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表优化循环子过程"><a href="#哈希表优化循环子过程" class="headerlink" title="哈希表优化循环子过程"></a>哈希表优化循环子过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过程几乎与上面的方法一样，只不过不需要每次递归后又进行循环来找到边界。</span></span><br><span class="line"><span class="comment">//提前把中序的所有遍历用哈希表储存起来即可。后面的取根直接依靠对应值来寻找序号，用来定界</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTreeTwo</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">char</span> [] in)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">PreLen</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">InLen</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(PreLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;InLen;i++)&#123;</span><br><span class="line">            map.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeTwo(pre,<span class="number">0</span>,PreLen-<span class="number">1</span>,map,<span class="number">0</span>,InLen-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTreeTwo</span><span class="params">(<span class="type">char</span>[]pre,<span class="type">int</span> PreLeft,<span class="type">int</span> PreRight,Map&lt;Character,Integer&gt; map,<span class="type">int</span> InLeft,<span class="type">int</span> InRight)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(PreLeft&gt;PreRight||InLeft&gt;InRight)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">val</span> <span class="operator">=</span> pre[PreLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);</span><br><span class="line">        root.left=buildTreeTwo(pre,PreLeft+<span class="number">1</span>,index-InLeft+PreLeft,map,InLeft,index-<span class="number">1</span>);</span><br><span class="line">        root.right=buildTreeTwo(pre,index-InLeft+PreLeft+<span class="number">1</span>,PreRight,map,index+<span class="number">1</span>,InRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="栈方法迭代"><a href="#栈方法迭代" class="headerlink" title="栈方法迭代"></a>栈方法迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] preorder, <span class="type">char</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preorderVal</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                inorderIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="建立树节点"><a href="#建立树节点" class="headerlink" title="建立树节点"></a>建立树节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">TreeNode()&#123;&#125;</span><br><span class="line">TreeNOde(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="type">this</span> <span class="variable">val</span> <span class="operator">=</span> val;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode(<span class="type">int</span> val,TreeNode left,TreeNode right)&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.left=left;</span><br><span class="line"><span class="built_in">this</span>.right=right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">preOrderTraveral(node.left);</span><br><span class="line">preOrderTraveral(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">inOrderTraveral(node.left);</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">inOrderTraveral(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">postTraveral(node.left);</span><br><span class="line">postTraveral(node.right);</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leverOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//声明一个队列对象</span></span><br><span class="line">        Queue&lt;TreeNode&gt; storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 根节点为空，返回空值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把结点拉入队列</span></span><br><span class="line">        storage.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!storage.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//把队列首部拉出输出值并且访问左右子树结点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> storage.poll();</span><br><span class="line">            System.out.print(cur.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//若左指针不为空，就把左子树拉入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                storage.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若右指针不为空，就把右子树拉入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">                storage.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p><a href="https://zitiu.top/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/">https://zitiu.top/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/</a></p><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><h3 id="总思路"><a href="#总思路" class="headerlink" title="总思路"></a>总思路</h3><ol><li><p>只要提到树的话就几乎都会涉及到递归和回溯.</p></li><li><p>比较常用的算法思想就是深度和广度优先搜索</p><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3></li><li><p> 这道题我的思路很简单,就是递归遍历,进行创新节点的操作</p></li><li><p>可以分三种情况</p><ul><li>两个节点均为null值</li><li>一个节点为null,一个不为null值</li><li>两个节点都不是null值</li></ul></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121621158.png" alt="image-20221112162114118"></p><p>实现1:深度优先搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">merageTrees</span><span class="params">(TreeNode r1,TreeNode r2)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(r1==<span class="literal">null</span>) <span class="keyword">return</span> r2;</span><br><span class="line">   <span class="keyword">if</span>(r2==<span class="literal">null</span>) <span class="keyword">return</span> r1;</span><br><span class="line">   <span class="type">TreeNode</span> <span class="variable">metaTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(r1.val+r2.val);</span><br><span class="line">   metaTree.left = merageTrees(r1.left,r2.left);</span><br><span class="line">   metaTree.right= merageTrees(r1.right,r2.right);</span><br><span class="line">   <span class="keyword">return</span> metaTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现2:广度优先搜索</p><ol><li>主要实现:构建三个队列分别储存3颗树的每个节点</li></ol><ul><li>每次从队列种取出一个节点,判断两个原始树的结点是否为空<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t1 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> t2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> t1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      queue.offer(merged);</span><br><span class="line">      queue1.offer(t1);</span><br><span class="line">      queue2.offer(t2);</span><br><span class="line">      <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;</span><br><span class="line">          <span class="keyword">if</span> (left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                  node.left = left;</span><br><span class="line">                  queue.offer(left);</span><br><span class="line">                  queue1.offer(left1);</span><br><span class="line">                  queue2.offer(left2);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.left = left1;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.left = left2;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                  node.right = right;</span><br><span class="line">                  queue.offer(right);</span><br><span class="line">                  queue1.offer(right1);</span><br><span class="line">                  queue2.offer(right2);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.right = right1;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  node.right = right2;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121840333.png" alt="image-20221112184055309"></p><ol><li>树的递归判断</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp;q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">null</span>||q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(p.val!=q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> isSameTree(p,left,q.left)&amp;&amp;isSameTree(p.right,q.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121844717.png" alt="image-20221112184440687"></p><ol><li>基本和相同树的判断思想是一样的，只要把左右两个孩子分别当作新的结点进行比较</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span>  isSameTree(root,root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode leftnode,TreeNode rightnode)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(leftnode==<span class="literal">null</span>&amp;&amp;rightnode==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftnode==<span class="literal">null</span>||rightnode==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> leftnode.val==rightnode.val&amp;&amp;isSameTree(leftnode.left,rightnode.right)&amp;&amp;isSameTree(leftnode.right,rightnode.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121849830.png" alt="image-20221112184924806"> </p><ol><li>思路也是十分的简单，像数组的位置变换一样，定义一个辅助变量，而这边定义一个新的树对象来储存。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思想十分像数组的辅助变量位置变换的方法</span></span><br><span class="line">       <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 声明一个新的对象，先是储存右孩子的数据</span></span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> root.right;</span><br><span class="line">           root.right = invertTree(root.left);</span><br><span class="line">           root.left = invertTree(rightTree);</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><ol><li>做法几乎于最大深度差不多，只是把max改成min罢了</li><li>但是要注意的是空节点是不需要比较的。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211131358958.png" alt="image-20221113135809932"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubilc <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+minDepth(root.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+minDepth(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><ol><li>我第一反应是一定要用到层次遍历，那么每层的结点个数我是应该怎么确定呢？</li><li> 然而实际上确实需要用到层次遍历的思想，而且还需要一个计数器</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211231913942.png" alt="image-20221123191353894"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Double&gt; storage = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">       Queue&lt;TreeNode&gt; stoge = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">       stoge.offer(root);</span><br><span class="line">       <span class="keyword">while</span>(!stoge.isEmpty())&#123;</span><br><span class="line">           <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stoge.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">               root = stoge.poll();</span><br><span class="line">               sum += root.val;</span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stoge.offer(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stoge.offer(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       storage.add(sum/size);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> storage;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>步骤解析<ol><li>在while之前把根结点代入队列。</li><li>开始while循环，重置sum值，目的是为了把每层的的结点总值区分开添入List中</li><li>获取队列的长度，队列的长度在这里其实就是这层结点的总数</li><li>比如代入root后，然后元素出队，因为此时的队列中只有root一个元素，所以出队root后，队列为空，停止循环，然后计算sum值，sum值得计算是用for循环本层得结点数得次数后得到得，然后把sum/size添加入List中</li><li>判断，那么两个if语句为了让下一个左右结点得入队，空则不入，不空则入。</li></ol></li></ol><h3 id="404-左子叶之和"><a href="#404-左子叶之和" class="headerlink" title="404.左子叶之和"></a>404.左子叶之和</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211251049323.png" alt="image-20221125104925282"></p><ol><li>首先需要的是找到叶子节点，如果是就回溯到上一个结点输出左子叶，如果不是的话就往下递归。<ol><li>递归<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root.left!=<span class="literal">null</span>&amp;&amp;root.left.right==<span class="literal">null</span>&amp;&amp;root.left.left==<span class="literal">null</span>)&#123;</span><br><span class="line">           sum += root.left.val;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right)+sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>队列（广度优先搜索）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    storage.offer(root);</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!storage.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> storage.poll();</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left.right==<span class="literal">null</span>&amp;&amp;node.left.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                sum+=node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                storage.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(node.right.left==<span class="literal">null</span>&amp;&amp;node.right.right==<span class="literal">null</span>))&#123;</span><br><span class="line">                storage.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h3 id=&quot;镜像二叉树&quot;&gt;&lt;a href=&quot;#镜像二叉树&quot; class=&quot;headerlink&quot; title=&quot;镜像二叉树&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="持续更新中" scheme="https://kalyan-zitiu.github.io/categories/%E7%BB%83%E4%B9%A0/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-传输层</title>
    <link href="https://kalyan-zitiu.github.io/2022/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2022-12-05T14:00:00.000Z</published>
    <updated>2023-03-27T03:28:51.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>UDP是无连接的，减少开销和发送数据之前的时延</li><li>UDP使用最大努力交付，即不保证可靠交付</li><li>面向报文，适合一次性传输少量的数据的网络应用</li><li>没有拥塞控制，适合多实时应用</li><li>首部开销晓，8B，Tcp208<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211151804590.png" alt="image-20221115180421539"></li></ol><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><ol><li>UDP长度是指UDP用户数据报的整个长度</li><li>UDP检验和是用来检测整个UDP数据报是否有错，错就丢弃</li><li>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161119442.png" alt="image-20221116111919394"></li></ol><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><ol><li>伪首部只有在计算机检验和时才出现，不向下传送也不向上递交。</li><li>17：封装UDP报文的IP数据报首部协议字段17。</li><li>UDP长度：UDP首部8B+数据部分长度（不包括伪首部）。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161132390.png" alt="image-20221116113239359"><br>在发送端上会存在：</li><li>填上伪首部</li><li>全0填充检验和字段</li><li>全0填充数据部分（UDP数据报要看称许多4B的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入检验和字段</li><li>去掉伪首部，发送<br>在接收端上会存在：</li><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告</li></ol><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ol><li>TCP是面向连接的传输层协议。</li><li>TCP只能有两个端点，每一条TCP连接只能是点对点的（因此没办法运用多播和广播的通讯方式）</li><li>TCP提供可靠交付的服务，无差错，不丢失，不重复，按序到达</li><li>提供全双工通讯（有发送缓存和接收缓存 ）</li><li>TCP面向字节流：TCP把应用程序交下来的数据看成一连串无结构的字节流</li></ol><h3 id="报文段的首部格式"><a href="#报文段的首部格式" class="headerlink" title="报文段的首部格式"></a>报文段的首部格式</h3><ol><li>序号：在一个TCP连接中传送的字节流中的每一个字节都在按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号</li><li>确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1位置的所有数据都已正确收到。</li><li>数据偏移：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即一个数组是4B。</li><li>6个控制位<ul><li>紧急位URG：URG=1时，标明此报文段中有紧急数据，是最高优先级的数据，应该尽快传送，不用在缓存中排队，配合紧急指针字段使用（发送方）。</li><li>确认位ACK：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li>推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位RST：RST=1时，标明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li>同步位SYN：SYN=1时，表明是一个连接请求/连接接受报文。</li><li>终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul></li><li>窗口：发送本报文段的一方接受窗口，即现在允许对方发送的数据量</li><li>检验和：检验首部+数据，检验时加上12B的伪首部，第四个字段为6.</li><li>紧急指针：URF=1时才有意义，指出本报文段中紧急数据的字节数</li><li>选项：最大报文段长度MSS，窗口扩大，时间戳，选择确认</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161310156.png" alt="image-20221116131046116"></p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><ol><li>TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器</li><li>假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用一下步骤与服务器中的TCP建立一条TCP连接<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211171124294.png" alt="image-20221117112431243"><ol><li>客户端发送连接请求报文段，无应用层数据SYN=1，seq=x（随机）</li><li>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。SYN=1，ACK=1，seq=y（随机），ack=x+1</li><li>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据SYN=0，ACK=1，seq=x+1,ack=y+1。</li></ol></li></ol><h3 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h3><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者会发送TCP SYN，SYN就是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，而那个TCP连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><p>1.参与一条TCP连接的两个进程中的任何一个都能终止连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。</p><ol><li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接FIN=1，seq=u</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了–半关闭状态ACK=1，seq=v,ack=u+1。</li><li>服务端发完数据，就发送连接释放报文段，主动关闭TCP连接。FIN=1，ACK=1，seq=w,ack=u+1</li><li>客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。ACK=1，seq=u+1，ack=w+1</li></ol><h3 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h3><ol><li>保证接受方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。也就是说明了数据帧在传输过程中既不能丢失，也不能受影响。<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4></li></ol><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><ol><li><p>一个字节占用一个序号</p></li><li><p>序号字段指的是一个报文段第一个字节的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211202009218.png" alt="image-20221120200930161"></p><h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4></li><li><p>发送方会保存一个TCP缓存报文段</p></li><li><p>接收方会在收到报文段后会发送确认报文段，当然接收方也可发送数据与确认报文段发去给发送方</p></li><li><p>若报文段在传输过程中丢失了，TCP会使用累计确认的方法，接收方会返回一个丢失报文段后的第一个字节的确认号报文段</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211202017088.png" alt="image-20221120201732026"></p><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><ol><li><p>超时重传，若在规定时间内发送方没有接收到接收方的确认数据报，就会进行重传。</p></li><li><p>TCP动态改变重传的规定时间RTTs（加权平均往返时间）</p></li><li><p>冗余ACK（冗余确认）每当期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。例子：发送方已发送1，2，3，4，5报文段</p></li></ol><ul><li>接收方收到1，返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到3，仍然返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到4，仍返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到5，仍返回给1的确认（确认号为2的第一个字节）<br>如果发送方收到了3个对于报文段1的冗余ACK就会认为报文段丢失，重传2号报文段，快速重传。</li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><ol><li>利用滑动窗口机制实现流量控制</li><li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212052140044.png" alt="image-20221205214003915"></li><li>TCP会为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就会启动持续计时器</li><li>若持续计时器设置的时间到期，就会发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值</li><li>若窗口仍然是0，那么发送方会重新设置持续计时器</li></ol><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>问题：当资源需求的总和大于可用资源的总和就会出现拥塞的条件，那么会有许多资源同时呈现供应不足就会导致网络性能变坏然后网络的吞吐量将会随输入负荷增大而下降</p><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>传输轮次：发送了一批报文段并收到了他们的确认的时间，也可以指的是往返的时延RTT</p><ol><li><p>探测网络拥塞程度后，提升拥塞窗口的数量</p></li><li><p>ssthresh的初始值指的是慢开始的值（不会再以指数增长的形式增长），会以加法的形式来增加，这就叫拥塞避免</p></li><li><p>当遇到网络拥塞的时候，就会执行断崖式减少，拥塞窗口会跌到cwnd=1，重新开始增加</p></li><li><p>在这过程中，可能会重新更新ssthresh，当遇到网络控制的时候，会把发送拥塞的cwnd值马上除以2生成新的ssthresh值，那么下一轮次的慢开始会从新的ssthresh开始。</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303271128126.png" alt="image-20221205221100217"></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>1.快重传就是等于冗余ack的算法是一致的，当某个报文段的确认帧并没有被发送方收到时候，后面发送的报文段返回的始终是还未收到的确认报文，当积累到三次的时候就会重传。<br>2.快恢复是和上面的ssthresh值是有关联的，当发送网络拥塞的时候，cwnd并不会直接降落到1，而是会降落到ssthresh值上直接进行慢开始。这样能够减少cwnd的变化幅度从而优化了速度。但是ssthresh值还是需要根据发送网络拥塞的cwnd来决定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h1&gt;&lt;h2 id=&quot;UDP协议&quot;&gt;&lt;a href=&quot;#UDP协议&quot; class=&quot;headerlink&quot; title=&quot;UDP协议&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/15/Http/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/15/Http/</id>
    <published>2022-11-15T11:30:04.000Z</published>
    <updated>2023-01-03T11:48:23.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>超文本传输协议(Hyper Text Transfer Protocol，Http)是一个简单的请求-响应协议，它通常运行在TCP之上，它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求何响应消息的头以ASCII形式给出；而消息内容则具有了MIME格式。所有的WWW文件都必须遵守这个标准</li><li>Http是一个基于TCP/IP通信协议来传递数据的（HTML文件，信息，结果等）</li></ul><h2 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h2><ul><li>Http是从万维网服务器传输超文本到本地浏览器的传送协议</li><li>Https是一种通过计算机网络进行的安全通信的传输协议</li><li>端口不一样Http的URL是默认使用端口80，而Https的是默认使用端口443<h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3></li><li>Https是通过Http进行通信，利用SSL/TLS来加密数据包，Https开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私和完整性<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4></li><li>1.TCP三次同步握手</li><li>2、客户端验证服务器数字证书</li><li>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>4、SSL 安全加密隧道协商完成</li><li>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210221158748.jpeg" alt="img"></p><h5 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h5><ul><li><p>SYN</p><ul><li>指的是<strong>同步序列编号</strong>，是T<strong>CP/IP</strong>建立连接时使用的握手信号。在客户端与服务器之间建立正常的<strong>TCP网络</strong>连接时，客户机首先发出一个<strong>SYN</strong>消息，服务器使用<strong>SYN+ACK</strong>应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起<strong>可靠的TCP连接</strong>，<strong>数据</strong>才可以在客户机和服务器之间传递。</li></ul></li><li><p>MIME</p><ul><li>多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该<strong>扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</strong>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</li></ul></li><li><p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号）客户端进入<strong>SYN_SEND</strong></p></li><li><p>第二次握手，服务器接收客户端syn包并且确认，同时向客户端发送一个SYN包，即SYN+ACK包，此时服务器处于<strong>SYN_RECV状态</strong></p></li><li><p>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入了<strong>ESTABLISHED状态</strong></p><h3 id="Http的工作原理"><a href="#Http的工作原理" class="headerlink" title="Http的工作原理"></a>Http的工作原理</h3></li><li><p>HTTP协议工作与客户端-服务端架构上</p></li><li><p>浏览器作为客户端通过URL向服务端发送所有请求</p></li><li><p>Web的服务端有Apache服务器，IIS服务器</p></li><li><p>需要注意的是</p><ul><li>HTTP是无连接，无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，断开连接以达到节省传输时间</li><li>它是一个媒体独立的，意味着，客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的MiME-type内容类型</li><li>它是无状态的：指的是对于事务的处理它是没有记忆能力的，这就说明如果后续需要处理前面的信息的话，必须得重新传输，导致每次连接的数据量增大。 </li></ul></li></ul><h3 id="Https-1"><a href="#Https-1" class="headerlink" title="Https"></a>Https</h3><ul><li>能够在不安全的网络上创建一个安全通道，并且可以使用适当的加密包和服务器证书验证且可被信任</li><li>当以下情况达成时可被信任</li><li>浏览器正确的实现了HTTPS且操作系统中安装了正确且受信任的证书颁发机构；</li><li>次协议的加密层也就是SSL./TLS能够有效的提供认证和高强度的加密</li></ul><h2 id="Http的消息结构"><a href="#Http的消息结构" class="headerlink" title="Http的消息结构"></a>Http的消息结构</h2><ul><li><p>客户端一般发送一个HTTP请求到服务器的请求消息包括以下格式：请求行，请求头部，空行和请求数据四个部分组成。</p><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210221316880.png" alt="image-20221022131636849"></li></ul></li><li><p>服务器响应也是四个部分组成，分别是：状态行，消息报头，空行和响应正文</p></li></ul><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><table><thead><tr><th>number</th><th>method</th><th>descrition</th></tr></thead><tbody><tr><td>1.</td><td>GET</td><td>请求指定的页面信息，返回实体主体</td></tr><tr><td>2.</td><td>HEAD</td><td>返回的响应中没有具体内容，用于获取报头</td></tr><tr><td>3.</td><td>POST</td><td>向指定的资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能导致新的资源的建立和/或已有的资源的修改</td></tr><tr><td>4.</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档内容</td></tr><tr><td>5.</td><td>DELETE</td><td>请求服务器伤处指定画面</td></tr><tr><td>6.</td><td>CONNECT</td><td>预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>7.</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>8.</td><td>PATCH</td><td>对PUT方法的补充，用来对已知资源进行局部更新</td></tr><tr><td>9.</td><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr></tbody></table><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><table><thead><tr><th>状态码</th><th>英文对应名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Http&quot;&gt;&lt;a href=&quot;#Http&quot; class=&quot;headerlink&quot; title=&quot;Http&quot;&gt;&lt;/a&gt;Http&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="协议" scheme="https://kalyan-zitiu.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>图存结构</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/15/%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/15/%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</id>
    <published>2022-11-15T11:00:23.000Z</published>
    <updated>2022-11-21T06:59:06.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）"><a href="#基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）" class="headerlink" title="基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）"></a>基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）</h2><h3 id="什么是图存储结构"><a href="#什么是图存储结构" class="headerlink" title="什么是图存储结构"></a>什么是图存储结构</h3><ul><li>根据有向和无向线来连接每个顶点间的关系<ul><li>有向图：如果元素之间存在单向的联系，那么这样的图结构称为有向图.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210270950517.png" alt="image-20221027095058466"></li><li>无向图：各个元素之间的联系都是双向的，这样的图存结构称为无向图。<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210270952151.png" alt="image-20221027095201129"></li></ul></li></ul><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>1.弧头和弧尾</p><ul><li>有向图中，无箭头的一端的顶点通常被称为“初始点”或“弧尾”，箭头的一段被称为“终端点”或“弧头”。</li></ul><p>2.入度和出度</p><ul><li>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。</li></ul><p>3.(V1,V2)和&lt;V1,V2&gt;的区别</p><ul><li><strong>无向图中描述两顶点V1和V2之间的关系可以用(V1,V2)来表示；有向图中描述从V1到V2的“单向”关系可以用&lt;V1,V2&gt;来表示</strong></li><li>由于图存储结构中顶点之间的关系是可以用线来表示的，因此(V1,V2)还可以用来表示无向图中连接V1和V2的线，又称为边;同样&lt;V1,V2&gt;也可用来表示有向图中从V1到V2带方向的线，又称为弧。</li></ul><p>4.集合VR</p><ul><li>图中习惯用VR表示图中所有顶点之间的关系的集合，例如，上图无向图的集合VR={(V1,V2),(V1,V4),(V1,V3),(V3,V4)}。有向图的集合 VR={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。</li></ul><p>5.路径和回路</p><ul><li>无论是无向图还是有向图，从一个顶点到另一个顶点途径的所有顶点组成的序列（包括起点和终点），称为一条路径。若路径中的<strong>某个顶点能够最后回到自己身上</strong>，那么这个路径称为<strong>环</strong>或者<strong>回路</strong></li></ul><p>6.权和网</p><ul><li>在一些图中，可能为每条边赋值一个实数表示一定的含义，这种与边（或弧）相互匹配的实数被称为“权”，而带权的图通常称为网。例如，图4就是一个网结构:<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271035591.png" alt="image-20221027103555566"></li></ul><p>7.子图</p><ul><li>指的是由图中一部分顶点和边构成的图称为原图的子图</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h4><ul><li>每个顶点都有与除开自身外的其他顶点有直接关系</li><li>若有n个顶点的完全图，则图中边的数量为n(n-1)/2;而对于具有n个顶点的有向完全图，图中的弧的数量为n(n-1)。<h4 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h4></li><li><strong>如果图中从一个顶点到达另外一个顶点，至少有一条路径，那么这两个顶点是连通着的。</strong>例如图中，虽然V1和V3没有直接关联，但从V1到V3存在两条路径，分别是V1-V2-V3和V1-V4-V3，因此称V1和V2之间是连通的<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271101163.png" alt="image-20221027110110138"><br>上面用的是无向图的例子，其实有向图也是基本差不多的啦，自己揣摩哦！！！！<h5 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h5></li><li>在有向图中两个顶点彼此都有至少有一条通路，那么这有向图为强连通图。</li><li>除此之外，若有向图不是强连通图，但其中包含的是最大连通子图具有强连通的性质，则称该子图为强连通分量<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271112764.png" alt="image-20221027111223735"></li></ul><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><ul><li>其实对连通图的遍历的过程中就已经是生成树的过程了<br>1.如图：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271122665.png" alt="image-20221027112213637"><br>2.需要注意的是连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。<br>3.连通图中的生成树必须满足以下 2 个条件：<ul><li>包含连通图中所有的顶点；</li><li>任意两顶点之间有且仅有一条通路；</li></ul></li></ul><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><h3 id="图的顺序存储结构"><a href="#图的顺序存储结构" class="headerlink" title="图的顺序存储结构"></a>图的顺序存储结构</h3><ul><li>虽然图结构的数据元素存在多对多关系，但是同样可以采用顺序储存，能够使用数组有效的储存图</li><li>需要注意的是：数组储存图时，需要一个数组存放图中顶点本身的数据（最好是一维数组），另外一个数组存储的是各顶点之间的关系（这时候就要是二维数组了）<h4 id="邻接矩阵无向图"><a href="#邻接矩阵无向图" class="headerlink" title="邻接矩阵无向图"></a>邻接矩阵无向图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixNDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//图顶点个数</span></span><br><span class="line">    <span class="type">char</span>[] vertexs;<span class="comment">//图顶点名称</span></span><br><span class="line">    <span class="type">int</span>[][] matrix;<span class="comment">//图关系矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixNDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        matrix=<span class="keyword">new</span> <span class="title class_">int</span>[size][size];<span class="comment">//设定图关系矩阵大小</span></span><br><span class="line">        <span class="built_in">this</span>.vertexs=vertexs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;<span class="comment">//设置矩阵值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(c[<span class="number">0</span>]);<span class="comment">//根据顶点名称确定对应矩阵下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(c[<span class="number">1</span>]);</span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>;<span class="comment">//无向图，在两个对称位置存储</span></span><br><span class="line">            matrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的遍历输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据顶点名称获取对应的矩阵下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i]==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line">        MatrixNDG pG;</span><br><span class="line">        <span class="comment">// 自定义&quot;图&quot;(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">// 采用已有的&quot;图&quot;</span></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">MatrixNDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接矩阵有向图"><a href="#邻接矩阵有向图" class="headerlink" title="邻接矩阵有向图"></a>邻接矩阵有向图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixDG</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">char</span>[] vertexs;</span><br><span class="line">    <span class="type">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        matrix=<span class="keyword">new</span> <span class="title class_">int</span>[size][size];</span><br><span class="line">        <span class="built_in">this</span>.vertexs=vertexs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和邻接矩阵无向图差别仅仅在这里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(c[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i]==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line">        MatrixDG pG;</span><br><span class="line">        <span class="comment">// 自定义&quot;图&quot;(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">//pG = new MatrixUDG();</span></span><br><span class="line">        <span class="comment">// 采用已有的&quot;图&quot;</span></span><br><span class="line">        pG = <span class="keyword">new</span> <span class="title class_">MatrixDG</span>(vexs, edges);</span><br><span class="line"></span><br><span class="line">        pG.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表无向表"><a href="#邻接表无向表" class="headerlink" title="邻接表无向表"></a>邻接表无向表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    Vertex[] vertexLists;<span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>&#123;<span class="comment">//邻接表节点类，单链表数据结构</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Vertex next;</span><br><span class="line"></span><br><span class="line">        Vertex(<span class="type">char</span> ch)&#123;<span class="comment">//初始化方法</span></span><br><span class="line">            <span class="built_in">this</span>.ch=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span>&#123;<span class="comment">//加到链表尾</span></span><br><span class="line">            Vertex node=<span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="keyword">new</span> <span class="title class_">Vertex</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line"></span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexLists=<span class="keyword">new</span> <span class="title class_">Vertex</span>[size];<span class="comment">//确定邻接表大小</span></span><br><span class="line">        <span class="comment">//设置邻接表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexLists[i]=<span class="keyword">new</span> <span class="title class_">Vertex</span>(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储边信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">           <span class="type">int</span> p1=getPosition(c[<span class="number">0</span>]);</span><br><span class="line">           vertexLists[p1].add(c[<span class="number">1</span>]);</span><br><span class="line">           <span class="type">int</span> p2=getPosition(c[<span class="number">1</span>]);</span><br><span class="line">           vertexLists[p2].add(c[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟据顶点名称获取链表下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].ch==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历输出邻接表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Vertex temp=vertexLists[i];</span><br><span class="line">           <span class="keyword">while</span>(temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.print(temp.ch+<span class="string">&quot; &quot;</span>);</span><br><span class="line">               temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListNDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">ListNDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接有向表"><a href="#邻接有向表" class="headerlink" title="邻接有向表"></a>邻接有向表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDG</span> &#123;</span><br><span class="line">    Vertex[] vertexLists;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>&#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Vertex next;</span><br><span class="line"></span><br><span class="line">        Vertex(<span class="type">char</span> ch)&#123;</span><br><span class="line">            <span class="built_in">this</span>.ch=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">            Vertex node=<span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="keyword">new</span> <span class="title class_">Vertex</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line"></span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexLists=<span class="keyword">new</span> <span class="title class_">Vertex</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexLists[i]=<span class="keyword">new</span> <span class="title class_">Vertex</span>(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">           <span class="type">int</span> p=getPosition(c[<span class="number">0</span>]);</span><br><span class="line">           vertexLists[p].add(c[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].ch==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Vertex temp=vertexLists[i];</span><br><span class="line">           <span class="keyword">while</span>(temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.print(temp.ch+<span class="string">&quot; &quot;</span>);</span><br><span class="line">               temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">ListDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li><p>所谓图的遍历，简单理解就是逐个访问图中的顶点，确保每个顶点都只访问一次</p></li><li><p>深度优先搜索算法遍历图1无向图的过程:<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271413712.png" alt="image-20221027141315660"></p></li></ul><p>1.初始状态下，无向图中的所有顶点都是没有被访问过的，一次可以任选一个顶点出发，遍历整个无向图，假设从V1顶点开始，先访问V1顶点。</p><p>2.紧邻V1的顶点有两个，分别是V2和V3，它们都没有被访问过，从它们中任选一个，这里选择V2</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271530315.png" alt="image-20221027153049261"></p><p>3.紧邻V2的顶点三个，分别是V1，V4，V5，尚未被访问的有V4，V5，从它们中任选一个，比如访问V4，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531571.png" alt="image-20221027153105528"></p><p>4.紧邻 V4 的顶点有两个，分别是 V2 和 V8，只有 V8 尚未被访问，因此访问 V8，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531449.png" alt="image-20221027153116398"></p><p>5.紧邻 V8 的顶点有两个，分别是 V4 和 V5，只有 V5 尚未被访问，因此访问 V5，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531351.png" alt="image-20221027153133306"></p><p>6.和 V5 相邻的顶点有两个，分别是 V2 和 V8，它们都已经访问过了。也就是说，此时从 V5 出发，找不到任何未被访问的顶点了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531438.png" alt="image-20221027153147389"></p><p>7.这种情况下，深度优先搜索算法会回退到之前的顶点，查看先前有没有漏掉的、尚未访问的顶点：</p><ul><li>从 V5 回退到 V8，找不到尚未访问的顶点；</li><li>从 V8 回退到 V4，还是找不到尚未访问的顶点；</li><li>从 V4 回退到 V2，也还是找不到尚未访问的顶点；</li><li>从 V2 回退到 V1，发现 V3 还没有被访问。<br>于是，下一个要访问的顶点就是 V3，如下图所示：</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271532746.png" alt="image-20221027153201697"></p><p>8.紧邻 V3 的顶点有三个，分别是 V1、V6 和 V7，尚未访问的有 V6 和 V7，因此从它们中任选一个，比如访问 V6，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271532529.png" alt="image-20221027153214477"></p><p>9.紧邻 V6 的顶点有两个，分别是 V3 和 V7，只有 V7 还没有访问，因此访问 V7，如下图所示：</p><p>10.紧邻 V7 顶点有 V6 和 V3，但它们都已经访问过了，此时面临的情况和第 6 步完全一样，深度优先搜索算法的解决方法也是一样的：</p><ul><li>从 V7 回退到 V6，依然找不到尚未访问的顶点；</li><li>从 V6 回退到 V3，依然找不到尚未访问的顶点；</li><li>从 V3 回退到 V1，依然找不到尚未访问的顶点；</li><li>V1 是遍历图的起始顶点，回退到 V1 还找不到尚未访问的顶点，意味着以 V1 顶点为突破口，能访问的顶点全部已经访问完了。这种情况下，深度优先搜索算法会从图的所有顶点中重新选择一个尚未访问的顶点，从该顶点出发查找尚未访问的其它顶点。<br>从图 9 可以看到，图中已经没有尚未访问的顶点了，此时深度优先搜索算法才执行结束。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的存储结构&quot;&gt;&lt;a href=&quot;#图的存储结构&quot; class=&quot;headerlink&quot; title=&quot;图的存储结构&quot;&gt;&lt;/a&gt;图的存储结构&lt;/h1&gt;&lt;h2 id=&quot;基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）&quot;&gt;&lt;a href=&quot;#基本知识</summary>
      
    
    
    
    <category term="数据结构" scheme="https://kalyan-zitiu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-物理层</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/14/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/14/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-11-14T13:00:04.000Z</published>
    <updated>2022-11-14T13:43:00.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><ul><li>数据：传送信息的实体，通常时有意义的符号序列</li><li>信号：数据的电气/电磁的表现，时数据传输过程中的存在形式</li><li>信源：产生和发送数据的源头</li><li>信宿：接收数据的终点</li><li>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114805.png" alt="image-20221106163817766"></li></ul><h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道</li><li>半双工通信：通信的双方都可以发送或接收消息，但任何一方都不能同时发送和接收，需要两条信道</li><li>全双工通信：通信双方可以同时发送和接收信息，也需要两条信道</li></ol><h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><ul><li>串行传输<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114004.png" alt="image-20221106165443091"></li><li>并行传输<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114090.png" alt="image-20221106165454936"></li></ul><h3 id="并口"><a href="#并口" class="headerlink" title="并口"></a>并口</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114190.png" alt="image-20221106165557385"></p><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><ol><li>指的时一个固定时长的信号波形（数字脉冲）代表不同离散数值的基本波形（码元是一个信号）</li><li>数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，该时长称为码元宽度</li><li>当码元的离散状态右M（M&gt;2）时，此时码元为M进制码元</li><li>1个码元可以携带多个比特信息量。</li></ol><ul><li>举例子：</li></ul><ol><li><p>当码元的<strong>离散状态有四种时</strong>，那么就对应了四种不同的码元<strong>00，01，11，10</strong>。每个码元都对应着自己的电平也就是<strong>数字信号。</strong></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114665.png" alt="image-20221108160327118"></p></li></ol><h3 id="速率（数据率）匹配"><a href="#速率（数据率）匹配" class="headerlink" title="速率（数据率）匹配"></a>速率（数据率）匹配</h3><ol><li>数据的传输速率，单位时间内传输的数据量</li></ol><h4 id="传输速率和传播速率的区别"><a href="#传输速率和传播速率的区别" class="headerlink" title="传输速率和传播速率的区别"></a>传输速率和传播速率的区别</h4><p>前者主要针对主机，链路开端方面的数据，即把数据发送到链路的速度。<br>后者是指数据在整个信道上，链路上传播的速度</p><h4 id="码元传输速率（波形速率，调制速率，符号速率）"><a href="#码元传输速率（波形速率，调制速率，符号速率）" class="headerlink" title="码元传输速率（波形速率，调制速率，符号速率）"></a>码元传输速率（波形速率，调制速率，符号速率）</h4><ol><li>表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud），一波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的。</li></ol><h4 id="信息传输速率（信息速率，比特率）"><a href="#信息传输速率（信息速率，比特率）" class="headerlink" title="信息传输速率（信息速率，比特率）"></a>信息传输速率（信息速率，比特率）</h4><ol><li>单位时间内数字通信系统传输的二进制码元个数（比特数），单位是比特/秒（1s传输多少比特）</li></ol><h4 id="码元传输和信息传输的关系"><a href="#码元传输和信息传输的关系" class="headerlink" title="码元传输和信息传输的关系"></a>码元传输和信息传输的关系</h4><ol><li>若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M X n bit/s。</li></ol><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><ol><li>表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”</li><li>表示网络的通信线路所能传输数据的能力。（b/s）</li></ol><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><ol><li>现实中的信道会有带宽受限以及噪音等干扰<h4 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h4></li><li>震动的速度和频率太快了，以至于接收端区别不了码元之间的清晰界限的现象。<h5 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h5></li><li>是信道能通过的最高频率和最低频率之差</li></ol><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><ol><li>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud,W是信道带宽，单位是Hz。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114527.png" alt="image-20221108164817649"></p><ol start="2"><li>码元传输当然是有上限速率的。传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能</li><li>信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。（也就是W越大）</li><li>奈氏准则给出了码元的传输速率的限制，但并没有对信息传输速率给出限制</li><li>由于码元的传输速率受奈氏准则的制约，所以提高数据的传输速率，就必须设法使每个码元携带跟多个比特的信息量，这就需要采用多元制的调制方法</li></ol><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><ol><li>噪声的随机产生会使接收端一段时间失去对码元的判断能力。</li><li>因为噪声和信号是相对的，因此引入了一个信噪比的量</li><li>信噪比=信号的平均功率/噪声的平均功率。</li></ol><ul><li>香农定理： 在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值</li></ul><ol><li>信噪比越大，极限传输速率越高</li><li>只有有传输带宽以及信噪比，就能够确定信息传输速率的上限</li><li>只要信息的传输速率低于极限值，就有可能完成无差错的传输</li><li>实际的信道传输速率会比极限值低很多<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114164.png" alt="image-20221108170535322"></li></ol><h2 id="编码和调制以及其基础知识"><a href="#编码和调制以及其基础知识" class="headerlink" title="编码和调制以及其基础知识"></a>编码和调制以及其基础知识</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><ol><li>信道：是信号的传输媒介，一般用来表示向某个方向传送信息介质。所以会包含一根发送信道和接收信道</li><li>信道又会根据传输信号和传输介质分为模拟信道（传送模拟信号）/数字信道和无线信道/有线信道<h4 id="基带信号"><a href="#基带信号" class="headerlink" title="基带信号"></a>基带信号</h4></li></ol><ul><li>将数字信号1，0采用不同的电压表示，再送到链路上。来自于信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。直接表达了要传输信息的信号（不加任何东西）</li></ul><h4 id="宽带信号"><a href="#宽带信号" class="headerlink" title="宽带信号"></a>宽带信号</h4><ul><li>将基带信号也就是01010的数字信号进行调制形成的频分复用模拟信号，再送到模拟信道上。</li><li>宽带利用的是载波调制，信号频分，把信号放在较高频段来传输。</li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101232481.png" alt="image-20221110123237415"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101131784.png" alt="image-20221110113137741"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101132385.png" alt="image-20221110113206340"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101143934.png" alt="image-20221110114311908"></p><h5 id="非归零编码【NRZ】"><a href="#非归零编码【NRZ】" class="headerlink" title="非归零编码【NRZ】"></a>非归零编码【NRZ】</h5><ol><li>高1低0,编码容易实现,但没有检错功能,而且没法判断一个码元的开始和结束.两端的难以保持同步 </li><li>需要一个信道来发送这条信号的周期和速度,以达到发送与接收同步<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101142456.png" alt="image-20221110114258427"></li></ol><h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a><strong>曼彻斯特编码</strong></h5><ol><li>前高后低为1,前低后高为0.当然也可以反着来使用</li><li>曼彻斯特能够实现<strong>自同步接收</strong>,因为它把码元分为了<strong>两个相同的间隔</strong></li><li>编码会在码元的时间中间发生跳变,来告诉接收方时钟信号,并且还能作为数据信号传输</li><li>在一个码元时间内信号变化两次也就是进行了2次脉冲</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101151216.png" alt="image-20221110115150189"></p><h5 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a><strong>差分曼彻斯特编码</strong></h5><ol><li>同1异0,简单来说就是后半段电平的下一位遇到0的话就变化,遇到1则不变</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101159529.png" alt="image-20221110115928497"></p><h5 id="归零编码【RZ】"><a href="#归零编码【RZ】" class="headerlink" title="归零编码【RZ】"></a>归零编码【RZ】</h5><ol><li>信号的电平在每一个码元后都要恢复到0的状态</li><li>需要信道来传输时钟信号</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101146390.png" alt="image-20221110114621361"></p><h5 id="反向不归零编码【NRZI】"><a href="#反向不归零编码【NRZI】" class="headerlink" title="反向不归零编码【NRZI】"></a>反向不归零编码【NRZI】</h5><ol><li>信号的电平翻转表示0,不变表示1.也就是说遇到0就翻转一次电平,遇到1就不变</li><li>需要信道来传输时钟信号</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101148118.png" alt="image-20221110114824090"></p><h5 id="4B-5B编码"><a href="#4B-5B编码" class="headerlink" title="4B/5B编码"></a>4B/5B编码</h5><ol><li>在一个比特流中插入额外的比特来打破一连串的01数据流,就是用5个比特来编码4个比特的数据,之后再传给接收方.</li><li>每个4比特的不同排序都会对应不同排序的5比特.</li><li>剩下的5比特排序会留给作为<strong>数据的控制码,<strong>也就是</strong>定界</strong>一样的作用</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101205953.png" alt="image-20221110120535909"></p><h4 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101214059.png" alt="image-20221110121407005"></p><h4 id="模拟数据编码为数字信号（举例：音频数字化）"><a href="#模拟数据编码为数字信号（举例：音频数字化）" class="headerlink" title="模拟数据编码为数字信号（举例：音频数字化）"></a>模拟数据编码为数字信号（举例：音频数字化）</h4><ol><li><p>抽样：对模拟信号周期性扫描，把时间上的连续的信号变成时间上离散的信号（定理：f<del>采样频率</del>&gt;=2f<del>信号最高频率</del>）</p></li><li><p>量化：把取得的电平幅值分级标度转化为对应的数字值，并取整数，这就把连续的电平变为离散的数字量</p></li><li><p>编码：量化结果变为二进制编码</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101222807.png" alt="image-20221110122251757"></p></li></ol><h4 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h4><ol><li>可以使用频分复用技术，充分利用带宽资源。</li><li>模拟的声音数据是加载到模拟的载波信号中进行传输。</li></ol><h2 id="传输介质及分类"><a href="#传输介质及分类" class="headerlink" title="传输介质及分类"></a>传输介质及分类</h2><ol><li>传输介质也称传输媒体/传输媒介，它是数据传输系统中在发送设备和设备之间的<strong>物理通路</strong></li><li>它是在物理层下面的并不是物理层，有时候会把传输媒体称为体系结构的第0层</li></ol><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><ol><li>需要依赖物理媒介<h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4></li></ol><ul><li>两根采用一定的规则进行并排绞合的，相互绝缘的铜导线组成。能够减少对相邻导线的电磁干扰<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141730472.png" alt="image-20221114173045429"></li></ul><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141736886.png" alt="image-20221114173620742"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141739188.png" alt="image-20221114173936067"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141740893.png" alt="image-20221114174024782"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><h4 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h4><ul><li>信号向所有方向传播</li><li>较强的穿透能力，可远距离传输，多用于手机通信</li></ul><h4 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h4><ul><li>信号固定方向传播</li><li>微波通信频率较高，频段范围宽，因此数据率很高<h5 id="卫星通信"><a href="#卫星通信" class="headerlink" title="卫星通信"></a>卫星通信</h5></li><li>通信容量大，距离远，覆盖广，广播通信和多址通信</li><li>传播时延较长，受气候影响大，误码率高，成本高</li></ul><h4 id="红外线，激光"><a href="#红外线，激光" class="headerlink" title="红外线，激光"></a>红外线，激光</h4><ul><li>信号固定方向传播</li><li>把要传输的信号分别转换为各自的信号格式，即红外信号和激光信号在空间中传播。</li></ul><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141851879.png" alt="image-20221114185153756"></p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141852692.png" alt="image-20221114185248596"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h1&gt;&lt;h2 id=&quot;数据通信基础知识&quot;&gt;&lt;a href=&quot;#数据通信基础知识&quot; class=&quot;headerlink&quot; title=&quot;数据通信基</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库基本操作学习笔记</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/</id>
    <published>2022-11-08T04:47:04.000Z</published>
    <updated>2022-11-10T05:23:25.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库SQL"><a href="#数据库SQL" class="headerlink" title="数据库SQL"></a>数据库SQL</h1><h2 id="数据库数据定义"><a href="#数据库数据定义" class="headerlink" title="数据库数据定义"></a>数据库数据定义</h2><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n),character(n)</td><td>长度为n的定长字符串</td></tr><tr><td>varchar(n),charactervarying(n)</td><td>最大长度为n的变长字符串</td></tr><tr><td>clob</td><td>字符串大对象</td></tr><tr><td>blob</td><td>二进制大对象</td></tr><tr><td>smallint</td><td>短整数（2B）</td></tr><tr><td>int，integet</td><td>长整数（4B）</td></tr><tr><td>bigint</td><td>大整数（8B）</td></tr><tr><td>numberic(p,d)</td><td>定点数，由p位数字（不包括符号，小数点）组成，小数点后面有d位数字</td></tr><tr><td>decimal（p，d）,dec(p,d)</td><td>同上面NUMBERIC(p,d)</td></tr><tr><td>real</td><td>取决于机器精度的单精度浮点数</td></tr><tr><td>double precision</td><td>取决于机器精度的双精度点数</td></tr><tr><td>float(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr><td>boolean</td><td>逻辑布尔量</td></tr><tr><td>date</td><td>日期，包含年，月，日，格式为YYYY—MM—DD</td></tr><tr><td>time</td><td>时间，包含一日的时，分，秒，格式为HH：MM：SS</td></tr><tr><td>timestamp</td><td>时间戳类型</td></tr><tr><td>interval</td><td>时间间隔类型</td></tr></tbody></table><h3 id="大对象简介"><a href="#大对象简介" class="headerlink" title="大对象简介"></a>大对象简介</h3><p>1.用来存储大型数据，图片，视频，音乐<br>2.可用于存储二进制数据，字符数据，引用外部文件的指针的数据类型</p><ul><li><p>大对象的4种类型</p><ul><li><p>BLOB数据类型</p><ul><li>1.它是用来存储二进制数据</li><li>2.可以存储的最大数据量（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>CLOB数据类型</p><ul><li>1.存储字符数据</li><li>2.可以存储的最大数据量（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>NCLOB数据类型</p><ul><li>1.用来存储多字节字符的数据，一般用于非英文的字符</li><li>2.可以存储的最大数据量是（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>BFILE数据类型</p><ul><li><p>1.存储文件指针</p></li><li><p>2.数据文件可以存储再数据库之外，数据库存储对该文件的引用</p></li><li><p>3.其最多也可以存储4GB的数据   </p></li></ul></li></ul></li></ul><h3 id="一些重要的SQL语句"><a href="#一些重要的SQL语句" class="headerlink" title="一些重要的SQL语句"></a>一些重要的SQL语句</h3><ul><li>SELECT - 从数据库中提取数据</li><li>UPDATE - 更新数据库中的数据</li><li>DELETE - 从数据库中删除数据</li><li>INSERT INTO - 向数据库中插入新数据</li><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h2 id="SQL基本命令"><a href="#SQL基本命令" class="headerlink" title="SQL基本命令"></a>SQL基本命令</h2><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 datatype,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY( <span class="keyword">one</span> <span class="keyword">or</span> more columns )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><ul><li>select column_name, column_name from table_name</li></ul><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><ul><li>有时候一个列会包含多个重复值，有时候你也是只想列出不同的值而已</li><li>也就是只列出一个种类值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> column_name, column_name <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><ul><li>提取满足指定条件的记录</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> column_name operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><ul><li>注意：如果是搜索字符串的话，请注意内容的大小写，这不属于数据库SQL无视大小写字母的范畴</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>搜索某种模式</td></tr><tr><td>in</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h5 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h5><h6 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h6><ul><li>And与同时满足两个条件的值 ，查询表中数值范围内的值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span><span class="operator">*</span><span class="keyword">from</span> emp sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">and</span> sal <span class="operator">&lt;</span><span class="number">3000</span></span><br></pre></td></tr></table></figure><ul><li>逻辑运算的优先级</li></ul><table><thead><tr><th>（）</th><th>not</th><th>and</th><th>or</th></tr></thead></table><h6 id="特殊条件"><a href="#特殊条件" class="headerlink" title="特殊条件"></a>特殊条件</h6><ul><li>空值判断</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>查询表中的comm中的空值</p><ul><li>between and</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>查询范围内的值</p><ul><li>in</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span>(<span class="number">5000</span>,<span class="number">3000</span>,<span class="number">1500</span>)</span><br></pre></td></tr></table></figure><p>查询表中与值相同的值</p><ul><li>like</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;M%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询emp表中有M的值，上面为模糊信息</p><ul><li>%：表示多个字值，_表示一个字符</li><li>M%：为能配符，正则表达式，表示的意思是为模糊查询信息为M开头的</li><li>%M%：查询包含M的所有内容</li><li>%M_：表示查询以M在倒数第二位的所有内容<h2 id="AND-amp-OR-运算符"><a href="#AND-amp-OR-运算符" class="headerlink" title="AND &amp; OR 运算符"></a>AND &amp; OR 运算符</h2></li></ul><p>1.如果两个条件同时成立，则AND运算符显示一条记录<br>2.如果两个条件中只有一个条件成立，则OR运算符显示一条记录</p><h3 id="AND运算符实例"><a href="#AND运算符实例" class="headerlink" title="AND运算符实例"></a>AND运算符实例</h3><p>表示查询出表中名字叫fuck而且性别男的信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;fuck&#x27;</span> <span class="keyword">AND</span> sex <span class="operator">=</span> <span class="string">&#x27;man&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="OR运算符实例"><a href="#OR运算符实例" class="headerlink" title="OR运算符实例"></a>OR运算符实例</h3><p>表示查询出表中名字叫fuck或者性别男的信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;fuck&#x27;</span> <span class="keyword">OR</span> sex <span class="operator">=</span> <span class="string">&#x27;man&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ORDER-BY-关键字"><a href="#ORDER-BY-关键字" class="headerlink" title="ORDER BY 关键字"></a>ORDER BY 关键字</h2><ul><li>用于对结果集按照一个列或者多个列进行排序</li><li>默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，你可以使用DESC关键字<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>在表中查询信息并且按照升序或降序排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name,column_name <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h2>该语句用于插入新的记录</li></ul><ol><li>不用指定插入数据的列名，只需要提供被插入的信息即可<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">values</span>(value1,value2,value3,...)</span><br></pre></td></tr></table></figure></li><li>需要指明列名以及被插入的信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...)</span><br></pre></td></tr></table></figure></li><li>无需指定的多表插入<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">values</span></span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3);</span><br></pre></td></tr></table></figure><h2 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h2></li></ol><ul><li>更新表中的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">set</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">where</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> site <span class="keyword">set</span> pre <span class="operator">=</span> <span class="string">&#x27;kalyan&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101105753.png" alt="image-20221110110519707"></p><h2 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h2><p>用来删除表中的行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><h2 id="SELECT-TOP，LIMIT，ROWNUM子句"><a href="#SELECT-TOP，LIMIT，ROWNUM子句" class="headerlink" title="SELECT TOP，LIMIT，ROWNUM子句"></a>SELECT TOP，LIMIT，ROWNUM子句</h2><p>1.SELECT TOP 子句用于规定要返回的记录的数目<br>2.SELECT TOP子句对于拥有数千条记录的大型表来说，是非常有用的<br>3.需要注意的是不是所有数据库系统都支持select top语句。mysql支持limit语句来选取指定的条数数据，Oracle可以使用rownum来选取</p><ul><li>SQL server/MS Access语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top number<span class="operator">|</span><span class="keyword">percent</span> column_name(s) <span class="keyword">from</span> table_name LIMIT nember</span><br></pre></td></tr></table></figure></li><li>MySQL语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name limit number</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> persons limit <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li>Oracle语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> rownwm<span class="operator">&lt;=</span>number</span><br></pre></td></tr></table></figure></li></ul><h2 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h2><ul><li>ALTER TABLE语句使用与在已有表中添加，修改，删除列</li></ul><ol><li>添加<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">add</span> column_name datatype;</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> column_name;</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name datatype;</span><br></pre></td></tr></table></figure></li></ol><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>替代0个或多个字符</td></tr><tr><td>_</td><td>替代一个字符</td></tr><tr><td>[charlist]</td><td>字符列中的任何单一字符</td></tr><tr><td>[^charlist]或[!charlist]</td><td>不在字符列中的任何单一字符</td></tr></tbody></table><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>通过使用SQL，可以为表名称或者列名称修改成为你喜欢的名字<br>这能够让你的表格根据有阅览性</p><ul><li>列的SQL别名语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">AS</span> alians_name <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li>表的SQL别名语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">AS</span> alias_name</span><br></pre></td></tr></table></figure></li></ul><h2 id="连接-JOIN"><a href="#连接-JOIN" class="headerlink" title="连接(JOIN)"></a>连接(JOIN)</h2><ul><li><p>join用于把两个或者多个表结合起来。</p></li><li><p>下面有相关的七种用法<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101103442.png" alt="image-20221110110358365"></p></li><li><p>inner join:如果表中有至少一个匹配，则返回行</p></li><li><p>left join：即使右表中没有匹配，也从左表返回所有的行</p></li><li><p>right join：即使左表中没有匹配，也从右表返回所有的行</p></li><li><p>full join：只要其中一个表中存在匹配，则返回行</p></li></ul><h3 id="SQL连接查询"><a href="#SQL连接查询" class="headerlink" title="SQL连接查询"></a>SQL连接查询</h3><ul><li><p>连接查询是关系数据表中最主要的查询，主要包括内连接，外连接以及交叉连接</p></li><li><p>在关系数据库管理系统中，表建立时各数据之间的关系不一定需要确定，经常把一个实体的所有信息放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息</p></li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><ul><li>内连接是一种最常用的连接类型。内连接查询实际上是一种任意条件的查询。使用内连接时，如果两个表的相关字段满足连接条件，就从这两个表中提取数据并组合成新的记录，也就是在内连接查询中，只有满足条件的元组才能出现在结果关系中</li><li>指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--例如：要查询每个已经选课的学生的情况，查询语句为</span></span><br><span class="line"><span class="comment">--等值连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> S.Sno <span class="operator">=</span> SC.Sno</span><br><span class="line"><span class="comment">--实际使用中常常省略 inner join</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student,SC <span class="keyword">WHERE</span> S.Sno <span class="operator">=</span> SC.Sno</span><br><span class="line"></span><br><span class="line"><span class="comment">--自然连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> S.Sno <span class="operator">=</span> SC.Sno</span><br></pre></td></tr></table></figure><h5 id="左连接left-join"><a href="#左连接left-join" class="headerlink" title="左连接left join"></a>左连接left join</h5></li><li>即使右表中没有匹配，也从左表返回所有的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name A <span class="keyword">left</span> <span class="keyword">join</span> table_name B <span class="keyword">on</span> A.column_name <span class="operator">=</span> B.column_name; </span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> Monggo m <span class="keyword">left</span> <span class="keyword">join</span> site s <span class="keyword">on</span> s.pre <span class="operator">=</span> m.pre;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101104378.png" alt="image-20221110110450327"></p><h5 id="右连接right-join"><a href="#右连接right-join" class="headerlink" title="右连接right join"></a>右连接right join</h5><ul><li>原理同上</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><ul><li>左边表数据行全部保留，右边表保留符合连接条件的行。<br>双表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure>三表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTC</span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTC.A</span><br></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5></li><li>右边表数据行全部保留，左边表保留符合连接条件的行。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure><h5 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h5></li><li>左外连接 union 右外连接。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">FULL</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB</span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="SQL-CREATE-VIEW语句"><a href="#SQL-CREATE-VIEW语句" class="headerlink" title="SQL CREATE VIEW语句"></a>SQL CREATE VIEW语句</h3><ul><li>简化数据访问，让复杂的 SQL 语句简单化。用户只需要对视图写简单的代码就能返回需要的数据，一些复杂的逻辑放在视图中完成。</li><li>防止敏感的字段被选中，同时仍然提供对其它重要数据的访问。</li><li>可以对视图添加一些额外的索引，来提高查询的效率。</li><li>在SQL中，视图时基于SQL语句的结果集的可视化的表</li><li>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段</li></ul><h3 id="SQL-CREATE-VIEW基本格式"><a href="#SQL-CREATE-VIEW基本格式" class="headerlink" title="SQL CREATE VIEW基本格式"></a>SQL CREATE VIEW基本格式</h3><ul><li>视图显示的是最新的数据，每当用户查询视图时候，数据库引擎通过使用视图的SQL语句重建数据。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span> column1，column2....</span><br><span class="line"><span class="keyword">from</span> table_name <span class="keyword">where</span>[<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h3><ul><li><p>SQL CREATE OR REPLACE VIEW语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure></li><li><p>添加</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> [<span class="keyword">current</span> product list] <span class="keyword">AS</span> <span class="keyword">select</span> productID,productName,Category <span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> discontinued<span class="operator">=</span><span class="keyword">no</span></span><br></pre></td></tr></table></figure></li><li><p>在server上</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> [ schema_name . ] view_name [ ( <span class="keyword">column</span> [ ,...n ] ) ] </span><br><span class="line">[ <span class="keyword">WITH</span> <span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> [ ,...n ] ] </span><br><span class="line"><span class="keyword">AS</span> select_statement </span><br><span class="line">[ <span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION ] [ ; ]</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> ::<span class="operator">=</span> </span><br><span class="line">&#123; </span><br><span class="line">    [ ENCRYPTION ]</span><br><span class="line">    [ SCHEMABINDING ]</span><br><span class="line">    [ VIEW_METADATA ]     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL-基本函数-以下均用SQL-server"><a href="#SQL-基本函数-以下均用SQL-server" class="headerlink" title="SQL 基本函数(以下均用SQL server)"></a>SQL 基本函数(以下均用SQL server)</h2><h3 id="AVG（）"><a href="#AVG（）" class="headerlink" title="AVG（）"></a>AVG（）</h3><ul><li>返回数组列的平均值<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;平均值&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102731.png" alt="image-20221108094247557"></p><h3 id="COUNT（）"><a href="#COUNT（）" class="headerlink" title="COUNT（）"></a>COUNT（）</h3><ul><li><p>返回函数匹配指定条件的值得数目</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(site_id) <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&lt;</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102230.png" alt="image-20221108095113965"></p><h3 id="FIRST（）（SQL-server-TOP-1）"><a href="#FIRST（）（SQL-server-TOP-1）" class="headerlink" title="FIRST（）（SQL server/TOP 1）"></a>FIRST（）（SQL server/TOP 1）</h3><ul><li>返回指定得列中得第一个记录的值<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site  <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102449.png" alt="image-20221108100159623"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102570.png" alt="image-20221108100426725"></li></ol><h3 id="LAST（）（SQL-server-TOP-1-DESC）"><a href="#LAST（）（SQL-server-TOP-1-DESC）" class="headerlink" title="LAST（）（SQL server/TOP 1 + DESC）"></a>LAST（）（SQL server/TOP 1 + DESC）</h3><ul><li><p>返回指定列中的最后一个记录的值(找TOP 1 的倒序)</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&lt;</span><span class="number">100</span> <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102522.png" alt="image-20221108101150100"></p><h3 id="MAX（）"><a href="#MAX（）" class="headerlink" title="MAX（）"></a>MAX（）</h3><ul><li><p>返回指定列的最大值</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(column_name)<span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;最大值&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101148.png" alt="image-20221108102303157"></p><h3 id="MIN（）"><a href="#MIN（）" class="headerlink" title="MIN（）"></a>MIN（）</h3><ul><li><p>返回指定列的最小值</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MIN</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MIN</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;最小值&#x27;</span> <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101304.png" alt="image-20221108103744764"></p><h3 id="SUM（）"><a href="#SUM（）" class="headerlink" title="SUM（）"></a>SUM（）</h3><ul><li><p>返回返回数值列的总数</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例 </p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101932.png" alt="image-20221108104354535"></p><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li>语句用于结合聚合函数（以上的基本函数就是聚合函数），根据一个或多个列队结果集进行分组<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,aggregate_function(column_name) </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> site_id,<span class="built_in">sum</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site <span class="keyword">group</span> <span class="keyword">by</span> site_id;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101973.png" alt="image-20221108111402398"></p><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li>能够与聚合函数一起使用，用于筛选分组后的各组数据<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,aggregate_function(column_name) </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br><span class="line"><span class="keyword">Having</span> aggregate_function(column_name) operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> site_id,<span class="built_in">sum</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site <span class="keyword">group</span> <span class="keyword">by</span> site_id <span class="keyword">having</span>  <span class="built_in">sum</span>(count) <span class="operator">&lt;</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101257.png" alt="image-20221108112038865"></p><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><ul><li><p>判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">450</span>);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101930.png" alt="image-20221108114028592"></p><h3 id="UCASE（）-UPPER（）"><a href="#UCASE（）-UPPER（）" class="headerlink" title="UCASE（）(UPPER（）)"></a>UCASE（）(UPPER（）)</h3><ul><li><p>把字段的值转为大写</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">UPPER</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(pre) <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101226.png" alt="image-20221108121304926"></p><h3 id="LCASE（）-LOWER（）"><a href="#LCASE（）-LOWER（）" class="headerlink" title="LCASE（）/LOWER（）"></a>LCASE（）/LOWER（）</h3><ul><li><p>把字段的值转换为小写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">LOWER</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">LOWER</span>(pre) <span class="keyword">from</span> site ;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101100031.png" alt="image-20221108122014010"></p><h3 id="MID（）-并不存在SQL-Server"><a href="#MID（）-并不存在SQL-Server" class="headerlink" title="MID（）(并不存在SQL Server)"></a>MID（）(并不存在SQL Server)</h3><ul><li>用于文本字段中提取字符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> MID(column_name,statr,[,length]) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LEN（）"><a href="#LEN（）" class="headerlink" title="LEN（）"></a>LEN（）</h3><ul><li>返回文本中字段的长度<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LEN(column_name)<span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li> 实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LEN(pre) <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101100544.png" alt="image-20221108122515385"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库SQL&quot;&gt;&lt;a href=&quot;#数据库SQL&quot; class=&quot;headerlink&quot; title=&quot;数据库SQL&quot;&gt;&lt;/a&gt;数据库SQL&lt;/h1&gt;&lt;h2 id=&quot;数据库数据定义&quot;&gt;&lt;a href=&quot;#数据库数据定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据库" scheme="https://kalyan-zitiu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://kalyan-zitiu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>KALI之arp欺骗</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/05/KALI%E4%B9%8Barp%E6%AC%BA%E9%AA%97/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/05/KALI%E4%B9%8Barp%E6%AC%BA%E9%AA%97/</id>
    <published>2022-11-05T12:01:04.000Z</published>
    <updated>2022-11-10T02:50:34.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KALI-arp欺骗"><a href="#KALI-arp欺骗" class="headerlink" title="KALI -arp欺骗"></a>KALI -arp欺骗</h1><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ul><li>kali linux</li><li>nmap</li><li>arpspoof</li><li>ettercap</li><li>driftnet</li></ul><h2 id="欺骗原理"><a href="#欺骗原理" class="headerlink" title="欺骗原理"></a>欺骗原理</h2><ol><li><p>ARP的全称是Address Resolution Protocol，翻译而成就是地址解析，需要注意的是这是针对以太网地址解析协议的一种攻击技术，通过欺骗局域网内访问者的PC的网关MAC地址，使访问者PC错以为攻击者的MAC地址才是网关的地址，导致被攻击者的网络不同。甚至可以修改被攻击者的数据报。</p></li><li><p>总的来说改攻击手法并不是让局域网的网络瘫痪而是直接切断所有主机的所有请求和所有该收取的响应。</p></li></ol><h2 id="个人步骤"><a href="#个人步骤" class="headerlink" title="个人步骤"></a>个人步骤</h2><ol><li>用netdiscover -p嗅探局域网内的存活的主机</li><li>一般第一步是很难达到你想要的目标，那么可以改用mrt工具，它可以直接检测目标地址的路由设备。</li><li>那么既然已经找到了路由，就可以通过路由fping自己的ip，这是用自己的ip地址来发出请求嗅探报文，如果有响应的话那么能知道局域网里面哪些ip是存活的，当然也会存在自己无法嗅探到的主机</li><li>既然确定了目标的ip就可以用arpspoof工具进行攻击</li></ol><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><ol><li>目标主机：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101050888.png" alt="image-20221105195940111"></li><li>他急了<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101050924.png" alt="image-20221105200011172"></li></ol>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="KALI" scheme="https://kalyan-zitiu.github.io/categories/KALI/"/>
    
    
    <category term="Kali linux" scheme="https://kalyan-zitiu.github.io/tags/Kali-linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-链路层</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/05/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/05/%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-11-05T11:00:04.000Z</published>
    <updated>2022-11-10T02:50:16.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul><li>数据链路层在物理层提供服务的基础上向<strong>网络层提供服务</strong> </li><li>主要作用是加强物理层传输原始比特流的功能，将物理层上提供可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li></ul><h2 id="封装成帧-帧定界"><a href="#封装成帧-帧定界" class="headerlink" title="封装成帧/帧定界"></a>封装成帧/帧定界</h2><ul><li>就是在一段数据前后添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流就可以识别到比特流的开始和结束。简称为”帧定界”</li></ul><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><ul><li>接受方应当能从接收到的二进制比特流中区分出帧的起始和终止。</li><li>组帧的四种方法：1.字符计数法  2.字符填充法  3.零比特填充法  4.违规编码法</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>在链路层上你不可能知道传输的是什么样的比特组合或者什么样类型的数据</li><li>字符计数法<ul><li>帧的首部使用的是一个计数字段来标明帧内字符数</li><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101049727.png" alt="image-20221014152411083"></li><li> 每个帧上的第一个数字代表了帧内有几个字节，但凡哪一个帧第一个字节出错了，整个也就错误了</li></ul></li><li>字符填充法<ul><li>以比特组合来判别帧边界,但传送的帧最好是由文本组成（因为文本文件的字符都是由键盘输入的，都是ASCLL码）</li><li>如果传送的帧是非ASCLL码的文本文件组成时（二进制代码的程序或图像等）。就要采用字符填充的方法来实现透明传输。  </li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161553200.png" alt=" "></li></ul></li><li>零比特填充法<ul><li>  <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161555764.png" alt="image-20221016155534713">理解就可以pass，总结就是5110.</li></ul></li><li>违规编码法<ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161558795.png" alt="image-20221016155820755"></li></ul></li></ul><h2 id="差错控制（检错编码）"><a href="#差错控制（检错编码）" class="headerlink" title="差错控制（检错编码）"></a>差错控制（检错编码）</h2><h3 id="差错怎么来的"><a href="#差错怎么来的" class="headerlink" title="差错怎么来的"></a>差错怎么来的</h3><ul><li>差错总的概括可以说是因为线路本身电气特性所产生的随机噪声（热噪声），是固有的且随机存在的<h3 id="差错类型"><a href="#差错类型" class="headerlink" title="差错类型"></a>差错类型</h3><h4 id="位错"><a href="#位错" class="headerlink" title="位错"></a>位错</h4></li><li>比特位出错，1和0的变化<h4 id="帧错"><a href="#帧错" class="headerlink" title="帧错"></a>帧错</h4>现有[#1]-[#2]-[#3];</li><li>丢失：[#1]-[#3]；</li><li>重复：[#1]-[#2]-[#2]-[#3]；</li><li>失序：[#1]-[#3]-[#2]；</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>差错控制（比特位）</p><h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><ul><li>奇偶校验码（1个校验元和n-1个信息元）<ul><li>奇校验码：”1”的个数为奇数，而且错误是奇数个检验错误</li><li>偶校验码：”1”的个数为偶数 ，错误是偶数个检验错误</li></ul></li><li>CRC循环冗余码<ul><li>发送端：最终发送的数据等于要发送的数据+帧检验序列FCS</li><li>计算冗余码：1.加0   2.模2除法：数据加0后处于多项式，余数就是为冗余码FCS</li><li>发送端顺序：<ul><li>1.接受发送的数据</li><li>2.采用CRC校验</li><li>3.生成多项式</li><li>4.计算冗余码</li><li>5.把发送数据加上冗余码如”1101011011”+”1110”=”11010110111110”</li></ul></li><li>接收端顺序：<ul><li>收到的每一个帧都除以同样的除数，然后检查得到的余数R。</li><li>1.余数为0，无错，接受 2.余数不为0，有错，丢弃 <h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><h5 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h5></li></ul></li></ul></li><li>注意：海明码是能发现双比特错误，但是只能纠正单比特错误。</li><li>工作流程=确认校验码位数r+确认校验码和数据的位置+求出校验码的值+检错并纠错<h5 id="确认校验码位数r"><a href="#确认校验码位数r" class="headerlink" title="确认校验码位数r"></a>确认校验码位数r</h5></li><li>海明不等式： 2^r^&gt;=k+r+1(r为冗余信息位，k为信息位)</li><li>列子：发送数据101101。数据位是6位，那么根据公式r则最小的是4位，那么海明码的位数就需要是6+4=10位，其中的原数据是6位，校验码是4位。</li></ul><h5 id="确认校验码和数据的位置"><a href="#确认校验码和数据的位置" class="headerlink" title="确认校验码和数据的位置"></a>确认校验码和数据的位置</h5><ul><li><p>校验码只能放在2的几次方上的位置</p></li><li><p>先计算好总的数据位，然后先安排校验码的放入，最后把数据按序填满</p></li><li><p>例子：<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210170854928.png" alt="image-20221017085425891"></p></li><li><p>P类为校验码，D类为数据位</p></li><li><p>看P<del>1</del>的第一位是1，所以所有第一位为一数据位和校验码都得一起异或为0，这样就能求出P<del>1</del>的值</p></li><li><p>以此类推求出其他的P值</p></li></ul><h5 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h5><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210170924679.png" alt="s"></li><li>以上图为例子数据位是101101，则加上海明码后收到的是0010111101。</li><li>令所有要校验的位继续异或运算得出的二进制序列0101恰好对应十进制的5，所以出错的位置就是5并且改为反码<h4 id="数据链路层和物理层的数据编码的区别"><a href="#数据链路层和物理层的数据编码的区别" class="headerlink" title="数据链路层和物理层的数据编码的区别"></a>数据链路层和物理层的数据编码的区别</h4></li><li>物理层针对的是单个比特，解决传输过程中比特的同步等问题，列如曼彻斯特编码</li><li>数据链路层</li></ul><h4 id="冗余编码"><a href="#冗余编码" class="headerlink" title="冗余编码"></a>冗余编码</h4><ul><li>在数据发送之前，先按某种关系附加上一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时。相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否符合原规则，从而判断是否出错。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>较高的发送速度和较低的接受能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</li><li>数据链路层的流量控制是点对点的，而传输层是端到端的</li><li>数据链路层流量控制手段：接收方收不下就不回复确认</li><li>传输层流量控制手段：接收端给发送端一个窗口公告。</li></ul><h2 id="流量控制的方法"><a href="#流量控制的方法" class="headerlink" title="流量控制的方法"></a>流量控制的方法</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><ul><li><p>每发送一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧</p></li><li><p>发送窗口大小=1，接收窗口大小=1</p><h4 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h4></li><li><p>丢包：物理线路故障，设备故障，病毒攻击，路由信息错误等原因，会导致数据包的丢失</p><h5 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210251501765.png" alt="image-20221025150130693"></p><h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h5><h6 id="数据帧丢失或检测到帧出错"><a href="#数据帧丢失或检测到帧出错" class="headerlink" title="数据帧丢失或检测到帧出错"></a>数据帧丢失或检测到帧出错</h6></li><li><p>数据帧丢失或检测到帧出错，所有会存在一个超时计时器：每发送一个帧就启动一个计时器，但超时计时器设置的重传实践应当比帧的传输的平均RTT更长一些</p></li><li><p>发完一个帧后，必须保留它的副本。数据帧和确认帧必须编号</p></li></ul><h6 id="ACK确认帧的丢失或迟到"><a href="#ACK确认帧的丢失或迟到" class="headerlink" title="ACK确认帧的丢失或迟到"></a>ACK确认帧的丢失或迟到</h6><ul><li><p>丢失</p><ul><li>发送方在超时后，会重传数据帧</li><li>接收方会收到后会丢弃重传的数据帧，然后重新发送确认帧</li></ul></li><li><p>迟到</p><ul><li>如果发送方发了一个1号数据帧，1号确认帧却迟到到下一个2号帧发送后才被发送方接收到，这时候发送方会把1号的确认帧直接丢弃<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4></li></ul></li><li><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期地比率</p><h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3></li><li><p>发送窗口大小&gt;1，接收窗口大小=1</p></li><li><p>流水线技术，需要增加序号范围</p></li><li><p>发送方需要缓存多个分组</p><h4 id="GBN中的滑动窗口"><a href="#GBN中的滑动窗口" class="headerlink" title="GBN中的滑动窗口"></a>GBN中的滑动窗口</h4></li><li><p>发送窗口：发送方维持一组连续的允许发送的帧的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261712772.png" alt="image-20221026171201711"></p></li><li><p>接收窗口：接受方维持一组连续允许接收帧的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261712878.png" alt="image-20221026171237832"></p><h5 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h5></li><li><p>上层的调用</p><ul><li>上层要发送数据时候，需要先查看发送方的窗口是否已满，未满则生成一个帧并且发送，若已满的， 发送方会缓存数据，等窗口空闲之后发送</li></ul></li><li><p>对ACK确认帧的响应</p><ul><li>GBN协议中，对n号的确认采用的是累积确认的方式，标明接收方已经收到了n号帧和它之前的全部帧 </li><li>累积确认：如果接收方收到了3号帧的确认帧，也就是说他已经收到了0到2号的所有帧，并且发送了确认帧</li></ul></li><li><p>超时事件 </p><ul><li>来源于出现丢失或者时延过长帧时发送方的行为。也会存在一个计时器再次用户恢复数据或者确认帧丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。<h5 id="接收方需要干的b事"><a href="#接收方需要干的b事" class="headerlink" title="接收方需要干的b事"></a>接收方需要干的b事</h5></li></ul></li><li><p>正确并且按序收到n号帧，那么会发送n号确认帧，并且把数据交付于上层</p></li><li><p>只要不是按照顺序收到的帧都会丢弃掉，并且会为需要接收的序号帧发送ACK，接收方不需要做任何缓存，只需要维护信息的有序性（比如现在我要收的是1号帧，如果其他帧来了的话，一律丢弃）</p></li></ul><h5 id="滑动窗口的长度"><a href="#滑动窗口的长度" class="headerlink" title="滑动窗口的长度"></a>滑动窗口的长度</h5><ul><li>根据n个比特对帧编号，窗口尺寸应满足：1&lt;=w&lt;=2^n^-1</li></ul><h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a><strong>选择重传协议（SR）</strong></h3><ul><li>发送窗口大小&gt;1，接收窗口大小&gt;1</li><li>GBN因为有按序列的需求，所以后面本来能够传到的数据帧都得重新传输</li></ul><h4 id="选择重传的滑动窗口"><a href="#选择重传的滑动窗口" class="headerlink" title="选择重传的滑动窗口"></a>选择重传的滑动窗口</h4><ul><li>发送方：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261909294.png" alt="image-20221026190921230"></li><li>上层调用<ul><li>大致与GBN一样，收到数据后，如果没有窗口空闲，要么将数据缓存，要么就返回上层</li></ul></li><li>ACK<ul><li>如果收到了一个ACK，确认后，发送方可以将那个帧标记为已经接收。那么等到前面的序号帧确认完毕后，可以直接把窗口移到未确定的序号帧。比如我现在可以发送序号1，2，3帧，我的1号帧是未确定的，2号帧是已经确定的，3号帧是未发生的。那么等到1号帧确认完毕后，就可以直接把窗口跳到3号帧，不必再在2号帧逗留。</li></ul></li><li>超时事件<ul><li>每个帧都有自己的计时器，一个超时事件发生后只能重传一个帧 </li></ul></li></ul><ul><li>接收方：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261916895.png" alt="image-20221026191658841"></li><li>在窗口内的所有帧来者不拒<ul><li>只要接收到窗口内的帧，就直接载入缓存并且返回一个ACK确认帧，只要在窗口内的有连续的帧都已经收到后就可以将窗口移出该连续帧前进。</li><li>但是如果接收方收到了窗口以外的序号帧，第一种情况时小于窗口序号的，只要在窗口长度内的所有已确定帧再次收到传来的帧就会返回一个ACK确认帧回去。第二种情况就是大于窗口序号的，就直接不接受。 </li></ul></li></ul><h4 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h4><ul><li>发送窗口最好等于接收窗口。</li><li>当有n个比特对帧编号时候，就可有2^(n-1)^个发送窗口。</li></ul><h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><h3 id="点对点链路"><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h3><ul><li><p>两个相邻的节点通过一个链路相连，没有第三者。应用：PPP协议，常用于广域网</p><h3 id="广播式链路"><a href="#广播式链路" class="headerlink" title="广播式链路"></a>广播式链路</h3></li><li><p>应用范围比较小的局域网，通信范围比较大，所有主机共享通信介质。常用于无线局域网。</p></li><li><p>典型的拓扑结构：总线型，星型也就是逻辑总线型</p></li><li><p>分别对应下图：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021411550.png" alt="image-20221102141117479"></p><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><h4 id="静态划分信道–信道划分介质访问控制"><a href="#静态划分信道–信道划分介质访问控制" class="headerlink" title="静态划分信道–信道划分介质访问控制"></a>静态划分信道–信道划分介质访问控制</h4></li><li><p>概述：将使用介质的每个设备与来自于同一信道上的其他设备通信分隔开，把时域和频域资源合理地分配给网络上的设备</p></li><li><p>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高资源信道利用率。把一条广播信道，逻辑上分成几条用于两个节点之间通信互不干扰的子信道，实际就是把广播信道转变为点对点信道。</p><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021434326.png" alt="image-20221102143430276"></p></li><li><p>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</p></li><li><p>充分利用传输介质，系统效率较高。</p><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021441005.png" alt="image-20221102144128959"></p></li><li><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用着固定序号的时隙，所有用户轮流占用信道</p></li><li><p>举个很简单的例子：我们把<strong>TDM帧想象成一个洗澡间</strong>，现有四个人可以使用这个洗澡间洗澡，但是他们需要彼此间<strong>拿个序号</strong>分别为A，B，C，D。按照<strong>排序来轮流</strong>使用这个洗澡间。</p></li><li><p>TDM帧是在物理层传送的比特流所划分的帧，标志着一个周期。</p></li><li><p>因为大家都要轮流使用这个TDM帧，所以固定有个周期，那么某个主机需要使用信道时候，必须要等待其他三个都处于休息状态，那么信道利用率就会比较低。</p><h6 id="时分复用TDM-MAX高效率版–统计时分复用STDM"><a href="#时分复用TDM-MAX高效率版–统计时分复用STDM" class="headerlink" title="时分复用TDM MAX高效率版–统计时分复用STDM"></a>时分复用TDM MAX高效率版–统计时分复用STDM</h6></li><li><p>其实也就多了一个集中器，功能就是收集多个用户的数据一起发送到外面</p></li><li><p>注意了STDM帧并不是链路层的帧，是物理层比特流上划分的帧</p></li><li><p><strong>STDM帧中的时隙数小于连接在集中器上的用户数。</strong>用户一有数据就可以<strong>随时发往集中器中缓存</strong>，集中器再根据<strong>顺序扫描输入缓存</strong>，再放入到STDM帧中。<strong>达到了一定的时隙数就会发送一个STDM帧。</strong>当然STDM帧的时隙数并不是固定的，而是按<strong>照需求来分配时隙</strong>的，但是可以肯定地是它是会小于这个TDM帧上的用户数。</p><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h5></li><li><p>其实就是用光的频分多路复用，在一个光纤中传输多种不同地波长地光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h5></li><li><p>码分多址CDMA，1个比特分为多个码片/芯片，每个站点会制定一个唯一地m位地芯片序列。</p></li><li><p>发送1时站点发送芯片序列，发送0时则发送他的反码（通常把0写成-1）。</p></li><li><p>那么他们怎么不打架呢。多个站点同时发送数据的时候，要求各个站点芯片序列相互正交（对位相乘然后相加除以m位，等于0的话就可以一起发送）。</p></li><li><p>那么他们怎么合并呢，各路数据再信道中被线性相加（对应位置相加）</p></li><li><p>那么怎么分离呢，合并数据和源站规格化内积（对应位置相乘相加，处于总和）。</p></li></ul><h4 id="动态分配信道"><a href="#动态分配信道" class="headerlink" title="动态分配信道"></a>动态分配信道</h4><h5 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h5><h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h6><ul><li>每个局域网会有一个老大主机叫主结点，它会轮流邀请从属结点发送数据。</li><li>被邀请的主机可以选择要不要发数据，要则发不要则跳过，在老大询问主机时，其他主机均不具备发数据的能力，因为要没被邀请到。</li><li>因此它是不会发生冲突，而且还能占用全部的带宽。</li><li>1.那么就会有轮询开销，等待延迟，单点故障<h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h6></li><li>令牌：一个特殊格式的MAC控制帧，不含有任何信息。只有手持令牌的主机才能进行数据操作，能够控制信道的使用，确保同一时刻只有一个结点独占信道。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031144247.png" alt="image-20221103114405194"></p><ul><li>主机得到令牌后如果需要进行数据发送的话，那么就需要吃下令牌，并对标志位进行修改，把令牌从空闲状态转变为繁忙状态。</li><li>主机会把自己需要发送的数据和令牌结合构成一个数据帧，发送到一个目标主机处</li><li>目标主机发现<strong>数据帧（其实就是带着数据的令牌）</strong>是给自己的，那么目标主机会把数据帧copy一份缓存，然后再把数据帧发还给源主机。</li><li>源主机收到自己的数据帧后会<strong>检查是否出错</strong>，如果出错了会进行重传，没有则会回收。并把令牌空闲下来。</li><li>那么就会存在，令牌开销（令牌可能丢失），等待延迟（其他主机需要等待发送），单点故障（因处于在星型网状网络，若一个主机宕机，那么环形将受到破坏）</li></ul><h5 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h5><h6 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h6><ul><li>纯ALOHA协议<ul><li>不会监听信道，不按时间槽发送，随机重发。想发就发。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021540073.png" alt="image-20221102154037015"></li><li>冲突检测：接收方能够检测出差错，然后不确认，发送方在一定时间内收不到确认帧，那么就判定为冲突。</li></ul></li><li>时隙ALOHA协议<ul><li>把时间分为若干相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片再发送<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021558989.png" alt="image-20221102155832935"><h6 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h6></li></ul></li><li>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机再发送数据</li><li>当几个站同时再总线上发送数据时候，总线上的信号电压摆动值将会增大，当一个站检测出信号电压摆动值超过他们设定的一个门限值后，就认为总线上至少有两个站同时发送数据，表明产生了碰撞，即发生了冲突 </li><li>MA：多点接入，表示许多计算机以多点接入的方式连接再一根总线上</li><li>总的思想就是监听信道，信道空闲就发生，忙就推迟发送，<ul><li>1- 坚持CSMA思想，监听信道，一直监听到信道不忙为止，能够在第一时间发现媒体空闲，马上发送。但是如果有两个或者两个以上的站点需要发送，那么很有可能发生冲突</li><li>非坚持CSMA思想，监听信道，信道不空闲的话，会等待一个随机时间再进行监听，能够减少冲突发生的可能性。</li><li>p-坚持CSMA，监听信道，空闲则以p概率直接传输，不等待，概率1-p等到下一个时间槽再传输。忙的话等待一个随机时间再监听，减少冲突。但是，发生冲突后还是会坚持把数据帧都发送完，造成浪费。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021617521.png" alt="image-20221102161719454"><h6 id="载波监听多点接入-碰撞检测CSMA-CD"><a href="#载波监听多点接入-碰撞检测CSMA-CD" class="headerlink" title="载波监听多点接入/碰撞检测CSMA/CD"></a>载波监听多点接入/碰撞检测CSMA/CD</h6>CD:碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，一边判断自己在发送数据时其他站点是否也发送数据。<br>####### 传播时延对载波监听的影响</li></ul></li><li>单程端到端的传播时延：t<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031217333.png" alt="image-20221103121744238"></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031219305.png" alt="image-20221103121939250"></p><p>####### 截断二进制指数规避算法</p><ul><li>确定基本退避(推迟)时间为争用期2tao</li><li>定义参数k，它等于重传次数，但k不超过10，即k=min[重传次数，10]。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，k就不再增大而一直等于10。</li><li>从离散的整数集合[0，1，2<del>k</del>-1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rtao</li><li>当重传大16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li><li>如果连续多次发生冲突，表明可能有很多站参与数据交流。 </li></ul><p>####### 最小帧长问题</p><ul><li>帧的传输时延至少要两倍于信号在总线中的传播时延</li><li>最小帧长=总线传播时延 x 数据传输速率 x 2。</li><li>以太网规定最短帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧。 <h6 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h6></li><li>CA：碰撞避免，主要应用于无线局域网</li><li>发送数据前，监听信道是否空闲</li><li>空闲则发出RTS，RTS包括发射端的地址，接收端的地址，下一份数据将持续发送的时间等信息;信道忙则等待。</li><li>接收端收到RTS后，将响应CTS。</li><li>发送端收到CTS后，开始发送数据帧（同时：预约信道：发送方告知其他站点自己要用多久时间去传输）</li><li>接收端收到数据后，会用CRC来检验数据帧是否正确，正确则响应ACK帧</li><li>发送方收到ACK帧就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）</li><li>1.预约信道，2. ACK帧，3. RTS/CTS帧（可选）</li></ul><h2 id="局域网基本概念及体系结构"><a href="#局域网基本概念及体系结构" class="headerlink" title="局域网基本概念及体系结构"></a>局域网基本概念及体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><ul><li>简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</li><li>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>特点2：使用专门铺设的传输介质(双绞线，同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s)。</li><li>特点3：通信延迟时间短，误码率低，可靠性较高</li><li>特点4：各站为平等关系，共享传输信道</li><li>特点5：多采用分布式控制和广播式通信，能进行广播和组播</li><li>决定局域网的主要因素：网络拓扑，传输介质，介质访问控制方法</li></ul><h3 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031505307.png" alt="image-20221103150550233"></p><ul><li>星型拓扑：中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构形简单，建网容易，便于控制和管理。但这种网络系统，网络可靠性低，网络共享能力差，有单点故障问题。</li><li>总线型拓扑：网络可靠性高，网络节点间响应速度快，共享资源能力强，设备投入量少，成本低，安装使用方便，当某个工作站节点出现故障时，对整个网络系统影响小。 </li><li>环形拓扑：系统中通信设备和线路比较节省。有单点故障问题；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低</li><li>树型拓扑：易于拓展，易于隔离故障，也容易有单点故障。</li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><ul><li>CSMA/CD常用于总线型局域网，也用于树型网络</li><li>令牌总线常用于总线型局域网，他把总线型的各个工作站按一定顺序按接口地址大小排列成一个逻辑环 ，只有令牌持有者才能控制总线，才有发送信息的权力</li><li>令牌环，用于环形局域网，如令牌环网 </li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ol><li><p>概述：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps），快速以太网，千兆以太网和10G以太网，他们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA/CD。</p></li><li><p>令牌环网：物理上采用了星型拓扑结构</p></li><li><p>FDDI网 ：物理上采用了双拓扑结构，逻辑上是环形拓扑结构</p></li><li><p>ATM网：较新型的单元交换技术，使用53字节固定长度的单元进行交换。</p></li><li><p>无线局域网：采用IEEE 802.11标准</p></li></ol><h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><ul><li>是IEEE 802 LAN/MAN标准委员会制定的局域网，城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网，令牌环，无线局域网等。这一系列标准中的每一个子标准都有委员会的一个专门工作组负责。</li></ul><p>IEEE 802.1 ：局域网体系结构、寻址、网络互联和网络</p><p>IEEE 802.1A：概述和系统结构</p><p>IEEE 802.1B：网络管理和网络互连</p><p>IEEE 802.2 ：逻辑链路控制子层（LLC）的定义。</p><p>IEEE 802.3 ：以太网介质访问控制协议 （CSMA/CD）及物理层技术规范 [1]  。</p><p>IEEE 802.4 ：令牌总线网（Token-Bus）的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.5 ：令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。</p><p>IEEE 802.7 ：宽带技术咨询组，提供有关宽带联网的技术咨询。</p><p>IEEE 802.8 ：光纤技术咨询组，提供有关光纤联网的技术咨询。</p><p>IEEE 802.9 ：综合声音数据的局域网（IVD LAN）介质访问控制协议及物理层技术规范。</p><p>IEEE 802.10：网络安全技术咨询组，定义了网络互操作的认证和加密方法。</p><p>IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.11，1997年，原始标准（2Mbit/s，播在2.4GHz）。</p><p>IEEE 802.11a，1999年，物理层补充（54Mbit/s，播在5GHz）。</p><p>IEEE 802.11b，1999年，物理层补充（11Mbit/s播在2.4GHz）。</p><p>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</p><p>IEEE 802.11d，根据各国无线电规定做的调整。</p><p>IEEE 802.11e，对服务等级（Quality of Service, QoS）的支持。</p><p>IEEE 802.11f，基站的互连性（IAPP，Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</p><p>IEEE 802.11g，2003年，物理层补充（54Mbit/s，播在2.4GHz）。</p><p>IEEE 802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</p><p>IEEE 802.11i，2004年，无线网络的安全方面的补充。.</p><p>IEEE 802.11j，2004年，根据日本规定做的升级。</p><p>IEEE 802.11l，预留及准备不使用。</p><p>IEEE 802.11m，维护标准；互斥及极限。</p><p>IEEE 802.11n，更高传输速率的改善，基础速率提升到72.2Mbit/s，可以使用双倍带宽40MHz，此时速率提升到150Mbit/s。支持多输入多输出技术（Multi-Input Multi-Output，MIMO）。</p><p>IEEE 802.11k，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</p><p>IEEE 802.11p，这个通信协定主要用在车用电子的无线通信上。它设置上是从IEEE 802.11来扩充延伸，来符合智能型运输系统（Intelligent Transportation Systems，ITS）的相关应用。</p><p>IEEE 802.11ac，802.11n的潜在继承者,更高传输速率的改善，当使用多基站时将无线速率提高到至少1Gbps，将单信道速率提高到至少500Mbps。使用更高的无线带宽(80MHz-160MHz)(802.11n只有40MHz),更多的MIMO流(最多8条流),更好的调制方式(QAM256)。目前是草案标准(draft)，预计正式标准于2012年晚些时间推出。Quantenna公司在2011年11月15日推出了世界上第一只采用802.11ac的无线路由器。Broadcom公司于2012年1月5日也发布了它的第一支支持802.11ac的芯片。</p><p>IEEE 802.11ae-2012</p><p>IEEE 802.12 ： [1]  [2-3]  需求优先的介质访问控制协议（100VG AnyLAN）。</p><p>IEEE 802.13 ：(未使用 )【不吉利的数字，没有人愿意使用它—查自《计算机网络-Andrew S. Tanebaum》 Page 63 - 1.6.2 国际标准领域中最有影响的组织】</p><p>IEEE 802.14：采用线缆调制解调器(Cable Modem)的交互式电视介质访问控制协议及网络层技术规范。</p><p>IEEE 802.15：采用蓝牙技术的无线个人网（Wireless Personal Area Networks，WPAN）技术规范。</p><p>IEEE 802.15.1：无线个人网络。</p><p>IEEE 802.15.4：低速无线个人网络</p><p>IEEE 802.16：宽带无线连接工作组，开发2~66GHz的无线接入系统空中接口。</p><p>IEEE 802.17：弹性分组环 （Resilient Packet Ring，RPR）工作组，制定了单性分组环网访问控制协议及有关标准。</p><p>IEEE 802.18：宽带无线局域网技术咨询组（Radio Regulatory）。</p><p>IEEE 802.19：多重虚拟局域网共存（Coexistence）技术咨询组。</p><p>IEEE 802.20：移动宽带无线接入（ Mobile Broadband Wireless Access ，MBWA）工作组，制定宽带无线接入网的解决 。</p><p>IEEE 802.21：媒介独立换手（Media Independent Handover）。</p><p>IEEE 802.22： [4]  无线区域网（Wireless Regional Area Network）</p><p>IEEE 802.23：紧急服务工作组 （Emergency Service Work Group）</p><h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><ul><li><p>LLC负责识别网络层协议，然后对他们进行封装，LLC报头会告诉这个数据链路层一旦帧被接收了，应当对数据包做什么处理。为网络层提供服务：无确认无连接，面向连接，带确认无连接，高速传送。</p></li><li><p>MAC子层的主要功能包括数据帧的封装和卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性</p></li></ul><h2 id="以太网（802-3局域网）"><a href="#以太网（802-3局域网）" class="headerlink" title="以太网（802.3局域网）"></a>以太网（802.3局域网）</h2><ul><li>以太网使用CSMA/CD（载波监听多路访问及冲突检测）技术。</li><li>两个标准<ul><li>DIX Ethernet V2：第一个局域网产品规约</li><li>IEEE802.3：IEEE802委员会802.3工作组指定的第一个IEEE的以太网标准</li></ul></li></ul><h3 id="无连接，不可靠服务"><a href="#无连接，不可靠服务" class="headerlink" title="无连接，不可靠服务"></a>无连接，不可靠服务</h3><ul><li>无连接：发送方和接收方之间无“握手过程”</li><li>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</li><li>以太网只实现无差错接收，不实现可靠传输</li></ul><h3 id="以太网传输介质与拓扑结构的发展"><a href="#以太网传输介质与拓扑结构的发展" class="headerlink" title="以太网传输介质与拓扑结构的发展"></a>以太网传输介质与拓扑结构的发展</h3><ul><li>粗同轴电缆到细同周电缆到双绞线+集线器。</li><li>集线器的以太网的逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。</li><li>以太网拓扑：逻辑上总线型，物理上星型。</li></ul><h3 id="10ASE-T以太网"><a href="#10ASE-T以太网" class="headerlink" title="10ASE-T以太网"></a>10ASE-T以太网</h3><ul><li>10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE—T采用的是无屏蔽双绞线（UTP），物理上是采用星型拓扑，逻辑上总线型，每段双绞线最长为100m，用的是曼彻斯特编码</li></ul><h3 id="适配器（网卡）和MAC地址"><a href="#适配器（网卡）和MAC地址" class="headerlink" title="适配器（网卡）和MAC地址"></a>适配器（网卡）和MAC地址</h3><ul><li>计算机与外界有局域网的连接时通过通信适配器的</li><li>网络接口板，网络接口卡NIC</li><li>NOW，不再使用单独网卡</li><li>适配器上装有处理器和储存器</li><li>ROM上有计算机硬件地址MAC地址。</li><li>在局域网中，硬件地址又称为物理地址或MAC地址</li><li>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家（IEEE规定，后24位厂家自己规定，常用6个十六进制数表示）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211032141205.png" alt="image-20221103214140094"></li></ul><h3 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h3><ul><li>MAC帧最常用的是以太网V2的格式<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051442023.png" alt="image-20221105144230956"></li></ul><h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051455378.png" alt="image-20221105145531318"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051500542.png" alt="image-20221105150008469"></p><h3 id="无线局域网分类"><a href="#无线局域网分类" class="headerlink" title="无线局域网分类"></a>无线局域网分类</h3><h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051702001.png" alt="image-20221105170215891"></p><ul><li>AP<del>1</del>，AP<del>2</del>，都是这个基本服务集BSS中的一个基站</li><li>在这个基本服务集内的所有主机都可以进行数据分享</li><li>那么夸服务集交流数据的话，那么就要通过基站与基站之间交流来达到跨网传输</li></ul><h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><ul><li>各节点的地位相同，可以发送数据也可以接收数据</li><li>自己组成网络，自由度比较高</li></ul><h2 id="PPP协议和HDLC协议"><a href="#PPP协议和HDLC协议" class="headerlink" title="PPP协议和HDLC协议"></a>PPP协议和HDLC协议</h2><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><ul><li><p>通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨，几个大洲提供远距离通信，形成国际性的远程网络</p></li><li><p>通信子网主要使用分组交换技术。广域网的通信子网可以利用公网分组交换网，卫星通信网和无线分组交换网，它将分布在不同地区局域网或计算机系统互连起来，达到资源共享的目的，如因特网是世界上范围内最大的广域网。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051721183.png" alt="image-20221105172105114"></p><h3 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h3><ul><li>点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般使用PPP协议</li><li>不用需要任何纠错以及序号和流量控制</li><li>封装成帧，透明传输</li><li>多种网络层协议，封装的IP数据报可以采用多种协议</li><li>多种类型链路：串行/并行，同步/异步，电与光。</li><li>差错检测，错就丢弃</li><li>检测连接状态，链路是否能够正常工作</li><li>网络层地址协商 知道通信双方的网络层地址</li><li>数据压缩</li></ul><h4 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h4><ol><li>一个将IP数据报封装到串行链路的方法</li><li>链路控制协议LCP：建立并且维护数据链路连接，身份验证</li><li>网络层控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li></ol><h4 id="PPP协议的状态图"><a href="#PPP协议的状态图" class="headerlink" title="PPP协议的状态图"></a>PPP协议的状态图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051748583.png" alt="image-20221105174847515"></p><h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051749395.png" alt="image-20221105174951330"></p><ol><li>F/7E（十六进制）（八进制01111110）:标志字段也就是帧定界符</li><li>转义字符详细见透明传输</li><li>A:地址字段</li><li>C:控制字段</li><li>协议部分（IP数据报，LCP数据，网络控制数据）</li><li>PPP协议是面向字节的协议</li></ol><h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h4><ol><li><p>高级数据链路控制，是一个同步网上传输数据，面向比特的数据链路层协议，它是由国际化标准化组织ISO根据IBM公司的SDLC协议扩展开发而成</p></li><li><p>数据报文可以透明传输，用的是零比特插入法，能够便于硬件实现</p></li><li><p>采用的帧检验方法是CRC检验，对信息帧进行顺序编号，防止漏收或重份，传输可靠性高</p></li></ol><h4 id="HDLC站"><a href="#HDLC站" class="headerlink" title="HDLC站"></a>HDLC站</h4><ol><li>主站的主要功能是发送命令帧，接收响应帧，负责对整个链路的控制系统的初启，流程的控制，差错检测或恢复等。</li><li>从站的主要功能是接收由主站发来的命令帧，向主站发出响应帧，并且配合主站参与差错恢复等链路控制</li><li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制</li></ol><h4 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051805237.png" alt="image-20221105180545174"></p><ul><li>信息帧(I)第一位为0，用来传输数据信息，或使用捎带技术对数据进行确认</li><li>监督帧(S)10，用于流量控制和差错控制，执行对信息帧的确认，请求重发和请求暂停发送等功能</li><li>无编号帧(U)11，用于提供对链路的建立，拆除等多种控制功能。</li></ul><h4 id="PPP与HDLC协议的区别"><a href="#PPP与HDLC协议的区别" class="headerlink" title="PPP与HDLC协议的区别"></a>PPP与HDLC协议的区别</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051812956.png" alt="image-20221105181204864"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;h2 id=&quot;功能概述&quot;&gt;&lt;a href=&quot;#功能概述&quot; class=&quot;headerlink&quot; title=&quot;功能概述&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Articles in English#3</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/26/Englishwork(3)/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/26/Englishwork(3)/</id>
    <published>2022-10-26T13:11:04.000Z</published>
    <updated>2022-10-26T13:14:41.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Most-Unforgettable-Person-I-Ever-Know"><a href="#The-Most-Unforgettable-Person-I-Ever-Know" class="headerlink" title="The Most Unforgettable Person I Ever Know"></a>The Most Unforgettable Person I Ever Know</h1><p>​    In my main,the most unforgettable person I ever know is Stephen William Hawking. I was touched by both his achievements and difficult stories</p><p>​    In 1963, at the age of 21, Hawking developed muscular wasting lateral sclerosis (Lou Gehrig’s disease), paralyzed, unable to speak, and had only three fingers on his hands to move. From 1979 to 2009, Lucas Professor of Mathematics, his main research areas are cosmology and black holes, proving the singularity theorem of general relativity and the area theorem of black holes, proposing the theory of black hole evaporation and the boundaryless Hawking cosmological model, and taking an important step in unifying the two basic theories of physics in the 20th century, Einstein’s theory of relativity and Planck’s quantum mechanics. He has received honors such as CH (British Honorary Lord), CBE (Commander of the Order of the British Empire), FRS (Fellow of the Royal Society), FRSA (Fellow of the Royal Society of Arts).</p><p>​      In the 21st episode of the fifth season of the hit American drama “The Big Bang Theory” broadcast on April 6, 2012, Stephen Hawking starred in a cameo. In 2017, he recorded the documentary “Exploring the New Earth” for the British BBC. [1] In November of the same year, Hawking said that technology is expected to reverse some of the harm caused by industrialization to the planet and help eradicate disease and poverty, but artificial intelligence needs to be controlled [2] , and predicted that the earth may become a “fireball” in 2600 years when energy consumption increases.</p><p>​     On March 14, 2018, Hawking passed away at the age of 76. After Hawking’s death, it caused mourning from all walks of life around the world.</p><p>​    The legend of his life is really memorable and fascinating</p>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="杂谈" scheme="https://kalyan-zitiu.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="English" scheme="https://kalyan-zitiu.github.io/tags/English/"/>
    
  </entry>
  
</feed>
