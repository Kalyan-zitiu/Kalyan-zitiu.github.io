<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kalyan的小书房</title>
  <icon>https://www.gravatar.com/avatar/26add54e467101c6779c59a0ed4ee504</icon>
  <subtitle>Kalyan is working hard</subtitle>
  <link href="https://kalyan-zitiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://kalyan-zitiu.github.io/"/>
  <updated>2024-07-24T08:28:41.582Z</updated>
  <id>https://kalyan-zitiu.github.io/</id>
  
  <author>
    <name>Kalyan</name>
    <email>3148862192@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排错杂记（pod error）</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/24/%E6%8E%92%E9%9A%9C%E6%97%A5%E5%BF%97%EF%BC%88updating%EF%BC%89/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/24/%E6%8E%92%E9%9A%9C%E6%97%A5%E5%BF%97%EF%BC%88updating%EF%BC%89/</id>
    <published>2024-07-24T02:44:28.000Z</published>
    <updated>2024-07-24T08:28:41.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="尝试排错"><a href="#尝试排错" class="headerlink" title="尝试排错"></a>尝试排错</h3><p>起因是拉起某个pod的时候持续不断的错误边拉边寄，显示的不是image问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104653156.png" alt="image-20240724104653156"></p><p>尝试describe一下，发现调度，拉取，创建，启动似乎都正常</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104802500.png" alt="image-20240724104802500"></p><p>这个时候就得去看日志kubectl log一下，</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104835975.png" alt="image-20240724104835975"></p><p>？？？timeout？？？kubectl 正常能get不至于访问不到api，api是包正常的。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104918625.png" alt="image-20240724104918625"></p><p>那就是网络问题，先看一下插件，插件也正常。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105000612.png" alt="image-20240724105000612"></p><p>再看DNS，似乎有点问题，丢了master3的conredns？？？</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105033529.png" alt="image-20240724105033529"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105351232.png" alt="image-20240724105351232"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105355465.png" alt="image-20240724105355465"></p><p>但是查询后这个pod的是属于master1的pod所以不是dns的问题，缺一个的问题后面再解决。<br>按着尝试手动再吃连接api服务器,草pod fail了，所以用不了，先标记</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it kcollie-pre-hook-install-crds-bdb4g -n kcollie-system -- /bin/sh</span><br><span class="line">curl -k https://10.233.0.1:433</span><br></pre></td></tr></table></figure><p>再check一下kube-system的pod</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724110135451.png" alt="image-20240724110135451"></p><p>md草了，有屎啊，节点二怎么就timeout了，相继的节点一三也爆屎了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724111053894.png" alt="image-20240724111053894"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724111922571.png" alt="image-20240724111922571"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724112010432.png" alt="image-20240724112010432"></p><p>看一下节点情况，感觉可以rollout整个kube-system，完蛋，怎么查个pod状态，查到整个kube崩了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724112656575.png" alt="image-20240724112656575"></p><p>直接rollout所有</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启所有 Deployments</span></span><br><span class="line"><span class="keyword">for</span> deployment <span class="keyword">in</span> $(kubectl get deployments -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart deployment <span class="variable">$deployment</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 StatefulSets</span></span><br><span class="line"><span class="keyword">for</span> statefulset <span class="keyword">in</span> $(kubectl get statefulsets -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart statefulset <span class="variable">$statefulset</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 DaemonSets</span></span><br><span class="line"><span class="keyword">for</span> daemonset <span class="keyword">in</span> $(kubectl get daemonsets -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart daemonset <span class="variable">$daemonset</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总算是起来了，然后有一个node还是not ready，估计是node3的某些pod还没好，但是报错还是</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724125055556.png" alt="image-20240724125055556"></p><p>不懂，node1的apiserver明明好好的，coredns也没问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724130355768.png" alt="image-20240724130355768"></p><p>又死了，草啊啊啊啊啊啊啊啊啊啊。节点不知道为什么十分的不稳定，似乎不断崩溃重启，直接停机加内存。</p><p>估计上面的Error是不怎么影响的。。。。。。。。重启然后就没事了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;尝试排错&quot;&gt;&lt;a href=&quot;#尝试排错&quot; class=&quot;headerlink&quot; title=&quot;尝试排错&quot;&gt;&lt;/a&gt;尝试排错&lt;/h3&gt;&lt;p&gt;起因是拉起某个pod的时候持续不断的错误边拉边寄，显示的不是image问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    <category term="杂记" scheme="https://kalyan-zitiu.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="https://kalyan-zitiu.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kind基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/24/Kind/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/24/Kind/</id>
    <published>2024-07-24T01:58:31.000Z</published>
    <updated>2024-07-24T08:22:58.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KIND（Kubernetes-IN-Docker）"><a href="#KIND（Kubernetes-IN-Docker）" class="headerlink" title="KIND（Kubernetes IN Docker）"></a>KIND（Kubernetes IN Docker）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>KIND，全称“Kubernetes IN Docker”，是一个开源工具，用于在本地开发和测试 Kubernetes 集群。KIND 允许在 Docker 容器中运行 Kubernetes 集群，从而便于开发者快速创建和销毁 Kubernetes 集群，提升开发效率。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>在使用 KIND 之前，你需要确保以下软件已经正确安装：<br>Docker<br>kubectl<br>确保 Docker 已经启动，并且你的用户在 docker 组中，以便能够运行 Docker 命令而无需 sudo。</p><h4 id="安装-KIND"><a href="#安装-KIND" class="headerlink" title="安装 KIND"></a>安装 KIND</h4><p>在 Linux 环境中，可以通过以下命令获取和安装 KIND：</p><p>curl -Lo ./kind <a href="https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64">https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64</a><br>chmod +x ./kind<br>sudo mv ./kind /usr/local/bin/kind</p><h4 id="检查安装"><a href="#检查安装" class="headerlink" title="检查安装"></a>检查安装</h4><p>验证 KIND 是否安装成功：</p><p>kind –version<br>你应该看到类似 kind v0.11.1 的输出。</p><h3 id="创建-Kubernetes-集群"><a href="#创建-Kubernetes-集群" class="headerlink" title="创建 Kubernetes 集群"></a>创建 Kubernetes 集群</h3><h4 id="简单创建一个集群"><a href="#简单创建一个集群" class="headerlink" title="简单创建一个集群"></a>简单创建一个集群</h4><p>使用以下命令创建一个默认的 Kubernetes 集群：</p><p>kind create cluster<br>成功创建后，你会看到与集群相关的信息输出。</p><h4 id="自定义配置创建集群"><a href="#自定义配置创建集群" class="headerlink" title="自定义配置创建集群"></a>自定义配置创建集群</h4><p>为了更具定制化，可以使用 YAML 文件：</p><p>创建 kind-config.yaml 文件：</p><p>kind: Cluster<br>apiVersion: kind.x-k8s.io/v1alpha4<br>nodes:</p><ul><li>role: control-plane</li><li>role: worker</li><li>role: worker<br>使用以下命令创建集群：</li></ul><p>kind create cluster –config kind-config.yaml</p><h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><p>验证集群状态：</p><p>kubectl cluster-info –context kind-kind</p><h3 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h3><h4 id="部署应用到-KIND-集群"><a href="#部署应用到-KIND-集群" class="headerlink" title="部署应用到 KIND 集群"></a>部署应用到 KIND 集群</h4><p>创建一个名为 nginx-deployment.yaml 的文件：</p><p>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nginx-deployment<br>spec:<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx:1.14.2<br>        ports:<br>        - containerPort: 80<br>使用 kubectl 部署：</p><p>kubectl apply -f nginx-deployment.yaml</p><h4 id="验证部署"><a href="#验证部署" class="headerlink" title="验证部署"></a>验证部署</h4><p>查看部署的状态：</p><p>kubectl get deployments<br>查看 Pods 状态：</p><p>kubectl get pods</p><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><p>创建一个名为 nginx-service.yaml 的文件：</p><p>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: nginx-service<br>spec:<br>  selector:<br>    app: nginx<br>  ports:</p><ul><li>protocol: TCP<br>port: 80<br>targetPort: 80<br>type: LoadBalancer<br>使用 kubectl 暴露服务：</li></ul><p>kubectl apply -f nginx-service.yaml</p><h3 id="KIND的应用场景和作用"><a href="#KIND的应用场景和作用" class="headerlink" title="KIND的应用场景和作用"></a>KIND的应用场景和作用</h3><h4 id="开发和测试环境"><a href="#开发和测试环境" class="headerlink" title="开发和测试环境"></a>开发和测试环境</h4><p>在本地开发和测试 Kubernetes 应用，KIND 的特性让开发者可以快速创建和删除集群，大大提高了开发效率。</p><h4 id="CI-CD管道"><a href="#CI-CD管道" class="headerlink" title="CI/CD管道"></a>CI/CD管道</h4><p>在 CI/CD 管道中，KIND 可以在每次代码变更时快速创建一个新的 Kubernetes 集群用于测试，确保代码的稳定性和一致性。</p><h4 id="学习和培训"><a href="#学习和培训" class="headerlink" title="学习和培训"></a>学习和培训</h4><p>KIND 非常适合用于学习和培训，可以在本地快速搭建 Kubernetes 环境，使学习者掌握 Kubernetes 基本操作和概念。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>KIND 是基于 Docker 容器的，因此某些 Kubernetes 高级功能可能不完全支持。<br>偶尔你可能需要手动清理 Docker 容器和网络设置，特别是在多次创建和删除集群后。<br>不建议在生产环境中使用 KIND，它更适用于开发和测试用途。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>KIND 是一个非常方便的工具，可以帮助我们在本地快速搭建和管理 Kubernetes 集群。无论是开发测试、CI/CD 还是学习培训，KIND 都能发挥其巨大的作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KIND（Kubernetes-IN-Docker）&quot;&gt;&lt;a href=&quot;#KIND（Kubernetes-IN-Docker）&quot; class=&quot;headerlink&quot; title=&quot;KIND（Kubernetes IN Docker）&quot;&gt;&lt;/a&gt;KIND（Kub</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/</id>
    <published>2024-07-23T08:10:02.000Z</published>
    <updated>2024-07-23T08:10:28.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>一个开源的监控和告警系统</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="多维数据模型"><a href="#多维数据模型" class="headerlink" title="多维数据模型"></a>多维数据模型</h4><ul><li>使用时间序列数据，每个序列有一个度量指标（metricname）和一组键值对（labels）标识，这样可以灵活对同一类进行细分。<h5 id="度量指标"><a href="#度量指标" class="headerlink" title="度量指标"></a>度量指标</h5></li><li>counter：计数器，用于记录累计值，例如请求次数。</li><li>gauge：测量值，可增可减，例如当前内存使用量。</li><li>histogram：直方图，用于记录值分布，例如请求延迟。</li><li>summary：摘要，用于统计分位数和总和，例如响应时间的分位数。</li></ul><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ul><li>一组键值对，用于对时间序列进行细分和区分。例如，监控一个 HTTP 请求的计数器可以通过标签区分不同的请求路径和状态码</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;200&quot;</span>&#125;</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;500&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们有一个 Web 服务，它记录了每个请求的数量和响应时间。我们可以定义以下指标：</p><ol><li>记录请求数量的计数器：<ul><li>Metric Name: <code>http_requests_total</code></li><li>Labels: <code>method</code>, <code>handler</code>, <code>status</code></li></ul></li><li>记录响应时间的直方图：<ul><li>Metric Name: <code>http_request_duration_seconds</code></li><li>Labels: <code>method</code>, <code>handler</code></li></ul></li></ol><p>每次有新的请求进来，计数器和直方图都会更新。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;200&quot;</span>&#125; 1234</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;500&quot;</span>&#125; 56</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.1&quot;</span>&#125; 5</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.5&quot;</span>&#125; 50</span><br></pre></td></tr></table></figure><h4 id="支持PromQL"><a href="#支持PromQL" class="headerlink" title="支持PromQL"></a>支持PromQL</h4><p>查询所有 POST 请求的数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;method=&quot;POST&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询 <code>/api/v1</code> 接口的所有请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;handler=&quot;/api/v1&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询状态码为 200 的请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;status=&quot;200&quot;&#125;)</span><br></pre></td></tr></table></figure><h5 id="优化使用标签"><a href="#优化使用标签" class="headerlink" title="优化使用标签"></a>优化使用标签</h5><ul><li><strong>标签数目不要过多</strong>：过多的标签会导致时间序列爆炸，影响性能。</li><li><strong>标签值尽量稳定</strong>：标签值变化太频繁会增加存储和查询负担。</li><li><strong>合理设计标签</strong>：确保标签的选择能够满足查询需求，同时不过度细化。</li></ul><h4 id="时间序列数据库"><a href="#时间序列数据库" class="headerlink" title="时间序列数据库"></a>时间序列数据库</h4><h5 id="TSDB-Prometheus自带时序数据库"><a href="#TSDB-Prometheus自带时序数据库" class="headerlink" title="TSDB Prometheus自带时序数据库"></a>TSDB Prometheus自带时序数据库</h5><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><p>高效写入：Prometheus 的 TSDB 能够每秒写入数百万个样本，适合高频数据采集。<br>高效查询：针对时间序列数据优化的查询性能。<br>数据压缩：使用差分编码和 Gorilla 压缩算法减少存储空间。<br>局部存储：数据默认存储在本地磁盘上，可以通过远程存储扩展。</p><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>样本 (Sample)：包含一个时间戳和一个值。<br>时间序列 (Time Series)：由一个度量名和一组标签唯一标识的一组样本。<br>块 (Block)：TSDB 中的数据以块的形式存储，每个块通常覆盖 2 小时的数据。<br>WAL (Write-Ahead Log)：在写入到块之前，数据先写入 WAL，以确保数据持久化。</p><h6 id="数据存储和管理"><a href="#数据存储和管理" class="headerlink" title="数据存储和管理"></a>数据存储和管理</h6><ol><li>数据存储路径：默认存储路径为 /var/lib/prometheus，可以在 Prometheus 配置文件中通过 storage.tsdb.path 参数修改。</li><li>数据保留策略：默认保留 15 天的数据，可以通过 –storage.tsdb.retention.time 参数设置。</li><li>数据压缩和删除：Prometheus 会自动压缩和删除过期数据。<h4 id="独立抓取模型："><a href="#独立抓取模型：" class="headerlink" title="独立抓取模型："></a>独立抓取模型：</h4></li></ol><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol><li><strong>Scrape</strong>：Prometheus 从目标处获取监控数据的过程。</li><li><strong>Target</strong>：被监控的对象，可以是服务器、应用程序、数据库等。</li><li><strong>Job</strong>：一组相似目标的集合。</li><li><strong>Exporter</strong>：用于将目标的数据暴露给 Prometheus 的组件，通常是 HTTP 端点</li></ol><h5 id="配置文件’prometheus-yml’"><a href="#配置文件’prometheus-yml’" class="headerlink" title="配置文件’prometheus.yml’"></a>配置文件’prometheus.yml’</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s     <span class="comment"># 每15秒抓取一次数据</span></span><br><span class="line">  evaluation_interval: 15s <span class="comment"># 每15秒评估一次规则</span></span><br></pre></td></tr></table></figure><h6 id="抓取配置"><a href="#抓取配置" class="headerlink" title="抓取配置"></a>抓取配置</h6><p>抓取配置定义了 Prometheus 如何发现和抓取目标数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br></pre></td></tr></table></figure><h6 id="动态服务发现"><a href="#动态服务发现" class="headerlink" title="动态服务发现"></a>动态服务发现</h6><p>Prometheus 支持多种服务发现机制，允许动态发现目标。例如，可以使用 Kubernetes、Consul、Etcd 等进行服务发现。</p><p>####### Exporter<br>Exporter 是将监控数据暴露给 Prometheus 的组件，不同的应用和系统有不同的 Exporter。例如：</p><ul><li>Node Exporter：用于监控操作系统的资源使用情况。</li><li>Blackbox Exporter：用于进行探测和检查（如 HTTP、HTTPS、TCP）。</li><li>MySQL Exporter：用于监控 MySQL 数据库。</li></ul><h4 id="多种数据支持："><a href="#多种数据支持：" class="headerlink" title="多种数据支持："></a>多种数据支持：</h4><p>支持包括通过导出器（exporters）收集第三方系统的数据，支持服务发现（Service Discovery），如 Kubernetes、Consul、Etcd 等</p><h4 id="告警："><a href="#告警：" class="headerlink" title="告警："></a>告警：</h4><p>内置了 Alertmanager，用于处理告警通知和管理告警规则。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol><li>Prometheus Server：<br>存储：使用基于时间序列数据库（TSDB）的本地存储来存储监控数据。<br>抓取（Scrape）：定期从目标端点（如应用程序、数据库等）拉取指标数据。<br>PromQL 查询引擎：允许用户通过 PromQL 查询存储的数据。</li><li>数据导出器（Exporters）：<br>节点导出器（Node Exporter）：收集系统级别的指标，如 CPU、内存、磁盘使用等。<br>应用程序导出器：如 MySQL Exporter、Redis Exporter，专门用于从特定应用中收集指标。</li><li>服务发现（Service Discovery）：<br>支持多种服务发现机制，如 Kubernetes、Consul、DNS 等，自动发现并监控动态变化的服务和主机。</li><li>Alertmanager：<br>告警规则：定义告警规则，当满足条件时触发告警。<br>告警通知：管理告警的路由和发送，支持多种通知方式，如电子邮件、Slack、PagerDuty 等。<br>告警抑制和分组：可以配置告警抑制规则和告警分组，避免告警风暴。</li><li>Pushgateway：<br>用于接收临时性任务（如批处理任务）的指标数据，这些任务无法被 Prometheus 定期拉取。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>配置和服务发现：通过配置文件或服务发现机制，Prometheus 确定需要监控的目标。</li><li>抓取数据：Prometheus 定期从目标端点拉取指标数据。</li><li>存储数据：将拉取到的指标数据存储在本地的时间序列数据库中。</li><li>查询和可视化：通过 PromQL 查询数据，结合 Grafana 等可视化工具展示监控结果。</li><li>告警处理：根据定义的告警规则，Prometheus 触发告警并通过 Alertmanager 发送通知。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prometheus&quot;&gt;&lt;a href=&quot;#Prometheus&quot; class=&quot;headerlink&quot; title=&quot;Prometheus&quot;&gt;&lt;/a&gt;Prometheus&lt;/h2&gt;&lt;p&gt;一个开源的监控和告警系统&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://kalyan-zitiu.github.io/categories/kubernetes/"/>
    
    
    <category term="Prometheus" scheme="https://kalyan-zitiu.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>简单ansible操作</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/</id>
    <published>2024-07-22T06:59:35.000Z</published>
    <updated>2024-07-22T07:00:01.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><p>用于配置管理、应用程序部署、任务自动化</p><h3 id="ansible主机清单"><a href="#ansible主机清单" class="headerlink" title="ansible主机清单"></a>ansible主机清单</h3><h4 id="定义组"><a href="#定义组" class="headerlink" title="定义组"></a>定义组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[webservers] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dbserver] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dce5_nodes]</span><br><span class="line">10.70.49.17[2:4]</span><br><span class="line"></span><br><span class="line">[all:vars] <span class="comment"># 定义全局变量适用于全部主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 用户名，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_user: guest2admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 密码，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_pass: @<span class="built_in">users</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible 使用的 Python 解释器路径</span></span><br><span class="line">ansible_python_interpreter: /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接的通用参数，这里指定了加密算法为 AES-256-CBC</span></span><br><span class="line">ansible_ssh_common_args: -c aes256-cbc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Ansible 连接到主机的方式，这里使用 SSH</span></span><br><span class="line">ansible_connection: ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权操作时使用的密码（例如切换到 root 用户时的密码）</span></span><br><span class="line">ansible_become_password: root@root@su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权方法，这里使用 su 命令切换用户</span></span><br><span class="line">ansible_become_method: su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权执行命令，这里指定了使用 sudo su - 命令来切换到超级用户</span></span><br><span class="line">ansible_become_exe: sudo su -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以组别变量</span></span><br><span class="line">[webserver:vars]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h3><ol><li><p><strong>Ping 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><p>通过 Ping 模块测试所有主机是否可达。</p></li><li><p><strong>Shell 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;uptime&#x27;</span></span><br></pre></td></tr></table></figure><p>在所有主机上执行 <code>uptime</code> 命令。</p></li><li><p><strong>Command 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&#x27;ls /tmp&#x27;</span></span><br></pre></td></tr></table></figure><p>使用 <code>command</code> 模块列出 <code>/tmp</code> 目录下的文件。</p></li><li><p><strong>Copy 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">&#x27;src=/path/to/source dest=/path/to/destination&#x27;</span></span><br></pre></td></tr></table></figure><p>将本地文件复制到远程主机。</p></li><li><p><strong>File 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m file -a <span class="string">&#x27;path=/tmp/testfile state=touch&#x27;</span></span><br></pre></td></tr></table></figure><p>在远程主机上创建一个空文件。</p></li><li><p><strong>Service 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m service -a <span class="string">&#x27;name=httpd state=started&#x27;</span></span><br></pre></td></tr></table></figure><p>启动所有主机上的 httpd 服务。</p></li><li><p><strong>User 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m user -a <span class="string">&#x27;name=johndoe state=present&#x27;</span></span><br></pre></td></tr></table></figure><p>创建一个名为 <code>johndoe</code> 的用户。</p></li></ol><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-i &lt;inventory&gt;</code>：指定主机清单文件。例如 <code>-i hosts</code>。</li><li><code>--list-hosts</code>：列出将运行任务的主机。</li><li><code>-l &lt;subset&gt;</code>：指定要执行任务的主机子集。例如 <code>-l webservers</code>。</li><li><code>-u &lt;user&gt;</code>：指定远程主机用户。例如 <code>-u root</code>。</li><li><code>-k</code>：提示输入 SSH 密码。</li><li><code>--ask-become-pass</code>：提示输入 sudo 密码。</li><li><code>-e &lt;extra_vars&gt;</code>：传递额外变量。例如 <code>-e &quot;var1=value1 var2=value2&quot;</code>。</li></ul><h3 id="示例详解"><a href="#示例详解" class="headerlink" title="示例详解"></a>示例详解</h3><ol><li><p><strong>列出主机</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all --list-hosts</span><br></pre></td></tr></table></figure><p>列出所有在清单中的主机。</p></li><li><p><strong>指定用户和密码执行命令</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;df -h&#x27;</span> -u root -k</span><br></pre></td></tr></table></figure><p>使用 root 用户执行 <code>df -h</code> 命令，并提示输入密码。</p></li><li><p><strong>传递额外变量</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;echo &#123;&#123; var_name &#125;&#125;&#x27;</span> -e <span class="string">&#x27;var_name=HelloWorld&#x27;</span></span><br></pre></td></tr></table></figure><p>传递变量 <code>var_name</code>，并在命令中使用。</p></li></ol><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ol><li><p><strong>使用标签</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;systemctl restart httpd&#x27;</span> --tags <span class="string">&quot;restart&quot;</span></span><br></pre></td></tr></table></figure><p>使用标签来组织和执行特定的任务。</p></li><li><p><strong>检查主机连通性</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping -i inventory/hosts</span><br></pre></td></tr></table></figure><p>使用指定的主机清单文件检查连通性。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h2&gt;&lt;p&gt;用于配置管理、应用程序部署、任务自动化&lt;/p&gt;
&lt;h3 id=&quot;ansible主机清单&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="ansible" scheme="https://kalyan-zitiu.github.io/categories/ansible/"/>
    
    
    <category term="ansible" scheme="https://kalyan-zitiu.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes服务网格</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</id>
    <published>2024-07-22T03:31:12.000Z</published>
    <updated>2024-07-22T03:35:22.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kubernetes服务网格"><a href="#kubernetes服务网格" class="headerlink" title="kubernetes服务网格"></a>kubernetes服务网格</h2><p>是一种架构，为了解决服务和服务之间的通信。</p><h3 id="服务网格接口（打算理解）"><a href="#服务网格接口（打算理解）" class="headerlink" title="服务网格接口（打算理解）"></a>服务网格接口（打算理解）</h3><h4 id="SMI"><a href="#SMI" class="headerlink" title="SMI"></a>SMI</h4><p>  用于定义服务网格标准化接口的规范，旨在提供一个通用的接口，让不同的服务网格实现可以互操作。SMI的主要目的是简化服务网格的使用和集成，使用户可以使用统一的API管理不同的服务网格实现，如Istio、Linkerd、Consul Connect等。</p><h4 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h4><p>  是Kubernetes中的一种机制，用于扩展Kubernetes API，使用户可以定义自己的资源类型。通过CRD，用户可以创建自定义资源（CR），这些资源可以与Kubernetes内置资源（如Pod、Service）一样进行管理和操作。</p><h3 id="数据平面代理"><a href="#数据平面代理" class="headerlink" title="数据平面代理"></a>数据平面代理</h3><p>负责处理和管理服务间流量的代理组件。</p><p>核心职责:<br>流量转发：代理组件负责接收、转发和负载均衡服务之间的流量。这包括 HTTP、gRPC、TCP 等多种协议。<br>服务发现：代理可以自动发现 Kubernetes 中的服务，根据服务的配置进行相应的流量路由。<br>流量管理：包括流量控制、重试策略、断路器、故障注入等功能，以保证服务间通信的可靠性和稳定性。<br>安全：提供 mTLS（双向 TLS）加密来确保服务间通信的安全性，支持认证和授权策略。<br>监控和可观测性：代理会收集并上报各种流量指标和日志，帮助管理员监控和诊断服务间的通信问题。</p><h4 id="数据平面架构"><a href="#数据平面架构" class="headerlink" title="数据平面架构"></a>数据平面架构</h4><h5 id="代理附件"><a href="#代理附件" class="headerlink" title="代理附件"></a>代理附件</h5><p>一般部署在工作负载的pod上，后续会拦截进出服务的所有通信，但是在一些升级上，代理附件不能保证在不重建Pod的条件下进行升级</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112524609.png" alt="image-20240722112524609"></p><h5 id="代理节点"><a href="#代理节点" class="headerlink" title="代理节点"></a>代理节点</h5><p>由代理节点来处理运行服务的所有流量。但是会存在很大的网络瓶颈。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112926402.png" alt="image-20240722112926402"></p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>  一个高性能的开源边缘和服务代理，主要用于微服务架构中的通信管理</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722102428515.png" alt="image-20240722102428515"></p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><h6 id="API网关："><a href="#API网关：" class="headerlink" title="API网关："></a>API网关：</h6><p>Envoy可以作为API网关，处理外部请求并将其路由到内部服务，同时提供认证、限流、缓存等功能。</p><h6 id="边车代理："><a href="#边车代理：" class="headerlink" title="边车代理："></a>边车代理：</h6><ul><li>是一种设计模式，在这种模式下，一个代理程序（如Envoy）被部署在每个服务实例的旁边，这样每个服务实例都有一个独立的代理来处理进出流量。</li><li>在服务网格架构中，Envoy通常以边车代理的形式部署在每个服务实例旁，拦截和处理所有入站和出站流量。</li><li>边车注入是将边车代理自动注入到服务实例的Pod中，以便在微服务架构中实现服务网格功能的过程。分为手动与自动，自动注入似乎能够用istio来进行自动注入。</li><li>Sidecar 模式：Envoy 通常以 sidecar 容器的形式部署在每个微服务 Pod 内，与应用容器共享网络命名空间。所有进出微服务的流量都会通过 Envoy 代理。</li></ul><h6 id="中介层代理："><a href="#中介层代理：" class="headerlink" title="中介层代理："></a>中介层代理：</h6><p>Envoy可以部署在不同的服务层之间，作为中介层代理，处理跨服务的流量和策略管理。</p><h5 id="模块化架构"><a href="#模块化架构" class="headerlink" title="模块化架构"></a>模块化架构</h5><p>Listener：<br>作用：Listener是Envoy用于监听网络端口的组件，负责接受客户端的连接请求。每个Listener都绑定到一个特定的IP地址和端口，并根据配置将流量传递给相应的处理模块。<br>配置：Listener的配置包括监听的地址和端口、使用的协议（如HTTP、TCP）、以及关联的过滤器链。</p><p>Filter：<br>作用：Filter是Envoy用于处理请求和响应的中间处理模块。Filter可以用于修改请求、添加日志、执行身份验证、路由选择等。Envoy的Filter分为多种类型，包括网络过滤器、HTTP过滤器和TCP过滤器。<br>类型：<br>网络过滤器：处理TCP连接层面的流量，如TLS终止、连接限速等。<br>HTTP过滤器：处理HTTP请求和响应，如修改头部信息、执行认证和授权、负载均衡等。<br>TCP过滤器：处理TCP层流量，如TCP代理、流量镜像等。</p><p>Cluster：<br>作用：Cluster是Envoy用于表示一组上游服务实例的组件。Cluster负责服务发现、负载均衡、健康检查等。每个Cluster包含多个主机（即上游服务实例），并定义了如何将流量分配到这些主机上。<br>配置：Cluster的配置包括服务发现类型（静态、DNS、EDS等）、负载均衡策略（如轮询、随机、加权轮询等）、健康检查配置等。</p><p>Route：<br>作用：Route组件定义了Envoy如何将请求路由到不同的Cluster。Route规则基于请求的属性（如路径、头部信息、方法等）来决定具体的路由目标。<br>配置：Route的配置包括匹配规则、路由目标Cluster、重试策略、超时设置等。</p><p>Admin：<br>作用：Admin组件提供了管理和监控Envoy的接口。通过Admin接口，用户可以查看Envoy的运行状态、统计信息、配置详情，并进行管理操作。<br>配置：Admin接口通常通过HTTP API暴露，可以在Envoy配置中指定Admin的监听地址和端口。</p><h5 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h5><p>配置管理<br>Envoy的配置管理可以通过静态文件配置，也可以通过动态配置API（xDS）实现。xDS（Envoy Dynamic Configuration API）包括以下几个部分：<br>ADS（Aggregated Discovery Service）：聚合配置服务，统一管理其他xDS服务。<br>CDS（Cluster Discovery Service）：动态管理Cluster的配置。<br>EDS（Endpoint Discovery Service）：动态管理Cluster中上游服务实例的配置。<br>LDS（Listener Discovery Service）：动态管理Listener的配置。<br>RDS（Route Discovery Service）：动态管理路由配置。<br>SDS（Secret Discovery Service）：动态管理密钥和证书。</p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>负责管理和协调数据平面代理</p><p>配置管理：提供统一的配置接口，管理服务网格中所有代理的配置，包括路由规则、负载均衡策略、故障恢复策略等。<br>服务发现：集成服务发现机制，实时感知集群中服务的变化，并通知数据平面代理更新其配置。<br>安全管理：实现服务间的认证和授权，管理 TLS 证书的分发和轮换，确保服务间通信的安全性。<br>流量管理：提供流量路由、灰度发布、A/B 测试等高级流量控制功能，帮助开发和运维人员灵活管理服务间的流量。<br>可观测性：收集和聚合数据平面代理的监控指标、日志和分布式追踪数据，提供全局的可观测性视图，帮助排查和诊断问题。</p><h4 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h4><p>istiod为基于envoy的服务网络提供控制平面，他包括三个核心组件，Galley，Pilot，Citidel</p><p>Pilot：一个Envoy的配置服务器，实现 xDS API，并将配置流向与应用程序一起运行的Envoy代理。</p><p>Citadel：负责网格内的证书管理，建立服务器身份和相互TLS。</p><p>Galley：与外部系统互动，Kubernetes等。</p><h4 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h4><p>用于在 Kubernetes 集群中实现动态配置和策略控制的关键组件。 Istio 中的主要用途包括服务网格控制、资源变更管理和策略执行等。</p><ul><li>自动注入 Sidecar 容器:Istio 使用一个变异（Mutating）Webhook 自动将 Envoy 代理（Sidecar）注入到新创建的 Kubernetes Pod 中。这个过程确保每个服务都能被 Istio 管理和监控。当你为集群启用了自动注入，Webhook 会拦截 Pod 创建请求，在 Pod 完成调度之前往其定义中添加 Envoy 容器以及必要的配置信息。</li><li>配置验证（Validating Webhook）:验证（Validating）Webhook 用于在新的 Istio 配置资源（如 VirtualService、DestinationRule 等）创建或更新时执行验证过程，确保这些配置符合要求，避免因错误配置导致服务故障。这个 Webhook 会在配置提交到 etcd 之前进行执行，起到一个“守门人”的作用，阻止不符合标准的配置生效。</li><li>动态配置和策略控制:Webhook 还可以用于执行动态配置和策略决策。例如，通过 Webhook，可以向运行时注入配置参数或更新策略以应对瞬时需求或安全要求。</li></ul><h4 id="通过iptable达到工作负载通过Envoy发送流量。"><a href="#通过iptable达到工作负载通过Envoy发送流量。" class="headerlink" title="通过iptable达到工作负载通过Envoy发送流量。"></a>通过iptable达到工作负载通过Envoy发送流量。</h4><p>Istio的iptables规则是通过init-containner来进行安装，拦截pod网络流量路由到Envoy。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722111557580.png" alt="image-20240722111557580"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="string">”argS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">istio-iptables</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--envoy-port</span> <span class="comment">#捕获出站的所有流量，并且发送到Envoy这个端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15001&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--inbound-capture-port</span> <span class="comment">#捕获入站的所有流量，并且发送Envoy这个端口1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15006&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--proxy-uid</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;1337”</span></span><br><span class="line"><span class="string">- --istio-inbound-interception-mode</span></span><br><span class="line"><span class="string">- REDIRECT</span></span><br><span class="line"><span class="string">--istio-service-cidr </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">--istio-inbound-ports </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">- --istio-local-exclude-ports</span></span><br><span class="line"><span class="string">- 15090,15021,15020</span></span><br><span class="line"><span class="string">image: docker.io/istio/proxyv2:1.6.7</span></span><br><span class="line"><span class="string">imagePullPolicy: Always</span></span><br><span class="line"><span class="string">name: istio-init</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kubernetes服务网格&quot;&gt;&lt;a href=&quot;#kubernetes服务网格&quot; class=&quot;headerlink&quot; title=&quot;kubernetes服务网格&quot;&gt;&lt;/a&gt;kubernetes服务网格&lt;/h2&gt;&lt;p&gt;是一种架构，为了解决服务和服务之间的通信。&lt;</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes ingress基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/19/Kubernetes_ingress/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/19/Kubernetes_ingress/</id>
    <published>2024-07-19T01:21:03.000Z</published>
    <updated>2024-07-19T08:02:55.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><p>  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，可以简单的理解为一个外包，现在在互联网上很多的流量都使用了TLS/SSL协议继续加密，但是这也会增加服务器的负担，因此SSL终止可以理解成<code>外包</code>一个机器处理这个问题。一般这个外包工作会给到负载均衡器和反向代理。</p><h3 id="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"><a href="#为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？" class="headerlink" title="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"></a>为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？</h3><ul><li>好像就是因为service不够用:dog:所以才有了ingress的存在，而且似乎ingress在处理HTTP和HTTPS流量的能力上十分出色。</li><li>除此之外ingress跳脱到应用层进行负载和流量路由的功能，大大减少统一访问策略和路由规则:boom:</li><li>而且ingress似乎为每一个集群提供了单一入口，流量能够精准投送。:fish:</li></ul><h3 id="ingress-配置冲突"><a href="#ingress-配置冲突" class="headerlink" title="ingress 配置冲突"></a>ingress 配置冲突</h3><p>不同团队或租户尝试使用相同的域名来暴露他们的应用程序时，可能会发生的问题。简单来说，就是两个团队都想用同一个域名，比如<code>app.bearcanoe.com</code>，来让外界访问他们的应用程序。这会导致冲突，因为Ingress控制器（管理这些网络流量的组件）不明确如何处理这种情况</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>准入控制器：在配置被应用到集群之前，验证并确保域名的唯一性。可以使用开放策略代理（OPA）来实现这个功能。</li><li>Contour Ingress 控制器：使用HTTPProxy自定义资源，创建一个根HTTPProxy资源，分配给特定团队。这种方法将域名管理集中化，避免冲突。</li></ol><h3 id="Ingress控制器"><a href="#Ingress控制器" class="headerlink" title="Ingress控制器"></a>Ingress控制器</h3><p>是用来实现Ingress资源定义的路由规则和流量管理的组件，以Pod的形式存在运行，负责解析Ingress资源，配置底层反向代理或负载均衡以处理HTTP和HTTPS流量 。</p><ol><li>解析 Ingress 资源：Ingress 控制器会监视 :eye: Kubernetes API，解析和处理定义在 Ingress 资源中的路由规则和配置。</li><li>配置反向代理/负载均衡器：根据解析到的 Ingress 规则，Ingress 控制器会动态配置底层的反向代理（如 NGINX、HAProxy）或云 :cloud: 提供商的负载均衡器（如 AWS ELB、GCP Load Balancer）。</li><li>管理外部访问：Ingress 控制器 :control_knobs: 负责将外部请求路由到集群内相应的服务，管理 HTTP/HTTPS 流量的转发、负载均衡以及 SSL/TLS 终止等功能。</li><li>支持高级特性：许多 Ingress 控制器支持高级功能，如基于 Cookie 的会话保持、限速、访问控制和基于 IP 的访问限制等。</li></ol><h3 id="流量模式"><a href="#流量模式" class="headerlink" title="流量模式"></a>流量模式</h3><h4 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h4><p>:question:什么是HTTP代理呢，想象一下你需要借一本书，但是这本书在一个封闭的空间内，你不能够直接自己拿到，这个时候你就需要一个中间人来帮你去借。这个时候这个中间人就可以理解成代理人。就是当客户进行一个HTTP请求，这个请求会通过代理服务器转发到目标服务器。反向代理也是这么理解，目标服务器的资源通过代理服务器传输出去。</p><p>:boy:ingress处理HTTP流量很简单，就是通过host头进行路由转发</p><h4 id="HTTPS代理"><a href="#HTTPS代理" class="headerlink" title="HTTPS代理"></a>HTTPS代理</h4><p>:question:HTTPS流量处理的有些特别，ingress在获取流量的时候进行SSL终止，然后建立新的HTTP请求进行转发。</p><p>但是特殊情况为了安全起见。ingress也会进行SSL终止之后再进行TLS加密与后端pod建立连接。</p><h4 id="OCI-3-4层代理"><a href="#OCI-3-4层代理" class="headerlink" title="OCI 3/4层代理"></a>OCI 3/4层代理</h4><p>:calendar:不懂往后点再研究…….</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="control-knobs-nginx-ingress-controller"><a href="#control-knobs-nginx-ingress-controller" class="headerlink" title=":control_knobs:nginx ingress controller"></a>:control_knobs:nginx ingress controller</h4><p>常用于HTTP和反向代理</p><ul><li>支持SSL/TLS终止</li><li>基于主机名和路径的路由</li><li>支持URL重写和重定向</li></ul><h4 id="control-knobs-Istio-ingress-Gateway"><a href="#control-knobs-Istio-ingress-Gateway" class="headerlink" title=":control_knobs:Istio ingress Gateway"></a>:control_knobs:Istio ingress Gateway</h4><p>Istio Ingress Gateway 是 Istio 服务网格中的一个组件，专门用于管理进入服务网格的外部 HTTP 和 HTTPS 流量。与传统的 Kubernetes Ingress 不同，Istio Ingress Gateway 提供了更多的高级流量管理和安全功能，如细粒度的流量控制、策略管理和监控。</p><h5 id="Istio-Ingress-Gateway-组件"><a href="#Istio-Ingress-Gateway-组件" class="headerlink" title="Istio Ingress Gateway 组件"></a>Istio Ingress Gateway 组件</h5><ol><li>:door: Gateway：定义哪些外部流量可以进入服务网格，以及如何路由这些流量。</li><li>VirtualService：定义流量的具体路由规则，可以包含多种匹配条件和路由行为。</li></ol><h4 id="control-knobs-HAProxy-Ingress"><a href="#control-knobs-HAProxy-Ingress" class="headerlink" title=":control_knobs: HAProxy Ingress"></a>:control_knobs: HAProxy Ingress</h4><p>高性能和高级路由功能，路由灵活，低延迟，负载均衡算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ingress&quot;&gt;&lt;a href=&quot;#ingress&quot; class=&quot;headerlink&quot; title=&quot;ingress&quot;&gt;&lt;/a&gt;ingress&lt;/h2&gt;&lt;p&gt;  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes服务基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-07-17T05:26:24.000Z</published>
    <updated>2024-07-17T07:34:53.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes服务基础"><a href="#Kubernetes服务基础" class="headerlink" title="Kubernetes服务基础"></a>Kubernetes服务基础</h1><h2 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl get svc &lt;svc-name&gt;</span><br><span class="line">kubectl describe svc &lt;svc-name&gt;</span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">kubectl expose deployment &lt;d-name&gt; --port&lt;port&gt; --target-port=&lt;target-port&gt;</span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">kubectl get endpoints &lt;svc-name&gt;：查看服务端点</span><br><span class="line">kubectl port-forward svc/&lt;svc-name&gt;&lt;local-port&gt;:&lt;svc-port&gt;:本地端口转发服务端口</span><br></pre></td></tr></table></figure><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h3><ul><li>ClusterIP: 分配一个集群内部的ip地址，使得服务只能集群内部访问</li><li>NodePort: 在每个节点上分配一个端口，是的可以外部访问服务</li><li>LoadBalancer: 使用负载均衡来暴露服务，让服务加入后端池</li><li>ExternalName: 通过返回的CNAME记录来映射另一个外部的DNS名称</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717132825010.png" alt="image-20240717132825010"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717145241179.png" alt="image-20240717145241179"></p><h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>用于定义一组Pod的逻辑集合，并且可以通过一个稳定的IP地址和端口进行访问。<code>ClusterIP</code>服务类型会在集群内部分配一个虚拟IP地址，这个IP地址只能在集群内部访问，不能从外部直接访问。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ClusterIP</code>类型的Service时，Kubernetes会为这个Service分配一个虚拟IP地址（Cluster IP）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>内部负载均衡</strong>: 当集群内的其他Pod或服务通过Cluster IP访问这个Service时，Kubernetes会自动将请求负载均衡到后端的Pod上。</li></ol><h5 id="yaml参考"><a href="#yaml参考" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: 855d96b0-c9e8-4ef2-afe5-bdb86e21adc3</span><br><span class="line">  resourceVersion: <span class="string">&#x27;194&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-12T07:36:07Z&#x27;</span></span><br><span class="line">  labels:</span><br><span class="line">    component: apiserver</span><br><span class="line">    provider: kubernetes</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: https</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 6443</span><br><span class="line">  clusterIP: 10.233.0.1</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.0.1</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>NodePort</code>类型的Service时，Kubernetes会在每个节点上分配一个端口（范围通常是30000-32767）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>节点端口（NodePort）</strong>: Kubernetes会在每个节点上开放一个指定的端口，并将这个端口的流量转发到Service的Cluster IP，然后再负载均衡到后端的Pod上。</li></ol><h4 id="yaml参考-1"><a href="#yaml参考-1" class="headerlink" title="yaml参考"></a>yaml参考</h4><h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>ps：这里的LoadBalancer和云上的不同，是为了解决nodeport不清晰问题。</p><h5 id="外部流量策略"><a href="#外部流量策略" class="headerlink" title="外部流量策略"></a>外部流量策略</h5><ol><li>cluster</li></ol><ul><li>把流量分配给所有集群中所有节点的可用实例上</li><li>能够做到全局分配和高利用，但是可能会造成比较高的延迟</li><li>场景：适合需要整体稳定可用的</li></ul><ol start="2"><li>local</li></ol><ul><li>优先把流量分给同一节点或同一区域的可用实例上</li><li>能够低延迟访问服务，本地优先</li><li>场景：适合游戏或者视频流媒体</li></ul><h5 id="yaml参考-2"><a href="#yaml参考-2" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: loadbalancer-01</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: c4093644-e423-4737-94e1-8fd92606933d</span><br><span class="line">  resourceVersion: <span class="string">&#x27;3774606&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-16T03:04:31Z&#x27;</span></span><br><span class="line">  annotations:</span><br><span class="line">    kpanda.io/alias-name: loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: tcp-loadbalaner</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 8081</span><br><span class="line">      targetPort: 8081</span><br><span class="line">      nodePort: 30683</span><br><span class="line">  selector:</span><br><span class="line">    app: baize-notebook-ssh</span><br><span class="line">  clusterIP: 10.233.59.228</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.59.228</span><br><span class="line">  <span class="built_in">type</span>: LoadBalancer</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  allocateLoadBalancerNodePorts: <span class="literal">true</span></span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h4><h5 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ExternalName</code>类型的Service时，你需要指定一个外部的DNS名称。</li><li><strong>DNS解析</strong>: Kubernetes的DNS服务会为这个Service创建一个CNAME记录，将Service名称解析为指定的外部DNS名称。</li><li><strong>访问外部服务</strong>: 集群内的Pod可以通过Service名称访问外部的服务，Kubernetes的DNS服务会将这个名称解析为外部的DNS名称</li></ol><h5 id="yaml参考-3"><a href="#yaml参考-3" class="headerlink" title="yaml参考"></a>yaml参考</h5><p>不许参考，懒得cv了都基本一样就其他字段和type不同。</p>]]></content>
    
    
    <summary type="html">了解服务以及服务网格的作用</summary>
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux文件</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/</id>
    <published>2024-07-10T03:47:16.000Z</published>
    <updated>2024-07-10T05:44:03.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h3><h4 id="1-lsof-List-Open-Files"><a href="#1-lsof-List-Open-Files" class="headerlink" title="1. lsof (List Open Files)"></a>1. lsof (List Open Files)</h4><p><code>lsof</code>命令用于列出当前系统中已打开的文件。它可以显示哪个进程正在使用哪个文件，并提供有关这些文件的详细信息。这个命令在排查文件占用、删除不成功或挂载卸载问题时非常有用。</p><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof [选项] [文件]</span><br></pre></td></tr></table></figure><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-u</code>：显示指定用户打开的文件。</li><li><code>-p</code>：显示指定进程ID打开的文件。</li><li><code>+D</code>：递归显示指定目录下的所有打开文件。</li><li><code>-i</code>：显示与网络相关的文件（例如端口使用情况）。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>列出所有打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>查看用户<code>user</code>打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u user</span><br></pre></td></tr></table></figure><p>显示进程ID为1234的进程打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure><h4 id="2-cp-Copy-Files"><a href="#2-cp-Copy-Files" class="headerlink" title="2. cp (Copy Files)"></a>2. cp (Copy Files)</h4><p><code>cp</code>命令用于复制文件和目录。</p><h5 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-r</code>：递归复制目录及其内容。</li><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时复制。</li><li><code>-p</code>：保留源文件的属性。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>复制文件<code>file1</code>到<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> file1 file2</span><br></pre></td></tr></table></figure><p>递归复制目录<code>dir1</code>到<code>dir2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r dir1 dir2</span><br></pre></td></tr></table></figure><h4 id="3-mv-Move-Rename-Files"><a href="#3-mv-Move-Rename-Files" class="headerlink" title="3. mv (Move/Rename Files)"></a>3. mv (Move/Rename Files)</h4><p><code>mv</code>命令用于移动或重命名文件和目录。</p><h5 id="基本语法：-2"><a href="#基本语法：-2" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时移动。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>重命名文件<code>file1</code>为<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 file2</span><br></pre></td></tr></table></figure><p>移动文件<code>file1</code>到目录<code>dir1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 dir1/</span><br></pre></td></tr></table></figure><h4 id="4-ln-Link-Files"><a href="#4-ln-Link-Files" class="headerlink" title="4. ln (Link Files)"></a>4. ln (Link Files)</h4><p><code>ln</code>命令用于创建硬链接或符号链接（软链接）。</p><h5 id="基本语法：-3"><a href="#基本语法：-3" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [选项] 目标文件 链接文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-s</code>：创建符号链接。</li><li><code>-f</code>：覆盖已有的链接文件。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><p>创建文件<code>file1</code>的硬链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><p>创建文件<code>file1</code>的符号链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file1 link1</span><br></pre></td></tr></table></figure><p>在Linux系统中，建立文件链接（Link）是非常有用的，它提供了多种文件管理和使用的灵活性。文件链接主要分为两种类型：硬链接（Hard Link）和符号链接（Symbolic Link，也称为软链接）。以下是建立链接的原因和它们的用途：</p><h5 id="硬链接（Hard-Link）"><a href="#硬链接（Hard-Link）" class="headerlink" title="硬链接（Hard Link）"></a>硬链接（Hard Link）</h5><p>硬链接是对文件的直接引用。每个硬链接都指向文件的相同物理数据块，因此它们是完全等价的。</p><h6 id="建立硬链接的原因："><a href="#建立硬链接的原因：" class="headerlink" title="建立硬链接的原因："></a>建立硬链接的原因：</h6><ol><li><strong>冗余与备份</strong>：硬链接允许在不同位置访问同一文件内容，可以在不同目录中保持文件的多个访问点，从而提高冗余度，避免文件意外删除。</li><li><strong>节省空间</strong>：硬链接不会占用额外的存储空间，因为它们只是指向同一个物理数据块。</li><li><strong>一致性</strong>：硬链接确保文件的多个实例始终保持同步。对其中一个硬链接的修改会影响所有其他硬链接，因为它们指向相同的数据块。</li></ol><h6 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><h5 id="符号链接（Symbolic-Link-Soft-Link）"><a href="#符号链接（Symbolic-Link-Soft-Link）" class="headerlink" title="符号链接（Symbolic Link / Soft Link）"></a>符号链接（Symbolic Link / Soft Link）</h5><p>符号链接是指向另一个文件路径的引用。它们类似于快捷方式，包含了目标文件或目录的路径。</p><h6 id="建立符号链接的原因："><a href="#建立符号链接的原因：" class="headerlink" title="建立符号链接的原因："></a>建立符号链接的原因：</h6><ol><li><strong>灵活性</strong>：符号链接可以跨文件系统边界创建，而硬链接只能在同一文件系统内使用。它们可以指向目录或文件。</li><li><strong>便捷访问</strong>：通过符号链接，用户可以创建对常用文件或目录的快捷访问点，简化路径的输入和操作。</li><li><strong>组织结构</strong>：符号链接可以帮助组织文件系统，使某些文件或目录在多个位置都能方便地访问，而不需要复制实际数据。</li><li><strong>共享资源</strong>：在多用户环境中，符号链接可以用于共享公共资源，例如库文件、配置文件等，而不必在每个用户目录中复制一份。</li></ol><h6 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/original /path/to/symlink</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux文件管理&quot;&gt;&lt;a href=&quot;#Linux文件管理&quot; class=&quot;headerlink&quot; title=&quot;Linux文件管理&quot;&gt;&lt;/a&gt;Linux文件管理&lt;/h3&gt;&lt;h4 id=&quot;1-lsof-List-Open-Files&quot;&gt;&lt;a href=&quot;#1-l</summary>
      
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="file" scheme="https://kalyan-zitiu.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux网络</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/</id>
    <published>2024-07-10T01:39:02.000Z</published>
    <updated>2024-07-10T03:39:24.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-tcpdump"><a href="#1-tcpdump" class="headerlink" title="1. tcpdump"></a>1. <code>tcpdump</code></h3><p><code>tcpdump</code> 是一个网络抓包工具，可以捕获并分析网络流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上的所有数据包。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.1</span><br></pre></td></tr></table></figure><p>捕获与特定主机 <code>192.168.1.1</code> 相关的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上所有通过端口 <code>80</code> 的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -w capture.pcap</span><br></pre></td></tr></table></figure><p>将捕获的数据包保存到文件 <code>capture.pcap</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r capture.pcap</span><br></pre></td></tr></table></figure><p>读取并分析 <code>capture.pcap</code> 文件中的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#x27;</span></span><br></pre></td></tr></table></figure><p>捕获所有带有 SYN 或 ACK 标志的 TCP 包。</p><h3 id="2-lsof"><a href="#2-lsof" class="headerlink" title="2. lsof"></a>2. <code>lsof</code></h3><p><code>lsof</code> 显示系统中打开的文件，常用于查看打开的网络连接。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p>显示所有打开的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><p>显示所有使用端口 <code>80</code> 的网络连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>显示特定进程 <code>&lt;PID&gt;</code> 打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u &lt;username&gt;</span><br></pre></td></tr></table></figure><p>显示特定用户打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof /path/to/file</span><br></pre></td></tr></table></figure><p>显示哪个进程打开了指定文件。</p><h3 id="3-net-tools"><a href="#3-net-tools" class="headerlink" title="3. net-tools"></a>3. <code>net-tools</code></h3><p><code>net-tools</code> 包含 <code>ifconfig</code>、<code>netstat</code> 等工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure><p>显示接口 <code>eth0</code> 的配置信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p>显示所有活动的网络连接及其状态。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.100 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>配置接口 <code>eth0</code> 的 IP 地址和子网掩码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p>显示路由表信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><p>显示网络接口统计信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -plnt</span><br></pre></td></tr></table></figure><p>显示所有监听的 TCP 端口及其关联的进程。</p><h3 id="4-iproute2"><a href="#4-iproute2" class="headerlink" title="4. iproute2"></a>4. <code>iproute2</code></h3><p><code>iproute2</code> 是 <code>net-tools</code> 的替代品，提供 <code>ip</code> 命令。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure><p>显示所有网络接口。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>显示所有接口的 IP 地址信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add 192.168.1.100/24 dev eth0</span><br></pre></td></tr></table></figure><p>为接口 <code>eth0</code> 添加 IP 地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure><p>启用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add default via 192.168.1.1</span><br></pre></td></tr></table></figure><p>设置默认网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down</span><br></pre></td></tr></table></figure><p>禁用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 1</span><br></pre></td></tr></table></figure><p>添加路由规则，使来自 <code>192.168.1.0/24</code> 的流量使用路由表 <code>1</code>。</p><h3 id="5-NetworkManager"><a href="#5-NetworkManager" class="headerlink" title="5. NetworkManager"></a>5. <code>NetworkManager</code></h3><p><code>NetworkManager</code> 是管理网络配置的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>交互命令窗口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device status</span><br></pre></td></tr></table></figure><p>查看当前设备的连接状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure><p>列出所有已保存的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>列出可用的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi connect SSID password PASSWORD</span><br></pre></td></tr></table></figure><p>连接到指定的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add <span class="built_in">type</span> ethernet ifname eth0 con-name my-eth0</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>my-eth0</code> 的以太网连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con modify my-eth0 ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1</span><br></pre></td></tr></table></figure><p>修改连接 <code>my-eth0</code> 的 IP 地址和网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con up my-eth0</span><br></pre></td></tr></table></figure><p>启用连接 <code>my-eth0</code>。</p><h3 id="6-firewalld"><a href="#6-firewalld" class="headerlink" title="6. firewalld"></a>6. <code>firewalld</code></h3><p><code>firewalld</code> 提供动态的防火墙管理工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p>启动 <code>firewalld</code> 服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><p>查看当前活动的区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>列出当前区域的所有规则。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久打开端口 <code>80</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>重新加载防火墙配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br></pre></td></tr></table></figure><p>将 <code>http</code> 服务添加到 <code>public</code> 区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久关闭端口 <code>80</code>。</p><h3 id="7-iptables"><a href="#7-iptables" class="headerlink" title="7. iptables"></a>7. <code>iptables</code></h3><p><code>iptables</code> 是 Linux 内核中的包过滤工具。</p><h4 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/1343683-20190523094912972-1910501182.png" alt="img"></p><p>iptables 是 Linux 系统中用于配置网络地址转换（NAT）、包过滤和包修改规则的工具。iptables 使用四个表和五个链来处理数据包。以下是对四个表和五个链的详细解释：</p><h5 id="四个表（Tables）"><a href="#四个表（Tables）" class="headerlink" title="四个表（Tables）"></a>四个表（Tables）</h5><ol><li><p><strong>filter 表</strong>：</p><ul><li><strong>用途</strong>：这是默认的表，用于网络包过滤。</li><li><strong>链</strong>：包含 INPUT、FORWARD 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有进入本地网络接口的流量</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许所有从本地网络接口发出的流量</span></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝所有从外部到达本机的流量</span></span><br><span class="line">iptables -A INPUT -i eth0 -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>nat 表</strong>：</p><ul><li><strong>用途</strong>：用于网络地址转换（NAT），比如源 NAT（SNAT）和目标 NAT（DNAT）。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将外部访问的80端口重定向到内部服务器的8080端口</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将发往外部的流量的源IP地址更改为指定的IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mangle 表</strong>：</p><ul><li><strong>用途</strong>：用于修改 IP 包头信息，如 TOS、TTL 等。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT、INPUT、FORWARD 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改流经本机的包的TTL值</span></span><br><span class="line">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 128</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>raw 表</strong>：</p><ul><li><strong>用途</strong>：用于在连接跟踪（conntrack）机制之前对数据包进行处理。</li><li><strong>链</strong>：包含 PREROUTING 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标记流经本机的包，以不进行连接跟踪</span></span><br><span class="line">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="五个链（Chains）"><a href="#五个链（Chains）" class="headerlink" title="五个链（Chains）"></a>五个链（Chains）</h5><ol><li><p><strong>INPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理入站流量，即目标为本机的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拒绝所有到达本机的入站流量</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>FORWARD 链</strong>：</p><ul><li><strong>用途</strong>：处理转发流量，即通过本机路由的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有通过本机的转发流量</span></span><br><span class="line">iptables -A FORWARD -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>OUTPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理出站流量，即从本机发出的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有从本机发出的出站流量</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>PREROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之前处理入站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之前修改入站包的目的IP地址</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>POSTROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之后处理出站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之后修改出站包的源IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure><p>列出所有当前规则。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有进入的 TCP 连接通过端口 <code>80</code>。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p icmp -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有 ICMP 出站流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>保存当前规则到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-restore &lt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>从文件恢复规则。</p><h3 id="8-nftables"><a href="#8-nftables" class="headerlink" title="8. nftables"></a>8. <code>nftables</code></h3><p>NFTables 是一个用于包过滤、网络地址转换 (NAT) 和流量控制的框架。它替代了 iptables、ip6tables、arptables 和 ebtables。NFTables 的配置文件通常使用简单的脚本语言来定义规则。以下是 NFTables 的表、链和规则的基本结构和语法。</p><h4 id="一、基础结构"><a href="#一、基础结构" class="headerlink" title="一、基础结构"></a>一、基础结构</h4><ol><li><p><strong>表（table）</strong></p><ul><li>表是规则集的容器。每张表可以包含多个链。</li></ul></li><li><p><strong>链（chain）</strong></p><ul><li>链是规则的有序列表。链可以是内置的（如 <code>input</code>、<code>output</code>、<code>forward</code>）或用户定义的。</li></ul></li><li><p><strong>规则（rule）</strong></p><ul><li>规则定义了特定条件下应执行的动作。</li></ul></li></ol><h4 id="二、表、链和规则的语法"><a href="#二、表、链和规则的语法" class="headerlink" title="二、表、链和规则的语法"></a>二、表、链和规则的语法</h4><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;family&gt;</code>: 地址族，常见的有 <code>ip</code>（IPv4）、<code>ip6</code>（IPv6）、<code>inet</code>（支持 IPv4 和 IPv6）、<code>arp</code>（ARP）、<code>bridge</code>（网桥）。</li><li><code>&lt;table_name&gt;</code>: 表的名称。</li></ul></li><li><p><strong>删除表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出现有表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list tables</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &#123; type &lt;type&gt; hook &lt;hook&gt; priority &lt;priority&gt;; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;type&gt;</code>: 链的类型，可以是 <code>filter</code>、<code>nat</code> 等。</li><li><code>&lt;hook&gt;</code>: 钩子点，可以是 <code>input</code>、<code>output</code>、<code>forward</code>、<code>prerouting</code>、<code>postrouting</code> 等。</li><li><code>&lt;priority&gt;</code>: 优先级。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; type filter hook input priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &lt;expression&gt; &lt;action&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;expression&gt;</code>: 匹配条件，例如 <code>ip saddr 192.168.1.1</code>。</li><li><code>&lt;action&gt;</code>: 动作，例如 <code>accept</code>、<code>drop</code>、<code>reject</code>、<code>log</code> 等。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure></li><li><p><strong>删除规则</strong><br> 可以通过规则句柄删除：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; handle &lt;handle_number&gt;</span><br></pre></td></tr></table></figure><p> 首先列出链中的规则以找到句柄：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h4><p>假设我们要创建一个简单的防火墙配置，允许入站 SSH 连接并拒绝所有其他入站流量。</p><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table ip filter</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip filter input &#123; type filter hook input priority 0\; &#125;</span><br><span class="line">nft add chain ip filter forward &#123; type filter hook forward priority 0\; &#125;</span><br><span class="line">nft add chain ip filter output &#123; type filter hook output priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip protocol tcp tcp dport 22 accept</span><br><span class="line">nft add rule ip filter input drop</span><br></pre></td></tr></table></figure></li><li><p><strong>查看配置</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><p>这样，我们就配置了一个简单的防火墙，允许入站 SSH 连接并拒绝所有其他入站流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>列出当前规则集。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>添加规则，允许通过端口 <code>80</code> 的 TCP 连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft delete rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add table ip mytable</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>mytable</code> 的表。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; <span class="built_in">type</span> filter hook input priority 0 \; &#125;</span><br></pre></td></tr></table></figure><p>在 <code>mytable</code> 表中添加一个名为 <code>mychain</code> 的链。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain counter</span><br></pre></td></tr></table></figure><p>在 <code>mychain</code> 链中添加一个计数规则。</p><h3 id="9-curl"><a href="#9-curl" class="headerlink" title="9. curl"></a>9. <code>curl</code></h3><p><code>curl</code> 是用于传输数据的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I http://example.com</span><br></pre></td></tr></table></figure><p>获取 HTTP 响应头信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/api</span><br></pre></td></tr></table></figure><p>发送 POST 请求。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password http://example.com</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://example.com</span><br></pre></td></tr></table></figure><p>忽略 SSL 证书错误。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://example.com</span><br></pre></td></tr></table></figure><p>跟随重定向。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -C - -O http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><h3 id="10-wget"><a href="#10-wget" class="headerlink" title="10. wget"></a>10. <code>wget</code></h3><p><code>wget</code> 是另一个下载文件的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q http://example.com/file</span><br></pre></td></tr></table></figure><p>静默模式下载文件，不输出任何信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./local http://example.com</span><br></pre></td></tr></table></figure><p>递归下载整个网站，并将文件保存到 <code>./local</code> 目录中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=100k http://example.com/file</span><br></pre></td></tr></table></figure><p>限制下载速度为 <code>100kB/s</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --user=username --password=password http://example.com/file</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><h3 id="11-iptop"><a href="#11-iptop" class="headerlink" title="11. iptop"></a>11. <code>iptop</code></h3><p><code>iptop</code> 是一个实时显示网络流量的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop</span><br></pre></td></tr></table></figure><p>启动 <code>iptop</code>，显示实时网络流量。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -i eth0</span><br></pre></td></tr></table></figure><p>显示特定接口 <code>eth0</code> 的网络流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f src net 192.168.1.0/24</span><br></pre></td></tr></table></figure><p>显示来自特定子网 <code>192.168.1.0/24</code> 的流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f dst port 80</span><br></pre></td></tr></table></figure><p>显示发送到端口 <code>80</code> 的流量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-tcpdump&quot;&gt;&lt;a href=&quot;#1-tcpdump&quot; class=&quot;headerlink&quot; title=&quot;1. tcpdump&quot;&gt;&lt;/a&gt;1. &lt;code&gt;tcpdump&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; 是一个网络抓</summary>
      
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="net" scheme="https://kalyan-zitiu.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux磁盘</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/</id>
    <published>2024-07-08T08:49:36.000Z</published>
    <updated>2024-07-09T07:35:51.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="磁盘方面"><a href="#磁盘方面" class="headerlink" title="磁盘方面"></a>磁盘方面</h3><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><h5 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h5><p>在linux系统中，磁盘分区是一种物理硬盘分割成多个逻辑部分的方法，每个分区可以独立地进行管理和使用通常会分为</p><ul><li>主分区：每个磁盘最多可以有四个主分区。需要更多地分区可以使用扩展分区。</li><li>扩展分区： 扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li><li>逻辑分区： 位于扩展分区内地分区，可以超过四个限制。</li></ul><h5 id="分区职责"><a href="#分区职责" class="headerlink" title="分区职责"></a>分区职责</h5><ul><li>主分区：用于安装操作系统，存储数据，以及引导系统</li><li>扩展分区：是用于包含逻辑分区的一个容器，解决主分区的限制，创建多个逻辑分区</li><li>逻辑分区：可以用来存储操作系统，应用程序和数据。</li></ul><h5 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h5><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，包含系统中所有文件和目录的起点。</td></tr><tr><td><code>/bin</code></td><td>基本命令的二进制文件，如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等。</td></tr><tr><td><code>/boot</code></td><td>存放启动加载器相关的文件和内核文件。</td></tr><tr><td><code>/dev</code></td><td>设备文件目录，包含所有设备的接口文件（如硬盘、终端）。</td></tr><tr><td><code>/etc</code></td><td>配置文件目录，包含系统和应用程序的所有配置文件。</td></tr><tr><td><code>/home</code></td><td>用户家目录，每个用户都有一个单独的子目录，用于存放个人文件和配置。</td></tr><tr><td><code>/lib</code></td><td>系统库文件目录，包含基本系统库和内核模块。</td></tr><tr><td><code>/media</code></td><td>自动挂载的可移动媒体设备（如CD-ROM、USB驱动器）。</td></tr><tr><td><code>/mnt</code></td><td>临时挂载文件系统的挂载点。</td></tr><tr><td><code>/opt</code></td><td>可选软件包目录，用于安装附加的第三方应用程序。</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，提供系统和进程信息。</td></tr><tr><td><code>/root</code></td><td>超级用户（root）家目录。</td></tr><tr><td><code>/run</code></td><td>运行时数据，存放系统启动后产生的临时文件（如进程ID文件）。</td></tr><tr><td><code>/sbin</code></td><td>系统管理员命令的二进制文件，如 <code>fdisk</code>、<code>ifconfig</code> 等。</td></tr><tr><td><code>/srv</code></td><td>服务数据目录，存放特定服务的数据（如Web服务器文件）。</td></tr><tr><td><code>/sys</code></td><td>虚拟文件系统，提供内核设备和驱动程序信息。</td></tr><tr><td><code>/tmp</code></td><td>临时文件目录，存放临时文件，系统重启后可能会清空。</td></tr><tr><td><code>/usr</code></td><td>用户程序目录，包含二进制文件、库文件、文档等（如 <code>/usr/bin</code>、<code>/usr/lib</code>）。</td></tr><tr><td><code>/var</code></td><td>可变数据文件目录，存放日志文件、邮件、临时文件等（如 <code>/var/log</code>、<code>/var/mail</code>）。</td></tr></tbody></table><h4 id="MBR-Master-Boot-Record"><a href="#MBR-Master-Boot-Record" class="headerlink" title="MBR (Master Boot Record)"></a>MBR (Master Boot Record)</h4><ul><li>MBR是一种传统的磁盘分区表格式，它位于磁盘的第一个扇区。</li><li>MBR分区表最多支持4个主分区，如果需要更多分区，必须将其中一个主分区转换为扩展分区，再在扩展分区内创建逻辑分区。</li><li>由于使用32位地址，MBR最多支持2TB的磁盘。</li></ul><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>主引导记录 (Master Boot Record)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0）。</li><li>大小为512字节。</li></ul></li><li><p><strong>主引导代码 (Boot Code)</strong></p><ul><li>前446字节存储主引导代码，用于启动操作系统。</li></ul></li><li><p><strong>分区表 (Partition Table)</strong></p><ul><li>紧随其后64字节（每个分区条目16字节，共4个条目）。</li><li>描述最多四个主分区或一个扩展分区的起始位置和大小。</li></ul></li><li><p><strong>签名 (Signature)</strong></p><ul><li>最后2字节为磁盘签名（0x55AA），标志主引导记录的结束。</li></ul></li><li><p><strong>扩展分区</strong></p><ul><li>如果需要超过四个分区，可以创建一个扩展分区（Extended Partition）。</li><li>扩展分区包含一个扩展引导记录 (EBR)，每个逻辑分区包含一个EBR。</li></ul></li></ol><h4 id="GPT-GUID-Partition-Table"><a href="#GPT-GUID-Partition-Table" class="headerlink" title="GPT (GUID Partition Table)"></a>GPT (GUID Partition Table)</h4><ul><li>GPT是一种现代的磁盘分区表格式，取代了传统的MBR。</li><li>GPT使用64位地址，可以支持超过8ZB的磁盘容量。</li><li>GPT最多可以支持128个主分区，没有扩展分区的限制。</li><li>GPT分区表有冗余备份和CRC校验，提高了数据的安全性和可靠性。</li></ul><h5 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>保护性MBR (Protective MBR)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0），防止旧版工具误读GPT磁盘。</li></ul></li><li><p><strong>主GPT头 (Primary GPT Header)</strong></p><ul><li>位于LBA 1，描述GPT分区表的总体信息。</li><li>包含GPT版本、头部大小、CRC32校验和等。</li></ul></li><li><p><strong>主分区表 (Primary Partition Table)</strong></p><ul><li>紧随其后，从LBA 2开始，一般占用32个扇区。</li><li>每个分区条目128字节，通常最多支持128个分区条目。</li></ul></li><li><p><strong>分区条目 (Partition Entries)</strong></p><ul><li>每个条目描述一个分区的GUID、类型GUID、起始LBA、结束LBA、属性标志等。</li></ul></li><li><p><strong>用户分区</strong></p><ul><li>从主分区表结束位置开始，存储实际的数据和文件系统。</li></ul></li><li><p><strong>备份分区表 (Backup Partition Table)</strong></p><ul><li>位于磁盘末尾，用于恢复主GPT头和分区表。</li></ul></li><li><p><strong>备份GPT头 (Backup GPT Header)</strong></p><ul><li>位于磁盘倒数第二个扇区，记录备份分区表的信息。</li></ul></li></ol><h4 id="Legacy-BIOS-引导"><a href="#Legacy-BIOS-引导" class="headerlink" title="Legacy / BIOS 引导"></a>Legacy / BIOS 引导</h4><p>Legacy/BIOS（Basic Input/Output System）引导是一种传统的计算机启动模式。它是PC兼容系统的早期固件接口，负责初始化硬件并引导操作系统。以下是详细的说明：</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><p><strong>电源自检（POST）</strong>:</p><ul><li>计算机启动时，BIOS首先进行电源自检（Power-On Self-Test），检查和初始化系统硬件，如内存、CPU、硬盘和外设。</li><li>如果POST过程中检测到错误，BIOS会通过蜂鸣声或屏幕错误信息提示用户。</li></ul></li><li><p><strong>查找引导设备</strong>:</p><ul><li>POST完成后，BIOS会根据预设的引导顺序查找可启动设备（如硬盘、光盘、U盘等）。</li><li>引导顺序通常可以在BIOS设置界面中配置。</li></ul></li><li><p><strong>加载引导扇区</strong>:</p><ul><li>一旦找到一个可引导的设备，BIOS会读取该设备的主引导记录（MBR，Master Boot Record），这通常是设备的第一个扇区（512字节）。</li><li>MBR包含了启动加载程序的初始部分以及分区表信息。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>BIOS将控制权交给MBR中的引导加载程序。这个程序进一步加载操作系统或更多的引导代码（例如，GRUB、LILO等引导加载程序）。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序最终加载操作系统内核，并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="特点和限制"><a href="#特点和限制" class="headerlink" title="特点和限制"></a>特点和限制</h5><ul><li><strong>地址空间限制</strong>: BIOS模式只能使用传统的32位地址模式，无法利用超过4GB的内存空间。</li><li><strong>MBR分区限制</strong>: MBR分区表限制最大支持4个主分区，每个分区最大只能是2TB。</li><li><strong>兼容性</strong>: 由于其长期存在，BIOS模式具有广泛的硬件和软件兼容性。</li></ul><h5 id="设置和配置"><a href="#设置和配置" class="headerlink" title="设置和配置"></a>设置和配置</h5><ul><li><strong>进入BIOS设置</strong>: 通常通过在启动时按下特定的键（如F2、Del、Esc）进入BIOS设置界面。</li><li><strong>配置引导顺序</strong>: 在BIOS设置界面中，用户可以配置引导设备的优先级。</li><li><strong>启用/禁用设备</strong>: 可以在BIOS中启用或禁用某些硬件设备，以优化系统性能或解决兼容性问题。</li></ul><h4 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h4><p>UEFI（统一可扩展固件接口）是一种现代固件接口，用于替代传统的BIOS。它提供更强大的功能和更灵活的引导方式。以下是详细的UEFI启动流程和相关设置的教学：</p><h5 id="UEFI-启动流程"><a href="#UEFI-启动流程" class="headerlink" title="UEFI 启动流程"></a>UEFI 启动流程</h5><ol><li><p><strong>电源开启和硬件初始化</strong>:</p><ul><li>计算机启动时，UEFI固件首先进行硬件初始化和电源自检（POST，Power-On Self-Test）。</li><li>检查CPU、内存、存储设备和外设，确保它们工作正常。</li></ul></li><li><p><strong>进入UEFI固件界面</strong>:</p><ul><li>在启动过程中，用户可以按特定的键（如F2、Del、Esc）进入UEFI固件设置界面。</li></ul></li><li><p><strong>查找EFI系统分区（ESP）</strong>:</p><ul><li>UEFI固件会查找包含EFI系统分区（ESP）的存储设备。ESP是一个特殊的分区，用于存储EFI引导加载程序和相关文件。</li><li>ESP通常格式化为FAT32文件系统，并且标记为“EFI System Partition”。</li></ul></li><li><p><strong>加载EFI引导加载程序</strong>:</p><ul><li>在ESP中，UEFI固件查找引导加载程序文件，通常位于 <code>\EFI\Boot\bootx64.efi</code>（对于64位系统）。</li><li>用户可以在UEFI设置中指定特定的引导加载程序路径或更改引导顺序。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>UEFI将控制权交给引导加载程序。这个程序进一步加载操作系统的引导程序或内核。</li><li>常见的引导加载程序包括Windows Boot Manager、GRUB、Clover等。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序加载操作系统内核并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="设置和配置UEFI"><a href="#设置和配置UEFI" class="headerlink" title="设置和配置UEFI"></a>设置和配置UEFI</h5><ol><li><p><strong>进入UEFI设置界面</strong>:</p><ul><li>重启计算机，在启动过程中按下特定的键（如F2、Del、Esc）进入UEFI设置界面。</li><li>不同品牌的主板可能有不同的按键，具体请参考主板或计算机手册。</li></ul></li><li><p><strong>配置引导顺序</strong>:</p><ul><li>在UEFI设置界面中，找到“Boot”或“启动”选项卡。</li><li>配置引导设备的优先级，将希望首先引导的设备设置为第一优先级。</li><li>如果需要从特定的EFI引导文件启动，可以手动指定路径。</li></ul></li><li><p><strong>启用/禁用设备</strong>:</p><ul><li>在“Advanced”或“高级”选项卡中，可以启用或禁用某些硬件设备。</li><li>例如，启用/禁用USB端口、网卡、SATA接口等。</li></ul></li><li><p><strong>安全启动（Secure Boot）</strong>:</p><ul><li>安全启动是一项UEFI功能，用于防止加载未签名或未经授权的操作系统引导程序。</li><li>在“Security”或“安全”选项卡中，可以启用或禁用安全启动。</li><li>如果需要安装非官方签名的操作系统，可能需要暂时禁用安全启动。</li></ul></li><li><p><strong>保存和退出</strong>:</p><ul><li>完成设置后，选择“Save &amp; Exit”或“保存并退出”选项。</li><li>保存设置后，系统将重新启动并应用新的设置。</li></ul></li></ol><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p><code>sar</code>（System Activity Reporter）是一个强大的工具，用于在Linux系统上收集、报告和保存系统活动信息。它可以提供有关系统性能的详细数据，包括CPU、内存、网络、磁盘I/O等多个方面。<code>sar</code>命令通常与<code>sysstat</code>软件包一起使用。下面是如何使用<code>sar</code>命令来监控磁盘活动的步骤：</p><h5 id="安装sysstat包"><a href="#安装sysstat包" class="headerlink" title="安装sysstat包"></a>安装sysstat包</h5><p>在大多数Linux发行版中，可以通过包管理器安装<code>sysstat</code>包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于基于Debian的系统（如Ubuntu）</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于基于RHEL的系统（如CentOS）</span></span><br><span class="line">sudo yum install sysstat</span><br></pre></td></tr></table></figure><h5 id="启用和配置sysstat"><a href="#启用和配置sysstat" class="headerlink" title="启用和配置sysstat"></a>启用和配置sysstat</h5><p>安装完成后，确保<code>sysstat</code>服务已启用并正在运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用sysstat服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sysstat</span><br><span class="line">sudo systemctl start sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置sysstat以启用数据收集</span></span><br><span class="line">sudo nano /etc/default/sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ENABLED=&quot;false&quot;修改为ENABLED=&quot;true&quot;</span></span><br><span class="line">ENABLED=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存并退出编辑器</span></span><br></pre></td></tr></table></figure><h5 id="使用sar监控磁盘I-O"><a href="#使用sar监控磁盘I-O" class="headerlink" title="使用sar监控磁盘I/O"></a>使用sar监控磁盘I/O</h5><p><code>sar</code>可以通过<code>-d</code>选项来监控磁盘I/O活动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实时监控磁盘I/O，每1秒报告一次，共报告10次</span></span><br><span class="line">sar -d 1 10</span><br></pre></td></tr></table></figure><h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><ul><li><code>-d</code>：报告磁盘I/O统计信息。</li><li><code>-p</code>：将设备名称从设备编号翻译为设备名称。</li><li><code>-r</code>：报告内存和交换空间使用情况。</li><li><code>-n</code>：报告网络统计信息（如<code>-n DEV</code>报告网络接口统计信息）。</li><li><code>-u</code>：报告CPU使用情况。</li></ul><h5 id="查看历史数据"><a href="#查看历史数据" class="headerlink" title="查看历史数据"></a>查看历史数据</h5><p><code>sar</code>命令可以查看过去的系统性能数据，这些数据通常保存在<code>/var/log/sa/</code>目录中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定日期的磁盘I/O活动（例如2024年7月5日）</span></span><br><span class="line">sar -d -f /var/log/sa/sa05</span><br></pre></td></tr></table></figure><h5 id="示例输出解读"><a href="#示例输出解读" class="headerlink" title="示例输出解读"></a>示例输出解读</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709151241420.png" alt="image-20240709151241420"></p><p>以下是<code>sar -d</code>命令的示例输出及其含义：</p><ul><li><code>tps</code>：每秒传输数（读+写）。</li><li><code>rd_sec/s</code>：每秒读取的扇区数。</li><li><code>wr_sec/s</code>：每秒写入的扇区数。</li><li><code>avgrq-sz</code>：平均请求大小（扇区）。</li><li><code>avgqu-sz</code>：平均请求队列长度。</li><li><code>await</code>：每个I/O操作的平均等待时间（毫秒）。</li><li><code>svctm</code>：每个I/O操作的平均服务时间（毫秒）。</li><li><code>%util</code>：设备的I/O使用百分比。</li></ul><p>使用<code>sar</code>工具可以帮助系统管理员深入了解系统性能瓶颈并进行相应的优化。</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID（Redundant Array of Independent Disks，即独立磁盘冗余阵列）是一种将多个物理硬盘驱动器组合成一个逻辑单元的存储技术。其主要目的是提高数据存储的性能、容量和可靠性。RAID技术通过不同的配置（称为RAID级别）来实现这些目标。以下是几种常见的RAID级别：</p><ol><li><p><strong>RAID 0</strong>：</p><ul><li><strong>条带化（Striping）</strong>：数据在多个磁盘上分割并并行写入。</li><li><strong>优点</strong>：提高读写速度。</li><li><strong>缺点</strong>：没有冗余，任何一个磁盘故障都会导致数据丢失。</li></ul></li><li><p><strong>RAID 1</strong>：</p><ul><li><strong>镜像（Mirroring）</strong>：每个数据块都在两个或多个磁盘上复制。</li><li><strong>优点</strong>：提供高冗余，数据安全性高。</li><li><strong>缺点</strong>：磁盘利用率低（50%），只使用了一半的存储容量。</li></ul></li><li><p><strong>RAID 5</strong>：</p><ul><li><strong>分布式奇偶校验（Distributed Parity）</strong>：数据和奇偶校验信息分布在所有磁盘上。</li><li><strong>优点</strong>：平衡了性能、容量和数据安全性，至少需要3个磁盘。</li><li><strong>缺点</strong>：写操作较慢，因为需要计算和写入奇偶校验数据。</li></ul></li><li><p><strong>RAID 6</strong>：</p><ul><li><strong>双奇偶校验（Double Parity）</strong>：类似RAID 5，但有两组奇偶校验数据，容忍两块磁盘同时故障。</li><li><strong>优点</strong>：更高的数据安全性。</li><li><strong>缺点</strong>：写操作更慢，磁盘利用率较低。</li></ul></li><li><p><strong>RAID 10（或1+0）</strong>：</p><ul><li><strong>条带化和镜像结合</strong>：先进行镜像，再进行条带化。</li><li><strong>优点</strong>：结合了RAID 0和RAID 1的优点，高性能和高冗余。</li><li><strong>缺点</strong>：需要较多的磁盘，成本较高。</li></ul></li><li><p><strong>RAID 50（或5+0）</strong>：</p><ul><li><strong>条带化和分布式奇偶校验结合</strong>：将RAID 5阵列条带化。</li><li><strong>优点</strong>：提高了性能和冗余，适合大规模存储需求。</li><li><strong>缺点</strong>：复杂度增加，需要更多磁盘。</li></ul></li></ol><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 MBR 分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>m</td><td>显示帮助菜单</td><td>显示所有可用命令的列表和简要说明。</td></tr><tr><td>p</td><td>显示当前分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>n</td><td>添加一个新分区</td><td>根据提示选择主分区或逻辑分区，并设置分区的开始和结束位置。</td></tr><tr><td>d</td><td>删除一个分区</td><td>选择要删除的分区编号。</td></tr><tr><td>l</td><td>列出已知分区类型</td><td>显示支持的所有分区类型代码和说明。</td></tr><tr><td>t</td><td>更改一个分区的系统ID</td><td>选择分区后，输入新的类型代码。</td></tr><tr><td>a</td><td>切换启动标志</td><td>设置或取消某个分区的启动标志（使其可引导）。</td></tr><tr><td>w</td><td>写入分区表并退出</td><td>将对分区所做的更改写入磁盘，并退出fdisk。</td></tr><tr><td>q</td><td>不保存更改并退出</td><td>退出fdisk而不保存对分区表的任何更改。</td></tr></tbody></table><h5 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h5><ol><li>输入<code>n</code>创建新分区。</li><li>选择分区类型（主分区<code>p</code>或逻辑分区<code>e</code>）。</li><li>指定分区号（例如<code>1</code>）。</li><li>指定分区的起始扇区和结束扇区。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h5><ol><li>输入<code>p</code>查看当前分区表。</li><li>输入<code>d</code>删除分区。</li><li>输入要删除的分区编号（例如<code>1</code>）。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="更改分区类型"><a href="#更改分区类型" class="headerlink" title="更改分区类型"></a>更改分区类型</h5><ol><li>输入<code>t</code>更改分区类型。</li><li>输入分区编号（例如<code>1</code>）。</li><li>输入新的类型代码（例如<code>83</code>用于Linux分区）。</li><li>输入<code>w</code>保存并退出。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709125834777.png" alt="image-20240709125834777"></p><h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 GPT分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>mklabel</td><td>创建新的磁盘标签（分区表）</td><td>格式：<code>mklabel &lt;label&gt;</code>，其中<code>label</code>可以是<code>gpt</code>、<code>msdos</code>等。</td></tr><tr><td>mkpart</td><td>创建新分区</td><td>格式：<code>mkpart &lt;part-type&gt; &lt;fs-type&gt; &lt;start&gt; &lt;end&gt;</code>，例如<code>mkpart primary ext4 1MiB 500MiB</code>。</td></tr><tr><td>rm</td><td>删除分区</td><td>格式：<code>rm &lt;number&gt;</code>，其中<code>number</code>是分区编号。</td></tr><tr><td>print</td><td>显示分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>name</td><td>给分区命名</td><td>格式：<code>name &lt;number&gt; &lt;name&gt;</code>，给指定编号的分区命名。</td></tr><tr><td>set</td><td>设置分区标志</td><td>格式：`set <number> <flag> &lt;on</td></tr><tr><td>resizepart</td><td>调整分区大小</td><td>格式：<code>resizepart &lt;number&gt; &lt;end&gt;</code>，将分区调整到新的结束位置。</td></tr><tr><td>move</td><td>移动分区</td><td>格式：<code>move &lt;number&gt; &lt;start&gt; &lt;end&gt;</code>，移动分区到新的位置。</td></tr><tr><td>mkfs</td><td>创建文件系统</td><td>格式：<code>mkfs &lt;number&gt; &lt;fs-type&gt;</code>，例如<code>mkfs 1 ext4</code>。</td></tr><tr><td>align-check</td><td>检查分区对齐</td><td>格式：<code>align-check &lt;opt&gt; &lt;number&gt;</code>，例如<code>align-check optimal 1</code>。</td></tr><tr><td>rescue</td><td>尝试恢复丢失的分区</td><td>格式：<code>rescue &lt;start&gt; &lt;end&gt;</code>，尝试在指定范围内恢复分区。</td></tr><tr><td>quit</td><td>退出parted</td><td>退出parted交互模式。</td></tr><tr><td>unit</td><td>设置显示单位</td><td>格式：<code>unit &lt;unit&gt;</code>，其中<code>unit</code>可以是<code>s</code>(扇区)、<code>MB</code>、<code>GB</code>等。</td></tr></tbody></table><h5 id="启动parted"><a href="#启动parted" class="headerlink" title="启动parted"></a>启动parted</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo parted /dev/sdb</span><br></pre></td></tr></table></figure><h5 id="创建新的分区表（GPT）"><a href="#创建新的分区表（GPT）" class="headerlink" title="创建新的分区表（GPT）"></a>创建新的分区表（GPT）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br></pre></td></tr></table></figure><h5 id="创建新分区-1"><a href="#创建新分区-1" class="headerlink" title="创建新分区"></a>创建新分区</h5><p>创建一个从1MiB开始，500MiB结束的主分区，文件系统类型为ext4：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br></pre></td></tr></table></figure><h5 id="删除分区-1"><a href="#删除分区-1" class="headerlink" title="删除分区"></a>删除分区</h5><p>删除刚才创建的第一个分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">rm</span> 1</span><br></pre></td></tr></table></figure><h5 id="调整分区大小"><a href="#调整分区大小" class="headerlink" title="调整分区大小"></a>调整分区大小</h5><p>假设重新创建了一个分区，现在调整其大小到1000MiB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br><span class="line">(parted) resizepart 1 1000MiB</span><br></pre></td></tr></table></figure><h5 id="设置分区标志"><a href="#设置分区标志" class="headerlink" title="设置分区标志"></a>设置分区标志</h5><p>设置第一个分区的启动标志：</p><p>可设置的标识有：</p><p><code>boot</code>：引导分区</p><p><code>esp</code>：EFI系统分区（通常用于UEFI引导）</p><p><code>lvm</code>：逻辑卷管理</p><p><code>raid</code>：RAID分区</p><p><code>swap</code>：交换分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">set</span> &lt;分区编号&gt; &lt;标识&gt; on</span><br></pre></td></tr></table></figure><h5 id="显示分区表"><a href="#显示分区表" class="headerlink" title="显示分区表"></a>显示分区表</h5><p>显示当前的分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h5 id="给分区命名"><a href="#给分区命名" class="headerlink" title="给分区命名"></a>给分区命名</h5><p>给第一个分区命名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) name 1 my_partition</span><br></pre></td></tr></table></figure><h5 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h5><p>在第一个分区上创建ext4文件系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkfs 1 ext4</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><ol><li><p><strong>ext4</strong>：</p><ul><li>目前最广泛使用的Linux文件系统，ext4具有良好的性能、稳定性和兼容性，支持大文件和大容量存储，适用于大多数应用场景。</li></ul></li><li><p><strong>XFS</strong>：</p><ul><li>XFS是一个高性能的日志文件系统，擅长处理大文件和高并发环境，常用于需要高性能和可扩展性的服务器和存储系统。</li></ul></li><li><p><strong>Btrfs</strong>：</p><ul><li>Btrfs（B-tree FS）支持快照、压缩、多设备存储池、在线文件系统检查和修复等高级功能，适用于需要高级数据管理和灵活性的环境。</li></ul></li><li><p>**ZFS on Linux (ZoL)**：</p><ul><li>ZFS具有高度的数据完整性、快照和复制等高级特性，适用于高存储要求的环境，如服务器和大型存储系统。</li></ul></li></ol><h5 id="检查分区对齐"><a href="#检查分区对齐" class="headerlink" title="检查分区对齐"></a>检查分区对齐</h5><p>检查第一个分区的对齐情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) align-check optimal 1</span><br></pre></td></tr></table></figure><h5 id="尝试恢复丢失的分区"><a href="#尝试恢复丢失的分区" class="headerlink" title="尝试恢复丢失的分区"></a>尝试恢复丢失的分区</h5><p>假设分区丢失，尝试在指定范围内恢复分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) rescue 1MiB 1000MiB</span><br></pre></td></tr></table></figure><h5 id="退出parted"><a href="#退出parted" class="headerlink" title="退出parted"></a>退出parted</h5><p>退出parted：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) quit</span><br></pre></td></tr></table></figure><h5 id="验证操作"><a href="#验证操作" class="headerlink" title="验证操作"></a>验证操作</h5><p>为了验证这些操作，可以使用<code>lsblk</code>或<code>fdisk -l</code>来查看分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsblk</span><br><span class="line">sudo fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure><p>系统中没有parted工具，可以通过以下命令安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install parted  <span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo yum install parted      <span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo dnf install parted      <span class="comment"># Fedora</span></span><br></pre></td></tr></table></figure><h4 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h4><p>LVM 是一种逻辑卷管理器，允许对硬盘和其他存储设备进行灵活的分区管理。</p><p>ps: 逻辑卷是由LVM创建和管理的虚拟存储单元，可以跨越多个物理磁盘或分区。逻辑卷是建立在物理卷之上，物理卷可以是整个磁盘分区或RAID设备。</p><h5 id="为什么要用到LVM"><a href="#为什么要用到LVM" class="headerlink" title="为什么要用到LVM"></a>为什么要用到LVM</h5><p>有工具就是因为有需求，传统的分区因为固定分区大小，需要停机调整分区，影响服务可用。所以需要用到LVM，在线扩展逻辑卷的大小无需停机，只需要添加新的物理硬盘到卷组（VG）中，然后扩展逻辑卷（LV）大小。除此之外，还能够快速创建备份，不需要传统的长时间锁定数据库，还能够整合多个磁盘设备成为一个存储池，能够在数据迁移阶段，避免长时间停机。</p><h5 id="怎么查看逻辑卷"><a href="#怎么查看逻辑卷" class="headerlink" title="怎么查看逻辑卷"></a>怎么查看逻辑卷</h5><h6 id="了解大概的可用块设备"><a href="#了解大概的可用块设备" class="headerlink" title="了解大概的可用块设备"></a>了解大概的可用块设备</h6><p>这张图片显示了<code>lsblk</code>命令的输出，列出了系统中的所有块设备及其挂载点。以下是对这张图片的详细描述：</p><ol><li><p><strong>loop设备</strong>：</p><ul><li><strong>loop0</strong>: 111.9M, 类型为loop，挂载在<code>/snap/lxd/24322</code></li><li><strong>loop1</strong>: 87M, 类型为loop，挂载在<code>/snap/lxd/28373</code></li><li><strong>loop2</strong>: 53.3M, 类型为loop，挂载在<code>/snap/snapd/19457</code></li><li><strong>loop3</strong>: 38.8M, 类型为loop，挂载在<code>/snap/core20/1974</code></li><li><strong>loop4</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2318</code></li><li><strong>loop5</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2456</code></li></ul></li><li><p><strong>物理磁盘</strong>：</p><ul><li><p>sda</p><p>: 25G, 类型为disk</p><ul><li><strong>sda1</strong>: 1M, 类型为part，没有挂载点（这可能是BIOS引导分区或其他用途的特殊分区）</li><li><strong>sda2</strong>: 2G, 类型为part，挂载在<code>/boot</code></li><li><strong>sda3</strong>: 23G, 类型为part，没有挂载点（这可能是LVM物理卷）</li></ul></li></ul></li><li><p><strong>逻辑卷管理器（LVM）</strong>：</p><ul><li><strong>ubuntu–vg-ubuntu–lv</strong>: 12.5G, 类型为lvm，挂载在<code>/</code></li></ul></li><li><p><strong>光驱设备</strong>：</p><ul><li><strong>sr0</strong>: 2G, 类型为rom，没有挂载点</li></ul></li><li></li></ol><ul><li><p><strong>loop设备</strong>：这些是虚拟设备，通常用于挂载磁盘映像文件。</p></li><li><p>sda</p><p>：这是系统中的一个物理磁盘，包含三个分区（sda1, sda2, sda3）。</p><ul><li><strong>sda1</strong>：非常小，只有1M，通常用于系统引导或其他特殊用途。</li><li><strong>sda2</strong>：挂载在<code>/boot</code>，通常用于存放启动加载程序和内核。</li><li><strong>sda3</strong>：较大，为23G，可能用于LVM管理。</li></ul></li><li><p><strong>LVM逻辑卷</strong>：<code>ubuntu--vg-ubuntu--lv</code>是一个逻辑卷，挂载在根目录<code>/</code>。这表示LVM在管理这个分区的存储。</p></li><li><p><strong>光驱设备（sr0）</strong>：显示为2G，未挂载。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709110545123.png" alt="image-20240709110545123"></p><h6 id="扩展逻辑卷大概步骤"><a href="#扩展逻辑卷大概步骤" class="headerlink" title="扩展逻辑卷大概步骤"></a>扩展逻辑卷大概步骤</h6><ol><li>添加新物理硬盘</li><li>将新的物理硬盘初始化为物理卷(PV)</li><li>将PV添加到现在的卷组VG</li><li>扩展逻辑卷LV的大小</li></ol><ul><li><strong>示例</strong>: 创建一个逻辑卷</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建物理卷</span></span><br><span class="line">pvcreate /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建卷组</span></span><br><span class="line">vgcreate myvg /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建逻辑卷</span></span><br><span class="line">lvcreate -L 10G -n mylv myvg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化逻辑卷</span></span><br><span class="line">mkfs.ext4 /dev/myvg/mylv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载点</span></span><br><span class="line">mkdir /mnt/kalyantest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载载目录上（ps：一个逻辑卷只能挂载一个目录）</span></span><br><span class="line">mount /mnt/kalyantest</span><br></pre></td></tr></table></figure><h6 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h6><p>创建lvm分区以及扩容</p><ol><li>首先增加物理盘<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114035255.png" alt="image-20240709114035255"></li><li>然后查询存储块</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114244596.png" alt="image-20240709114244596"></p><ol start="3"><li>为物理盘建立分区</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114615916.png" alt="image-20240709114615916"></p><ol start="4"><li>创建PV，VG，LV</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115109564.png" alt="image-20240709115109564"></p><ol start="5"><li>格式化lv<pre><code>![image-20240709115309348](https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115309348.png)</code></pre></li><li>创建挂载目录（也可挂载在你想挂载的地方），并进行挂载(ps:记得修改etc/fstab文件，不然重启会丢失mount点)</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115612877.png" alt="image-20240709115612877"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;磁盘方面&quot;&gt;&lt;a href=&quot;#磁盘方面&quot; class=&quot;headerlink&quot; title=&quot;磁盘方面&quot;&gt;&lt;/a&gt;磁盘方面&lt;/h3&gt;&lt;h4 id=&quot;磁盘分区&quot;&gt;&lt;a href=&quot;#磁盘分区&quot; class=&quot;headerlink&quot; title=&quot;磁盘分区&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="linux" scheme="https://kalyan-zitiu.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://kalyan-zitiu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Blog脚本编写</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2024-07-07T03:03:50.000Z</published>
    <updated>2024-07-07T03:34:02.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺好的，公司的前辈们挺有趣的，而且感觉在这里努力下去会有收获的感觉。回到正题，因为运维实习的原因，在正式上岗工作之前都会有一段培训，所以写博客的机会就变多了，因为我的博客框架原因，我每次写博客都需要处理一下页头的一些参数，而且需要用git进行仓库上传，这些重复的工作有点繁琐，所以打算写两个脚本来处理一下。</p><h2 id="页头处理"><a href="#页头处理" class="headerlink" title="页头处理"></a>页头处理</h2><p> 我的页头格式是这样的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707111114634.png" alt="image-20240707111114634"></p><h3 id="模块确定"><a href="#模块确定" class="headerlink" title="模块确定"></a>模块确定</h3><p>基本涉及到一些题目，时间，分类，标签，图片，作者之类的，有时候还会涉及到是否加密等。所以第一时间需要考虑的是，这个脚本需要能够获取时间，其次要能够快捷输入题目，标签以及分类和用的图片序号，所以需要GUI，然后还需要能够处理文件系统。故基本能够确定三个模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime  <span class="comment"># 导入datetime模块，用于处理日期和时间</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  <span class="comment"># 从pathlib导入Path，用于处理文件系统路径</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 导入tkinter，用于创建GUI应用程序</span></span><br></pre></td></tr></table></figure><h3 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h3><p>然后就可以开始写专门用来生成头部的函数，根据一些页头的结构和格式，进行编写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_markdown_header</span>(<span class="params">title, categories, tags, wallpaper_index</span>):</span><br><span class="line">    now = datetime.datetime.now()  <span class="comment"># 获取当前日期和时间</span></span><br><span class="line">    date_str = now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="comment"># 将日期和时间格式化为字符串</span></span><br><span class="line">    author = <span class="string">&quot;Kalyan&quot;</span>  <span class="comment"># 作者名称</span></span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的类别项字符串</span></span><br><span class="line">    categories_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;cat.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> cat <span class="keyword">in</span> categories.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的标签项字符串</span></span><br><span class="line">    tags_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;tag.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> tag <span class="keyword">in</span> tags.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 使用提供的信息构建完整的Markdown头部</span></span><br><span class="line">    markdown_header = <span class="string">f&quot;&quot;&quot;---</span></span><br><span class="line"><span class="string">title: <span class="subst">&#123;title&#125;</span></span></span><br><span class="line"><span class="string">date: <span class="subst">&#123;date_str&#125;</span></span></span><br><span class="line"><span class="string">categories:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;categories_str&#125;</span></span></span><br><span class="line"><span class="string">tags:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;tags_str&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">description: </span></span><br><span class="line"><span class="string">top_img: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">cover: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">copyright_author: <span class="subst">&#123;author&#125;</span></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> markdown_header  <span class="comment"># 返回构建的Markdown头部</span></span><br></pre></td></tr></table></figure><h3 id="GUI事件处理"><a href="#GUI事件处理" class="headerlink" title="GUI事件处理"></a>GUI事件处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理GUI中提交按钮点击的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_submit</span>():</span><br><span class="line">    title = title_entry.get()  <span class="comment"># 从文本输入小部件获取标题</span></span><br><span class="line">    categories = categories_entry.get()  <span class="comment"># 从文本输入小部件获取类别</span></span><br><span class="line">    tags = tags_entry.get()  <span class="comment"># 从文本输入小部件获取标签</span></span><br><span class="line">    wallpaper_index = wallpaper_entry.get()  <span class="comment"># 从文本输入小部件获取壁纸序号</span></span><br><span class="line">    header = generate_markdown_header(title, categories, tags, wallpaper_index)  <span class="comment"># 生成Markdown头部</span></span><br><span class="line">    desktop = Path.home() / <span class="string">&#x27;Desktop&#x27;</span>  <span class="comment"># 获取桌面路径</span></span><br><span class="line">    file_name = title.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.md&quot;</span>  <span class="comment"># 创建文件名</span></span><br><span class="line">    full_path = desktop / file_name  <span class="comment"># 完整的文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(full_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 打开文件进行写入</span></span><br><span class="line">        f.write(header)  <span class="comment"># 写入Markdown头部</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件已保存在桌面: <span class="subst">&#123;full_path&#125;</span>&quot;</span>)  <span class="comment"># 打印文件保存位置</span></span><br><span class="line"></span><br><span class="line">    root.destroy()  <span class="comment"># 关闭GUI</span></span><br></pre></td></tr></table></figure><h3 id="窗口UI调整"><a href="#窗口UI调整" class="headerlink" title="窗口UI调整"></a>窗口UI调整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = tk.Tk()</span><br><span class="line">root.title(<span class="string">&quot;文章信息输入&quot;</span>)  <span class="comment"># 设置窗口标题</span></span><br><span class="line">root.geometry(<span class="string">&quot;400x200&quot;</span>)  <span class="comment"># 设置窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并放置各种标签和输入框</span></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;文章标题:&quot;</span>).pack()</span><br><span class="line">title_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">title_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;分类（用逗号分隔）-&quot;</span>).pack()</span><br><span class="line">categories_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">categories_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;标签（用逗号分隔）:&quot;</span>).pack()</span><br><span class="line">tags_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">tags_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;壁纸序号:&quot;</span>).pack()</span><br><span class="line">wallpaper_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">wallpaper_entry.pack()</span><br><span class="line"></span><br><span class="line">submit_button = tk.Button(root, text=<span class="string">&quot;提交&quot;</span>, command=on_submit)  <span class="comment"># 创建提交按钮</span></span><br><span class="line">submit_button.pack()</span><br><span class="line"></span><br><span class="line">root.mainloop()  <span class="comment"># 启动GUI事件循环</span></span><br></pre></td></tr></table></figure><p>以上搞定，然后就是打包创建可执行文件就好了。感觉还不错。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112220421.png" alt="image-20240707112220421"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112235909.png" alt="image-20240707112235909"></p><h2 id="上传处理"><a href="#上传处理" class="headerlink" title="上传处理"></a>上传处理</h2><p>这次并用不上写python脚本，只需要用批处理就好了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112640400.png" alt="image-20240707112640400"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺</summary>
      
    
    
    
    <category term="python" scheme="https://kalyan-zitiu.github.io/categories/python/"/>
    
    
    <category term="脚本" scheme="https://kalyan-zitiu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>VMware vSphere</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/07/VMware%20vSphere/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/07/VMware%20vSphere/</id>
    <published>2024-07-07T03:01:04.000Z</published>
    <updated>2024-07-08T02:36:43.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是vmware官方开发的一套虚拟化平台</p><h2 id="能够干什么"><a href="#能够干什么" class="headerlink" title="能够干什么"></a>能够干什么</h2><ol><li>虚拟化：将物理服务器的资源分配给多个VM，提高硬件资源利用率，减少硬件成本。</li><li>集中管理：统一管理监控整个虚拟化环境，包括虚拟机，主机，网络和存储</li><li>高可用提供：能够自动重启故障的物理服务器，保持业务连续。</li><li>资源优化：提供分布式资源调度DRS功能，动态调整VM资源，性能和负载</li><li>安全：能够网络隔离，访问控制，数据加密</li><li>数据保护：提供快照和备份，支持快速恢复</li><li>自动化和编排，通过脚本和工具实现虚拟机的快速部署。</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="ESXi"><a href="#ESXi" class="headerlink" title="ESXi"></a>ESXi</h3><p>是VMware vSphere虚拟化平台的核心组件。它是一种小型的、专用的操作系统，直接安装在物理服务器上，用于运行和管理虚拟机（VM）。可以说有ESXi的OS的物理服务器就是宿主机Host。</p><h3 id="vSwitch"><a href="#vSwitch" class="headerlink" title="vSwitch"></a>vSwitch</h3><p>运行在VMware ESXi主机上的软件交换机，用于管理虚拟网络。它类似于物理交换机，但功能更灵活，能够在虚拟化环境中提供网络连接和管理。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>网络连接：提供VM之间的网络连接，以及虚拟机与外部物理网络的连接。</p></li><li><p>流量隔离和管理：通过VLAN（虚拟局域网）标签，vSwitch可以隔离和管理不同虚拟机的网络流量，提高网络安全性和性能。</p></li><li><p>网络适配器绑定：vSwitch支持将多个物理网络适配器（NIC）绑定在一起，提供冗余和负载均衡，提高网络的可用性和带宽。</p></li></ol><p>ps: NIC即网络接口卡，是计算机硬件组件，用于计算机与网络的连接。它通常以插卡形式存在，插入计算机主板的扩展槽中，也有集成在主板上的形式。</p><ol start="4"><li><p>流量整形：vSwitch能够对进出网络流量进行整形（Traffic Shaping），控制流量速率，确保网络性能的稳定性。</p></li><li><p>安全特性：vSwitch具备安全特性，如防止MAC地址欺骗和IP地址欺骗，提升虚拟网络的安全性。 </p></li></ol><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="标准虚拟交换机（vSS）"><a href="#标准虚拟交换机（vSS）" class="headerlink" title="标准虚拟交换机（vSS）"></a>标准虚拟交换机（vSS）</h5><ul><li>独立管理：每台ESXi主机上的vSS独立管理，不同主机上的vSS配置相互独立</li><li>本地主机管理：配置和管理通过ESXi主机的Host Client或vSphere Clinet进行。</li><li>手动配置：手动为每个ESXi主机上分别配置，配置工作量大。</li><li>适用小型环境：适合规模较小或独立的环境，网络配置相对简单<br>ps：缺乏跨主机的集中管理和高级网络功能。</li></ul><h5 id="分布式虚拟交换机（vDS）"><a href="#分布式虚拟交换机（vDS）" class="headerlink" title="分布式虚拟交换机（vDS）"></a>分布式虚拟交换机（vDS）</h5><ul><li>集中管理：能够跨多个ESXi主机统一配置管理</li><li>视图统一：提供网络配置视图，简化大规模环境中的网络管理。</li><li>集中配置：可以在vCenter Server中一次性配置和管理所有相关ESXi主机上的网络设备</li><li>适用于大环境：适合规模大，复杂的，网络配置需求高的。</li></ul><p>ps：拥有比较高级的功能，入Private VLAN，网络IO控制（NetIOC），分布式端口镜像（Port Mirroring）/简化迁移能够网络配置一起迁移，无需重新配置。</p><h5 id="VLAN-和Private-VALN"><a href="#VLAN-和Private-VALN" class="headerlink" title="VLAN 和Private VALN"></a>VLAN 和Private VALN</h5><ol><li>VLAN: </li></ol><ul><li>主要通过交换机端口配置，将交换机端口分到不同的VLAN中。每个VLAN都有唯一的VLAN ID</li><li>设备之间通信得在同一VLAN进行，不同VLAN之间通信需要通过三层设备（如路由器，三层交换机）</li></ul><ol start="2"><li>Private VLAN</li></ol><ul><li>进一步细分VLAN内部的子VLAN，从而提供更精细的流量隔离和控制。</li><li>避免VLAN ID的浪费，适合大规模网络环境。</li></ul><h6 id="Private实现"><a href="#Private实现" class="headerlink" title="Private实现"></a>Private实现</h6><ol><li>Private VLAN将一个VLAN划分为主VLAN（Primary VLAN）和子VLAN（Secondary VLAN）。子VLAN又分为两种类型：Isolated VLAN和Community VLAN。</li></ol><ul><li>Primary VLAN：主VLAN，包含所有的Secondary VLAN。</li><li>Isolated VLAN：隔离VLAN，主机只能与Promiscuous端口通信，不能与其他任何端口通信。</li><li>Community VLAN：社区VLAN，主机可以与同一个Community VLAN内的其他主机和Promiscuous端口通信，但不能与其他Community VLAN或Isolated VLAN内的主机通信。</li><li>Promiscuous端口：可以与所有子VLAN内的端口通信，通常用于连接网关或路由器等设备。</li></ul><h5 id="vDS和vSS的区别"><a href="#vDS和vSS的区别" class="headerlink" title="vDS和vSS的区别"></a>vDS和vSS的区别</h5><p>管理上，vSS独立管理（每个ESXi独立配置），vDS集中管理（跨多个ESXi主机统一配置）<br>功能上，vSS网络配置简单，vDS提供高级网络功能。</p><h3 id="Datastore"><a href="#Datastore" class="headerlink" title="Datastore"></a>Datastore</h3><ul><li>Datastore是一个逻辑存储单元，由ESXi主机创建和管理。</li><li>它可以基于不同类型的物理存储，如本地硬盘、NFS共享、iSCSI目标和SAN存储。</li><li>Datastore用于存储虚拟机的虚拟磁盘文件（.vmdk）、配置文件（.vmx）、ISO映像文件以及其他虚拟机相关的数据。</li></ul><h4 id="数据存储类型及其特点"><a href="#数据存储类型及其特点" class="headerlink" title="数据存储类型及其特点"></a>数据存储类型及其特点</h4><ol><li>本地</li></ol><ul><li>直接连接单个ESXi主机的存储设备，SATA，SAS，SSD硬盘</li></ul><ol start="2"><li>SAN（Storage Area Network）</li></ol><ul><li>高性能，低延迟的存储网络，通常使用光纤通道或iSCSI协议连接</li><li>提供集中管理和共享存储</li></ul><ol start="3"><li>NAS（Network Attached Storage）</li></ol><ul><li>通过标准网络协议（IFS或SMB）访问存储设备</li><li>适用于文件级存储需求</li></ul><ol start="4"><li>vSAN（Virtual SAN）</li></ol><ul><li>VM的分布式存储解决方案，集群中所有ESXi主机的本地存储集合成一个逻辑数据存储。</li><li>提供高性能，可扩展共享存储，支持高可用性。</li></ul><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><ul><li>VMFS： 块存储，如SAN和本地存储。</li><li>NFS：网络附加存储如NAS。</li><li>vSAN:分布式存储解决方案。</li></ul><h3 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h3><p>用于管理和分配计算资源（如CPU和内存）。</p><h4 id="资源池的关键特性"><a href="#资源池的关键特性" class="headerlink" title="资源池的关键特性"></a>资源池的关键特性</h4><ol><li><strong>资源分配</strong>：<ul><li><strong>预留（Reservation）</strong>：确保虚拟机或资源池可以使用的最小资源量。预留的资源保证在所有者需要时始终可用。</li><li><strong>限制（Limit）</strong>：资源池或虚拟机可以使用的最大资源量。限制防止单个实体使用过多资源，影响其他实体的性能。</li><li><strong>份额（Shares）</strong>：定义资源争用时的相对优先级。份额是一个权重，用于确定在资源紧张时各个虚拟机或资源池的优先级。</li></ul></li><li><strong>灵活的资源管理</strong>：<ul><li>动态调整资源：管理员可以在不影响虚拟机运行的情况下动态调整资源池的配置。</li><li>自动化资源分配：配合VMware的DRS（分布式资源调度），可以自动平衡资源池之间的负载。</li></ul></li><li><strong>资源池的层次结构</strong>：<ul><li><strong>根资源池（Root Resource Pool）</strong>：默认存在于每个主机或集群中，是最顶层的资源池。</li><li><strong>子资源池（Child Resource Pool）</strong>：创建在根资源池或其他资源池下，形成树状结构。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;是vmware官方开发的一套虚拟化平台&lt;/p&gt;
&lt;h2 id=&quot;能够干什么&quot;&gt;&lt;a href=&quot;#能够干什么&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="VMware" scheme="https://kalyan-zitiu.github.io/categories/VMware/"/>
    
    
    <category term="虚拟化" scheme="https://kalyan-zitiu.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CNI</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/05/CNI/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/05/CNI/</id>
    <published>2024-07-05T01:51:24.000Z</published>
    <updated>2024-07-05T03:01:35.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>定义容器运行时，如何配置网络接口，以便容器可以网络通信。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ul><li>关注网络连接和网络解除连接</li><li>支持各种不同的网络配置要求</li><li>通过各种不同的网络解决方案解决网络配置。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>当一个Pod被创建时，k8s调用CNI插件来为pod配置网络，通常包括分配IP地址，设置网络路由和创建网络接口等任务。CNI插件负责把pod连接到一个预先的环境，保证pod之间的网络通信。</p><h2 id="常见的-CNI-插件："><a href="#常见的-CNI-插件：" class="headerlink" title="常见的 CNI 插件："></a>常见的 CNI 插件：</h2><ul><li><strong>Calico</strong>：提供高性能的网络和网络策略，支持跨主机的网络隔离。</li><li><strong>Flannel</strong>：简单易用，主要用于创建一个覆盖网络，允许 Pod 跨节点通信。</li><li><strong>Weave Net</strong>：提供一个强大的网络和网络策略，支持自动发现和网络隔离。</li><li><strong>Cilium</strong>：使用 BPF（Berkeley Packet Filter）来提供网络安全、策略执行和负载均衡功能。</li></ul><h3 id="1-Calico"><a href="#1-Calico" class="headerlink" title="1. Calico"></a>1. <strong>Calico</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>高性能</strong>：Calico 使用 BGP（边界网关协议）进行路由，避免了封装和解封装的开销，从而提供高性能的网络连接。</li><li><strong>网络策略</strong>：Calico 提供强大的网络策略功能，允许用户定义细粒度的访问控制规则。</li><li><strong>可扩展性</strong>：适用于大规模集群，能够处理成千上万的节点和 Pod。</li><li><strong>安全性</strong>：支持网络隔离和加密，确保数据在传输过程中安全。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>大规模生产环境</strong>：由于其高性能和可扩展性，Calico 非常适合大规模生产环境。</li><li><strong>需要严格网络策略的环境</strong>：如果需要细粒度的网络访问控制和安全策略，Calico 是一个理想的选择。</li></ul><h3 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. <strong>Flannel</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>简单易用</strong>：Flannel 设计简单，易于部署和管理。</li><li><strong>覆盖网络</strong>：主要提供覆盖网络，使用 UDP、VXLAN 或 host-gw 模式来封装跨主机的容器流量。</li><li><strong>轻量级</strong>：适合中小规模的集群，不需要复杂的配置。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>中小规模集群</strong>：由于其简单性和轻量级特性，Flannel 适用于中小规模的 Kubernetes 集群。</li><li><strong>快速部署</strong>：如果需要快速部署一个 Kubernetes 集群，Flannel 是一个不错的选择。</li></ul><h3 id="3-Weave-Net"><a href="#3-Weave-Net" class="headerlink" title="3. Weave Net"></a>3. <strong>Weave Net</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>自发现网络</strong>：Weave Net 能够自动发现和管理网络配置，简化了网络管理。</li><li><strong>网络加密</strong>：支持网络流量加密，确保数据在传输过程中的安全性。</li><li><strong>多云支持</strong>：能够跨多个云提供商和本地数据中心创建统一的网络。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>多云环境</strong>：Weave Net 非常适合需要跨多个云提供商和本地数据中心的环境。</li><li><strong>需要网络加密的环境</strong>：如果需要确保网络流量的安全性，Weave Net 是一个理想的选择。</li></ul><h3 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. <strong>Cilium</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>基于 BPF</strong>：Cilium 使用 Linux 内核的 BPF 技术来实现高性能和可扩展的网络功能。</li><li><strong>Layer 7 支持</strong>：支持 HTTP/HTTPS、gRPC 等 Layer 7 协议的负载均衡和安全策略。</li><li><strong>可见性和监控</strong>：提供丰富的网络可见性和监控功能，帮助用户了解网络流量和性能。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要高级网络功能的环境</strong>：Cilium 非常适合需要高级网络功能和安全策略的环境。</li><li><strong>微服务架构</strong>：由于其对 Layer 7 协议的支持，Cilium 非常适合微服务架构。</li></ul><h3 id="5-Canal"><a href="#5-Canal" class="headerlink" title="5. Canal"></a>5. <strong>Canal</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>结合了 Flannel 和 Calico</strong>：Canal 将 Flannel 的简单性和 Calico 的网络策略功能结合在一起。</li><li><strong>灵活性</strong>：提供了 Flannel 的覆盖网络和 Calico 的网络策略，适用于多种场景。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要简单网络和策略控制的环境</strong>：Canal 适用于需要简单网络配置和基本网络策略控制的环境。</li><li><strong>中小规模集群</strong>：由于其灵活性和简单性，Canal 适用于中小规模的 Kubernetes 集群。</li></ul><h3 id="6-Kube-Router"><a href="#6-Kube-Router" class="headerlink" title="6. Kube-Router"></a>6. <strong>Kube-Router</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>综合功能</strong>：Kube-Router 提供网络路由、网络策略和服务代理功能。</li><li><strong>高性能</strong>：使用 BGP 进行路由，提供高性能的网络连接。</li><li><strong>易于部署</strong>：集成了多个网络功能，简化了部署和管理。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要综合网络功能的环境</strong>：Kube-Router 适用于需要综合网络功能（如路由、策略和服务代理）的环境。</li><li><strong>高性能需求</strong>：由于其高性能特性，Kube-Router 适用于对网络性能有较高要求的环境。</li></ul><h3 id="7-Multus"><a href="#7-Multus" class="headerlink" title="7. Multus"></a>7. <strong>Multus</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>多网络支持</strong>：Multus 允许一个 Pod 连接到多个网络，支持多种 CNI 插件的组合使用。</li><li><strong>灵活性</strong>：提供了极大的灵活性，适用于复杂的网络需求。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>复杂网络需求</strong>：Multus 适用于需要多个网络接口和复杂网络配置的环境。</li><li><strong>多 CNI 插件组合</strong>：如果需要同时使用多个 CNI 插件，Multus 是一个理想的选择。</li></ul>]]></content>
    
    
    <summary type="html">容器网络接口</summary>
    
    
    
    <category term="K8s" scheme="https://kalyan-zitiu.github.io/categories/K8s/"/>
    
    <category term="CNI" scheme="https://kalyan-zitiu.github.io/categories/K8s/CNI/"/>
    
    
    <category term="Kubernets" scheme="https://kalyan-zitiu.github.io/tags/Kubernets/"/>
    
  </entry>
  
  <entry>
    <title>CRI容器运行时接口</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/04/CRI/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/04/CRI/</id>
    <published>2024-07-04T08:22:37.000Z</published>
    <updated>2024-07-22T01:26:10.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRI-容器运行时接口"><a href="#CRI-容器运行时接口" class="headerlink" title="CRI (容器运行时接口)"></a>CRI (容器运行时接口)</h1><p>了解CRI之前，我们先了解一下什么是RPC</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  一种常用的通信机制，运行程序调用位于远程计算机上的行数或方法，就像调用本地对象一眼。RPC抽象了底层的网络通信细节，使得开发者可以更加专注与业务逻辑的开发，不必过多担心网络相关性的复杂性。</p><h3 id="RPC工作原理"><a href="#RPC工作原理" class="headerlink" title="RPC工作原理"></a>RPC工作原理</h3><h4 id="客户端调用过程"><a href="#客户端调用过程" class="headerlink" title="客户端调用过程"></a>客户端调用过程</h4><ol><li>客户端程序调用一个本地的存根（stub）函数，这个存根代表远程函数</li><li>存根将函数调用的参数打包成一个消息，通过网络发送给服务端</li><li>客户端等待服务端响应</li></ol><h4 id="服务端处理过程"><a href="#服务端处理过程" class="headerlink" title="服务端处理过程"></a>服务端处理过程</h4><ol><li>服务器收到消息，解包得到调用参数。</li><li>服务端调用本地实际函数，执行必要的处理。</li><li>处理完毕后，服务端将结果打包并发送回客户端。<h4 id="客户端接收过程"><a href="#客户端接收过程" class="headerlink" title="客户端接收过程"></a>客户端接收过程</h4></li><li>客户端存根收到响应消息，解包得到结果</li><li>客户端的调用像本地执行一样，得到从远程服务器返回的结果。</li></ol><h3 id="RPC特点"><a href="#RPC特点" class="headerlink" title="RPC特点"></a>RPC特点</h3><ul><li>封装:隐藏网络通信细节，开发者无需直接处理socket编程或其他通信协议细节</li><li>同步:默认同步，即客户端调用一个远程方法时候，回阻塞知道得到结果，尽管如此，许多现代RPC框架支持异步调用。</li><li>透明:</li></ul><h3 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h3><ul><li><p>Finagle：一个构建高并发，分布式系统的异步RPC库，用Scala语言编写，但可以与其他JVM语言一起使用，适合用于高扩展，弹性和容错（异步编程模型，有效地处理大量并发请求，不会阻塞线程，支持多种协议，内置负载均衡）</p></li><li><p>gRPC：由Google开发，基于HTTP/2协议，支持多种语言，能够提供高性能的通信。gRPC使用Protocol Buffers作为其接口定义语言和消息序列化格式。</p></li><li><p>Apache Thrift：由Facebook开发，支持跨语言服务的开发，使用自定义的IDL (Interface Definition Language) 来定义数据类型和服务接口。</p></li><li><p>JSON-RPC和XML-RPC：这些是较轻量级的RPC实现，使用JSON和XML格式分别进行数据序列化，易于与Web技术集成。</p></li></ul><h3 id="RPC应用场景"><a href="#RPC应用场景" class="headerlink" title="RPC应用场景"></a>RPC应用场景</h3><ul><li><p>微服务架构：在微服务架构中，各个服务组件常常需要进行网络通信，RPC提供了一种高效的方式来实现服务间的调用。</p></li><li><p>分布式计算：在需要多个节点共同完成计算任务的场景中，RPC可以用来协调各个节点之间的工作。</p></li></ul><p>让我再在了解CRI之前，先清楚什么是容器的执行以及生命周期</p><h2 id="容器执行和生命周期"><a href="#容器执行和生命周期" class="headerlink" title="容器执行和生命周期"></a>容器执行和生命周期</h2><p>容器的执行和生命周期是指容器从创建到终止的整个过程，涉及到创建，启动，运行，停止和删除。</p><ul><li>创建（Pre-production/Planning）：<br>就像电影制作前的筹备阶段，需要确定剧本、演员、场地等。在 Kubernetes 中，创建容器涉及配置容器的环境，如定义容器的镜像、资源限制（CPU、内存）、网络设置等。</li><li>启动（Production/Shooting）：<br>类似于电影开始拍摄。容器的启动阶段是指实际上将容器镜像运行起来。在这个阶段，容器内部的应用开始执行其预定任务，比如启动一个 Web 服务器、数据库服务等。</li><li>运行（Release/Screening）：<br>就像电影的放映过程。容器成功启动后，它会进入运行状态。在这个阶段，容器内的应用对外提供服务，如处理网络请求、执行数据处理等。</li><li>停止（Ending）：<br>类似于电影放映结束。当容器需要更新或不再需要时，它会被停止。停止容器通常意味着停止容器内部的应用进程。</li><li>删除（Post-production/Cleanup）：<br>就像电影拍摄后的清理阶段。在容器的生命周期的最后阶段，容器会被彻底删除，包括其在节点上的所有数据。这确保了不会留下无用的资源或数据。</li></ul><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>允许用户在容器的特殊阶段进行自定义操作。</p><h4 id="PostStart"><a href="#PostStart" class="headerlink" title="PostStart"></a>PostStart</h4><p><code>PostSrart</code>是在容器创建并启动后立即执行的钩子，这个钩子的执行时间是容器入口命令开始执行之后，但是并不保证是容器的应用程序完全启动之后再再执行。</p><p>ps：若是PostStart钩子启动失败，那么容器不会被杀死或者重启，钩子启动失败的记录会写入日志中。</p><h4 id="PreStop"><a href="#PreStop" class="headerlink" title="PreStop"></a>PreStop</h4><p><code>PreStop</code>是容器被终止钱执行的钩子。当k8s需要停止容器时，首先调用PreStop钩子，然后才会执行容器的终止过程。经常用于优雅的关闭应用程序，保存状态，执行清理任务。</p><p>ps：钩子是会延迟容器的终止过程的，因为k8s会等待钩子执行完成后才会发送SIGTERM信号停止容器。</p><h2 id="CRI是什么"><a href="#CRI是什么" class="headerlink" title="CRI是什么"></a>CRI是什么</h2><p>简单理解的话可以理解成一个适配器，就是为了管理不同容器运行时进行交互的一套标准接口。主要的作用是为了解决k8s直接依赖特定容器运行时的问题。主要是启动停止容器，拉取容器镜像，查询容器状态，管理容器生命周期。</p><ol><li>统一接口是通过RPC内gRPC框架实现的。</li><li>解耦合，完成了k8s与docker直接集成的紧密耦合关系。</li><li>可以让开发者通过自我需求或喜爱来选择合适的容器进行时。</li></ol><h3 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h3><ul><li>首先是使用了能够适应高并发低延迟的通信的HTTP/2，再头部压缩和多路复用请求等高效传输机制。</li><li>gRPC支持双向流，允许服务器和客户端再长连接中实时发送和接受消息。</li></ul><p>只有了解这么多了，gRPC还有很多有用的功能，适用场景也比较广，可能日后碰上这种场景后再继续了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRI-容器运行时接口&quot;&gt;&lt;a href=&quot;#CRI-容器运行时接口&quot; class=&quot;headerlink&quot; title=&quot;CRI (容器运行时接口)&quot;&gt;&lt;/a&gt;CRI (容器运行时接口)&lt;/h1&gt;&lt;p&gt;了解CRI之前，我们先了解一下什么是RPC&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="K8s" scheme="https://kalyan-zitiu.github.io/categories/K8s/"/>
    
    <category term="CRI" scheme="https://kalyan-zitiu.github.io/categories/K8s/CRI/"/>
    
    
    <category term="CRI" scheme="https://kalyan-zitiu.github.io/tags/CRI/"/>
    
  </entry>
  
  <entry>
    <title>Linux从核心到边缘</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-01T15:42:37.000Z</published>
    <updated>2024-07-02T03:52:51.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux从核心到边缘"><a href="#Linux从核心到边缘" class="headerlink" title="Linux从核心到边缘"></a>Linux从核心到边缘</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>  今天有面试一家专注云原生产品的企业，有问到一个问题，就是你还有用过其他的Linux发行版吗，突然顿时觉得很惭愧，而且有一些基础的Linux问题居然发现我忘记了没有回答出来。而且仔细思考了一下，确实在大学期间仅仅只了解过Ubuntu偏向新手和私人开发的linux发行版，而且在命令上似乎只是停留在一些基础的操作（甚至有一些基础命令还忘记了），并没有深入的了解过Linux的内核。而且今天面试官说了一句话，就是从需求出发的科技探索更有利于我们进步。有的时候确实会把某些技术当作工具，但事实上确实是工具，作为一名希望在IT行业继续深耕的我，似乎越来越缺乏对技术美的欣赏，在大学没有多少生活压力的时期最应该体验这种美感的时候，却好像被一些<strong>保姆级</strong>教学一步步蒙蔽了眼睛。结果虽然出来了，但是可能对过程保留不多的记忆或者理解。只能说有时候学习的结果并不重要，重要的是一些有容错的过程。</p><h2 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h2><ul><li>内核类似一个资源的管理程序，负载资源调度到需要的系统进程，我看有些理解可以把内核理解成一个库，有了一组面向系统命令，系统调用应用程序来说，就像调用普通函数一样。其实内核也可以理解成一个桥梁，能够练习硬件和上层应用点的桥梁。一涉及到底层的东西就越来越抽象，还是能够用一些比喻理解比较好。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/3435502-20240507214431792-1257148225.png" alt="img"></li></ul><h2 id="内核的角色"><a href="#内核的角色" class="headerlink" title="内核的角色"></a>内核的角色</h2><ul><li>内核是管理计算机的硬件资源的重要角色，就比如CPU，内存，存储设备和输入输出的设别。</li><li>内核主要威威上层提供了抽象的操作接口，让我们不需要关心硬件的细节。</li><li>内核维护不同程序和用户之间的安全界限，确保学习通的稳定和安全。</li></ul><h2 id="内核的主要组成部分"><a href="#内核的主要组成部分" class="headerlink" title="内核的主要组成部分"></a>内核的主要组成部分</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程调度："><a href="#进程调度：" class="headerlink" title="进程调度："></a>进程调度：</h4><ul><li>Linux内核使用多种调度算法，决定那个进程获得CPU时间，确保各个进程公平使用CPU资源。<h4 id="进程同步："><a href="#进程同步：" class="headerlink" title="进程同步："></a>进程同步：</h4></li><li>内核提供了多种机制，处理进程或线程之间的同步，防止数据争抢，确保线程安全。</li></ul><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul><li>支持多种进程间通信IPC方法，包括信号，管道，消息队列，共享内存和套接字。</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>虚拟内存：程序使用比实际物理内存更多的地址空间，通过使用分页/分段来实现</li><li>内存分配：内核提供多级分配框架，包括页分配器，slab分配器（说实话有够抽象的。）</li><li>交换空间：当物理内存不足时，内核可以将内存页移动到磁盘上的交换控件，以来释放内存。<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3></li><li>支持ext4，XFS，Btrfs，NFS和更多，以适应不同的存储需求和性能特点。</li><li>虚拟文件系统，VFS提供一个统一接口来访问不同文件系统</li><li>文件操作，内核提供系统调用，open，read，write，close。<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3></li><li>字符设备和块设备：Linux区分字符设备，键盘鼠标和块设备硬盘驱动器。</li><li>模块化驱动：Linux支持动态加载和卸载设备驱动模块，这允许不重启系统的情况下添加或更新驱动程序。<h3 id="网络栈"><a href="#网络栈" class="headerlink" title="网络栈"></a>网络栈</h3></li><li>协议实现：内核实现了各种网络协议，IP，TCP，UDP和ICMP</li><li>网络接口：通过网络接口与各种网络硬件进行交互，如以太网卡，无限适配</li><li>网络数据处理：内核处理数据包路由，转发，过滤，支持高级网络功能，如虚拟网络，网络安全规则等。</li></ul><h2 id="linux防火墙"><a href="#linux防火墙" class="headerlink" title="linux防火墙"></a>linux防火墙</h2><ul><li>防火墙系统主要基于iptable，以及比较新的nftables系统，运行管理员配置规则，控制进出网络接口的数据包。</li></ul><ol><li>iptables是一个广泛使用防火墙工具，使用一组表来组织规则，每个表包含多个链，链中包含具体规则，主要有 filter默认表，nat网络地址转换（处理进出接口的地址和端口转换），mangle用来修改数据包的内容，raw配置免除连接跟踪机制的数据包。</li></ol><h2 id="APT包管理"><a href="#APT包管理" class="headerlink" title="APT包管理"></a>APT包管理</h2><ul><li>使用的是.deb包格式，通过apt源来管理和安装软件包。</li><li>一般是使用的linux发行版有Ubuntu，Debian，Linux Mint等</li></ul><h3 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h3><p>  一般可以通过编辑/etc/apt/sourcer.list文件或者在sources.list.d目录下面，创建一个新的源。然后通过更新apt索引的方式。deb标识这是一个二进制的源，一般都会需要导入公钥，验证软件包的真实性，APT使用的是PGP签名，如果你源头是签名的，你需要的导入并信任该公钥，通常，源提供者会提供公钥和相应的导入命令。一般都是会直接把源echo进去，比较快捷。</p><h4 id="sources-list文件结构"><a href="#sources-list文件结构" class="headerlink" title="sources.list文件结构"></a>sources.list文件结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type uri suite &#123;component&#125;</span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted</span><br></pre></td></tr></table></figure><ul><li>type:源的类型，通常是 <code>deb</code> 用于二进制包，或 <code>deb-src</code> 用于源代码包</li><li>uri:源的URI</li><li>suite:发行版的代号,buster,bullseye,focal,bionic</li><li>component:可选，指定源中的区域或分区 </li></ul><h2 id="YUM-DNF包管理"><a href="#YUM-DNF包管理" class="headerlink" title="YUM,DNF包管理"></a>YUM,DNF包管理</h2><ul><li>基于RPM的Linux发行版，使用.repo文件来定义软件仓库。</li><li>一般是使用的linux发行版有Fedora，CentOS和RHEL等</li></ul><h3 id="添加源-1"><a href="#添加源-1" class="headerlink" title="添加源"></a>添加源</h3><p>一般添加源可以创建一个新的文件或者编辑指定现有文件，这个和apt包管理的添源方式类似。但是他们的文件结构格式大不相同</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仓库的唯一标识符。这个ID在 .repo 文件中必须是唯一的</span></span><br><span class="line"><span class="section">[docker-ce-stable]</span></span><br><span class="line"><span class="comment"># 仓库的描述性名称</span></span><br><span class="line"><span class="attr">name</span>=Docker CE Stable - <span class="variable">$basearch</span> </span><br><span class="line"><span class="comment"># 仓库的基本URL，指向包含RPM包的目录</span></span><br><span class="line"><span class="attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="number">7</span>/<span class="variable">$basearch</span>/stable</span><br><span class="line"><span class="comment"># 定是否启用该仓库。设置为 1 表示启用，0 表示禁用</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指定是否检查GPG签名。设置为 1 表示启用GPG签名检查</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指向GPG公钥文件的路径，用于验证包的签名。</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br></pre></td></tr></table></figure><h3 id="更新方式也和apt管理不同"><a href="#更新方式也和apt管理不同" class="headerlink" title="更新方式也和apt管理不同"></a>更新方式也和apt管理不同</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum(dnf) makecache fast</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里为止，我依然觉得我还是不够了解Linux内核，总感觉没有想象的那么简单。可能过几天忙过了可以开始了解和学习一下KVM可能那里会给我一些答案。希望自己也能开始重新拾取对知识的渴望和动力吧。</p>]]></content>
    
    
    <summary type="html">一次对Linux的探讨以及自我端正</summary>
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/tags/Linux/"/>
    
    <category term="内核" scheme="https://kalyan-zitiu.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>简易高弹性B/S架构</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/</id>
    <published>2024-04-12T12:00:00.000Z</published>
    <updated>2024-06-24T07:59:40.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VPC架构设计"><a href="#VPC架构设计" class="headerlink" title="VPC架构设计"></a><strong>VPC架构设计</strong></h3><p>一个虚拟私有云（VPC）的结构，名称为“MyVPC”。该VPC包含4个子网，分布在两个可用区（us-east-1a和us-east-1b）中。其中，us-east-1a包含PublicSubnet1和PrivateSubnet1，us-east-1b包含PublicSubnet2和PrivateSubnet2。此外，该VPC还配置了两个路由表：PrivateRouteTable和PublicRouteTable，其中一个路由表的ID为“rtb-08c231d3d0fbbf2c2”。最后，图中显示了两个网络设备：MyInternetGateway和MyNatGateway。这些组件共同构成了一个典型的VPC架构，用于管理和控制网络流量的路由和访问。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154008942.png" alt="image-20240624154008942"></p><h3 id="B-S架构设计"><a href="#B-S架构设计" class="headerlink" title="B/S架构设计"></a><strong>B/S架构设计</strong></h3><p>这幅图展示了一个详细的虚拟私有云（VPC）架构，包含多个AWS组件和服务。该架构包括一个名为”MyVPC”的VPC，内部包含多个子网（如PublicSubnetA、PublicSubnetB、PrivateSubnetA、PrivateSubnetB）和路由表（如PublicRouteTable、PrivateRouteTable）。此外，还配置了网络ACL（如PublicNetworkACL、PrivateNetworkACL）来控制子网的入站和出站流量。网络设备方面，包含一个InternetGateway用于公共子网的互联网访问，以及一个NATGateway和其对应的弹性IP用于私有子网的互联网访问。安全组（如PublicInstanceSecurityGroup、PrivateInstanceSecurityGroup）用于实例的流量控制。实例部分，包括PublicInstanceA、PublicInstanceB、PrivateInstanceA、PrivateInstanceB等。</p><p>该架构使用堡垒机来登录实例，VPC通过CloudFormation模板构建，并基于CloudWatch指标实现自动扩展（AutoScaling）。会话状态保存在DynamoDB中，数据库缓存使用Amazon<br>ElastiCache for<br>Redis。此外，还使用消息队列SQS来处理消息。这些组件通过复杂的连接关系，构成了一个集成的、高度可扩展和可靠的网络架构，用于管理和控制流量的路由、访问和安全性，适用于在云环境中部署和管理各种应用和服务。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154015927.png" alt="image-20240624154015927"></p><h3 id="Auto-Scaling组配置"><a href="#Auto-Scaling组配置" class="headerlink" title="Auto Scaling组配置"></a><strong>Auto Scaling组配置</strong></h3><p>定义了一个自动扩展启动配置（Launch<br>Configuration），指定了使用的AMI镜像、实例类型、安全组、用户数据等信息，确保新实例能够按照指定的配置启动并运行。接着创建了一个自动扩展组（Auto<br>Scaling<br>Group），设置了VPC子网、启动配置、最小和最大实例数量、目标组等参数，以便根据负载情况自动调整实例数量。同时，配置了CloudWatch告警监控CPU利用率高低，当CPU利用率超过或低于阈值时，会触发相应的扩展或缩容策略。具体而言，定义了两个告警，分别用于CPU利用率超过70%和低于30%时的自动扩展和缩容操作。此外，还设置了扩展和缩容策略，包括调整实例数量、冷却时间等参数，以确保系统能够根据负载情况自动调整实例数量，实现自动化弹性扩展和收缩。整体而言，这个配置文件实现了一个基于CPU利用率的自动扩展机制，能够根据实际负载情况动态调整实例数量，提高系统的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154021722.png" alt="image-20240624154021722"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154027789.png" alt="image-20240624154027789"></p><h3 id="ALB配置"><a href="#ALB配置" class="headerlink" title="ALB配置"></a><strong>ALB配置</strong></h3><p>这个应用负载均衡器（ALB）在你的架构中担任了至关重要的角色，确保了应用的高效运行和用户体验的优化。具体来说，ALB将进入的应用程序流量智能地分配到多个目标（如EC2实例），平衡了负载并防止了单点故障，从而保证了系统的高可用性和可扩展性。通过定期进行健康检查，ALB确保只有健康的实例接收流量，如果某个实例出现故障，它会自动将流量重定向到其他健康的实例，提高了应用的可靠性。</p><p>此外，ALB支持基于内容的路由功能，可以根据请求的URL路径、HTTP头、查询字符串等，将流量路由到不同的目标组，使得你可以更灵活地管理流量，比如将静态内容和动态内容分开处理，从而优化资源使用。ALB还可以与AWS的安全服务（如AWS<br>WAF和ACM）集成，提供强大的安全防护，支持SSL/TLS终止，确保传输层的安全，同时简化了证书管理。通过与Auto<br>Scaling集成，ALB可以根据流量负载自动增加或减少目标实例的数量，确保了应用能够应对流量高峰，同时优化了成本。ALB还与CloudWatch无缝集成，提供详细的监控和日志记录功能，让你可以实时监控流量模式、请求响应时间等关键指标，快速识别和解决潜在问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154059526.png" alt="image-20240624154059526"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154041177.png" alt="image-20240624154035908"></p><h3 id="通过CloudFormation进行快速实施过程"><a href="#通过CloudFormation进行快速实施过程" class="headerlink" title="通过CloudFormation进行快速实施过程"></a><strong>通过CloudFormation进行快速实施过程</strong></h3><p>首先，通过CloudFormation创建一个VPC和多个子网，配置Internet网关和NAT网关以实现公共和私有网络的连接。然后设置安全组并启动Bastion主机作为跳板机。接着，配置目标组和创建应用负载均衡器，设置监听器以将流量引导到后端实例。定义启动配置并基于此配置创建自动伸缩组，实现根据负载情况动态调整实例数量。继续创建RDS子网组和部署RDS实例，确保数据库服务的高可用性和持久性。创建DynamoDB表以存储非结构化数据，实现快速读写和扩展性。配置ElastiCache子网组并部署ElastiCache集群，提供高性能的缓存服务，加速数据访问。最后，创建SQS队列用于处理消息队列，确保应用程序之间的异步通信。在完成上述步骤后，获取关键资源的信息，包括Bastion主机的公有IP地址用于远程访问，负载均衡器的DNS名称用于访问应用程序，RDS实例的终端节点用于数据库连接，DynamoDB表名用于数据存储，Redis缓存的终端节点用于快速数据缓存，以及SQS队列的URL用于消息处理。这样可以确保整个架构的部署和运行顺利进行。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154107810.png" alt="image-20240624154107810"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154125600.png" alt="image-20240624154125600"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154118431.png" alt="image-20240624154114091"></p><h3 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a><strong>遇到的问题与解决方案</strong></h3><p>权限问题：如果遇到权限不足的问题，确保使用的IAM用户或角色具有必要的权限，比如创建VPC、子网、EC2实例、RDS实例等权限。</p><p>资源限制问题：如果遇到资源限制（如EC2实例配额不足），可以通过联系AWS支持来提升配额。</p><p>网络配置问题：确保VPC和子网的CIDR块配置正确，避免重叠。确保安全组规则配置正确，允许所需的入站和出站流量。</p><p>模板语法错误：使用AWS<br>CloudFormation的模板验证工具来检查模板语法是否正确。</p><h3 id="测试方案与结果"><a href="#测试方案与结果" class="headerlink" title="测试方案与结果"></a><strong>测试方案与结果</strong></h3><h4 id="基于CloudWatch的AutoScaling"><a href="#基于CloudWatch的AutoScaling" class="headerlink" title="基于CloudWatch的AutoScaling"></a><strong>基于CloudWatch的AutoScaling</strong></h4><p>CloudWatch的Auto<br>Scaling是一种动态调整计算资源以匹配应用需求的机制，通过监控关键指标（如CPU利用率）来触发扩展或缩减操作。CloudWatch会收集和监控这些指标，并基于设定的阈值触发警报。当警报触发时，Auto<br>Scaling组会根据预定义的策略自动增加或减少EC2实例的数量。例如，当CPU利用率超过某个阈值时，Auto<br>Scaling会增加实例数量以处理高负载；当CPU利用率低于阈值时，Auto<br>Scaling会减少实例数量以节约成本。通过这种方式，Auto<br>Scaling确保了应用程序的高可用性和性能，同时优化了资源使用和成本效益。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154158215.png" alt="image-20240624154158215"></p><h4 id="DynamoDB保存会话状态"><a href="#DynamoDB保存会话状态" class="headerlink" title="DynamoDB保存会话状态"></a><strong>DynamoDB保存会话状态</strong></h4><p>在Web应用中，会话（Session） 是在用户与服务器之间的交互过程中维持状态的一种方式。HTTP协议本身是无状态的，这意味着每个请求都是独立的，服务器默认不会记住前一个请求的信息。会话状态技术允许服务器记住用户的状态信息（如用户是否已登录、用户的偏好设置等），这对于创建交互式Web应用是必要的。DynamoDB作为会话存储的后端，帮助Web应用维护用户的状态，提供连贯的用户体验，并且能够在用户数量激增时保持高性能和可靠性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154209751.png" alt="image-20240624154209751"></p><h4 id="使用消息队列SQS"><a href="#使用消息队列SQS" class="headerlink" title="使用消息队列SQS"></a><strong>使用消息队列SQS</strong></h4><p>使用AWS<br>SDK（例如Python的Boto3）向队列发送消息。首先，确保你已安装Boto3并配置了AWS凭证。接收消息也很简单。使用同样的SQS客户端，你可以从队列中拉取消息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154216362.png" alt="image-20240624154216362"></p><h4 id="使用ElastiCache-for-Redis数据库缓存"><a href="#使用ElastiCache-for-Redis数据库缓存" class="headerlink" title="使用ElastiCache for Redis数据库缓存"></a><strong>使用ElastiCache for Redis数据库缓存</strong></h4><p>ElastiCache for Redis 是一种由 AWS<br>托管的内存缓存服务，通过在内存中存储数据，提供极低的延迟和高吞吐量的数据访问能力，适用于实时分析、会话存储和排行榜等应用场景。它支持水平和垂直扩展，可以根据应用需求动态调整节点数量和实例规格，确保在流量高峰期依然高效运行。通过多可用区部署和自动故障转移功能，ElastiCache<br>for Redis<br>提供了高可用性和数据持久性，确保在节点故障时数据不丢失并迅速恢复。此外，ElastiCache<br>for Redis 是完全托管的服务，AWS<br>负责基础设施管理、软件更新、安全补丁和备份恢复，简化了管理工作，使开发者可以专注于应用开发。它还支持VPC、子网、安全组和加密功能，确保数据传输和存储的安全性。总之，ElastiCache<br>for Redis<br>提供了一个高效、可靠和安全的缓存解决方案，显著提升了数据访问速度和系统响应能力，简化了缓存管理和运维工作，使开发者能够专注于核心业务逻辑的开发。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154224745.png" alt="image-20240624154224745"></p><h4 id="实例与数据库连接"><a href="#实例与数据库连接" class="headerlink" title="实例与数据库连接"></a><strong>实例与数据库连接</strong></h4><p>为了使EC2实例与RDS实例互联，需要创建并配置两个安全组，一个用于EC2实例，另一个用于RDS实例。然后在RDS实例的安全组中添加入站规则，允许从EC2实例的安全组IP地址范围通过数据库端口（如3306）进行访问。最后，在EC2实例中配置数据库客户端，使用RDS实例的端点和端口号进行连接，从而实现网络通信与数据库操作。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154229517.png" alt="image-20240624154229517"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154234077.png" alt="image-20240624154234077"></p><h4 id="用CloudFormation进行VPC内容创建"><a href="#用CloudFormation进行VPC内容创建" class="headerlink" title="用CloudFormation进行VPC内容创建"></a><strong>用CloudFormation进行VPC内容创建</strong></h4><p>使用CloudFormation进行VPC创建可以自动化管理和部署完整网络架构。通过编写CloudFormation模板，可以创建一个VPC，设置其CIDR块，配置公共和私有子网，创建并连接Internet网关和NAT网关，并配置路由表和关联。这样不仅提高了部署效率，还减少了人为配置错误，确保网络架构的可重复性和一致性。例如，模板中配置了一个CIDR为10.0.0.0/16的VPC，包含两个公共子网和两个私有子网，并分别配置了路由表和NAT网关，以保证私有子网具有访问外部网络的能力。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="string">&#x27;2010-09-09&#x27;</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">AWS</span> <span class="string">CloudFormation</span> <span class="string">Template</span> <span class="string">for</span> <span class="string">B/S</span> <span class="string">Architecture</span> <span class="string">with</span> <span class="string">VPC,</span> <span class="string">Subnets,</span> <span class="string">RDS,</span> <span class="string">EC2,</span> <span class="string">Auto</span> <span class="string">Scaling,</span> <span class="string">DynamoDB,</span> <span class="string">ElastiCache,</span> <span class="string">and</span> <span class="string">SQS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">MyVPC:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPC</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">EnableDnsSupport:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">EnableDnsHostnames:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyVPC</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.3</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">InternetGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::InternetGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyInternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">GatewayAttachment:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPCGatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">InternetGatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGatewayEIP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::EIP</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Domain:</span> <span class="string">vpc</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGatewayEIP</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::NatGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">AllocationId:</span> <span class="type">!GetAtt</span> <span class="string">NatGatewayEIP.AllocationId</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPublicRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">DependsOn:</span> <span class="string">GatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">GatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPrivateRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">NatGatewayId:</span> <span class="type">!Ref</span> <span class="string">NatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">WebServerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">HTTP,</span> <span class="string">RDP,</span> <span class="string">and</span> <span class="string">SSH</span> <span class="string">access</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">bastion</span> <span class="string">host</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Instance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostInstance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Load Balancer Security Group</span></span><br><span class="line">  <span class="attr">LoadBalancerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">access</span> <span class="string">to</span> <span class="string">Load</span> <span class="string">Balancer</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Application Load Balancer</span></span><br><span class="line">  <span class="attr">ApplicationLoadBalancer:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::LoadBalancer</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Name:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Subnets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line">      <span class="attr">Scheme:</span> <span class="string">internet-facing</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Target Group for Load Balancer</span></span><br><span class="line">  <span class="attr">TargetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">TargetGroupTwo:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Listener for Load Balancer</span></span><br><span class="line">  <span class="attr">LoadBalancerListenerHTTP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">LoadBalancerListenerCustomPort:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Auto Scaling Launch Configuration</span></span><br><span class="line">  <span class="attr">LaunchConfiguration:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::LaunchConfiguration</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">UserData:</span></span><br><span class="line">        <span class="attr">Fn::Base64:</span> <span class="type">!Sub</span> <span class="string">|</span></span><br><span class="line"><span class="string">          #!/bin/bash</span></span><br><span class="line"><span class="string">          yum update -y</span></span><br><span class="line"><span class="string">          yum install -y httpd nodejs unzip</span></span><br><span class="line"><span class="string">          systemctl start httpd</span></span><br><span class="line"><span class="string">          systemctl enable httpd</span></span><br><span class="line"><span class="string">          cd /var/www/html</span></span><br><span class="line"><span class="string">          aws s3 cp s3://myawsbucketkalyanzitiu/mysqlViewer.zip</span></span><br><span class="line"><span class="string">          unzip mysqlViewer.zip</span></span><br><span class="line"><span class="string">          rm mysqlViewer.zip</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          node /var/www/html/start.js &amp;</span></span><br><span class="line"><span class="string">          /opt/aws/bin/cfn-signal -e $? --stack $&#123;AWS::StackName&#125; --resource AutoScalingGroup --region $&#123;AWS::Region&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="comment"># Auto Scaling Group</span></span><br><span class="line">  <span class="attr">AutoScalingGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::AutoScalingGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VPCZoneIdentifier:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">LaunchConfigurationName:</span> <span class="type">!Ref</span> <span class="string">LaunchConfiguration</span></span><br><span class="line">      <span class="attr">MinSize:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">MaxSize:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">DesiredCapacity:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">TargetGroupARNs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyAutoScalingGroup</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Environment</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">Production</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># CloudWatch Alarm for Auto Scaling</span></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmHigh:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale up if CPU &gt; 70% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">70</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">GreaterThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleUpPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmLow:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale down if CPU &lt; 30% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">LessThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleDownPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scaling Policies</span></span><br><span class="line">  <span class="attr">ScaleUpPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ScaleDownPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">-1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DynamoDB Table</span></span><br><span class="line">  <span class="attr">DynamoDBTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::DynamoDB::Table</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TableName:</span> <span class="string">SessionTable</span></span><br><span class="line">      <span class="attr">AttributeDefinitions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">AttributeType:</span> <span class="string">S</span></span><br><span class="line">      <span class="attr">KeySchema:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">KeyType:</span> <span class="string">HASH</span></span><br><span class="line">      <span class="attr">ProvisionedThroughput:</span></span><br><span class="line">        <span class="attr">ReadCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">WriteCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">SessionTable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ElastiCache for Redis</span></span><br><span class="line">  <span class="attr">RedisCacheCluster:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::CacheCluster</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CacheNodeType:</span> <span class="string">cache.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">NumCacheNodes:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">VpcSecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">RedisCacheCluster</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">RedisSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::SubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Description:</span> <span class="string">&quot;Subnet group for Redis cache&quot;</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># SQS Queue</span></span><br><span class="line">  <span class="attr">SQSQueue:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::SQS::Queue</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">QueueName:</span> <span class="string">MyQueue</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MySQSQueue</span></span><br><span class="line">          </span><br><span class="line">  <span class="attr">MyDBSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBSubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBSubnetGroupDescription:</span> <span class="string">My</span> <span class="string">DB</span> <span class="string">Subnet</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RDS Instance for Multi-AZ Deployment</span></span><br><span class="line">  <span class="attr">DBInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBInstance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBName:</span> <span class="string">MyDatabase</span></span><br><span class="line">      <span class="attr">AllocatedStorage:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">DBInstanceClass:</span> <span class="string">db.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MasterUsername:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">MasterUserPassword:</span> <span class="string">admin123</span></span><br><span class="line">      <span class="attr">VPCSecurityGroups:</span> []</span><br><span class="line">      <span class="attr">DBSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line">      <span class="attr">MultiAZ:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyRDSInstance</span></span><br><span class="line">    <span class="attr">DeletionPolicy:</span> <span class="string">Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Outputs:</span></span><br><span class="line">  <span class="attr">DBInstanceEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the RDS instance&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">DBInstance.Endpoint.Address</span></span><br><span class="line">  <span class="attr">BastionHostPublicIp:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The public IP address of the bastion host&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">BastionHostInstance.PublicIp</span></span><br><span class="line">  <span class="attr">LoadBalancerDNSName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The DNS name of the Application Load Balancer&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">ApplicationLoadBalancer.DNSName</span></span><br><span class="line">  <span class="attr">DynamoDBTableName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The name of the DynamoDB table&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">DynamoDBTable</span> </span><br><span class="line">  <span class="attr">RedisCacheEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the Redis cache cluster&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">RedisCacheCluster.RedisEndpoint.Address</span></span><br><span class="line">  <span class="attr">SQSQueueURL:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The URL of the SQS queue&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">SQSQueue</span></span><br></pre></td></tr></table></figure><h4 id="使用堡垒机登录实例"><a href="#使用堡垒机登录实例" class="headerlink" title="使用堡垒机登录实例"></a><strong>使用堡垒机登录实例</strong></h4><p>首先，通过SSH连接到堡垒机，以便安全地访问私有子网内的Web实例。登录堡垒机后，利用存储在堡垒机上的SSH密钥登录私有子网内的Web实例进行部署操作。有时使用密钥登录可能会显示“权限被拒绝”的错误，这通常是由于密钥文件权限设置不正确导致的。此时，可以通过运行chmod<br>400<br>path_to_your_private_key命令重新设置密钥文件权限，确保只有当前用户可以读取该文件，从而解决登录被拒绝的问题。通过这种方式，能够安全有效地管理和部署私有子网内的实例。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154256449.png" alt="image-20240624154256449"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154303065.png" alt="image-20240624154303065"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154308929.png" alt="image-20240624154308929"></p><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a><strong>性能评估</strong></h3><h4 id="负载均衡测试"><a href="#负载均衡测试" class="headerlink" title="负载均衡测试"></a><strong>负载均衡测试</strong></h4><p>通过性能监控对实例进行分流，显示不同ip型号的实例</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154334381.png" alt="image-20240624154334381"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154338428.png" alt="image-20240624154338428"></p><h4 id="数据库性能测试"><a href="#数据库性能测试" class="headerlink" title="数据库性能测试"></a><strong>数据库性能测试</strong></h4><p>显示了数据库性能测试中的几个关键指标，包括剩余存储空间、读写操作次数（IOPS）、网络接收与发送吞吐量等。图中显示在测试初期读写操作和网络传输活动较高，随后逐渐趋于平稳，表明数据库在高负载初期经过密集活动后恢复到稳定状态。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154345250.png" alt="image-20240624154345250"></p><h4 id="自动伸缩功能测试"><a href="#自动伸缩功能测试" class="headerlink" title="自动伸缩功能测试"></a><strong>自动伸缩功能测试</strong></h4><p>进行自动伸缩功能测试时，首先配置一个Auto<br>Scaling组，并设置其最小实例数为2，最大实例数为3。此外，创建缩放策略，当CPU利用率低于30%时减少实例数量，当CPU利用率高于70%时增加实例数量。启动测试后，可以观察到，当负载增加时，Auto<br>Scaling组中的实例数量从2个自动扩展到3个，而在负载减小时，实例数量则会减少回2个。这种自动调整实例数量的功能确保了应用在高负载时有足够的资源，同时在低负载时节省资源成本。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154404728.png" alt="image-20240624154404728"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154356696.png" alt="image-20240624154351414"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154414919.png" alt="image-20240624154414919"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154424766.png" alt="image-20240624154424766"></p><h4 id="项目部署效果测试"><a href="#项目部署效果测试" class="headerlink" title="项目部署效果测试"></a><strong>项目部署效果测试</strong></h4><p>项目架构部署在AWS云平台上，使用包含两个可用区的VPC，配置有公有和私有子网，互联网网关和NAT网关。核心部分是通过配置在互联网网关内的应用程序负载均衡器和Auto<br>Scaling组，实现Web实例的自动扩展，并将这些实例分布在两个可用区内。同时，RDS数据库配置了主备实例，确保数据的高可用性和可靠性。安全组进一步管理网络安全，确保系统的高可用性和灵活扩展性。</p><p>当负载均衡器正常运行时，提示项目成功启动。您可以通过访问以下URL连接到数据库并查看Web项目：</p><p><a href="http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/">http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/</a></p><p>这将能够直接访问部署在AWS上的Web应用，并与底层的数据库实例交互，确保应用的可靠运行和性能优化。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154510878.png" alt="image-20240624154510878"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154514651.png" alt="image-20240624154514651"></p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>EKS概述</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/</id>
    <published>2024-04-10T12:00:00.000Z</published>
    <updated>2024-06-30T10:38:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EKS"><a href="#EKS" class="headerlink" title="EKS"></a>EKS</h1><p>学校给的AWS沙盒快过期了，剩下几十🔪也不想浪费，突然发现居然有给EKS的权限，想到前几天自建K8S集群的经历，虽然可以熟悉集群流程，但是倘若在生产环境下，还是有安全高可用的托管平台舒服。</p><h2 id="架构结构"><a href="#架构结构" class="headerlink" title="架构结构"></a>架构结构</h2><p>学习一个东西，肯定是先了解概念以及大概的结构，由大入微，最重要的是要不断实践和尝试，通过实际操作来加深对该工具或技术的理解。</p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>首先是k8s，一个开源容器编排平台，源于Google的Borg。主要就是能够多平台进行自动化调度，修复，扩展，服务发现和负载，存储编排等重要功能。</p><p><img src="https://github.com/ben1234560/k8s_PaaS/raw/master/assets/1582188308711.png" alt="1582188308711"></p><h4 id="经典七大件"><a href="#经典七大件" class="headerlink" title="经典七大件"></a>经典七大件</h4><ol><li><p><strong>kube-apiserver</strong>：Kubernetes API服务器，提供了Kubernetes集群的API接口，负责接收和处理来自用户、控制器和其他组件的请求。</p></li><li><p><strong>kube-controller-manager</strong>：Kubernetes控制器管理器，包含多个控制器，负责监控集群状态并根据预定义的控制器逻辑进行调整，确保集群中的资源达到预期状态。</p></li><li><p><strong>kube-scheduler</strong>：Kubernetes调度器，负责根据Pod的调度策略（如资源需求、亲和性、反亲和性等）选择合适的Node节点来运行Pod。</p></li><li><p><strong>kubelet</strong>：每个Node节点上运行的Kubernetes代理，负责管理Node节点上的Pod和容器，与kube-apiserver通信，执行Pod的生命周期管理和监控。</p></li><li><p><strong>kube-proxy</strong>：Kubernetes网络代理，负责为Pod提供网络代理和负载均衡功能，实现Pod之间和Pod与外部网络的通信。</p></li><li><p><strong>etcd</strong>：分布式键值存储系统，用于存储Kubernetes集群的所有配置数据、状态信息和元数据，保证集群的一致性和可靠性。</p></li><li><p><strong>Container Runtime</strong>：容器运行时，负责在Node节点上创建和管理容器，常见的容器运行时包括Docker、containerd、CRI-O等。</p></li></ol><h3 id="EKS-1"><a href="#EKS-1" class="headerlink" title="EKS"></a>EKS</h3><p>EKS能够简化云上K8S的复杂性，提供一个高可用安全的控制平台，主要还可以集成其他服务，比如IAM、VPC、CloudWatch、ELB等。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630155419294.png" alt="image-20240630155419294"></p><p>上面的一个架构图，也是能够很清晰的看出来EKS Conrtol Plane成为了管理k8集群的核心组件，然后通过网络负载均衡余kubectl通信。咋一看好像中间少了API Server，scheduler，controller-manager这些组件，但是估计是由在集成在EKS Control里面的，而且相比于自建k8s集群的一个vpc内，这里却分为了两个VPC一个是管理的VPC，另一个是节点的VPC。这应该是属于一种网络隔离方法。可能是为了集群的稳定。其次就是责任分离了。然后工作节点的服务通过ELB来进行负载均衡给用户。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>首先配置eks集群</li><li>创建一个或多个工作节点</li><li>选择工具。并且连接到EKS</li><li>在pod上部署应用程序</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630165310994.png" alt="image-20240630165310994"></p><h2 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h2><p>不得不说是真的方便，还能够同时集成多个插件和统一的管理。可惜了，后面有一些操作，权限不够用不了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630183047481.png" alt="image-20240630183047481"></p>]]></content>
    
    
    <summary type="html">瞎玩EKS</summary>
    
    
    
    <category term="EKS" scheme="https://kalyan-zitiu.github.io/categories/EKS/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/EKS/K8S/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/EKS/K8S/AWS/"/>
    
    
    <category term="Academy" scheme="https://kalyan-zitiu.github.io/tags/Academy/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker部署Kubernetes</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/</id>
    <published>2024-04-08T06:00:00.000Z</published>
    <updated>2024-06-30T05:34:01.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Docker部署Kubernetes"><a href="#基于Docker部署Kubernetes" class="headerlink" title="基于Docker部署Kubernetes"></a>基于Docker部署Kubernetes</h1><h2 id="学习环境架构搭建"><a href="#学习环境架构搭建" class="headerlink" title="学习环境架构搭建"></a>学习环境架构搭建</h2><h3 id="创建VPC"><a href="#创建VPC" class="headerlink" title="创建VPC"></a>创建VPC</h3><p>在AWS创建一个拥有一个子网的VPC</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629213836702.png" alt="image-20240629213836702"></p><h3 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h3><p>安全组为了方便最好把ssh的22端口以及Kubernetes API服务的端口6443设置为入站规则。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214700104.png" alt="image-20240629214700104"></p><h3 id="启动模板创建"><a href="#启动模板创建" class="headerlink" title="启动模板创建"></a>启动模板创建</h3><p>根据最小配置。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214828795.png" alt="image-20240629214828795"></p><p>编写用户数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Docker</span></span><br><span class="line">apt-get install -y docker.io</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Kubernetes官方APT软件仓库的密钥和仓库</span></span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新APT索引并安装kubelet, kubeadm和kubectl</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swap（Kubernetes不支持运行在启用了Swap的机器上）</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>问题来了，当我试图用用户数据来做启动后的自动安装配置，由于Ubuntu版本命令已经不用apt-key了，所以在实例启动后并没有得到相应的环境，不过没有问题。</p><h2 id="Master主节点"><a href="#Master主节点" class="headerlink" title="Master主节点"></a>Master主节点</h2><h3 id="配置主节点环境以及准备初始化主节点"><a href="#配置主节点环境以及准备初始化主节点" class="headerlink" title="配置主节点环境以及准备初始化主节点"></a>配置主节点环境以及准备初始化主节点</h3><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. <strong>安装docker</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新本地的包索引数据库，这样在安装新软件时能获取到最新的软件包。</span></span><br><span class="line">sudo apt-get update </span><br><span class="line"><span class="comment"># 安装Docker。docker.io是Ubuntu官方仓库中Docker的软件包名称，-y参数表示自动同意安装过程中的询问。</span></span><br><span class="line">sudo apt-get install docker.io -y</span><br><span class="line"><span class="comment"># 启动Docker服务，并设置为开机自启动。</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><h3 id="2-关闭Swap"><a href="#2-关闭Swap" class="headerlink" title="2.关闭Swap"></a><strong>2.关闭Swap</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用swap（交换空间）。Kubernetes要求禁用swap，因为需要严格的资源控制和隔离，swap存在可能会影响性能和调度决策。</span></span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><h3 id="3-安装-cri-dockerd"><a href="#3-安装-cri-dockerd" class="headerlink" title="3.安装 cri-dockerd"></a>3.安装 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br><span class="line"><span class="comment"># cri-dockerd是一个桥接组件，允许Kubernetes通过CRI（容器运行时接口）与Docker交互。</span></span><br><span class="line">dpkg -i cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br></pre></td></tr></table></figure><ul><li></li></ul><h3 id="4-启动并配置开机启动-cri-dockerd"><a href="#4-启动并配置开机启动-cri-dockerd" class="headerlink" title="4.启动并配置开机启动 cri-dockerd"></a>4.启动并配置开机启动 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.socket</span><br></pre></td></tr></table></figure><ul><li>这些命令设置<code>cri-docker</code>服务和socket的启动和开机自启动，确保Kubernetes可以正确与Docker通信。</li></ul><h3 id="5-安装-kubeadm、kubelet、kubectl"><a href="#5-安装-kubeadm、kubelet、kubectl" class="headerlink" title="5.安装 kubeadm、kubelet、kubectl"></a>5.安装 kubeadm、kubelet、kubectl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装网络传输和证书相关的工具，为后续下载和验证Kubernetes包做准备。</span></span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并安装Kubernetes的GPG密钥，用于验证后续安装包的完整性。</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加Kubernetes的软件源，以便安装kubeadm、kubelet和kubectl。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] http://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><ul><li>测试拉取，然后查看需要的images</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630104435917.png" alt="image-20240630104435917"></p><ul><li>拉取镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/etcd:3.5.7-0</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630111103161.png" alt="image-20240630111103161"></p><h4 id="第一次尝试初始化"><a href="#第一次尝试初始化" class="headerlink" title="第一次尝试初始化"></a>第一次尝试初始化</h4><p>粗心大意,podSubnet没有注意大小写</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630113034682.png" alt="image-20240630113034682"></p><h4 id="第二次尝试初始化"><a href="#第二次尝试初始化" class="headerlink" title="第二次尝试初始化"></a>第二次尝试初始化</h4><p>需要reset一下kubeeadm</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们用的是docker</span></span><br><span class="line">sudo kubeadm reset -f --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630114542529.png" alt="image-20240630114542529"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>出现了两个问题,总的来说就是权限问题和连接问题.</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115125908.png" alt="image-20240630115125908"></p><h5 id="权限问题解决"><a href="#权限问题解决" class="headerlink" title="权限问题解决"></a>权限问题解决</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> ubuntu:ubuntu /etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>解决完权限问题后,连接问题也解决了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115354437.png" alt="image-20240630115354437"></p><p> 经过一定的搜寻和思考,</p><ul><li>运行上述命令后，你实际上是在改变 <code>/etc/kubernetes/admin.conf</code> 文件的所有权，将其从 <code>root</code> 用户和组更改为 <code>ubuntu</code> 用户和组。这样做的直接结果是，普通用户 <code>ubuntu</code> 现在有权限读取这个文件。</li><li>在k8s中集群中,<code>admin.conf</code> 文件包含了连接到集群的 K8s API 服务器的必要凭证和连接信息。这包括 API 服务器的地址、端口、使用的证书等。当你以 <code>ubuntu</code> 用户身份运行 <code>kubectl</code> 命令时，<code>kubectl</code> 会尝试读取这个配置文件来获取连接到 K8s 集群的必要信息。</li></ul><h4 id="先观察一下kubelet日志"><a href="#先观察一下kubelet日志" class="headerlink" title="先观察一下kubelet日志"></a>先观察一下kubelet日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl -u kubelet -f</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630120005623.png" alt="image-20240630120005623"></p><h4 id="再看一眼pod的日志"><a href="#再看一眼pod的日志" class="headerlink" title="再看一眼pod的日志"></a>再看一眼pod的日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定namespace;</span></span><br><span class="line">sudo kubectl logs coredns-5dd5756b68-jd25s --namespace=kube-system</span><br></pre></td></tr></table></figure><p>这种情况,大概率是网络上的,问题,经过查找需要安装一些网络插件</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630121445618.png" alt="image-20240630121445618"></p><h4 id="安装部署-Calico-网络插件"><a href="#安装部署-Calico-网络插件" class="headerlink" title="安装部署 Calico 网络插件"></a>安装部署 Calico 网络插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure><h2 id="Node-节点加入集群"><a href="#Node-节点加入集群" class="headerlink" title="Node 节点加入集群"></a>Node 节点加入集群</h2><h3 id="先在master节点查看加入命令"><a href="#先在master节点查看加入命令" class="headerlink" title="先在master节点查看加入命令"></a>先在master节点查看加入命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入命令,并指定cri-socket</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.0.1.237:6443 --token a69ewm.uvje3ei8zhox3xar --discovery-token-ca-cert-hash sha256:64db0e4e2ddc13e1a06390ac6b90b4f38a965fdc7cbfd2e3baa80a668e7cd74d --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><h3 id="为了node节点加入必备组件"><a href="#为了node节点加入必备组件" class="headerlink" title="为了node节点加入必备组件"></a>为了node节点加入必备组件</h3><p>成功后会显示</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630124600952.png" alt="image-20240630124600952"></p><p>然后主节点查看加入集群的节点</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630125420559.png" alt="image-20240630125420559"></p><p>ps:如果报couldn’t get current server API group list: Get “<a href="http://localhost:8080/api?timeout=32s&quot;">http://localhost:8080/api?timeout=32s&quot;</a>: dial tcp 127.0.0.1:8080: connect: connection refused的话，大概率是终端断连导致之前export的环境变量失效了，可以在/etc/environment文件中加入KUBECONFIG=”/etc/kubernetes/admin.conf”以使环境变量永久生效</p>]]></content>
    
    
    <summary type="html">基于Docker部署Kubernetes</summary>
    
    
    
    <category term="docker" scheme="https://kalyan-zitiu.github.io/categories/docker/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/docker/K8S/"/>
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>javaEE</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/02/javaEE/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/02/javaEE/</id>
    <published>2024-04-02T07:00:00.000Z</published>
    <updated>2024-06-30T11:29:41.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码连接"><a href="#代码连接" class="headerlink" title="代码连接"></a>代码连接</h2><p><a href="https://github.com/Kalyan-zitiu/Studyroomreservationsystem">https://github.com/Kalyan-zitiu/Studyroomreservationsystem</a></p><h2 id="需求说明以及功能分析"><a href="#需求说明以及功能分析" class="headerlink" title="需求说明以及功能分析"></a>需求说明以及功能分析</h2><h3 id="用户用例需求分析及其功能"><a href="#用户用例需求分析及其功能" class="headerlink" title="用户用例需求分析及其功能"></a>用户用例需求分析及其功能</h3><p>  如下图，普通用户：1.查看自习室情况：普通用户可以查看自习室的预约情况。2.预约自习室：普通用户可以预约自习室。3.取消预约：普通用户可以取消已预约的自习室。4.查看预约情况：普通用户可以查看自己的预约情况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630190654093.png" alt="image-20240630190654093"></p><p>如下图管理员用例图，1.删除自习室：管理员可以删除系统中的自习室。2.添加自习室：管理员可以在系统中新增自习室。3.修改自习室：管理员可以对现有的自习室信息进行修改。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191300868.png" alt="image-20240630191300868"></p><p>如下图超级管理员用例图，1.添加自习室：超级管理员可以在系统中新增自习室。2.删除自习室：超级管理员可以删除系统中的自习室。3.修改自习室：超级管理员可以对现有的自习室信息进行修改。4.查看使用统计：超级管理员可以查看自习室的使用统计数据。5.管理用户：超级管理员可以管理系统中的用户，包括添加删除修改用户信息。6.搜索普通用户：超级管理员可以搜索普通用户的信息。</p><p>​                                                                      <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps3.jpg" alt="img"> </p><h3 id="系统总操作流程分析"><a href="#系统总操作流程分析" class="headerlink" title="系统总操作流程分析"></a>系统总操作流程分析</h3><p>如下图，操作流程图展示了一个自习室预约系统的总操作流程。用户首先进行登录，输入用户名和密码后，系统会检查输入是否为空。如果为空，系统会提示信息不为空并要求重新输入。如果不为空，系统继续检查用户名和密码是否正确。如果不正确，系统会提示信息不正确并返回重新输入步骤。如果正确，系统会进行身份权限判断，根据用户权限执行相应的功能处理。整个过程在执行完相关功能处理后结束。这个流程图主要描述了登录验证和权限判断的过程，但缺少注册、找回密码、不同权限的具体功能分支及错误处理等环节。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191401981.png" alt="image-20240630191401981"></p><h2 id="系统概要设计"><a href="#系统概要设计" class="headerlink" title="系统概要设计"></a>系统概要设计</h2><h3 id="系统概述以及设计"><a href="#系统概述以及设计" class="headerlink" title="系统概述以及设计"></a>系统概述以及设计</h3><p>自习室预约系统是一种在线平台，旨在为学生和教职员工提供便捷、高效的自习室预订服务。该系统通过采用先进的数字化管理手段，实现了自习室资源的合理分配和高效利用，用户可以随时随地进行自习室的查看、预订、取消和管理，以满足其个性化学习需求。如下图系统工作原理图，展示了自习室预约系统的执行过程：客户端向Web服务器发送请求，Web服务器对请求进行验证后，向数据库检索相关数据或更新信息。数据库完成操作后，将结果传送回Web服务器，Web服务器再将最终结果回发给客户端。整个流程确保数据的实时性和准确性</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191517073.png" alt="image-20240630191517073"></p><h3 id="系统结构设计"><a href="#系统结构设计" class="headerlink" title="系统结构设计"></a>系统结构设计</h3><p>如下图系统结构图，展示自习室预约系统的功能结构图，包含普通用户、管理员和超级管理员三个角色。普通用户可以查看自习室情况、进行预约和取消预约；管理员可以管理预约情况、添加、修改和删除自习室信息；超级管理员则具有更高级别的权限，不仅可以管理用户，还能查看使用统计，以及添加、修改和删除自习室信息。图中用方框和连接线清晰地展示了各角色的功能模块和操作权限。</p><p>​                                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps6.jpg" alt="img"> </p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><ol><li>数据存储</li></ol><p>数据库包含以下主要实体：用户、角色、自习室、自习室详情、预约信息、用户角色。各实体表的设计如下：</p><p>用户表存储用户ID、用户名、密码、手机号和邮箱。</p><p>角色表存储角色ID、角色名称、角色标识和角色状态。</p><p>自习室表存储自习室ID、自习室编号、容量、设施和类型。</p><p>自习室详情表存储自习室地址、预约次数和使用次数。</p><p>预约信息表记录预约ID、用户ID、自习室详情ID、预约时间、状态原因和结束时间。</p><ol start="2"><li>数据管理</li></ol><p>数据库通过标准的SQL命令行管理工具以及数据库管理软件进行管理，包括数据的插入、更新、删除和查询。此外，视图、存储过程和触发器简化了数据管理操作和维护数据完整性。</p><ol start="3"><li>数据检索</li></ol><p>通过SQL查询语句进行数据检索。例如：</p><p>查询用户的预约记录。</p><p>查询某段时间内某自习室的使用情况。</p><p>在重要字段（如用户ID、自习室ID、预约时间）上建立索引，以提高检索效率。</p><ol start="4"><li>数据安全</li></ol><p>数据安全包括：</p><p>用户认证：使用加密和散列技术保护用户密码。</p><p>权限控制：通过角色和权限管理控制不同用户对数据库的访问权限。</p><p>数据传输：使用SSL/TLS保护数据传输安全。</p><p>日志记录：记录数据库访问和修改行为，以便审计。</p><ol start="5"><li>数据一致性</li></ol><p>数据库通过以下策略确保数据一致性：</p><p>主键约束：保证每个表的主键唯一且非空。</p><p>外键约束：确保引用完整性（如预约记录的用户ID必须在用户表中存在）。</p><p>触发器：自动检查和修正数据的一致性。</p><ol start="6"><li>数据完整性</li></ol><p>数据库使用以下方法保证数据完整性：</p><p>实体完整性：确保每个表的主键唯一且非空。</p><p>参照完整性：通过外键约束保持表间关系一致。</p><p>业务规则：使用存储过程和触发器实现业务逻辑，防止数据失效。</p><p>如下图用户信息实体图，用户信息实体包含以下属性：用户ID、用户名、密码、手机号和邮箱。用户实体与预约信息（reservation）实体之间存在一对多的关系，即每个用户可以有多个预约记录。用户实体还与用户角色（user_role）实体存在一对多的关系，表示每个用户可以对应多个角色，从而实现不同的权限和功能。该设计保证了用户的基本信息与其预约和角色信息的有效关联。</p><p>如下图角色信息实体图，角色信息实体（role）包含以下属性：角色ID、角色名字、角色标识和角色状态。角色信息实体与用户角色（user_role）实体之间存在一对多的关系，即每个角色可以对应多个用户角色记录。这个设计确保了每个角色的信息能够与多个用户相关联，从而在系统中实现多用户角色的管理和权限分配。</p><p>​                                                                          <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps8.jpg" alt="img"> </p><p>如下图自习室详情信息实体图，自习室详情信息实体包含以下属性：自习室详情ID、自习室地址、自习室ID、自习室预约次数和自习室使用次数。自习室详情信息实体与自习室信息实体之间存在一对一的关系，即每个自习室对应唯一的自习室详情记录。这个设计确保了每个自习室都有独立且详细的预订和使用情况描述，从而可以有效管理和监控每个自习室的使用状态。</p><p>​                                                                         <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps9.jpg" alt="img"> </p><p>如下图预约系统实体图，预约信息实体包含以下属性：预约ID、用户ID、自习室详情ID、预约开始时间、预约状态、取消或拒绝理由以及预约结束时间。预约信息实体与用户信息实体之间存在多对一关系，即多个预约记录可以对应同一个用户。同时，预约信息实体与自习室详情实体之间也存在多对一关系，即多个预约记录可以对应同一个自习室详情。这种设计确保了预约信息能够准确关联到具体的用户和自习室详情，从而实现全面的预约管理。</p><p>​                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192344417.png" alt="image-20240630192344417"></p><p>如下图，自习室实体图，自习室信息实体包含以下属性：自习室ID、自习室编号、总容量、可用设备和自习室类型。自习室信息实体与自习室详情信息实体之间存在一对一的关系，即每个自习室对应唯一的自习室详情记录。这个设计确保了每个自习室在系统中都有详细且独立的描述，从而可以准确记录和管理自习室的使用情况、容量和设备等信息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192355875.png" alt="image-20240630192355875"></p><p>如下表3-1，自习室表存储每个自习室的基本信息，包括自习室ID、自习室编号、容量、设施和类型。在系统内，自习室表用于记录和管理所有自习室的基础信息，并与自习室详情表存在一对一关系。这种关系确保每个自习室都有唯一的详细信息记录，用于详细描述自习室的位置和使用情况。</p><p>表3-1 自习室表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>study_room_id</td><td>int</td><td>11</td><td>主键非空</td><td>Id</td></tr><tr><td>study_room_num</td><td>varchar</td><td>50</td><td>无</td><td>自习室可用数量</td></tr><tr><td>capacity</td><td>int</td><td>50</td><td>无</td><td>总容量</td></tr><tr><td>Type</td><td>varchar</td><td>50</td><td>无</td><td>自习室类型</td></tr><tr><td>facilities</td><td>varchar</td><td>50</td><td>无</td><td>自习室设备</td></tr></tbody></table><p>如下表3-2，自习室详情表包含自习室的详细信息，包括位置、自习室ID、预约频率和使用频率。在系统内，自习室详情用于进一步描述自习室的具体信息，如地理位置和使用统计信息。它与自习室表存在一对一关系，确保每个自习室都有唯一的详细信息记录。</p><p>表3-2 自习室详情表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>自习室Id</td></tr><tr><td>Location</td><td>varchar</td><td>50</td><td>无</td><td>自习室地址</td></tr><tr><td>study_room_id</td><td>int</td><td>11</td><td>无</td><td>自习室归属Id</td></tr><tr><td>reservation_frequency</td><td>int</td><td>11</td><td>无</td><td>自习室预约状态</td></tr><tr><td>usage_frequency</td><td>int</td><td>11</td><td>无</td><td>自习室使用次数</td></tr><tr><td>capecity</td><td>int</td><td>11</td><td>无</td><td>容量</td></tr></tbody></table><p>  如下表3-3，用户表包含用户的基本信息，包括用户ID、用户名、密码、手机号和邮箱。系统内，用户表用于存储和管理所有用户的信息，并通过多对一关系与预约记录和用户角色关联，以便管理用户的预约活动和角色分配。</p><p>表3-3 用户表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>User_id</td><td>int</td><td>11</td><td>主键非空</td><td>用户Id</td></tr><tr><td>password</td><td>varchar</td><td>50</td><td>无</td><td>密码</td></tr><tr><td>phone</td><td>mediumtext</td><td>11</td><td>无</td><td>用户手机号码</td></tr><tr><td>email</td><td>varchar</td><td>11</td><td>无</td><td>用户邮箱</td></tr><tr><td>User_name</td><td>varchar</td><td>50</td><td>无</td><td>用户姓名</td></tr></tbody></table><p>  如下表3-4，预约表记录每个预约的详细信息，包括预约ID、用户ID、自习室详情ID、预约时间、状态、取消或拒绝的原因和结束时间。在系统内，预约表用于跟踪和管理所有的自习室预约记录。它通过多对一关系与用户表和自习室详情表关联，确保每个预约记录都与特定的用户和自习室关联。</p><p>表3-4 预约信息表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>reservation_id</td><td>int</td><td>11</td><td>主键非空</td><td>预约Id</td></tr><tr><td>User_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>Study_details_id</td><td>int</td><td>11</td><td>无</td><td>自习室详情Id</td></tr><tr><td>time_start</td><td>datetime</td><td>50</td><td>无</td><td>预约开始时间</td></tr><tr><td>time_end</td><td>datetime</td><td>50</td><td>无</td><td>预约结束时间</td></tr><tr><td>status</td><td>tinyint</td><td>11</td><td>无</td><td>预约状态</td></tr><tr><td>reason</td><td>varchar</td><td>50</td><td>无</td><td>申请原因</td></tr></tbody></table><p>  如下表3-5，角色表包含每个角色的信息，包括角色ID、角色名称、角色标识和状态。在系统内，角色表用于定义和存储不同的角色，并与用户角色表存在多对一关系。这样，每个角色可以分配给多个用户，方便进行权限管理和角色分配。</p><p>表3-5 角色表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色Id</td></tr><tr><td>role_name</td><td>varchar</td><td>255</td><td>无</td><td>角色名字</td></tr><tr><td>role_sign</td><td>varchar</td><td>30</td><td>无</td><td>角色标识</td></tr><tr><td>status</td><td>tinyint</td><td>11</td><td>无</td><td>角色状态</td></tr></tbody></table><p>  如下表3-6，用户角色表记录用户与其分配角色之间的关系，包括用户角色ID、用户ID和角色ID。在系统内，用户角色表用来管理和存储用户与角色的映射关系。它通过多对一关系与用户表和角色表关联，确保用户可以拥有相应的角色和权限。</p><p>表3-6 用户角色表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>user_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>role_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr></tbody></table><p>  如下表3-7，自习室管理员表包含管理员的信息，包括管理员ID、用户ID和自习室ID。在系统内，自习室管理员表用于指定和管理自习室的管理员。它通过多对一关系与用户表和自习室表关联，确保每个自习室有特定的管理员进行管理和维护。</p><p>表3-7 自习室管理表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>admin_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>user_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>study_room_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr></tbody></table><p>  如下表3-8，角色权限表存储角色与权限之间的关系，包括角色权限ID、角色ID和权限ID。在系统内，角色权限表用于管理和记录每个角色与其权限之间的映射关系。它通过多对一关系与角色表和权限表关联。</p><p>表3-8 角色权限表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>角色权限Id</td></tr><tr><td>role_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr><tr><td>permission_id</td><td>int</td><td>11</td><td>无</td><td>权限Id</td></tr></tbody></table><p>如下表3-9，权限表存储权限的信息，包括权限ID、权限名称和权限简化表示。在系统内，权限表用于定义和存储不同的权限，并通过多对一关系与角色权限表关联。这样，每个权限可以分配给多个角色，实现灵活的权限管理。</p><p>表3-9 权限表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>permsission_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>permission_simplify</td><td>varchar</td><td>20</td><td>无</td><td>权限简化标识</td></tr><tr><td>permsission_name</td><td>varchar</td><td>255</td><td>无</td><td>权限名称</td></tr></tbody></table><h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><p>用户认证：采用安全认证机制，如密码哈希存储用户密码，使用令牌或会话管理用户登录状态。</p><p>权限控制：根据用户角色进行权限控制，确保只有具有相应权限的用户才能执行特定操作。</p><p>数据保护：对敏感数据进行加密存储和传输，确保数据的机密性和完整性。</p><h2 id="系统详细设计"><a href="#系统详细设计" class="headerlink" title="系统详细设计"></a>系统详细设计</h2><h3 id="登录功能模块"><a href="#登录功能模块" class="headerlink" title="登录功能模块"></a>登录功能模块</h3><p>如下图，在自习室预约系统的登录时序图中，用户首先在浏览器中输入用户名和密码并点击登录。接着，浏览器通过HTTP请求将表单数据发送到服务器，服务器查询数据库以验证用户名和密码。如验证成功，服务器生成会话令牌，如JWT或Session ID，并将其发送回浏览器，同时浏览器将令牌保存在CookieLocalStorage中。最后，服务器发送登录成功的信息，并可能重定向用户到主页面或个人主页。这一过程清晰展示了用户登录流程的各个关键步骤及各组件间的交互</p><p>​                               <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191841675.png" alt="image-20240630191841675"></p><p>如下图3,用户首先在浏览器中打开自习室预约系统的登录页面，并在页面的表单中输入用户名和密码。然后，用户点击“登录”按钮，表单数据通过HTTP请求发送到服务器。服务器接收到请求后，提取用户名和密码，并查询数据库以验证用户名是否存在。如果用户名存在，服务器会对比存储的哈希密码和用户输入的密码。如果用户名或密码不匹配，服务器向用户返回登录失败的信息。如果用户名密码匹配，服务器生成会话令牌，并将令牌发送给用户的浏览器。随后，浏览器收到会话令牌（如JWT或Session ID）并将其保存到Cookie或LocalStorage中。最后，服务器向用户浏览器返回登录成功的信息，并重定向到系统的主页面或用户的个人主页。把这部分的时序图的从上面内容提取出来。</p><p>​                                                   <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps13.jpg" alt="img"> </p><h3 id="管理员功能模块"><a href="#管理员功能模块" class="headerlink" title="管理员功能模块"></a>管理员功能模块</h3><p>添加自习室：</p><p>如下图，浏览器将这些信息通过HTTP请求发送到服务器。服务器接收到请求后，首先对数据进行完整性和合法性检查，确保所有必填字段都有值且数据格式正确。然后，服务器将验证通过的自习室信息存入数据库。如果存储成功，服务器返回成功信息给浏览器；如果失败，则返回错误信息。最后，浏览器接收到服务器的响应并更新页面，根据返回的信息显示添加成功或失败的结果提示。</p><p>​                               <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192418134.png" alt="image-20240630192418134"></p><p>如下图所示，管理员访问自习室预约系统的添加自习室页面，在表单中输入自习室的详细信息并点击“添加”按钮</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192428678.png" alt="image-20240630192428678"></p><p>删除自习室：</p><p>如下图，该请求通过HTTP发送到服务器。服务器接收到请求后，会进行权限检查和请求有效性验证，确保管理员具有相应的操作权限。一旦验证通过，服务器指示数据库删除相关的自习室记录。数据库执行删除操作，服务器将结果返回给浏览器，显示该自习室已被成功删除或删除失败的信息。</p><p>​                                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps16.jpg" alt="img"> </p><p>如下图所示，管理员首先登录到自习室预约系统，并访问自习室管理页面，该页面列出了所有注册的自习室信息。管理员找到并选择他们想要删除的自习室，并点击该自习室旁的“删除”按钮以发起删除请求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192435966.png" alt="image-20240630192435966"></p><p>修改自习室：</p><p>如下图，编辑完成后，管理员点击“提交”按钮，浏览器会将修改后的信息以HTTP请求的形式发送到服务器。服务器接收这些信息后进行权限验证和数据合法性检查，一旦确认无误，服务器会指示数据库更新这些自习室信息。数据库完成更新操作后，服务器根据操作结果向管理员返回一个成功或失败的响应。浏览器接收到响应后，将页面更新以显现修改成功或失败的通知。这个过程不仅确保了数据的准确性和操作的安全性，还通过即时反馈帮助管理员确认修改操作的最终结果。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192447410.png" alt="image-20240630192447410"></p><p>如下图所示，在自习室预约系统中，管理员首先登录并导航到自习室管理页面，这里列出了所有自习室的详细信息。管理员选择需要修改的自习室，并点击相对应的“编辑”按钮，这将打开一个带有当前自习室信息的表单。管理员在此表单中可以更新自习室的各类信息，如名称、容量、地点及开放时间等。</p><p>​                                                                    <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps19.jpg" alt="img"> </p><h3 id="用户功能模块"><a href="#用户功能模块" class="headerlink" title="用户功能模块"></a>用户功能模块</h3><p>预约自习室：</p><p>如下图，编辑完成后，管理员点击“提交”按钮，浏览器会将修改后的信息以HTTP请求的形式发送到服务器。服务器接收这些信息后进行权限验证和数据合法性检查，一旦确认无误，服务器会指示数据库更新这些自习室信息。数据库完成更新操作后，服务器根据操作结果向管理员返回一个成功或失败的响应。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192457889.png" alt="image-20240630192457889"></p><p>如下图，3-22所示，在自习室预约系统中，管理员首先登录并导航到自习室管理页面，这里列出了所有自习室的详细信息。管理员选择需要修改的自习室，并点击相对应的“编辑”按钮，这将打开一个带有当前自习室信息的表单。管理员在此表单中可以更新自习室的各类信息，如名称、容量、地点及开放时间等。</p><p>​                                                         <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps21.jpg" alt="img"> </p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192512225.png" alt="image-20240630192512225"></p><p>取消预约：</p><p>如下图所示，用户首先登录到系统并导航到自己的预约历史或当前预约页面。在这里，所有的活跃预约都会被列出，包括每个预约的时间、自习室编号以及取消预约的选项。用户选择需要取消的预约后，点击“取消预约”按钮，系统会提示用户确认是否要取消。一旦用户确认取消，系统将自动发送取消请求到服务器，服务器验证请求的有效性后，更新数据库以反映预约被取消的状态。完成后，系统会通知用户预约已成功取消，并更新页面以显示最新的预约状态。用户首先登录到系统并导航到自己的预约历史或当前预约</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192521588.png" alt="image-20240630192521588"></p><p>查看自习室情况：</p><p>如下图所示，用户可以通过系统提供的自习室状态页面来查看各自习室的当前状态和预约情况。用户访问该页面后，系统展示所有自习室的列表，包括每间自习室的位置、容量和当前的占用情况。用户可以查看每个自习室的详细信息，如开放时间和特定时间段内的预约状况，这有助于用户在预约前做出更明智的选择。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192525619.png" alt="image-20240630192525619"></p><p>查看预约情况：</p><p>如下图所示，用户需要了解自己的预约历史，以便于管理和规划个人时间。系统允许用户访问一个专门的页面，列出他们过去和即将进行的所有预约详情。这包括预约的日期、时间、自习室号码以及预约的状态。用户可以通过这一功能轻松跟踪自己的预约状况，并进行相应的规划和调整。</p><p>​                                                           <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps25.jpg" alt="img"> </p><h3 id="超级管理员功能模块"><a href="#超级管理员功能模块" class="headerlink" title="超级管理员功能模块"></a>超级管理员功能模块</h3><p>搜索用户：</p><p>如下图，服务器接收到请求后，解析其中的搜索关键字，并基于这些关键字对数据库进行查询操作，以找到符合条件的用户信息。一旦数据库查询完成，服务器会根据查询结果生成相应的响应信息。如果查询成功并找到了匹配的用户，服务器会将这些用户数据作为响应发送回浏览器；如果没有找到匹配的用户，则会发送一个表示无结果的提示信息。浏览器接收到这些信息后，便会更新用户管理页面，显示出搜索结果或者是没有找到任何用户的提示。整个过程不仅保证了超级管理员能够快速准确地获取用户信息，还优化了用户管理的效率。</p><p>​                                                             <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps26.jpg" alt="img"> </p><p>如下图所示，超级管理员首先需要登录到自习室预约系统，并导船到用户管理页面。这个页面包括一个搜索框，允许超级管理员输入特定的搜索条件，如用户的用户名、邮箱或其他相关属性。输入完成后，超级管理员点击“搜索”按钮，此时浏览器会将这些搜索条件通过HTTP请求形式发送给服务器。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192544783.png" alt="image-20240630192544783"></p><p>管理用户：</p><p>如下图，此时系统会将这一角色更改请求通过HTTP请求发送到服务器。服务器接收到请求后，首先进行权限验证，确保当前操作员有权执行这一角色修改操作。若权限验证通过，服务器则指令数据库更新该用户的角色信息。数据库更新完成后，服务器会根据操作的结果生成响应，并将其发送回浏览器。浏览器接收到这一信息后，会更新用户管理页面，并向超级管理员显示角色更新成功或失败的提示。这个完整的流程不仅保证了用户角色管理的灵活性和系统的权限控制，还通过实时反馈使得超级管理员能够即刻知晓操作结果，从而提升了用户管理的效率和准确性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192553947.png" alt="image-20240630192553947"></p><p>如下图所示，在自习室预约系统中，超级管理员首先需要通过浏览器登录系统，并导航至用户管理页面。此页面详细展示了系统中所有用户的列表，包括他们的基本信息和当前分配的角色。超级管理员浏览这个列表，并选择想要修改角色的特定用户。选择用户后，超级管理员可以通过一个界面元素（通常是下拉菜单）来指定新的用户角色，比如将用户从普通用户改为管理员或其他角色。一旦选择了新的角色，超级管理员会点击“更新”或“提交”按钮。</p><p>​                                                                <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192605509.png" alt="image-20240630192605509"></p><p>​                                                                                  <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps30.jpg" alt="img"> </p><p>查看使用统计：</p><p>如下图所示，通过合法的认证流程登录系统。登录后，超级管理员可以导航到系统提供的“统计”或“报表”页面，这里集中展示了自习室使用的各种统计数据。这些统计数据通常包括但不限于用户预约次数、自习室使用频率、高峰使用时段、取消预约的次数以及任何特定时间段内的用户活动情况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192613060.png" alt="image-20240630192613060"></p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="系统测试综述"><a href="#系统测试综述" class="headerlink" title="系统测试综述"></a>系统测试综述</h3><p>综述：</p><p>在自习室预约系统中，我们聚焦于测试查看自习室情况、预约和取消预约功能以确认普通用户的交互正确性；同时，管理员的添加、删除和修改自习室信息功能进行深入测试以保证系统信息的准确更新；对于超级管理员功能，特别测试了查看使用统计、管理用户以及搜索用户信息的准确性和效率。这些测试是为了确保系统各功能模块不仅符合设计要求，同时也提供了用户友好、安全和高效的操作体验，从而在系统投入实际使用前，能够识别并修正潜在问题，进一步提升服务的质量和用户满意度。通过全面的测试策略，我们的目标是确保自习室预约系统在提供必需服务的同时，保护用户信息的安全，同时确保系统跨平台的兼容性和高效性。测试覆盖了从基本功能到用户最终接受的每个阶段，确保发现并修复潜在的问题，从而提供一个既易于使用也高度可靠的系统，满足最终用户的期望和需求。这些测试不仅提高了系统的整体质量，也提升了用户信任。</p><p>测试类型及其目的：</p><p>功能测试：主要验证系统中的核心功能，如预约准确性、用户管理、通知系统以及时间选择功能。这项测试确保所有功能按预期工作，没有逻辑错误或缺陷，从而保证系统操作的正确性和预期行为。</p><p>性能测试：着重检查系统在高负载或高压力条件下的表现。该测试评估系统的响应速度和稳定性，确保在大量用户同时使用时系统能够有效地处理请求，从而提供持续的服务质量。</p><p>安全性测试：保证用户数据的安全性和隐私。通过这项测试，我们评估系统防止未授权访问以及数据泄露的能力，关注保护用户信息和转输安全。</p><p>兼容性测试：验证软件在不同的设备、操作系统和浏览器上的运行稳定性。这确保所有用户无论使用何种技术平台都能获得一致的体验。</p><p>用户接受测试：通过实际用户的操作反馈来评估系统的实用性和满意度。这项测试帮助我们了解用户在日常使用中遇到的问题和不便，以便进行调整和优化，提升用户体验。</p><h3 id="关键测试"><a href="#关键测试" class="headerlink" title="关键测试"></a>关键测试</h3><p>接口测试：</p><p>如下图所示，登录接口测试用Postman进行用户登录测试的过程。其中，发送了一个包含用户名和密码的POST请求到本地服务器，并成功接收到JSON格式响应数据。这表明登录操作被成功处理，用户被验证为“普通用户”。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192633876.png" alt="image-20240630192633876"></p><p>如下图所示，预约查询接口测试使用Postman来获取预约信息的过程。在图中，执行了一个GET请求至<a href="http://localhost:8989/reservations%E4%BB%A5%E6%9F%A5%E8%AF%A2%E9%A2%84%E7%BA%A6%E6%95%B0%E6%8D%AE%E3%80%82%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81200%E8%A1%A8%E6%98%8E%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E9%A1%BA%E5%88%A9%E3%80%82%E8%BF%94%E5%9B%9E%E7%9A%84JSON%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%90%AB%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E9%A2%84%E7%BA%A6%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%BF%99%E9%87%8C%E6%98%BE%E7%A4%BA%E4%BA%86%E4%B8%80%E6%9D%A1%E9%A2%84%E7%BA%A6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E3%80%82%E8%AF%A5%E9%A2%84%E7%BA%A6%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9A%E9%A2%84%E7%BA%A6ID%E4%B8%BA1%EF%BC%8C%E9%A2%84%E7%BA%A6%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%BA2%EF%BC%88%E5%8F%AF%E8%83%BD%E8%A1%A8%E7%A4%BA%E6%9F%90%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%94%E5%A6%82&quot;%E5%B7%B2%E7%A1%AE%E8%AE%A4&quot;%EF%BC%89%EF%BC%8C%E7%94%A8%E6%88%B7%E5%A7%93%E5%90%8D%E4%B8%BA%E7%A9%BA%EF%BC%8C%E9%A2%84%E7%BA%A6%E7%B1%BB%E5%9E%8B%E4%B8%BA&quot;%E8%AE%BE%E6%96%BD%E9%A2%84%E7%BA%A6&quot;%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BD%8D%E7%BD%AE%E4%B8%BA&quot;A2-209&quot;%EF%BC%8C%E9%A2%84%E7%BA%A6%E5%8E%9F%E5%9B%A0%E6%98%AF&quot;%E5%AD%A6%E4%B9%A0%E8%AE%A8%E8%AE%BA&quot;%E3%80%82%E9%A2%84%E7%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E6%96%BD%E5%8C%85%E6%8B%AC&quot;%E7%94%B5%E8%84%91%E5%92%8C%E6%8A%95%E5%BD%B1%E4%BB%AA&quot;%E3%80%82%E8%BF%99%E5%9B%BE%E6%9C%89%E6%95%88%E6%BC%94%E7%A4%BA%E4%BA%86%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87API%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BA%A6%E8%AF%A6%E6%83%85%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%91%E7%9D%A3%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E5%B0%A4%E4%B8%BA%E9%87%8D%E8%A6%81%E3%80%82">http://localhost:8989/reservations以查询预约数据。请求成功，状态码200表明查询过程顺利。返回的JSON响应数据包含一系列的预约信息，这里显示了一条预约的详细信息。该预约包含多个字段：预约ID为1，预约状态码为2（可能表示某种状态，比如&quot;已确认&quot;），用户姓名为空，预约类型为&quot;设施预约&quot;，具体位置为&quot;A2-209&quot;，预约原因是&quot;学习讨论&quot;。预约相关的设施包括&quot;电脑和投影仪&quot;。这图有效演示了如何通过API接口获取系统中的预约详情，这对于管理和监督预约系统尤为重要。</a></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192639167.png" alt="image-20240630192639167"></p><p>如下图所示，审核接口测试使用Postman执行PUT请求以修改预约信息的操作。请求成功执行，返回表明预约信息已经被成功更新。这表明API已经正确处理了修改预约信息的请求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps34.jpg" alt="img"> </p><p>如下图所示，获取用户列表接口测试使用Postman执行GET请求从服务器获取用户角色信息的过程。请求成功返回，展示了包括用户名、角色、电邮、电话和用户ID在内的详细信息，用于描绘系统中某个用户的权限和角色概况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps35.jpg" alt="img"> </p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>如下表3-10，这组测试用例关注于验证系统管理用户的功能，包括添加新用户，修改现有用户信息，以及删除用户。各个用例检验系统是否能够成功执行用户管理任务并给出适当的反馈消息。</p><p>表3-10 管理用户测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>添加新用户</td><td>检验添加用户功能的执行</td><td>成功添加用户，系统显示添加成功消息</td><td>成功添加，消息正确显示</td></tr><tr><td>修改现有用户信息</td><td>检验修改用户信息的正确性</td><td>成功修改用户信息，系统显示更新成功消息</td><td>修改成功，消息正确显示</td></tr><tr><td>删除用户</td><td>检验删除用户的功能</td><td>成功删除用户，系统显示删除成功消息</td><td>用户成功删除，确认消息显示</td></tr></tbody></table><p>如下表3-11，测试用例集中于系统的用户搜索功能，包括对存在的用户的精确搜索，对不存在用户的搜索处理，以及使用模糊匹配进行的多用户搜索，确认系统能否在这些情况下准确显示用户信息或相关提示。</p><p>表3-11 搜索用户测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>搜索存在的用户</td><td>检验搜索功能的准确性</td><td>系统正确显示匹配的用户信息</td><td>搜索成功，用户信息准确显示</td></tr><tr><td>搜索不存在的用户</td><td>测试系统的搜索容错能力</td><td>系统显示无结果，提示用户找不到匹配信息</td><td>搜索结果为空，系统正确显示无匹配信息提示</td></tr><tr><td>使用模糊匹配搜索多个用户</td><td>检验模糊搜索功能的效果</td><td>系统显示所有相关匹配的用户信息</td><td>模糊搜索成功，相关用户信息被展示</td></tr></tbody></table><p>如下表3-12，这些测试用例旨在评估系统在显示自习室使用统计信息上的表现，无论是在没有使用记录的情况下还是有使用记录时，系统都应正确显示相关统计信息。</p><p>表3-12 查看使用统计测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>没有任何自习室使用记录时查看统计</td><td>检验统计功能正常情况下的显示</td><td>统计结果显示无使用记录</td><td>系统正确显示无使用记录</td></tr><tr><td>自习室有使用记录时查看统计</td><td>检验统计功能反映实际使用情况</td><td>统计结果详细反映每个自习室的使用情况</td><td>统计正确，详细展示每个自习室的使用记录</td></tr></tbody></table><p>如下表3-13，这一组测试用例检查系统在不同情况下（全部空闲、部分预约、全部预约满）展示自习室状态的准确性。</p><p>表3-13 查看自习室情况测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>自习室全部空闲时进行查看</td><td>检查系统显示所有自习室空闲情况</td><td>系统显示所有自习室处于空闲状态</td><td>系统正确显示所有自习室空闲状态</td></tr><tr><td>自习室部分被预约时进行查看</td><td>检查系统显示部分自习室预约情况</td><td>系统显示部分自习室被预约，其余空闲</td><td>系统正确反映部分自习室被预约，其余空闲</td></tr><tr><td>自习室全部被预约满时查看</td><td>检查系统显示所有自习室被预约情况</td><td>系统显示所有自习室处于被预约状态</td><td>系统正确显示所有自习室被预约状态</td></tr></tbody></table><p>如下表3-14，用例专注于系统处理自习室预约的能力，包括成功预约空闲的自习室、处理预约冲突以及连续预约多间自习室的情况，确保系统在这些场景下能正确执行并提供反馈。</p><p>表3-14 预约自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>预约一间未被预约的自习室</td><td>测试能否成功预约自习室</td><td>成功预约，系统显示预约成功信息</td><td>预约成功，系统显示预约成功信息</td></tr><tr><td>尝试预约已被他人预约满的自习室</td><td>测试系统处理冲突预约的能力</td><td>系统显示错误信息，指出自习室已被预约</td><td>尝试失败，系统正确显示错误信息</td></tr><tr><td>连续预约多间自习室</td><td>测试系统处理多项预约的能力</td><td>成功预约多间自习室，显示预约成功信息</td><td>成功预约多间，系统正确显示预约成功信息</td></tr></tbody></table><p>如下表3-15，测试集包括检验用户取消自己之前成功的自习室预约，并测试系统防止用户撤销他人预约的安全性和权限管理。目的是确保系统在处理取消操作时既符合预期又维护了适当的访问控制。</p><p>表3-15 取消预约测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>取消自己之前成功预约的自习室</td><td>测试能否取消自己的预约</td><td>成功取消预约，系统显示取消成功信息</td><td>预约取消成功，实际结果与预期相符</td></tr><tr><td>尝试取消他人的预约</td><td>测试系统的安全性和权限管理</td><td>系统显示错误信息，不允许取消他人预约</td><td>系统正确显示错</td></tr></tbody></table><p>如下表3-16，这些用例测试系统如何处理自习室的删除请求，包括已安排和未安排预约的自习室，以及尝试删除不存在的自习室。这一系列测试旨在确保删除操作在不同状况下被正确处理，提供适当的反馈和错误处理。</p><p>表3-16 删除自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>删除系统中未被预约的自习室</td><td>检验删除功能的正常逻辑</td><td>成功删除，系统更新状态表示自习室已删除</td><td>成功删除自习室，系统正确显示删除状态</td></tr><tr><td>删除系统中已被预约的自习室</td><td>检验系统如何处理预约中的删除请求</td><td>系统阻止删除或需特殊处理</td><td>系统成功阻止删除，提示自习室正在被预约中</td></tr><tr><td>尝试删除不存在的自习室</td><td>测试系统的错误处理能力</td><td>系统显示错误信息，删除失败</td><td>系统正确显示错误信息，指出自习室不存在</td></tr></tbody></table><p>如下表3-17，此部分测试用例关注于系统添加新自习室的功能，验证系统如何处理新自习室的添加，包括重复自习室编号的错误处理和在信息输入不完整时的系统反馈。</p><p>表3-17 添加自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>成功在系统中添加一个新的自习室</td><td>检验添加功能的正常逻辑</td><td>系统显示添加成功并更新自习室列表</td><td>添加成功，系统正确显示自习室列表更新</td></tr><tr><td>尝试添加已存在的自习室编号</td><td>测试系统处理重复添加的能力</td><td>系统显示错误，指出自习室编号重复</td><td>系统成功显示错误信息，防止重复添加</td></tr><tr><td>添加自习室时未填写完整信息</td><td>测试系统的输入验证功能</td><td>系统显示错误并要求必要信息完整</td><td>系统正确显示错误，要求填写必要信息</td></tr></tbody></table><p>如下表3-18，这组测试用例评估了修改自习室信息的功能，测试了合法和非法修改案例，包括尝试修改不存在的自习室以及输入非法数据时的系统响应。目标是验证系统在更新自习室信息时的可靠性和错误处理能力。</p><p>表3-18 修改自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>修改自习室的信息</td><td>检验修改功能的正常逻辑</td><td>成功修改，系统显示更新成功消息</td><td>修改成功，系统正确显示更新成功消息</td></tr><tr><td>尝试修改不存在的自习室信息</td><td>测试系统的错误处理能力</td><td>系统显示错误信息，修改失败</td><td>系统正确显示错误信息，指出自习室不存在</td></tr><tr><td>修改自习室信息时输入非法数据</td><td>测试系统的输入验证功能</td><td>系统显示错误信息，阻止修改</td><td>系统正确显示错误，防止了无效的修改</td></tr></tbody></table><h3 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h3><p>在对自习室预约系统进行细致的测试后，我们发现系统在多数关键功能上运作正常且符合预设需求。通过模拟普通用户的各种情境，如查看自习室预约状态、预约和取消自习室，系统显示了良好的反馈和正确管理冲突的能力。管理员功能测试表明，添加、删除和修改自习室的操作均得以准确执行，系统妥善处理了包括预约中的自习室不能被删除的逻辑。超级管理员的权限测试也验证了其对整个系统用户和统计信息的完全控制能力。模拟的实际结果与预期结果大致一致，验证了系统的可靠性和用户界面的友好性。然而，存在的一些预期外情况建议我们在未来增强输入验证、错误提示和系统的异常处理机制，特别是在处理重复数据和非法输入时。总体来说，自习室预约系统表现出了良好的稳定性和功能完整性，适合进行下一阶段的用户验收测试和进一步开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个项目中，我使用Spring Boot作为后端框架，并结合Element Plus和Vue作为前端框架，构建了一个功能齐全的应用程序。Spring Boot提供了快速搭建后端服务的方式，支持依赖注入、自动配置和开发工具，极大地提升了开发效率，并能轻松集成各种第三方库。前端方面，Element Plus提供了一套漂亮易用的UI组件，而Vue则简化了数据绑定和组件开发，使前端代码更易维护和扩展。通过将后端和前端分离开发和部署，利用RESTful API进行通信，系统保持了松散耦合和易扩展性。我实现了用户管理功能，如登录、注册、获取和修改个人信息、搜索用户和查看所有用户等，并使用Spring Security进行权限控制，确保只有特定权限的用户能访问相应接口。项目中，用户管理功能包括注册、登录、获取和修改个人信息，这些操作通过Spring Boot的RESTful API实现，前端通过Axios进行请求处理。为了确保系统的安全性，我使用Spring Security进行权限控制，确保只有特定权限的用户可以访问相应的接口。这个项目集成了Spring Boot、Element Plus和Vue等技术，增强了我对这些技术的理解，并为今后的开发工作提供了良好的基础和参考。通过这个项目，我深刻体会到合适的技术栈能够极大地提升开发效率和系统质量，前后端分离开发的优势使得开发过程更加高效，细粒度的权限控制确保了系统的安全性，而组件化开发使得代码更加模块化和可维护。总之，这个项目不仅提升了我的技术能力，也让我对系统架构设计、用户体验和安全性有了更深刻的理解。</p>]]></content>
    
    
    <summary type="html">一次基于javaEE系统的设计</summary>
    
    
    
    <category term="javaEE" scheme="https://kalyan-zitiu.github.io/categories/javaEE/"/>
    
    
    <category term="java" scheme="https://kalyan-zitiu.github.io/tags/java/"/>
    
    <category term="springboot" scheme="https://kalyan-zitiu.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>AWS Server Details</title>
    <link href="https://kalyan-zitiu.github.io/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/"/>
    <id>https://kalyan-zitiu.github.io/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/</id>
    <published>2024-03-04T07:00:00.000Z</published>
    <updated>2024-06-24T07:27:59.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><ul><li>是AWS Elastic Block Store(EBS)提供了用于EC2实例的<strong>块存储卷</strong></li><li>设计用来提供高可靠性和高性能的存储<h2 id="块存储卷"><a href="#块存储卷" class="headerlink" title="块存储卷"></a>块存储卷</h2></li><li>是一种数据存储技术，将存储空间分割成固定大小的“块”，每个块可以像独立硬盘一样被单独管理和操作</li><li>低级别数据处理（能够在较低的操作系统级别进行数据处理），高性能（块存储可以与操作系统直接交互），独立性（在没有文件系统的情况下存在，不会存储任何文件结构或元数据），灵活性（轻松扩展或调整大小），可访问性（能够通过存储区域网络（san），互联网协议（ip）网络或本地连接进行访问。）</li></ul><h2 id="持久性存储"><a href="#持久性存储" class="headerlink" title="持久性存储"></a>持久性存储</h2><p>EBS卷在EC2实例终后仍然存在，可以在创建EC3实例时候将其删除。</p><h2 id="多种卷类型"><a href="#多种卷类型" class="headerlink" title="多种卷类型"></a>多种卷类型</h2><h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><ul><li>是一个衡量计算存储设备性能的指标，表示每秒可以完成的输入/输出操作次数。这个指标通常用于评估硬盘驱动器（HDD）、固态硬盘（SSD）、存储区域网络（SAN）和网络附加存储（NAS）等存储设备的性能。</li></ul><p>IOPS高低的因素：</p><ol><li>存储介质：SSD通常提供比HDD更高的IOPS，因为SSD没有移动部件，数据访问速度更快。</li><li>数据块大小：通常较小的数据块会产生更高的IOPS数，每个操作处理的数据量更少。</li><li>读写模式：IOPS性能可能会根据读写操作的比例而变化。一般来说，读写操作的IOPS高于写操作</li><li>并发和队列深度：多个并发操作和更深的队列深度可以提高IOPS，但也可能增加延迟。</li><li>随机与顺序访问：随机I/O操作通常比顺序I/O操作有更低的IOPS，存储设备需要在不同位置寻找数据，尤其是在使用传统的机械硬盘时。</li></ol><h4 id="硬盘驱动器（HDD）"><a href="#硬盘驱动器（HDD）" class="headerlink" title="硬盘驱动器（HDD）"></a>硬盘驱动器（HDD）</h4><ul><li>一种创痛的机械存储设备，具有较大的存储容量和较低的成本</li></ul><h4 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h4><ul><li>是一种基于闪存存储技术的存储设备，具有更快的数据访问速度，更多的访问延迟和更高的可靠性，但是SSD的加个通常比HDD高，存储容量也很较小</li></ul><h4 id="存储区域网络（SAN）"><a href="#存储区域网络（SAN）" class="headerlink" title="存储区域网络（SAN）"></a>存储区域网络（SAN）</h4><ul><li>是一种专用网络，用于连接存储设备和计算设备。SAN通过高速网络连接将存储资源提供给计算设备，使其能够访问和共享存储数据，SAN通常用于大规模企业环境中，提供高性能，高可靠性和可扩展性的存储解决方案。</li></ul><h4 id="网络附加存储（NAS）"><a href="#网络附加存储（NAS）" class="headerlink" title="网络附加存储（NAS）"></a>网络附加存储（NAS）</h4><ul><li>通过网络连接提供文件级别存储服务的设备，NAS设备通常是独立的存储服务器，可以通过网络协议（NFS或SMB）共享文件，使多个计算设备能够访问和共享存储数据。NAS适用与小型办公环境或家庭用户，提供简单的文件共享和备份功能。</li></ul><h3 id="通用型SSD（gp2和gp3）"><a href="#通用型SSD（gp2和gp3）" class="headerlink" title="通用型SSD（gp2和gp3）"></a>通用型SSD（gp2和gp3）</h3><ul><li>提供平衡的性能和成本，适用与广泛的应用。gp2卷提供基于卷大小的IOPS，而gp3则允许用户独立选择和调整IOPS和吞吐量，与卷大小没有关系</li><li><strong>应用场景：</strong> gp2适用于大多数工作负载，如虚拟桌面，中小型数据库，开发和测试环境。gp3是更新的版本，适用于需要可预测的性能和价格的应用程序</li></ul><h3 id="预置IOPS-SSD（io1和io2）"><a href="#预置IOPS-SSD（io1和io2）" class="headerlink" title="预置IOPS SSD（io1和io2）"></a>预置IOPS SSD（io1和io2）</h3><ul><li>提供高性能的IOPS，适用于I/O密集型的数据库和应用程序，io2提供更高的耐久性和IOPS效率</li><li><strong>应用场景：</strong>高性能数据库，如大型关系型数据库或NoSQL数据库，以及需要高吞吐量和低延迟的关键业务应用程序。</li></ul><h3 id="吞吐量优化HDD（st1）"><a href="#吞吐量优化HDD（st1）" class="headerlink" title="吞吐量优化HDD（st1）"></a>吞吐量优化HDD（st1）</h3><ul><li>低成本HDD卷。适用于频繁访问的，吞吐量密集型工作负载。</li><li><strong>应用场景：</strong>大数据，数据仓库，日志处理等需要大量顺序读写操作的应用程序。</li></ul><h3 id="Cold-HDD（st1）"><a href="#Cold-HDD（st1）" class="headerlink" title="Cold HDD（st1）"></a>Cold HDD（st1）</h3><ul><li>最低成本的HDD卷，适用于较少访问的工作负载。</li><li><strong>应用场景：</strong>适合用于冷数据存储，如备份和灾难恢复。</li></ul><h3 id="磁带（standard）"><a href="#磁带（standard）" class="headerlink" title="磁带（standard）"></a>磁带（standard）</h3><ul><li>之前的基础性能HDD卷，现在以及不推荐使用，因为AWS提供更高性能和成本效益更高的选项。</li></ul><h3 id="选择EBS卷类型，考虑因素"><a href="#选择EBS卷类型，考虑因素" class="headerlink" title="选择EBS卷类型，考虑因素"></a>选择EBS卷类型，考虑因素</h3><ul><li>性能：IOPS，吞吐，延迟</li><li>数据访问频率，频繁访问的数据适合SSD，偶尔访问的数据适合HDD。</li><li>成本：预算和成本效益</li><li>耐久性和可用性：重要应用程序可能需要更高的耐久性和可用性</li></ul><h2 id="快照功能"><a href="#快照功能" class="headerlink" title="快照功能"></a>快照功能</h2><ul><li>创建EBS卷的快照，并存储在S3中，用于数据备份和恢复</li><li>快照捕获了某一时刻卷上的数据状态，并将这些数据存储在S3中<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3>对一个EBS卷进行快照备份时，仅仅是新的或者被修改过的块会被保存在S3。如果创建了多个快照，S3不会为未更改的块进行重复存储，而是自上次快照以来变化的块。</li></ul><h3 id="持久性和可靠性"><a href="#持久性和可靠性" class="headerlink" title="持久性和可靠性"></a>持久性和可靠性</h3><p>快照在S3上，是一个高持久性的存储服务，数据会自动复制到多个设施，确保其耐久性。</p><h3 id="点对点复制"><a href="#点对点复制" class="headerlink" title="点对点复制"></a>点对点复制</h3><p>可以跨AWS区域复制，对于灾难恢复和数据中心迁移非常有用。</p><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>原始EBS卷加密，快照也会自动加密。同样，从加密快照创建任何新的EBS卷也会自动假面。</p><h3 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h3><p>快照是增量的，所以它们通常比完整卷备份更加经济。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>允许自动创建和删除快照，便于用户按照自定义的策略维护快照</p><h3 id="共享或私有"><a href="#共享或私有" class="headerlink" title="共享或私有"></a>共享或私有</h3><p>快照可以与特定的AWS账户共享，或者公开共享给所有AWS用户。允许数据和配置的共享，同时支持软件供应商分发产品。</p><h1 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h1><ul><li>是Amazon Simple Storage Service一个对象存储服务</li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><ul><li>无限存储：S3提供几乎无限的存储空间，可以在需要时随时存储和检索任意数量数据</li><li>自动扩展：其实没有s3自动扩展这说法，只是他会适应存储数据量，无需手动去干预</li></ul><h2 id="数据可用性和持久性"><a href="#数据可用性和持久性" class="headerlink" title="数据可用性和持久性"></a>数据可用性和持久性</h2><ul><li>高持久性：S3提供99.999999999%的持久性，确保数据不会因为硬件问题而丢失<h3 id="多区域复制"><a href="#多区域复制" class="headerlink" title="多区域复制"></a>多区域复制</h3></li><li>多区域复制是一项功能，允许自动复制S3存储桶中对象到一个或者多个不同AWS区域的目标存储桶中<h4 id="数据复制策略"><a href="#数据复制策略" class="headerlink" title="数据复制策略"></a>数据复制策略</h4></li><li>可以设置复制策略来指定哪些数据需要被复制，可以是存储桶中的所有数据，也可以是符合特定前缀或标签的数据</li></ul><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><ul><li>多区域复制要求源存储桶启动版本控制，确保每个版本对象都会被复制到目标存储桶</li></ul><h4 id="延迟和一致性"><a href="#延迟和一致性" class="headerlink" title="延迟和一致性"></a>延迟和一致性</h4><p>复制操作通常是异步的，到目标区域会有延迟</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><p>多区域复制会产生额外的成本，包括数据传输费用和目标区域存储的费用</p><h4 id="数据加密-1"><a href="#数据加密-1" class="headerlink" title="数据加密"></a>数据加密</h4><p>支持复制过程中，用AWS提供的加密键（SSE-S3或SSE-KMS）或自己的加密键位（SSE-C）</p><h5 id="SSE-S3"><a href="#SSE-S3" class="headerlink" title="SSE-S3"></a>SSE-S3</h5><ul><li>是Amazon S3提供的服务端加密的一种方式，会自动使用多租户硬件安全模块HSM管理的密钥进行数据加密<br>如何工作：</li><li>当上传文件到S3时，可以指定使用SSE-S3进行加密</li><li>S3会为每个保存的对象生成一个唯一的密钥，使用该密钥对数据进行加密，把加密的数据保存的存储中</li><li>将每个对象的密钥进一步使用一个主密钥进行加密，这个主密钥是定期轮换的</li><li>访问数据时，会自动处理解密过程，可以像访问未加密的数据一样访问加密数据</li></ul><p>特点：<br>简单易用：SSE-S3 的操作非常简单，只需要在上传对象时指定使用 SSE-S3 加密即可，其余的加密和解密过程都由 Amazon S3 自动管理。<br>透明：对于使用 SSE-S3 加密的数据，用户在访问时不会感觉到任何不同，因为加密和解密都是透明进行的。<br>安全性：使用 SSE-S3 加密的数据，其密钥管理和保护是由 AWS 的硬件安全模块（HSM）来完成的，这提供了很高的安全保障。<br>自动加密：默认情况下，所有新的 S3 存储桶都会自动使用 SSE-S3 加密新上传的对象，除非您指定了其他加密方式。</p><p>注意事项：<br>性能影响：使用 SSE-S3 加密可能会对性能产生微小的影响，因为每次读取和写入操作都需要进行加密和解密操作。<br>成本：虽然 AWS 不额外收费用于 SSE-S3 加密，但是如果您使用了 S3 提供的额外密钥管理功能，如 AWS Key Management Service (KMS)，则可能会产生额外费用。<br>权限：如果您的 AWS Identity and Access Management (IAM) 策略不允许使用 SSE-S3，那么尝试上传文件时可能会遇到权限问题。</p><h5 id="SSE-KMS"><a href="#SSE-KMS" class="headerlink" title="SSE-KMS"></a>SSE-KMS</h5><ul><li>是Amazon S3的另一种服务端加密选项，提供更多的用户控制权和审计跟踪</li><li>如何工作：<br>当您启用 SSE-KMS 时，您可以选择使用由 KMS 管理的默认服务密钥，也可以在 KMS 中创建自己的客户主密钥（CMK）。<br>当您上传数据到 S3 时，您需要指定使用 KMS 密钥进行加密。<br>S3 将与 KMS 通信，使用指定的 CMK 对数据进行加密，并将加密的数据保存到存储中。<br>当您需要读取数据时，S3 将请求 KMS 解密数据，然后将解密后的数据返回给您。</li></ul><p>特点：<br>用户控制的密钥：您可以创建、管理和使用您自己的加密密钥，也可以使用由 AWS 管理的默认密钥。<br>密钥轮换：KMS 支持自动轮换密钥，提高了安全性。<br>审计日志：与 KMS 集成的 AWS CloudTrail 提供了密钥使用情况的审计日志，方便审计和合规。<br>细粒度权限：您可以使用 IAM 策略精确控制谁可以使用哪些密钥来加密和解密数据。</p><p>注意事项：<br>性能影响：与 SSE-S3 类似，使用 SSE-KMS 也可能会对性能产生微小的影响，尤其是在加密和解密操作时。<br>成本：使用 KMS 管理的密钥可能会产生额外的费用，包括密钥存储费用和密钥使用费用。<br>权限管理：需要确保适当的 IAM 策略和权限设置，以便用户可以正确地使用 KMS 密钥。</p><h4 id="权限和角色"><a href="#权限和角色" class="headerlink" title="权限和角色"></a>权限和角色</h4><p>适当IAM角色和权限来设置和管理多区域复制</p><h2 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h2><ul><li>数据加密：S3支持服务端加密数据，以及在传输过程中使用SSL/TLS加密数据</li></ul><h3 id="过程中SSL-TLS加密"><a href="#过程中SSL-TLS加密" class="headerlink" title="过程中SSL/TLS加密"></a>过程中SSL/TLS加密</h3><ul><li>机密协议：AWS S3使用的是SSL/TLS协议在加密传输中的数据，确保互联网安全</li><li>自动加密： 通过HTTPS向S3上传或从S3下载数据时候，SSL/TLS加密是自动应用的，以为这无需进行额外的配置</li><li>端点安全：使用HTTPS连接可以确保您的数据在从客户端到S3端点的整个路径上都是加密的。</li><li>与存储中加密的区别：需要注意的是，传输中加密与存储中加密（例如S3的服务器端加密）是不同的。存储中加密关注的是数据在S3存储桶中处于静止状态时的加密，而传输中加密关注的是数据移动时的安全性。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>优化的性能：S3 提供了优化的性能，尤其是对于分布式应用和大数据工作负载。<br>并行传输：S3 支持多部分上传和下载，使得大文件可以分成小块并行处理，提高数据传输速度。</p><h2 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h2><p>生命周期管理：S3 提供了生命周期管理策略，允许你自动转移或删除在一定时间后不再需要的数据。<br>存储类别：S3 提供多种存储类别，如 S3 Standard、S3 Intelligent-Tiering、S3 Standard-IA（低频访问）、S3 One Zone-IA（单可用区低频访问）和 S3 Glacier（用于长期存档），以适应不同的成本和访问频率需求。<br>监控和日志记录：S3 提供了监控工具，如 S3 访问日志和 AWS CloudTrail，以及与 Amazon CloudWatch 的集成，以便于监控和记录存储操作。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>存储在S3的数据可以用各种AWS的分析服务</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>数据分析服务可以有<a href="#amazon-athena">Amazon Athena</a>,<a href="#amozon-redshift">Amozon Redshift</a>,<a href="#amazon-emr">Amazon EMR</a></p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>数据转换服务可以有<a href="#aws-glue">AWS Glue</a> ，<a href="#aws-data-pipeline">AWS Data Pipeline</a> ，<a href="#aws-lambda">AWS Lambda</a></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>AWS提供了一系列机器学习服务，如<a href="#amazon-sagemaker">Amazon SageMaker</a>、<a href="#amazon-rekognition">Amazon Rekognition</a>、<a href="#amazon-comprehend">Amazon Comprehend</a>等，可以在S3上的数据上构建和训练机器学习模型。</p><h2 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h2><h3 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h3><ul><li>检索速度必然是比S3存储要长的，主要是因为大数量和低频访问</li><li>S3 Glacier的检索会产生额外的检索费用，取决于数据大小和检索速度</li><li>可指定检索选项</li></ul><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>可以用生命周期策略自动将数据从S3标准存储转移到S3 Glacier</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一般都是在需要存储大量数据但又不经常访问的场景</p><h1 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h1><h2 id="DNS功能"><a href="#DNS功能" class="headerlink" title="DNS功能"></a>DNS功能</h2><p>域名注册与转移：Route 53 允许用户注册新的域名或将现有域名从其他注册商转移到 AWS。</p><p>托管区域（Hosted Zones）：在 Route 53 中，托管区域是一个容器，它包含了处理一个域名及其子域名的 DNS 记录。托管区域分为公有托管区域和私有托管区域。</p><p>DNS 记录类型：Route 53 支持多种 DNS 记录类型，包括 A (地址记录)，AAAA (IPv6 地址记录)，CNAME (规范名称记录)，MX (邮件交换记录)，TXT (文本记录)，NS (名称服务器记录) 和 SOA (起始授权机构记录) 等。</p><p>路由策略：Route 53 提供多种路由策略，如简单路由、加权路由、延迟路由、故障转移路由和地理位置路由等，允许用户根据不同的条件来路由流量。</p><p>别名记录：Route 53 的别名记录允许将一个域名映射到 AWS 资源，例如 Amazon S3 存储桶、Elastic Load Balancing (ELB) 负载均衡器或另一个 Route 53 托管区域中的域名。与 CNAME 记录不同，别名记录可以用于域名的根节点（例如 example.com）。</p><p>DNS 查询日志：用户可以配置 Route 53 以记录所有对托管区域的 DNS 查询，这有助于调试和监控 DNS 活动。</p><p>DNSSEC：Route 53 支持 DNS 安全扩展 (DNSSEC)，这是一种增强 DNS 安全性的协议，可以保护域名解析过程不被篡改。</p><p>全球分布的 DNS 服务器：Route 53 使用全球分布的 DNS 服务器和 Anycast 路由技术，确保 DNS 查询响应迅速且可靠。</p><h3 id="DNSSEC安全扩展"><a href="#DNSSEC安全扩展" class="headerlink" title="DNSSEC安全扩展"></a>DNSSEC安全扩展</h3><p>保护互联网用户免受伪造DNS数据（缓存投毒）的攻击，通过对DNS响应进行数字签名</p><p>主要步骤：<br>生成密钥：为每一个DNS区域生成一次公钥和私钥。</p><p>签名记录：使用私钥对DNS区域中RRsets进行签名，签名存储再DNS作为性的记录类型，称为DNSSEC签名（RRSIG）记录。</p><p>分发公钥：将公钥作为DNSKEY记录分发再DNS中，以便任何人都可以用它来验证签名</p><p>链式信任：DNSSEC 使用一种链式信任模型，其中每个级别的 DNS 区域都会签署其下一级别的区域的密钥。这个链条一直延伸到根域名服务器，它的密钥被称为根密钥，是整个信任链的基础。</p><p>验证：当客户端（如 DNS 解析器）收到 DNSSEC 保护的响应时，它会使用存储在 DNS 中的公钥来验证响应的签名。如果验证成功，客户端可以确信该响应是未被篡改的。</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><h4 id="简单路由："><a href="#简单路由：" class="headerlink" title="简单路由："></a>简单路由：</h4><p>到单个资源，域名指向一个IP地址或一个Amazon S3 存储桶</p><h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><ul><li>单一资源服务，单个web服务器或单个Amazon S3存储桶</li><li>不需要复杂的路由决策的简单域名分析</li></ul><h4 id="加权路由："><a href="#加权路由：" class="headerlink" title="加权路由："></a>加权路由：</h4><p>允许你分配不同的权重给相同域名下的多个资源，从而控制流量的分配比例。这对于流量切换和 A/B 测试非常有用。</p><h5 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h5><ul><li>A/B 测试，将流量按照一定比例分配给不同的应用版本。</li><li>平滑的流量迁移，逐渐增加指向新资源的流量比例。</li><li>负载分配，根据服务器能力分配不同的权重。</li></ul><h4 id="延迟路由"><a href="#延迟路由" class="headerlink" title="延迟路由"></a>延迟路由</h4><p>根据用户到 AWS 区域的网络延迟自动路由用户请求。这有助于向用户提供最低延迟的响应。</p><h5 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h5><ul><li>多区域部署，根据用户到 AWS 区域的延迟选择最佳路由。</li><li>性能优化，确保用户获得最快的响应时间。</li></ul><h4 id="故障转移路由"><a href="#故障转移路由" class="headerlink" title="故障转移路由"></a>故障转移路由</h4><p>在主要资源发生故障时，自动将流量切换到备份资源。这对于实现高可用性和灾难恢复非常关键。</p><h5 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h5><ul><li>灾难恢复，当主要资源发生故障时自动切换到备用资源。</li><li>高可用性配置，配合健康检查确保服务不间断<h4 id="地理位置路由"><a href="#地理位置路由" class="headerlink" title="地理位置路由"></a>地理位置路由</h4>根据用户的地理位置将流量路由到特定的资源。这可以用于内容本地化或遵守地理位置相关的法律法规。</li></ul><h5 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h5><ul><li>地理目标定位，向特定地理区域的用户提供定制化内容。</li><li>法规遵从，确保数据存储和处理遵守特定地区的法律法规。</li><li>负载分散，将用户流量分散到不同的区域以减轻特定服务器的负载。<h4 id="地理位置优先路由"><a href="#地理位置优先路由" class="headerlink" title="地理位置优先路由"></a>地理位置优先路由</h4>根据用户和资源之间的地理位置距离来路由流量。可以通过使用“偏置值”来调整流量的分配<h5 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h5></li><li>地理位置敏感的负载均衡，更精细地控制基于用户位置的流量分配。</li><li>业务扩展，根据业务需求和用户位置动态调整流量。<h4 id="多值答案路由"><a href="#多值答案路由" class="headerlink" title="多值答案路由"></a>多值答案路由</h4>当你想要 Route 53 返回多个资源的 IP 地址，并且希望 Route 53 对这些资源进行健康检查时，可以使用这种策略。</li></ul><h5 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h5><ul><li>提供了内置健康检查的简单负载均衡。</li><li>当有多个资源可以提供服务时，增加系统的容错能力。</li><li>需要从多个资源中返回单个或多个健康资源的 IP 地址。</li></ul><h2 id="Route-53-的Best-Match"><a href="#Route-53-的Best-Match" class="headerlink" title="Route 53 的Best Match"></a>Route 53 的Best Match</h2><h3 id="与EC2配合实现静态网站托管"><a href="#与EC2配合实现静态网站托管" class="headerlink" title="与EC2配合实现静态网站托管"></a>与EC2配合实现静态网站托管</h3><ul><li>Route 53 可以将流量路由运行在Amazon EC2实例上的应用程序</li><li>使用故障转移路由来监控EC2实例的健康状况，在需要时将流量自动切换到备用实例</li></ul><h3 id="与ELB配合实现高可用性和负载均衡"><a href="#与ELB配合实现高可用性和负载均衡" class="headerlink" title="与ELB配合实现高可用性和负载均衡"></a>与ELB配合实现高可用性和负载均衡</h3><ul><li>ELB自动分配进来的应用流量到多个EC2实例，以提高容错能力和可伸缩性</li><li>Route 53可以直接与ELB集成，将域名解析到ELB的DNS名称，而不是特定的IP地址</li></ul><h3 id="与S3配合实现静态网站托管"><a href="#与S3配合实现静态网站托管" class="headerlink" title="与S3配合实现静态网站托管"></a>与S3配合实现静态网站托管</h3><ul><li>可以以将域名解析到一个Amazon存储桶，这个存储桶配置为静态网站</li></ul><h3 id="与Lambda和API-Gateway配合实现无服务器架构"><a href="#与Lambda和API-Gateway配合实现无服务器架构" class="headerlink" title="与Lambda和API Gateway配合实现无服务器架构"></a>与Lambda和API Gateway配合实现无服务器架构</h3><ul><li>Route 53 可以将流量路由到一个API Gateway，后者触发Lambda函数来处理请求</li><li>架构可以构建完全无服务器的应用，轻松扩展且成本效益高</li></ul><h3 id="与CloudFront配合实现全球内容分发"><a href="#与CloudFront配合实现全球内容分发" class="headerlink" title="与CloudFront配合实现全球内容分发"></a>与CloudFront配合实现全球内容分发</h3><ul><li>将用户请求解析到最近的CloudFront边缘位置，加速内容的分发</li></ul><h3 id="与shield配合实现防御分布式拒绝服务DDOS攻击"><a href="#与shield配合实现防御分布式拒绝服务DDOS攻击" class="headerlink" title="与shield配合实现防御分布式拒绝服务DDOS攻击"></a>与shield配合实现防御分布式拒绝服务DDOS攻击</h3><ul><li>托管型DDos防护服务，可以保护在AWS上运行的应用不受DDos攻击</li></ul><h3 id="与WAF配合实现应用层防护"><a href="#与WAF配合实现应用层防护" class="headerlink" title="与WAF配合实现应用层防护"></a>与WAF配合实现应用层防护</h3><ul><li>是一种Web应用防火墙，保护Web应用免受常见的网络和应用层攻击。</li><li>为域名提供基于规则的控制，防止恶意流量到达应用</li></ul><h3 id="与RDS实现数据库故障转移"><a href="#与RDS实现数据库故障转移" class="headerlink" title="与RDS实现数据库故障转移"></a>与RDS实现数据库故障转移</h3><ul><li>Route 53 可以与Amazon RDS配合实现数据库的故障转移和读取复制</li></ul><h3 id="与VPC配合使用构建私有云解析和内部域名服务"><a href="#与VPC配合使用构建私有云解析和内部域名服务" class="headerlink" title="与VPC配合使用构建私有云解析和内部域名服务"></a>与VPC配合使用构建私有云解析和内部域名服务</h3><ul><li>通过私有托管区域，企业可以管理内部域名，而这些域名不会被路由到公共互联网上</li></ul><h3 id="与Transit-Gateway实现多区域网络连接"><a href="#与Transit-Gateway实现多区域网络连接" class="headerlink" title="与Transit Gateway实现多区域网络连接"></a>与Transit Gateway实现多区域网络连接</h3><ul><li>AWS Transit Gateway 允许连接多个 VPC 和本地网络，形成一个中心式的网络枢纽。</li><li>Route 53 可以用来解析跨这些连接的 VPCs 内部的服务名称。</li></ul><h3 id="与-AWS-Direct-Connect-配合混合云环境"><a href="#与-AWS-Direct-Connect-配合混合云环境" class="headerlink" title="与 AWS Direct Connect 配合混合云环境"></a>与 AWS Direct Connect 配合混合云环境</h3><ul><li>AWS Direct Connect 通过私有连接将企业数据中心连接到 AWS，绕过公共互联网，提高安全性和带宽。</li><li>Route 53 可以用来解析通过 Direct Connect 连接的资源，保证内部和外部解析的一致性。</li></ul><h3 id="与ACM构建SSL-TLS证书管理"><a href="#与ACM构建SSL-TLS证书管理" class="headerlink" title="与ACM构建SSL/TLS证书管理"></a>与ACM构建SSL/TLS证书管理</h3><ul><li>简化了SSL/TLS证书的获取，管理和部署过程</li><li>自动使用DNS验证来验证域名的所有权并且自动续签证书</li></ul><h3 id="与EC2和EKS构建容器化应用和微服务"><a href="#与EC2和EKS构建容器化应用和微服务" class="headerlink" title="与EC2和EKS构建容器化应用和微服务"></a>与EC2和EKS构建容器化应用和微服务</h3><ul><li>ECS和EKS提供容器服务</li><li>Route 53可以与ECS和EKS集成，通过服务发现机制自动注册和解除注册容器实例，使微服务架构中的服务能够相互发现和通信</li></ul><h1 id="稍微理解"><a href="#稍微理解" class="headerlink" title="稍微理解"></a>稍微理解</h1><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend +"></a>Amazon Comprehend +</h2><ul><li>一项自然语言（NLP）服务，使用机器学习技术赖解析文本中的洞察和关系</li></ul><ol><li><strong>实体识别（Entity Recognition）</strong>：能够识别文本中的具体实体，如人名、地点、品牌或其他专有名词。</li><li><strong>情感分析（Sentiment Analysis）</strong>：分析文本的情感倾向，判断它是正面的、负面的、中性的还是复合情感的。</li><li><strong>关键词提取（Key Phrase Extraction）</strong>：从文本中提取重要的或者有意义的短语。</li><li><strong>语言识别（Language Detection）</strong>：自动识别文本所使用的语言。</li><li><strong>句法分析（Syntax Analysis）</strong>：分析文本中的语言构成，比如词性标注和句子成分分析。</li><li><strong>主题建模（Topic Modeling）</strong>：识别文档集合中的主题模式。</li></ol><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p><strong>Amazon Rekognition</strong> 是一项基于深度学习的图像和视频分析服务。它可以识别图像和视频中的对象、场景、文字以及人脸。Rekognition 提供了多种功能，包括：</p><ul><li><strong>人脸分析</strong>：识别人脸、检测面部特征、评估情绪等。</li><li><strong>人脸比对</strong>：比对两张人脸图像，判断它们是否属于同一个人。</li><li><strong>人脸搜索</strong>：在大型图像库中搜索特定人脸。</li><li><strong>文本识别</strong>：检测和识别图像中的文字。</li><li><strong>场景分析</strong>：识别图像中的场景和对象。</li></ul><p>开发者可以通过简单的 API 调用来使用这些功能，从而构建各种视觉分析应用。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p><strong>Amazon SageMaker</strong> 是一项全面的机器学习平台，旨在简化机器学习模型的构建、训练和部署过程。SageMaker 提供了以下功能：</p><ul><li><strong>数据标注</strong>：帮助准备训练数据。</li><li><strong>模型训练</strong>：使用各种机器学习算法训练模型。</li><li><strong>模型调优</strong>：优化模型性能。</li><li><strong>模型部署</strong>：将训练好的模型部署到生产环境中。</li></ul><p>SageMaker 支持多种常见的机器学习算法和框架，同时提供了一个交互式的开发环境，方便开发者快速迭代和部署模型。</p><h2 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h2><p><strong>AWS Lambda</strong> 是一项无服务器计算服务，开发者可以在 Lambda 上运行代码而无需管理服务器。Lambda 可以根据各种事件（如 API 调用、文件上传等）触发执行代码，支持多种编程语言，包括 Python、Node.js、Java 等。Lambda 的特点包括：</p><ul><li><strong>弹性扩展</strong>：根据请求量自动扩展计算资源。</li><li><strong>按需计费</strong>：只需为实际使用的计算资源付费。</li><li><strong>事件驱动</strong>：可以与多种 AWS 服务集成，响应各种事件。</li></ul><p>Lambda 适用于构建无服务器应用、自动化任务、数据处理等场景。</p><h2 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h2><p><strong>AWS Data Pipeline</strong> 是一项数据处理服务，用于自动化和调度数据处理工作流程。开发者可以使用 Data Pipeline 来定义数据处理流程、调度任务执行、跟踪任务状态等。Data Pipeline 提供了以下功能：</p><ul><li><strong>数据源连接</strong>：支持多种数据源，包括 AWS 服务和外部数据存储。</li><li><strong>灵活调度</strong>：可以根据时间表、事件触发等条件调度任务。</li><li><strong>任务监控</strong>：提供任务状态监控和报警功能。</li></ul><p>Data Pipeline 可以帮助简化数据处理流程，提高数据处理的效率和可靠性。</p><h2 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h2><p><strong>AWS Glue</strong> 是一项全托管的数据集成服务，用于抽取、转换和加载数据。Glue 可以自动发现数据源、推断数据模式、执行数据转换操作，并将数据加载到目标数据存储中。Glue 的主要功能包括：</p><ul><li><strong>数据目录</strong>：自动创建和维护数据目录。</li><li><strong>ETL 转换</strong>：支持数据抽取、转换和加载。</li><li><strong>数据目录版本控制</strong>：管理数据目录版本。</li></ul><p>AWS Glue 可以帮助用户简化数据集成和数据准备的过程，加速数据处理和分析的流程。</p><h2 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h2><p><strong>Amazon EMR</strong> 是一项大数据处理服务，基于开源的 Apache Hadoop 和 Apache Spark 构建。EMR 可以帮助用户快速搭建、扩展和管理大数据处理集群，用于分析、处理大规模数据集。EMR 提供了以下特点：</p><ul><li><strong>弹性扩展</strong>：根据需求自动扩展集群规模。</li><li><strong>多种框架支持</strong>：支持 Hadoop、Spark、Presto 等多种大数据处理框架。</li><li><strong>安全性和可靠性</strong>：提供数据加密、访问控制等安全特性。</li></ul><p>EMR 可以帮助用户快速搭建大数据处理环境，进行数据分析和处理。</p><h2 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p><strong>Amazon Redshift</strong> 是一种云数据仓库服务，用于分析大规模数据集。Redshift 提供了高性能的数据查询和分析能力，支持列式存储、压缩和并行查询等特性。Redshift 的特点包括：</p><ul><li><strong>高性能</strong>：支持大规模数据并行处理，提供快速的查询性能。</li><li><strong>可扩展性</strong>：可以根据需求扩展集群规模。</li><li><strong>SQL 兼容</strong>：支持标准 SQL 查询语言。</li></ul><p>Redshift 可以帮助用户构建数据仓库和商业智能应用，进行复杂的数据分析和查询。</p><h2 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h2><p><strong>Amazon Athena</strong> 是一项交互式查询服务，用于在亚马逊 S3 存储中执行 SQL 查询。Athena 可以帮助用户快速分析存储在 S3 中的数据，无需预先加载数据到数据库中。Athena 的特点包括：</p><ul><li><strong>无服务器</strong>：无需管理基础设施，按需执行查询。</li><li><strong>标准 SQL</strong>：支持标准 SQL 查询语言。</li><li><strong>数据格式支持</strong>：支持多种数据格式，如 CSV、JSON 等。</li></ul><p>Athena 可以帮助用户快速进行数据查询和分析，适用于需要快速查询大规模数据集的场景。</p><h1 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h1><h2 id="无服务器集成"><a href="#无服务器集成" class="headerlink" title="无服务器集成"></a>无服务器集成</h2><p>无服务器集成是能够将API端点直接连接到无服务器后端服务，如Lambda和DynamoDB，不需要运行或管理任何服务器，这种集成方式简化了API部署和管理，因为AWS负责所有的基础设置管理。</p><h3 id="Lambda集成"><a href="#Lambda集成" class="headerlink" title="Lambda集成"></a>Lambda集成</h3><p>API Gateway可以将请求直接路由到Lambda函数，当API被调用时，触发一个Lambda函数，该函数执行业务逻辑然后返回响应，允许你构建强大的后端逻辑，无需担心服务器的运行和维护</p><h3 id="DynamoDB集成"><a href="#DynamoDB集成" class="headerlink" title="DynamoDB集成"></a>DynamoDB集成</h3><p>API Gateway可以直接与DynamoDB集成，运行API直接执行DynamoDB表上的操作，如获取项目，写入项目等。API Gateway，创建一个完全无服务的后端，用于存储和检索数据。</p><h3 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h3><p>创建Lambda函数或DynamoDB表，设置API Gateway资源，创建新的API，配置集成请求和响应，部署，用CloudWatch监控API调用和Lambda函数执行，确保性能和可靠性</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>API Gateway 提供了几种流量控制机制，帮助开发者防止过载后端服务</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>默认节流：对每个账户提供默认的节流限制，这些限制是以每秒请求数TPS和并发限制来定义的，如果超过限制则会返回429错误</li><li>自定义节流</li></ul><h3 id="使用计划"><a href="#使用计划" class="headerlink" title="使用计划"></a>使用计划</h3><ul><li>允许用户创建使用计划，并与API密钥关联，可定义API密钥允许请求频率的限制和配额限制</li></ul><h3 id="突发限制"><a href="#突发限制" class="headerlink" title="突发限制"></a>突发限制</h3><ul><li>突发限制是指在短时间内允许的最大请求数。这对于处理短时间内的突然流量增加很有用，同时确保后端服务不会因为大量并发请求而过载。</li></ul><h3 id="客户端限流"><a href="#客户端限流" class="headerlink" title="客户端限流"></a>客户端限流</h3><ul><li>开发者可以在客户端实施限流措施，这通常是通过重试逻辑和指数退避策略来实现的。这有助于在客户端自动处理和平滑处理 429 错误。</li></ul><h2 id="数据转换-1"><a href="#数据转换-1" class="headerlink" title="数据转换"></a>数据转换</h2><p>API Gateway 中实现数据转换的主要工具是模板和模型：</p><h3 id="模板（Mapping-Templates）"><a href="#模板（Mapping-Templates）" class="headerlink" title="模板（Mapping Templates）"></a>模板（Mapping Templates）</h3><p>API Gateway 允许你使用 Velocity Template Language (VTL) 和 JSONPath 表达式来创建映射模板。这些模板定义了如何将客户端请求转换为后端服务所期望的格式，以及如何将后端服务的响应转换为客户端所期望的格式。</p><p>请求模板：在请求模板中，你可以添加逻辑来定制请求有效载荷，例如添加或删除 JSON 字段，修改头部信息，或者根据请求参数构建一个全新的请求体。<br>响应模板：响应模板允许你修改从后端服务返回的数据。你可以转换数据格式，只返回客户端需要的部分数据，或者处理错误响应。</p><h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>模型是 API Gateway 中定义的数据结构，它们使用 JSON Schema 描述了 API 的请求和响应数据。模型可以帮助你标准化数据结构，并为你的 API 用户提供清晰的数据格式文档。<br>请求模型：定义了 API 接收的数据结构，可以用来校验请求数据。<br>响应模型：定义了 API 返回的数据结构，可以用来校验响应数据。<br>利用这些数据转换功能，开发者可以确保 API 的前端和后端之间的通信是平滑和一致的，即使它们可能使用不同的数据格式或标准。这也使得 API Gateway 成为一个强大的工具，用于在不修改后端服务的情况下，快速适应前端应用程序的变化需求。</p><h2 id="RESTful-API-和-WebSocket-API"><a href="#RESTful-API-和-WebSocket-API" class="headerlink" title="RESTful API 和 WebSocket API"></a>RESTful API 和 WebSocket API</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>RESTful API 是一种基于 HTTP 协议的 Web API。它遵循 REST 架构原则，通常使用标准的 HTTP 方法，如 GET、POST、PUT、DELETE 等。API Gateway 中的 RESTful API 提供以下特性：</p><p>无服务器集成：可以直接与 AWS Lambda 函数或其他 AWS 服务集成，无需运行或管理服务器。<br>数据转换：通过映射模板对请求和响应进行转换和重写。<br>流量控制：包括节流、使用计划和配额管理。<br>安全性：支持 API 密钥、AWS IAM 角色和权限以及 Cognito 用户池进行身份验证和授权。<br>版本管理和生命周期管理：支持多个发布阶段和版本控制。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控API调用和记录日志。<br>缓存：可以配置 API 缓存以减少延迟和后端负载。<br>RESTful API 适用于大多数标准的 Web 应用程序场景，特别是那些需要严格的状态无关和资源导向架构的场景。</p><h3 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h3><p>WebSocket API 提供了全双工通信通道，允许服务器和客户端之间进行实时、双向的通信。API Gateway 中的 WebSocket API 具有以下特性：</p><p>连接管理：API Gateway 负责连接的建立和维护。<br>规模扩展：可以根据连接数自动扩展，支持大量并发WebSocket连接。<br>路由选择：基于传入的消息内容，将不同的消息路由到不同的后端服务，如 AWS Lambda 或 HTTP 终端节点。<br>集成后端服务：与 AWS Lambda 和 HTTP API 直接集成，无需管理服务器。<br>安全性：可以使用 AWS IAM、Lambda 授权器或自定义授权器来管理连接和消息的授权。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控连接和消息传递。<br>WebSocket API 适用于需要实时通信的应用程序，如聊天应用、实时游戏、实时通知和协作工具。</p><h2 id="SDK集成"><a href="#SDK集成" class="headerlink" title="SDK集成"></a>SDK集成</h2><p>Amazon API Gateway 提供了与各种编程语言的 SDK 集成支持，这样开发者可以在他们选择的编程语言中更容易地调用由 API Gateway 托管的 API。这些 SDKs，通常称为客户端 SDKs，是自动生成的，并且可以针对已经部署的 API 生成。</p><p>以下是 API Gateway 与 SDK 集成的一些关键点：</p><h3 id="SDK-生成"><a href="#SDK-生成" class="headerlink" title="SDK 生成"></a>SDK 生成</h3><p>对于 RESTful API，API Gateway 允许开发者生成客户端 SDK 来调用 API。这些 SDK 可以针对以下平台生成：</p><ul><li>Android</li><li>iOS (Objective-C 和 Swift)</li><li>JavaScript (适用于浏览器和 Node.js)</li></ul><p>生成 SDK 的过程通常涉及到在 API Gateway 控制台中选择你的 API 阶段，然后选择你想要生成的 SDK 的类型。API Gateway 会为你生成一个包含所有必要调用逻辑和数据结构的压缩文件。</p><h3 id="SDK-的使用"><a href="#SDK-的使用" class="headerlink" title="SDK 的使用"></a>SDK 的使用</h3><p>生成的 SDK 会包含对应语言的库和工具，使得客户端应用程序可以轻松地与 API Gateway 进行通信。例如，生成的 JavaScript SDK 会包含 API 调用的 AJAX 请求代码，而 iOS SDK 会包含构建网络请求的代码。</p><p>使用这些 SDK，开发者可以快速地在他们的应用程序中实现以下功能：</p><ul><li>调用 API Gateway 托管的 API。</li><li>处理请求和响应，包括错误处理。</li><li>传递身份验证和授权信息，如果 API 使用了 API 密钥、AWS IAM 或 Amazon Cognito 用户池。</li></ul><h3 id="SDK-定制和优化"><a href="#SDK-定制和优化" class="headerlink" title="SDK 定制和优化"></a>SDK 定制和优化</h3><p>尽管 SDK 是自动生成的，但开发者仍然可以根据需要对其进行定制。例如，他们可以添加额外的逻辑来处理特定的应用程序场景，或者改进错误处理和重试策略。</p><p>此外，开发者可能需要考虑 SDK 如何影响应用程序的性能和大小，特别是在移动应用程序中。他们可能需要优化网络请求，或者去除未使用的 SDK 部分以减小应用程序的体积。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>使用 SDK 时，安全性是一个重要考虑因素。开发者需要确保他们的应用程序安全地存储和传递任何敏感信息，如 API 密钥或用户凭证。此外，他们可能需要实施额外的安全措施，如使用 HTTPS 来保护数据在传输过程中的安全，或者使用 OAuth 和 Amazon Cognito 来为用户提供安全的身份验证和授权。</p><p>总的来说，API Gateway 的 SDK 集成简化了客户端应用程序与后端服务的交互，允许开发者专注于构建应用程序的核心功能，而不是编写重复的代码来处理 API 调用。通过自动化的 SDK 生成和简单的集成过程，API Gateway 使得从客户端应用程序到云端服务的开发变得更加快捷和高效。</p><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>AWS Lambda 是亚马逊网络服务（Amazon Web Services, 简称AWS）提供的一项无服务器计算服务。它允许你运行代码，而无需预置或管理服务器。</p><h2 id="事件驱动执行"><a href="#事件驱动执行" class="headerlink" title="事件驱动执行"></a>事件驱动执行</h2><ul><li>通过事件触发执行，也可以来自于应用程序的自定义事件</li></ul><h3 id="举例场景：Lambda处理在S3上传新文件时触发"><a href="#举例场景：Lambda处理在S3上传新文件时触发" class="headerlink" title="举例场景：Lambda处理在S3上传新文件时触发"></a>举例场景：Lambda处理在S3上传新文件时触发</h3><p>1.需要创建一个新的Lambda函数，选为某编程语言运行<br>2.把函数分配一个执行角色，这里就是有权读取S3的对象，写入CloudWatch日志<br>3.在S3中设置事件通知，在上传时触发Lambda函数，可以在S3存储属性中找到，把Lambda函数作为目标。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例代码</span></span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote_plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志记录</span></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 S3 客户端</span></span><br><span class="line">s3_client = boto3.client(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># 获取存储桶名称和文件键值</span></span><br><span class="line">    bucket_name = event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;bucket&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    file_key = unquote_plus(event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;object&#x27;</span>][<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录到 CloudWatch 日志中</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;New file uploaded: <span class="subst">&#123;file_key&#125;</span> in bucket: <span class="subst">&#123;bucket_name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里可以添加更多处理逻辑，例如读取文件内容、转换文件格式等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;File processed successfully!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="无服务器架构"><a href="#无服务器架构" class="headerlink" title="无服务器架构"></a>无服务器架构</h2><p>不需要服务器和任何环境，Lambda负责运行你的代码并自动管理底层计算资源</p><h2 id="自动扩展"><a href="#自动扩展" class="headerlink" title="自动扩展"></a>自动扩展</h2><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>一个事件触发器激活一个Lambda函数，如果有多个事件几乎同时到达，Lambda会自动启动多个实例来处理事件</p><h3 id="冷启动与热启动"><a href="#冷启动与热启动" class="headerlink" title="冷启动与热启动"></a>冷启动与热启动</h3><ul><li><p>冷启动：当一个函数被触发而当前没有可用的运行实例时，Lambda会进行一个“冷启动”，即创建一个新的函数实例。过程基本涉及到加载代码，初始化运行时，运行初始化代码（如全局变量声明）等步骤。冷启动通常需要更长启动时间。</p></li><li><p>热启动：如果一个函数实例在执行完一个时间后仍然处于空闲状态，可以被用来快速响应新的时间，这称为热启动，热启动跳过了实例创建过程比冷启动快</p></li></ul><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>Lambda在账户级别有并发执行限制。这个限制是指任何时刻，一个AWS账户可以同时运行的Lambda函数实例的数量。这个限制既保护了用户免受意外的高费用，确保资源的合理分配</p><h3 id="预热行为"><a href="#预热行为" class="headerlink" title="预热行为"></a>预热行为</h3><p>避免冷启动延迟，用户可以实现预热策略，通过定期触发Lambda函数来保持一定数量的热实例。</p><h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><h3 id="IAM角色和策略"><a href="#IAM角色和策略" class="headerlink" title="IAM角色和策略"></a>IAM角色和策略</h3><ul><li><p>创建一个 Lambda 函数时，您需要指定一个执行角色（IAM 角色）。Lambda 函数将使用这个角色的权限来访问 AWS 服务和资源。</p><h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><p>资源策略包含以下部分：</p></li><li><p>Statement：资源策略由一个或多个语句（Statement）组成，每个语句都是一个权限声明，指定了一个允许或拒绝的权限。</p></li><li><p>Effect：每个语句的 Effect 决定了这个语句是允许（Allow）还是拒绝（Deny）某项操作。</p></li><li><p>Action：Action 定义了可以在 Lambda 函数上执行的操作，例如 lambda:InvokeFunction。</p></li><li><p>Resource：Resource 指定了策略适用的资源，对于 Lambda 函数策略来说，这通常是函数的 ARN（Amazon Resource Name）。</p></li><li><p>Principal：Principal 定义了哪些 AWS 账户、用户、角色或服务可以执行在 Action 中定义的操作。</p></li><li><p>Condition：条件（Condition）用于指定策略的有效性取决于一系列预定义的条件是否满足。</p></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>下面是一个资源策略的示例，它允许另一个 AWS 账户的用户调用 Lambda 函数：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Version&quot;:</span> <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Statement&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;Effect&quot;:</span> <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Principal&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;AWS&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;Action&quot;:</span> <span class="string">&quot;lambda:InvokeFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Resource&quot;:</span> <span class="string">&quot;arn:aws:lambda:us-west-2:111122223333:function:MyFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Condition&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;StringEquals&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceAccount&quot;:</span> <span class="string">&quot;123456789012&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ArnLike&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceArn&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，只有在条件满足时（即请求来自特定账户和用户），指定的用户才能调用 MyFunction。通过使用资源策略，您可以跨账户共享 Lambda 函数，或者允许来自 AWS 服务（如 Amazon S3 事件、Amazon SNS 主题、Amazon DynamoDB 更新流等）的触发器调用您的函数。这是实现跨账户功能和集成 AWS 服务的一种强大方式。</p><h3 id="环境变量加密"><a href="#环境变量加密" class="headerlink" title="环境变量加密"></a>环境变量加密</h3><ul><li> 允许您为函数设置环境变量，用于存储配置信息。您可以使用 AWS Key Management Service (KMS) 加密这些环境变量，以保护敏感信息。<h3 id="VPC集成"><a href="#VPC集成" class="headerlink" title="VPC集成"></a>VPC集成</h3></li><li>Lambda函数可配置在VPC内运行</li></ul><h3 id="网络隔离和防火墙"><a href="#网络隔离和防火墙" class="headerlink" title="网络隔离和防火墙"></a>网络隔离和防火墙</h3><ul><li>配置 Lambda 函数在 VPC 中运行，您可以使用网络 ACL 和安全组作为网络层的防火墙，来控制流入和流出资源的流量。<h3 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h3></li><li>调用和执行情况可以通过 Amazon CloudWatch 进行监控和记录日志。您可以配置日志记录，以便在函数执行时捕获调用请求和响应数据。</li></ul><h2 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h2><p>一个经典的多服务场景，使用 AWS Lambda 的例子是一个自动化的图像处理平台。在这个场景中，用户上传图片到 Amazon S3，这会触发一个 Lambda 函数来处理这些图片（例如，压缩、转换格式、添加水印等），然后结果可以被存储在另一个 S3 桶中，或者被发送到其他服务进行进一步处理或分析。</p><p>以下是服务之间的作用和交互：</p><ol><li><p><strong>Amazon S3 (Simple Storage Service)</strong>:</p><ul><li>作为图像和处理后文件的存储位置。</li><li>触发 Lambda 函数以响应新上传的图像。</li></ul></li><li><p><strong>AWS Lambda</strong>:</p><ul><li>执行图像处理逻辑，如调整大小、格式转换或应用水印。</li><li>读取和写入 S3 桶中的文件。</li><li>可以调用其他 AWS 服务，如 Amazon Rekognition 进行图像分析。</li></ul></li><li><p><strong>Amazon Rekognition</strong>:</p><ul><li>提供图像和视频分析，如识别对象、场景和名人。</li><li>Lambda 函数可以将图像发送到 Rekognition 以获取元数据，并根据这些信息进一步处理或分类图像。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>:</p><ul><li>用于存储图像的元数据，如文件名、大小、图像类型、处理状态和 Rekognition 提供的任何分析数据。</li><li>Lambda 函数可以更新 DynamoDB 表以反映处理状态或存储分析结果。</li></ul></li><li><p><strong>Amazon SNS (Simple Notification Service)</strong> 或 <strong>Amazon SQS (Simple Queue Service)</strong>:</p><ul><li>用于通知系统的其他部分，例如，当图像处理完成时。</li><li>Lambda 函数可以发布消息到 SNS 主题或 SQS 队列，以触发其他处理流程或通知用户。</li></ul></li><li><p><strong>AWS Step Functions</strong>:</p><ul><li>管理和协调复杂的多步骤 Lambda 函数工作流。</li><li>Lambda 函数可以作为步骤函数状态机中的一个步骤，以确保处理逻辑按照预定顺序执行。</li></ul></li><li><p><strong>Amazon CloudWatch</strong>:</p><ul><li>监控 Lambda 函数的性能和日志。</li><li>Lambda 函数执行时会自动记录日志和各种指标，以供分析和调试。</li></ul></li></ol><p>在这个场景中，用户上传图片到 S3 桶，这个上传操作自动触发一个 Lambda 函数。Lambda 函数读取新上传的图片，进行必要的处理，然后将处理后的图片存储到另一个 S3 桶中。如果启用了图像分析，Lambda 函数还会调用 Amazon Rekognition。处理结果（包括图像元数据和分析数据）可以被存储到 DynamoDB。Lambda 函数还可以将处理完成的事件通过 SNS 或 SQS 发布出去，以便其他应用组件可以响应这些事件。整个处理流程可以用 AWS Step Functions 来协调。最后，Amazon CloudWatch 被用来监控整个过程，包括 Lambda 函数的性能和日志记录。</p><h1 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h1><h2 id="Classic-Load-Balancer（CLB）"><a href="#Classic-Load-Balancer（CLB）" class="headerlink" title="Classic Load Balancer（CLB）"></a>Classic Load Balancer（CLB）</h2><ul><li>支持基于TCP和HTTP/HTTPS的负载均衡</li><li>提供固定性能，但没有ALB和NLB那样灵活</li><li>支持一个简单的健康检查<h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3></li></ul><ul><li>旧的或遗留的应用程序，这些应用程序不需要复杂的路由规则，只需简单地在多个服务器之间分发流量。</li><li>示例：一个简单的网站或应用程序，客户端通过HTTP/HTTPS请求服务，CLB将请求均匀地分配给后端的多个EC2实例。</li></ul><h2 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h2><ul><li>ALB是为HTTP/HTTPS流量设计的，提供高级的请求路由功能，比如基于内容的路由。</li><li>支持路径、主机、HTTP头部、HTTP方法和查询参数等多种路由条件。</li><li>可以直接与容器化服务和微服务架构进行集成。</li><li>提供了更细粒度的健康检查。</li><li>支持WebSocket和HTTP/2。</li></ul><h3 id="场景举例-1"><a href="#场景举例-1" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>面向现代应用程序，特别是在微服务架构中，需要根据URL的不同路径将流量路由到不同的服务。</li><li>示例：一个电子商务网站，其中/catalog路径指向商品目录服务，而/cart路径指向购物车服务。ALB可以根据路径将流量路由到不同的服务或容器。</li></ul><h2 id="3-Network-Load-Balancer-NLB"><a href="#3-Network-Load-Balancer-NLB" class="headerlink" title="3. Network Load Balancer (NLB)"></a>3. Network Load Balancer (NLB)</h2><ul><li>NLB是在第4层（传输层）工作的负载均衡器，专门设计用于处理极高的性能和低延迟需求。</li><li>支持静态IP地址或Elastic IP地址。</li><li>适用于处理TCP、UDP和TLS流量。</li><li>能够处理数百万请求每秒，同时保持极低的延迟。</li><li>支持长连接，适合需要保持TCP连接的应用程序。</li></ul><h3 id="场景举例-2"><a href="#场景举例-2" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>高性能的实时游戏、股票交易平台或需要处理大量TCP连接的任何其他类型的应用程序。</li><li>示例：实时多人在线游戏服务器，玩家的连接需要低延迟和高吞吐量，NLB可以有效地在多个游戏服务器实例之间分配TCP流量。</li></ul><h2 id="其他服务集成"><a href="#其他服务集成" class="headerlink" title="其他服务集成"></a>其他服务集成</h2><p>AWS的Elastic Load Balancing (ELB)服务可以与许多其他AWS服务集成，以提供更完整、更强大的解决方案。以下是一些常与ELB集成使用的AWS服务：</p><h3 id="1-Amazon-EC2-Elastic-Compute-Cloud"><a href="#1-Amazon-EC2-Elastic-Compute-Cloud" class="headerlink" title="1. Amazon EC2 (Elastic Compute Cloud)"></a>1. Amazon EC2 (Elastic Compute Cloud)</h3><ul><li>ELB通常用来分配流量给后端的EC2实例。当实例的健康检查通过时，它们会被加入负载均衡器的目标池中。</li></ul><h3 id="2-Amazon-ECS-Elastic-Container-Service"><a href="#2-Amazon-ECS-Elastic-Container-Service" class="headerlink" title="2. Amazon ECS (Elastic Container Service)"></a>2. Amazon ECS (Elastic Container Service)</h3><ul><li>对于容器化的应用程序，ALB可以直接与ECS服务集成，自动注册容器实例作为负载均衡器的目标。</li></ul><h3 id="3-AWS-Fargate"><a href="#3-AWS-Fargate" class="headerlink" title="3. AWS Fargate"></a>3. AWS Fargate</h3><ul><li>Fargate提供了无服务器的容器执行环境，与ELB（特别是ALB）集成时，可以动态地负载均衡到Fargate任务。</li></ul><h3 id="4-Amazon-EKS-Elastic-Kubernetes-Service"><a href="#4-Amazon-EKS-Elastic-Kubernetes-Service" class="headerlink" title="4. Amazon EKS (Elastic Kubernetes Service)"></a>4. Amazon EKS (Elastic Kubernetes Service)</h3><ul><li>对于Kubernetes管理的容器应用程序，ELB可以用来平滑地分配流量到EKS集群中的Pods。</li></ul><h3 id="5-AWS-Lambda"><a href="#5-AWS-Lambda" class="headerlink" title="5. AWS Lambda"></a>5. AWS Lambda</h3><ul><li>ALB可以直接触发Lambda函数，允许无服务器架构的应用程序响应HTTP/HTTPS请求。</li></ul><h3 id="6-AWS-Auto-Scaling"><a href="#6-AWS-Auto-Scaling" class="headerlink" title="6. AWS Auto Scaling"></a>6. AWS Auto Scaling</h3><ul><li>ELB与Auto Scaling紧密集成，可以根据流量增减自动调整EC2实例的数量。</li></ul><h3 id="7-Amazon-RDS-Relational-Database-Service"><a href="#7-Amazon-RDS-Relational-Database-Service" class="headerlink" title="7. Amazon RDS (Relational Database Service)"></a>7. Amazon RDS (Relational Database Service)</h3><ul><li>虽然ELB不直接与RDS集成，但是可以配置应用程序在ELB后面连接到RDS数据库，从而使数据库层与应用层分离，提高可扩展性。</li></ul><h3 id="8-Amazon-S3-Simple-Storage-Service"><a href="#8-Amazon-S3-Simple-Storage-Service" class="headerlink" title="8. Amazon S3 (Simple Storage Service)"></a>8. Amazon S3 (Simple Storage Service)</h3><ul><li>对于静态内容，可以配置ALB通过HTTP(S)重定向到S3存储桶，以便高效地提供静态资源。</li></ul><h3 id="9-AWS-WAF-Web-Application-Firewall"><a href="#9-AWS-WAF-Web-Application-Firewall" class="headerlink" title="9. AWS WAF (Web Application Firewall)"></a>9. AWS WAF (Web Application Firewall)</h3><ul><li>可以将AWS WAF与ALB和NLB集成，为应用程序提供基于规则的防护，以防止常见的网络攻击。</li></ul><h3 id="10-AWS-Certificate-Manager-ACM"><a href="#10-AWS-Certificate-Manager-ACM" class="headerlink" title="10. AWS Certificate Manager (ACM)"></a>10. AWS Certificate Manager (ACM)</h3><ul><li>与ACM集成可以轻松地在ELB上部署SSL/TLS证书，以实现安全的数据传输。</li></ul><h3 id="11-Amazon-CloudWatch"><a href="#11-Amazon-CloudWatch" class="headerlink" title="11. Amazon CloudWatch"></a>11. Amazon CloudWatch</h3><ul><li>ELB与CloudWatch集成，提供了监控和日志记录功能，以跟踪和分析负载均衡器的性能。</li></ul><h3 id="12-AWS-CloudTrail"><a href="#12-AWS-CloudTrail" class="headerlink" title="12. AWS CloudTrail"></a>12. AWS CloudTrail</h3><ul><li>CloudTrail与ELB集成，可以记录所有ELB事件，帮助用户进行安全分析和操作审计。</li></ul><h3 id="13-AWS-Global-Accelerator"><a href="#13-AWS-Global-Accelerator" class="headerlink" title="13. AWS Global Accelerator"></a>13. AWS Global Accelerator</h3><ul><li>对于全球分布的应用程序，可以使用Global Accelerator提高用户到ELB的连接速度和可靠性。</li></ul><h3 id="14-AWS-Shield"><a href="#14-AWS-Shield" class="headerlink" title="14. AWS Shield"></a>14. AWS Shield</h3><ul><li>与ELB集成的AWS Shield提供了DDoS保护，以保护应用程序免受分布式拒绝服务攻击。</li></ul>]]></content>
    
    
    <summary type="html">AWS server for learning</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
</feed>
