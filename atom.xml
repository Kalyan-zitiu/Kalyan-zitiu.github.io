<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kalyan的小书房</title>
  <icon>https://www.gravatar.com/avatar/26add54e467101c6779c59a0ed4ee504</icon>
  <subtitle>Kalyan is working hard</subtitle>
  <link href="https://kalyan-zitiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://kalyan-zitiu.github.io/"/>
  <updated>2024-06-24T07:59:40.100Z</updated>
  <id>https://kalyan-zitiu.github.io/</id>
  
  <author>
    <name>Kalyan</name>
    <email>3148862192@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简易高弹性B/S架构</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/</id>
    <published>2024-04-12T12:00:00.000Z</published>
    <updated>2024-06-24T07:59:40.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VPC架构设计"><a href="#VPC架构设计" class="headerlink" title="VPC架构设计"></a><strong>VPC架构设计</strong></h3><p>一个虚拟私有云（VPC）的结构，名称为“MyVPC”。该VPC包含4个子网，分布在两个可用区（us-east-1a和us-east-1b）中。其中，us-east-1a包含PublicSubnet1和PrivateSubnet1，us-east-1b包含PublicSubnet2和PrivateSubnet2。此外，该VPC还配置了两个路由表：PrivateRouteTable和PublicRouteTable，其中一个路由表的ID为“rtb-08c231d3d0fbbf2c2”。最后，图中显示了两个网络设备：MyInternetGateway和MyNatGateway。这些组件共同构成了一个典型的VPC架构，用于管理和控制网络流量的路由和访问。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154008942.png" alt="image-20240624154008942"></p><h3 id="B-S架构设计"><a href="#B-S架构设计" class="headerlink" title="B/S架构设计"></a><strong>B/S架构设计</strong></h3><p>这幅图展示了一个详细的虚拟私有云（VPC）架构，包含多个AWS组件和服务。该架构包括一个名为”MyVPC”的VPC，内部包含多个子网（如PublicSubnetA、PublicSubnetB、PrivateSubnetA、PrivateSubnetB）和路由表（如PublicRouteTable、PrivateRouteTable）。此外，还配置了网络ACL（如PublicNetworkACL、PrivateNetworkACL）来控制子网的入站和出站流量。网络设备方面，包含一个InternetGateway用于公共子网的互联网访问，以及一个NATGateway和其对应的弹性IP用于私有子网的互联网访问。安全组（如PublicInstanceSecurityGroup、PrivateInstanceSecurityGroup）用于实例的流量控制。实例部分，包括PublicInstanceA、PublicInstanceB、PrivateInstanceA、PrivateInstanceB等。</p><p>该架构使用堡垒机来登录实例，VPC通过CloudFormation模板构建，并基于CloudWatch指标实现自动扩展（AutoScaling）。会话状态保存在DynamoDB中，数据库缓存使用Amazon<br>ElastiCache for<br>Redis。此外，还使用消息队列SQS来处理消息。这些组件通过复杂的连接关系，构成了一个集成的、高度可扩展和可靠的网络架构，用于管理和控制流量的路由、访问和安全性，适用于在云环境中部署和管理各种应用和服务。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154015927.png" alt="image-20240624154015927"></p><h3 id="Auto-Scaling组配置"><a href="#Auto-Scaling组配置" class="headerlink" title="Auto Scaling组配置"></a><strong>Auto Scaling组配置</strong></h3><p>定义了一个自动扩展启动配置（Launch<br>Configuration），指定了使用的AMI镜像、实例类型、安全组、用户数据等信息，确保新实例能够按照指定的配置启动并运行。接着创建了一个自动扩展组（Auto<br>Scaling<br>Group），设置了VPC子网、启动配置、最小和最大实例数量、目标组等参数，以便根据负载情况自动调整实例数量。同时，配置了CloudWatch告警监控CPU利用率高低，当CPU利用率超过或低于阈值时，会触发相应的扩展或缩容策略。具体而言，定义了两个告警，分别用于CPU利用率超过70%和低于30%时的自动扩展和缩容操作。此外，还设置了扩展和缩容策略，包括调整实例数量、冷却时间等参数，以确保系统能够根据负载情况自动调整实例数量，实现自动化弹性扩展和收缩。整体而言，这个配置文件实现了一个基于CPU利用率的自动扩展机制，能够根据实际负载情况动态调整实例数量，提高系统的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154021722.png" alt="image-20240624154021722"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154027789.png" alt="image-20240624154027789"></p><h3 id="ALB配置"><a href="#ALB配置" class="headerlink" title="ALB配置"></a><strong>ALB配置</strong></h3><p>这个应用负载均衡器（ALB）在你的架构中担任了至关重要的角色，确保了应用的高效运行和用户体验的优化。具体来说，ALB将进入的应用程序流量智能地分配到多个目标（如EC2实例），平衡了负载并防止了单点故障，从而保证了系统的高可用性和可扩展性。通过定期进行健康检查，ALB确保只有健康的实例接收流量，如果某个实例出现故障，它会自动将流量重定向到其他健康的实例，提高了应用的可靠性。</p><p>此外，ALB支持基于内容的路由功能，可以根据请求的URL路径、HTTP头、查询字符串等，将流量路由到不同的目标组，使得你可以更灵活地管理流量，比如将静态内容和动态内容分开处理，从而优化资源使用。ALB还可以与AWS的安全服务（如AWS<br>WAF和ACM）集成，提供强大的安全防护，支持SSL/TLS终止，确保传输层的安全，同时简化了证书管理。通过与Auto<br>Scaling集成，ALB可以根据流量负载自动增加或减少目标实例的数量，确保了应用能够应对流量高峰，同时优化了成本。ALB还与CloudWatch无缝集成，提供详细的监控和日志记录功能，让你可以实时监控流量模式、请求响应时间等关键指标，快速识别和解决潜在问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154059526.png" alt="image-20240624154059526"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154041177.png" alt="image-20240624154035908"></p><h3 id="通过CloudFormation进行快速实施过程"><a href="#通过CloudFormation进行快速实施过程" class="headerlink" title="通过CloudFormation进行快速实施过程"></a><strong>通过CloudFormation进行快速实施过程</strong></h3><p>首先，通过CloudFormation创建一个VPC和多个子网，配置Internet网关和NAT网关以实现公共和私有网络的连接。然后设置安全组并启动Bastion主机作为跳板机。接着，配置目标组和创建应用负载均衡器，设置监听器以将流量引导到后端实例。定义启动配置并基于此配置创建自动伸缩组，实现根据负载情况动态调整实例数量。继续创建RDS子网组和部署RDS实例，确保数据库服务的高可用性和持久性。创建DynamoDB表以存储非结构化数据，实现快速读写和扩展性。配置ElastiCache子网组并部署ElastiCache集群，提供高性能的缓存服务，加速数据访问。最后，创建SQS队列用于处理消息队列，确保应用程序之间的异步通信。在完成上述步骤后，获取关键资源的信息，包括Bastion主机的公有IP地址用于远程访问，负载均衡器的DNS名称用于访问应用程序，RDS实例的终端节点用于数据库连接，DynamoDB表名用于数据存储，Redis缓存的终端节点用于快速数据缓存，以及SQS队列的URL用于消息处理。这样可以确保整个架构的部署和运行顺利进行。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154107810.png" alt="image-20240624154107810"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154125600.png" alt="image-20240624154125600"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154118431.png" alt="image-20240624154114091"></p><h3 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a><strong>遇到的问题与解决方案</strong></h3><p>权限问题：如果遇到权限不足的问题，确保使用的IAM用户或角色具有必要的权限，比如创建VPC、子网、EC2实例、RDS实例等权限。</p><p>资源限制问题：如果遇到资源限制（如EC2实例配额不足），可以通过联系AWS支持来提升配额。</p><p>网络配置问题：确保VPC和子网的CIDR块配置正确，避免重叠。确保安全组规则配置正确，允许所需的入站和出站流量。</p><p>模板语法错误：使用AWS<br>CloudFormation的模板验证工具来检查模板语法是否正确。</p><h3 id="测试方案与结果"><a href="#测试方案与结果" class="headerlink" title="测试方案与结果"></a><strong>测试方案与结果</strong></h3><h4 id="基于CloudWatch的AutoScaling"><a href="#基于CloudWatch的AutoScaling" class="headerlink" title="基于CloudWatch的AutoScaling"></a><strong>基于CloudWatch的AutoScaling</strong></h4><p>CloudWatch的Auto<br>Scaling是一种动态调整计算资源以匹配应用需求的机制，通过监控关键指标（如CPU利用率）来触发扩展或缩减操作。CloudWatch会收集和监控这些指标，并基于设定的阈值触发警报。当警报触发时，Auto<br>Scaling组会根据预定义的策略自动增加或减少EC2实例的数量。例如，当CPU利用率超过某个阈值时，Auto<br>Scaling会增加实例数量以处理高负载；当CPU利用率低于阈值时，Auto<br>Scaling会减少实例数量以节约成本。通过这种方式，Auto<br>Scaling确保了应用程序的高可用性和性能，同时优化了资源使用和成本效益。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154158215.png" alt="image-20240624154158215"></p><h4 id="DynamoDB保存会话状态"><a href="#DynamoDB保存会话状态" class="headerlink" title="DynamoDB保存会话状态"></a><strong>DynamoDB保存会话状态</strong></h4><p>在Web应用中，会话（Session） 是在用户与服务器之间的交互过程中维持状态的一种方式。HTTP协议本身是无状态的，这意味着每个请求都是独立的，服务器默认不会记住前一个请求的信息。会话状态技术允许服务器记住用户的状态信息（如用户是否已登录、用户的偏好设置等），这对于创建交互式Web应用是必要的。DynamoDB作为会话存储的后端，帮助Web应用维护用户的状态，提供连贯的用户体验，并且能够在用户数量激增时保持高性能和可靠性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154209751.png" alt="image-20240624154209751"></p><h4 id="使用消息队列SQS"><a href="#使用消息队列SQS" class="headerlink" title="使用消息队列SQS"></a><strong>使用消息队列SQS</strong></h4><p>使用AWS<br>SDK（例如Python的Boto3）向队列发送消息。首先，确保你已安装Boto3并配置了AWS凭证。接收消息也很简单。使用同样的SQS客户端，你可以从队列中拉取消息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154216362.png" alt="image-20240624154216362"></p><h4 id="使用ElastiCache-for-Redis数据库缓存"><a href="#使用ElastiCache-for-Redis数据库缓存" class="headerlink" title="使用ElastiCache for Redis数据库缓存"></a><strong>使用ElastiCache for Redis数据库缓存</strong></h4><p>ElastiCache for Redis 是一种由 AWS<br>托管的内存缓存服务，通过在内存中存储数据，提供极低的延迟和高吞吐量的数据访问能力，适用于实时分析、会话存储和排行榜等应用场景。它支持水平和垂直扩展，可以根据应用需求动态调整节点数量和实例规格，确保在流量高峰期依然高效运行。通过多可用区部署和自动故障转移功能，ElastiCache<br>for Redis<br>提供了高可用性和数据持久性，确保在节点故障时数据不丢失并迅速恢复。此外，ElastiCache<br>for Redis 是完全托管的服务，AWS<br>负责基础设施管理、软件更新、安全补丁和备份恢复，简化了管理工作，使开发者可以专注于应用开发。它还支持VPC、子网、安全组和加密功能，确保数据传输和存储的安全性。总之，ElastiCache<br>for Redis<br>提供了一个高效、可靠和安全的缓存解决方案，显著提升了数据访问速度和系统响应能力，简化了缓存管理和运维工作，使开发者能够专注于核心业务逻辑的开发。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154224745.png" alt="image-20240624154224745"></p><h4 id="实例与数据库连接"><a href="#实例与数据库连接" class="headerlink" title="实例与数据库连接"></a><strong>实例与数据库连接</strong></h4><p>为了使EC2实例与RDS实例互联，需要创建并配置两个安全组，一个用于EC2实例，另一个用于RDS实例。然后在RDS实例的安全组中添加入站规则，允许从EC2实例的安全组IP地址范围通过数据库端口（如3306）进行访问。最后，在EC2实例中配置数据库客户端，使用RDS实例的端点和端口号进行连接，从而实现网络通信与数据库操作。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154229517.png" alt="image-20240624154229517"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154234077.png" alt="image-20240624154234077"></p><h4 id="用CloudFormation进行VPC内容创建"><a href="#用CloudFormation进行VPC内容创建" class="headerlink" title="用CloudFormation进行VPC内容创建"></a><strong>用CloudFormation进行VPC内容创建</strong></h4><p>使用CloudFormation进行VPC创建可以自动化管理和部署完整网络架构。通过编写CloudFormation模板，可以创建一个VPC，设置其CIDR块，配置公共和私有子网，创建并连接Internet网关和NAT网关，并配置路由表和关联。这样不仅提高了部署效率，还减少了人为配置错误，确保网络架构的可重复性和一致性。例如，模板中配置了一个CIDR为10.0.0.0/16的VPC，包含两个公共子网和两个私有子网，并分别配置了路由表和NAT网关，以保证私有子网具有访问外部网络的能力。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="string">&#x27;2010-09-09&#x27;</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">AWS</span> <span class="string">CloudFormation</span> <span class="string">Template</span> <span class="string">for</span> <span class="string">B/S</span> <span class="string">Architecture</span> <span class="string">with</span> <span class="string">VPC,</span> <span class="string">Subnets,</span> <span class="string">RDS,</span> <span class="string">EC2,</span> <span class="string">Auto</span> <span class="string">Scaling,</span> <span class="string">DynamoDB,</span> <span class="string">ElastiCache,</span> <span class="string">and</span> <span class="string">SQS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">MyVPC:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPC</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">EnableDnsSupport:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">EnableDnsHostnames:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyVPC</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.3</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">InternetGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::InternetGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyInternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">GatewayAttachment:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPCGatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">InternetGatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGatewayEIP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::EIP</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Domain:</span> <span class="string">vpc</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGatewayEIP</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::NatGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">AllocationId:</span> <span class="type">!GetAtt</span> <span class="string">NatGatewayEIP.AllocationId</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPublicRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">DependsOn:</span> <span class="string">GatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">GatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPrivateRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">NatGatewayId:</span> <span class="type">!Ref</span> <span class="string">NatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">WebServerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">HTTP,</span> <span class="string">RDP,</span> <span class="string">and</span> <span class="string">SSH</span> <span class="string">access</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">bastion</span> <span class="string">host</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Instance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostInstance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Load Balancer Security Group</span></span><br><span class="line">  <span class="attr">LoadBalancerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">access</span> <span class="string">to</span> <span class="string">Load</span> <span class="string">Balancer</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Application Load Balancer</span></span><br><span class="line">  <span class="attr">ApplicationLoadBalancer:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::LoadBalancer</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Name:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Subnets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line">      <span class="attr">Scheme:</span> <span class="string">internet-facing</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Target Group for Load Balancer</span></span><br><span class="line">  <span class="attr">TargetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">TargetGroupTwo:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Listener for Load Balancer</span></span><br><span class="line">  <span class="attr">LoadBalancerListenerHTTP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">LoadBalancerListenerCustomPort:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Auto Scaling Launch Configuration</span></span><br><span class="line">  <span class="attr">LaunchConfiguration:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::LaunchConfiguration</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">UserData:</span></span><br><span class="line">        <span class="attr">Fn::Base64:</span> <span class="type">!Sub</span> <span class="string">|</span></span><br><span class="line"><span class="string">          #!/bin/bash</span></span><br><span class="line"><span class="string">          yum update -y</span></span><br><span class="line"><span class="string">          yum install -y httpd nodejs unzip</span></span><br><span class="line"><span class="string">          systemctl start httpd</span></span><br><span class="line"><span class="string">          systemctl enable httpd</span></span><br><span class="line"><span class="string">          cd /var/www/html</span></span><br><span class="line"><span class="string">          aws s3 cp s3://myawsbucketkalyanzitiu/mysqlViewer.zip</span></span><br><span class="line"><span class="string">          unzip mysqlViewer.zip</span></span><br><span class="line"><span class="string">          rm mysqlViewer.zip</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          node /var/www/html/start.js &amp;</span></span><br><span class="line"><span class="string">          /opt/aws/bin/cfn-signal -e $? --stack $&#123;AWS::StackName&#125; --resource AutoScalingGroup --region $&#123;AWS::Region&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="comment"># Auto Scaling Group</span></span><br><span class="line">  <span class="attr">AutoScalingGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::AutoScalingGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VPCZoneIdentifier:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">LaunchConfigurationName:</span> <span class="type">!Ref</span> <span class="string">LaunchConfiguration</span></span><br><span class="line">      <span class="attr">MinSize:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">MaxSize:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">DesiredCapacity:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">TargetGroupARNs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyAutoScalingGroup</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Environment</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">Production</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># CloudWatch Alarm for Auto Scaling</span></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmHigh:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale up if CPU &gt; 70% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">70</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">GreaterThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleUpPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmLow:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale down if CPU &lt; 30% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">LessThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleDownPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scaling Policies</span></span><br><span class="line">  <span class="attr">ScaleUpPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ScaleDownPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">-1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DynamoDB Table</span></span><br><span class="line">  <span class="attr">DynamoDBTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::DynamoDB::Table</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TableName:</span> <span class="string">SessionTable</span></span><br><span class="line">      <span class="attr">AttributeDefinitions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">AttributeType:</span> <span class="string">S</span></span><br><span class="line">      <span class="attr">KeySchema:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">KeyType:</span> <span class="string">HASH</span></span><br><span class="line">      <span class="attr">ProvisionedThroughput:</span></span><br><span class="line">        <span class="attr">ReadCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">WriteCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">SessionTable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ElastiCache for Redis</span></span><br><span class="line">  <span class="attr">RedisCacheCluster:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::CacheCluster</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CacheNodeType:</span> <span class="string">cache.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">NumCacheNodes:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">VpcSecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">RedisCacheCluster</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">RedisSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::SubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Description:</span> <span class="string">&quot;Subnet group for Redis cache&quot;</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># SQS Queue</span></span><br><span class="line">  <span class="attr">SQSQueue:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::SQS::Queue</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">QueueName:</span> <span class="string">MyQueue</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MySQSQueue</span></span><br><span class="line">          </span><br><span class="line">  <span class="attr">MyDBSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBSubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBSubnetGroupDescription:</span> <span class="string">My</span> <span class="string">DB</span> <span class="string">Subnet</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RDS Instance for Multi-AZ Deployment</span></span><br><span class="line">  <span class="attr">DBInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBInstance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBName:</span> <span class="string">MyDatabase</span></span><br><span class="line">      <span class="attr">AllocatedStorage:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">DBInstanceClass:</span> <span class="string">db.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MasterUsername:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">MasterUserPassword:</span> <span class="string">admin123</span></span><br><span class="line">      <span class="attr">VPCSecurityGroups:</span> []</span><br><span class="line">      <span class="attr">DBSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line">      <span class="attr">MultiAZ:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyRDSInstance</span></span><br><span class="line">    <span class="attr">DeletionPolicy:</span> <span class="string">Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Outputs:</span></span><br><span class="line">  <span class="attr">DBInstanceEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the RDS instance&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">DBInstance.Endpoint.Address</span></span><br><span class="line">  <span class="attr">BastionHostPublicIp:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The public IP address of the bastion host&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">BastionHostInstance.PublicIp</span></span><br><span class="line">  <span class="attr">LoadBalancerDNSName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The DNS name of the Application Load Balancer&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">ApplicationLoadBalancer.DNSName</span></span><br><span class="line">  <span class="attr">DynamoDBTableName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The name of the DynamoDB table&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">DynamoDBTable</span> </span><br><span class="line">  <span class="attr">RedisCacheEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the Redis cache cluster&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">RedisCacheCluster.RedisEndpoint.Address</span></span><br><span class="line">  <span class="attr">SQSQueueURL:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The URL of the SQS queue&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">SQSQueue</span></span><br></pre></td></tr></table></figure><h4 id="使用堡垒机登录实例"><a href="#使用堡垒机登录实例" class="headerlink" title="使用堡垒机登录实例"></a><strong>使用堡垒机登录实例</strong></h4><p>首先，通过SSH连接到堡垒机，以便安全地访问私有子网内的Web实例。登录堡垒机后，利用存储在堡垒机上的SSH密钥登录私有子网内的Web实例进行部署操作。有时使用密钥登录可能会显示“权限被拒绝”的错误，这通常是由于密钥文件权限设置不正确导致的。此时，可以通过运行chmod<br>400<br>path_to_your_private_key命令重新设置密钥文件权限，确保只有当前用户可以读取该文件，从而解决登录被拒绝的问题。通过这种方式，能够安全有效地管理和部署私有子网内的实例。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154256449.png" alt="image-20240624154256449"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154303065.png" alt="image-20240624154303065"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154308929.png" alt="image-20240624154308929"></p><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a><strong>性能评估</strong></h3><h4 id="负载均衡测试"><a href="#负载均衡测试" class="headerlink" title="负载均衡测试"></a><strong>负载均衡测试</strong></h4><p>通过性能监控对实例进行分流，显示不同ip型号的实例</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154334381.png" alt="image-20240624154334381"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154338428.png" alt="image-20240624154338428"></p><h4 id="数据库性能测试"><a href="#数据库性能测试" class="headerlink" title="数据库性能测试"></a><strong>数据库性能测试</strong></h4><p>显示了数据库性能测试中的几个关键指标，包括剩余存储空间、读写操作次数（IOPS）、网络接收与发送吞吐量等。图中显示在测试初期读写操作和网络传输活动较高，随后逐渐趋于平稳，表明数据库在高负载初期经过密集活动后恢复到稳定状态。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154345250.png" alt="image-20240624154345250"></p><h4 id="自动伸缩功能测试"><a href="#自动伸缩功能测试" class="headerlink" title="自动伸缩功能测试"></a><strong>自动伸缩功能测试</strong></h4><p>进行自动伸缩功能测试时，首先配置一个Auto<br>Scaling组，并设置其最小实例数为2，最大实例数为3。此外，创建缩放策略，当CPU利用率低于30%时减少实例数量，当CPU利用率高于70%时增加实例数量。启动测试后，可以观察到，当负载增加时，Auto<br>Scaling组中的实例数量从2个自动扩展到3个，而在负载减小时，实例数量则会减少回2个。这种自动调整实例数量的功能确保了应用在高负载时有足够的资源，同时在低负载时节省资源成本。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154404728.png" alt="image-20240624154404728"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154356696.png" alt="image-20240624154351414"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154414919.png" alt="image-20240624154414919"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154424766.png" alt="image-20240624154424766"></p><h4 id="项目部署效果测试"><a href="#项目部署效果测试" class="headerlink" title="项目部署效果测试"></a><strong>项目部署效果测试</strong></h4><p>项目架构部署在AWS云平台上，使用包含两个可用区的VPC，配置有公有和私有子网，互联网网关和NAT网关。核心部分是通过配置在互联网网关内的应用程序负载均衡器和Auto<br>Scaling组，实现Web实例的自动扩展，并将这些实例分布在两个可用区内。同时，RDS数据库配置了主备实例，确保数据的高可用性和可靠性。安全组进一步管理网络安全，确保系统的高可用性和灵活扩展性。</p><p>当负载均衡器正常运行时，提示项目成功启动。您可以通过访问以下URL连接到数据库并查看Web项目：</p><p><a href="http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/">http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/</a></p><p>这将能够直接访问部署在AWS上的Web应用，并与底层的数据库实例交互，确保应用的可靠运行和性能优化。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154510878.png" alt="image-20240624154510878"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154514651.png" alt="image-20240624154514651"></p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>docker概述</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/</id>
    <published>2024-04-08T06:00:00.000Z</published>
    <updated>2024-06-30T05:30:56.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Docker部署Kubernetes"><a href="#基于Docker部署Kubernetes" class="headerlink" title="基于Docker部署Kubernetes"></a>基于Docker部署Kubernetes</h1><h2 id="学习环境架构搭建"><a href="#学习环境架构搭建" class="headerlink" title="学习环境架构搭建"></a>学习环境架构搭建</h2><h3 id="创建VPC"><a href="#创建VPC" class="headerlink" title="创建VPC"></a>创建VPC</h3><p>在AWS创建一个拥有一个子网的VPC</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629213836702.png" alt="image-20240629213836702"></p><h3 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h3><p>安全组为了方便最好把ssh的22端口以及Kubernetes API服务的端口6443设置为入站规则。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214700104.png" alt="image-20240629214700104"></p><h3 id="启动模板创建"><a href="#启动模板创建" class="headerlink" title="启动模板创建"></a>启动模板创建</h3><p>根据最小配置。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214828795.png" alt="image-20240629214828795"></p><p>编写用户数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Docker</span></span><br><span class="line">apt-get install -y docker.io</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Kubernetes官方APT软件仓库的密钥和仓库</span></span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新APT索引并安装kubelet, kubeadm和kubectl</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swap（Kubernetes不支持运行在启用了Swap的机器上）</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>问题来了，当我试图用用户数据来做启动后的自动安装配置，由于Ubuntu版本命令已经不用apt-key了，所以在实例启动后并没有得到相应的环境，不过没有问题。</p><h2 id="Master主节点"><a href="#Master主节点" class="headerlink" title="Master主节点"></a>Master主节点</h2><h3 id="配置主节点环境以及准备初始化主节点"><a href="#配置主节点环境以及准备初始化主节点" class="headerlink" title="配置主节点环境以及准备初始化主节点"></a>配置主节点环境以及准备初始化主节点</h3><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. <strong>安装docker</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新本地的包索引数据库，这样在安装新软件时能获取到最新的软件包。</span></span><br><span class="line">sudo apt-get update </span><br><span class="line"><span class="comment"># 安装Docker。docker.io是Ubuntu官方仓库中Docker的软件包名称，-y参数表示自动同意安装过程中的询问。</span></span><br><span class="line">sudo apt-get install docker.io -y</span><br><span class="line"><span class="comment"># 启动Docker服务，并设置为开机自启动。</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><h3 id="2-关闭Swap"><a href="#2-关闭Swap" class="headerlink" title="2.关闭Swap"></a><strong>2.关闭Swap</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用swap（交换空间）。Kubernetes要求禁用swap，因为需要严格的资源控制和隔离，swap存在可能会影响性能和调度决策。</span></span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><h3 id="3-安装-cri-dockerd"><a href="#3-安装-cri-dockerd" class="headerlink" title="3.安装 cri-dockerd"></a>3.安装 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br><span class="line"><span class="comment"># cri-dockerd是一个桥接组件，允许Kubernetes通过CRI（容器运行时接口）与Docker交互。</span></span><br><span class="line">dpkg -i cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br></pre></td></tr></table></figure><ul><li></li></ul><h3 id="4-启动并配置开机启动-cri-dockerd"><a href="#4-启动并配置开机启动-cri-dockerd" class="headerlink" title="4.启动并配置开机启动 cri-dockerd"></a>4.启动并配置开机启动 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.socket</span><br></pre></td></tr></table></figure><ul><li>这些命令设置<code>cri-docker</code>服务和socket的启动和开机自启动，确保Kubernetes可以正确与Docker通信。</li></ul><h3 id="5-安装-kubeadm、kubelet、kubectl"><a href="#5-安装-kubeadm、kubelet、kubectl" class="headerlink" title="5.安装 kubeadm、kubelet、kubectl"></a>5.安装 kubeadm、kubelet、kubectl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装网络传输和证书相关的工具，为后续下载和验证Kubernetes包做准备。</span></span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并安装Kubernetes的GPG密钥，用于验证后续安装包的完整性。</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加Kubernetes的软件源，以便安装kubeadm、kubelet和kubectl。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] http://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><ul><li>测试拉取，然后查看需要的images</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630104435917.png" alt="image-20240630104435917"></p><ul><li>拉取镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/etcd:3.5.7-0</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630111103161.png" alt="image-20240630111103161"></p><h4 id="第一次尝试初始化"><a href="#第一次尝试初始化" class="headerlink" title="第一次尝试初始化"></a>第一次尝试初始化</h4><p>粗心大意,podSubnet没有注意大小写</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630113034682.png" alt="image-20240630113034682"></p><h4 id="第二次尝试初始化"><a href="#第二次尝试初始化" class="headerlink" title="第二次尝试初始化"></a>第二次尝试初始化</h4><p>需要reset一下kubeeadm</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们用的是docker</span></span><br><span class="line">sudo kubeadm reset -f --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630114542529.png" alt="image-20240630114542529"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>出现了两个问题,总的来说就是权限问题和连接问题.</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115125908.png" alt="image-20240630115125908"></p><h5 id="权限问题解决"><a href="#权限问题解决" class="headerlink" title="权限问题解决"></a>权限问题解决</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> ubuntu:ubuntu /etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>解决完权限问题后,连接问题也解决了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115354437.png" alt="image-20240630115354437"></p><p> 经过一定的搜寻和思考,</p><ul><li>运行上述命令后，你实际上是在改变 <code>/etc/kubernetes/admin.conf</code> 文件的所有权，将其从 <code>root</code> 用户和组更改为 <code>ubuntu</code> 用户和组。这样做的直接结果是，普通用户 <code>ubuntu</code> 现在有权限读取这个文件。</li><li>在k8s中集群中,<code>admin.conf</code> 文件包含了连接到集群的 K8s API 服务器的必要凭证和连接信息。这包括 API 服务器的地址、端口、使用的证书等。当你以 <code>ubuntu</code> 用户身份运行 <code>kubectl</code> 命令时，<code>kubectl</code> 会尝试读取这个配置文件来获取连接到 K8s 集群的必要信息。</li></ul><h4 id="先观察一下kubelet日志"><a href="#先观察一下kubelet日志" class="headerlink" title="先观察一下kubelet日志"></a>先观察一下kubelet日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl -u kubelet -f</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630120005623.png" alt="image-20240630120005623"></p><h4 id="再看一眼pod的日志"><a href="#再看一眼pod的日志" class="headerlink" title="再看一眼pod的日志"></a>再看一眼pod的日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定namespace;</span></span><br><span class="line">sudo kubectl logs coredns-5dd5756b68-jd25s --namespace=kube-system</span><br></pre></td></tr></table></figure><p>这种情况,大概率是网络上的,问题,经过查找需要安装一些网络插件</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630121445618.png" alt="image-20240630121445618"></p><h4 id="安装部署-Calico-网络插件"><a href="#安装部署-Calico-网络插件" class="headerlink" title="安装部署 Calico 网络插件"></a>安装部署 Calico 网络插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure><h2 id="Node-节点加入集群"><a href="#Node-节点加入集群" class="headerlink" title="Node 节点加入集群"></a>Node 节点加入集群</h2><h3 id="先在master节点查看加入命令"><a href="#先在master节点查看加入命令" class="headerlink" title="先在master节点查看加入命令"></a>先在master节点查看加入命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入命令,并指定cri-socket</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.0.1.237:6443 --token a69ewm.uvje3ei8zhox3xar --discovery-token-ca-cert-hash sha256:64db0e4e2ddc13e1a06390ac6b90b4f38a965fdc7cbfd2e3baa80a668e7cd74d --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><h3 id="为了node节点加入必备组件"><a href="#为了node节点加入必备组件" class="headerlink" title="为了node节点加入必备组件"></a>为了node节点加入必备组件</h3><p>成功后会显示</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630124600952.png" alt="image-20240630124600952"></p><p>然后主节点查看加入集群的节点</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630125420559.png" alt="image-20240630125420559"></p><p>ps:如果报couldn’t get current server API group list: Get “<a href="http://localhost:8080/api?timeout=32s&quot;">http://localhost:8080/api?timeout=32s&quot;</a>: dial tcp 127.0.0.1:8080: connect: connection refused的话，大概率是终端断连导致之前export的环境变量失效了，可以在/etc/environment文件中加入KUBECONFIG=”/etc/kubernetes/admin.conf”以使环境变量永久生效</p>]]></content>
    
    
    <summary type="html">基于Docker部署Kubernetes</summary>
    
    
    
    <category term="docker" scheme="https://kalyan-zitiu.github.io/categories/docker/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/docker/K8S/"/>
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>AWS Server Details</title>
    <link href="https://kalyan-zitiu.github.io/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/"/>
    <id>https://kalyan-zitiu.github.io/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/</id>
    <published>2024-03-04T07:00:00.000Z</published>
    <updated>2024-06-24T07:27:59.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><ul><li>是AWS Elastic Block Store(EBS)提供了用于EC2实例的<strong>块存储卷</strong></li><li>设计用来提供高可靠性和高性能的存储<h2 id="块存储卷"><a href="#块存储卷" class="headerlink" title="块存储卷"></a>块存储卷</h2></li><li>是一种数据存储技术，将存储空间分割成固定大小的“块”，每个块可以像独立硬盘一样被单独管理和操作</li><li>低级别数据处理（能够在较低的操作系统级别进行数据处理），高性能（块存储可以与操作系统直接交互），独立性（在没有文件系统的情况下存在，不会存储任何文件结构或元数据），灵活性（轻松扩展或调整大小），可访问性（能够通过存储区域网络（san），互联网协议（ip）网络或本地连接进行访问。）</li></ul><h2 id="持久性存储"><a href="#持久性存储" class="headerlink" title="持久性存储"></a>持久性存储</h2><p>EBS卷在EC2实例终后仍然存在，可以在创建EC3实例时候将其删除。</p><h2 id="多种卷类型"><a href="#多种卷类型" class="headerlink" title="多种卷类型"></a>多种卷类型</h2><h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><ul><li>是一个衡量计算存储设备性能的指标，表示每秒可以完成的输入/输出操作次数。这个指标通常用于评估硬盘驱动器（HDD）、固态硬盘（SSD）、存储区域网络（SAN）和网络附加存储（NAS）等存储设备的性能。</li></ul><p>IOPS高低的因素：</p><ol><li>存储介质：SSD通常提供比HDD更高的IOPS，因为SSD没有移动部件，数据访问速度更快。</li><li>数据块大小：通常较小的数据块会产生更高的IOPS数，每个操作处理的数据量更少。</li><li>读写模式：IOPS性能可能会根据读写操作的比例而变化。一般来说，读写操作的IOPS高于写操作</li><li>并发和队列深度：多个并发操作和更深的队列深度可以提高IOPS，但也可能增加延迟。</li><li>随机与顺序访问：随机I/O操作通常比顺序I/O操作有更低的IOPS，存储设备需要在不同位置寻找数据，尤其是在使用传统的机械硬盘时。</li></ol><h4 id="硬盘驱动器（HDD）"><a href="#硬盘驱动器（HDD）" class="headerlink" title="硬盘驱动器（HDD）"></a>硬盘驱动器（HDD）</h4><ul><li>一种创痛的机械存储设备，具有较大的存储容量和较低的成本</li></ul><h4 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h4><ul><li>是一种基于闪存存储技术的存储设备，具有更快的数据访问速度，更多的访问延迟和更高的可靠性，但是SSD的加个通常比HDD高，存储容量也很较小</li></ul><h4 id="存储区域网络（SAN）"><a href="#存储区域网络（SAN）" class="headerlink" title="存储区域网络（SAN）"></a>存储区域网络（SAN）</h4><ul><li>是一种专用网络，用于连接存储设备和计算设备。SAN通过高速网络连接将存储资源提供给计算设备，使其能够访问和共享存储数据，SAN通常用于大规模企业环境中，提供高性能，高可靠性和可扩展性的存储解决方案。</li></ul><h4 id="网络附加存储（NAS）"><a href="#网络附加存储（NAS）" class="headerlink" title="网络附加存储（NAS）"></a>网络附加存储（NAS）</h4><ul><li>通过网络连接提供文件级别存储服务的设备，NAS设备通常是独立的存储服务器，可以通过网络协议（NFS或SMB）共享文件，使多个计算设备能够访问和共享存储数据。NAS适用与小型办公环境或家庭用户，提供简单的文件共享和备份功能。</li></ul><h3 id="通用型SSD（gp2和gp3）"><a href="#通用型SSD（gp2和gp3）" class="headerlink" title="通用型SSD（gp2和gp3）"></a>通用型SSD（gp2和gp3）</h3><ul><li>提供平衡的性能和成本，适用与广泛的应用。gp2卷提供基于卷大小的IOPS，而gp3则允许用户独立选择和调整IOPS和吞吐量，与卷大小没有关系</li><li><strong>应用场景：</strong> gp2适用于大多数工作负载，如虚拟桌面，中小型数据库，开发和测试环境。gp3是更新的版本，适用于需要可预测的性能和价格的应用程序</li></ul><h3 id="预置IOPS-SSD（io1和io2）"><a href="#预置IOPS-SSD（io1和io2）" class="headerlink" title="预置IOPS SSD（io1和io2）"></a>预置IOPS SSD（io1和io2）</h3><ul><li>提供高性能的IOPS，适用于I/O密集型的数据库和应用程序，io2提供更高的耐久性和IOPS效率</li><li><strong>应用场景：</strong>高性能数据库，如大型关系型数据库或NoSQL数据库，以及需要高吞吐量和低延迟的关键业务应用程序。</li></ul><h3 id="吞吐量优化HDD（st1）"><a href="#吞吐量优化HDD（st1）" class="headerlink" title="吞吐量优化HDD（st1）"></a>吞吐量优化HDD（st1）</h3><ul><li>低成本HDD卷。适用于频繁访问的，吞吐量密集型工作负载。</li><li><strong>应用场景：</strong>大数据，数据仓库，日志处理等需要大量顺序读写操作的应用程序。</li></ul><h3 id="Cold-HDD（st1）"><a href="#Cold-HDD（st1）" class="headerlink" title="Cold HDD（st1）"></a>Cold HDD（st1）</h3><ul><li>最低成本的HDD卷，适用于较少访问的工作负载。</li><li><strong>应用场景：</strong>适合用于冷数据存储，如备份和灾难恢复。</li></ul><h3 id="磁带（standard）"><a href="#磁带（standard）" class="headerlink" title="磁带（standard）"></a>磁带（standard）</h3><ul><li>之前的基础性能HDD卷，现在以及不推荐使用，因为AWS提供更高性能和成本效益更高的选项。</li></ul><h3 id="选择EBS卷类型，考虑因素"><a href="#选择EBS卷类型，考虑因素" class="headerlink" title="选择EBS卷类型，考虑因素"></a>选择EBS卷类型，考虑因素</h3><ul><li>性能：IOPS，吞吐，延迟</li><li>数据访问频率，频繁访问的数据适合SSD，偶尔访问的数据适合HDD。</li><li>成本：预算和成本效益</li><li>耐久性和可用性：重要应用程序可能需要更高的耐久性和可用性</li></ul><h2 id="快照功能"><a href="#快照功能" class="headerlink" title="快照功能"></a>快照功能</h2><ul><li>创建EBS卷的快照，并存储在S3中，用于数据备份和恢复</li><li>快照捕获了某一时刻卷上的数据状态，并将这些数据存储在S3中<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3>对一个EBS卷进行快照备份时，仅仅是新的或者被修改过的块会被保存在S3。如果创建了多个快照，S3不会为未更改的块进行重复存储，而是自上次快照以来变化的块。</li></ul><h3 id="持久性和可靠性"><a href="#持久性和可靠性" class="headerlink" title="持久性和可靠性"></a>持久性和可靠性</h3><p>快照在S3上，是一个高持久性的存储服务，数据会自动复制到多个设施，确保其耐久性。</p><h3 id="点对点复制"><a href="#点对点复制" class="headerlink" title="点对点复制"></a>点对点复制</h3><p>可以跨AWS区域复制，对于灾难恢复和数据中心迁移非常有用。</p><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>原始EBS卷加密，快照也会自动加密。同样，从加密快照创建任何新的EBS卷也会自动假面。</p><h3 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h3><p>快照是增量的，所以它们通常比完整卷备份更加经济。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>允许自动创建和删除快照，便于用户按照自定义的策略维护快照</p><h3 id="共享或私有"><a href="#共享或私有" class="headerlink" title="共享或私有"></a>共享或私有</h3><p>快照可以与特定的AWS账户共享，或者公开共享给所有AWS用户。允许数据和配置的共享，同时支持软件供应商分发产品。</p><h1 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h1><ul><li>是Amazon Simple Storage Service一个对象存储服务</li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><ul><li>无限存储：S3提供几乎无限的存储空间，可以在需要时随时存储和检索任意数量数据</li><li>自动扩展：其实没有s3自动扩展这说法，只是他会适应存储数据量，无需手动去干预</li></ul><h2 id="数据可用性和持久性"><a href="#数据可用性和持久性" class="headerlink" title="数据可用性和持久性"></a>数据可用性和持久性</h2><ul><li>高持久性：S3提供99.999999999%的持久性，确保数据不会因为硬件问题而丢失<h3 id="多区域复制"><a href="#多区域复制" class="headerlink" title="多区域复制"></a>多区域复制</h3></li><li>多区域复制是一项功能，允许自动复制S3存储桶中对象到一个或者多个不同AWS区域的目标存储桶中<h4 id="数据复制策略"><a href="#数据复制策略" class="headerlink" title="数据复制策略"></a>数据复制策略</h4></li><li>可以设置复制策略来指定哪些数据需要被复制，可以是存储桶中的所有数据，也可以是符合特定前缀或标签的数据</li></ul><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><ul><li>多区域复制要求源存储桶启动版本控制，确保每个版本对象都会被复制到目标存储桶</li></ul><h4 id="延迟和一致性"><a href="#延迟和一致性" class="headerlink" title="延迟和一致性"></a>延迟和一致性</h4><p>复制操作通常是异步的，到目标区域会有延迟</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><p>多区域复制会产生额外的成本，包括数据传输费用和目标区域存储的费用</p><h4 id="数据加密-1"><a href="#数据加密-1" class="headerlink" title="数据加密"></a>数据加密</h4><p>支持复制过程中，用AWS提供的加密键（SSE-S3或SSE-KMS）或自己的加密键位（SSE-C）</p><h5 id="SSE-S3"><a href="#SSE-S3" class="headerlink" title="SSE-S3"></a>SSE-S3</h5><ul><li>是Amazon S3提供的服务端加密的一种方式，会自动使用多租户硬件安全模块HSM管理的密钥进行数据加密<br>如何工作：</li><li>当上传文件到S3时，可以指定使用SSE-S3进行加密</li><li>S3会为每个保存的对象生成一个唯一的密钥，使用该密钥对数据进行加密，把加密的数据保存的存储中</li><li>将每个对象的密钥进一步使用一个主密钥进行加密，这个主密钥是定期轮换的</li><li>访问数据时，会自动处理解密过程，可以像访问未加密的数据一样访问加密数据</li></ul><p>特点：<br>简单易用：SSE-S3 的操作非常简单，只需要在上传对象时指定使用 SSE-S3 加密即可，其余的加密和解密过程都由 Amazon S3 自动管理。<br>透明：对于使用 SSE-S3 加密的数据，用户在访问时不会感觉到任何不同，因为加密和解密都是透明进行的。<br>安全性：使用 SSE-S3 加密的数据，其密钥管理和保护是由 AWS 的硬件安全模块（HSM）来完成的，这提供了很高的安全保障。<br>自动加密：默认情况下，所有新的 S3 存储桶都会自动使用 SSE-S3 加密新上传的对象，除非您指定了其他加密方式。</p><p>注意事项：<br>性能影响：使用 SSE-S3 加密可能会对性能产生微小的影响，因为每次读取和写入操作都需要进行加密和解密操作。<br>成本：虽然 AWS 不额外收费用于 SSE-S3 加密，但是如果您使用了 S3 提供的额外密钥管理功能，如 AWS Key Management Service (KMS)，则可能会产生额外费用。<br>权限：如果您的 AWS Identity and Access Management (IAM) 策略不允许使用 SSE-S3，那么尝试上传文件时可能会遇到权限问题。</p><h5 id="SSE-KMS"><a href="#SSE-KMS" class="headerlink" title="SSE-KMS"></a>SSE-KMS</h5><ul><li>是Amazon S3的另一种服务端加密选项，提供更多的用户控制权和审计跟踪</li><li>如何工作：<br>当您启用 SSE-KMS 时，您可以选择使用由 KMS 管理的默认服务密钥，也可以在 KMS 中创建自己的客户主密钥（CMK）。<br>当您上传数据到 S3 时，您需要指定使用 KMS 密钥进行加密。<br>S3 将与 KMS 通信，使用指定的 CMK 对数据进行加密，并将加密的数据保存到存储中。<br>当您需要读取数据时，S3 将请求 KMS 解密数据，然后将解密后的数据返回给您。</li></ul><p>特点：<br>用户控制的密钥：您可以创建、管理和使用您自己的加密密钥，也可以使用由 AWS 管理的默认密钥。<br>密钥轮换：KMS 支持自动轮换密钥，提高了安全性。<br>审计日志：与 KMS 集成的 AWS CloudTrail 提供了密钥使用情况的审计日志，方便审计和合规。<br>细粒度权限：您可以使用 IAM 策略精确控制谁可以使用哪些密钥来加密和解密数据。</p><p>注意事项：<br>性能影响：与 SSE-S3 类似，使用 SSE-KMS 也可能会对性能产生微小的影响，尤其是在加密和解密操作时。<br>成本：使用 KMS 管理的密钥可能会产生额外的费用，包括密钥存储费用和密钥使用费用。<br>权限管理：需要确保适当的 IAM 策略和权限设置，以便用户可以正确地使用 KMS 密钥。</p><h4 id="权限和角色"><a href="#权限和角色" class="headerlink" title="权限和角色"></a>权限和角色</h4><p>适当IAM角色和权限来设置和管理多区域复制</p><h2 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h2><ul><li>数据加密：S3支持服务端加密数据，以及在传输过程中使用SSL/TLS加密数据</li></ul><h3 id="过程中SSL-TLS加密"><a href="#过程中SSL-TLS加密" class="headerlink" title="过程中SSL/TLS加密"></a>过程中SSL/TLS加密</h3><ul><li>机密协议：AWS S3使用的是SSL/TLS协议在加密传输中的数据，确保互联网安全</li><li>自动加密： 通过HTTPS向S3上传或从S3下载数据时候，SSL/TLS加密是自动应用的，以为这无需进行额外的配置</li><li>端点安全：使用HTTPS连接可以确保您的数据在从客户端到S3端点的整个路径上都是加密的。</li><li>与存储中加密的区别：需要注意的是，传输中加密与存储中加密（例如S3的服务器端加密）是不同的。存储中加密关注的是数据在S3存储桶中处于静止状态时的加密，而传输中加密关注的是数据移动时的安全性。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>优化的性能：S3 提供了优化的性能，尤其是对于分布式应用和大数据工作负载。<br>并行传输：S3 支持多部分上传和下载，使得大文件可以分成小块并行处理，提高数据传输速度。</p><h2 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h2><p>生命周期管理：S3 提供了生命周期管理策略，允许你自动转移或删除在一定时间后不再需要的数据。<br>存储类别：S3 提供多种存储类别，如 S3 Standard、S3 Intelligent-Tiering、S3 Standard-IA（低频访问）、S3 One Zone-IA（单可用区低频访问）和 S3 Glacier（用于长期存档），以适应不同的成本和访问频率需求。<br>监控和日志记录：S3 提供了监控工具，如 S3 访问日志和 AWS CloudTrail，以及与 Amazon CloudWatch 的集成，以便于监控和记录存储操作。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>存储在S3的数据可以用各种AWS的分析服务</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>数据分析服务可以有<a href="#amazon-athena">Amazon Athena</a>,<a href="#amozon-redshift">Amozon Redshift</a>,<a href="#amazon-emr">Amazon EMR</a></p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>数据转换服务可以有<a href="#aws-glue">AWS Glue</a> ，<a href="#aws-data-pipeline">AWS Data Pipeline</a> ，<a href="#aws-lambda">AWS Lambda</a></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>AWS提供了一系列机器学习服务，如<a href="#amazon-sagemaker">Amazon SageMaker</a>、<a href="#amazon-rekognition">Amazon Rekognition</a>、<a href="#amazon-comprehend">Amazon Comprehend</a>等，可以在S3上的数据上构建和训练机器学习模型。</p><h2 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h2><h3 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h3><ul><li>检索速度必然是比S3存储要长的，主要是因为大数量和低频访问</li><li>S3 Glacier的检索会产生额外的检索费用，取决于数据大小和检索速度</li><li>可指定检索选项</li></ul><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>可以用生命周期策略自动将数据从S3标准存储转移到S3 Glacier</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一般都是在需要存储大量数据但又不经常访问的场景</p><h1 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h1><h2 id="DNS功能"><a href="#DNS功能" class="headerlink" title="DNS功能"></a>DNS功能</h2><p>域名注册与转移：Route 53 允许用户注册新的域名或将现有域名从其他注册商转移到 AWS。</p><p>托管区域（Hosted Zones）：在 Route 53 中，托管区域是一个容器，它包含了处理一个域名及其子域名的 DNS 记录。托管区域分为公有托管区域和私有托管区域。</p><p>DNS 记录类型：Route 53 支持多种 DNS 记录类型，包括 A (地址记录)，AAAA (IPv6 地址记录)，CNAME (规范名称记录)，MX (邮件交换记录)，TXT (文本记录)，NS (名称服务器记录) 和 SOA (起始授权机构记录) 等。</p><p>路由策略：Route 53 提供多种路由策略，如简单路由、加权路由、延迟路由、故障转移路由和地理位置路由等，允许用户根据不同的条件来路由流量。</p><p>别名记录：Route 53 的别名记录允许将一个域名映射到 AWS 资源，例如 Amazon S3 存储桶、Elastic Load Balancing (ELB) 负载均衡器或另一个 Route 53 托管区域中的域名。与 CNAME 记录不同，别名记录可以用于域名的根节点（例如 example.com）。</p><p>DNS 查询日志：用户可以配置 Route 53 以记录所有对托管区域的 DNS 查询，这有助于调试和监控 DNS 活动。</p><p>DNSSEC：Route 53 支持 DNS 安全扩展 (DNSSEC)，这是一种增强 DNS 安全性的协议，可以保护域名解析过程不被篡改。</p><p>全球分布的 DNS 服务器：Route 53 使用全球分布的 DNS 服务器和 Anycast 路由技术，确保 DNS 查询响应迅速且可靠。</p><h3 id="DNSSEC安全扩展"><a href="#DNSSEC安全扩展" class="headerlink" title="DNSSEC安全扩展"></a>DNSSEC安全扩展</h3><p>保护互联网用户免受伪造DNS数据（缓存投毒）的攻击，通过对DNS响应进行数字签名</p><p>主要步骤：<br>生成密钥：为每一个DNS区域生成一次公钥和私钥。</p><p>签名记录：使用私钥对DNS区域中RRsets进行签名，签名存储再DNS作为性的记录类型，称为DNSSEC签名（RRSIG）记录。</p><p>分发公钥：将公钥作为DNSKEY记录分发再DNS中，以便任何人都可以用它来验证签名</p><p>链式信任：DNSSEC 使用一种链式信任模型，其中每个级别的 DNS 区域都会签署其下一级别的区域的密钥。这个链条一直延伸到根域名服务器，它的密钥被称为根密钥，是整个信任链的基础。</p><p>验证：当客户端（如 DNS 解析器）收到 DNSSEC 保护的响应时，它会使用存储在 DNS 中的公钥来验证响应的签名。如果验证成功，客户端可以确信该响应是未被篡改的。</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><h4 id="简单路由："><a href="#简单路由：" class="headerlink" title="简单路由："></a>简单路由：</h4><p>到单个资源，域名指向一个IP地址或一个Amazon S3 存储桶</p><h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><ul><li>单一资源服务，单个web服务器或单个Amazon S3存储桶</li><li>不需要复杂的路由决策的简单域名分析</li></ul><h4 id="加权路由："><a href="#加权路由：" class="headerlink" title="加权路由："></a>加权路由：</h4><p>允许你分配不同的权重给相同域名下的多个资源，从而控制流量的分配比例。这对于流量切换和 A/B 测试非常有用。</p><h5 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h5><ul><li>A/B 测试，将流量按照一定比例分配给不同的应用版本。</li><li>平滑的流量迁移，逐渐增加指向新资源的流量比例。</li><li>负载分配，根据服务器能力分配不同的权重。</li></ul><h4 id="延迟路由"><a href="#延迟路由" class="headerlink" title="延迟路由"></a>延迟路由</h4><p>根据用户到 AWS 区域的网络延迟自动路由用户请求。这有助于向用户提供最低延迟的响应。</p><h5 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h5><ul><li>多区域部署，根据用户到 AWS 区域的延迟选择最佳路由。</li><li>性能优化，确保用户获得最快的响应时间。</li></ul><h4 id="故障转移路由"><a href="#故障转移路由" class="headerlink" title="故障转移路由"></a>故障转移路由</h4><p>在主要资源发生故障时，自动将流量切换到备份资源。这对于实现高可用性和灾难恢复非常关键。</p><h5 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h5><ul><li>灾难恢复，当主要资源发生故障时自动切换到备用资源。</li><li>高可用性配置，配合健康检查确保服务不间断<h4 id="地理位置路由"><a href="#地理位置路由" class="headerlink" title="地理位置路由"></a>地理位置路由</h4>根据用户的地理位置将流量路由到特定的资源。这可以用于内容本地化或遵守地理位置相关的法律法规。</li></ul><h5 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h5><ul><li>地理目标定位，向特定地理区域的用户提供定制化内容。</li><li>法规遵从，确保数据存储和处理遵守特定地区的法律法规。</li><li>负载分散，将用户流量分散到不同的区域以减轻特定服务器的负载。<h4 id="地理位置优先路由"><a href="#地理位置优先路由" class="headerlink" title="地理位置优先路由"></a>地理位置优先路由</h4>根据用户和资源之间的地理位置距离来路由流量。可以通过使用“偏置值”来调整流量的分配<h5 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h5></li><li>地理位置敏感的负载均衡，更精细地控制基于用户位置的流量分配。</li><li>业务扩展，根据业务需求和用户位置动态调整流量。<h4 id="多值答案路由"><a href="#多值答案路由" class="headerlink" title="多值答案路由"></a>多值答案路由</h4>当你想要 Route 53 返回多个资源的 IP 地址，并且希望 Route 53 对这些资源进行健康检查时，可以使用这种策略。</li></ul><h5 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h5><ul><li>提供了内置健康检查的简单负载均衡。</li><li>当有多个资源可以提供服务时，增加系统的容错能力。</li><li>需要从多个资源中返回单个或多个健康资源的 IP 地址。</li></ul><h2 id="Route-53-的Best-Match"><a href="#Route-53-的Best-Match" class="headerlink" title="Route 53 的Best Match"></a>Route 53 的Best Match</h2><h3 id="与EC2配合实现静态网站托管"><a href="#与EC2配合实现静态网站托管" class="headerlink" title="与EC2配合实现静态网站托管"></a>与EC2配合实现静态网站托管</h3><ul><li>Route 53 可以将流量路由运行在Amazon EC2实例上的应用程序</li><li>使用故障转移路由来监控EC2实例的健康状况，在需要时将流量自动切换到备用实例</li></ul><h3 id="与ELB配合实现高可用性和负载均衡"><a href="#与ELB配合实现高可用性和负载均衡" class="headerlink" title="与ELB配合实现高可用性和负载均衡"></a>与ELB配合实现高可用性和负载均衡</h3><ul><li>ELB自动分配进来的应用流量到多个EC2实例，以提高容错能力和可伸缩性</li><li>Route 53可以直接与ELB集成，将域名解析到ELB的DNS名称，而不是特定的IP地址</li></ul><h3 id="与S3配合实现静态网站托管"><a href="#与S3配合实现静态网站托管" class="headerlink" title="与S3配合实现静态网站托管"></a>与S3配合实现静态网站托管</h3><ul><li>可以以将域名解析到一个Amazon存储桶，这个存储桶配置为静态网站</li></ul><h3 id="与Lambda和API-Gateway配合实现无服务器架构"><a href="#与Lambda和API-Gateway配合实现无服务器架构" class="headerlink" title="与Lambda和API Gateway配合实现无服务器架构"></a>与Lambda和API Gateway配合实现无服务器架构</h3><ul><li>Route 53 可以将流量路由到一个API Gateway，后者触发Lambda函数来处理请求</li><li>架构可以构建完全无服务器的应用，轻松扩展且成本效益高</li></ul><h3 id="与CloudFront配合实现全球内容分发"><a href="#与CloudFront配合实现全球内容分发" class="headerlink" title="与CloudFront配合实现全球内容分发"></a>与CloudFront配合实现全球内容分发</h3><ul><li>将用户请求解析到最近的CloudFront边缘位置，加速内容的分发</li></ul><h3 id="与shield配合实现防御分布式拒绝服务DDOS攻击"><a href="#与shield配合实现防御分布式拒绝服务DDOS攻击" class="headerlink" title="与shield配合实现防御分布式拒绝服务DDOS攻击"></a>与shield配合实现防御分布式拒绝服务DDOS攻击</h3><ul><li>托管型DDos防护服务，可以保护在AWS上运行的应用不受DDos攻击</li></ul><h3 id="与WAF配合实现应用层防护"><a href="#与WAF配合实现应用层防护" class="headerlink" title="与WAF配合实现应用层防护"></a>与WAF配合实现应用层防护</h3><ul><li>是一种Web应用防火墙，保护Web应用免受常见的网络和应用层攻击。</li><li>为域名提供基于规则的控制，防止恶意流量到达应用</li></ul><h3 id="与RDS实现数据库故障转移"><a href="#与RDS实现数据库故障转移" class="headerlink" title="与RDS实现数据库故障转移"></a>与RDS实现数据库故障转移</h3><ul><li>Route 53 可以与Amazon RDS配合实现数据库的故障转移和读取复制</li></ul><h3 id="与VPC配合使用构建私有云解析和内部域名服务"><a href="#与VPC配合使用构建私有云解析和内部域名服务" class="headerlink" title="与VPC配合使用构建私有云解析和内部域名服务"></a>与VPC配合使用构建私有云解析和内部域名服务</h3><ul><li>通过私有托管区域，企业可以管理内部域名，而这些域名不会被路由到公共互联网上</li></ul><h3 id="与Transit-Gateway实现多区域网络连接"><a href="#与Transit-Gateway实现多区域网络连接" class="headerlink" title="与Transit Gateway实现多区域网络连接"></a>与Transit Gateway实现多区域网络连接</h3><ul><li>AWS Transit Gateway 允许连接多个 VPC 和本地网络，形成一个中心式的网络枢纽。</li><li>Route 53 可以用来解析跨这些连接的 VPCs 内部的服务名称。</li></ul><h3 id="与-AWS-Direct-Connect-配合混合云环境"><a href="#与-AWS-Direct-Connect-配合混合云环境" class="headerlink" title="与 AWS Direct Connect 配合混合云环境"></a>与 AWS Direct Connect 配合混合云环境</h3><ul><li>AWS Direct Connect 通过私有连接将企业数据中心连接到 AWS，绕过公共互联网，提高安全性和带宽。</li><li>Route 53 可以用来解析通过 Direct Connect 连接的资源，保证内部和外部解析的一致性。</li></ul><h3 id="与ACM构建SSL-TLS证书管理"><a href="#与ACM构建SSL-TLS证书管理" class="headerlink" title="与ACM构建SSL/TLS证书管理"></a>与ACM构建SSL/TLS证书管理</h3><ul><li>简化了SSL/TLS证书的获取，管理和部署过程</li><li>自动使用DNS验证来验证域名的所有权并且自动续签证书</li></ul><h3 id="与EC2和EKS构建容器化应用和微服务"><a href="#与EC2和EKS构建容器化应用和微服务" class="headerlink" title="与EC2和EKS构建容器化应用和微服务"></a>与EC2和EKS构建容器化应用和微服务</h3><ul><li>ECS和EKS提供容器服务</li><li>Route 53可以与ECS和EKS集成，通过服务发现机制自动注册和解除注册容器实例，使微服务架构中的服务能够相互发现和通信</li></ul><h1 id="稍微理解"><a href="#稍微理解" class="headerlink" title="稍微理解"></a>稍微理解</h1><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend +"></a>Amazon Comprehend +</h2><ul><li>一项自然语言（NLP）服务，使用机器学习技术赖解析文本中的洞察和关系</li></ul><ol><li><strong>实体识别（Entity Recognition）</strong>：能够识别文本中的具体实体，如人名、地点、品牌或其他专有名词。</li><li><strong>情感分析（Sentiment Analysis）</strong>：分析文本的情感倾向，判断它是正面的、负面的、中性的还是复合情感的。</li><li><strong>关键词提取（Key Phrase Extraction）</strong>：从文本中提取重要的或者有意义的短语。</li><li><strong>语言识别（Language Detection）</strong>：自动识别文本所使用的语言。</li><li><strong>句法分析（Syntax Analysis）</strong>：分析文本中的语言构成，比如词性标注和句子成分分析。</li><li><strong>主题建模（Topic Modeling）</strong>：识别文档集合中的主题模式。</li></ol><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p><strong>Amazon Rekognition</strong> 是一项基于深度学习的图像和视频分析服务。它可以识别图像和视频中的对象、场景、文字以及人脸。Rekognition 提供了多种功能，包括：</p><ul><li><strong>人脸分析</strong>：识别人脸、检测面部特征、评估情绪等。</li><li><strong>人脸比对</strong>：比对两张人脸图像，判断它们是否属于同一个人。</li><li><strong>人脸搜索</strong>：在大型图像库中搜索特定人脸。</li><li><strong>文本识别</strong>：检测和识别图像中的文字。</li><li><strong>场景分析</strong>：识别图像中的场景和对象。</li></ul><p>开发者可以通过简单的 API 调用来使用这些功能，从而构建各种视觉分析应用。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p><strong>Amazon SageMaker</strong> 是一项全面的机器学习平台，旨在简化机器学习模型的构建、训练和部署过程。SageMaker 提供了以下功能：</p><ul><li><strong>数据标注</strong>：帮助准备训练数据。</li><li><strong>模型训练</strong>：使用各种机器学习算法训练模型。</li><li><strong>模型调优</strong>：优化模型性能。</li><li><strong>模型部署</strong>：将训练好的模型部署到生产环境中。</li></ul><p>SageMaker 支持多种常见的机器学习算法和框架，同时提供了一个交互式的开发环境，方便开发者快速迭代和部署模型。</p><h2 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h2><p><strong>AWS Lambda</strong> 是一项无服务器计算服务，开发者可以在 Lambda 上运行代码而无需管理服务器。Lambda 可以根据各种事件（如 API 调用、文件上传等）触发执行代码，支持多种编程语言，包括 Python、Node.js、Java 等。Lambda 的特点包括：</p><ul><li><strong>弹性扩展</strong>：根据请求量自动扩展计算资源。</li><li><strong>按需计费</strong>：只需为实际使用的计算资源付费。</li><li><strong>事件驱动</strong>：可以与多种 AWS 服务集成，响应各种事件。</li></ul><p>Lambda 适用于构建无服务器应用、自动化任务、数据处理等场景。</p><h2 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h2><p><strong>AWS Data Pipeline</strong> 是一项数据处理服务，用于自动化和调度数据处理工作流程。开发者可以使用 Data Pipeline 来定义数据处理流程、调度任务执行、跟踪任务状态等。Data Pipeline 提供了以下功能：</p><ul><li><strong>数据源连接</strong>：支持多种数据源，包括 AWS 服务和外部数据存储。</li><li><strong>灵活调度</strong>：可以根据时间表、事件触发等条件调度任务。</li><li><strong>任务监控</strong>：提供任务状态监控和报警功能。</li></ul><p>Data Pipeline 可以帮助简化数据处理流程，提高数据处理的效率和可靠性。</p><h2 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h2><p><strong>AWS Glue</strong> 是一项全托管的数据集成服务，用于抽取、转换和加载数据。Glue 可以自动发现数据源、推断数据模式、执行数据转换操作，并将数据加载到目标数据存储中。Glue 的主要功能包括：</p><ul><li><strong>数据目录</strong>：自动创建和维护数据目录。</li><li><strong>ETL 转换</strong>：支持数据抽取、转换和加载。</li><li><strong>数据目录版本控制</strong>：管理数据目录版本。</li></ul><p>AWS Glue 可以帮助用户简化数据集成和数据准备的过程，加速数据处理和分析的流程。</p><h2 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h2><p><strong>Amazon EMR</strong> 是一项大数据处理服务，基于开源的 Apache Hadoop 和 Apache Spark 构建。EMR 可以帮助用户快速搭建、扩展和管理大数据处理集群，用于分析、处理大规模数据集。EMR 提供了以下特点：</p><ul><li><strong>弹性扩展</strong>：根据需求自动扩展集群规模。</li><li><strong>多种框架支持</strong>：支持 Hadoop、Spark、Presto 等多种大数据处理框架。</li><li><strong>安全性和可靠性</strong>：提供数据加密、访问控制等安全特性。</li></ul><p>EMR 可以帮助用户快速搭建大数据处理环境，进行数据分析和处理。</p><h2 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p><strong>Amazon Redshift</strong> 是一种云数据仓库服务，用于分析大规模数据集。Redshift 提供了高性能的数据查询和分析能力，支持列式存储、压缩和并行查询等特性。Redshift 的特点包括：</p><ul><li><strong>高性能</strong>：支持大规模数据并行处理，提供快速的查询性能。</li><li><strong>可扩展性</strong>：可以根据需求扩展集群规模。</li><li><strong>SQL 兼容</strong>：支持标准 SQL 查询语言。</li></ul><p>Redshift 可以帮助用户构建数据仓库和商业智能应用，进行复杂的数据分析和查询。</p><h2 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h2><p><strong>Amazon Athena</strong> 是一项交互式查询服务，用于在亚马逊 S3 存储中执行 SQL 查询。Athena 可以帮助用户快速分析存储在 S3 中的数据，无需预先加载数据到数据库中。Athena 的特点包括：</p><ul><li><strong>无服务器</strong>：无需管理基础设施，按需执行查询。</li><li><strong>标准 SQL</strong>：支持标准 SQL 查询语言。</li><li><strong>数据格式支持</strong>：支持多种数据格式，如 CSV、JSON 等。</li></ul><p>Athena 可以帮助用户快速进行数据查询和分析，适用于需要快速查询大规模数据集的场景。</p><h1 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h1><h2 id="无服务器集成"><a href="#无服务器集成" class="headerlink" title="无服务器集成"></a>无服务器集成</h2><p>无服务器集成是能够将API端点直接连接到无服务器后端服务，如Lambda和DynamoDB，不需要运行或管理任何服务器，这种集成方式简化了API部署和管理，因为AWS负责所有的基础设置管理。</p><h3 id="Lambda集成"><a href="#Lambda集成" class="headerlink" title="Lambda集成"></a>Lambda集成</h3><p>API Gateway可以将请求直接路由到Lambda函数，当API被调用时，触发一个Lambda函数，该函数执行业务逻辑然后返回响应，允许你构建强大的后端逻辑，无需担心服务器的运行和维护</p><h3 id="DynamoDB集成"><a href="#DynamoDB集成" class="headerlink" title="DynamoDB集成"></a>DynamoDB集成</h3><p>API Gateway可以直接与DynamoDB集成，运行API直接执行DynamoDB表上的操作，如获取项目，写入项目等。API Gateway，创建一个完全无服务的后端，用于存储和检索数据。</p><h3 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h3><p>创建Lambda函数或DynamoDB表，设置API Gateway资源，创建新的API，配置集成请求和响应，部署，用CloudWatch监控API调用和Lambda函数执行，确保性能和可靠性</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>API Gateway 提供了几种流量控制机制，帮助开发者防止过载后端服务</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>默认节流：对每个账户提供默认的节流限制，这些限制是以每秒请求数TPS和并发限制来定义的，如果超过限制则会返回429错误</li><li>自定义节流</li></ul><h3 id="使用计划"><a href="#使用计划" class="headerlink" title="使用计划"></a>使用计划</h3><ul><li>允许用户创建使用计划，并与API密钥关联，可定义API密钥允许请求频率的限制和配额限制</li></ul><h3 id="突发限制"><a href="#突发限制" class="headerlink" title="突发限制"></a>突发限制</h3><ul><li>突发限制是指在短时间内允许的最大请求数。这对于处理短时间内的突然流量增加很有用，同时确保后端服务不会因为大量并发请求而过载。</li></ul><h3 id="客户端限流"><a href="#客户端限流" class="headerlink" title="客户端限流"></a>客户端限流</h3><ul><li>开发者可以在客户端实施限流措施，这通常是通过重试逻辑和指数退避策略来实现的。这有助于在客户端自动处理和平滑处理 429 错误。</li></ul><h2 id="数据转换-1"><a href="#数据转换-1" class="headerlink" title="数据转换"></a>数据转换</h2><p>API Gateway 中实现数据转换的主要工具是模板和模型：</p><h3 id="模板（Mapping-Templates）"><a href="#模板（Mapping-Templates）" class="headerlink" title="模板（Mapping Templates）"></a>模板（Mapping Templates）</h3><p>API Gateway 允许你使用 Velocity Template Language (VTL) 和 JSONPath 表达式来创建映射模板。这些模板定义了如何将客户端请求转换为后端服务所期望的格式，以及如何将后端服务的响应转换为客户端所期望的格式。</p><p>请求模板：在请求模板中，你可以添加逻辑来定制请求有效载荷，例如添加或删除 JSON 字段，修改头部信息，或者根据请求参数构建一个全新的请求体。<br>响应模板：响应模板允许你修改从后端服务返回的数据。你可以转换数据格式，只返回客户端需要的部分数据，或者处理错误响应。</p><h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>模型是 API Gateway 中定义的数据结构，它们使用 JSON Schema 描述了 API 的请求和响应数据。模型可以帮助你标准化数据结构，并为你的 API 用户提供清晰的数据格式文档。<br>请求模型：定义了 API 接收的数据结构，可以用来校验请求数据。<br>响应模型：定义了 API 返回的数据结构，可以用来校验响应数据。<br>利用这些数据转换功能，开发者可以确保 API 的前端和后端之间的通信是平滑和一致的，即使它们可能使用不同的数据格式或标准。这也使得 API Gateway 成为一个强大的工具，用于在不修改后端服务的情况下，快速适应前端应用程序的变化需求。</p><h2 id="RESTful-API-和-WebSocket-API"><a href="#RESTful-API-和-WebSocket-API" class="headerlink" title="RESTful API 和 WebSocket API"></a>RESTful API 和 WebSocket API</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>RESTful API 是一种基于 HTTP 协议的 Web API。它遵循 REST 架构原则，通常使用标准的 HTTP 方法，如 GET、POST、PUT、DELETE 等。API Gateway 中的 RESTful API 提供以下特性：</p><p>无服务器集成：可以直接与 AWS Lambda 函数或其他 AWS 服务集成，无需运行或管理服务器。<br>数据转换：通过映射模板对请求和响应进行转换和重写。<br>流量控制：包括节流、使用计划和配额管理。<br>安全性：支持 API 密钥、AWS IAM 角色和权限以及 Cognito 用户池进行身份验证和授权。<br>版本管理和生命周期管理：支持多个发布阶段和版本控制。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控API调用和记录日志。<br>缓存：可以配置 API 缓存以减少延迟和后端负载。<br>RESTful API 适用于大多数标准的 Web 应用程序场景，特别是那些需要严格的状态无关和资源导向架构的场景。</p><h3 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h3><p>WebSocket API 提供了全双工通信通道，允许服务器和客户端之间进行实时、双向的通信。API Gateway 中的 WebSocket API 具有以下特性：</p><p>连接管理：API Gateway 负责连接的建立和维护。<br>规模扩展：可以根据连接数自动扩展，支持大量并发WebSocket连接。<br>路由选择：基于传入的消息内容，将不同的消息路由到不同的后端服务，如 AWS Lambda 或 HTTP 终端节点。<br>集成后端服务：与 AWS Lambda 和 HTTP API 直接集成，无需管理服务器。<br>安全性：可以使用 AWS IAM、Lambda 授权器或自定义授权器来管理连接和消息的授权。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控连接和消息传递。<br>WebSocket API 适用于需要实时通信的应用程序，如聊天应用、实时游戏、实时通知和协作工具。</p><h2 id="SDK集成"><a href="#SDK集成" class="headerlink" title="SDK集成"></a>SDK集成</h2><p>Amazon API Gateway 提供了与各种编程语言的 SDK 集成支持，这样开发者可以在他们选择的编程语言中更容易地调用由 API Gateway 托管的 API。这些 SDKs，通常称为客户端 SDKs，是自动生成的，并且可以针对已经部署的 API 生成。</p><p>以下是 API Gateway 与 SDK 集成的一些关键点：</p><h3 id="SDK-生成"><a href="#SDK-生成" class="headerlink" title="SDK 生成"></a>SDK 生成</h3><p>对于 RESTful API，API Gateway 允许开发者生成客户端 SDK 来调用 API。这些 SDK 可以针对以下平台生成：</p><ul><li>Android</li><li>iOS (Objective-C 和 Swift)</li><li>JavaScript (适用于浏览器和 Node.js)</li></ul><p>生成 SDK 的过程通常涉及到在 API Gateway 控制台中选择你的 API 阶段，然后选择你想要生成的 SDK 的类型。API Gateway 会为你生成一个包含所有必要调用逻辑和数据结构的压缩文件。</p><h3 id="SDK-的使用"><a href="#SDK-的使用" class="headerlink" title="SDK 的使用"></a>SDK 的使用</h3><p>生成的 SDK 会包含对应语言的库和工具，使得客户端应用程序可以轻松地与 API Gateway 进行通信。例如，生成的 JavaScript SDK 会包含 API 调用的 AJAX 请求代码，而 iOS SDK 会包含构建网络请求的代码。</p><p>使用这些 SDK，开发者可以快速地在他们的应用程序中实现以下功能：</p><ul><li>调用 API Gateway 托管的 API。</li><li>处理请求和响应，包括错误处理。</li><li>传递身份验证和授权信息，如果 API 使用了 API 密钥、AWS IAM 或 Amazon Cognito 用户池。</li></ul><h3 id="SDK-定制和优化"><a href="#SDK-定制和优化" class="headerlink" title="SDK 定制和优化"></a>SDK 定制和优化</h3><p>尽管 SDK 是自动生成的，但开发者仍然可以根据需要对其进行定制。例如，他们可以添加额外的逻辑来处理特定的应用程序场景，或者改进错误处理和重试策略。</p><p>此外，开发者可能需要考虑 SDK 如何影响应用程序的性能和大小，特别是在移动应用程序中。他们可能需要优化网络请求，或者去除未使用的 SDK 部分以减小应用程序的体积。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>使用 SDK 时，安全性是一个重要考虑因素。开发者需要确保他们的应用程序安全地存储和传递任何敏感信息，如 API 密钥或用户凭证。此外，他们可能需要实施额外的安全措施，如使用 HTTPS 来保护数据在传输过程中的安全，或者使用 OAuth 和 Amazon Cognito 来为用户提供安全的身份验证和授权。</p><p>总的来说，API Gateway 的 SDK 集成简化了客户端应用程序与后端服务的交互，允许开发者专注于构建应用程序的核心功能，而不是编写重复的代码来处理 API 调用。通过自动化的 SDK 生成和简单的集成过程，API Gateway 使得从客户端应用程序到云端服务的开发变得更加快捷和高效。</p><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>AWS Lambda 是亚马逊网络服务（Amazon Web Services, 简称AWS）提供的一项无服务器计算服务。它允许你运行代码，而无需预置或管理服务器。</p><h2 id="事件驱动执行"><a href="#事件驱动执行" class="headerlink" title="事件驱动执行"></a>事件驱动执行</h2><ul><li>通过事件触发执行，也可以来自于应用程序的自定义事件</li></ul><h3 id="举例场景：Lambda处理在S3上传新文件时触发"><a href="#举例场景：Lambda处理在S3上传新文件时触发" class="headerlink" title="举例场景：Lambda处理在S3上传新文件时触发"></a>举例场景：Lambda处理在S3上传新文件时触发</h3><p>1.需要创建一个新的Lambda函数，选为某编程语言运行<br>2.把函数分配一个执行角色，这里就是有权读取S3的对象，写入CloudWatch日志<br>3.在S3中设置事件通知，在上传时触发Lambda函数，可以在S3存储属性中找到，把Lambda函数作为目标。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例代码</span></span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote_plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志记录</span></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 S3 客户端</span></span><br><span class="line">s3_client = boto3.client(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># 获取存储桶名称和文件键值</span></span><br><span class="line">    bucket_name = event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;bucket&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    file_key = unquote_plus(event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;object&#x27;</span>][<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录到 CloudWatch 日志中</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;New file uploaded: <span class="subst">&#123;file_key&#125;</span> in bucket: <span class="subst">&#123;bucket_name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里可以添加更多处理逻辑，例如读取文件内容、转换文件格式等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;File processed successfully!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="无服务器架构"><a href="#无服务器架构" class="headerlink" title="无服务器架构"></a>无服务器架构</h2><p>不需要服务器和任何环境，Lambda负责运行你的代码并自动管理底层计算资源</p><h2 id="自动扩展"><a href="#自动扩展" class="headerlink" title="自动扩展"></a>自动扩展</h2><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>一个事件触发器激活一个Lambda函数，如果有多个事件几乎同时到达，Lambda会自动启动多个实例来处理事件</p><h3 id="冷启动与热启动"><a href="#冷启动与热启动" class="headerlink" title="冷启动与热启动"></a>冷启动与热启动</h3><ul><li><p>冷启动：当一个函数被触发而当前没有可用的运行实例时，Lambda会进行一个“冷启动”，即创建一个新的函数实例。过程基本涉及到加载代码，初始化运行时，运行初始化代码（如全局变量声明）等步骤。冷启动通常需要更长启动时间。</p></li><li><p>热启动：如果一个函数实例在执行完一个时间后仍然处于空闲状态，可以被用来快速响应新的时间，这称为热启动，热启动跳过了实例创建过程比冷启动快</p></li></ul><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>Lambda在账户级别有并发执行限制。这个限制是指任何时刻，一个AWS账户可以同时运行的Lambda函数实例的数量。这个限制既保护了用户免受意外的高费用，确保资源的合理分配</p><h3 id="预热行为"><a href="#预热行为" class="headerlink" title="预热行为"></a>预热行为</h3><p>避免冷启动延迟，用户可以实现预热策略，通过定期触发Lambda函数来保持一定数量的热实例。</p><h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><h3 id="IAM角色和策略"><a href="#IAM角色和策略" class="headerlink" title="IAM角色和策略"></a>IAM角色和策略</h3><ul><li><p>创建一个 Lambda 函数时，您需要指定一个执行角色（IAM 角色）。Lambda 函数将使用这个角色的权限来访问 AWS 服务和资源。</p><h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><p>资源策略包含以下部分：</p></li><li><p>Statement：资源策略由一个或多个语句（Statement）组成，每个语句都是一个权限声明，指定了一个允许或拒绝的权限。</p></li><li><p>Effect：每个语句的 Effect 决定了这个语句是允许（Allow）还是拒绝（Deny）某项操作。</p></li><li><p>Action：Action 定义了可以在 Lambda 函数上执行的操作，例如 lambda:InvokeFunction。</p></li><li><p>Resource：Resource 指定了策略适用的资源，对于 Lambda 函数策略来说，这通常是函数的 ARN（Amazon Resource Name）。</p></li><li><p>Principal：Principal 定义了哪些 AWS 账户、用户、角色或服务可以执行在 Action 中定义的操作。</p></li><li><p>Condition：条件（Condition）用于指定策略的有效性取决于一系列预定义的条件是否满足。</p></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>下面是一个资源策略的示例，它允许另一个 AWS 账户的用户调用 Lambda 函数：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Version&quot;:</span> <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Statement&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;Effect&quot;:</span> <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Principal&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;AWS&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;Action&quot;:</span> <span class="string">&quot;lambda:InvokeFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Resource&quot;:</span> <span class="string">&quot;arn:aws:lambda:us-west-2:111122223333:function:MyFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Condition&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;StringEquals&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceAccount&quot;:</span> <span class="string">&quot;123456789012&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ArnLike&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceArn&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，只有在条件满足时（即请求来自特定账户和用户），指定的用户才能调用 MyFunction。通过使用资源策略，您可以跨账户共享 Lambda 函数，或者允许来自 AWS 服务（如 Amazon S3 事件、Amazon SNS 主题、Amazon DynamoDB 更新流等）的触发器调用您的函数。这是实现跨账户功能和集成 AWS 服务的一种强大方式。</p><h3 id="环境变量加密"><a href="#环境变量加密" class="headerlink" title="环境变量加密"></a>环境变量加密</h3><ul><li> 允许您为函数设置环境变量，用于存储配置信息。您可以使用 AWS Key Management Service (KMS) 加密这些环境变量，以保护敏感信息。<h3 id="VPC集成"><a href="#VPC集成" class="headerlink" title="VPC集成"></a>VPC集成</h3></li><li>Lambda函数可配置在VPC内运行</li></ul><h3 id="网络隔离和防火墙"><a href="#网络隔离和防火墙" class="headerlink" title="网络隔离和防火墙"></a>网络隔离和防火墙</h3><ul><li>配置 Lambda 函数在 VPC 中运行，您可以使用网络 ACL 和安全组作为网络层的防火墙，来控制流入和流出资源的流量。<h3 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h3></li><li>调用和执行情况可以通过 Amazon CloudWatch 进行监控和记录日志。您可以配置日志记录，以便在函数执行时捕获调用请求和响应数据。</li></ul><h2 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h2><p>一个经典的多服务场景，使用 AWS Lambda 的例子是一个自动化的图像处理平台。在这个场景中，用户上传图片到 Amazon S3，这会触发一个 Lambda 函数来处理这些图片（例如，压缩、转换格式、添加水印等），然后结果可以被存储在另一个 S3 桶中，或者被发送到其他服务进行进一步处理或分析。</p><p>以下是服务之间的作用和交互：</p><ol><li><p><strong>Amazon S3 (Simple Storage Service)</strong>:</p><ul><li>作为图像和处理后文件的存储位置。</li><li>触发 Lambda 函数以响应新上传的图像。</li></ul></li><li><p><strong>AWS Lambda</strong>:</p><ul><li>执行图像处理逻辑，如调整大小、格式转换或应用水印。</li><li>读取和写入 S3 桶中的文件。</li><li>可以调用其他 AWS 服务，如 Amazon Rekognition 进行图像分析。</li></ul></li><li><p><strong>Amazon Rekognition</strong>:</p><ul><li>提供图像和视频分析，如识别对象、场景和名人。</li><li>Lambda 函数可以将图像发送到 Rekognition 以获取元数据，并根据这些信息进一步处理或分类图像。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>:</p><ul><li>用于存储图像的元数据，如文件名、大小、图像类型、处理状态和 Rekognition 提供的任何分析数据。</li><li>Lambda 函数可以更新 DynamoDB 表以反映处理状态或存储分析结果。</li></ul></li><li><p><strong>Amazon SNS (Simple Notification Service)</strong> 或 <strong>Amazon SQS (Simple Queue Service)</strong>:</p><ul><li>用于通知系统的其他部分，例如，当图像处理完成时。</li><li>Lambda 函数可以发布消息到 SNS 主题或 SQS 队列，以触发其他处理流程或通知用户。</li></ul></li><li><p><strong>AWS Step Functions</strong>:</p><ul><li>管理和协调复杂的多步骤 Lambda 函数工作流。</li><li>Lambda 函数可以作为步骤函数状态机中的一个步骤，以确保处理逻辑按照预定顺序执行。</li></ul></li><li><p><strong>Amazon CloudWatch</strong>:</p><ul><li>监控 Lambda 函数的性能和日志。</li><li>Lambda 函数执行时会自动记录日志和各种指标，以供分析和调试。</li></ul></li></ol><p>在这个场景中，用户上传图片到 S3 桶，这个上传操作自动触发一个 Lambda 函数。Lambda 函数读取新上传的图片，进行必要的处理，然后将处理后的图片存储到另一个 S3 桶中。如果启用了图像分析，Lambda 函数还会调用 Amazon Rekognition。处理结果（包括图像元数据和分析数据）可以被存储到 DynamoDB。Lambda 函数还可以将处理完成的事件通过 SNS 或 SQS 发布出去，以便其他应用组件可以响应这些事件。整个处理流程可以用 AWS Step Functions 来协调。最后，Amazon CloudWatch 被用来监控整个过程，包括 Lambda 函数的性能和日志记录。</p><h1 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h1><h2 id="Classic-Load-Balancer（CLB）"><a href="#Classic-Load-Balancer（CLB）" class="headerlink" title="Classic Load Balancer（CLB）"></a>Classic Load Balancer（CLB）</h2><ul><li>支持基于TCP和HTTP/HTTPS的负载均衡</li><li>提供固定性能，但没有ALB和NLB那样灵活</li><li>支持一个简单的健康检查<h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3></li></ul><ul><li>旧的或遗留的应用程序，这些应用程序不需要复杂的路由规则，只需简单地在多个服务器之间分发流量。</li><li>示例：一个简单的网站或应用程序，客户端通过HTTP/HTTPS请求服务，CLB将请求均匀地分配给后端的多个EC2实例。</li></ul><h2 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h2><ul><li>ALB是为HTTP/HTTPS流量设计的，提供高级的请求路由功能，比如基于内容的路由。</li><li>支持路径、主机、HTTP头部、HTTP方法和查询参数等多种路由条件。</li><li>可以直接与容器化服务和微服务架构进行集成。</li><li>提供了更细粒度的健康检查。</li><li>支持WebSocket和HTTP/2。</li></ul><h3 id="场景举例-1"><a href="#场景举例-1" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>面向现代应用程序，特别是在微服务架构中，需要根据URL的不同路径将流量路由到不同的服务。</li><li>示例：一个电子商务网站，其中/catalog路径指向商品目录服务，而/cart路径指向购物车服务。ALB可以根据路径将流量路由到不同的服务或容器。</li></ul><h2 id="3-Network-Load-Balancer-NLB"><a href="#3-Network-Load-Balancer-NLB" class="headerlink" title="3. Network Load Balancer (NLB)"></a>3. Network Load Balancer (NLB)</h2><ul><li>NLB是在第4层（传输层）工作的负载均衡器，专门设计用于处理极高的性能和低延迟需求。</li><li>支持静态IP地址或Elastic IP地址。</li><li>适用于处理TCP、UDP和TLS流量。</li><li>能够处理数百万请求每秒，同时保持极低的延迟。</li><li>支持长连接，适合需要保持TCP连接的应用程序。</li></ul><h3 id="场景举例-2"><a href="#场景举例-2" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>高性能的实时游戏、股票交易平台或需要处理大量TCP连接的任何其他类型的应用程序。</li><li>示例：实时多人在线游戏服务器，玩家的连接需要低延迟和高吞吐量，NLB可以有效地在多个游戏服务器实例之间分配TCP流量。</li></ul><h2 id="其他服务集成"><a href="#其他服务集成" class="headerlink" title="其他服务集成"></a>其他服务集成</h2><p>AWS的Elastic Load Balancing (ELB)服务可以与许多其他AWS服务集成，以提供更完整、更强大的解决方案。以下是一些常与ELB集成使用的AWS服务：</p><h3 id="1-Amazon-EC2-Elastic-Compute-Cloud"><a href="#1-Amazon-EC2-Elastic-Compute-Cloud" class="headerlink" title="1. Amazon EC2 (Elastic Compute Cloud)"></a>1. Amazon EC2 (Elastic Compute Cloud)</h3><ul><li>ELB通常用来分配流量给后端的EC2实例。当实例的健康检查通过时，它们会被加入负载均衡器的目标池中。</li></ul><h3 id="2-Amazon-ECS-Elastic-Container-Service"><a href="#2-Amazon-ECS-Elastic-Container-Service" class="headerlink" title="2. Amazon ECS (Elastic Container Service)"></a>2. Amazon ECS (Elastic Container Service)</h3><ul><li>对于容器化的应用程序，ALB可以直接与ECS服务集成，自动注册容器实例作为负载均衡器的目标。</li></ul><h3 id="3-AWS-Fargate"><a href="#3-AWS-Fargate" class="headerlink" title="3. AWS Fargate"></a>3. AWS Fargate</h3><ul><li>Fargate提供了无服务器的容器执行环境，与ELB（特别是ALB）集成时，可以动态地负载均衡到Fargate任务。</li></ul><h3 id="4-Amazon-EKS-Elastic-Kubernetes-Service"><a href="#4-Amazon-EKS-Elastic-Kubernetes-Service" class="headerlink" title="4. Amazon EKS (Elastic Kubernetes Service)"></a>4. Amazon EKS (Elastic Kubernetes Service)</h3><ul><li>对于Kubernetes管理的容器应用程序，ELB可以用来平滑地分配流量到EKS集群中的Pods。</li></ul><h3 id="5-AWS-Lambda"><a href="#5-AWS-Lambda" class="headerlink" title="5. AWS Lambda"></a>5. AWS Lambda</h3><ul><li>ALB可以直接触发Lambda函数，允许无服务器架构的应用程序响应HTTP/HTTPS请求。</li></ul><h3 id="6-AWS-Auto-Scaling"><a href="#6-AWS-Auto-Scaling" class="headerlink" title="6. AWS Auto Scaling"></a>6. AWS Auto Scaling</h3><ul><li>ELB与Auto Scaling紧密集成，可以根据流量增减自动调整EC2实例的数量。</li></ul><h3 id="7-Amazon-RDS-Relational-Database-Service"><a href="#7-Amazon-RDS-Relational-Database-Service" class="headerlink" title="7. Amazon RDS (Relational Database Service)"></a>7. Amazon RDS (Relational Database Service)</h3><ul><li>虽然ELB不直接与RDS集成，但是可以配置应用程序在ELB后面连接到RDS数据库，从而使数据库层与应用层分离，提高可扩展性。</li></ul><h3 id="8-Amazon-S3-Simple-Storage-Service"><a href="#8-Amazon-S3-Simple-Storage-Service" class="headerlink" title="8. Amazon S3 (Simple Storage Service)"></a>8. Amazon S3 (Simple Storage Service)</h3><ul><li>对于静态内容，可以配置ALB通过HTTP(S)重定向到S3存储桶，以便高效地提供静态资源。</li></ul><h3 id="9-AWS-WAF-Web-Application-Firewall"><a href="#9-AWS-WAF-Web-Application-Firewall" class="headerlink" title="9. AWS WAF (Web Application Firewall)"></a>9. AWS WAF (Web Application Firewall)</h3><ul><li>可以将AWS WAF与ALB和NLB集成，为应用程序提供基于规则的防护，以防止常见的网络攻击。</li></ul><h3 id="10-AWS-Certificate-Manager-ACM"><a href="#10-AWS-Certificate-Manager-ACM" class="headerlink" title="10. AWS Certificate Manager (ACM)"></a>10. AWS Certificate Manager (ACM)</h3><ul><li>与ACM集成可以轻松地在ELB上部署SSL/TLS证书，以实现安全的数据传输。</li></ul><h3 id="11-Amazon-CloudWatch"><a href="#11-Amazon-CloudWatch" class="headerlink" title="11. Amazon CloudWatch"></a>11. Amazon CloudWatch</h3><ul><li>ELB与CloudWatch集成，提供了监控和日志记录功能，以跟踪和分析负载均衡器的性能。</li></ul><h3 id="12-AWS-CloudTrail"><a href="#12-AWS-CloudTrail" class="headerlink" title="12. AWS CloudTrail"></a>12. AWS CloudTrail</h3><ul><li>CloudTrail与ELB集成，可以记录所有ELB事件，帮助用户进行安全分析和操作审计。</li></ul><h3 id="13-AWS-Global-Accelerator"><a href="#13-AWS-Global-Accelerator" class="headerlink" title="13. AWS Global Accelerator"></a>13. AWS Global Accelerator</h3><ul><li>对于全球分布的应用程序，可以使用Global Accelerator提高用户到ELB的连接速度和可靠性。</li></ul><h3 id="14-AWS-Shield"><a href="#14-AWS-Shield" class="headerlink" title="14. AWS Shield"></a>14. AWS Shield</h3><ul><li>与ELB集成的AWS Shield提供了DDoS保护，以保护应用程序免受分布式拒绝服务攻击。</li></ul>]]></content>
    
    
    <summary type="html">AWS server for learning</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Basic for SAA</title>
    <link href="https://kalyan-zitiu.github.io/2023/12/24/SAA%E6%8F%90%E7%BA%B2/"/>
    <id>https://kalyan-zitiu.github.io/2023/12/24/SAA%E6%8F%90%E7%BA%B2/</id>
    <published>2023-12-24T12:00:00.000Z</published>
    <updated>2023-12-25T09:05:54.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SAA"><a href="#SAA" class="headerlink" title="SAA"></a>SAA</h1><h3 id="领域-1：-设计安全的架构"><a href="#领域-1：-设计安全的架构" class="headerlink" title="领域 1： 设计安全的架构"></a><strong>领域</strong> <strong>1</strong>： 设计安全的架构</h3><h3 id="跨多个账户的访问控制和管理："><a href="#跨多个账户的访问控制和管理：" class="headerlink" title="跨多个账户的访问控制和管理："></a>跨多个账户的访问控制和管理：</h3><p>跨多个AWS账户的访问控制和管理是一项复杂任务，它涉及到使用AWS的服务和功能来创建一个安全、高效且易于管理的多账户环境。以下是详细介绍如何实现这一目标的步骤：</p><h4 id="1-使用AWS-Organizations："><a href="#1-使用AWS-Organizations：" class="headerlink" title="1. 使用AWS Organizations："></a>1. 使用AWS Organizations：</h4><p>AWS Organizations是一个服务，允许您集中管理和治理您的多个AWS账户。使用AWS Organizations，您可以：</p><ul><li><strong>创建组织</strong>：将所有账户集合成一个组织，方便管理。</li><li><strong>创建组织单位（OUs）</strong>：将账户分组，以便对一组账户执行策略。</li><li><strong>服务控制策略（SCPs）</strong>：为OUs或单个账户设置策略，限制可执行的AWS服务和操作。</li></ul><h5 id="实践步骤："><a href="#实践步骤：" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>登录到AWS Management Console。</li><li>寻找并选择AWS Organizations服务。</li><li>创建一个新组织，邀请现有账户或创建新账户。</li><li>创建OUs，按功能、部门或其他逻辑方式组织账户。</li><li>应用SCPs以限制OU或账户级别的权限。</li></ol><h4 id="2-使用IAM进行用户管理："><a href="#2-使用IAM进行用户管理：" class="headerlink" title="2. 使用IAM进行用户管理："></a>2. 使用IAM进行用户管理：</h4><p>在AWS中，IAM允许您创建和管理用户、组、角色和权限策略。在多账户环境中，您应该：</p><ul><li><strong>创建IAM用户</strong>：为每个需要访问AWS服务的人员创建IAM用户。</li><li><strong>创建IAM组</strong>：根据用户的角色和职责，将用户分组，并将权限策略附加到组上。</li><li><strong>使用IAM角色跨账户访问</strong>：为需要在多个账户间进行操作的用户创建IAM角色。</li></ul><h5 id="实践步骤：-1"><a href="#实践步骤：-1" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在每个AWS账户中设置IAM用户和组。</li><li>定义IAM权限策略，明确用户和组可以执行的操作。</li><li>创建IAM角色以供跨账户访问，并定义信任关系以允许其他账户的用户扮演角色。</li></ol><h4 id="3-使用AWS-IAM-Identity-Center-SSO-："><a href="#3-使用AWS-IAM-Identity-Center-SSO-：" class="headerlink" title="3. 使用AWS IAM Identity Center (SSO)："></a>3. 使用AWS IAM Identity Center (SSO)：</h4><p>AWS IAM Identity Center (SSO)允许用户使用单一凭据登录到多个AWS账户和第三方应用程序。</p><h5 id="实践步骤：-2"><a href="#实践步骤：-2" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>设置AWS IAM Identity Center (SSO)。</li><li>配置身份源，例如Microsoft Active Directory。</li><li>设置SSO集成以连接到您的AWS账户。</li><li>为用户分配SSO访问权限，允许他们访问指定的账户和资源。</li></ol><h4 id="4-监控和审计："><a href="#4-监控和审计：" class="headerlink" title="4. 监控和审计："></a>4. 监控和审计：</h4><p>使用AWS CloudTrail和Amazon CloudWatch等服务来监控和记录所有账户的活动。</p><h5 id="实践步骤：-3"><a href="#实践步骤：-3" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在所有账户中启用AWS CloudTrail。</li><li>使用Amazon CloudWatch创建警报，监控关键活动和性能指标。</li><li>定期审计账户活动，确保遵守策略和最佳实践。</li></ol><h4 id="5-定期审查和优化："><a href="#5-定期审查和优化：" class="headerlink" title="5. 定期审查和优化："></a>5. 定期审查和优化：</h4><p>定期审查账户使用情况、权限策略和安全设置，以确保它们仍然适用于您的业务需求，并遵循最低权限原则。</p><h5 id="实践步骤：-4"><a href="#实践步骤：-4" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>使用IAM Access Advisor查看用户和角色的服务使用情况。</li><li>使用IAM Policy Simulator测试权限策略。</li><li>定期进行权限和安全设置的审计。</li></ol><h3 id="AWS-联合访问和身份服务（例如，AWS-Identity-and-Access-Management-IAM-、AWS-IAM-Identity-Center-AWS-Single-Sign-On-）"><a href="#AWS-联合访问和身份服务（例如，AWS-Identity-and-Access-Management-IAM-、AWS-IAM-Identity-Center-AWS-Single-Sign-On-）" class="headerlink" title="AWS 联合访问和身份服务（例如，AWS Identity and Access Management[IAM]、AWS IAM Identity Center [AWS Single Sign-On]）"></a>AWS 联合访问和身份服务（例如，AWS Identity and Access Management[IAM]、AWS IAM Identity Center [AWS Single Sign-On]）</h3><p>AWS提供了一系列服务来帮助您管理访问和身份验证，确保只有经过授权的用户才能访问您的资源。以下是对AWS联合访问和身份服务的详细指导，重点介绍AWS Identity and Access Management (IAM)和AWS IAM Identity Center（以前称为AWS Single Sign-On或AWS SSO）。</p><h4 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h4><p>IAM是AWS的核心服务之一，它允许您安全地控制对AWS服务和资源的访问。以下是如何使用IAM的步骤：</p><h5 id="1-创建IAM用户和组"><a href="#1-创建IAM用户和组" class="headerlink" title="1. 创建IAM用户和组"></a>1. 创建IAM用户和组</h5><ul><li><strong>IAM用户</strong>：代表个人或服务的身份，可以是一个人或一个系统/应用程序。</li><li><strong>IAM组</strong>：是一组IAM用户，可以让您更容易地管理多个用户的权限。</li></ul><h5 id="实践步骤：-5"><a href="#实践步骤：-5" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>登录到AWS管理控制台。</li><li>导航到IAM控制台。</li><li>创建新用户：<ul><li>选择“用户”然后点击“添加用户”。</li><li>输入用户名，选择“程序访问”和/或“AWS管理控制台访问”。</li><li>设置密码和密码策略（如果选择了控制台访问）。</li></ul></li><li>创建新组：<ul><li>选择“用户组”然后点击“创建新组”。</li><li>输入组名，选择适当的权限策略。</li><li>将用户添加到组。</li></ul></li></ol><h5 id="2-创建和管理访问密钥"><a href="#2-创建和管理访问密钥" class="headerlink" title="2. 创建和管理访问密钥"></a>2. 创建和管理访问密钥</h5><ul><li>对于需要通过API、CLI或SDK访问AWS服务的用户，您需要创建访问密钥。</li></ul><h4 id="实践步骤：-6"><a href="#实践步骤：-6" class="headerlink" title="实践步骤："></a>实践步骤：</h4><ol><li>在IAM用户的“安全凭证”选项卡下创建新的访问密钥。</li><li>安全地保存访问密钥ID和秘密访问密钥。</li></ol><h5 id="3-使用IAM角色和策略"><a href="#3-使用IAM角色和策略" class="headerlink" title="3. 使用IAM角色和策略"></a>3. 使用IAM角色和策略</h5><ul><li><strong>IAM角色</strong>：是一种权限集合，可以被分配给任何一个用户、服务或其他角色。</li><li><strong>IAM策略</strong>：定义了具体的权限，描述了可以对哪些资源执行哪些操作。</li></ul><h5 id="实践步骤：-7"><a href="#实践步骤：-7" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>创建新角色并选择信任关系（例如，EC2、Lambda等）。</li><li>附加策略到角色以定义权限。</li><li>将角色分配给AWS资源或服务。</li></ol><h4 id="4-使用条件和细粒度的权限控制"><a href="#4-使用条件和细粒度的权限控制" class="headerlink" title="4. 使用条件和细粒度的权限控制"></a>4. 使用条件和细粒度的权限控制</h4><ul><li>通过使用条件和细粒度的权限控制，您可以定义更精确的访问规则。</li></ul><h5 id="实践步骤：-8"><a href="#实践步骤：-8" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在IAM策略中定义条件。</li><li>使用策略模拟器测试策略。</li></ol><h4 id="AWS-IAM-Identity-Center-AWS-SSO"><a href="#AWS-IAM-Identity-Center-AWS-SSO" class="headerlink" title="AWS IAM Identity Center (AWS SSO)"></a>AWS IAM Identity Center (AWS SSO)</h4><p>AWS IAM Identity Center允许您中心化管理用户对多个AWS账户和业务应用程序的访问。以下是如何使用AWS IAM Identity Center的步骤：</p><h5 id="1-设置AWS-IAM-Identity-Center"><a href="#1-设置AWS-IAM-Identity-Center" class="headerlink" title="1. 设置AWS IAM Identity Center"></a>1. 设置AWS IAM Identity Center</h5><ul><li>通过AWS IAM Identity Center，您可以连接到现有的身份源，如Microsoft Active Directory，或者使用AWS SSO内置的身份存储。</li></ul><h5 id="实践步骤：-9"><a href="#实践步骤：-9" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>打开AWS IAM Identity Center控制台。</li><li>配置您的身份源。</li><li>启用AWS SSO。</li></ol><h5 id="2-配置AWS账户和应用程序"><a href="#2-配置AWS账户和应用程序" class="headerlink" title="2. 配置AWS账户和应用程序"></a>2. 配置AWS账户和应用程序</h5><ul><li>将AWS账户集成到AWS IAM Identity Center，并配置任何内部或第三方应用程序以使用AWS SSO。</li></ul><h5 id="实践步骤：-10"><a href="#实践步骤：-10" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在AWS IAM Identity Center控制台中，选择“AWS组织”来管理账户访问。</li><li>为每个账户分配用户或组。</li><li>配置单个应用程序访问。</li></ol><h5 id="3-分配用户权限"><a href="#3-分配用户权限" class="headerlink" title="3. 分配用户权限"></a>3. 分配用户权限</h5><ul><li>为用户分配在AWS账户和应用程序中的权限。</li></ul><h5 id="实践步骤：-11"><a href="#实践步骤：-11" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在AWS IAM Identity Center中，选择“用户”或“组”。</li><li>分配访问权限到AWS账户或应用程序。</li></ol><h5 id="4-用户登录和访问管理"><a href="#4-用户登录和访问管理" class="headerlink" title="4. 用户登录和访问管理"></a>4. 用户登录和访问管理</h5><ul><li>用户可以使用单一登录访问他们有权访问的AWS账户和应用程序。</li></ul><h5 id="实践步骤：-12"><a href="#实践步骤：-12" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>用户访问AWS IAM Identity Center的用户门户。</li><li>用户使用他们的单一凭证登录。</li><li>用户选择他们有权访问的账户或应用程序。</li></ol><h3 id="AWS-全球基础设施（例如，可用区、AWS-区域）"><a href="#AWS-全球基础设施（例如，可用区、AWS-区域）" class="headerlink" title="AWS 全球基础设施（例如，可用区、AWS 区域）"></a>AWS 全球基础设施（例如，可用区、AWS 区域）</h3><h4 id="AWS-全球基础设施概述"><a href="#AWS-全球基础设施概述" class="headerlink" title="AWS 全球基础设施概述"></a>AWS 全球基础设施概述</h4><p>AWS 全球基础设施是由数据中心组成的广泛网络，这些数据中心分布在世界各地的多个地理区域中。这个基础设施支持运行亚马逊网络服务（Amazon Web Services，简称AWS）的所有服务，为用户提供了高可用性、高可靠性和高扩展性的云计算资源。</p><h4 id="AWS-区域"><a href="#AWS-区域" class="headerlink" title="AWS 区域"></a>AWS 区域</h4><p>AWS 区域是物理位置的集合，每个区域都包含多个独立的可用区。每个AWS区域都是一个独立的地理区域，比如美国东部（北弗吉尼亚）、欧洲（爱尔兰）、亚太（孟买）等。</p><h5 id="设计原则和优势"><a href="#设计原则和优势" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>隔离性</strong>：每个区域都是独立运行的，故障不会传播到其他区域。</li><li><strong>低延迟</strong>：用户可以选择离他们的客户或用户最近的区域，以减少延迟。</li><li><strong>合规性</strong>：用户可以选择将数据存储在特定的法律或合规性要求的区域。</li></ul><h5 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>登录AWS管理控制台。</li><li>在控制台顶部，选择您希望部署资源的区域。</li><li>部署AWS服务（例如EC2实例、S3存储桶等）时，确保您在正确的区域操作。</li></ol><h4 id="AWS-可用区"><a href="#AWS-可用区" class="headerlink" title="AWS 可用区"></a>AWS 可用区</h4><p>AWS 可用区是指在单个区域内的一个或多个离散的数据中心，每个数据中心都有独立的电源、冷却和网络连接，以降低单点故障的风险。</p><h5 id="设计原则和优势-1"><a href="#设计原则和优势-1" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>高可用性</strong>：通过在多个可用区中部署应用程序和数据，可以提高容错能力和业务持续性。</li><li><strong>独立性</strong>：每个可用区都设计为与其他可用区隔离，即使在极端情况下也能保持运行。</li></ul><h5 id="实践步骤-1"><a href="#实践步骤-1" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设计应用程序架构时，确保使用多个可用区以实现高可用性。</li><li>在创建资源（如EC2实例）时，选择多个可用区进行部署。</li><li>配置负载均衡器和数据库服务以跨多个可用区分布。</li></ol><h4 id="AWS-边缘位置"><a href="#AWS-边缘位置" class="headerlink" title="AWS 边缘位置"></a>AWS 边缘位置</h4><p>AWS 边缘位置是位于世界各地的站点，用于缓存数据，从而减少对用户的响应时间。这些边缘位置是由Amazon CloudFront（AWS的内容分发网络服务）和AWS Lambda@Edge使用的。</p><h5 id="设计原则和优势-2"><a href="#设计原则和优势-2" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>性能优化</strong>：边缘位置可以减少数据传输的延迟，加快内容的交付速度。</li><li><strong>可扩展性</strong>：AWS的全球网络可以轻松处理大量请求，满足不断增长的需求。</li></ul><h5 id="实践步骤-2"><a href="#实践步骤-2" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>通过Amazon CloudFront创建分发，选择一个或多个原始位置。</li><li>为常用内容配置缓存行为和TTL（生存时间）设置。</li><li>使用Lambda@Edge来运行自定义代码，它会响应CloudFront事件。</li></ol><h4 id="结合使用区域和可用区"><a href="#结合使用区域和可用区" class="headerlink" title="结合使用区域和可用区"></a>结合使用区域和可用区</h4><p>在AWS中，最佳实践是结合使用区域和可用区来设计和部署应用程序和服务。这样可以优化性能，同时确保业务连续性和灾难恢复。</p><h5 id="实践步骤-3"><a href="#实践步骤-3" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>根据用户群体选择合适的区域部署服务。</li><li>在该区域的多个可用区中创建和配置资源，以实现高可用性。</li><li>使用AWS服务，如Amazon RDS和Amazon EC2 Auto Scaling，跨多个可用区自动管理资源。</li></ol><h3 id="AWS-安全最佳实践（例如，最低权限原则）"><a href="#AWS-安全最佳实践（例如，最低权限原则）" class="headerlink" title="AWS 安全最佳实践（例如，最低权限原则）"></a>AWS 安全最佳实践（例如，最低权限原则）</h3><h4 id="AWS-安全最佳实践概述"><a href="#AWS-安全最佳实践概述" class="headerlink" title="AWS 安全最佳实践概述"></a>AWS 安全最佳实践概述</h4><p>在使用AWS时，遵循安全最佳实践是至关重要的，因为它有助于保护您的云资源免受未经授权的访问和潜在的安全威胁。AWS提供了强大的工具和服务来帮助用户实现这些最佳实践。</p><h4 id="遵循最低权限原则"><a href="#遵循最低权限原则" class="headerlink" title="遵循最低权限原则"></a>遵循最低权限原则</h4><p>最低权限原则是指仅授予必要的权限，以执行特定任务的最小权限集。在AWS中，这通常涉及IAM（Identity and Access Management）的精细权限管理。</p><h5 id="设计原则和优势-3"><a href="#设计原则和优势-3" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>风险降低</strong>：限制权限可以减少安全风险和潜在的数据泄露。</li><li><strong>易于管理</strong>：精确的权限使得权限管理更加清晰和容易维护。</li></ul><h5 id="实践步骤-4"><a href="#实践步骤-4" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个IAM用户创建唯一的身份，而不是共享凭证。</li><li>为每个用户分配最小的必要权限，以完成其工作。</li><li>使用IAM策略来精细控制访问权限。</li><li>定期审查和调整权限，确保它们仍然符合需要。</li></ol><h4 id="使用IAM角色和策略"><a href="#使用IAM角色和策略" class="headerlink" title="使用IAM角色和策略"></a>使用IAM角色和策略</h4><p>IAM角色允许您在不共享安全凭证的情况下，将权限委托给用户、应用程序或服务。</p><h5 id="设计原则和优势-4"><a href="#设计原则和优势-4" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>安全性</strong>：角色不需要永久性凭证，使用时会临时提供安全令牌。</li><li><strong>灵活性</strong>：可以轻松地向用户或服务分配和撤销角色。</li></ul><h5 id="实践步骤-5"><a href="#实践步骤-5" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建IAM角色并定义其权限策略。</li><li>将角色分配给需要特定权限的AWS服务或用户。</li><li>当任务完成或角色不再需要时，撤销对该角色的访问权限。</li></ol><h4 id="保护数据"><a href="#保护数据" class="headerlink" title="保护数据"></a>保护数据</h4><p>在AWS中，保护存储和传输中的数据是保证安全的关键组成部分。</p><h5 id="设计原则和优势-5"><a href="#设计原则和优势-5" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>数据加密</strong>：确保数据在传输和静态时都是加密的。</li><li><strong>数据备份</strong>：定期备份数据以防止丢失或损坏。</li></ul><h5 id="实践步骤-6"><a href="#实践步骤-6" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS服务（如S3、EBS、RDS）时，启用加密功能。</li><li>对敏感数据实施端到端加密。</li><li>定期备份数据，并测试恢复过程。</li></ol><h4 id="监控和日志记录"><a href="#监控和日志记录" class="headerlink" title="监控和日志记录"></a>监控和日志记录</h4><p>使用AWS提供的监控和日志记录工具可以帮助您检测和响应安全事件。</p><h5 id="设计原则和优势-6"><a href="#设计原则和优势-6" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>可见性</strong>：日志提供了对环境中发生的活动的洞察。</li><li><strong>审计</strong>：监控和日志记录有助于满足合规性要求。</li></ul><h5 id="实践步骤-7"><a href="#实践步骤-7" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS CloudTrail来记录用户活动和API使用情况。</li><li>配置Amazon CloudWatch来监控资源和应用程序。</li><li>定期审查日志文件，并设置警报以监控可疑活动。</li></ol><h4 id="定期审计和合规性检查"><a href="#定期审计和合规性检查" class="headerlink" title="定期审计和合规性检查"></a>定期审计和合规性检查</h4><p>定期进行安全审计和合规性检查，以确保持续遵守安全最佳实践。</p><h5 id="设计原则和优势-7"><a href="#设计原则和优势-7" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>持续改进</strong>：审计有助于识别和修复潜在的安全问题。</li><li><strong>合规性</strong>：检查有助于确保符合法律和行业标准。</li></ul><h5 id="实践步骤-8"><a href="#实践步骤-8" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Config来跟踪资源配置的变化和合规性。</li><li>利用AWS Trusted Advisor来获取安全优化建议。</li><li>定期进行安全评估，如使用AWS Inspector。</li></ol><h3 id="AWS-责任共担模式"><a href="#AWS-责任共担模式" class="headerlink" title="AWS 责任共担模式"></a>AWS 责任共担模式</h3><h4 id="AWS-责任共担模式概述"><a href="#AWS-责任共担模式概述" class="headerlink" title="AWS 责任共担模式概述"></a>AWS 责任共担模式概述</h4><p>AWS 责任共担模式是一个安全和合规性框架，其中AWS和客户共同承担确保云环境安全的责任。在这个模型中，AWS负责保护云计算基础设施的安全，而客户则负责在AWS云中运行的内容、平台、应用程序和数据的安全。</p><h4 id="AWS-的责任"><a href="#AWS-的责任" class="headerlink" title="AWS 的责任"></a>AWS 的责任</h4><p>在责任共担模式中，AWS负责“云的安全”，这涉及到保护其基础设施的安全，包括硬件、软件、网络和设施。</p><h5 id="设计原则和优势-8"><a href="#设计原则和优势-8" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>基础设施安全</strong>：AWS负责保护全球数据中心的物理安全。</li><li><strong>服务安全</strong>：AWS负责其服务的底层软件和硬件的安全性。</li></ul><h5 id="实践步骤-9"><a href="#实践步骤-9" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>AWS定期维护其数据中心的物理安全措施。</li><li>AWS管理云服务的底层操作系统和虚拟化层。</li><li>AWS实施网络基础设施的安全性和弹性。</li></ol><h4 id="客户的责任"><a href="#客户的责任" class="headerlink" title="客户的责任"></a>客户的责任</h4><p>客户负责“云中的安全”，这包括客户设置和管理的数据、应用程序以及其他资源的安全性。</p><h5 id="设计原则和优势-9"><a href="#设计原则和优势-9" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>数据保护</strong>：客户负责管理自己的数据加密和访问控制。</li><li><strong>身份管理</strong>：客户负责使用IAM工具管理用户访问权限。</li><li><strong>操作安全</strong>：客户负责操作系统、网络配置和应用程序的安全性。</li></ul><h5 id="实践步骤-10"><a href="#实践步骤-10" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>客户应加密敏感数据，并管理加密密钥。</li><li>客户应配置IAM策略，实施最低权限原则。</li><li>客户应定期更新和打补丁自己的应用程序和操作系统。</li></ol><h4 id="共同责任的例子"><a href="#共同责任的例子" class="headerlink" title="共同责任的例子"></a>共同责任的例子</h4><p>在责任共担模式下，某些安全责任是由AWS和客户共同承担的。</p><h5 id="设计原则和优势-10"><a href="#设计原则和优势-10" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>合作防御</strong>：通过AWS和客户的共同努力，可以建立更强大的安全防线。</li><li><strong>明确职责</strong>：清晰地划分责任有助于避免安全漏洞和责任模糊。</li></ul><h5 id="实践步骤-11"><a href="#实践步骤-11" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>AWS提供网络防火墙和DDoS保护服务，客户负责配置这些服务。</li><li>AWS提供身份和访问管理服务，客户负责使用这些服务来控制对资源的访问。</li><li>AWS提供日志服务，客户负责监控和分析日志数据。</li></ol><h4 id="理解责任共担模式的重要性"><a href="#理解责任共担模式的重要性" class="headerlink" title="理解责任共担模式的重要性"></a>理解责任共担模式的重要性</h4><p>理解并执行责任共担模式对于在AWS上运营的任何组织都是至关重要的，因为它有助于确保整个IT环境的安全性。</p><h5 id="设计原则和优势-11"><a href="#设计原则和优势-11" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>安全合作</strong>：确保所有安全层面都得到适当的关注和资源。</li><li><strong>风险管理</strong>：帮助组织更好地理解和管理其在云中的风险。</li></ul><h5 id="实践步骤-12"><a href="#实践步骤-12" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>客户应该了解和评估其在云中的责任。</li><li>客户应该实施必要的策略和控制措施来管理其资源。</li><li>客户应该定期进行安全评估和合规性审查。</li></ol><h3 id="将AWS安全最佳实践应用于IAM用户和根用户"><a href="#将AWS安全最佳实践应用于IAM用户和根用户" class="headerlink" title="将AWS安全最佳实践应用于IAM用户和根用户"></a>将AWS安全最佳实践应用于IAM用户和根用户</h3><ol><li><p><strong>为根用户和IAM用户启用多重验证（MFA）</strong>：</p><ul><li>根用户：AWS账户的根用户拥有完全的访问权限，因此保护它至关重要。应启用MFA，以添加一层额外的安全性。</li><li>IAM用户：对于具有重要权限的IAM用户，也应启用MFA。这可以减少因密码泄露导致的安全风险。</li></ul></li><li><p><strong>最小权限原则</strong>：</p><ul><li>仅授予必要的权限。每个IAM用户和角色都应只拥有完成其任务所需的最少权限。</li></ul></li><li><p><strong>定期审核和更新权限</strong>：</p><ul><li>定期审查IAM用户和根用户的权限，确保它们仍符合当前的业务需求。</li></ul></li><li><p><strong>使用强密码策略</strong>：</p><ul><li>为IAM用户实施强密码策略，包括密码复杂度、更换频率和历史密码的限制。</li></ul></li></ol><h3 id="设计包含IAM用户、组、角色和策略的灵活授权模型"><a href="#设计包含IAM用户、组、角色和策略的灵活授权模型" class="headerlink" title="设计包含IAM用户、组、角色和策略的灵活授权模型"></a>设计包含IAM用户、组、角色和策略的灵活授权模型</h3><ol><li><p><strong>使用IAM组管理用户权限</strong>：</p><ul><li>将具有相似权限需求的IAM用户组合到组中，这样可以更容易地管理它们的权限。</li></ul></li><li><p><strong>创建和管理IAM策略</strong>：</p><ul><li>使用IAM策略精确控制用户、组和角色的权限。可以使用AWS管理的策略或创建自定义策略。</li></ul></li><li><p><strong>利用条件语句提高安全性</strong>：</p><ul><li>在IAM策略中使用条件语句，根据需求对权限进行细粒度控制，如基于IP地址限制访问。</li></ul></li></ol><h3 id="设计基于角色的访问控制策略"><a href="#设计基于角色的访问控制策略" class="headerlink" title="设计基于角色的访问控制策略"></a>设计基于角色的访问控制策略</h3><ol><li><p><strong>使用AWS Security Token Service (AWS STS) 临时凭证</strong>：</p><ul><li>使用AWS STS生成临时安全凭证，使用户可以在有限的时间内访问AWS资源，这提高了安全性并降低了长期凭证泄露的风险。</li></ul></li><li><p><strong>角色切换</strong>：</p><ul><li>允许用户切换到具有不同权限的IAM角色，这样可以避免创建具有广泛权限的单个用户。</li></ul></li><li><p><strong>跨账户访问</strong>：</p><ul><li>通过创建IAM角色并定义信任关系，允许从一个AWS账户访问另一个账户中的资源。</li></ul></li></ol><h3 id="为多个AWS账户设计安全策略"><a href="#为多个AWS账户设计安全策略" class="headerlink" title="为多个AWS账户设计安全策略"></a>为多个AWS账户设计安全策略</h3><ol><li><p><strong>使用AWS Control Tower</strong>：</p><ul><li>AWS Control Tower提供了一种简单的方法来设置和管理多个AWS账户的安全性和合规性。</li></ul></li><li><p><strong>服务控制策略（SCP）</strong>：</p><ul><li>SCPs用于管理AWS组织中的账户权限。它们可以限制账户中可以执行的操作，从而提高整体安全性。</li></ul></li></ol><h3 id="确定AWS服务的资源策略的正确用法"><a href="#确定AWS服务的资源策略的正确用法" class="headerlink" title="确定AWS服务的资源策略的正确用法"></a>确定AWS服务的资源策略的正确用法</h3><ol><li><p><strong>利用资源策略控制访问</strong>：</p><ul><li>资源策略（如S3桶策略、Lambda函数策略）允许定义哪些实体可以执行哪些操作。</li></ul></li><li><p><strong>与IAM策略结合使用</strong>：</p><ul><li>结合使用IAM和资源策略，以实现更精细的访问控制。</li></ul></li></ol><h3 id="确定何时将Directory-Service与IAM角色联合"><a href="#确定何时将Directory-Service与IAM角色联合" class="headerlink" title="确定何时将Directory Service与IAM角色联合"></a>确定何时将Directory Service与IAM角色联合</h3><ol><li><p><strong>联合身份管理</strong>：</p><ul><li>当需要与企业目录服务（如Active Directory）集成时，可以使用联合身份管理。这允许企业用户使用其现有的身份凭证来访问AWS资源。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>当企业需要将其用户身份管理集中在现有的目录服务中时，或者需要对</li></ul></li></ol><p>访问AWS服务的用户进行详细审计时，应考虑使用联合身份管理。</p><p>以上是应用AWS安全最佳实践的一些关键方面。通过合理的设计和持续的管理，可以显著提高AWS环境的安全性。</p><h3 id="应用程序配置和凭证安全"><a href="#应用程序配置和凭证安全" class="headerlink" title="应用程序配置和凭证安全"></a>应用程序配置和凭证安全</h3><h4 id="应用程序配置和凭证安全-1"><a href="#应用程序配置和凭证安全-1" class="headerlink" title="应用程序配置和凭证安全"></a>应用程序配置和凭证安全</h4><p>在现代云基础设施中，确保应用程序配置和凭证的安全是至关重要的。不当的凭证管理和配置错误是导致安全漏洞的常见原因。以下是一些关键的最佳实践，可以帮助确保应用程序配置和凭证的安全性。</p><h4 id="管理和保护凭证"><a href="#管理和保护凭证" class="headerlink" title="管理和保护凭证"></a>管理和保护凭证</h4><p>凭证，如密码、密钥和令牌，是访问资源的关键。不正确的管理可能导致安全风险。</p><h5 id="最佳实践原则"><a href="#最佳实践原则" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>集中管理</strong>：使用集中的身份管理系统来存储和管理凭证。</li><li><strong>定期轮换</strong>：定期更换凭证，以减少被泄露的风险。</li></ul><h5 id="实践步骤-13"><a href="#实践步骤-13" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Secrets Manager或类似服务存储敏感凭证。</li><li>定期自动更换数据库和服务的密码。</li><li>实施凭证轮换策略，确保旧凭证在一定时间后失效。</li></ol><h4 id="使用环境变量存储配置"><a href="#使用环境变量存储配置" class="headerlink" title="使用环境变量存储配置"></a>使用环境变量存储配置</h4><p>将应用程序配置存储在环境变量中，而不是硬编码在应用程序代码中，可以提高灵活性和安全性。</p><h5 id="最佳实践原则-1"><a href="#最佳实践原则-1" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>分离配置</strong>：将配置与代码分离，使之可以在不同环境中重复使用。</li><li><strong>避免硬编码</strong>：不要在代码中硬编码敏感信息。</li></ul><h5 id="实践步骤-14"><a href="#实践步骤-14" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序的启动脚本中设置环境变量。</li><li>使用AWS Elastic Beanstalk、AWS Lambda或其他服务的配置选项来管理环境变量。</li><li>确保不在源代码仓库中暴露环境变量的值。</li></ol><h4 id="实施应用层加密"><a href="#实施应用层加密" class="headerlink" title="实施应用层加密"></a>实施应用层加密</h4><p>对敏感数据进行应用层加密可以保护数据，即使在传输过程中或在数据存储时被截获也能保持其安全性。</p><h5 id="最佳实践原则-2"><a href="#最佳实践原则-2" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>端到端加密</strong>：加密数据传输和存储过程中的所有敏感信息。</li><li><strong>使用强加密标准</strong>：使用行业标准的加密算法和协议。</li></ul><h5 id="实践步骤-15"><a href="#实践步骤-15" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用TLS/SSL协议加密数据在传输中的敏感信息。</li><li>在数据库或存储层加密敏感数据。</li><li>使用AWS KMS或类似服务管理加密密钥。</li></ol><h4 id="定期审计和监控"><a href="#定期审计和监控" class="headerlink" title="定期审计和监控"></a>定期审计和监控</h4><p>通过定期审计和监控，可以发现潜在的安全问题，并确保凭证和配置的安全性。</p><h5 id="最佳实践原则-3"><a href="#最佳实践原则-3" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>持续监控</strong>：实时监控配置和凭证的使用情况。</li><li><strong>定期审计</strong>：定期审查配置和凭证的安全性。</li></ul><h5 id="实践步骤-16"><a href="#实践步骤-16" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>利用AWS CloudTrail监控对敏感凭证的访问。</li><li>定期检查IAM权限和凭证的使用情况。</li><li>使用自动化工具检测配置的不一致性和潜在的安全问题。</li></ol><h4 id="敏感数据的访问控制"><a href="#敏感数据的访问控制" class="headerlink" title="敏感数据的访问控制"></a>敏感数据的访问控制</h4><p>确保只有授权用户和系统能够访问敏感数据。</p><h5 id="最佳实践原则-4"><a href="#最佳实践原则-4" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>最小权限</strong>：遵循最小权限原则，仅授予必要的访问权限。</li><li><strong>细粒度控制</strong>：实施细粒度的访问控制策略。</li></ul><h5 id="实践步骤-17"><a href="#实践步骤-17" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用IAM角色和策略来限制对敏感数据的访问。</li><li>在数据库和文件存储级别实现访问控制。</li><li>审查和更新访问权限，以反映组织变化或人员变动。</li></ol><h3 id="AWS-服务终端节点"><a href="#AWS-服务终端节点" class="headerlink" title="AWS 服务终端节点"></a>AWS 服务终端节点</h3><h4 id="AWS-服务终端节点（VPC-Endpoints）"><a href="#AWS-服务终端节点（VPC-Endpoints）" class="headerlink" title="AWS 服务终端节点（VPC Endpoints）"></a>AWS 服务终端节点（VPC Endpoints）</h4><p>AWS服务终端节点允许你在Amazon Virtual Private Cloud (VPC)内部安全地连接到AWS服务，而无需通过公共互联网。这样可以减少数据被截获的风险，并可能提高连接速度。</p><h4 id="理解服务终端节点"><a href="#理解服务终端节点" class="headerlink" title="理解服务终端节点"></a>理解服务终端节点</h4><p>服务终端节点是AWS为了提高网络安全和效率而设计的一种机制，它们与传统的通过公网访问AWS服务的方式不同。</p><h5 id="最佳实践原则-5"><a href="#最佳实践原则-5" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：通过私有网络访问AWS服务，减少对公共互联网的依赖。</li><li><strong>性能</strong>：可能提高访问速度，因为数据不必离开Amazon网络。</li></ul><h5 id="实践步骤-18"><a href="#实践步骤-18" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在VPC控制台中创建终端节点。</li><li>选择你需要连接的AWS服务（例如S3或DynamoDB）。</li><li>指定VPC和子网，以及要关联的路由表。</li><li>设置安全组，以控制流向服务的流量。</li></ol><h4 id="配置服务终端节点"><a href="#配置服务终端节点" class="headerlink" title="配置服务终端节点"></a>配置服务终端节点</h4><p>配置服务终端节点时，需要确定哪些资源需要通过终端节点进行通信，并相应地配置网络。</p><h5 id="最佳实践原则-6"><a href="#最佳实践原则-6" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>精确配置</strong>：确保仅允许必要的流量通过终端节点。</li><li><strong>细粒度访问控制</strong>：使用IAM策略来控制对服务的访问。</li></ul><h5 id="实践步骤-19"><a href="#实践步骤-19" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为需要访问AWS服务的资源创建终端节点。</li><li>配置路由表，以确保流量定向到终端节点。</li><li>设定安全组规则，限制通过终端节点的流量类型。</li><li>如果可能，使用IAM策略进一步限制对服务的访问。</li></ol><h4 id="监控服务终端节点"><a href="#监控服务终端节点" class="headerlink" title="监控服务终端节点"></a>监控服务终端节点</h4><p>监控是确保服务终端节点安全和高效运行的关键环节。AWS提供了多种工具来帮助监控这些终端节点。</p><h5 id="最佳实践原则-7"><a href="#最佳实践原则-7" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>可见性</strong>：确保你可以监控和记录通过终端节点的所有流量。</li><li><strong>报告</strong>：定期查看终端节点的性能和安全性报告。</li></ul><h5 id="实践步骤-20"><a href="#实践步骤-20" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用VPC流日志来捕获有关网络流量的信息。</li><li>利用AWS CloudWatch监控终端节点的性能指标。</li><li>定期审查安全日志，以检测异常或未授权的访问尝试。</li></ol><h4 id="故障排除服务终端节点"><a href="#故障排除服务终端节点" class="headerlink" title="故障排除服务终端节点"></a>故障排除服务终端节点</h4><p>当服务终端节点出现问题时，需要能够快速诊断和解决问题。</p><h5 id="最佳实践原则-8"><a href="#最佳实践原则-8" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>响应性</strong>：迅速识别和响应终端节点的问题。</li><li><strong>详细日志</strong>：保持详细的日志记录，以便于故障排除。</li></ul><h5 id="实践步骤-21"><a href="#实践步骤-21" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>验证路由表和网络ACLs配置是否正确。</li><li>检查安全组规则，确保它们没有阻止预期的流量。</li><li>查看VPC流日志和CloudWatch指标，寻找任何异常。</li><li>如果使用了IAM策略，确认策略允许预期的访问。</li></ol><h3 id="控制-AWS-上的端口、协议和网络流量"><a href="#控制-AWS-上的端口、协议和网络流量" class="headerlink" title="控制 AWS 上的端口、协议和网络流量"></a>控制 AWS 上的端口、协议和网络流量</h3><h4 id="控制-AWS-上的端口、协议和网络流量-1"><a href="#控制-AWS-上的端口、协议和网络流量-1" class="headerlink" title="控制 AWS 上的端口、协议和网络流量"></a>控制 AWS 上的端口、协议和网络流量</h4><p>在AWS中，对端口、协议和网络流量的控制是通过网络访问控制列表（Network Access Control Lists, NACLs）、安全组（Security Groups）和路由表来实现的。这些工具共同作用于AWS的虚拟私有云（VPC）中，确保了网络流量的安全和合规。</p><h4 id="理解端口和协议"><a href="#理解端口和协议" class="headerlink" title="理解端口和协议"></a>理解端口和协议</h4><p>在网络通信中，端口和协议是数据传输的基础。端口是网络连接的逻辑端点，而协议则定义了数据如何在网络中传输。</p><h5 id="最佳实践原则-9"><a href="#最佳实践原则-9" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>明确定义</strong>：清晰定义哪些端口和协议对业务是必需的。</li><li><strong>最小暴露</strong>：仅开放必要的端口和协议，以减少潜在的攻击面。</li></ul><h5 id="实践步骤-22"><a href="#实践步骤-22" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>识别应用程序和服务所需的端口和协议。</li><li>确定哪些端口需要对外开放，哪些可以仅在内部网络中访问。</li><li>规划公共和私有子网中的资源布局，以控制端口和协议的暴露。</li></ol><h4 id="使用安全组控制访问"><a href="#使用安全组控制访问" class="headerlink" title="使用安全组控制访问"></a>使用安全组控制访问</h4><p>安全组是AWS中控制实例访问的主要工具。它们允许或拒绝到达实例的流量，并且是状态性的，这意味着返回流量自动允许。</p><h5 id="最佳实践原则-10"><a href="#最佳实践原则-10" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>实例级别保护</strong>：为每个实例配置安全组，以提供精细的访问控制。</li><li><strong>默认拒绝所有</strong>：默认情况下拒绝所有入站流量，仅按需开放。</li></ul><h5 id="实践步骤-23"><a href="#实践步骤-23" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建安全组并定义入站和出站规则。</li><li>为每个服务和应用程序配置专用的安全组。</li><li>定期审查和更新安全组规则，以保持最新的安全状态。</li></ol><h4 id="利用-NACLs-控制子网流量"><a href="#利用-NACLs-控制子网流量" class="headerlink" title="利用 NACLs 控制子网流量"></a>利用 NACLs 控制子网流量</h4><p>NACLs提供了一种在子网级别控制流量的方法。与安全组不同，NACLs是无状态的，需要为入站和出站流量分别定义规则。</p><h5 id="最佳实践原则-11"><a href="#最佳实践原则-11" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>子网级别保护</strong>：使用NACLs为整个子网提供一层额外的安全。</li><li><strong>明确规则</strong>：明确地定义允许和拒绝的规则，以防止未授权的访问。</li></ul><h5 id="实践步骤-24"><a href="#实践步骤-24" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个子网创建NACL。</li><li>配置入站和出站规则，以控制流量。</li><li>定期检查和维护NACL规则，确保它们符合当前的安全策略。</li></ol><h4 id="管理路由表"><a href="#管理路由表" class="headerlink" title="管理路由表"></a>管理路由表</h4><p>路由表决定了网络包在VPC内以及VPC外的目的地。通过管理路由表，可以控制网络流量的方向。</p><h5 id="最佳实践原则-12"><a href="#最佳实践原则-12" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>明确路由</strong>：确保路由表中的路由清晰，且正确地反映了网络设计。</li><li><strong>安全路由</strong>：避免创建可能导致数据泄露的不安全路由。</li></ul><h5 id="实践步骤-25"><a href="#实践步骤-25" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为VPC和每个子网创建和配置路由表。</li><li>确保路由表中的条目正确地指向网络流量的预期目的地。</li><li>定期审查路由表，确保它们没有过时的或不必要的路由。</li></ol><h4 id="监控和审计网络流量"><a href="#监控和审计网络流量" class="headerlink" title="监控和审计网络流量"></a>监控和审计网络流量</h4><p>要确保网络安全，需要对网络流量进行持续的监控和审计。</p><h5 id="最佳实践原则-13"><a href="#最佳实践原则-13" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>持续监控</strong>：实时监控网络流量，以便快速发现异常。</li><li><strong>审计日志</strong>：保留审计日志，以便在需要时回溯和分析。</li></ul><h5 id="实践步骤-26"><a href="#实践步骤-26" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS CloudTrail和VPC流日志进行网络流量监控。</li><li>定期审查日志文件，寻找异常或不符合策略的流量模式。</li><li>利用AWS服务和第三方工具自动化异常检测和报警。</li></ol><h3 id="安全应用程序访问"><a href="#安全应用程序访问" class="headerlink" title="安全应用程序访问"></a>安全应用程序访问</h3><h4 id="安全应用程序访问-1"><a href="#安全应用程序访问-1" class="headerlink" title="安全应用程序访问"></a>安全应用程序访问</h4><p>在云环境中，安全地控制对应用程序的访问是至关重要的。这涉及到确保只有授权用户能够访问应用程序，并且应用程序的数据传输是安全的。以下是如何在AWS环境中实现安全应用程序访问的指导。</p><h4 id="实施身份和访问管理-IAM"><a href="#实施身份和访问管理-IAM" class="headerlink" title="实施身份和访问管理 (IAM)"></a>实施身份和访问管理 (IAM)</h4><p>AWS的身份和访问管理（IAM）允许你精确控制谁可以在AWS中做什么。它是保证应用程序访问安全的基础。</p><h5 id="最佳实践原则-14"><a href="#最佳实践原则-14" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>最小权限</strong>：确保用户和服务仅具有执行其任务所必需的权限。</li><li><strong>角色分离</strong>：为不同的任务和责任创建不同的角色。</li></ul><h5 id="实践步骤-27"><a href="#实践步骤-27" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个用户和应用程序创建IAM用户和角色。</li><li>为每个角色分配最小的权限集。</li><li>定期审计IAM策略和权限，确保它们仍然符合业务需求。</li></ol><h4 id="启用多因素认证-MFA"><a href="#启用多因素认证-MFA" class="headerlink" title="启用多因素认证 (MFA)"></a>启用多因素认证 (MFA)</h4><p>多因素认证（MFA）为AWS账户添加了一个额外的安全层，要求用户在登录时提供两个或更多的验证因素。</p><h5 id="最佳实践原则-15"><a href="#最佳实践原则-15" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>强制MFA</strong>：对所有用户，特别是具有高权限的用户，强制使用MFA。</li><li><strong>多样化认证方式</strong>：使用不同类型的认证因素，如密码、手机应用或硬件令牌。</li></ul><h5 id="实践步骤-28"><a href="#实践步骤-28" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在IAM设置中为用户启用MFA。</li><li>教育用户如何正确设置和使用MFA设备。</li><li>定期检查确保所有用户都启用了MFA。</li></ol><h4 id="配置网络安全"><a href="#配置网络安全" class="headerlink" title="配置网络安全"></a>配置网络安全</h4><p>网络安全设置是保护应用程序不受恶意访问的关键组成部分。</p><h5 id="最佳实践原则-16"><a href="#最佳实践原则-16" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全组和NACLs</strong>：正确配置安全组和NACLs来控制进出网络流量。</li><li><strong>私有链接</strong>：使用VPC私有链接确保内部应用程序之间的安全通信。</li></ul><h5 id="实践步骤-29"><a href="#实践步骤-29" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>根据需要创建和配置安全组和NACLs。</li><li>使用VPC Endpoints连接到AWS服务，避免流量经过公共互联网。</li><li>对于不应公开访问的内部应用程序，确保它们部署在私有子网中。</li></ol><h4 id="加密数据传输"><a href="#加密数据传输" class="headerlink" title="加密数据传输"></a>加密数据传输</h4><p>确保数据在传输过程中被加密，以防止数据在途中被截获或篡改。</p><h5 id="最佳实践原则-17"><a href="#最佳实践原则-17" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>强制TLS</strong>：对所有传入和传出的通信使用传输层安全性（TLS）加密。</li><li><strong>证书管理</strong>：使用AWS Certificate Manager或其他工具来管理和自动更新TLS证书。</li></ul><h5 id="实践步骤-30"><a href="#实践步骤-30" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>配置应用程序使用HTTPS进行所有通信。</li><li>使用AWS Certificate Manager为应用程序获取和管理SSL/TLS证书。</li><li>确保所有的API和服务端点都强制使用加密连接。</li></ol><h4 id="实施应用程序层防火墙"><a href="#实施应用程序层防火墙" class="headerlink" title="实施应用程序层防火墙"></a>实施应用程序层防火墙</h4><p>AWS Web Application Firewall (WAF) 可以帮助保护你的应用程序不受网络攻击。</p><h5 id="最佳实践原则-18"><a href="#最佳实践原则-18" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定制规则</strong>：根据应用程序的具体需求定制WAF规则。</li><li><strong>实时监控</strong>：监控应用程序的流量，并根据需要调整WAF规则。</li></ul><h5 id="实践步骤-31"><a href="#实践步骤-31" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序的入口点配置AWS WAF。</li><li>创建和实施包含SQL注入和跨站脚本保护的规则集。</li><li>定期审查和更新WAF规则，以应对新出现的威胁。</li></ol><h4 id="审计日志和持续监控"><a href="#审计日志和持续监控" class="headerlink" title="审计日志和持续监控"></a>审计日志和持续监控</h4><p>持续监控和记录审计日志是发现和响应安全事件的关键。</p><h5 id="最佳实践原则-19"><a href="#最佳实践原则-19" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>日志记录</strong>：启用AWS CloudTrail和其他日志服务来记录所有操作。</li><li><strong>监控系统</strong>：使用Amazon CloudWatch等工具实时监控系统性能和安全事件。</li></ul><h5 id="实践步骤-32"><a href="#实践步骤-32" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>配置CloudTrail来记录所有AWS API调用。</li><li>使用CloudWatch来监控和报警异常行为。</li><li>利用AWS Lambda等服务自动化响应策略。</li></ol><h3 id="AWS-外部的威胁向量（例如，DDoS、SQL-注入）"><a href="#AWS-外部的威胁向量（例如，DDoS、SQL-注入）" class="headerlink" title="AWS 外部的威胁向量（例如，DDoS、SQL 注入）"></a>AWS 外部的威胁向量（例如，DDoS、SQL 注入）</h3><h4 id="AWS-外部威胁向量介绍"><a href="#AWS-外部威胁向量介绍" class="headerlink" title="AWS 外部威胁向量介绍"></a>AWS 外部威胁向量介绍</h4><p>在AWS环境中，外部威胁向量指的是那些源自互联网的攻击和风险，它们可能会对运行在AWS上的服务和数据造成损害。理解这些威胁向量及其防御措施对于确保AWS资源的安全至关重要。</p><h4 id="防御分布式拒绝服务-DDoS-攻击"><a href="#防御分布式拒绝服务-DDoS-攻击" class="headerlink" title="防御分布式拒绝服务(DDoS)攻击"></a>防御分布式拒绝服务(DDoS)攻击</h4><p>分布式拒绝服务(DDoS)攻击是一种常见的网络攻击，旨在通过超载目标的网络或服务器资源来使其不可用。</p><h5 id="最佳实践原则-20"><a href="#最佳实践原则-20" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>缓解和吸收</strong>：使用AWS Shield等服务来缓解和吸收DDoS攻击。</li><li><strong>弹性架构</strong>：设计弹性架构以分散流量和减轻攻击影响。</li></ul><h5 id="实践步骤-33"><a href="#实践步骤-33" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS Shield Standard或AWS Shield Advanced来提供自动化的DDoS防护。</li><li>利用Amazon CloudFront和Amazon Route 53来分散流量和提高可用性。</li><li>实施自动缩放策略，以便在流量激增时增加资源。</li></ol><h4 id="防护SQL注入攻击"><a href="#防护SQL注入攻击" class="headerlink" title="防护SQL注入攻击"></a>防护SQL注入攻击</h4><p>SQL注入攻击是一种代码注入技术，攻击者试图通过在应用程序的输入中注入恶意SQL语句来操纵后端数据库。</p><h5 id="最佳实践原则-21"><a href="#最佳实践原则-21" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>输入验证</strong>：对所有用户输入进行严格的验证。</li><li><strong>使用参数化查询</strong>：避免直接在SQL语句中拼接用户输入。</li></ul><h5 id="实践步骤-34"><a href="#实践步骤-34" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用预编译的SQL语句或数据库存储过程来避免注入风险。</li><li>在应用程序层面实现输入验证和清理措施。</li><li>对数据库访问权限进行最小化，限制数据库用户的权限。</li></ol><h4 id="防御跨站脚本-XSS-攻击"><a href="#防御跨站脚本-XSS-攻击" class="headerlink" title="防御跨站脚本(XSS)攻击"></a>防御跨站脚本(XSS)攻击</h4><p>跨站脚本(XSS)攻击允许攻击者在用户浏览器中执行恶意脚本，通常是通过注入未经过滤的用户输入到网页中。</p><h5 id="最佳实践原则-22"><a href="#最佳实践原则-22" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>内容安全策略</strong>：实施内容安全策略(CSP)来限制可以执行的脚本。</li><li><strong>输出编码</strong>：对所有用户生成的输出进行编码。</li></ul><h5 id="实践步骤-35"><a href="#实践步骤-35" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>对所有用户输入进行过滤和转义，尤其是在输出到HTML页面时。</li><li>实施CSP，并将其设置为只允许信任的脚本来源。</li><li>使用Web应用程序防火墙(WAF)来识别和阻止XSS攻击。</li></ol><h4 id="防御钓鱼攻击"><a href="#防御钓鱼攻击" class="headerlink" title="防御钓鱼攻击"></a>防御钓鱼攻击</h4><p>钓鱼攻击通常通过伪装成可信实体来诱骗用户提供敏感信息，如用户名、密码和信用卡详情。</p><h5 id="最佳实践原则-23"><a href="#最佳实践原则-23" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>用户教育</strong>：教育用户识别钓鱼邮件和链接。</li><li><strong>安全协议</strong>：使用HTTPS和电子邮件安全协议如SPF、DKIM和DMARC。</li></ul><h5 id="实践步骤-36"><a href="#实践步骤-36" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为所有网站和在线服务启用SSL/TLS加密。</li><li>教育员工关于钓鱼攻击的识别和响应方法。</li><li>配置SPF、DKIM和DMARC来验证发出的电子邮件并减少钓鱼邮件。</li></ol><h4 id="防御恶意软件和病毒"><a href="#防御恶意软件和病毒" class="headerlink" title="防御恶意软件和病毒"></a>防御恶意软件和病毒</h4><p>恶意软件和病毒可以通过多种途径感染AWS资源，包括通过电子邮件附件、下载链接或通过感染的设备。</p><h5 id="最佳实践原则-24"><a href="#最佳实践原则-24" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期扫描</strong>：定期进行恶意软件和病毒扫描。</li><li><strong>访问控制</strong>：限制对敏感系统的访问，仅限必要的服务和用户。</li></ul><h5 id="实践步骤-37"><a href="#实践步骤-37" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Marketplace中的安全解决方案来扫描和监控AWS环境。</li><li>实施强大的端点保护策略，包括反病毒软件和入侵检测系统。</li><li>定期更新操作系统和应用程序，以修补已知的安全漏洞。</li></ol><h3 id="设计带安全组件的VPC架构"><a href="#设计带安全组件的VPC架构" class="headerlink" title="设计带安全组件的VPC架构"></a>设计带安全组件的VPC架构</h3><h4 id="安全组和网络ACL"><a href="#安全组和网络ACL" class="headerlink" title="安全组和网络ACL"></a>安全组和网络ACL</h4><ul><li><strong>安全组（SG）</strong>：作为虚拟防火墙，控制着对EC2实例的访问。为每个EC2实例配置合适的入站和出站规则，确保只允许必要的流量。</li><li><strong>网络访问控制列表（ACL）</strong>：作为VPC内各子网的附加安全层，用于控制进出子网的流量。配置网络ACL以允许或拒绝特定类型的流量。</li></ul><h4 id="路由表和NAT网关"><a href="#路由表和NAT网关" class="headerlink" title="路由表和NAT网关"></a>路由表和NAT网关</h4><ul><li><strong>路由表</strong>：确定网络流量如何从VPC的一个子网路由到另一个子网或外部网络。为每个子网分配合适的路由表。</li><li><strong>NAT网关</strong>：在私有子网中的实例需要访问互联网时使用NAT网关。它使私有子网中的实例能够发起向外部互联网的连接，同时阻止来自互联网的直接访问。</li></ul><h3 id="确定网络分段策略"><a href="#确定网络分段策略" class="headerlink" title="确定网络分段策略"></a>确定网络分段策略</h3><h4 id="公有子网和私有子网"><a href="#公有子网和私有子网" class="headerlink" title="公有子网和私有子网"></a>公有子网和私有子网</h4><ul><li><strong>公有子网</strong>：包含需要从互联网直接访问的资源（如Web服务器）。公有子网中的实例通常配置有公网IP地址。</li><li><strong>私有子网</strong>：用于不需要直接从互联网访问的资源（如数据库）。私有子网中的实例无法直接从互联网访问，提供了更高的安全性。</li></ul><h3 id="将AWS服务集成到安全应用程序"><a href="#将AWS服务集成到安全应用程序" class="headerlink" title="将AWS服务集成到安全应用程序"></a>将AWS服务集成到安全应用程序</h3><h4 id="AWS-Shield、AWS-WAF和IAM-Identity-Center"><a href="#AWS-Shield、AWS-WAF和IAM-Identity-Center" class="headerlink" title="AWS Shield、AWS WAF和IAM Identity Center"></a>AWS Shield、AWS WAF和IAM Identity Center</h4><ul><li><strong>AWS Shield</strong>：提供DDoS保护，保护AWS资源（如EC2、Elastic Load Balancing等）免受DDoS攻击。</li><li><strong>AWS WAF（Web Application Firewall）</strong>：保护应用程序免受Web攻击，可以创建自定义的Web安全规则。</li><li><strong>IAM Identity Center（原AWS SSO）</strong>：提供单点登录（SSO），管理对AWS账户和应用程序的访问。</li></ul><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li><strong>AWS Secrets Manager</strong>：保护访问密钥和其他敏感信息，可以轻松地在应用中管理和检索机密。</li></ul><h3 id="保护与AWS云的外部网络连接"><a href="#保护与AWS云的外部网络连接" class="headerlink" title="保护与AWS云的外部网络连接"></a>保护与AWS云的外部网络连接</h3><h4 id="VPN和AWS-Direct-Connect"><a href="#VPN和AWS-Direct-Connect" class="headerlink" title="VPN和AWS Direct Connect"></a>VPN和AWS Direct Connect</h4><ul><li><strong>VPN（虚拟私人网络）</strong>：安全地将本地网络连接到AWS VPC。利用IPSec VPN连接，可以建立加密的通道，保护数据传输。</li><li><strong>AWS Direct Connect</strong>：通过私有网络连接来访问AWS服务，提供更可靠、更高带宽的连接选项，同时降低网络成本。</li></ul><p>以上是构建安全AWS VPC架构的关键组件和策略。通过结合使用这些服务和配置，可以创建一个既安全又高效的网络环境。</p><h3 id="数据访问和监管"><a href="#数据访问和监管" class="headerlink" title="数据访问和监管"></a>数据访问和监管</h3><h4 id="数据访问和监管概述"><a href="#数据访问和监管概述" class="headerlink" title="数据访问和监管概述"></a>数据访问和监管概述</h4><p>在AWS云环境中，数据访问和监管涉及确保数据的安全性和合规性，以及控制和监视数据的访问。这包括实施策略和技术措施来保护数据，确保只有授权用户才能访问敏感信息，并遵守相关的法律和行业标准。</p><h4 id="实施数据访问控制"><a href="#实施数据访问控制" class="headerlink" title="实施数据访问控制"></a>实施数据访问控制</h4><p>数据访问控制是确保数据安全性的关键部分，它涉及到限制对数据的访问和操作。</p><h5 id="最佳实践原则-25"><a href="#最佳实践原则-25" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>基于角色的访问控制</strong> (RBAC): 为不同的用户分配基于角色的权限。</li><li><strong>最小权限原则</strong>: 限制用户只能访问他们执行职责所必需的数据。</li></ul><h5 id="实践步骤-38"><a href="#实践步骤-38" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义数据访问角色，并为每个角色分配适当的权限。</li><li>使用AWS IAM来创建和管理用户、组、角色和权限策略。</li><li>定期审查和调整IAM策略，确保它们符合最小权限原则。</li></ol><h4 id="监管数据访问"><a href="#监管数据访问" class="headerlink" title="监管数据访问"></a>监管数据访问</h4><p>监管数据访问是指监控和记录对数据的所有访问尝试，无论是成功还是失败的。</p><h5 id="最佳实践原则-26"><a href="#最佳实践原则-26" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>全面的审计日志</strong>: 记录所有数据访问尝试的详细日志。</li><li><strong>实时监控</strong>: 使用工具实时监控数据访问模式和潜在的异常活动。</li></ul><h5 id="实践步骤-39"><a href="#实践步骤-39" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS CloudTrail来记录和监控API调用。</li><li>配置Amazon S3存储桶访问日志记录所有请求。</li><li>利用Amazon CloudWatch或AWS Config来创建自定义监控和警报。</li></ol><h4 id="数据保护和加密"><a href="#数据保护和加密" class="headerlink" title="数据保护和加密"></a>数据保护和加密</h4><p>保护数据的完整性和保密性需要在传输和静态时对数据进行加密。</p><h5 id="最佳实践原则-27"><a href="#最佳实践原则-27" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>传输中加密</strong>: 使用SSL/TLS等协议在传输过程中加密数据。</li><li><strong>静态数据加密</strong>: 存储数据时使用服务器端加密。</li></ul><h5 id="实践步骤-40"><a href="#实践步骤-40" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>对所有传输中的数据使用HTTPS和其他安全协议。</li><li>在Amazon S3等服务中启用服务器端加密（如SSE-S3、SSE-KMS）。</li><li>管理加密密钥，使用AWS Key Management Service (KMS)来创建和控制加密密钥。</li></ol><h4 id="遵守合规性要求"><a href="#遵守合规性要求" class="headerlink" title="遵守合规性要求"></a>遵守合规性要求</h4><p>合规性要求可能来自行业标准、法律法规或公司政策，需要确保数据访问和处理符合这些要求。</p><h5 id="最佳实践原则-28"><a href="#最佳实践原则-28" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>了解合规性框架</strong>: 熟悉适用于组织的合规性框架，如GDPR、HIPAA。</li><li><strong>实施合规性控制</strong>: 根据合规性要求实施相应的控制措施。</li></ul><h5 id="实践步骤-41"><a href="#实践步骤-41" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>评估适用的合规性要求，并将其整合到数据访问策略中。</li><li>利用AWS的合规性报告和认证，如AWS Artifact提供的文档。</li><li>实施定期的合规性审计和自我评估，确保持续合规。</li></ol><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="数据恢复概述"><a href="#数据恢复概述" class="headerlink" title="数据恢复概述"></a>数据恢复概述</h4><p>数据恢复是指在数据丢失或损坏后恢复数据的过程。在AWS云中，数据恢复策略是确保业务连续性和灾难恢复计划的重要组成部分。这包括备份数据、确保备份的完整性以及在必要时迅速有效地恢复数据。</p><h4 id="设计数据备份策略"><a href="#设计数据备份策略" class="headerlink" title="设计数据备份策略"></a>设计数据备份策略</h4><p>有效的数据备份策略是数据恢复计划的核心。它应该包括定期备份的计划和确保备份数据的安全性和可用性。</p><h5 id="最佳实践原则-29"><a href="#最佳实践原则-29" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期自动备份</strong>：自动定期备份数据以减少人为错误和遗漏。</li><li><strong>多地域冗余存储</strong>：在多个地理位置存储备份，以防止单点故障。</li></ul><h5 id="实践步骤-42"><a href="#实践步骤-42" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Backup服务来集中管理和自动化备份任务。</li><li>利用Amazon S3的跨区域复制功能来存储备份数据的副本。</li><li>确保备份数据的加密，以保护数据在传输和存储中的安全。</li></ol><h4 id="测试和验证备份"><a href="#测试和验证备份" class="headerlink" title="测试和验证备份"></a>测试和验证备份</h4><p>备份数据的存在并不足以确保数据恢复的成功。定期测试和验证备份是必要的步骤。</p><h5 id="最佳实践原则-30"><a href="#最佳实践原则-30" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期恢复测试</strong>：定期进行恢复测试以验证备份数据的完整性。</li><li><strong>监控备份活动</strong>：监控备份过程，确保没有失败或遗漏。</li></ul><h5 id="实践步骤-43"><a href="#实践步骤-43" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定期执行恢复测试，以验证备份的完整性和可用性。</li><li>使用AWS CloudTrail和Amazon CloudWatch来监控备份和恢复活动。</li><li>记录和分析测试结果，确保符合恢复时间目标(RTO)和恢复点目标(RPO)。</li></ol><h4 id="实施灾难恢复计划"><a href="#实施灾难恢复计划" class="headerlink" title="实施灾难恢复计划"></a>实施灾难恢复计划</h4><p>灾难恢复(DR)计划是确保在发生灾难时能够快速恢复操作的详细指南。</p><h5 id="最佳实践原则-31"><a href="#最佳实践原则-31" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>多层次备份策略</strong>：实施多层次的备份策略，包括快照、复制和归档。</li><li><strong>自动化恢复流程</strong>：自动化恢复流程以减少恢复时间。</li></ul><h5 id="实践步骤-44"><a href="#实践步骤-44" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义业务影响分析(BIA)并建立恢复优先级。</li><li>设计并实施灾难恢复方案，如AWS的Pilot Light、Warm Standby或Multi-Site方案。</li><li>编写和维护详细的灾难恢复文档，并定期进行演练。</li></ol><h3 id="数据留存和分类"><a href="#数据留存和分类" class="headerlink" title="数据留存和分类"></a>数据留存和分类</h3><h4 id="数据留存和分类概述"><a href="#数据留存和分类概述" class="headerlink" title="数据留存和分类概述"></a>数据留存和分类概述</h4><p>数据留存和分类是数据管理策略的关键组成部分，涉及保留数据的时间长度以及如何组织数据以便于访问和合规性。在AWS云中，这意味着使用合适的服务和工具来存储、分类和管理数据的生命周期。</p><h4 id="确定数据留存策略"><a href="#确定数据留存策略" class="headerlink" title="确定数据留存策略"></a>确定数据留存策略</h4><p>数据留存策略决定了数据应该保留多久，以及何时应该删除或归档数据。</p><h5 id="最佳实践原则-32"><a href="#最佳实践原则-32" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>合规性和业务需求</strong>：根据法律法规和业务需求确定数据留存期限。</li><li><strong>成本效益分析</strong>：考虑数据留存的成本和价值，进行成本效益分析。</li></ul><h5 id="实践步骤-45"><a href="#实践步骤-45" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>审查法律法规和业务政策，确定数据留存的最小和最大期限。</li><li>使用AWS的数据生命周期管理策略来自动删除过期的数据。</li><li>配置Amazon S3生命周期策略，自动将数据转移到更低成本的存储类别或归档服务。</li></ol><h4 id="实施数据分类"><a href="#实施数据分类" class="headerlink" title="实施数据分类"></a>实施数据分类</h4><p>数据分类是对数据进行标记和分组的过程，以便于管理和检索。</p><h5 id="最佳实践原则-33"><a href="#最佳实践原则-33" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>数据敏感性和重要性</strong>：根据数据的敏感性和业务重要性进行分类。</li><li><strong>一致的标签系统</strong>：使用一致的标签系统来简化数据分类和检索。</li></ul><h5 id="实践步骤-46"><a href="#实践步骤-46" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为数据定义分类标准，如公开、机密、高度机密等。</li><li>使用AWS资源标签来分类和管理数据和其他AWS资源。</li><li>利用Amazon Macie等服务自动发现和分类敏感数据。</li></ol><h4 id="管理数据留存和分类"><a href="#管理数据留存和分类" class="headerlink" title="管理数据留存和分类"></a>管理数据留存和分类</h4><p>有效的数据留存和分类管理不仅要设置策略，还需要持续监控和调整这些策略。</p><h5 id="最佳实践原则-34"><a href="#最佳实践原则-34" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期审查</strong>：定期审查数据留存和分类策略，确保它们仍然适用。</li><li><strong>自动化流程</strong>：尽可能自动化数据留存和分类的流程。</li></ul><h5 id="实践步骤-47"><a href="#实践步骤-47" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定期进行内部或外部审计，以确保遵守数据留存政策。</li><li>利用AWS的自动化工具，如AWS Lambda，来自动执行数据分类和留存策略的更新。</li><li>教育员工关于数据留存和分类的最佳实践，确保组织内部的一致性。</li></ol><h4 id="数据留存和分类的监控与报告"><a href="#数据留存和分类的监控与报告" class="headerlink" title="数据留存和分类的监控与报告"></a>数据留存和分类的监控与报告</h4><p>监控和报告是确保数据留存和分类策略有效执行的重要组成部分。</p><h5 id="最佳实践原则-35"><a href="#最佳实践原则-35" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>透明度</strong>：确保数据留存和分类的过程具有高度透明度。</li><li><strong>可审计性</strong>：保持记录，确保数据留存和分类的过程可审计。</li></ul><h5 id="实践步骤-48"><a href="#实践步骤-48" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用Amazon CloudWatch来监控数据留存和分类相关的指标和警报。</li><li>利用AWS CloudTrail来记录和审计数据相关的操作。</li><li>生成定期报告，以向管理层展示数据留存和分类的状态和活动。</li></ol><p>要调整AWS技术以满足合规性要求并实现数据的安全保护，可以遵循以下步骤：</p><h3 id="对数据进行静态加密"><a href="#对数据进行静态加密" class="headerlink" title="对数据进行静态加密"></a>对数据进行静态加密</h3><ol><li><strong>使用AWS Key Management Service (AWS KMS)</strong>: AWS KMS允许您创建和管理加密密钥，并通过使用硬件安全模块控制它们的使用。这些密钥可以用来加密存储在AWS服务中的数据。</li><li><strong>创建密钥</strong>: 在AWS KMS中创建一个新的客户主键（CMK）。可以选择密钥用途和自动轮换设置。</li><li><strong>加密数据</strong>: 使用创建的CMK对需要静态加密的数据进行加密。这可以通过集成的AWS服务（如S3、EBS等）或直接通过KMS API实现。</li></ol><h3 id="对数据进行传输中加密"><a href="#对数据进行传输中加密" class="headerlink" title="对数据进行传输中加密"></a>对数据进行传输中加密</h3><ol><li><strong>使用AWS Certificate Manager (ACM)</strong>: ACM允许您轻松地部署、管理和自动续订SSL/TLS证书。</li><li><strong>创建和部署证书</strong>: 在ACM中创建一个SSL/TLS证书，并将其部署到支持HTTPS的AWS服务（如ELB、CloudFront）。</li><li><strong>配置TLS加密</strong>: 确保所有的数据传输都通过TLS加密通道进行，以保证数据在传输过程中的安全。</li></ol><h3 id="对加密密钥实施访问策略"><a href="#对加密密钥实施访问策略" class="headerlink" title="对加密密钥实施访问策略"></a>对加密密钥实施访问策略</h3><ol><li><strong>创建IAM策略</strong>: 为需要访问加密密钥的IAM角色或用户创建策略，明确指定哪些操作是允许的。</li><li><strong>绑定策略到用户或角色</strong>: 将策略应用于适当的IAM用户或角色，以控制对KMS密钥的访问。</li></ol><h3 id="实施数据备份和复制"><a href="#实施数据备份和复制" class="headerlink" title="实施数据备份和复制"></a>实施数据备份和复制</h3><ol><li><strong>自动备份</strong>: 利用AWS服务（如RDS、EBS的快照功能）进行定期数据备份。</li><li><strong>跨区域复制</strong>: 对于关键数据，使用跨区域复制功能以增加数据的耐久性和可用性。</li></ol><h3 id="实施数据访问、生命周期和保护策略"><a href="#实施数据访问、生命周期和保护策略" class="headerlink" title="实施数据访问、生命周期和保护策略"></a>实施数据访问、生命周期和保护策略</h3><ol><li><strong>数据访问控制</strong>: 使用IAM和资源级别的策略控制对数据的访问权限。</li><li><strong>数据生命周期管理</strong>: 利用S3的生命周期管理策略自动转移或删除旧数据。</li><li><strong>数据保护</strong>: 使用AWS Shield等工具保护数据免受DDoS攻击等安全威胁。</li></ol><h3 id="轮换加密密钥和续订证书"><a href="#轮换加密密钥和续订证书" class="headerlink" title="轮换加密密钥和续订证书"></a>轮换加密密钥和续订证书</h3><ol><li><strong>定期轮换加密密钥</strong>: 在KMS中设置密钥轮换，自动或手动更新加密密钥。</li><li><strong>监控和续订证书</strong>: 利用ACM的自动续订功能，确保SSL/TLS证书始终有效。</li></ol><h2 id="设计弹性架构"><a href="#设计弹性架构" class="headerlink" title="设计弹性架构"></a>设计弹性架构</h2><h3 id="API-创建和管理（例如，Amazon-API-Gateway、REST-API）"><a href="#API-创建和管理（例如，Amazon-API-Gateway、REST-API）" class="headerlink" title="API 创建和管理（例如，Amazon API Gateway、REST API）"></a>API 创建和管理（例如，Amazon API Gateway、REST API）</h3><h4 id="API-创建和管理概述"><a href="#API-创建和管理概述" class="headerlink" title="API 创建和管理概述"></a>API 创建和管理概述</h4><p>API（应用程序编程接口）是软件间交互的一套规则和定义，允许不同的系统和应用程序之间进行通信。Amazon API Gateway 是一个完全托管的服务，它使开发者能够轻松地创建、发布、维护、监控和保护任何规模的API。</p><h4 id="设计-REST-API"><a href="#设计-REST-API" class="headerlink" title="设计 REST API"></a>设计 REST API</h4><p>在使用Amazon API Gateway创建REST API之前，需要设计API的架构，包括资源、方法和状态码。</p><h5 id="最佳实践原则-36"><a href="#最佳实践原则-36" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>使用RESTful原则</strong>：设计符合REST架构风格的API，这意味着使用HTTP方法和状态码，资源的表述等。</li><li><strong>版本控制</strong>：通过API路径或头部信息实现API版本控制。</li></ul><h5 id="实践步骤-49"><a href="#实践步骤-49" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义API的资源（如用户、产品等）和子资源。</li><li>为每个资源定义CRUD（创建、读取、更新和删除）操作对应的HTTP方法（如GET、POST、PUT、DELETE）。</li><li>设计API的请求和响应模型，包括状态码和错误消息。</li></ol><h4 id="创建-API-与部署"><a href="#创建-API-与部署" class="headerlink" title="创建 API 与部署"></a>创建 API 与部署</h4><p>使用Amazon API Gateway创建API涉及到设置资源、方法、方法请求和响应等。</p><h5 id="最佳实践原则-37"><a href="#最佳实践原则-37" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：确保API的每个部分都采用适当的安全措施，如API密钥、身份验证和授权。</li><li><strong>性能优化</strong>：使用缓存和节流等技术来优化API性能。</li></ul><h5 id="实践步骤-50"><a href="#实践步骤-50" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在Amazon API Gateway中创建一个新的API。</li><li>设置API的资源和方法，并配置请求和响应的模型。</li><li>配置API的授权和认证机制。</li><li>部署API到一个或多个阶段（如开发、测试、生产）。</li></ol><h4 id="管理-API-生命周期"><a href="#管理-API-生命周期" class="headerlink" title="管理 API 生命周期"></a>管理 API 生命周期</h4><p>API的管理包括监控、维护、版本更新和退役。</p><h5 id="最佳实践原则-38"><a href="#最佳实践原则-38" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>监控和日志记录</strong>：监控API的使用情况和性能，记录日志以便于故障排查。</li><li><strong>持续迭代</strong>：定期更新API以添加新功能或改进现有功能。</li></ul><h5 id="实践步骤-51"><a href="#实践步骤-51" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用Amazon CloudWatch监控API的调用次数、错误率和延迟。</li><li>利用AWS CloudTrail记录API的管理事件。</li><li>为API发布新版本和更新，同时保持旧版本的稳定性。</li><li>当API退役时，通知消费者，并提供迁移路径。</li></ol><h4 id="确保-API-安全"><a href="#确保-API-安全" class="headerlink" title="确保 API 安全"></a>确保 API 安全</h4><p>保护API以防止未授权访问和攻击是至关重要的。</p><h5 id="最佳实践原则-39"><a href="#最佳实践原则-39" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>使用HTTPS</strong>：确保所有API调用都通过HTTPS进行，以保证数据传输的安全性。</li><li><strong>访问控制</strong>：使用IAM角色和策略控制对API的访问。</li></ul><h5 id="实践步骤-52"><a href="#实践步骤-52" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>强制执行SSL/TLS，确保API仅通过HTTPS提供服务。</li><li>配置API Gateway资源策略，限制IP地址或IAM用户的访问。</li><li>使用API Gateway的API密钥和使用计划来控制和限制客户端的API请求。</li><li>实施AWS WAF（Web应用程序防火墙）以防止常见的网络攻击。</li></ol><h4 id="监控和优化-API-性能"><a href="#监控和优化-API-性能" class="headerlink" title="监控和优化 API 性能"></a>监控和优化 API 性能</h4><p>API性能的监控和优化是确保API可靠和高效的关键。</p><h5 id="最佳实践原则-40"><a href="#最佳实践原则-40" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>性能指标</strong>：关注API的延迟和错误率等关键性能指标。</li><li><strong>缓存策略</strong>：合理设置API缓存以提高响应速度和减轻后端负载。</li></ul><h5 id="实践步骤-53"><a href="#实践步骤-53" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设置Amazon CloudWatch警报，当API的性能指标超出预定阈值时接收通知。</li><li>使用API Gateway缓存减少后端服务的调用次数。</li><li>分析API使用模式，并据此调整请求节流限制。</li></ol><h3 id="具有合适使用案例的-AWS-Managed-Services（例如，AWS-Transfer-Family、Amazon-Simple-Queue-Service-Amazon-SQS-、Secrets-Manager）"><a href="#具有合适使用案例的-AWS-Managed-Services（例如，AWS-Transfer-Family、Amazon-Simple-Queue-Service-Amazon-SQS-、Secrets-Manager）" class="headerlink" title="具有合适使用案例的 AWS Managed Services（例如，AWS Transfer Family、Amazon Simple Queue Service [Amazon SQS]、Secrets Manager）"></a>具有合适使用案例的 AWS Managed Services（例如，AWS Transfer Family、Amazon Simple Queue Service [Amazon SQS]、Secrets Manager）</h3><h4 id="AWS-Transfer-Family-使用案例"><a href="#AWS-Transfer-Family-使用案例" class="headerlink" title="AWS Transfer Family 使用案例"></a>AWS Transfer Family 使用案例</h4><p>AWS Transfer Family 提供安全的文件传输服务，使您能够轻松地在AWS上接收、存储和共享数据。</p><h5 id="最佳实践原则-41"><a href="#最佳实践原则-41" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：确保传输过程中使用加密协议，如SFTP、FTPS和FTP。</li><li><strong>集成</strong>：与AWS服务（如Amazon S3和Amazon EFS）集成以存储和处理数据。</li></ul><h5 id="实践步骤-54"><a href="#实践步骤-54" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建一个AWS Transfer Family服务器，并指定服务类型（SFTP、FTPS、或FTP）。</li><li>配置用户，并将它们与IAM角色关联，以便控制对S3桶的访问。</li><li>设置网络访问，通过VPC或互联网进行传输。</li></ol><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>文件共享</strong>：企业可以使用AWS Transfer Family 安全地与合作伙伴共享文件。</li><li><strong>数据迁移</strong>：将本地数据迁移到AWS，作为云存储的一部分。</li><li><strong>内容分发</strong>：媒体公司可以将大型媒体文件上传到云端，供全球分发。</li></ul><h4 id="Amazon-Simple-Queue-Service-Amazon-SQS-使用案例"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS-使用案例" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS) 使用案例"></a>Amazon Simple Queue Service (Amazon SQS) 使用案例</h4><p>Amazon SQS 是一种完全托管的消息队列服务，它可以帮助您在软件组件之间解耦和扩展应用程序。</p><h5 id="最佳实践原则-42"><a href="#最佳实践原则-42" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>解耦组件</strong>：使用消息队列来解耦生产者和消费者进程。</li><li><strong>扩展性</strong>：根据工作负载动态调整消费者的数量。</li></ul><h5 id="实践步骤-55"><a href="#实践步骤-55" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建一个新的SQS队列。</li><li>配置消息保留策略和传递延迟设置。</li><li>在生产者应用程序中发送消息到队列。</li><li>在消费者应用程序中从队列接收和处理消息。</li></ol><h5 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>异步处理</strong>：应用程序可以将任务发送到SQS队列进行异步处理。</li><li><strong>应用程序扩展</strong>：在用户请求量增加时，通过增加消费者实例数量来处理更多的消息。</li><li><strong>容错性</strong>：在处理消息失败时，SQS可以重新尝试或将消息移动到死信队列。</li></ul><h4 id="AWS-Secrets-Manager-使用案例"><a href="#AWS-Secrets-Manager-使用案例" class="headerlink" title="AWS Secrets Manager 使用案例"></a>AWS Secrets Manager 使用案例</h4><p>AWS Secrets Manager 是一项服务，用于保护访问应用程序的敏感信息，如数据库密码、API密钥和其他秘密。</p><h5 id="最佳实践原则-43"><a href="#最佳实践原则-43" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期轮换秘密</strong>：自动更换秘密以提高安全性。</li><li><strong>集中管理</strong>：集中存储和访问所有秘密。</li></ul><h5 id="实践步骤-56"><a href="#实践步骤-56" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在AWS Secrets Manager中存储新的秘密。</li><li>配置秘密的自动轮换策略。</li><li>通过IAM策略控制对秘密的访问权限。</li><li>在应用程序中使用SDK或CLI获取秘密，而不是硬编码。</li></ol><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>数据库凭证管理</strong>：存储和管理数据库登录信息，自动处理密码更换。</li><li><strong>API密钥安全</strong>：安全地存储第三方服务的API密钥，并在需要时轻松访问。</li><li><strong>应用配置</strong>：存储应用程序配置详情，如端口、域和更多环境特定的秘密。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>AWS Managed Services 提供了一系列工具，以帮助组织在AWS云环境中高效、安全地操作。AWS Transfer Family 适用于需要安全文件传输的场景，Amazon SQS 适合于需要消息队列来实现应用程序解耦和扩展的情况，而AWS Secrets Manager 非常适合需要安全管理敏感信息的应用程序。通过这些服务，AWS用户可以提高应用程序的安全性、可靠性和扩展性，同时简化运维工作。</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="缓存策略基础"><a href="#缓存策略基础" class="headerlink" title="缓存策略基础"></a>缓存策略基础</h4><p>缓存策略是优化数据检索性能的关键组成部分。它涉及存储数据的临时副本，以便快速访问，减少对原始数据源的请求次数，从而提高应用程序的响应速度和减少延迟。</p><h5 id="最佳实践原则-44"><a href="#最佳实践原则-44" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li>**有效期 (TTL)**：为缓存的数据设置合适的生命周期。</li><li><strong>一致性</strong>：确保缓存数据的一致性，以防止过期或不正确的信息被提供。</li><li><strong>无效化</strong>：当原始数据更改时，及时无效化缓存。</li></ul><h5 id="实践步骤-57"><a href="#实践步骤-57" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>选择合适的缓存策略（如LRU、FIFO等）。</li><li>配置缓存存储，可以是内存中的、本地的或分布式的。</li><li>实施缓存失效逻辑，确保数据的一致性。</li></ol><h4 id="应用层缓存策略"><a href="#应用层缓存策略" class="headerlink" title="应用层缓存策略"></a>应用层缓存策略</h4><p>应用层缓存通常指在应用程序代码中实现的缓存，例如使用内存中的数据结构来存储计算结果或频繁访问的数据。</p><h5 id="最佳实践原则-45"><a href="#最佳实践原则-45" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>选择性缓存</strong>：仅缓存那些读取操作频繁且相对不经常更新的数据。</li><li><strong>内存管理</strong>：监控缓存占用的内存，并确保它不会导致应用程序崩溃。</li></ul><h5 id="实践步骤-58"><a href="#实践步骤-58" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序代码中标识高延迟或高计算成本的操作。</li><li>使用合适的数据结构（如哈希表）来存储这些操作的结果。</li><li>在数据更新时，更新缓存或标记为无效。</li></ol><h4 id="数据库缓存策略"><a href="#数据库缓存策略" class="headerlink" title="数据库缓存策略"></a>数据库缓存策略</h4><p>数据库缓存涉及在数据库系统中缓存查询结果，以减少对数据库引擎的查询次数。</p><h5 id="最佳实践原则-46"><a href="#最佳实践原则-46" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>查询优化</strong>：缓存那些执行成本高昂的查询结果。</li><li><strong>自动化</strong>：利用数据库管理系统提供的自动缓存机制。</li></ul><h5 id="实践步骤-59"><a href="#实践步骤-59" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用数据库查询分析器找出成本高昂的查询。</li><li>配置数据库级别的缓存设置，如MySQL的Query Cache或SQL Server的In-Memory OLTP。</li><li>监控缓存的效率并根据需要调整配置。</li></ol><h4 id="CDN-缓存策略"><a href="#CDN-缓存策略" class="headerlink" title="CDN 缓存策略"></a>CDN 缓存策略</h4><p>内容分发网络（CDN）缓存是一种分布式网络缓存，它存储静态资源，如图片、视频、CSS和JavaScript文件，以便于快速交付给全球用户。</p><h5 id="最佳实践原则-47"><a href="#最佳实践原则-47" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>地理分布</strong>：缓存内容应靠近用户，以减少延迟。</li><li><strong>版本控制</strong>：使用文件版本命名来管理缓存的更新。</li></ul><h5 id="实践步骤-60"><a href="#实践步骤-60" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>选择CDN提供商，并配置CDN缓存规则。</li><li>为静态资源实现版本控制，例如通过添加查询字符串或文件指纹。</li><li>设置缓存的TTL，确保内容的及时更新。</li></ol><h4 id="HTTP-缓存策略"><a href="#HTTP-缓存策略" class="headerlink" title="HTTP 缓存策略"></a>HTTP 缓存策略</h4><p>HTTP缓存策略涉及客户端（如浏览器）和服务器之间的缓存控制，通常通过HTTP头部来控制。</p><h5 id="最佳实践原则-48"><a href="#最佳实践原则-48" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>缓存控制头部</strong>：使用<code>Cache-Control</code>头部指令来控制资源的缓存行为。</li><li><strong>协商缓存</strong>：当可能时，使用<code>ETag</code>和<code>Last-Modified</code>头部进行缓存验证。</li></ul><h5 id="实践步骤-61"><a href="#实践步骤-61" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在服务器响应中设置<code>Cache-Control</code>头部，如<code>max-age</code>和<code>must-revalidate</code>。</li><li>使用<code>ETag</code>头部提供资源的特定版本标记。</li><li>通过<code>Last-Modified</code>头部提供资源最后修改的时间戳。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存策略是提高应用程序性能和用户体验的重要组成部分。无论是应用层缓存、数据库缓存、CDN缓存还是HTTP缓存，合理的缓存策略都可以显著减少数据检索时间，减轻后端服务的压力，并提供更快的响应速度。实施缓存时，重要的是要考虑数据的一致性、有效期和无效化策略，以确保用户始终访问到最新和最准确的信息。</p><h3 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h3><h4 id="微服务架构概述"><a href="#微服务架构概述" class="headerlink" title="微服务架构概述"></a>微服务架构概述</h4><p>微服务架构是一种设计方法，它通过将一个大型应用程序拆分成一组小型、松散耦合的服务来促进敏捷开发和部署。每个服务通常围绕特定业务功能构建，并且可以独立于其他服务进行开发、部署和扩展。</p><h5 id="最佳实践原则-49"><a href="#最佳实践原则-49" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>服务自治</strong>：每个服务应该是自包含的，并拥有特定的业务逻辑。</li><li><strong>松耦合</strong>：服务之间的依赖关系应该最小化。</li><li><strong>可维护性和可测试性</strong>：服务应该容易维护和测试。</li></ul><h5 id="实践步骤-62"><a href="#实践步骤-62" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>确定业务域，并围绕这些域设计服务。</li><li>设计服务API，并确保它们清晰和一致。</li><li>实现服务的持续集成和部署（CI/CD）。</li></ol><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责原则指的是微服务应该围绕一个核心功能构建，并且只做好一件事情。这有助于确保服务的复杂性保持在可管理的水平。</p><h5 id="最佳实践原则-50"><a href="#最佳实践原则-50" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>聚焦业务能力</strong>：服务应该围绕单一的业务能力构建。</li><li><strong>避免臃肿服务</strong>：避免创建大型服务，这些服务难以维护和扩展。</li></ul><h5 id="实践步骤-63"><a href="#实践步骤-63" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>明确界定服务的业务边界。</li><li>避免在单个服务中实现多个业务功能。</li><li>定期评估服务的职责，确保它们没有变得过于复杂。</li></ol><h4 id="服务自治和独立性"><a href="#服务自治和独立性" class="headerlink" title="服务自治和独立性"></a>服务自治和独立性</h4><p>服务自治是微服务设计的核心原则之一。每个服务都应该是自主的，能够独立于其他服务运行和演进。</p><h5 id="最佳实践原则-51"><a href="#最佳实践原则-51" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>独立部署</strong>：服务应该能够独立于其他服务进行部署。</li><li><strong>自主数据管理</strong>：服务应该拥有并管理自己的数据模型和数据库。</li></ul><h5 id="实践步骤-64"><a href="#实践步骤-64" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个服务实现独立的部署流程。</li><li>确保服务有自己的数据库或数据存储，不与其他服务共享。</li><li>使用服务发现机制，使服务能够独立地找到并与其他服务通信。</li></ol><h4 id="服务的松耦合和内聚"><a href="#服务的松耦合和内聚" class="headerlink" title="服务的松耦合和内聚"></a>服务的松耦合和内聚</h4><p>微服务应该是松耦合的，这意味着它们之间的依赖关系应该尽可能地少。同时，服务内部应该是高度内聚的，意味着服务内部的组件紧密相关且为同一目标工作。</p><h5 id="最佳实践原则-52"><a href="#最佳实践原则-52" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定义良好的接口</strong>：服务之间的交互应该通过定义良好的API进行。</li><li><strong>事件驱动通信</strong>：使用事件来减少服务间的直接依赖。</li></ul><h5 id="实践步骤-65"><a href="#实践步骤-65" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设计清晰的API和服务契约。</li><li>使用异步消息传递和事件来促进服务间的通信。</li><li>限制直接的服务到服务调用，以减少耦合。</li></ol><h4 id="可维护性和可测试性"><a href="#可维护性和可测试性" class="headerlink" title="可维护性和可测试性"></a>可维护性和可测试性</h4><p>微服务应该容易维护和测试，这有助于快速迭代和提高系统的稳定性。</p><h5 id="最佳实践原则-53"><a href="#最佳实践原则-53" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>模块化设计</strong>：服务应该是模块化的，以便于理解和更改。</li><li><strong>自动化测试</strong>：服务应该有一套完善的自动化测试套件。</li></ul><h5 id="实践步骤-66"><a href="#实践步骤-66" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>构建模块化的服务，使其能够容易地添加或修改功能。</li><li>开发单元测试、集成测试和端到端测试。</li><li>实施持续集成和持续部署流程。</li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>微服务设计原则旨在支持构建可维护、可扩展和可持续的服务。通过遵循单一职责原则、确保服务自治和独立性、实现服务的松耦合和内聚、以及强调可维护性和可测试性，团队可以创建出强大而灵活的微服务架构。这些原则有助于微服务在快速变化的市场中保持竞争力，同时降低长期的技术债务风险。</p><h3 id="事件驱动型架构"><a href="#事件驱动型架构" class="headerlink" title="事件驱动型架构"></a>事件驱动型架构</h3><p>事件驱动型架构是一种软件架构范式，它通过事件来触发和通信各个服务或应用程序组件之间的交互。在这种架构中，事件是一个重要的状态改变，它可以由系统内部或外部的动作产生，并且被系统内的其他组件所监听和响应。</p><h5 id="最佳实践原则-54"><a href="#最佳实践原则-54" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>解耦生产者和消费者</strong>：生产者产生事件而不需要知道哪些消费者会处理这些事件。</li><li><strong>异步通信</strong>：系统组件应该异步地处理事件，以提高性能和响应性。</li><li><strong>可伸缩性</strong>：事件驱动架构应该能够水平扩展，以处理大量的事件流。</li></ul><h5 id="实践步骤-67"><a href="#实践步骤-67" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义明确的事件模型和事件列表。</li><li>实现事件生产者，它负责发布系统中发生的事件。</li><li>实现事件消费者，它订阅感兴趣的事件并作出响应。</li><li>使用消息队列或事件总线来传输事件，确保系统的可靠性和可伸缩性。</li></ol><h3 id="水平扩展与垂直扩展"><a href="#水平扩展与垂直扩展" class="headerlink" title="水平扩展与垂直扩展"></a>水平扩展与垂直扩展</h3><p>水平扩展（Scaling Out）和垂直扩展（Scaling Up）是两种不同的系统扩展策略，用于提高应用程序或服务的处理能力。</p><h5 id="水平扩展（Scaling-Out）"><a href="#水平扩展（Scaling-Out）" class="headerlink" title="水平扩展（Scaling Out）"></a>水平扩展（Scaling Out）</h5><p>水平扩展指的是增加更多的节点来分摊负载，例如添加更多的服务器实例。</p><h6 id="最佳实践原则-55"><a href="#最佳实践原则-55" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h6><ul><li><strong>无状态服务</strong>：确保服务无状态，使得任何实例都能处理任何请求。</li><li><strong>负载均衡</strong>：使用负载均衡器来分配跨多个节点的请求。</li></ul><h6 id="实践步骤-68"><a href="#实践步骤-68" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>设计无状态的服务。</li><li>在多个服务器或容器中部署服务的实例。</li><li>配置负载均衡器来分配流量到不同的实例。</li></ol><h5 id="垂直扩展（Scaling-Up）"><a href="#垂直扩展（Scaling-Up）" class="headerlink" title="垂直扩展（Scaling Up）"></a>垂直扩展（Scaling Up）</h5><p>垂直扩展指的是增强单个节点的处理能力，如增加CPU、内存或存储资源。</p><h6 id="最佳实践原则-56"><a href="#最佳实践原则-56" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h6><ul><li><strong>资源优化</strong>：优化应用程序以充分利用增强的硬件资源。</li><li><strong>成本效益</strong>：评估垂直扩展的成本效益，因为它可能涉及昂贵的硬件升级。</li></ul><h6 id="实践步骤-69"><a href="#实践步骤-69" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>识别性能瓶颈，确定需要增强的资源（CPU、内存等）。</li><li>升级硬件或迁移到更强大的机器。</li><li>优化应用程序配置以利用新的硬件资源。</li></ol><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>事件驱动型架构通过促进组件之间的松耦合交互，提高了系统的响应性和可伸缩性。它允许系统更灵活地处理大量并发事件，而不会受到单点故障的影响。水平扩展和垂直扩展是两种主要的系统扩展策略，它们可以用来应对不同的性能和资源需求。水平扩展通过增加更多的处理节点来提升系统的并发处理能力，而垂直扩展则通过增强单个节点的资源来提升其处理能力。选择合适的扩展策略取决于应用程序的需求、成本考虑以及预期的负载增长。</p><h3 id="边缘加速器的正确使用（例如，内容分发网络-CDN-）"><a href="#边缘加速器的正确使用（例如，内容分发网络-CDN-）" class="headerlink" title="边缘加速器的正确使用（例如，内容分发网络 [CDN]）"></a>边缘加速器的正确使用（例如，内容分发网络 [CDN]）</h3><h4 id="边缘加速器的概念"><a href="#边缘加速器的概念" class="headerlink" title="边缘加速器的概念"></a>边缘加速器的概念</h4><p>边缘加速器，如内容分发网络（CDN），是一种分布式网络基础设施，用于通过在全球多个地点缓存内容来加快内容的交付速度。CDN 的工作机制是将内容复制到距离用户更近的服务器上，从而减少数据传输的延迟，提高访问速度和用户体验。</p><h5 id="CDN的工作原理"><a href="#CDN的工作原理" class="headerlink" title="CDN的工作原理"></a>CDN的工作原理</h5><ul><li><strong>缓存静态资源</strong>：将网站的静态资源（如图片、CSS、JavaScript文件）缓存到全球分布的边缘节点。</li><li><strong>内容复制</strong>：根据用户的地理位置，从最近的边缘节点提供内容，减少数据旅行的距离。</li><li><strong>负载均衡</strong>：动态地将用户请求分配到最近或响应最快的边缘节点。</li></ul><h4 id="正确使用CDN"><a href="#正确使用CDN" class="headerlink" title="正确使用CDN"></a>正确使用CDN</h4><p>使用CDN时，需要考虑资源的缓存策略、内容的更新频率以及如何确保内容的安全性和合规性。</p><h5 id="缓存策略-1"><a href="#缓存策略-1" class="headerlink" title="缓存策略"></a>缓存策略</h5><ul><li><strong>设置合理的缓存时间</strong>：为不同类型的资源设置适当的缓存时间（TTL），以优化性能和更新频率之间的平衡。</li><li><strong>版本控制</strong>：使用资源版本控制，如文件指纹（hash），以确保更新后的内容能够被用户及时获取。</li></ul><h6 id="实践步骤-70"><a href="#实践步骤-70" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>为网站上的静态资源配置CDN。</li><li>设置缓存头信息，如<code>Cache-Control</code>，以控制资源在CDN节点的缓存时间。</li><li>当资源更新时，更改资源的文件名或添加查询字符串，以使缓存失效。</li></ol><h5 id="内容更新"><a href="#内容更新" class="headerlink" title="内容更新"></a>内容更新</h5><ul><li><strong>即时清除缓存</strong>：当内容更新时，使用CDN提供的清除缓存的功能，以确保用户能够访问到最新的内容。</li><li><strong>预缓存新内容</strong>：在发布新内容前，预先将其推送到CDN节点，以加快首次访问速度。</li></ul><h6 id="实践步骤-71"><a href="#实践步骤-71" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>配置CDN的缓存清除机制，以便在内容更新时能够快速清除旧版本。</li><li>利用CDN的API或控制面板来管理缓存和预加载新内容。</li></ol><h5 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h5><ul><li><strong>使用HTTPS</strong>：确保CDN节点支持HTTPS，加密用户和CDN之间的数据传输。</li><li><strong>遵守数据合规</strong>：选择支持数据地理位置合规的CDN提供商，尤其是在处理有地理位置限制的内容时。</li></ul><h6 id="实践步骤-72"><a href="#实践步骤-72" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>启用CDN的SSL/TLS功能，为所有缓存内容提供HTTPS加密。</li><li>确保CDN提供商符合地区的数据保护法规，如GDPR。</li></ol><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>正确使用CDN可以显著提升网站的加载速度和用户体验，同时减轻原始服务器的负载。为了最大化CDN的效果，应当设计合理的缓存策略，确保内容的及时更新，并且遵循最佳的安全和合规实践。通过这些步骤，可以确保内容以最高效和最安全的方式分发给全球的用户。</p><h3 id="将应用程序迁移到容器中"><a href="#将应用程序迁移到容器中" class="headerlink" title="将应用程序迁移到容器中"></a>将应用程序迁移到容器中</h3><h4 id="将应用程序迁移到容器中的概念"><a href="#将应用程序迁移到容器中的概念" class="headerlink" title="将应用程序迁移到容器中的概念"></a>将应用程序迁移到容器中的概念</h4><p>将应用程序迁移到容器中是一种将应用程序与其依赖项打包在一起的方式，以便在不同的环境中进行部署和运行。容器化应用程序具有独立性、可移植性和可扩展性，使得应用程序的部署和管理更加简化和灵活。</p><h5 id="容器化的工作原理"><a href="#容器化的工作原理" class="headerlink" title="容器化的工作原理"></a>容器化的工作原理</h5><ul><li><strong>容器引擎</strong>：使用容器引擎（如Docker）创建和管理容器。</li><li><strong>容器镜像</strong>：将应用程序及其依赖项打包为容器镜像，其中包含了应用程序运行所需的一切。</li><li><strong>容器运行时</strong>：将容器镜像部署到容器运行时环境中，如Docker引擎，以便在不同的主机上运行。</li></ul><h4 id="将应用程序迁移到容器中的步骤"><a href="#将应用程序迁移到容器中的步骤" class="headerlink" title="将应用程序迁移到容器中的步骤"></a>将应用程序迁移到容器中的步骤</h4><h5 id="1-容器化应用程序"><a href="#1-容器化应用程序" class="headerlink" title="1. 容器化应用程序"></a>1. 容器化应用程序</h5><ul><li><strong>创建Dockerfile</strong>：编写一个Dockerfile，定义如何构建容器镜像。在Dockerfile中指定应用程序的依赖项、环境变量和运行命令。</li><li><strong>构建容器镜像</strong>：使用Docker命令构建容器镜像，将Dockerfile与应用程序代码放在同一个目录中，并执行构建命令。</li></ul><h5 id="2-测试容器化应用程序"><a href="#2-测试容器化应用程序" class="headerlink" title="2. 测试容器化应用程序"></a>2. 测试容器化应用程序</h5><ul><li><strong>本地测试</strong>：在本地环境中使用Docker运行容器镜像，确保应用程序能够在容器中正常运行。</li><li><strong>验证功能</strong>：测试应用程序的功能和性能，确保在容器中的运行与原始环境中一致。</li></ul><h5 id="3-配置容器编排工具"><a href="#3-配置容器编排工具" class="headerlink" title="3. 配置容器编排工具"></a>3. 配置容器编排工具</h5><ul><li><strong>选择容器编排工具</strong>：选择适合的容器编排工具（如Kubernetes），用于管理和编排容器集群。</li><li><strong>配置集群</strong>：根据应用程序的需求，配置容器编排工具以创建、扩展和管理容器集群。</li></ul><h5 id="4-部署容器化应用程序"><a href="#4-部署容器化应用程序" class="headerlink" title="4. 部署容器化应用程序"></a>4. 部署容器化应用程序</h5><ul><li><strong>创建容器编排文件</strong>：编写容器编排文件（如Kubernetes的YAML文件），描述应用程序的部署配置和资源要求。</li><li><strong>部署应用程序</strong>：使用容器编排工具部署应用程序，将容器镜像部署到容器集群中的节点上。</li></ul><h5 id="5-监控和管理容器化应用程序"><a href="#5-监控和管理容器化应用程序" class="headerlink" title="5. 监控和管理容器化应用程序"></a>5. 监控和管理容器化应用程序</h5><ul><li><strong>监控应用程序</strong>：配置监控工具，监视容器化应用程序的性能和运行状态。</li><li><strong>容器管理</strong>：使用容器编排工具管理容器集群，包括扩展、缩减、更新和回滚应用程序。</li></ul><h4 id="容器化应用程序的最佳实践"><a href="#容器化应用程序的最佳实践" class="headerlink" title="容器化应用程序的最佳实践"></a>容器化应用程序的最佳实践</h4><ul><li><strong>最小化容器镜像</strong>：确保容器镜像尽可能小，只包含应用程序运行所需的依赖项。</li><li><strong>使用版本控制</strong>：将应用程序代码和Dockerfile纳入版本控制，以便跟踪和管理变更。</li><li><strong>配置环境变量</strong>：使用环境变量来传递应用程序的配置，以便在不同环境中进行配置更改。</li><li><strong>持久化数据</strong>：将应用程序生成的数据存储在持久化存储卷或外部存储中，以便在容器重新启动时不丢失数据。</li></ul><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>将应用程序迁移到容器中可以提供更好的应用程序管理和部署方式。通过容器化，应用程序可以更加独立、可移植和可扩展。迁移到容器中的步骤包括容器化应用程序、测试容器化应用程序、配置容器编排工具、部署容器化应用程序以及监控和管理容器化应用程序。遵循最佳实践原则，可以确保容器化应用程序的高效性和可靠性。</p><h3 id="负载均衡概念（例如，Application-Load-Balancer）"><a href="#负载均衡概念（例如，Application-Load-Balancer）" class="headerlink" title="负载均衡概念（例如，Application Load Balancer）"></a>负载均衡概念（例如，Application Load Balancer）</h3><h4 id="负载均衡的概念"><a href="#负载均衡的概念" class="headerlink" title="负载均衡的概念"></a>负载均衡的概念</h4><p>负载均衡是一种在多个服务器之间分配工作负载的技术，以提高应用程序的可用性、性能和可扩展性。负载均衡器（Load Balancer）作为中间层，接收客户端请求并将其分发到后端服务器，以确保请求能够被高效地处理。</p><h5 id="负载均衡的工作原理"><a href="#负载均衡的工作原理" class="headerlink" title="负载均衡的工作原理"></a>负载均衡的工作原理</h5><ul><li><strong>请求分发</strong>：负载均衡器接收客户端请求，并根据特定的算法将请求分发到后端服务器。</li><li><strong>流量管理</strong>：负载均衡器监控后端服务器的负载情况，并根据负载情况动态地分配请求，以确保各个服务器的负载均衡。</li><li><strong>故障处理</strong>：负载均衡器检测后端服务器的健康状态，并自动将请求从故障服务器转发到正常的服务器上。</li></ul><h4 id="Application-Load-Balancer（应用程序负载均衡器）的概念"><a href="#Application-Load-Balancer（应用程序负载均衡器）的概念" class="headerlink" title="Application Load Balancer（应用程序负载均衡器）的概念"></a>Application Load Balancer（应用程序负载均衡器）的概念</h4><p>Application Load Balancer（ALB）是云平台（如AWS）上的一种负载均衡服务，专门用于分发应用程序流量。ALB能够根据请求的内容和上下文信息，智能地将请求分发到不同的后端服务器上。</p><h5 id="ALB的特点和功能"><a href="#ALB的特点和功能" class="headerlink" title="ALB的特点和功能"></a>ALB的特点和功能</h5><ul><li><strong>应用层负载均衡</strong>：ALB在应用层（第7层）进行负载均衡，可以根据请求的内容进行路由和转发。</li><li><strong>多协议支持</strong>：ALB支持HTTP、HTTPS和WebSocket等多种协议。</li><li><strong>容器集成</strong>：ALB可以与容器服务（如ECS、EKS）集成，实现自动服务发现和动态端口映射。</li><li><strong>SSL/TLS终止</strong>：ALB可以终止SSL/TLS连接，并将请求以明文形式转发给后端服务器。</li><li><strong>身份验证和授权</strong>：ALB支持基于身份验证和授权的访问控制，以保护应用程序的安全性。</li></ul><h4 id="使用Application-Load-Balancer的步骤"><a href="#使用Application-Load-Balancer的步骤" class="headerlink" title="使用Application Load Balancer的步骤"></a>使用Application Load Balancer的步骤</h4><h5 id="1-创建Application-Load-Balancer"><a href="#1-创建Application-Load-Balancer" class="headerlink" title="1. 创建Application Load Balancer"></a>1. 创建Application Load Balancer</h5><ul><li><strong>配置监听器</strong>：定义负载均衡器监听的端口和协议（如HTTP或HTTPS）。</li><li><strong>配置目标组</strong>：创建目标组，指定后端服务器的信息（如IP地址和端口）。</li></ul><h5 id="2-配置目标组"><a href="#2-配置目标组" class="headerlink" title="2. 配置目标组"></a>2. 配置目标组</h5><ul><li><strong>添加后端服务器</strong>：将后端服务器添加到目标组中，以便负载均衡器将请求分发到这些服务器上。</li><li><strong>配置健康检查</strong>：定义健康检查规则，用于监测后端服务器的健康状态。</li></ul><h5 id="3-配置路由规则"><a href="#3-配置路由规则" class="headerlink" title="3. 配置路由规则"></a>3. 配置路由规则</h5><ul><li><strong>创建规则</strong>：定义路由规则，根据请求的路径、主机名或其他条件将请求转发到相应的目标组。</li><li><strong>配置目标组权重</strong>：根据服务器的性能和资源配置，调整目标组的权重，以实现负载均衡。</li></ul><h5 id="4-监控和调优"><a href="#4-监控和调优" class="headerlink" title="4. 监控和调优"></a>4. 监控和调优</h5><ul><li><strong>监控负载均衡器</strong>：使用云平台提供的监控工具，监测负载均衡器的性能和可用性。</li><li><strong>调整负载均衡策略</strong>：根据实际情况，调整负载均衡器的算法和配置，以满足应用程序的需求。</li></ul><h4 id="Application-Load-Balancer的最佳实践"><a href="#Application-Load-Balancer的最佳实践" class="headerlink" title="Application Load Balancer的最佳实践"></a>Application Load Balancer的最佳实践</h4><ul><li><strong>多区域部署</strong>：将负载均衡器部署在多个区域，以提高应用程序的冗余性和可用性。</li><li><strong>安全性配置</strong>：启用SSL/TLS终止，使用安全证书保护数据传输。</li><li><strong>优化目标组</strong>：根据应用程序的特点和负载情况，调整目标组的健康检查设置和目标服务器权重。</li><li><strong>日志记录和监控</strong>：启用负载均衡器的日志记录和监控功能，以便及时发现和解决问题。</li></ul><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>Application Load Balancer（应用程序负载均衡器）是一种用于分发应用程序流量的负载均衡服务。通过配置监听器、目标组和路由规则，可以实现请求的智能分发和负载均衡。使用ALB可以提高应用程序的可用性、性能和可扩展性。在使用ALB时，应遵循最佳实践，以确保负载均衡器的安全性和高效性。</p><h3 id="多层架构"><a href="#多层架构" class="headerlink" title="多层架构"></a>多层架构</h3><h4 id="多层架构的概念"><a href="#多层架构的概念" class="headerlink" title="多层架构的概念"></a>多层架构的概念</h4><p>多层架构是一种软件设计模式，将应用程序分为多个层级，每个层级负责不同的功能和责任。每个层级都有明确定义的接口，层与层之间通过接口进行通信和交互。多层架构的目标是实现分离关注点、提高可维护性和可扩展性。</p><h5 id="多层架构的层级"><a href="#多层架构的层级" class="headerlink" title="多层架构的层级"></a>多层架构的层级</h5><ul><li><strong>表示层</strong>：负责处理用户界面和用户交互，将用户请求传递给下一层处理，并将处理结果呈现给用户。</li><li><strong>应用层</strong>：包含应用程序的业务逻辑和处理规则，负责协调各个层级的工作，并处理业务逻辑。</li><li><strong>领域层</strong>：包含应用程序的核心业务逻辑和业务实体，负责处理业务规则和数据验证。</li><li><strong>数据访问层</strong>：负责与数据存储交互，包括数据库访问、数据持久化和数据操作。</li></ul><h4 id="多层架构的优势"><a href="#多层架构的优势" class="headerlink" title="多层架构的优势"></a>多层架构的优势</h4><p>多层架构具有以下优势：</p><ul><li><strong>分离关注点</strong>：不同层级负责不同的功能，使得代码易于理解、维护和扩展。</li><li><strong>可测试性</strong>：每个层级都可以独立进行单元测试，方便进行测试和调试。</li><li><strong>可扩展性</strong>：每个层级可以独立进行扩展，增加新的功能或修改现有功能。</li><li><strong>可维护性</strong>：各个层级之间的松耦合性使得代码的修改和维护更加容易。</li><li><strong>团队协作</strong>：不同的开发团队可以同时开发不同的层级，提高开发效率。</li></ul><h4 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h4><p>表示层负责处理用户界面和用户交互，将用户的请求传递给下一层处理，并将处理结果呈现给用户。</p><p>表示层的功能包括：</p><ul><li><strong>用户界面</strong>：设计和开发用户界面，包括网页、移动应用等。</li><li><strong>用户输入处理</strong>：接收用户的输入请求，验证和解析用户输入。</li><li><strong>用户输出呈现</strong>：将处理结果呈现给用户，生成并发送响应。</li></ul><h4 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h4><p>应用层包含应用程序的业务逻辑和处理规则，负责协调各个层级的工作，并处理业务逻辑。</p><p>应用层的功能包括：</p><ul><li><strong>业务逻辑处理</strong>：实现应用程序的业务规则和处理逻辑。</li><li><strong>协调层级</strong>：协调表示层、领域层和数据访问层之间的交互和通信。</li><li><strong>异常处理</strong>：处理和管理应用程序的异常情况。</li></ul><h4 id="领域层（Domain-Layer）"><a href="#领域层（Domain-Layer）" class="headerlink" title="领域层（Domain Layer）"></a>领域层（Domain Layer）</h4><p>领域层包含应用程序的核心业务逻辑和业务实体，负责处理业务规则和数据验证。</p><p>领域层的功能包括：</p><ul><li><strong>业务实体</strong>：定义和实现业务实体，包括对象和数据模型。</li><li><strong>业务规则</strong>：实现业务规则和业务逻辑，确保数据的有效性和一致性。</li><li><strong>数据验证</strong>：验证和验证输入数据的有效性和完整性。</li></ul><h4 id="数据访问层（Data-Access-Layer）"><a href="#数据访问层（Data-Access-Layer）" class="headerlink" title="数据访问层（Data Access Layer）"></a>数据访问层（Data Access Layer）</h4><p>数据访问层负责与数据存储交互，包括数据库访问、数据持久化和数据操作。</p><p>数据访问层的功能包括：</p><ul><li><strong>数据库访问</strong>：与数据库进行交互，执行数据查询、插入、更新和删除操作。</li><li><strong>数据持久化</strong>：将数据持久化到数据库或其他数据存储介质中。</li><li><strong>数据操作</strong>：封装对数据的操作，提供高层次的数据访问接口。</li></ul><h4 id="多层架构的最佳实践"><a href="#多层架构的最佳实践" class="headerlink" title="多层架构的最佳实践"></a>多层架构的最佳实践</h4><ul><li><strong>单一职责原则</strong>：每个层级应该具有清晰的职责和功能，避免功能交叉和混乱。</li><li><strong>松耦合</strong>：各个层级之间应该松散耦合，通过接口进行通信，降低依赖性。</li><li><strong>抽象和封装</strong>：使用接口和抽象类来定义层级之间的交互和通信。</li><li><strong>分层架构图</strong>：绘制和维护分层架构图，以便开发人员理解和遵循架构设计。</li><li><strong>测试驱动开发</strong>：每个层级都应该进行单元测试，确保各个层级的功能和交互正常。</li></ul><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>多层架构将应用程序分为表示层、应用层、领域层和数据访问层，每个层级负责不同的功能和责任。多层架构的优势包括分离关注点、</p><h3 id="队列和消息收发概念（例如，发布-订阅）"><a href="#队列和消息收发概念（例如，发布-订阅）" class="headerlink" title="队列和消息收发概念（例如，发布/订阅）"></a>队列和消息收发概念（例如，发布/订阅）</h3><h4 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h4><p>队列是一种常用的数据结构，用于存储和管理元素。它遵循先进先出（FIFO）的原则，即先进入队列的元素将首先被处理，后进入队列的元素将在后续被处理。</p><p>队列的操作包括：</p><ul><li><strong>入队（Enqueue）</strong>：将元素添加到队列的末尾。</li><li><strong>出队（Dequeue）</strong>：从队列的头部移除并返回元素。</li><li><strong>查看队头元素（Peek）</strong>：查看队列头部的元素，但不将其移除。</li></ul><p>队列常用于处理异步任务、消息传递和事件处理等场景，其中消息收发是队列的一个重要应用。</p><h4 id="消息收发的概念"><a href="#消息收发的概念" class="headerlink" title="消息收发的概念"></a>消息收发的概念</h4><p>消息收发是一种用于在分布式系统中进行通信的模式。在消息收发模式中，消息发送者将消息发送到消息队列，而消息接收者从队列中接收和处理消息。</p><h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h5><p>发布/订阅（Publish/Subscribe）是一种常见的消息收发模式。在发布/订阅模式中，消息发送者（发布者）将消息发布到特定的主题（Topic），而消息接收者（订阅者）订阅感兴趣的主题，从而接收与该主题相关的消息。</p><p>发布/订阅模式的特点包括：</p><ul><li><strong>解耦性</strong>：发布者和订阅者之间是松耦合的，彼此不需要直接知道对方的存在。</li><li><strong>灵活性</strong>：发布者可以将消息发布到多个主题，订阅者可以订阅多个主题。</li><li><strong>扩展性</strong>：可以动态地添加新的发布者和订阅者，扩展系统的功能和规模。</li></ul><h4 id="使用队列和发布-订阅模式的步骤"><a href="#使用队列和发布-订阅模式的步骤" class="headerlink" title="使用队列和发布/订阅模式的步骤"></a>使用队列和发布/订阅模式的步骤</h4><h5 id="1-创建消息队列"><a href="#1-创建消息队列" class="headerlink" title="1. 创建消息队列"></a>1. 创建消息队列</h5><ul><li><strong>选择消息队列系统</strong>：选择适合你的需求的消息队列系统，如RabbitMQ、Apache Kafka等。</li><li><strong>配置消息队列</strong>：创建消息队列，设置队列的属性和参数。</li></ul><h5 id="2-定义消息格式和主题"><a href="#2-定义消息格式和主题" class="headerlink" title="2. 定义消息格式和主题"></a>2. 定义消息格式和主题</h5><ul><li><strong>消息格式</strong>：定义消息的结构和内容，包括消息的字段和数据类型。</li><li><strong>主题</strong>：定义不同的主题，用于区分不同类型的消息。</li></ul><h5 id="3-发布消息"><a href="#3-发布消息" class="headerlink" title="3. 发布消息"></a>3. 发布消息</h5><ul><li><strong>创建发布者</strong>：创建发布者应用程序，连接到消息队列。</li><li><strong>选择主题</strong>：选择要发布的消息主题。</li><li><strong>构造消息</strong>：构造消息，填充消息的内容和字段。</li><li><strong>发布消息</strong>：将消息发布到消息队列的指定主题。</li></ul><h5 id="4-订阅消息"><a href="#4-订阅消息" class="headerlink" title="4. 订阅消息"></a>4. 订阅消息</h5><ul><li><strong>创建订阅者</strong>：创建订阅者应用程序，连接到消息队列。</li><li><strong>选择订阅的主题</strong>：选择要订阅的消息主题。</li><li><strong>接收消息</strong>：订阅者从消息队列接收与其订阅的主题相关的消息。</li><li><strong>处理消息</strong>：订阅者处理接收到的消息，执行相应的操作。</li></ul><h4 id="队列和消息收发的最佳实践"><a href="#队列和消息收发的最佳实践" class="headerlink" title="队列和消息收发的最佳实践"></a>队列和消息收发的最佳实践</h4><ul><li><strong>消息持久化</strong>：确保消息在发送和接收过程中的持久化存储，以防止消息丢失。</li><li><strong>消息确认机制</strong>：使用消息确认机制，确保消息在发送和接收之间的可靠传递。</li><li><strong>消息序列化</strong>：对消息进行序列化和反序列化，以便在不同的应用程序和平台之间进行通信。</li><li><strong>错误处理和重试</strong>：处理发送和接收消息过程中的错误，并实现适当的重试机制。</li><li><strong>监控和日志记录</strong>：监控消息队列的性能和可用性，并记录相关的日志信息。</li></ul><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>队列是一种先进先出的数据结构，常用于存储和管理元素。消息收发是一种在分布式系统中进行通信的模式，其中发布/订阅是常见的消息收发模式。使用队列和发布/订阅模式可以实现异步任务处理、消息传递和事件处理等功能</p><h3 id="无服务器技术和模式（例如，AWS-Fargate、AWS-Lambda）"><a href="#无服务器技术和模式（例如，AWS-Fargate、AWS-Lambda）" class="headerlink" title="无服务器技术和模式（例如，AWS Fargate、AWS Lambda）"></a>无服务器技术和模式（例如，AWS Fargate、AWS Lambda）</h3><ul><li><h4 id="无服务器技术和模式概述"><a href="#无服务器技术和模式概述" class="headerlink" title="无服务器技术和模式概述"></a>无服务器技术和模式概述</h4><p>无服务器技术是一种云计算模型，它使开发人员能够构建和运行应用程序，而无需关注底层的服务器管理和维护。无服务器模式基于事件驱动的架构，可以根据需要自动扩展和收缩资源，以满足应用程序的需求。AWS（亚马逊网络服务）提供了多种无服务器服务，其中包括AWS Fargate和AWS Lambda。</p><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>AWS Fargate是一种无服务器容器计算引擎，允许开发人员在无需管理服务器的情况下运行容器化的应用程序。它提供了一种简化的方式来部署和管理容器，使开发人员可以专注于应用程序的开发和部署，而无需关注底层的基础设施。</p><h5 id="主要特性和用途"><a href="#主要特性和用途" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无服务器容器</strong>：AWS Fargate允许开发人员以无服务器的方式运行容器，无需管理底层的服务器资源。</li><li><strong>按需计费</strong>：AWS Fargate按实际使用的资源进行计费，可以根据应用程序的需求自动扩展和收缩容器。</li><li><strong>与其他AWS服务集成</strong>：AWS Fargate可以与其他AWS服务集成，如Amazon ECS（Elastic Container Service）和Amazon ECR（Elastic Container Registry），以构建完整的容器解决方案。</li></ul><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建任务定义</strong>：定义容器的规格、映像和其他配置。</li><li><strong>创建集群</strong>：创建一个容器集群，用于托管和管理容器实例。</li><li><strong>启动任务</strong>：将任务定义部署到集群中，启动容器实例。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理容器实例，进行日志记录、扩展和更新等操作。</li></ol><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>AWS Lambda是一种无服务器计算服务，以事件驱动的方式运行代码。开发人员可以编写函数并将其上传到AWS Lambda，然后在需要时自动触发执行函数。AWS Lambda负责管理底层的计算资源，使开发人员可以专注于编写业务逻辑。</p><h5 id="主要特性和用途-1"><a href="#主要特性和用途-1" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无服务器计算</strong>：AWS Lambda以无服务器的方式运行代码，无需管理底层的服务器。</li><li><strong>按需计费</strong>：AWS Lambda按代码的实际执行时间和资源使用进行计费，没有持续运行的费用。</li><li><strong>自动扩展</strong>：AWS Lambda根据请求的数量和负载自动扩展和收缩资源。</li><li><strong>与其他AWS服务集成</strong>：AWS Lambda可以与其他AWS服务集成，如API网关、S3、DynamoDB等，以构建强大的无服务器应用程序。</li></ul><h5 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>编写函数</strong>：编写函数代码，处理特定的事件或请求。</li><li><strong>创建Lambda函数</strong>：使用AWS管理控制台或CLI工具创建Lambda函数，并上传函数代码。</li><li><strong>配置触发器</strong>：配置触发器，指定何时触发函数的执行，如API调用、定时任务或其他事件。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理Lambda函数，查看执行日志、设置权限和调整函数配置等操作。</li></ol><h4 id="无服务器技术的最佳实践"><a href="#无服务器技术的最佳实践" class="headerlink" title="无服务器技术的最佳实践"></a>无服务器技术的最佳实践</h4><ul><li><strong>函数拆分</strong>：将应用程序拆分为多个小型函数，以提高可维护性和扩展性。</li><li><strong>状态管理</strong>：避免在函数之间共享状态，使用无状态函数设计，将状态存储在外部服务中。</li><li><strong>日志和监控</strong>：记录函数的执行日志，并使用监控工具来监视函数的性能和可用性。</li><li><strong>安全性</strong>：实施适当的安全措施，如函数级别的访问控制、数据加密和网络安全配置。</li><li><strong>测试和部署</strong>：编写自动化测试用例，使用持续集成和部署工具来自动部署和更新函数。</li></ul><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>无服务器技术和模式使开发人员能够构建和运行应用程序，而无需关注底层的服务器管理和维护。AWS Fargate是一种无服务器容器计算引擎，允许无服务器地运行容器化的应用程序。AWS Lambda是一种无服务器计算服务，以事件驱动的方式运行代码。无服务器技术的最佳实践包括函数拆分、状态管理、日志和监控、安全性以及测试和部署。</p></li></ul><h3 id="具有相关特性的存储类型（例如，对象、文件、数据块）"><a href="#具有相关特性的存储类型（例如，对象、文件、数据块）" class="headerlink" title="具有相关特性的存储类型（例如，对象、文件、数据块）"></a>具有相关特性的存储类型（例如，对象、文件、数据块）</h3><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>对象存储是一种存储数据的方式，它以对象的形式存储数据和元数据，并提供简单的API来管理和访问数据。</p><h5 id="主要特性和用途-2"><a href="#主要特性和用途-2" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无限扩展</strong>：对象存储可以存储大规模的数据，具有无限的扩展性。</li><li><strong>高可用性</strong>：对象存储通常具有高可用性，数据会自动在多个地理位置进行复制和冗余存储。</li><li><strong>持久性</strong>：对象存储数据通常是持久的，不容易丢失。</li><li><strong>适用于大文件和多媒体</strong>：对象存储适用于存储大型文件和多媒体内容，如图像、视频和音频文件。</li><li><strong>与其他服务集成</strong>：对象存储可以与其他服务集成，如CDN、数据分析和备份服务。</li></ul><h5 id="示例服务"><a href="#示例服务" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon S3</strong>：亚马逊简单存储服务（Amazon S3）是一种对象存储服务，用于在亚马逊云上存储和检索数据。它是一种高度可扩展、持久性强的存储解决方案，广泛用于各种应用程序和场景。</li></ul><h4 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h4><p>文件存储是一种存储数据的方式，它以文件的形式存储数据，并提供文件系统接口来管理和访问数据。</p><h5 id="主要特性和用途-3"><a href="#主要特性和用途-3" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>文件系统接口</strong>：文件存储提供类似于传统文件系统的接口，如读取、写入和删除文件。</li><li><strong>适用于结构化数据</strong>：文件存储适用于存储结构化的数据，如文本文件、配置文件和日志文件。</li><li><strong>共享访问</strong>：多个应用程序或用户可以共享访问文件存储中的数据。</li><li><strong>与现有应用程序兼容</strong>：文件存储可以与现有的应用程序和工具集成，无需进行大规模的代码更改。</li></ul><h5 id="示例服务-1"><a href="#示例服务-1" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon EFS</strong>：亚马逊弹性文件系统（Amazon EFS）是一种可扩展的、共享的文件存储服务，用于在亚马逊云上存储和访问文件数据。它提供标准文件系统接口，可以与多个EC2实例共享访问。</li></ul><h4 id="数据块存储"><a href="#数据块存储" class="headerlink" title="数据块存储"></a>数据块存储</h4><p>数据块存储是一种存储数据的方式，它将数据划分为固定大小的数据块，并使用唯一的标识符来管理和访问这些数据块。</p><h5 id="主要特性和用途-4"><a href="#主要特性和用途-4" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>低延迟</strong>：数据块存储通常具有低延迟的读写操作，适用于需要快速访问的应用程序。</li><li><strong>随机访问</strong>：可以随机访问数据块，而不需要读取整个文件或对象。</li><li><strong>适用于数据库和应用程序</strong>：数据块存储适用于存储数据库和应用程序的数据，如关系数据库和分布式文件系统。</li></ul><h5 id="示例服务-2"><a href="#示例服务-2" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon EBS</strong>：亚马逊弹性块存储（Amazon EBS）是一种持久性块存储服务，用于在亚马逊云上附加和使用块级存储卷。它提供低延迟的随机访问，并可与EC2实例进行关联。</li></ul><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p>存储类型包括对象存储、文件存储和数据块存储。对象存储适用于存储大规模数据和多媒体内容，如Amazon S3。文件存储适用于结构化数据和共享访问，如Amazon EFS。数据块存储适用于低延迟和随机访问的应用程序，如Amazon EBS。选择适当的存储类型取决于应用程序的需求和数据的特性。</p><h3 id="容器编排（例如，Amazon-Elastic-Container-Service-Amazon-ECS-、Amazon-Elastic-Kubernetes-Service-Amazon-EKS-）"><a href="#容器编排（例如，Amazon-Elastic-Container-Service-Amazon-ECS-、Amazon-Elastic-Kubernetes-Service-Amazon-EKS-）" class="headerlink" title="容器编排（例如，Amazon Elastic Container Service [Amazon ECS]、Amazon Elastic Kubernetes Service [Amazon EKS]）"></a>容器编排（例如，Amazon Elastic Container Service [Amazon ECS]、Amazon Elastic Kubernetes Service [Amazon EKS]）</h3><h4 id="容器编排概述"><a href="#容器编排概述" class="headerlink" title="容器编排概述"></a>容器编排概述</h4><p>容器编排是一种管理和调度容器化应用程序的技术，它可以帮助开发人员自动化容器的部署、扩展和管理。容器编排工具提供了一种简化的方式来定义、组织和运行容器，以便应用程序能够高效地运行在分布式环境中。AWS（亚马逊网络服务）提供了多种容器编排服务，其中包括Amazon Elastic Container Service（Amazon ECS）和Amazon Elastic Kubernetes Service（Amazon EKS）。</p><h4 id="Amazon-Elastic-Container-Service（Amazon-ECS）"><a href="#Amazon-Elastic-Container-Service（Amazon-ECS）" class="headerlink" title="Amazon Elastic Container Service（Amazon ECS）"></a>Amazon Elastic Container Service（Amazon ECS）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>Amazon Elastic Container Service（Amazon ECS）是一种高度可扩展的容器编排服务，用于在AWS云上运行和管理容器化应用程序。它提供了一种简单的方式来部署、运行和扩展容器，同时具备高可用性和可靠性。</p><h5 id="主要特性和用途-5"><a href="#主要特性和用途-5" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>托管容器</strong>：Amazon ECS允许开发人员将容器化的应用程序部署到托管的集群中，无需关注底层的基础设施。</li><li><strong>自动扩展</strong>：Amazon ECS可以根据应用程序的负载自动扩展和收缩容器实例，以确保应用程序的性能和可用性。</li><li><strong>与其他AWS服务集成</strong>：Amazon ECS可以与其他AWS服务集成，如Amazon EC2（Elastic Compute Cloud）、Amazon S3（Simple Storage Service）和Amazon VPC（Virtual Private Cloud），以构建完整的应用程序解决方案。</li><li><strong>任务定义和服务</strong>：通过任务定义和服务，可以定义容器的规格、映像和其他配置，并确保容器的持续运行和自动恢复。</li></ul><h5 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建集群</strong>：创建一个Amazon ECS集群，用于托管和管理容器实例。</li><li><strong>定义任务</strong>：创建一个任务定义，定义容器的规格、映像和其他配置。</li><li><strong>启动任务</strong>：使用任务定义创建一个任务，并将其部署到集群中，启动容器实例。</li><li><strong>创建服务</strong>：创建一个服务，指定任务的副本数和负载均衡策略，以确保容器的持续运行和自动恢复。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理容器实例和服务，进行日志记录、扩展和更新等操作。</li></ol><h4 id="Amazon-Elastic-Kubernetes-Service（Amazon-EKS）"><a href="#Amazon-Elastic-Kubernetes-Service（Amazon-EKS）" class="headerlink" title="Amazon Elastic Kubernetes Service（Amazon EKS）"></a>Amazon Elastic Kubernetes Service（Amazon EKS）</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>Amazon Elastic Kubernetes Service（Amazon EKS）是一种托管的Kubernetes服务，用于在AWS云上运行和管理Kubernetes容器编排平台。它提供了一个高度可扩展、安全和可靠的方式来部署和管理容器化应用程序。</p><h5 id="主要特性和用途-6"><a href="#主要特性和用途-6" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>托管Kubernetes集群</strong>：Amazon EKS提供了一个托管的Kubernetes控制平面，负责管理和调度容器化应用程序。</li><li><strong>自动扩展</strong>：Amazon EKS可以根据应用程序的负载自动扩展和收缩Kubernetes节点，以满足应用程序的需求。</li><li><strong>与其他AWS服务集成</strong>：Amazon EKS可以与其他AWS服务集成，如Amazon EC2、Amazon S3和Amazon VPC，以构建强大的容器化应用程序解决方案。</li><li><strong>Kubernetes生态系统</strong>：Amazon EKS与Kubernetes生态系统紧密集成，可以使用Kubernetes的丰富功能和工具来部署和管理应用程序。</li></ul><h5 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建集群</strong>：创建一个Amazon EKS集群，该集群将作为Kubernetes控制平面的托管环境。</li><li><strong>配置kubectl</strong>：配置kubectl命令行工具，以便与Amazon EKS集群进行通信。</li><li><strong>部署应用程序</strong>：使用Kubernetes清单文件定义和部署应用程序的Pod、服务和其他资源。</li><li><strong>扩展和管理</strong>：使用kubectl命令行工具或Kubernetes仪表板来扩展和管理应用程序，进行水平扩展、滚动更新和故障恢复等操作。</li><li><strong>监控和日志</strong>：使用Kubernetes的监控和日志工具，如Prometheus和Elasticsearch，来监控和记录应用程序的性能和日志。</li></ol><h4 id="容器编排的最佳实践"><a href="#容器编排的最佳实践" class="headerlink" title="容器编排的最佳实践"></a>容器编排的最佳实践</h4><ul><li><p><strong>声明式清单</strong>：使用声明式的清单文件来定义和部署应用程序，以便实现可重复、可维护和可扩展的部署。</p></li><li><p><strong>自动化部署</strong>：使用持续集成和持续部署（CI/CD）工具来自动化应用程序的</p></li><li><p>部署过程，包括构建、测试、部署和监控等环节，以提高开发和交付效率。</p><ul><li><strong>服务发现和负载均衡</strong>：使用容器编排工具提供的服务发现和负载均衡功能，以实现容器之间的通信和流量分发。</li><li><strong>弹性扩展</strong>：根据应用程序的负载情况，使用自动扩展功能来动态调整容器实例的数量，以满足需求并节省资源。</li><li><strong>安全性</strong>：实施适当的安全措施，如访问控制、网络隔离和容器映像的安全扫描，以保护容器化应用程序的安全性。</li><li><strong>日志和监控</strong>：使用日志和监控工具来收集、分析和可视化容器化应用程序的日志和性能指标，以便快速发现和解决问题。</li><li><strong>持续改进</strong>：不断优化容器编排的流程和架构，通过监控和分析数据来改进应用程序的性能、可靠性和可扩展性。</li></ul><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p>容器编排是一种管理和调度容器化应用程序的技术，可以帮助开发人员自动化容器的部署、扩展和管理。AWS提供了多种容器编排服务，包括Amazon ECS和Amazon EKS。Amazon ECS是一种高度可扩展的容器编排服务，用于在AWS云上运行和管理容器化应用程序。Amazon EKS是一种托管的Kubernetes服务，用于在AWS云上运行和管理Kubernetes容器编排平台。容器编排的最佳实践包括使用声明式清单、自动化部署、服务发现和负载均衡、弹性扩展、安全性、日志和监控以及持续改进。</p></li></ul><h3 id="何时使用只读副本"><a href="#何时使用只读副本" class="headerlink" title="何时使用只读副本"></a>何时使用只读副本</h3><h4 id="只读副本概述"><a href="#只读副本概述" class="headerlink" title="只读副本概述"></a>只读副本概述</h4><p>只读副本是数据库系统中的一种常见技术，它允许在主数据库的基础上创建一个副本，并将该副本配置为只读模式。只读副本用于提供读取性能的扩展、高可用性和冗余备份。在某些情况下，只读副本可以提供更好的性能和可用性，同时减轻主数据库的负载。</p><h4 id="何时使用只读副本-1"><a href="#何时使用只读副本-1" class="headerlink" title="何时使用只读副本"></a>何时使用只读副本</h4><p>以下是一些适合使用只读副本的情况：</p><h5 id="1-读取密集型工作负载"><a href="#1-读取密集型工作负载" class="headerlink" title="1. 读取密集型工作负载"></a>1. 读取密集型工作负载</h5><p>如果应用程序有大量的读取操作，而写入操作较少，可以考虑使用只读副本来分担主数据库的读取负载。只读副本可以处理读取请求，从而提高整体性能和响应时间。</p><h5 id="2-高可用性和容错"><a href="#2-高可用性和容错" class="headerlink" title="2. 高可用性和容错"></a>2. 高可用性和容错</h5><p>只读副本可以提供高可用性和容错能力。当主数据库发生故障或不可用时，只读副本可以继续提供读取服务，确保应用程序的连续性。这对于对可用性要求较高的关键业务非常重要。</p><h5 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3. 负载均衡"></a>3. 负载均衡</h5><p>通过将读取请求分发到多个只读副本，可以实现负载均衡，从而提高整体系统的性能和吞吐量。只读副本可以根据负载情况自动处理读取请求，减轻主数据库的负载。</p><h5 id="4-数据分析和报告"><a href="#4-数据分析和报告" class="headerlink" title="4. 数据分析和报告"></a>4. 数据分析和报告</h5><p>如果需要对数据库中的数据进行复杂的分析和报告，可以使用只读副本来执行这些任务，而不会对主数据库的性能产生负面影响。只读副本可以专门用于数据分析，提供更高的性能和资源。</p><h5 id="5-备份和恢复"><a href="#5-备份和恢复" class="headerlink" title="5. 备份和恢复"></a>5. 备份和恢复</h5><p>只读副本可以作为主数据库的冗余备份。通过定期将主数据库的数据复制到只读副本，可以确保在主数据库发生故障或数据损坏时能够快速恢复数据。</p><h4 id="部署只读副本的步骤"><a href="#部署只读副本的步骤" class="headerlink" title="部署只读副本的步骤"></a>部署只读副本的步骤</h4><p>以下是部署只读副本的一般步骤：</p><ol><li><p><strong>创建只读副本</strong>：在主数据库的基础上创建一个副本，并将其配置为只读模式。这可以通过数据库管理工具或数据库系统提供的命令来完成。</p></li><li><p><strong>配置复制</strong>：配置主数据库和只读副本之间的数据复制机制。这可以使用数据库系统提供的复制功能，如MySQL的主从复制或PostgreSQL的流复制。</p></li><li><p><strong>连接和路由</strong>：确保应用程序能够连接到只读副本并发送读取请求。这可能涉及到调整应用程序的数据库连接字符串或配置负载均衡器来路由读取请求到只读副本。</p></li><li><p><strong>监控和维护</strong>：监控只读副本的状态和性能，确保它正常工作并与主数据库保持同步。定期进行维护操作，如备份和更新，以保持只读副本的可用性和数据完整性。</p></li></ol><h4 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ul><li><p><strong>数据一致性</strong>：只读副本是通过复制主数据库的数据来实现的，因此在进行读取操作时，可能会存在一定的延迟，导致读取到的数据可能不是最新的。在应用程序中要注意处理这种数据一致性的情况。</p></li><li><p><strong>负载均衡策略</strong>：根据应用程序的读取负载情况选择合适的负载均衡策略，如轮询、最少连接等，以确保读取请求能够均衡地分发到只读副本。</p></li><li><p><strong>监控和警报</strong>：建立监控和警报系统，及时检测只读副本的状态和性能问题。监控指标可以包括副本延迟、同步状态、负载情况等。</p></li><li><p><strong>定期测试和维护</strong>：定期进行测试和维护操作，如故障切换测试、备份恢复测试和软件更新。这可以帮助确保只读副本的可用性和数据完整性。</p></li></ul><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p>只读副本是一种常见的数据库技术，用于提供读取性能的扩展、高可用性和冗余备份。适合使用只读副本的情况包括读取密集型工作负载、高可用性和容错、负载均衡、数据分析和报告以及备份和恢复。部署只读副本的步骤包括创建副本、配置复制、连接和路由以及监控和维护。在使用只读副本时，需要注意数据一致性、负载均衡策略、监控和警报以及定期测试和维护等注意事项和最佳实践。</p><h3 id="工作流编排（例如，AWS-Step-Functions）"><a href="#工作流编排（例如，AWS-Step-Functions）" class="headerlink" title="工作流编排（例如，AWS Step Functions）"></a>工作流编排（例如，AWS Step Functions）</h3><h4 id="工作流编排概述"><a href="#工作流编排概述" class="headerlink" title="工作流编排概述"></a>工作流编排概述</h4><p>工作流编排是一种将多个任务和步骤组织起来，按照特定的顺序和条件执行的技术。它可以帮助简化复杂的业务逻辑和流程，并提供可靠的执行和错误处理机制。AWS Step Functions是亚马逊云服务（AWS）提供的一项工作流编排服务，它使开发人员能够轻松地构建、部署和管理具有复杂业务逻辑的工作流应用程序。</p><h4 id="何时使用工作流编排"><a href="#何时使用工作流编排" class="headerlink" title="何时使用工作流编排"></a>何时使用工作流编排</h4><p>以下是一些适合使用工作流编排的情况：</p><h5 id="1-复杂的业务逻辑"><a href="#1-复杂的业务逻辑" class="headerlink" title="1. 复杂的业务逻辑"></a>1. 复杂的业务逻辑</h5><p>如果应用程序的业务逻辑涉及多个步骤和条件，且这些步骤需要按照特定的顺序执行，那么使用工作流编排可以帮助组织和管理这些步骤，使业务逻辑更易于理解和维护。</p><h5 id="2-异步和分布式任务"><a href="#2-异步和分布式任务" class="headerlink" title="2. 异步和分布式任务"></a>2. 异步和分布式任务</h5><p>当应用程序需要执行异步和分布式任务时，工作流编排可以帮助协调和管理这些任务的执行顺序和依赖关系。工作流编排可以处理任务的并行执行、等待和超时等复杂情况。</p><h5 id="3-错误处理和重试"><a href="#3-错误处理和重试" class="headerlink" title="3. 错误处理和重试"></a>3. 错误处理和重试</h5><p>工作流编排提供了强大的错误处理和重试机制。当任务执行失败时，工作流编排可以根据配置的错误处理策略进行相应的处理，如重试、错误通知或执行备用步骤。</p><h5 id="4-可视化和监控"><a href="#4-可视化和监控" class="headerlink" title="4. 可视化和监控"></a>4. 可视化和监控</h5><p>工作流编排通常提供可视化界面，用于可视化工作流的结构和执行状态。这可以帮助开发人员和运维团队更好地理解和监控工作流的执行情况，及时发现和解决问题。</p><h4 id="使用-AWS-Step-Functions-的步骤"><a href="#使用-AWS-Step-Functions-的步骤" class="headerlink" title="使用 AWS Step Functions 的步骤"></a>使用 AWS Step Functions 的步骤</h4><p>以下是使用AWS Step Functions进行工作流编排的一般步骤：</p><ol><li><p><strong>定义状态机</strong>：使用AWS Step Functions提供的定义语言（如Amazon States Language）来定义工作流的状态机。状态机由一系列状态和状态转换组成，每个状态代表一个任务或步骤。</p></li><li><p><strong>配置输入和输出</strong>：为工作流定义输入和输出参数，以便任务之间可以传递数据。输入参数可以是工作流的初始输入，输出参数可以是工作流的最终结果。</p></li><li><p><strong>定义状态转换</strong>：为每个状态定义状态转换条件和动作。状态转换条件可以是成功或失败的条件，动作可以是执行任务、等待、重试或跳转到其他状态。</p></li><li><p><strong>部署和执行</strong>：将定义好的状态机部署到AWS Step Functions，并通过API或控制台触发工作流的执行。工作流将按照定义的状态机和转换逻辑执行任务。</p></li><li><p><strong>监控和调试</strong>：使用AWS Step Functions提供的监控和日志功能来监控工作流的执行情况。可以查看工作流的状态、执行时间和错误信息，以及进行调试和故障排除。</p></li></ol><h4 id="注意事项和最佳实践-1"><a href="#注意事项和最佳实践-1" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ul><li><p><strong>模块化设计</strong>：将工作流分解为较小的任务和步骤，并通过模块化的方式设计状态机。这样可以提高工作流的可维护性和重用性。</p></li><li><p><strong>错误处理和重试策略</strong>：定义适当的错误处理和重试策略，以处理任务执行失败的情况。可以配置重试次数、重试间隔和备用步骤等。</p></li><li><p><strong>保持状态的幂等性</strong>：确保工作流中的任务和步骤具有幂等性，即多次执行不会产生不一致的结果。这样可以避免由于重试导致的数据重复或不一致性。</p></li><li><p><strong>监控和警报</strong>：建立监控和警报系统，及时检测工作流的执行状态和错误情况。可以使用AWS CloudWatch等服务来监控工作流的指标和日志。</p></li><li><p><strong>版本控制和回滚</strong>：对工作流的定义和配置进行版本控制，并确保可以回滚到之前的版本。这样可以方便地管理和维护工作流的变更和更新。</p></li></ul><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p>工作流编排是一种将多个任务和步骤组织起来、按照特定顺序和条件执行的技术。AWS Step Functions是一项强大的工作流编排服务，适用于复杂的业务逻辑、异步和分布式任务、错误处理和重试以及可视化和监控需求。使用AWS Step Functions的步骤包括定义状态机、配置输入和输出、定义状态转换、部署和执行以及监控和调试。在使用AWS Step Functions时，需要注意模块化设计、错误处理和重试策略、保持状态的幂等性、监控和警报以及版本控制和回滚等注意事项和最佳实践。</p><h2 id="设计高可用性架构和-或容错架构"><a href="#设计高可用性架构和-或容错架构" class="headerlink" title="设计高可用性架构和/或容错架构"></a>设计高可用性架构和/或容错架构</h2><h4 id="AWS全球基础设施"><a href="#AWS全球基础设施" class="headerlink" title="AWS全球基础设施"></a>AWS全球基础设施</h4><p>AWS全球基础设施包括多个地理区域和可用区。每个区域是一组数据中心，每个区域内的可用区则是更小的独立单元，可提供冗余和容错能力。例如，如果一个可用区出现故障，其他可用区仍能继续运行。Amazon Route 53是一种DNS服务，可以根据地理位置智能地路由用户到最近的区域。</p><h4 id="AWS-Managed-Services及其使用案例"><a href="#AWS-Managed-Services及其使用案例" class="headerlink" title="AWS Managed Services及其使用案例"></a>AWS Managed Services及其使用案例</h4><p>AWS Managed Services提供了许多托管服务，如Amazon Comprehend（一种自然语言处理服务）和Amazon Polly（一个文本转语音服务）。这些服务简化了管理任务，并提高了可用性。例如，使用Amazon Polly，你可以轻松将文本转换为语音输出，而无需深入了解语音合成技术。</p><h4 id="基本联网概念"><a href="#基本联网概念" class="headerlink" title="基本联网概念"></a>基本联网概念</h4><p>联网概念包括路由表、子网和网络ACLs等。路由表定义了网络流量如何从一个子网转移到另一个子网或外部网络。在AWS中，你可以设置路由表来指导网络流量的流向，以确保高效和安全的数据传输。</p><h4 id="灾难恢复策略"><a href="#灾难恢复策略" class="headerlink" title="灾难恢复策略"></a>灾难恢复策略</h4><p>灾难恢复策略包括备份和还原、长明灯（持续运行的最小资源）、热备用、双活故障转移等。这些策略通过定义RPO（恢复点目标）和RTO（恢复时间目标）来确保在发生灾难时数据和应用程序的快速恢复。例如，使用AWS的备份服务可以定期备份关键数据，以便在需要时迅速恢复。</p><h4 id="分布式设计模式"><a href="#分布式设计模式" class="headerlink" title="分布式设计模式"></a>分布式设计模式</h4><p>分布式设计模式涉及在多个服务器、区域或可用区中分布应用程序和数据，以提高可靠性和可用性。例如，可以在不同的AWS区域部署应用程序的副本，以防某个区域出现故障。</p><h4 id="故障转移策略"><a href="#故障转移策略" class="headerlink" title="故障转移策略"></a>故障转移策略</h4><p>故障转移策略包括自动检测故障并将流量重定向到健康的服务器或区域。例如，Amazon RDS的多可用区部署可以在主数据库故障时自动故障转移到备用数据库。</p><h4 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h4><p>不可变基础设施意味着一旦创建，资源（如服务器）就不会被更改。相反，任何更新都通过替换现有资源来实现。这减少了配置漂移和相关故障的可能性。</p><h4 id="负载均衡概念"><a href="#负载均衡概念" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h4><p>负载均衡器（如Application Load Balancer）可以在多个服务器之间分配流量，以优化性能和可用性。例如，如果一个服务器过载，负载均衡器可以将流量转移到其他较少负载的服务器。</p><h4 id="代理概念"><a href="#代理概念" class="headerlink" title="代理概念"></a>代理概念</h4><p>代理（如Amazon RDS Proxy）是一种数据库代理服务，它可以帮助管理数据库连接，提高可扩展性和可用性。它作为应用程序和数据库之间的中间层，优化连接。</p><h4 id="Service-Quotas和限流"><a href="#Service-Quotas和限流" class="headerlink" title="Service Quotas和限流"></a>Service Quotas和限流</h4><p>Service Quotas是AWS服务的使用限额。在设计容错架构时，重要的是要了解这些限额并相应地配置备用环境。限流可以帮助管理资源使用，防止系统过载。</p><h4 id="存储选项和特性"><a href="#存储选项和特性" class="headerlink" title="存储选项和特性"></a>存储选项和特性</h4><p>AWS提供多种存储选项，如EBS、S3和Glacier，每种都有不同的特</p><p>性，如持久性和复制。选择正确的存储解决方案对于确保数据的可用性和持久性至关重要。</p><h4 id="工作负载可见性"><a href="#工作负载可见性" class="headerlink" title="工作负载可见性"></a>工作负载可见性</h4><p>工具如AWS X-Ray可以提供工作负载的可见性，帮助识别和排除性能问题。它允许你跟踪请求在分布式系统中的路径，并识别瓶颈。</p><p>以上各点是设计高可用性和/或容错架构时需要掌握的关键知识点。每个点都是构建强大、可靠云基础设施的基石。</p><h2 id="确定高性能和-或可扩展的存储解决方案"><a href="#确定高性能和-或可扩展的存储解决方案" class="headerlink" title="确定高性能和/或可扩展的存储解决方案"></a>确定高性能和/或可扩展的存储解决方案</h2><h4 id="可满足业务要求的混合存储解决方案"><a href="#可满足业务要求的混合存储解决方案" class="headerlink" title="可满足业务要求的混合存储解决方案"></a>可满足业务要求的混合存储解决方案</h4><p>混合存储解决方案结合了本地存储和云存储的优势，以满足不同业务需求。例如，一个公司可能使用本地存储处理高速、低延迟的任务，同时使用云存储进行数据备份和灾难恢复。</p><ul><li><strong>本地存储</strong>: 快速访问，适用于处理大量实时数据。</li><li><strong>云存储</strong>: 可扩展性强，适合长期数据存储、共享和远程访问。</li></ul><p>案例：一个视频编辑公司可能在本地服务器上存储当前正在编辑的视频，以利用高速访问；同时，将已完成的项目存储在云中，以节省本地存储空间和便于客户访问。</p><h4 id="具有合适使用案例的存储服务"><a href="#具有合适使用案例的存储服务" class="headerlink" title="具有合适使用案例的存储服务"></a>具有合适使用案例的存储服务</h4><ul><li><strong>Amazon S3</strong>: 一种对象存储服务，适用于存储大量非结构化数据。例如，可以用于存储网站的静态文件、备份数据或大数据分析。</li><li><strong>Amazon Elastic File System (EFS)</strong>: 提供简单、可扩展的文件存储。适用于需要共享文件系统的应用，如内容管理系统或数据分析应用。</li><li><strong>Amazon Elastic Block Store (EBS)</strong>: 提供块存储，适用于需要持久化存储的情况，如数据库或企业级应用。</li></ul><p>案例：如果需要存储网站图像和视频，Amazon S3是理想选择；如果需要运行需要高吞吐量共享文件系统的应用，可以选择EFS；对于运行数据库，EBS更合适。</p><h4 id="具有相关特性的存储类型"><a href="#具有相关特性的存储类型" class="headerlink" title="具有相关特性的存储类型"></a>具有相关特性的存储类型</h4><ul><li><strong>对象存储</strong>: 如Amazon S3，适合存储非结构化数据。特点是可扩展性高，成本效益好。</li><li><strong>文件存储</strong>: 如Amazon EFS，适合需要共享访问的场景。</li><li><strong>数据块存储</strong>: 如Amazon EBS，适合需要高性能、低延迟的应用，如数据库。</li></ul><p>案例：一个电子健康记录系统可能使用文件存储来存储和共享病历，同时使用数据块存储来支持其数据库。</p><h4 id="技能一：确定可满足性能要求的存储服务和配置"><a href="#技能一：确定可满足性能要求的存储服务和配置" class="headerlink" title="技能一：确定可满足性能要求的存储服务和配置"></a>技能一：确定可满足性能要求的存储服务和配置</h4><p>分析业务需求，确定数据访问模式、吞吐量需求和延迟敏感度。例如，对于高频读写的数据库，需要选择低延迟、高吞吐量的存储解决方案，如Amazon EBS的高性能配置。</p><p>案例：一家金融服务公司可能需要使用高性能的EBS配置来支持其高速交易系统。</p><h4 id="技能二：确定可扩展以适应未来需求的存储服务"><a href="#技能二：确定可扩展以适应未来需求的存储服务" class="headerlink" title="技能二：确定可扩展以适应未来需求的存储服务"></a>技能二：确定可扩展以适应未来需求的存储服务</h4><p>评估业务增长和数据增长预期，选择可扩展性强的存储解决方案。例如，Amazon S3在对象存储方面提供几乎无限的扩展性，适合长期数据增长。</p><p>案例：随着用户基数的增长，一款社交媒体应用可能需要不断扩大其存储容量，因此选择S3作为其图片和视频存储的理想选择。<br>确定高性能数据库解决方案时，需要考虑多个方面。我将逐一讲解以下知识点，并尽量使用通俗易懂的例子来阐述。</p><h2 id="确定高性能数据库解决方案。"><a href="#确定高性能数据库解决方案。" class="headerlink" title="确定高性能数据库解决方案。"></a>确定高性能数据库解决方案。</h2><h3 id="AWS-全球基础设施"><a href="#AWS-全球基础设施" class="headerlink" title="AWS 全球基础设施"></a>AWS 全球基础设施</h3><p>AWS（亚马逊网络服务）提供了一个全球性的基础设施，包括多个地理位置分布的区域和可用区。每个AWS区域是一个独立的地理区域，每个区域内又包含多个物理上分离的、冗余连接的数据中心，这些被称为可用区。例如，如果您的用户主要在中国，选择靠近中国的亚马逊数据中心可以减少延迟，提高服务的响应速度。</p><h3 id="缓存策略和服务"><a href="#缓存策略和服务" class="headerlink" title="缓存策略和服务"></a>缓存策略和服务</h3><p>Amazon ElastiCache 是一个广泛使用的缓存服务，它支持常见的缓存策略，如Redis和Memcached。通过使用ElastiCache，可以将频繁访问的数据存储在内存中，从而快速响应读取请求，减轻数据库的负担。例如，一个电商网站可以将热销商品的信息存储在ElastiCache中，以便快速响应用户的查询请求。</p><h3 id="数据访问模式"><a href="#数据访问模式" class="headerlink" title="数据访问模式"></a>数据访问模式</h3><p>数据访问模式主要分为读取密集型和写入密集型。读取密集型的应用，如新闻网站，主要面向大量的读取操作，而写入密集型的应用，如社交媒体的评论系统，则面临着大量的数据写入操作。根据应用的访问模式，选择合适的数据库类型和配置是非常重要的。</p><h3 id="数据库容量规划"><a href="#数据库容量规划" class="headerlink" title="数据库容量规划"></a>数据库容量规划</h3><p>数据库容量规划包括容量单位、实例类型和预置IOPS（输入/输出操作每秒）。这需要根据应用程序的需求来定制，例如一个需要处理大量事务的金融系统可能需要高IOPS的数据库配置。预置IOPS是一种性能模式，它可以保证在高负载下提供一致的I/O性能。</p><h3 id="数据库连接和代理"><a href="#数据库连接和代理" class="headerlink" title="数据库连接和代理"></a>数据库连接和代理</h3><p>数据库连接管理是数据库性能的关键因素之一。过多的数据库连接会消耗大量资源，而连接池技术可以有效地管理这些连接。数据库代理如Amazon RDS Proxy可以帮助管理和缩放数据库连接，提高应用程序的可扩展性和弹性。</p><h3 id="数据库引擎的适用案例"><a href="#数据库引擎的适用案例" class="headerlink" title="数据库引擎的适用案例"></a>数据库引擎的适用案例</h3><p>不同的数据库引擎适合不同的使用场景。例如，对于需要高度可靠性和一致性的银行系统，适合使用传统的关系型数据库，如MySQL或PostgreSQL。对于需要高速数据分析和实时处理的大数据应用，非关系型数据库如Amazon DynamoDB可能更合适。</p><h3 id="数据库复制"><a href="#数据库复制" class="headerlink" title="数据库复制"></a>数据库复制</h3><p>数据库复制是指在多个数据库之间同步数据，以提高数据的可用性和灾难恢复能力。例如，只读副本可以用于负载均衡和备份，如果主数据库发生故障，可以快速切换到副本上继续提供服务。</p><h3 id="数据库类型和服务"><a href="#数据库类型和服务" class="headerlink" title="数据库类型和服务"></a>数据库类型和服务</h3><p>数据库可以分为关系型和非关系型两大类。关系型数据库，如MySQL，适合于结构化数据和复杂查询；而非关系型数据库，如MongoDB，适合于非结构化数据和快速的读写操作。无服务器的关系数据库（如Amazon Aurora Serverless）和内存中的非关系数据库（如Redis）提供了不同的性能和扩展性选项，适合于不同的应用场景。</p><p>确定高性能和可扩展的网络架构，以及掌握相关知识点，是确保网络系统可靠、高效的关键。以下是对您提到的各个知识点的详细解释：</p><h2 id="确定高性能的数据摄取和转换解决方案。"><a href="#确定高性能的数据摄取和转换解决方案。" class="headerlink" title="确定高性能的数据摄取和转换解决方案。"></a>确定高性能的数据摄取和转换解决方案。</h2><h3 id="边缘联网服务及其使用案例"><a href="#边缘联网服务及其使用案例" class="headerlink" title="边缘联网服务及其使用案例"></a>边缘联网服务及其使用案例</h3><p>边缘联网服务允许数据更靠近用户处理，从而减少延迟和提高性能。例如，Amazon CloudFront 是一个内容分发网络（CDN）服务，它缓存数据至全球分布的节点，使得用户可以快速访问数据。AWS Global Accelerator 则通过优化路径，加速用户到 AWS 应用程序的访问。</p><p><strong>举例：</strong><br>一个视频流媒体公司使用 Amazon CloudFront 来分发内容。当用户请求视频时，他们会从最近的边缘位置获取数据，而不是从远端的数据中心，从而减少了加载时间。</p><h3 id="设计网络架构"><a href="#设计网络架构" class="headerlink" title="设计网络架构"></a>设计网络架构</h3><p>网络架构设计是指定义网络的结构和组件，如子网、路由和IP地址等。合理设计可以提高网络的安全性、可扩展性和性能。</p><p><strong>举例：</strong><br>在AWS中，您可以创建多个子网，将网络划分为不同的部分，每部分可以有不同的安全级别和路由策略。例如，公共子网可用于托管需要外部访问的资源，如Web服务器，而私有子网则用于数据库。</p><h3 id="负载均衡概念-1"><a href="#负载均衡概念-1" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h3><p>负载均衡是一种技术，用于在多个服务器之间分配网络或应用程序流量。Application Load Balancer (ALB) 是 AWS 提供的一种负载均衡器，专门用于HTTP和HTTPS流量，它可以根据请求内容将流量路由至不同的后端。</p><p><strong>举例：</strong><br>一个网站可以使用 ALB 来分配流量至多个服务器，确保没有单一服务器过载。ALB 可以根据用户请求的URL或请求头来决定将流量路由至哪个服务器。</p><h3 id="网络连接选项"><a href="#网络连接选项" class="headerlink" title="网络连接选项"></a>网络连接选项</h3><p>AWS 提供多种网络连接选项，包括 VPN、Direct Connect 和 AWS PrivateLink，以适应不同的连接需求。</p><ul><li><strong>AWS VPN</strong> 允许您安全地连接您的本地网络到 AWS。</li><li><strong>Direct Connect</strong> 提供了一种私有的、高速的网络连接，直接连接您的数据中心和 AWS。</li><li><strong>AWS PrivateLink</strong> 提供了一种安全的连接方式，允许您通过私有网络访问 AWS 服务。</li></ul><p><strong>举例：</strong><br>企业可以使用 AWS Direct Connect 在其数据中心和 AWS 之间建立专用网络连接，以提高网络传输速度并降低网络成本。</p><h3 id="确定高性能的数据摄取和转换解决方案"><a href="#确定高性能的数据摄取和转换解决方案" class="headerlink" title="确定高性能的数据摄取和转换解决方案"></a>确定高性能的数据摄取和转换解决方案</h3><h4 id="数据分析和可视化服务"><a href="#数据分析和可视化服务" class="headerlink" title="数据分析和可视化服务"></a>数据分析和可视化服务</h4><h5 id="示例：Amazon-Athena-和-AWS-Lake-Formation"><a href="#示例：Amazon-Athena-和-AWS-Lake-Formation" class="headerlink" title="示例：Amazon Athena 和 AWS Lake Formation"></a>示例：Amazon Athena 和 AWS Lake Formation</h5><ul><li><strong>Amazon Athena</strong> 是一种基于 SQL 的服务，允许用户直接在 Amazon S3 上分析数据。适用场景包括对大量未处理的日志文件进行即席查询和分析。</li><li><strong>AWS Lake Formation</strong> 用于构建、保护和管理数据湖。它简化了数据收集、存储、清洁和安全控制的过程。例如，企业可以使用 Lake Formation 快速设置数据湖，集成各种数据源。</li></ul><h4 id="数据摄取模式"><a href="#数据摄取模式" class="headerlink" title="数据摄取模式"></a>数据摄取模式</h4><h5 id="示例：频率"><a href="#示例：频率" class="headerlink" title="示例：频率"></a>示例：频率</h5><ul><li><strong>频率</strong> 指数据摄取发生的频繁程度，比如实时、每日或每周。例如，一个电子商务网站可能会实时摄取交易数据，而一个月度财务报告可能只需要每月摄取数据。</li></ul><h4 id="数据传输服务"><a href="#数据传输服务" class="headerlink" title="数据传输服务"></a>数据传输服务</h4><h5 id="示例：AWS-DataSync-和-AWS-Storage-Gateway"><a href="#示例：AWS-DataSync-和-AWS-Storage-Gateway" class="headerlink" title="示例：AWS DataSync 和 AWS Storage Gateway"></a>示例：AWS DataSync 和 AWS Storage Gateway</h5><ul><li><strong>AWS DataSync</strong> 可用于快速、简单、安全地移动大量数据。适合于将本地数据迁移到 AWS 或在 AWS 服务之间同步数据。</li><li><strong>AWS Storage Gateway</strong> 是一种混合存储服务，允许本地环境与 AWS 云存储服务无缝集成。适用于需要定期备份本地数据到云的场景。</li></ul><h4 id="数据转换服务"><a href="#数据转换服务" class="headerlink" title="数据转换服务"></a>数据转换服务</h4><h5 id="示例：AWS-Glue"><a href="#示例：AWS-Glue" class="headerlink" title="示例：AWS Glue"></a>示例：AWS Glue</h5><ul><li><strong>AWS Glue</strong> 是一种完全托管的 ETL (提取、转换、加载) 服务。例如，可以使用 AWS Glue 自动化地将来自不同源的数据格式化、清洁，并准备用于分析。</li></ul><h4 id="对摄取接入点的安全访问"><a href="#对摄取接入点的安全访问" class="headerlink" title="对摄取接入点的安全访问"></a>对摄取接入点的安全访问</h4><ul><li>确保数据在摄取过程中的安全性至关重要。例如，使用加密和身份验证机制来保护数据的完整性和机密性。</li></ul><h4 id="满足业务要求所需的规模和速度"><a href="#满足业务要求所需的规模和速度" class="headerlink" title="满足业务要求所需的规模和速度"></a>满足业务要求所需的规模和速度</h4><ul><li>根据业务需求选择合适的数据处理能力和传输速度。例如，处理大量实时数据流可能需要更高的处理速度和计算资源。</li></ul><h4 id="流式传输数据服务"><a href="#流式传输数据服务" class="headerlink" title="流式传输数据服务"></a>流式传输数据服务</h4><h5 id="示例：Amazon-Kinesis"><a href="#示例：Amazon-Kinesis" class="headerlink" title="示例：Amazon Kinesis"></a>示例：Amazon Kinesis</h5><ul><li><strong>Amazon Kinesis</strong> 提供实时数据处理能力。适用于需要实时监控和分析的场景，如社交媒体数据流或实时游戏数据分析。</li></ul><p>以上每个服务和概念都是构建高性能数据摄取和转换解决方案的重要部分。通过理解这些服务的适用场景和特点，可以更好地设计和实施数据处理策略，以满足特定业务需求。</p><h2 id="设计成本优化型存储解决方案"><a href="#设计成本优化型存储解决方案" class="headerlink" title="设计成本优化型存储解决方案"></a>设计成本优化型存储解决方案</h2><h4 id="访问选项"><a href="#访问选项" class="headerlink" title="访问选项"></a>访问选项</h4><h5 id="示例：S3-存储桶的申请方付款"><a href="#示例：S3-存储桶的申请方付款" class="headerlink" title="示例：S3 存储桶的申请方付款"></a>示例：S3 存储桶的申请方付款</h5><ul><li>在 Amazon S3 中，可以配置存储桶以启用“申请方付款”模式。这意味着数据访问费用由访问者承担，而不是存储桶的拥有者。适用于公共数据集的共享场景。</li></ul><h4 id="AWS-成本管理服务功能"><a href="#AWS-成本管理服务功能" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><h5 id="示例：成本分配标签和多账户账单"><a href="#示例：成本分配标签和多账户账单" class="headerlink" title="示例：成本分配标签和多账户账单"></a>示例：成本分配标签和多账户账单</h5><ul><li><strong>成本分配标签</strong> 允许用户按项目、部门等对 AWS 资源的成本进行分类和跟踪。</li><li><strong>多账户账单</strong> 功能使组织能够将多个 AWS 账户的成本和使用情况集中到一个账单中，简化财务管理。</li></ul><h4 id="AWS-成本管理工具"><a href="#AWS-成本管理工具" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><h5 id="示例：AWS-Cost-Explorer、AWS-Budgets"><a href="#示例：AWS-Cost-Explorer、AWS-Budgets" class="headerlink" title="示例：AWS Cost Explorer、AWS Budgets"></a>示例：AWS Cost Explorer、AWS Budgets</h5><ul><li><strong>AWS Cost Explorer</strong> 用于分析和可视化 AWS 花费和使用情况数据。</li><li><strong>AWS Budgets</strong> 允许用户设置预算，以监控服务的使用情况和成本。</li></ul><h4 id="AWS-存储服务"><a href="#AWS-存储服务" class="headerlink" title="AWS 存储服务"></a>AWS 存储服务</h4><h5 id="示例：Amazon-FSx、Amazon-EFS、Amazon-S3、Amazon-EBS"><a href="#示例：Amazon-FSx、Amazon-EFS、Amazon-S3、Amazon-EBS" class="headerlink" title="示例：Amazon FSx、Amazon EFS、Amazon S3、Amazon EBS"></a>示例：Amazon FSx、Amazon EFS、Amazon S3、Amazon EBS</h5><ul><li><strong>Amazon FSx</strong> 提供完全托管的 Windows 文件服务器。</li><li><strong>Amazon EFS</strong> 为 Linux 实例提供简单、可扩展的文件存储。</li><li><strong>Amazon S3</strong> 是高度可扩展的对象存储服务。</li><li><strong>Amazon EBS</strong> 提供块存储卷，用于与 EC2 实例一起使用。</li></ul><h4 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h4><ul><li>定期备份数据，确保在灾难发生时可恢复。可利用 AWS Backup 等服务自动化此过程。</li></ul><h4 id="数据块存储选项"><a href="#数据块存储选项" class="headerlink" title="数据块存储选项"></a>数据块存储选项</h4><h5 id="示例：HDD-卷类型和-SSD-卷类型"><a href="#示例：HDD-卷类型和-SSD-卷类型" class="headerlink" title="示例：HDD 卷类型和 SSD 卷类型"></a>示例：HDD 卷类型和 SSD 卷类型</h5><ul><li><strong>HDD 卷类型</strong> 适用于频繁访问不太集中的数据。</li><li><strong>SSD 卷类型</strong> 适合于高吞吐量和低延迟的需求。</li></ul><h4 id="数据生命周期"><a href="#数据生命周期" class="headerlink" title="数据生命周期"></a>数据生命周期</h4><ul><li>使用数据生命周期管理策略自动将老旧数据转移到更经济的存储类别。</li></ul><h4 id="混合存储选项"><a href="#混合存储选项" class="headerlink" title="混合存储选项"></a>混合存储选项</h4><h5 id="示例：DataSync、Transfer-Family、Storage-Gateway"><a href="#示例：DataSync、Transfer-Family、Storage-Gateway" class="headerlink" title="示例：DataSync、Transfer Family、Storage Gateway"></a>示例：DataSync、Transfer Family、Storage Gateway</h5><ul><li><strong>DataSync</strong> 自动化数据转移。</li><li><strong>Transfer Family</strong> 管理文件传输。</li><li><strong>Storage Gateway</strong> 连接本地和云存储。</li></ul><h4 id="存储访问模式"><a href="#存储访问模式" class="headerlink" title="存储访问模式"></a>存储访问模式</h4><ul><li>分析数据的访问模式，选择最适合的存储类型，如频繁访问或偶尔访问。</li></ul><h4 id="存储分层"><a href="#存储分层" class="headerlink" title="存储分层"></a>存储分层</h4><h5 id="示例：对象存储的冷分层"><a href="#示例：对象存储的冷分层" class="headerlink" title="示例：对象存储的冷分层"></a>示例：对象存储的冷分层</h5><ul><li>对象存储的冷分层适用于不常访问的数据，比如 Amazon S3 的 Glacier。</li></ul><h4 id="存储类型的相关特性"><a href="#存储类型的相关特性" class="headerlink" title="存储类型的相关特性"></a>存储类型的相关特性</h4><h5 id="示例：对象、文件、数据块存储"><a href="#示例：对象、文件、数据块存储" class="headerlink" title="示例：对象、文件、数据块存储"></a>示例：对象、文件、数据块存储</h5><ul><li><strong>对象存储</strong>：适用于大量非结构化数据。</li><li><strong>文件存储</strong>：适用于需要共享文件系统的场景。</li><li><strong>数据块存储</strong>：适用于数据库和其他需要持久存储的应用。</li></ul><h2 id="设计成本优化型计算解决方案"><a href="#设计成本优化型计算解决方案" class="headerlink" title="设计成本优化型计算解决方案"></a>设计成本优化型计算解决方案</h2><p>当设计成本优化型计算解决方案时，需要考虑多个方面，包括AWS成本管理服务、全球基础设施、购买选项、计算策略等。以下是这些主要知识点的详细解释和实例。</p><h4 id="AWS-成本管理服务功能-1"><a href="#AWS-成本管理服务功能-1" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><ul><li><strong>成本分配标签</strong>：允许你标记AWS资源，以便跟踪成本。例如，你可以为不同的部门或项目标记不同的资源，从而更容易地追踪和管理这些成本。</li><li><strong>多账户账单</strong>：如果你管理多个AWS账户，这个功能可以帮助你集中查看和管理这些账户的费用。它能够让你从总体上把握成本，便于进行成本优化。</li></ul><h4 id="具有合适使用案例的-AWS-成本管理工具"><a href="#具有合适使用案例的-AWS-成本管理工具" class="headerlink" title="具有合适使用案例的 AWS 成本管理工具"></a>具有合适使用案例的 AWS 成本管理工具</h4><ul><li><strong>Cost Explorer</strong>：用于可视化和理解AWS花费和使用情况。例如，你可以使用它来查看过去几个月的消费趋势，预测未来的费用。</li><li><strong>AWS Budgets</strong>：允许你设定预算和警报，以便在费用或使用量超出预设的阈值时收到通知。</li><li><strong>AWS 成本和使用情况报告</strong>：提供详细的成本和使用数据，方便你深入分析成本。</li></ul><h4 id="AWS-全球基础设施-1"><a href="#AWS-全球基础设施-1" class="headerlink" title="AWS 全球基础设施"></a>AWS 全球基础设施</h4><ul><li><strong>可用区</strong>：AWS在特定区域内的多个独立数据中心。通过在不同的可用区部署应用，可以提高可靠性和可用性。</li><li><strong>AWS 区域</strong>：AWS全球的地理区域，每个区域包含多个可用区。选择距离用户较近的区域可以减少延迟，可能还能降低数据传输费用。</li></ul><h4 id="AWS-购买选项"><a href="#AWS-购买选项" class="headerlink" title="AWS 购买选项"></a>AWS 购买选项</h4><ul><li><strong>Spot 实例</strong>：以市场定价购买的实例，适合于可以容忍中断的灵活和非关键任务。通常比按需实例便宜很多。</li><li><strong>预留实例</strong>：提前预订的实例，适合长期稳定的需求，价格低于按需实例。</li><li><strong>Savings Plans</strong>：为一致的使用量提供更低的价格，适用于长期稳定的使用。</li></ul><h4 id="分布式计算策略"><a href="#分布式计算策略" class="headerlink" title="分布式计算策略"></a>分布式计算策略</h4><ul><li><strong>边缘处理</strong>：在离数据来源更近的地方进行数据处理，如使用AWS Lambda@Edge在边缘位置运行代码，减少延迟，优化性能。</li></ul><h4 id="混合计算选项"><a href="#混合计算选项" class="headerlink" title="混合计算选项"></a>混合计算选项</h4><ul><li><strong>AWS Outposts</strong>：将AWS服务、基础设施和操作模型带到几乎任何数据中心、共同位置空间或云环境。</li><li><strong>AWS Snowball Edge</strong>：物理设备，用于数据传输和边缘计算，适合大量数据迁移和离线处理。</li></ul><h4 id="实例类型、系列和大小"><a href="#实例类型、系列和大小" class="headerlink" title="实例类型、系列和大小"></a>实例类型、系列和大小</h4><ul><li><strong>内存优化型</strong>：适合内存密集型应用，如大型数据库。</li><li><strong>计算优化型</strong>：适合计算密集型任务，如高性能计算。</li><li><strong>虚拟化</strong>：提供虚拟服务器，适合多种用途。</li></ul><h4 id="优化计算利用率"><a href="#优化计算利用率" class="headerlink" title="优化计算利用率"></a>优化计算利用率</h4><ul><li><strong>容器</strong>：通过容器技术（如Docker），可以更高效地使用资源，提高应用的部署速度和可移植性。</li><li><strong>无服务器计算</strong>：如AWS Lambda，按需自动扩展，只为实际使用的资源付费。</li><li><strong>微服务</strong>：将应用拆分为小型、独立的服务，可以独立</li></ul><h2 id="设计成本优化型数据库解决方案"><a href="#设计成本优化型数据库解决方案" class="headerlink" title="设计成本优化型数据库解决方案"></a>设计成本优化型数据库解决方案</h2><p>在设计成本优化型数据库解决方案时，考虑以下关键知识点非常重要：</p><h4 id="AWS-成本管理服务功能-2"><a href="#AWS-成本管理服务功能-2" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><p>AWS 提供多种成本管理工具，帮助您理解、控制和优化 AWS 资源的成本。</p><ul><li><strong>成本分配标签</strong>：允许您将自定义标签分配给 AWS 资源，以便对成本进行更详细的跟踪。例如，您可以为不同的部门或项目分配标签，以跟踪每个部门或项目的资源使用情况和成本。</li><li><strong>多账户账单</strong>：如果您有多个 AWS 账户，可以使用此功能来合并账单。这有助于简化账单管理并获得整体成本视图。</li></ul><h4 id="AWS-成本管理工具-1"><a href="#AWS-成本管理工具-1" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><ul><li><strong>Cost Explorer</strong>：一个强大的工具，用于可视化和分析您的 AWS 贴费数据。您可以查看历史数据，预测未来开支，以及识别成本趋势。</li><li><strong>AWS Budgets</strong>：允许您设置预算以控制成本。您可以为 AWS 成本、使用量、保留实例覆盖率等设置预算。</li><li><strong>AWS 成本和使用情况报告</strong>：提供详细的成本和使用数据报告，支持将数据导出到 Amazon S3，方便进行深入分析。</li></ul><h4 id="缓存策略-2"><a href="#缓存策略-2" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>缓存可以显著减少数据库的负载，降低成本。例如，使用 Amazon ElastiCache 来缓存常用数据，减少对数据库的直接访问次数。</p><h4 id="数据留存策略"><a href="#数据留存策略" class="headerlink" title="数据留存策略"></a>数据留存策略</h4><p>合理的数据留存策略可以减少不必要的存储成本。例如，使用 Amazon S3 的生命周期策略自动转移或删除旧数据。</p><h4 id="数据库容量规划-1"><a href="#数据库容量规划-1" class="headerlink" title="数据库容量规划"></a>数据库容量规划</h4><ul><li><strong>容量单位</strong>：合理规划数据库容量可以避免资源浪费。例如，根据业务需求选择合适的 Amazon RDS 实例类型和大小。</li></ul><h4 id="数据库连接和代理-1"><a href="#数据库连接和代理-1" class="headerlink" title="数据库连接和代理"></a>数据库连接和代理</h4><ul><li>使用 Amazon RDS Proxy 可以有效管理数据库连接，减少不必要的资源开销。</li></ul><h4 id="数据库引擎的合适使用案例"><a href="#数据库引擎的合适使用案例" class="headerlink" title="数据库引擎的合适使用案例"></a>数据库引擎的合适使用案例</h4><ul><li><strong>异构迁移</strong>：例如，从 Oracle 迁移到 Amazon Aurora。</li><li><strong>同构迁移</strong>：例如，从一个 MySQL 数据库迁移到另一个 MySQL 数据库。</li></ul><h4 id="数据库复制-1"><a href="#数据库复制-1" class="headerlink" title="数据库复制"></a>数据库复制</h4><ul><li><strong>只读副本</strong>：例如，使用 Amazon RDS for MySQL 的只读副本来分担读取负载，从而提高性能和可靠性。</li></ul><h4 id="数据库类型和服务-1"><a href="#数据库类型和服务-1" class="headerlink" title="数据库类型和服务"></a>数据库类型和服务</h4><ul><li><strong>关系数据库与非关系数据库</strong>：选择适合您数据模式的数据库类型。例如，结构化数据使用 Amazon RDS，非结构化数据使用 Amazon DynamoDB。</li><li><strong>Aurora 与 DynamoDB 的比较</strong>：Aurora 适用于需要高性能事务处理的场景，而 DynamoDB 适用于需要高度可扩展、低延迟的 NoSQL 解决方案。</li></ul><h3 id="设计成本优化型网络架构"><a href="#设计成本优化型网络架构" class="headerlink" title="设计成本优化型网络架构"></a>设计成本优化型网络架构</h3><h4 id="AWS-成本管理服务功能-3"><a href="#AWS-成本管理服务功能-3" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><p>AWS成本管理服务提供了多种工具和功能，帮助用户监控、管理和优化他们在AWS上的支出和使用情况。这包括：</p><ul><li><p><strong>成本分配标签</strong>：它们允许用户通过添加标签来组织资源，以便更容易地追踪成本和使用情况。例如，你可以为不同的项目或部门设置标签，以便更容易地分配成本。</p></li><li><p><strong>多账户账单</strong>：对于拥有多个AWS账户的组织来说，多账户账单功能可以帮助它们更好地理解和管理各个账户的开销。</p></li></ul><h4 id="AWS-成本管理工具-2"><a href="#AWS-成本管理工具-2" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><ul><li><p><strong>Cost Explorer</strong>：这是一个可视化工具，用户可以通过它查看和分析他们的AWS成本和使用情况数据。例如，你可以使用Cost Explorer来查看过去几个月的支出趋势，或者分析特定服务的成本。</p></li><li><p><strong>AWS Budgets</strong>：这个工具允许用户设置预算并接收警报，以便在成本或使用量超出预定阈值时得到通知。</p></li><li><p><strong>AWS 成本和使用情况报告</strong>：这是一种更高级的工具，它提供关于AWS使用情况和成本的详细报告。用户可以用它来进行深入的成本分析。</p></li></ul><h4 id="负载均衡概念-2"><a href="#负载均衡概念-2" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h4><ul><li><strong>Application Load Balancer</strong>：这是一种用于分配进入应用程序的流量的负载均衡器。例如，如果你有一个高流量的网站，使用Application Load Balancer可以帮助分散流量，提高应用程序的可用性和效率。</li></ul><h4 id="NAT-网关"><a href="#NAT-网关" class="headerlink" title="NAT 网关"></a>NAT 网关</h4><ul><li><strong>NAT实例与NAT网关成本比较</strong>：NAT实例是一种基于EC2的解决方案，而NAT网关是AWS提供的托管服务。通常，NAT网关比NAT实例更易于管理且可扩展性更好，但可能在某些情况下成本更高。</li></ul><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><ul><li><strong>私有线路、专用线路、VPN</strong>：这些都是连接到AWS的不同方法。私有线路（如AWS Direct Connect）提供了一种直接连接到AWS的方式，可以降低网络成本，提高带宽效率。专用线路适用于需要高安全性的连接。VPN提供了一种通过互联网安全连接到AWS的方式。</li></ul><h4 id="网络路由、拓扑和对等连接"><a href="#网络路由、拓扑和对等连接" class="headerlink" title="网络路由、拓扑和对等连接"></a>网络路由、拓扑和对等连接</h4><ul><li><strong>AWS Transit Gateway和VPC对等连接</strong>：这些服务允许不同的VPC之间以及VPC和本地网络之间的通信。例如，使用Transit Gateway可以更容易地管理大规模的网络拓扑，而VPC对等连接允许两个VPC之间直接通信。</li></ul><h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><ul><li><strong>DNS</strong>：域名系统（DNS）是网络上的一项关键服务，用于将域名转换为IP地址。在AWS中，Amazon Route 53提供了强大的DNS服务，支持成本优化和高可用性。</li></ul><p>通过这些知识点的掌握，你可以更好地设计和管理一个成本效益高、性能优化的AWS网络架构。</p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Basic/Study-Note/"/>
    
    
    <category term="SAA" scheme="https://kalyan-zitiu.github.io/tags/SAA/"/>
    
  </entry>
  
  <entry>
    <title>Conspectus for SAA</title>
    <link href="https://kalyan-zitiu.github.io/2023/12/24/saa%E6%A6%82%E5%BF%B5/"/>
    <id>https://kalyan-zitiu.github.io/2023/12/24/saa%E6%A6%82%E5%BF%B5/</id>
    <published>2023-12-24T12:00:00.000Z</published>
    <updated>2024-01-07T04:56:06.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Elastic-Load-Balancing（弹性负载均衡）"><a href="#Elastic-Load-Balancing（弹性负载均衡）" class="headerlink" title="Elastic Load Balancing（弹性负载均衡）"></a>Elastic Load Balancing（弹性负载均衡）</h3><p> 是一种自动分配进入应用程序的网络流量的服务。它可以确保负载均匀分布在多个服务器上，从而提高应用程序的可用性和容错能力。Elastic Load Balancing支持三种主要类型的负载均衡器：</p><ol><li><strong>应用程序负载均衡器（Application Load Balancer）</strong>：适用于HTTP和HTTPS流量，提供高级路由功能，可以基于内容将流量路由到不同的服务。</li><li><strong>网络负载均衡器（Network Load Balancer）</strong>：适用于TCP流量，特别适合处理高性能、低延迟的网络传输。网络负载均衡器能够在数毫秒内自动响应流量变化。</li><li><strong>经典负载均衡器（Classic Load Balancer）</strong>：提供基本的负载均衡功能，适用于应用程序和网络层面的负载均衡。</li></ol><p>Elastic Load Balancing可以集成到AWS的其他服务中，如Auto Scaling（自动扩展服务），以确保应用程序在不同的负载条件下均能稳定运行。通过Elastic Load Balancing，可以自动检测不健康的实例，并将流量重新分配到健康的实例上，从而保证应用程序的高可用性。</p><h3 id="Auto-Scaling（自动扩展）"><a href="#Auto-Scaling（自动扩展）" class="headerlink" title="Auto Scaling（自动扩展）"></a>Auto Scaling（自动扩展）</h3><p>是一种云计算服务，用于自动调整计算资源的数量以满足应用程序的需求。这种服务通常与云计算平台（如AWS、Azure或Google Cloud）结合使用。Auto Scaling的主要特点和优点包括：</p><ol><li><strong>动态扩展和缩减</strong>：根据预定义的指标（如CPU使用率、网络流量或自定义指标），自动增加或减少服务器实例的数量。这确保了在需求增加时提供足够的资源，而在需求减少时减少不必要的开支。</li><li><strong>成本效益</strong>：通过仅在需要时添加资源，并在不需要时移除资源，Auto Scaling有助于优化成本，因为用户只需为实际使用的资源付费。</li><li><strong>高可用性和容错性</strong>：通过跨多个地理区域或可用区自动分配资源，Auto Scaling可以提高应用程序的可用性和抗故障能力。</li><li><strong>预测性扩展</strong>：某些自动扩展服务还提供基于预测分析的扩展，这意味着它们可以根据历史数据和趋势分析来预测需求，并相应地调整资源。</li><li><strong>与负载均衡器集成</strong>：Auto Scaling通常与负载均衡器（如Elastic Load Balancing）集成，以确保新添加的实例可以接收到流量，并且流量在所有实例之间均匀分配。</li></ol><p>Auto Scaling适用于需要根据流量或其他指标动态调整资源的应用程序，例如电子商务网站、大数据分析应用程序和在线游戏服务器。通过自动扩展，这些应用程序可以在负载高峰期间保持性能，并在低峰期间减少资源浪费。</p><h3 id="Amazon-CloudFront"><a href="#Amazon-CloudFront" class="headerlink" title="Amazon CloudFront"></a>Amazon CloudFront</h3><p>是由亚马逊网络服务（AWS）提供的内容分发网络（CDN）服务。它帮助以低延迟和高传输速度向用户提供内容，如网页、视频、图像和其他静态和动态文件。CloudFront通过在全球范围内的边缘位置缓存内容，使内容更接近最终用户，从而减少内容传输的距离和时间。</p><p>在设置和配置Amazon CloudFront时，您有几个选项和参数可以考虑。以下是一些关键设置：</p><p>源：</p><p>源类型：指定您内容的源，可以是AWS资源（例如S3存储桶、EC2实例）或自定义源（例如HTTP服务器）。<br>源协议策略：选择CloudFront与源之间通信时使用的协议，可以是HTTP或HTTPS。<br>分发设置：</p><p>价格级别：选择决定用于传送内容的边缘位置数量的价格级别（边缘位置越多，成本越高但性能更好）。<br>替代域名（CNAME）：指定要与CloudFront分发关联的任何自定义域名。<br>SSL证书：选择用于安全连接的SSL证书（您可以使用AWS证书管理器来管理SSL证书）。<br>默认根对象：定义当用户访问分发的根URL时要提供的默认文件。<br>缓存行为设置：</p><p>路径模式：定义匹配特定路径或模式的规则<br>这些只是Amazon CloudFront的一些关键设置，具体选择的设置取决于您的应用程序要求和分发的预期行为。建议查阅AWS文档以获取关于每个参数及其影响的详细信息。</p><h3 id="AWS-Glacier"><a href="#AWS-Glacier" class="headerlink" title="AWS Glacier"></a>AWS Glacier</h3><p>是亚马逊网络服务（AWS）提供的一种低成本、长期存储服务。它旨在为需要长期保存数据的场景提供可靠的、安全的存储解决方案。Glacier适用于备份、归档和长期数据保留等用途。</p><p>以下是AWS Glacier的一些关键特点和概念：</p><ol><li><p>存储类别：AWS Glacier提供了三种存储类别：标准存储（Standard）、大容量存储（Bulk）和快速存储（Expedited）。每种存储类别具有不同的定价和可用性。标准存储适用于大多数场景，而大容量存储和快速存储适用于需要快速检索数据的特定用例。</p></li><li><p>存储桶和存档：在AWS Glacier中，数据存储在称为存储桶（Vault）的容器中。每个存储桶可以包含多个存档（Archive），每个存档代表一个文件或对象。存档可以是任意大小，最大支持40TB。</p></li><li><p>数据上传和检索：您可以使用AWS Glacier提供的API或AWS管理控制台将数据上传到存储桶中。上传的数据被分割成多个部分，并进行压缩和加密，然后存储在AWS的数据中心中。对于大容量存储和快速存储，数据可以更快地检索出来。数据检索请求可以是实时的（快速存储）或延迟几个小时（大容量存储）。</p></li><li><p>数据保留和可用性：AWS Glacier被设计为长期存储解决方案，数据的可用性相对较低。数据检索请求可能需要几个小时才能完成，因此不适合需要实时访问的数据。但是，AWS Glacier提供了数据可靠性保证，并采取了多重复制和数据校验等措施来确保数据的安全性和完整性。</p></li><li><p>定价：AWS Glacier的定价基于存储的数据量、数据上传和检索的操作次数以及存储的时间长度。不同的存储类别和数据检索速度会影响定价。您可以参考AWS Glacier的定价页面或使用AWS计算器来估算使用该服务的成本。</p></li></ol><p>AWS Glacier提供了一种经济高效的长期数据存储解决方案，适用于需要将数据安全地保存多年的场景。它与其他AWS服务（如Amazon S3和Amazon Glacier Deep Archive）相互集成，为用户提供了灵活的存储和数据管理选项。</p><h3 id="AWS-Elastic-Transcoder"><a href="#AWS-Elastic-Transcoder" class="headerlink" title="AWS Elastic Transcoder"></a>AWS Elastic Transcoder</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一项云视频转码服务。它可以帮助用户将视频文件转换成不同的格式，以适应不同的设备和平台，比如移动设备、电视、互联网流媒体等等。以下是一些关于 AWS Elastic Transcoder 的关键信息：</p><ol><li><p><strong>视频转码：</strong> Elastic Transcoder 可以将输入的视频文件转码成多种输出格式，包括不同的分辨率、编码和容器格式。这有助于确保视频在不同设备上的流畅播放。</p></li><li><p><strong>自动缩放：</strong> 它能够自动调整输出视频的分辨率和比特率，以适应不同的终端设备和带宽条件。</p></li><li><p><strong>预设模板：</strong> Elastic Transcoder 提供了多种预设模板，可用于快速配置输出参数，用户可以选择适合其需求的预设，也可以自定义设置。</p></li><li><p><strong>工作流程：</strong> 用户可以创建自定义工作流程，将多个转码任务组合在一起，以实现复杂的视频处理需求。</p></li><li><p><strong>云服务：</strong> Elastic Transcoder 是一项托管的云服务，用户无需关心基础设施维护和扩展，只需支付按用量计费。</p></li><li><p><strong>集成性：</strong> 它可以与其他 AWS 服务和云存储服务（如Amazon S3）集成，使视频转码和存储变得更加简单。</p></li></ol><p>AWS Elastic Transcoder 是一个强大的工具，适用于需要处理和分发视频内容的各种应用，包括媒体流媒体、在线教育、广告等。通过使用它，您可以确保您的视频在不同的设备上以最佳质量进行播放。</p><h3 id="AWS-简单通知服务（Simple-Notification-Service，SNS）"><a href="#AWS-简单通知服务（Simple-Notification-Service，SNS）" class="headerlink" title="AWS 简单通知服务（Simple Notification Service，SNS）"></a>AWS 简单通知服务（Simple Notification Service，SNS）</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一项托管的通知服务，用于构建分布式、可扩展的应用程序和微服务架构。以下是关于 AWS SNS 的关键信息：</p><ol><li><p><strong>消息发布和订阅：</strong> SNS 允许开发人员将消息发布到主题（Topic），然后允许订阅者通过不同的通信协议接收这些消息。订阅者可以是应用程序、服务器、移动设备或终端用户。</p></li><li><p><strong>多通信协议支持：</strong> SNS 支持多种通信协议，包括电子邮件、短信、HTTP、HTTPS、Lambda、SQS（简单队列服务）等。这意味着您可以以多种方式将消息传递给订阅者，以适应不同的用例。</p></li><li><p><strong>消息筛选：</strong> SNS 支持消息筛选功能，让订阅者可以只接收与他们关心的主题相关的消息，这可以降低不必要的消息传递。</p></li><li><p><strong>可扩展性：</strong> SNS 可以轻松扩展以处理大量的消息和订阅者。它是高可用的，可以确保消息的可靠传递。</p></li><li><p><strong>事件驱动架构：</strong> SNS 可以作为事件驱动架构的一部分，将通知消息传递给触发器（例如 AWS Lambda 函数），从而实现自动化和响应式应用程序。</p></li><li><p><strong>安全性：</strong> SNS 提供身份验证和授权机制，以确保消息的安全传递，并可以与 AWS Identity and Access Management（IAM）集成，以控制对 SNS 主题的访问权限。</p></li></ol><p>AWS SNS 可以用于各种用例，包括应用程序提醒、监控和警报、社交媒体分享、移动应用程序通知等。它是构建具有高度可扩展性和弹性的分布式应用程序的有力工具，有助于将消息和通知传递到目标接收者，无论是人还是应用程序。</p><h3 id="AWS-Simple-Queue-Service（SQS）"><a href="#AWS-Simple-Queue-Service（SQS）" class="headerlink" title="AWS Simple Queue Service（SQS）"></a>AWS Simple Queue Service（SQS）</h3><p>是亚马逊网络服务（AWS）提供的一种完全托管的消息队列服务。它允许应用程序在分布式系统中进行异步通信，并解耦发送者和接收者之间的关系。SQS可用于构建可靠的、可扩展的应用程序，处理大量消息并保证消息的可靠传递。</p><p>以下是AWS Simple Queue Service的一些关键特点和概念：</p><ol><li><p>消息队列：SQS使用消息队列来存储和传递消息。消息队列是一种中间件，可以存储消息并按照先进先出（FIFO）的顺序将其传递给消费者。</p></li><li><p>队列类型：SQS提供两种类型的队列：标准队列和先进先出（FIFO）队列。标准队列提供高吞吐量和最少一次交付保证，但消息的顺序不是严格保证的。FIFO队列提供严格的消息顺序保证，但吞吐量略低。</p></li><li><p>消息传递：应用程序可以使用SQS API将消息发送到队列中，并使用API接收消息。消息可以是任意大小，最大支持256KB。发送者和接收者可以是不同的应用程序，甚至可以跨越不同的系统和云服务。</p></li><li><p>可靠性和可伸缩性：SQS提供高度可靠的消息传递，确保消息不会丢失。它还具有自动伸缩的能力，可以根据负载的变化自动调整吞吐量。</p></li><li><p>可见性超时：当消费者接收到消息后，消息将在一段时间内不可见，称为可见性超时。在此期间，消费者可以处理消息，但其他消费者无法看到该消息。如果消费者在处理消息时发生故障或未能删除消息，消息将重新变为可见状态，供其他消费者处理。</p></li><li><p>消息保留：SQS可以保留消息，即使消息被消费者接收和处理，也可以在队列中保留一段时间。这对于需要重放或重新处理消息的场景非常有用。</p></li><li><p>延迟队列：SQS还支持延迟队列，可以将消息延迟发送到队列中。这对于需要在一定时间后执行某些操作的应用程序非常有用。</p></li></ol><p>AWS Simple Queue Service提供了一种可靠、高可用的消息队列服务，适用于构建分布式系统、异步通信和处理大量消息的场景。它与其他AWS服务（如AWS Lambda、Amazon EC2和Amazon SNS）集成，提供了灵活的消息传递选项和可扩展性。</p><h3 id="DynamoDB-表（DynamoDB-table）"><a href="#DynamoDB-表（DynamoDB-table）" class="headerlink" title="DynamoDB 表（DynamoDB table）"></a>DynamoDB 表（DynamoDB table）</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一种全托管的 NoSQL 数据库服务，用于存储和检索数据。以下是关于 DynamoDB 表的关键信息：</p><ol><li><p><strong>分布式和托管：</strong> DynamoDB 表是一种完全托管的数据库服务，它自动处理底层硬件和分布式数据库的运维工作，使开发人员可以专注于数据建模和应用程序逻辑。</p></li><li><p><strong>键值存储：</strong> DynamoDB 是一种键值存储数据库，每个表都有一个主键，可以是单一属性或组合属性。这使得数据的检索和查询非常快速。</p></li><li><p><strong>无模式和灵活：</strong> DynamoDB 是无模式的数据库，这意味着您可以在同一表中存储不同结构的数据，而不需要预定义模式。这使得 DynamoDB 适用于多样化的数据。</p></li><li><p><strong>自动缩放：</strong> DynamoDB 具有自动扩展和缩小的能力，根据负载的变化自动调整读取和写入容量单元，以确保高性能和低延迟。</p></li><li><p><strong>多区域复制：</strong> 您可以配置 DynamoDB 表以进行多区域复制，以增加数据的可用性和容错性。这使得数据在多个 AWS 区域之间进行复制和同步。</p></li><li><p><strong>安全性：</strong> DynamoDB 提供了身份和访问管理（IAM）集成，以控制对表的访问权限。您可以定义细粒度的权限策略，以确保数据的安全性。</p></li><li><p><strong>高可用性：</strong> DynamoDB 具有高可用性和持久性，保证数据的可靠性和持久性。</p></li><li><p><strong>全局二级索引：</strong> 您可以创建全局二级索引，以支持不同于主键的查询需求，这使得检索数据更加灵活。</p></li></ol><p>DynamoDB 表通常用于构建具有大规模、低延迟读取和写入需求的应用程序，如电子商务平台、游戏分数排名、用户配置文件存储等。它是一种强大的数据库服务，可以适应各种用例，并提供高度的可扩展性和性能。</p><h3 id="EBS（Elastic-Block-Store）"><a href="#EBS（Elastic-Block-Store）" class="headerlink" title="EBS（Elastic Block Store）"></a>EBS（Elastic Block Store）</h3><p>是亚马逊网络服务（AWS）提供的一种持久性块存储服务，用于在云中运行的虚拟机实例（如Amazon EC2实例）上存储数据。EBS 提供了可靠、高性能和可扩展的块级存储解决方案，允许用户创建、附加、备份和恢复数据卷。</p><p>以下是 EBS 的一些关键特点和功能：</p><ol><li><p>持久性存储：EBS 提供持久性存储，确保数据在实例终止或发生故障时不会丢失。数据存储在 EBS 卷上，并且持久保存在亚马逊的后端存储系统中。</p></li><li><p>高性能：EBS 提供低延迟和高吞吐量的性能，适用于各种工作负载，包括数据库、文件存储和应用程序数据。</p></li><li><p>可扩展性：用户可以根据需要创建和调整 EBS 卷的容量，无需中断实例。EBS 卷的大小可以从几GB到16TB不等。</p></li><li><p>快照备份：EBS 允许用户创建卷的快照备份，以便在需要时进行数据恢复或创建新的卷。快照是卷的点-in-time 副本，可以用作数据备份、复制和迁移。</p></li><li><p>多种卷类型：EBS 提供多种卷类型，以满足不同的性能和成本需求。其中包括：SSD（固态硬盘）卷类型（如 gp2、io1、io2）和 HDD（硬盘驱动器）卷类型（如 st1、sc1）。</p></li><li><p>可靠性和可用性：EBS 提供了数据冗余和故障转移功能，以确保数据的可靠性和可用性。EBS 卷的数据会在多个存储设备上进行复制，以提供高可靠性。</p></li><li><p>集成性：EBS 与其他 AWS 服务集成紧密，例如 Amazon EC2、Amazon RDS（关系型数据库服务）和 Amazon EMR（弹性 MapReduce 服务），使用户可以轻松地将 EBS 用于各种应用场景。</p></li></ol><p>通过使用 EBS，用户可以在 AWS 上创建和管理持久性存储卷，为云中的应用程序提供可靠的数据存储解决方案。EBS 提供了高性能、可扩展性和数据保护功能，使用户能够根据需要灵活地管理和使用存储资源。</p><h4 id="EBS-提供不同类型的存储选项"><a href="#EBS-提供不同类型的存储选项" class="headerlink" title="(EBS) 提供不同类型的存储选项"></a>(EBS) 提供不同类型的存储选项</h4><p>Amazon Elastic Block Store (EBS) 提供不同类型的存储选项，每种类型都针对特定的使用案例和性能需求设计。以下是四种主要类型的 EBS 卷的概述：</p><p>EBS Provisioned IOPS SSD (io1/io2): 这种类型的 EBS 卷专为 I/O 密集型的事务型工作负载设计，如数据库应用程序。它们提供高性能的 SSD 支持，并允许用户预设 IOPS（每秒输入/输出操作次数），以满足高吞吐量和低延迟的需求。对于需要持续高 IOPS 的应用，如大型关系型数据库或高频交易系统，这是理想的选择。</p><p>EBS General Purpose SSD (gp2/gp3): 这是一种通用的 SSD 卷，适用于广泛的工作负载。它们提供了良好的性能和价格比，对 IOPS 有基本的需求，但不像 io1/io2 那样高。这种卷适合用于系统引导盘、虚拟桌面环境、中小型数据库和开发/测试环境。</p><p>EBS Cold HDD (sc1): 这种硬盘驱动器 (HDD) 卷提供了较低的存储成本，并适用于低频访问的数据。它们是为需要较大存储容量但不频繁访问数据的应用程序设计的，如备份、数据仓库和冷数据存储。</p><p>EBS Throughput Optimized HDD (st1): 这是另一种 HDD 类型的卷，专为吞吐量密集型的工作负载设计，如大数据、数据仓库、日志处理和大型数据集的批量处理。st1 卷提供高吞吐量性能，适用于频繁读写的大数据集。</p><p>选择哪种类型的 EBS 卷取决于您的具体应用需求，包括性能、成本和存储容量的考虑。例如，对于高性能数据库，可能会选择 Provisioned IOPS SSD，而对于成本敏感且访问频率较低的数据存储，则可能选择 Cold HDD 或 Throughput Optimized HDD。</p><h3 id="EFS（Elastic-File-System）"><a href="#EFS（Elastic-File-System）" class="headerlink" title="EFS（Elastic File System）"></a>EFS（Elastic File System）</h3><p>是亚马逊网络服务（AWS）提供的一种托管的弹性文件存储服务，可用于在云中运行的应用程序和服务。它提供了一个简单、可扩展和高性能的文件系统，可以与多个 Amazon EC2 实例共享数据，并且可以在不同的可用区域之间复制和备份数据。</p><p>以下是 EFS 的一些关键特点和功能：</p><ol><li><p>共享文件系统：EFS 允许多个 Amazon EC2 实例同时访问和共享相同的文件系统。这使得多个实例可以同时读取和写入相同的文件，方便了分布式应用程序和共享存储需求的实现。</p></li><li><p>自动扩展：EFS 可以根据需要自动扩展存储容量和性能，无需中断实例。它可以根据文件系统的使用情况自动调整存储容量，并提供高吞吐量和低延迟的性能。</p></li><li><p>可靠性和耐用性：EFS 提供了高度可靠和耐用的文件存储解决方案。数据在多个可用区域进行复制，以提供高可用性和数据冗余。此外，EFS 还支持自动的文件系统级别的备份和恢复功能。</p></li><li><p>安全性和权限控制：EFS 提供了细粒度的权限控制，允许用户对文件和目录设置访问权限。用户可以使用 AWS Identity and Access Management（IAM）来管理对文件系统的访问，并通过文件系统级别的加密来保护数据的安全性。</p></li><li><p>高性能：EFS 提供了低延迟和高吞吐量的性能，适用于各种工作负载，包括大规模并发访问和大型文件的读写操作。</p></li><li><p>跨可用区域复制：EFS 支持在不同的 AWS 区域之间进行文件系统的复制和备份，以提供更高的可用性和灾备能力。</p></li><li><p>集成性：EFS 与其他 AWS 服务集成紧密，例如 Amazon EC2、Amazon ECS（容器服务）和 AWS Lambda（无服务器计算服务），使用户可以轻松地将 EFS 用于各种应用场景。</p></li></ol><p>通过使用 EFS，用户可以轻松地创建和管理共享的弹性文件系统，为云中的应用程序提供可靠和高性能的文件存储解决方案。EFS 提供了自动扩展、高可用性和安全性等功能，使用户能够轻松地实现多实例共享数据和分布式应用程序的需求。</p><h3 id="ElastiCache"><a href="#ElastiCache" class="headerlink" title="ElastiCache"></a>ElastiCache</h3><p> 是亚马逊网络服务（AWS）提供的一种托管的内存缓存服务，旨在提高应用程序的性能和可扩展性。它支持两种流行的开源内存缓存引擎：Redis 和 Memcached。</p><p>以下是 ElastiCache 的一些关键特点和功能：</p><ol><li><p>高性能缓存：ElastiCache 提供了快速、低延迟的内存缓存服务，可以显著提高应用程序的读取性能。通过将常用的数据存储在内存中，应用程序可以更快地检索数据，减轻后端数据库的负载。</p></li><li><p>托管服务：ElastiCache 是一种完全托管的服务，AWS 负责管理缓存集群的设置、维护和监控。这样，用户无需关心硬件和软件的细节，可以专注于应用程序的开发和性能优化。</p></li><li><p>可扩展性：ElastiCache 允许用户根据需要扩展缓存集群的规模，以适应不断增长的数据和流量。用户可以根据应用程序的需求增加或减少节点数，以实现水平扩展和高可用性。</p></li><li><p>Redis 和 Memcached 支持：ElastiCache 支持两种主流的开源内存缓存引擎：Redis 和 Memcached。用户可以根据自己的需求选择适合的引擎。Redis 提供了更丰富的功能，例如数据持久化、复制和发布/订阅，而 Memcached 则提供了简单高效的缓存功能。</p></li><li><p>自动故障转移和恢复：ElastiCache 提供自动故障转移功能，当缓存节点发生故障时，会自动将请求路由到可用节点，以保证高可用性和持续的服务。</p></li><li><p>安全性和权限控制：ElastiCache 提供了多层次的安全性和权限控制机制。用户可以使用 AWS Identity and Access Management（IAM）来管理对 ElastiCache 的访问权限，并通过网络隔离和访问控制列表（ACL）来保护缓存集群的安全性。</p></li><li><p>监控和日志记录：ElastiCache 提供了丰富的监控和日志记录功能，用户可以实时监控缓存集群的性能指标、运行状况和事件。此外，ElastiCache 还与 AWS CloudWatch 和 AWS CloudTrail 集成，以便进行更全面的监控和日志分析。</p></li></ol><p>通过使用 ElastiCache，用户可以轻松地添加和管理高性能的内存缓存层，提高应用程序的响应速度和可伸缩性。ElastiCache 提供了托管服务、可扩展性、安全性和监控等功能，使用户能够轻松地构建和管理缓存集群，以满足不同应用程序的需求。</p><h3 id="ECS（Elastic-Container-Service）"><a href="#ECS（Elastic-Container-Service）" class="headerlink" title="ECS（Elastic Container Service）"></a>ECS（Elastic Container Service）</h3><p>是亚马逊网络服务（AWS）提供的一种托管容器编排服务，用于在云中运行和管理容器化应用程序。它支持 Docker 容器，并提供了一种简单而高效的方式来部署、运行和扩展容器化应用程序。</p><p>以下是 ECS 的一些关键特点和功能：</p><ol><li><p>容器编排：ECS 提供了一种灵活的容器编排机制，可以方便地部署和管理容器化应用程序。它允许用户定义任务（Task）和服务（Service），并自动处理容器的调度、启动、停止和扩展。</p></li><li><p>容器集群：ECS 使用容器集群（Cluster）作为容器化应用程序的运行环境。用户可以创建和管理多个集群，每个集群可以包含多个 EC2 实例或 Fargate 任务（无需 EC2 实例）。集群提供了资源管理、负载均衡和容器调度等功能。</p></li><li><p>弹性扩展：ECS 允许根据应用程序的需求自动扩展容器实例。用户可以定义自动扩展策略，根据 CPU 使用率、内存使用率或其他指标来动态调整容器实例数量，以满足流量和负载的变化。</p></li><li><p>任务定义：ECS 使用任务定义（Task Definition）来描述容器化应用程序的配置和要求。任务定义包括容器映像、资源限制、网络设置和存储卷等信息。通过任务定义，用户可以定义应用程序的结构和配置，并将其部署到容器集群中。</p></li><li><p>服务调度：ECS 提供了服务调度功能，可以确保容器实例持续运行和可用。服务定义了要运行的任务数量、负载均衡设置和健康检查规则等。ECS 会自动监视容器实例的健康状态，并根据需要启动、停止或替换容器实例，以保持服务的可用性。</p></li><li><p>与其他 AWS 服务集成：ECS 与其他 AWS 服务集成紧密，例如 Elastic Load Balancing、Amazon VPC、AWS IAM 和 AWS CloudFormation 等。这使得用户可以轻松地将 ECS 与其他服务结合使用，构建完整的应用程序架构。</p></li><li><p>支持 Fargate：ECS 提供了 Fargate 托管模式，允许用户无需管理 EC2 实例即可运行容器。Fargate 提供了一种无服务器的容器执行环境，用户只需定义任务和服务，而无需关心底层基础设施。</p></li></ol><p>通过使用 ECS，用户可以轻松地部署、运行和扩展容器化应用程序。ECS 提供了容器编排、弹性扩展、服务调度和与其他 AWS 服务的集成等功能，使用户能够以高效和可靠的方式管理容器化应用程序，并实现弹性和可伸缩的部署。</p><h3 id="AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景："><a href="#AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景：" class="headerlink" title="AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景："></a>AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景：</h3><ol><li><p>**Amazon Simple Storage Service (S3)**：</p><ul><li>特点：高度可扩展的对象存储服务，提供99.999999999%的持久性，支持存储任意大小的数据。</li><li>应用场景：适用于存储网站内容、备份、归档、大数据分析等。</li></ul></li><li><p>**Amazon Elastic Block Store (EBS)**：</p><ul><li>特点：为EC2实例提供块级存储卷，支持频繁的读写操作，可实现持久存储。</li><li>应用场景：适合于需要持久、低延迟存储的场景，如数据库、文件系统等。</li></ul></li><li><p>**Amazon Elastic File System (EFS)**：</p><ul><li>特点：提供简单、可扩展的文件存储服务，可同时供多个EC2实例访问。</li><li>应用场景：适用于需要共享文件存储的应用，如内容管理、数据共享等。</li></ul></li><li><p><strong>Amazon Glacier</strong>：</p><ul><li>特点：低成本的长期备份和归档服务，检索时间可能从几分钟到几小时不等。</li><li>应用场景：适合长期数据归档，如法规遵从、数字保存等。</li></ul></li><li><p><strong>AWS Storage Gateway</strong>：</p><ul><li>特点：连接本地环境与AWS云存储的混合存储服务，支持文件、块及磁带数据。</li><li>应用场景：适用于需要将本地存储环境与云端集成的场景。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>：</p><ul><li>特点：快速、可扩展的NoSQL数据库服务，支持键值和文档数据模型。</li><li>应用场景：适用于需要高性能、灵活的数据库解决方案的应用，如移动应用、Web应用等。</li></ul></li><li><p>**Amazon Relational Database Service (RDS)**：</p><ul><li>特点：简化的关系数据库服务，支持包括MySQL、PostgreSQL、Oracle等在内的多种数据库引擎。</li><li>应用场景：适用于需要传统关系数据库的应用，如企业应用、ERP系统等。</li></ul></li></ol><p>每种服务都有其优势和局限性，选择合适的存储服务需要根据具体的应用需求、成本考虑以及性能要求来决定。</p><h3 id="AWS-Key-Management-Service（KMS）"><a href="#AWS-Key-Management-Service（KMS）" class="headerlink" title="AWS Key Management Service（KMS）"></a>AWS Key Management Service（KMS）</h3><p>是亚马逊网络服务（AWS）提供的一种托管密钥管理服务，用于创建和控制加密密钥，以保护数据的安全性。KMS 可以帮助用户轻松地生成、存储、使用和管理加密密钥，以加密和解密数据，并确保数据在存储和传输过程中的保密性。</p><p>以下是 AWS Key Management Service 的一些关键特点和功能：</p><ol><li><p>密钥生成和管理：KMS 提供了简单的 API 和控制台界面，用于生成和管理加密密钥。用户可以创建自己的主密钥（Customer Master Key，CMK）或使用 AWS 托管的主密钥。KMS 还提供了密钥轮换、禁用和删除等功能，以确保密钥的安全性和可管理性。</p></li><li><p>数据加密和解密：KMS 可以用于加密和解密数据。用户可以使用 KMS 提供的 API 或 AWS SDK 来对数据进行加密，然后在需要时使用相同的密钥进行解密。KMS 支持多种加密算法和模式，包括对称密钥加密和非对称密钥加密。</p></li><li><p>密钥策略和访问控制：KMS 允许用户定义密钥策略来控制谁可以使用密钥进行加密和解密操作。用户可以为每个密钥指定访问权限，并使用 AWS Identity and Access Management（IAM）来管理和控制对密钥的访问。</p></li><li><p>审计和监控：KMS 提供了审计日志和监控功能，用于跟踪密钥的使用情况和操作历史。用户可以通过 AWS CloudTrail 来获取密钥的操作日志，并使用 AWS CloudWatch 来监控密钥的使用情况和性能。</p></li><li><p>集成和扩展性：KMS 可以与其他 AWS 服务和应用程序集成，以提供端到端的数据加密解决方案。例如，可以将 KMS 与 Amazon S3、Amazon EBS、Amazon RDS 等服务结合使用，以实现对数据的加密保护。</p></li></ol><p>通过使用 AWS Key Management Service，用户可以轻松地生成、存储和管理加密密钥，以保护数据的安全性。KMS 提供了密钥生成和管理、数据加密和解密、密钥策略和访问控制、审计和监控等功能，为用户提供了一种可靠和安全的密钥管理解决方案。</p><h3 id="Amazon-Kinesis-Data-Streams"><a href="#Amazon-Kinesis-Data-Streams" class="headerlink" title="Amazon Kinesis Data Streams"></a>Amazon Kinesis Data Streams</h3><p>是亚马逊网络服务（AWS）提供的一种实时数据流平台，用于收集、处理和分析大规模实时数据流。它能够处理和存储来自数千个数据源的大量数据，并使用户能够实时处理和分析这些数据，以获得有关数据的实时洞察。</p><p>以下是 Amazon Kinesis Data Streams 的一些关键特点和功能：</p><ol><li><p>数据收集：Kinesis Data Streams 可以接收来自各种数据源（如应用程序、传感器、日志文件等）的大规模实时数据流。数据以流的形式发送到 Kinesis Data Streams，并按照时间顺序进行排序和存储。</p></li><li><p>实时数据处理：Kinesis Data Streams 允许用户实时处理数据流。用户可以使用 AWS Lambda、Amazon Kinesis Data Analytics、自定义应用程序等方式对数据进行实时处理和转换。这使用户能够即时响应数据流中的事件和模式，并执行实时计算、过滤、聚合等操作。</p></li><li><p>数据持久化和存储：Kinesis Data Streams 提供持久化的数据存储，可以在一段时间内保留数据流中的数据。用户可以根据需要配置数据保留期限，并随时访问和检索存储的数据。</p></li><li><p>可伸缩性和高可用性：Kinesis Data Streams 具有高度可伸缩和高可用的特性。它可以处理大量的并发数据流，并自动分配和扩展资源以适应数据流的需求。此外，Kinesis Data Streams 在多个 AWS 区域内提供冗余和容错，以确保数据的持续可用性和可靠性。</p></li><li><p>数据安全和访问控制：Kinesis Data Streams 提供多层数据安全和访问控制机制。用户可以使用 AWS Identity and Access Management（IAM）来管理对数据流的访问权限，并使用数据加密和传输加密等功能来保护数据的安全性。</p></li><li><p>与其他 AWS 服务的集成：Kinesis Data Streams 可以与其他 AWS 服务集成，以构建端到端的实时数据处理和分析解决方案。例如，可以将 Kinesis Data Streams 与 Amazon Kinesis Data Firehose、Amazon Kinesis Data Analytics、Amazon S3、Amazon Redshift 等服务结合使用，实现数据的收集、处理、存储和分析。</p></li></ol><p>通过使用 Amazon Kinesis Data Streams，用户可以轻松地处理和分析大规模实时数据流。它提供了数据收集、实时数据处理、数据持久化和存储、可伸缩性和高可用性、数据安全和访问控制等功能，为用户构建实时数据处理和分析的强大平台。</p><h3 id="ENI代表Elastic-Network-Interface（弹性网络接口）"><a href="#ENI代表Elastic-Network-Interface（弹性网络接口）" class="headerlink" title="ENI代表Elastic Network Interface（弹性网络接口）"></a>ENI代表Elastic Network Interface（弹性网络接口）</h3><p>是亚马逊网络服务（AWS）提供的一种虚拟网络接口，用于连接Amazon Elastic Compute Cloud（EC2）实例与虚拟私有云（VPC）之间的网络。</p><p>每个EC2实例可以附加一个或多个ENI，每个ENI都有自己的私有IP地址、MAC地址和安全组。ENI可以用于实现高级网络配置和功能，例如创建多个网络接口、实现高可用性和负载均衡、实现虚拟专用网络（VPC）间的流量转发等。</p><p>以下是ENI的一些关键特点和功能：</p><ol><li><p>网络连接：ENI允许EC2实例连接到VPC中的子网，并通过子网的路由表与其他资源进行通信。每个ENI都有一个私有IP地址，可以用于内部通信和与其他资源交互。</p></li><li><p>多个IP地址：每个ENI可以分配一个或多个IP地址，这些地址可以是IPv4地址或IPv6地址。这使得EC2实例能够处理多个网络流量和服务。</p></li><li><p>安全组：每个ENI都可以与一个或多个安全组相关联，用于控制入站和出站的网络流量。安全组是一种虚拟防火墙，可以定义允许或拒绝的网络流量规则。</p></li><li><p>弹性IP地址：ENI可以与弹性IP地址（Elastic IP）相关联，使EC2实例的IP地址保持不变。这对于需要固定公网IP地址的应用程序或服务非常有用。</p></li><li><p>高可用性和负载均衡：通过将多个ENI附加到EC2实例上，可以实现高可用性和负载均衡。这样，即使一个ENI或实例发生故障，仍然可以继续提供服务。</p></li><li><p>虚拟专用网络（VPC）间的流量转发：ENI还可以用于在不同的VPC之间转发流量。这可以通过在两个VPC之间创建一个带有ENI的转发实例来实现。</p></li></ol><p>通过使用ENI，用户可以实现更灵活和高级的网络配置，以满足特定的应用程序需求。ENI提供了网络连接、多个IP地址、安全组、弹性IP地址、高可用性和负载均衡等功能，为用户提供了强大的网络管理和控制能力。</p><h3 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h3><p>代表Elastic IP（弹性IP），是亚马逊网络服务（AWS）提供的一种静态公网IP地址。Elastic IP地址是与AWS账户相关联的IP地址，可以动态地映射到用户的云资源（如EC2实例、NAT网关等），并保持不变，即使资源被停止、重新启动或迁移。</p><p>以下是Elastic IP的一些关键特点和功能：</p><ol><li><p>固定公网IP地址：Elastic IP提供了一个固定的公网IP地址，用户可以将其分配给EC2实例、NAT网关或其他支持公网访问的AWS资源。这使得用户可以通过固定的IP地址访问其云资源，而不受资源启动、停止或重新分配的影响。</p></li><li><p>弹性和可靠性：Elastic IP是弹性和可靠的，可以在需要时轻松地将其映射到不同的云资源。用户可以根据需要将Elastic IP从一个实例或资源解绑，并绑定到另一个实例或资源上，而无需更改与该IP地址相关联的应用程序或服务。</p></li><li><p>公网访问：通过将Elastic IP地址分配给EC2实例或其他支持公网访问的资源，用户可以通过公网访问这些资源。这对于需要对外提供服务或需要远程访问资源的应用程序非常有用。</p></li><li><p>网络地址转换（NAT）：Elastic IP还可以与网络地址转换（NAT）网关相关联，用于实现私有子网中EC2实例的出站互联网访问。NAT网关使用Elastic IP地址作为源IP地址，将私有子网中的流量转发到公网。</p></li><li><p>费用和配额：Elastic IP地址在使用期间会产生费用。AWS为每个账户提供了一定数量的免费Elastic IP地址配额，超出配额的部分将会收取费用。用户可以根据需要管理和分配Elastic IP地址。</p></li></ol><p>通过使用Elastic IP，用户可以获得固定的公网IP地址，并将其分配给需要公网访问的云资源。Elastic IP具有弹性和可靠性，可以轻松映射到不同的资源，同时还可以与NAT网关一起使用实现私有子网中的出站互联网访问。</p><h3 id="AWS-CloudTrail-和-Amazon-CloudWatch-都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别："><a href="#AWS-CloudTrail-和-Amazon-CloudWatch-都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别：" class="headerlink" title="AWS CloudTrail 和 Amazon CloudWatch 都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别："></a>AWS CloudTrail 和 Amazon CloudWatch 都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别：</h3><ol><li><p><strong>功能焦点</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：主要用于记录和监控AWS账户中的API调用和相关事件。CloudTrail提供了一个记录谁在何时对AWS资源执行了什么操作的详细历史。这些信息对于安全分析、资源变更追踪、和合规审计非常重要。</li><li><strong>Amazon CloudWatch</strong>：专注于监控AWS资源和应用程序的运行状况。CloudWatch可以收集和跟踪指标，设置和管理告警，自动反应系统的变化。它用于实时监控应用程序的性能和运行状况。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：用于安全和合规审计。例如，追踪特定用户在特定时间进行的操作，审计资源的配置历史和变更，或者检测不寻常的活动，以识别安全威胁。</li><li><strong>Amazon CloudWatch</strong>：用于性能监控和管理。例如，监控EC2实例的CPU和网络使用情况，设置基于特定阈值的警报（如内存使用率过高），或自动扩展资源以应对负载变化。</li></ul></li><li><p><strong>数据类型</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：主要记录API调用和相关事件的日志，包括调用者身份、调用时间、请求参数以及响应元素等。</li><li><strong>Amazon CloudWatch</strong>：主要收集指标数据，如CPU利用率、磁盘读写、网络流量等。同时，CloudWatch Logs可以收集、监控和存储日志文件。</li></ul></li><li><p><strong>数据保留</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：默认情况下，CloudTrail事件日志在S3中保留无限期，但是可以根据需要配置保留策略。</li><li><strong>Amazon CloudWatch</strong>：指标数据的默认保留期限不同（从3小时到15个月不等），而日志数据的保留期限是可以配置的，从永久保存到自动删除都可以。</li></ul></li></ol><p>总结来说，CloudTrail更偏向于安全和合规的日志记录，而CloudWatch则侧重于性能监控和实时数据分析。两者通常结合使用，以提供全面的资源监控和事件记录功能。</p><h3 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h3><p>Amazon Athena 是一种交互式查询服务，使您能够使用标准 SQL 轻松分析存储在 Amazon S3 中的数据。没有需设置复杂的数据仓库或管理基础设施。</p><h3 id="AWS-Data-Exchange"><a href="#AWS-Data-Exchange" class="headerlink" title="AWS Data Exchange"></a>AWS Data Exchange</h3><p>AWS Data Exchange 允许客户在 AWS 云中轻松查找、订阅和使用第三方数据。这种服务简化了数据许可和交换过程。</p><h3 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h3><p>AWS Data Pipeline 是一种云服务，用于自动化数据移动和转换过程。它可以帮助你轻松地将数据从一个地方移动和处理到另一个地方。</p><h3 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h3><p>Amazon EMR 是一种托管的群集平台，可处理大量数据集并运行大数据分析作业。它支持多种大数据框架，如 Apache Hadoop 和 Apache Spark。</p><h3 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h3><p>AWS Glue 是一种完全托管的提取、转换和加载（ETL）服务，用于准备和加载数据。它自动发现和分类数据，使得数据集成更加容易。</p><h3 id="Amazon-Kinesis"><a href="#Amazon-Kinesis" class="headerlink" title="Amazon Kinesis"></a>Amazon Kinesis</h3><p>Amazon Kinesis 使您能够在实时地收集、处理和分析视频和数据流。这对于实时应用程序和数据分析非常重要。</p><h3 id="AWS-Lake-Formation"><a href="#AWS-Lake-Formation" class="headerlink" title="AWS Lake Formation"></a>AWS Lake Formation</h3><p>AWS Lake Formation 是一种服务，用于建立、安全地管理和共享数据湖。它简化了数据湖的设置和管理。</p><h3 id="Amazon-Managed-Streaming-for-Apache-Kafka-Amazon-MSK"><a href="#Amazon-Managed-Streaming-for-Apache-Kafka-Amazon-MSK" class="headerlink" title="Amazon Managed Streaming for Apache Kafka (Amazon MSK)"></a>Amazon Managed Streaming for Apache Kafka (Amazon MSK)</h3><p>Amazon MSK 是一种完全托管的 Apache Kafka 服务，使您能够构建和运行应用程序，这些应用程序可处理来自多个数据源的流数据。</p><h3 id="Amazon-OpenSearch-Service"><a href="#Amazon-OpenSearch-Service" class="headerlink" title="Amazon OpenSearch Service"></a>Amazon OpenSearch Service</h3><p>Amazon OpenSearch Service（原名Amazon Elasticsearch Service）提供了在 AWS 上运行 OpenSearch（一种流行的开源搜索和分析引擎）的能力。</p><h3 id="Amazon-QuickSight"><a href="#Amazon-QuickSight" class="headerlink" title="Amazon QuickSight"></a>Amazon QuickSight</h3><p>Amazon QuickSight 是一种快速、易用的商业智能服务，用于从您的数据中构建可视化效果，并提供洞察力。</p><h3 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h3><p>Amazon Redshift 是一种快速、可扩展的数据仓库服务，使您能够分析所有数据使用标准 SQL 和现有的商业智能工具。</p><h3 id="应用程序集成"><a href="#应用程序集成" class="headerlink" title="应用程序集成"></a>应用程序集成</h3><h4 id="Amazon-AppFlow"><a href="#Amazon-AppFlow" class="headerlink" title="Amazon AppFlow"></a>Amazon AppFlow</h4><p>Amazon AppFlow 是一种集成服务，使您能够在 AWS 和 SaaS 应用程序（如 Salesforce、ServiceNow 和 Slack）之间轻松传输数据。</p><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><p>AWS AppSync 是一种完全托管的服务，用于开发 GraphQL API，实现应用程序数据的即时同步。</p><h4 id="Amazon-EventBridge"><a href="#Amazon-EventBridge" class="headerlink" title="Amazon EventBridge"></a>Amazon EventBridge</h4><p>Amazon EventBridge 是一种服务器事件总线服务，它使应用程序能够与来自 AWS 服务、自定义应用程序和 SaaS 应用程序的事件进行交互。</p><h4 id="Amazon-MQ"><a href="#Amazon-MQ" class="headerlink" title="Amazon MQ"></a>Amazon MQ</h4><p>Amazon MQ 是一种托管的消息代理服务，适用于 ActiveMQ 和 RabbitMQ，使您能夠建立通信系统，轻松地在应用程序之间发送和接收消息。</p><h4 id="Amazon-Simple-Notification-Service-Amazon-SNS"><a href="#Amazon-Simple-Notification-Service-Amazon-SNS" class="headerlink" title="Amazon Simple Notification Service (Amazon SNS)"></a>Amazon Simple Notification Service (Amazon SNS)</h4><p>Amazon SNS 是一种完全托管的发布/订阅消息通知服务，您可以用它来分离微服务、分布式系统和服务器。</p><h4 id="Amazon-Simple-Queue-Service-Amazon-SQS"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS)"></a>Amazon Simple Queue Service (Amazon SQS)</h4><p>Amazon SQS 提供了托管的消息队列服务，以便您可以通过解耦和扩展微服务、分布式系统和服务器应用程序来传输任何量的数据。</p><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><p>AWS Step Functions 是一种服务，用于在 AWS 上协调各种服务的组件。它使得创建和管理复杂工作流程变得容易。</p><h3 id="AWS-成本管理"><a href="#AWS-成本管理" class="headerlink" title="AWS 成本管理"></a>AWS 成本管理</h3><h4 id="AWS-Budgets"><a href="#AWS-Budgets" class="headerlink" title="AWS Budgets"></a>AWS Budgets</h4><p>AWS Budgets 允许您设置自定义的预算，以便跟踪您的成本和使用情况。</p><h4 id="AWS-成本和使用情况报告"><a href="#AWS-成本和使用情况报告" class="headerlink" title="AWS 成本和使用情况报告"></a>AWS 成本和使用情况报告</h4><p>这项服务提供了有关您的 AWS 成本</p><p>和使用情况的详细报告，帮助您更好地了解和管理 AWS 费用。</p><h4 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h4><p>AWS Cost Explorer 是一种分析工具，用于可视化和理解 AWS 花费和使用情况数据。</p><h4 id="Savings-Plans"><a href="#Savings-Plans" class="headerlink" title="Savings Plans"></a>Savings Plans</h4><p>Savings Plans 是一种灵活的定价模型，提供对特定 AWS 服务的显著折扣，换取一定时间内的使用承诺。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><p>AWS Batch 允许您运行大规模的批处理作业，自动地在 AWS 的云计算资源上。</p><h4 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h4><p>Amazon Elastic Compute Cloud (Amazon EC2) 提供了可伸缩的计算容量。这使您可以快速启动和管理虚拟服务器。</p><h4 id="Amazon-EC2-Auto-Scaling"><a href="#Amazon-EC2-Auto-Scaling" class="headerlink" title="Amazon EC2 Auto Scaling"></a>Amazon EC2 Auto Scaling</h4><p>Amazon EC2 Auto Scaling 帮助您确保具有正确数量的 Amazon EC2 实例来处理应用程序的负载。</p><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><p>AWS Elastic Beanstalk 是一种易于使用的服务，用于部署和扩展 Web 应用程序和服务。</p><h4 id="AWS-Outposts"><a href="#AWS-Outposts" class="headerlink" title="AWS Outposts"></a>AWS Outposts</h4><p>AWS Outposts 是一种完全托管的服务，将 AWS 基础设施、服务、API 和工具扩展到几乎任何数据中心、共同托管空间或本地设施。</p><h4 id="AWS-Serverless-Application-Repository"><a href="#AWS-Serverless-Application-Repository" class="headerlink" title="AWS Serverless Application Repository"></a>AWS Serverless Application Repository</h4><p>AWS Serverless Application Repository 是一种管理和部署无服务器应用程序的平台。</p><h4 id="VMware-Cloud-on-AWS"><a href="#VMware-Cloud-on-AWS" class="headerlink" title="VMware Cloud on AWS"></a>VMware Cloud on AWS</h4><p>VMware Cloud on AWS 是一个集成的云服务，使您能够在 AWS 云上运行基于 VMware 的环境。</p><h4 id="AWS-Wavelength"><a href="#AWS-Wavelength" class="headerlink" title="AWS Wavelength"></a>AWS Wavelength</h4><p>AWS Wavelength 将 AWS 服务扩展到移动和边缘设备，使开发人员能够构建提供超低延迟应用程序的应用程序。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="Amazon-ECS-Anywhere"><a href="#Amazon-ECS-Anywhere" class="headerlink" title="Amazon ECS Anywhere"></a>Amazon ECS Anywhere</h4><p>Amazon ECS Anywhere 允许您在任何基础设施上运行 Amazon ECS，包括您自己的数据中心。</p><h4 id="Amazon-EKS-Anywhere"><a href="#Amazon-EKS-Anywhere" class="headerlink" title="Amazon EKS Anywhere"></a>Amazon EKS Anywhere</h4><p>Amazon EKS Anywhere 提供了一种在您自己的基础设施上运行 Amazon EKS 的方式。</p><h4 id="Amazon-EKS-Distro"><a href="#Amazon-EKS-Distro" class="headerlink" title="Amazon EKS Distro"></a>Amazon EKS Distro</h4><p>Amazon EKS Distro 是一个 Kubernetes 分发版，您可以在任何环境中运行它，包括您自己的数据中心。</p><h4 id="Amazon-Elastic-Container-Registry-Amazon-ECR"><a href="#Amazon-Elastic-Container-Registry-Amazon-ECR" class="headerlink" title="Amazon Elastic Container Registry (Amazon ECR)"></a>Amazon Elastic Container Registry (Amazon ECR)</h4><p>Amazon ECR 是一种完全托管的 Docker 容器注册服务，使开发人员可以轻松存储、管理和部署 Docker 容器映像。</p><h4 id="Amazon-Elastic-Container-Service-Amazon-ECS"><a href="#Amazon-Elastic-Container-Service-Amazon-ECS" class="headerlink" title="Amazon Elastic Container Service (Amazon ECS)"></a>Amazon Elastic Container Service (Amazon ECS)</h4><p>Amazon ECS 是一种高度可扩展的、高性能的容器管理服务，支持 Docker 容器。</p><h4 id="Amazon-Elastic-Kubernetes-Service-Amazon-EKS"><a href="#Amazon-Elastic-Kubernetes-Service-Amazon-EKS" class="headerlink" title="Amazon Elastic Kubernetes Service (Amazon EKS)"></a>Amazon Elastic Kubernetes Service (Amazon EKS)</h4><p>Amazon EKS 是一种托管服务，使您可以在 AWS 上轻松运行 Kubernetes。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h4><p>Amazon Aurora 是一种兼容 MySQL 和 PostgreSQL 的关系数据库，它结合了商业数据库的性能和可用性以及开源数据库的成本效益。</p><h4 id="Amazon-Aurora-Serverless"><a href="#Amazon-Aurora-Serverless" class="headerlink" title="Amazon Aurora Serverless"></a>Amazon Aurora Serverless</h4><p>Amazon Aurora Serverless 是一种自动缩放的 Aurora 数据库版本，适用于不需要持续数据库连接的应用程序。</p><h4 id="Amazon-DocumentDB（兼容-MongoDB）"><a href="#Amazon-DocumentDB（兼容-MongoDB）" class="headerlink" title="Amazon DocumentDB（兼容 MongoDB）"></a>Amazon DocumentDB（兼容 MongoDB）</h4><p>Amazon DocumentDB 是一种文档数据库服务，与 MongoDB 兼容，为 JSON 数据提供持久性存储。</p><h4 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h4><p>Amazon DynamoDB 是一种快速和灵活的 NoSQL 数据库服务，适用于所有需要一致的、单毫秒级延迟的应用程序。</p><h4 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h4><p>Amazon ElastiCache 是一种缓存服务，支持 Redis 和 Memcached。它用于提升数据库和应用程序的性能。</p><h4 id="Amazon-Keyspaces（适用于-Apache-Cassandra）"><a href="#Amazon-Keyspaces（适用于-Apache-Cassandra）" class="headerlink" title="Amazon Keyspaces（适用于 Apache Cassandra）"></a>Amazon Keyspaces（适用于 Apache Cassandra）</h4><p>Amazon Keyspaces 是一种可扩展、高可用性和托管的 Apache Cassandra 兼容数据库服务。</p><p>!</p><p>ChatGPT</p><h2 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h2><p>Amazon Neptune 是一种完全托管的图数据库服务，专门设计用于存储和导航连接数据。它支持广泛的图查询语言，如Gremlin和SPARQL，使其适用于构建高效的关系网络应用程序，如社交网络、推荐引擎或知识图谱。</p><h2 id="Amazon-Quantum-Ledger-Database-Amazon-QLDB"><a href="#Amazon-Quantum-Ledger-Database-Amazon-QLDB" class="headerlink" title="Amazon Quantum Ledger Database (Amazon QLDB)"></a>Amazon Quantum Ledger Database (Amazon QLDB)</h2><p>Amazon QLDB 是一个完全托管的账本数据库，提供一个透明、可验证且不可篡改的交易日志记录功能。它旨在为需要记录和跟踪数据变更历史的应用程序提供高性能和易于使用的数据结构。</p><h2 id="Amazon-RDS"><a href="#Amazon-RDS" class="headerlink" title="Amazon RDS"></a>Amazon RDS</h2><p>Amazon RDS（Relational Database Service）是一个托管型SQL数据库服务，支持多种数据库引擎，如MySQL、PostgreSQL、Oracle和SQL Server。它简化了数据库设置、运维和扩展工作，同时提供高可用性和安全性。</p><h2 id="Amazon-Redshift-1"><a href="#Amazon-Redshift-1" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p>Amazon Redshift 是一种完全托管的、基于列的数据仓库服务，它允许用户通过SQL查询大规模数据集。它特别适合用于数据仓库和大数据分析任务。</p><h2 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h2><p>AWS X-Ray 是一种服务，帮助开发人员分析和调试在AWS环境中运行的应用程序。它提供了一个详细的视图，显示应用程序如何在分布式系统中执行，帮助识别和解决性能瓶颈和错误。</p><h2 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h2><p>AWS Amplify 是一套工具和服务，可帮助前端开发人员更快地构建全栈应用程序。它提供了一系列功能，包括认证、API、数据库和文件存储，以及与React、Angular、Vue和其他JavaScript框架的集成。</p><h2 id="Amazon-API-Gateway"><a href="#Amazon-API-Gateway" class="headerlink" title="Amazon API Gateway"></a>Amazon API Gateway</h2><p>Amazon API Gateway 是一项托管服务，使开发人员可以轻松地创建、发布、维护、监控和保护API。它处理所有的API托管任务，包括流量管理、授权和访问控制、监控以及API版本管理。</p><h2 id="AWS-Device-Farm"><a href="#AWS-Device-Farm" class="headerlink" title="AWS Device Farm"></a>AWS Device Farm</h2><p>AWS Device Farm 是一种应用测试服务，允许开发人员在多种真实设备上测试他们的Web和移动应用程序。它提供了一个云端平台，用于测试应用程序的功能性和性能，确保在多种设备和操作系统上都能正常运行。</p><h2 id="Amazon-Pinpoint"><a href="#Amazon-Pinpoint" class="headerlink" title="Amazon Pinpoint"></a>Amazon Pinpoint</h2><p>Amazon Pinpoint 是一种灵活的、用户参与服务，旨在帮助公司通过电子邮件、短信、推送通知等渠道有效地与客户沟通。它支持客户参与分析和营销活动的自动化。</p><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend"></a>Amazon Comprehend</h2><p>Amazon Comprehend 是一种基于自然语言处理（NLP）的服务，可以识别文本中的语言、提取关键短语、地点、人名、品牌、情绪等。它广泛用于文本分析和数据挖掘。</p><h2 id="Amazon-Forecast"><a href="#Amazon-Forecast" class="headerlink" title="Amazon Forecast"></a>Amazon Forecast</h2><p>Amazon Forecast 是一种基于机器学习的预测服务，它可以根据历史数据预测未来趋势。这种服务适用于库存规划、资源需求预测、金融市场分析等场景。</p><h2 id="Amazon-Fraud-Detector"><a href="#Amazon-Fraud-Detector" class="headerlink" title="Amazon Fraud Detector"></a>Amazon Fraud Detector</h2><p>Amazon Fraud Detector 是一种基于机器学习和大量欺诈数据集的服务，用于检测在线活动中的欺诈行为。它可以帮助企业识别潜在的欺诈交易和异常活动。</p><h2 id="Amazon-Kendra"><a href="#Amazon-Kendra" class="headerlink" title="Amazon Kendra"></a>Amazon Kendra</h2><p>Amazon Kendra 是一种高度精准的企业级搜索服务，使用机器学习提供更自然的搜索体验。它能够理解复杂的用户查询，提供高相关性的搜索结果。</p><h2 id="Amazon-Lex"><a href="#Amazon-Lex" class="headerlink" title="Amazon Lex"></a>Amazon Lex</h2><p>Amazon Lex 是一种服务，使开发人员能够构建能与用户自然交流的对话界面。它是构建聊天机器人的主要工具，可以集成到各种应用程序和服务中。</p><h2 id="Amazon-Polly"><a href="#Amazon-Polly" class="headerlink" title="Amazon Polly"></a>Amazon Polly</h2><p>Amazon Polly 是一种文本转语音服务，它使用高级深度学习技术将文本转换成自然听起来的语音。它支持多种语言和声音，适用于创建各种语音应用程序。</p><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p>Amazon Rekognition 是一种图像和视频分析服务，它使用机器学习模型识别图像和视频中的对象、场景、人脸等。它广泛用于媒体分析、安全监控等领域。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p>Amazon SageMaker 是一个全面的机器学习服务，它帮助数据科学家和开发人员快速构建、训练和部署机器学习模型。它提供了一系列工具来简化机器学习工作流程。</p><h2 id="Amazon-Textract"><a href="#Amazon-Textract" class="headerlink" title="Amazon Textract"></a>Amazon Textract</h2><p>Amazon Textract 是一种文档分析服务，它可以自动提取PDF、图像和扫描文档中的文本、表格和表单数据。它可以用于自动化文档处理任务。</p><h2 id="Amazon-Transcribe"><a href="#Amazon-Transcribe" class="headerlink" title="Amazon Transcribe"></a>Amazon Transcribe</h2><p>Amazon Transcribe 是一个自动语音识别服务，它可以将音频和视频文件中的语音转换为文本。它支持多种语言和方言，适用于生成字幕、转录会议记录等。</p><h2 id="Amazon-Translate"><a href="#Amazon-Translate" class="headerlink" title="Amazon Translate"></a>Amazon Translate</h2><p>Amazon Translate 是一种神经机器翻译服务，它提供快速、高质量的语言翻译。它支持多种语言，可以用于网站、应用程序和内容的本地化。</p><h2 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h2><p>AWS Auto Scaling 是一种服务，帮助您自动调整AWS资源的数量，以满足应用程序的需求。它可以根据预定的条件和指标自动增加或减少资源，确保性能和成本效率。</p><h2 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h2><p>AWS CloudFormation 是一种服务，使开发人员可以使用代码来定义和部署AWS资源。它可以自动化和简化资源管理，确保基础设施的一致性和重复性。</p><h2 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h2><p>AWS CloudTrail 是一项服务，用于记录AWS账户的API调用和相关事件。这些日志可以用于安全分析、资源变更追踪和合规性审计。</p><h2 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h2><p>是 Amazon Web Services（AWS）提供的一项监控服务，主要用于对在 AWS 上运行的应用程序和资源进行监控和管理。CloudWatch 提供了多种功能，使您能够收集和跟踪指标、收集和监控日志文件，以及设置警报。下面是 CloudWatch 的一些主要功能和应用：</p><p>指标收集与监控：CloudWatch 可以收集如 CPU 使用率、网络使用量、磁盘读写次数等各种指标。这些指标可用于监控 AWS 资源（如 EC2 实例、Amazon RDS 数据库实例等）的性能。</p><p>日志管理：CloudWatch Logs 服务允许您监控、存储和访问日志文件。您可以使用 CloudWatch Logs 来监控应用程序的日志，这对于诊断问题和维护应用程序运行状况非常有用。</p><p>警报：CloudWatch Alarms 可以让您在某个指标达到预设阈值时得到通知。警报可以用于实时监控应用程序和资源的状态，并在问题出现时及时做出响应。</p><p>自动化反应：结合 AWS 自动化工具（如 AWS Lambda 或 Auto Scaling），当特定指标达到某个值时，CloudWatch 可以触发自动化动作，例如启动或停止实例。</p><p>自定义指标与仪表板：您还可以发布自定义指标到 CloudWatch，并使用 CloudWatch Dashboards 创建可视化的数据面板，这有助于您更直观地理解和分析数据。</p><p>集成与扩展性：CloudWatch 与其他 AWS 服务紧密集成，例如 AWS Identity and Access Management (IAM)、Amazon S3、Amazon EC2 等，支持广泛的应用场景。</p><h2 id="AWS-Command-Line-Interface-AWS-CLI"><a href="#AWS-Command-Line-Interface-AWS-CLI" class="headerlink" title="AWS Command Line Interface (AWS CLI)"></a>AWS Command Line Interface (AWS CLI)</h2><p>AWS Command Line Interface (CLI) 是一个工具，允许开发人员通过命令行界面管理AWS服务。它提供了一种简便的方式来访问AWS的广泛服务。</p><h2 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h2><p>AWS Compute Optimizer 是一种工具，它使用机器学习来推荐适合您工作负载的AWS资源配置。它旨在优化性能和成本效率。</p><h2 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h2><p>AWS Config 是一种服务，用于评估、审计和评估AWS资源的配置。它可以帮助确保资源符合公司政策和合规性要求。</p><h2 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h2><p>AWS Control Tower 是一种管理服务，提供了一个中央仪表板来监控和管理多个AWS账户。它提供了一种简化的方式来建立和维护安全的、合规的多账户环境。</p><h2 id="AWS-Health-Dashboard"><a href="#AWS-Health-Dashboard" class="headerlink" title="AWS Health Dashboard"></a>AWS Health Dashboard</h2><p>AWS Health Dashboard 提供了有关 AWS 服务健康状况的实时信息。它提供了服务中断和维护事件的通知，帮助用户及时了解和应对潜在的服务影响。</p><h2 id="AWS-License-Manager"><a href="#AWS-License-Manager" class="headerlink" title="AWS License Manager"></a>AWS License Manager</h2><p>AWS License Manager 使用户能够管理软件许可证的使用情况。它有助于用户遵守许可证规定，避免超出许可证的约束，从而降低合规风险。</p><h2 id="Amazon-Managed-Grafana"><a href="#Amazon-Managed-Grafana" class="headerlink" title="Amazon Managed Grafana"></a>Amazon Managed Grafana</h2><p>Amazon Managed Grafana 是一种开源分析和可视化平台，由 AWS 管理。用户可以使用它来监控和分析其AWS环境中的数据。</p><h2 id="Amazon-Managed-Service-for-Prometheus"><a href="#Amazon-Managed-Service-for-Prometheus" class="headerlink" title="Amazon Managed Service for Prometheus"></a>Amazon Managed Service for Prometheus</h2><p>这是一种完全托管的服务，它兼容开源 Prometheus，用于监控和警报。它专门用于容器化和微服务架构的监控。</p><h2 id="AWS-管理控制台"><a href="#AWS-管理控制台" class="headerlink" title="AWS 管理控制台"></a>AWS 管理控制台</h2><p>AWS管理控制台是一个基于网页的界面，用于管理AWS账户和运行的服务。它提供了一个用户友好的界面，用于访问和管理AWS资源。</p><h2 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h2><p>AWS Organizations 允许用户以集中的方式管理和治理其多个AWS账户。它支持账户分组、策略设置和成本报告等功能。</p><h2 id="AWS-Proton"><a href="#AWS-Proton" class="headerlink" title="AWS Proton"></a>AWS Proton</h2><p>AWS Proton 是一种完全托管的应用交付服务，用于自动化和管理服务器和无服务器应用程序的部署。</p><h2 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h2><p>AWS Service Catalog 允许组织创建和管理可授权给用户使用的预定义的IT服务和产品目录。</p><h2 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h2><p>AWS Systems Manager 提供了一套集成工具，用于自动化和管理AWS环境。这包括资源配置、监控和自动化任务执行等。</p><h2 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h2><p>AWS Trusted Advisor 是一种在线工具，提供了对AWS环境的最佳实践建议。它涉及成本优化、性能、安全和容错能力。</p><h2 id="AWS-Well-Architected-Tool"><a href="#AWS-Well-Architected-Tool" class="headerlink" title="AWS Well-Architected Tool"></a>AWS Well-Architected Tool</h2><p>这是一种帮助用户检查其AWS工作负载是否符合最佳实践的工具。它提供了指导和建议，以优化工作负载。</p><h2 id="媒体服务"><a href="#媒体服务" class="headerlink" title="媒体服务"></a>媒体服务</h2><h3 id="Amazon-Elastic-Transcoder"><a href="#Amazon-Elastic-Transcoder" class="headerlink" title="Amazon Elastic Transcoder"></a>Amazon Elastic Transcoder</h3><p>这是一种媒体转码服务，用于将音视频文件转换成不同的格式，以便在各种设备和平台上播放。</p><h3 id="Amazon-Kinesis-Video-Streams"><a href="#Amazon-Kinesis-Video-Streams" class="headerlink" title="Amazon Kinesis Video Streams"></a>Amazon Kinesis Video Streams</h3><p>该服务允许用户安全地将视频流连接到AWS用于分析和其他处理。</p><h2 id="迁移和传输"><a href="#迁移和传输" class="headerlink" title="迁移和传输"></a>迁移和传输</h2><h3 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h3><p>此服务帮助企业快速准确地了解其IT基础设施，以便更有效地规划迁移。</p><h3 id="AWS-Application-Migration-Service"><a href="#AWS-Application-Migration-Service" class="headerlink" title="AWS Application Migration Service"></a>AWS Application Migration Service</h3><p>这是一种自动化迁移服务，可简化应用程序的迁移过程，从而加速迁移和降低成本。</p><h3 id="AWS-Database-Migration-Service-AWS-DMS"><a href="#AWS-Database-Migration-Service-AWS-DMS" class="headerlink" title="AWS Database Migration Service (AWS DMS)"></a>AWS Database Migration Service (AWS DMS)</h3><p>AWS DMS 支持不同数据库之间的迁移，包括跨平台迁移，同时最小化停机时间。</p><h3 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h3><p>DataSync 是一个数据迁移工具，用于快速、安全地移动大量数据到和从AWS。</p><h3 id="AWS-Migration-Hub"><a href="#AWS-Migration-Hub" class="headerlink" title="AWS Migration Hub"></a>AWS Migration Hub</h3><p>AWS Migration Hub 提供了一个中心位置来跟踪和管理整个迁移过程。</p><h3 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h3><p>这包括一系列物理设备，用于大数据量的迁移，以及边缘计算和存储。</p><h3 id="AWS-Transfer-Family"><a href="#AWS-Transfer-Family" class="headerlink" title="AWS Transfer Family"></a>AWS Transfer Family</h3><p>提供安全、全面的文件传输服务，支持标准协议，如SFTP、FTPS和FTP。</p><h2 id="联网和内容分发"><a href="#联网和内容分发" class="headerlink" title="联网和内容分发"></a>联网和内容分发</h2><h3 id="AWS-Client-VPN"><a href="#AWS-Client-VPN" class="headerlink" title="AWS Client VPN"></a>AWS Client VPN</h3><p>这是一种托管的VPN服务，可为用户提供安全的远程访问。</p><h3 id="Amazon-CloudFront-1"><a href="#Amazon-CloudFront-1" class="headerlink" title="Amazon CloudFront"></a>Amazon CloudFront</h3><p>CloudFront 是一种全球内容分发网络(CDN)服务，它加速了网站和其他web内容的分发。</p><h3 id="AWS-Direct-Connect"><a href="#AWS-Direct-Connect" class="headerlink" title="AWS Direct Connect"></a>AWS Direct Connect</h3><p>通过 Direct Connect，用户可以在AWS和自己的数据中心之间建立私有网络连接。</p><h3 id="弹性负载均衡（ELB）"><a href="#弹性负载均衡（ELB）" class="headerlink" title="弹性负载均衡（ELB）"></a>弹性负载均衡（ELB）</h3><p>ELB 自动分发进入的应用程序流量，提高应用的可用性和容错能力。</p><h3 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h3><p>这是一种服务，可以提高用户向全球用户提供应用程序的性能。</p><h3 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h3><p>PrivateLink 提供了一种安全的连接方式，将AWS服务和VPC、本地网络连接起来。</p><h3 id="Amazon-Route-53"><a href="#Amazon-Route-53" class="headerlink" title="Amazon Route 53"></a>Amazon Route 53</h3><p>这是一种可扩展的云DNS服务，用于域名解析和路由互联网流量。</p><h3 id="AWS-Site-to-Site-VPN"><a href="#AWS-Site-to-Site-VPN" class="headerlink" title="AWS Site-to-Site VPN"></a>AWS Site-to-Site VPN</h3><p>通过 Site-to-Site VPN，用户可以将本地网络安全地连接到AWS VPC。</p><h3 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h3><p>Transit Gateway 简化了网络架构，允许不同的VPC和本地网络通过单一网关连接。</p><h3 id="Amazon-VPC"><a href="#Amazon-VPC" class="headerlink" title="Amazon VPC"></a>Amazon VPC</h3><p>Amazon VPC 允许用户在AWS云中启动AWS资源，提供了可控的网络环境。</p><h2 id="安全性、身份与合规性"><a href="#安全性、身份与合规性" class="headerlink" title="安全性、身份与合规性"></a>安全性、身份与合规性</h2><h3 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h3><p>这是一个资源门户，提供有关AWS合规性和安全性文档的访问。</p><h3 id="AWS-Audit-Manager"><a href="#AWS-Audit-Manager" class="headerlink" title="AWS Audit Manager"></a>AWS Audit Manager</h3><p>Audit Manager 帮助用户自动化合规性审计过程，简化了审计工作。</p><h3 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h3><p>ACM 用于轻松创建、管理和部署SSL/TLS证书，保障网站和应用的安全。</p><h3 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h3><p>CloudHSM 提供了硬件安全模块(HSM)设备，以增强数据加密和密钥管理的安全性。</p><h3 id="Amazon-Cognito"><a href="#Amazon-Cognito" class="headerlink" title="Amazon Cognito"></a>Amazon Cognito</h3><p>Cognito 提供用户身份和数据同步服务，支持移动和网络应用程序的用户认证。</p><h3 id="Amazon-Detective"><a href="#Amazon-Detective" class="headerlink" title="Amazon Detective"></a>Amazon Detective</h3><p>Amazon Detective 是一种分析服务，用于调查和识别安全问题和可疑活动。</p><h3 id="AWS-Directory-Service"><a href="#AWS-Directory-Service" class="headerlink" title="AWS Directory Service"></a>AWS Directory Service</h3><p>这个服务为AWS资源提供了Microsoft Active Directory (AD)的实现。</p><h3 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h3><p>Firewall Manager 简化了AWS账户内防火墙规则的管理和维护。</p><h3 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h3><p>GuardDuty 是一种智能威胁检测服务，保护AWS账户和工作负载免受恶意活动。</p><h3 id="AWS-IAM-Identity-Center-AWS-Single-Sign-On"><a href="#AWS-IAM-Identity-Center-AWS-Single-Sign-On" class="headerlink" title="AWS IAM Identity Center (AWS Single Sign-On)"></a>AWS IAM Identity Center (AWS Single Sign-On)</h3><p>提供单点登录(SSO)服务，使用户可以方便地访问AWS和第三方应用程序。</p><h3 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h3><p>IAM 允许用户管理对AWS服务和资源的访问权限。</p><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><p>Inspector 是一种自动化安全评估服务，帮助改善应用程序的安全性和合规性。</p><h3 id="AWS-Key-Management-Service-AWS-KMS"><a href="#AWS-Key-Management-Service-AWS-KMS" class="headerlink" title="AWS Key Management Service (AWS KMS)"></a>AWS Key Management Service (AWS KMS)</h3><p>KMS 提供了创建和控制加密密钥的能力，用于加密数据。</p><h3 id="Amazon-Macie"><a href="#Amazon-Macie" class="headerlink" title="Amazon Macie"></a>Amazon Macie</h3><p>Macie 使用机器学习和模式匹配来识别和保护敏感数据。</p><h3 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h3><p>这是一种防火墙服务，用于保护VPC网络。</p><h3 id="AWS-Resource-Access-Manager-AWS-RAM"><a href="#AWS-Resource-Access-Manager-AWS-RAM" class="headerlink" title="AWS Resource Access Manager (AWS RAM)"></a>AWS Resource Access Manager (AWS RAM)</h3><p>RAM 允许用户共享AWS资源，实现跨账户资源共享。</p><h3 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h3><p>Secrets Manager 用于管理、检索和轮换数据库凭证、API密钥和其他机密。</p><h3 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h3><p>Security Hub 提供了一个集中的安全和合规性视图，跨多个AWS服务聚合安全性数据。</p><h3 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h3><p>Shield 是一种DDoS保护服务，保护AWS资源免受DDoS攻击。</p><h3 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h3><p>AWS WAF (Web Application Firewall) 是一种帮助保护 Web 应用程序或 API 免受网络攻击的服务。它可以过滤、监控和控制传入和传出的 HTTP(S) 流量。AWS WAF 提供了自定义的规则集，可以用来阻止常见的网络攻击，如 SQL 注入和跨站脚本 (XSS)。</p><h3 id="无服务器服务"><a href="#无服务器服务" class="headerlink" title="无服务器服务"></a>无服务器服务</h3><h4 id="AWS-AppSync-1"><a href="#AWS-AppSync-1" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><p>AWS AppSync 是一种托管的 GraphQL 服务，用于构建 API，使应用程序能够安全地访问、操纵和组合来自一个或多个数据源的数据。它支持实时数据同步和离线数据访问，适用于构建复杂的数据驱动应用程序。</p><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><p>AWS Fargate 是一种无服务器计算引擎，用于 Amazon ECS 和 EKS，让用户无需管理服务器即可运行容器。Fargate 自动管理容器的扩展和基础设施，使得容器化应用程序的部署和管理更加简便。</p><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><p>AWS Lambda 是一种事件驱动的计算服务，可运行代码以响应事件并自动管理计算资源。Lambda 可以用于构建各种应用程序和后端服务，只需上传代码，Lambda 即可为其分配资源并运行。</p><h3 id="存储服务"><a href="#存储服务" class="headerlink" title="存储服务"></a>存储服务</h3><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><p>AWS Backup 是一种集中式备份服务，可用于跨 AWS 服务备份数据。它提供了自动化的解决方案，用于备份 AWS 云中的数据，以及跨多个服务的备份管理和监控。</p><h4 id="Amazon-Elastic-Block-Store-Amazon-EBS"><a href="#Amazon-Elastic-Block-Store-Amazon-EBS" class="headerlink" title="Amazon Elastic Block Store (Amazon EBS)"></a>Amazon Elastic Block Store (Amazon EBS)</h4><p>Amazon EBS 提供高性能块存储，适用于 Amazon EC2 实例。EBS 卷用于持久存储，适用于数据库、文件系统等场景，提供高吞吐量和低延迟。</p><h4 id="Amazon-Elastic-File-System-Amazon-EFS"><a href="#Amazon-Elastic-File-System-Amazon-EFS" class="headerlink" title="Amazon Elastic File System (Amazon EFS)"></a>Amazon Elastic File System (Amazon EFS)</h4><p>Amazon EFS 提供了一种简单、可扩展的文件存储，适用于 Linux-based 的 Amazon EC2 实例。EFS 可以用于多种应用程序，支持高并发和高吞吐量。</p><h4 id="Amazon-FSx"><a href="#Amazon-FSx" class="headerlink" title="Amazon FSx"></a>Amazon FSx</h4><p>Amazon FSx 提供了多种完全托管的文件系统选项，包括适用于 Windows 文件服务器和 Lustre。FSx 为特定的工作负载和应用程序提供了优化的文件存储。</p><h4 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h4><p>Amazon S3 (Simple Storage Service) 是一种对象存储服务，提供了高度可扩展、持久、安全和低成本的存储解决方案。它广泛用于数据备份、存档、大数据分析等。</p><h4 id="Amazon-S3-Glacier"><a href="#Amazon-S3-Glacier" class="headerlink" title="Amazon S3 Glacier"></a>Amazon S3 Glacier</h4><p>Amazon S3 Glacier 是一种低成本的存储服务，用于数据归档和长期备份。提供了高耐久性的存储，但访问时间较长，适合不经常访问的数据。</p><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><p>是一种混合云存储服务，它允许您在本地环境和 AWS 云之间无缝地连接。这项服务主要用于数据备份、存档、灾难恢复和移动数据到 AWS 云。它支持三种不同类型的网关：文件网关、卷网关和磁带网关，每种都有其特定的用途。</p><ol><li><strong>文件网关</strong>：允许您将文件存储在 Amazon S3 中，同时保持本地存储的访问方式。它支持 NFS 和 SMB 协议，适用于文件共享、数据湖和备份。</li><li><strong>卷网关</strong>：提供两种模式，存储卷和缓存卷。存储卷模式将您的数据存储在 AWS 云中，同时保留本地的一个副本。缓存卷模式则将您的主数据集保留在 AWS 云中，只缓存经常访问的数据。</li><li><strong>磁带网关</strong>：用于替代物理磁带基础设施，将磁带存储虚拟化。您可以使用它来备份数据并将其存储在 AWS 云中，同时保持与现有磁带备份应用程序的兼容性。</li></ol><p>AWS Storage Gateway 通过这些功能，帮助企业实现云存储的优势，同时减少对本地存储资源的需求。它的主要优点包括成本效率、灵活的存储选项、简化的数据管理和提高的数据安全性。</p><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>是一种用于确定各种用户或系统进程是否有权访问特定资源的方式。它是计算机安全和网络管理中常用的概念。ACL 通常用于文件系统、数据库、网络设备等，以控制对文件、目录、数据库记录、网络连接等的访问权限。</p><p>一个 ACL 包含一系列的访问控制条目（ACEs）。每个 ACE 指定了一个主体（可以是用户、用户组、或系统进程）和该主体对于特定对象的访问权限。这些权限可以包括读取、写入、执行等操作。</p><p>例如，在文件系统中，一个 ACL 可以指定某个用户可以读取一个文件，但不能修改它。在网络环境中，ACL 可以用来控制哪些IP地址可以访问网络中的特定设备。</p><p>ACL 的主要作用包括：</p><p>保护敏感数据：通过限制对敏感信息的访问，来保护数据的安全性和隐私。</p><p>最小权限原则：确保用户和进程只有完成其任务所必需的最小权限，以减少潜在的安全风险。</p><p>权限管理：提供一种灵活的方式来指定和管理不同用户和用户组对资源的访问权限。</p><p>审计和合规性：通过记录和监控对资源的访问尝试，帮助组织遵守法规要求，并进行安全审计。</p><p>不同的系统和应用可能会有不同的 ACL 实现方式，但它们的核心目的都是为了保护资源不被未授权访问，并确保资源的安全和完整性。</p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Basic/Study-Note/"/>
    
    
    <category term="SAA" scheme="https://kalyan-zitiu.github.io/tags/SAA/"/>
    
  </entry>
  
  <entry>
    <title>practise for AWS SAA</title>
    <link href="https://kalyan-zitiu.github.io/2023/12/24/saa%E9%A2%98%E5%BA%93/"/>
    <id>https://kalyan-zitiu.github.io/2023/12/24/saa%E9%A2%98%E5%BA%93/</id>
    <published>2023-12-24T12:00:00.000Z</published>
    <updated>2024-06-24T07:09:26.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AWS-Certified-Solutions-Architect-Associate"><a href="#AWS-Certified-Solutions-Architect-Associate" class="headerlink" title="AWS Certified Solutions Architect - Associate"></a>AWS Certified Solutions Architect - Associate</h1><h2 id="1-AWS-为确保数据安全而执行的操作流程是什么？"><a href="#1-AWS-为确保数据安全而执行的操作流程是什么？" class="headerlink" title="1. AWS 为确保数据安全而执行的操作流程是什么？"></a>1. AWS 为确保数据安全而执行的操作流程是什么？</h2><p><strong>A</strong>. AES-256 encryption of data stored on any shared storage device<br>.AES-256 加密存储在任何共享存储设备上的数据</p><p><strong>B</strong>. Decommissioning of storage devices using industry-standard practices<br>.使用行业标准做法停用存储设备</p><p><strong>C</strong>. Background virus scans of EBS volumes and EBS snapshots<br>.EBS 卷和 EBS 快照的后台病毒扫描</p><p><strong>D</strong>. Replication of data across multiple AWS Regions</p><p><strong>E</strong>. Secure wiping of EBS data when an EBS volume is un-mounted<br>.卸载 EBS 卷时安全擦除 EBS 数据</p><p>答案 ：B</p><ul><li>A:加密存储在任何共享存储设备上的数据是用户的责任。</li><li>C:AWS不会对用户实例执行病毒扫描</li><li>D:AWS不会跨区域复制数据，除非是由用户完成的。</li></ul><h2 id="客户有一个-Web-应用程序，该应用程序使用基于-Cookie-的会话来跟踪登录用户。它使用-Elastic-Load-Balancing-和-Auto-Scaling-部署在-AWS-上。当负载增加时，Auto-Scaling-会启动新实例，但其他实例上的负载不会减少-这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？"><a href="#客户有一个-Web-应用程序，该应用程序使用基于-Cookie-的会话来跟踪登录用户。它使用-Elastic-Load-Balancing-和-Auto-Scaling-部署在-AWS-上。当负载增加时，Auto-Scaling-会启动新实例，但其他实例上的负载不会减少-这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？" class="headerlink" title="客户有一个 Web 应用程序，该应用程序使用基于 Cookie 的会话来跟踪登录用户。它使用 Elastic Load Balancing 和 Auto Scaling 部署在 AWS 上。当负载增加时，Auto Scaling 会启动新实例，但其他实例上的负载不会减少;这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？"></a>客户有一个 Web 应用程序，该应用程序使用基于 Cookie 的会话来跟踪登录用户。它使用 Elastic Load Balancing 和 Auto Scaling 部署在 AWS 上。当负载增加时，Auto Scaling 会启动新实例，但其他实例上的负载不会减少;这会导致所有现有用户的体验速度较慢。用户体验不佳的原因可能是什么？</h2><p><strong>A</strong>. ELB DNS record’s TTL is set too high.<br>.ELB DNS 记录的 TTL 设置过高。</p><p><strong>B</strong>. The new instances are not being added to the ELB during the Auto Scaling cooldown period.<br>.在 Auto Scaling 冷却期间，不会将新实例添加到 ELB。</p><p><strong>C</strong>. The website uses the dynamic content feature of Amazon CloudFront which is keeping connections alive to the ELB.<br>.该网站使用 Amazon CloudFront 的动态内容功能，该功能使与 ELB 的连接保持活动状态。</p><p><strong>D</strong>. ELB is continuing to send requests with previously established sessions to the same backend instances rather than spreading them out to the new instances.<br>.ELB 将继续将具有先前建立的会话的请求发送到相同的后端实例，而不是将它们分散到新实例。</p><p>答案：正确答案是 D，因为 ELB 是有状态的，并且使用基于 cookie 的会话。因此，它可能会继续向以前建立的会话发送请求，因此现有用户的体验很差.选项 A 是错误的，因为 Elastic Load Balancing 在 DNS 记录上使用 60 秒的 TTL 设置，并且没有提到配置是什么，选项 B 是错误的，因为仍会添加实例以减少负载，并且只有在这些实例之后的新实例才会取决于冷却时间。选项 C 是错误的，因为 CloudFront 会根据 TTL 将流量路由回源服务器</p><h2 id="3-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？"><a href="#3-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？" class="headerlink" title="3.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？"></a>3.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？</h2><p><strong>A</strong>. AWS Glacier</p><p><strong>B</strong>. AWS Elastic Transcoder</p><p><strong>C</strong>. AWS Simple Notification Service<br>.AWS 简单通知服务</p><p><strong>D</strong>. AWS Simple Queue Service</p><p>正确答案是D，因为SQS可用于构建可扩展和解耦的软件。SQS 可用于存储消息，文件位于 S3 中并相应地进行处理和扩展，选项 A 是错误的，因为 Glacier 是一种存档存储解决方案，选项 B 是错误的，因为 Elastic Transcoder 是一种用于转码不同格式视频的托管服务，选项 C 是错误的，因为 SNS 是发布/订阅消息收发服务。</p><h2 id="4-在-EC2-实例上运行的应用程序处理存储在-Amazon-S3-上的敏感信息。该信息可通过-Internet-访问。安全团队担心与-Amazon-S3-的-Internet-连接存在安全风险。哪种解决方案可以解决安全问题？"><a href="#4-在-EC2-实例上运行的应用程序处理存储在-Amazon-S3-上的敏感信息。该信息可通过-Internet-访问。安全团队担心与-Amazon-S3-的-Internet-连接存在安全风险。哪种解决方案可以解决安全问题？" class="headerlink" title="4.在 EC2 实例上运行的应用程序处理存储在 Amazon S3 上的敏感信息。该信息可通过 Internet 访问。安全团队担心与 Amazon S3 的 Internet 连接存在安全风险。哪种解决方案可以解决安全问题？"></a>4.在 EC2 实例上运行的应用程序处理存储在 Amazon S3 上的敏感信息。该信息可通过 Internet 访问。安全团队担心与 Amazon S3 的 Internet 连接存在安全风险。哪种解决方案可以解决安全问题？</h2><p><strong>A</strong>. Access the data through an Internet Gateway.</p><p><strong>B</strong>. Access the data through a VPN connection.</p><p><strong>C</strong>. Access the data through a NAT Gateway.</p><p><strong>D</strong>. Access the data through a VPC endpoint for Amazon S3.<br>.通过 Amazon S3 的 VPC 终端节点访问数据。</p><p>正确答案是 D，因为 VPC 终端节点允许 EC2 实例在不通过 Internet 的情况下访问 S3，请参阅 AWS 文档 - VPC 终端节点，VPC 终端节点使您能够将 VPC 私下连接到受支持的 AWS 服务和由 PrivateLink 提供支持的 VPC 终端节点服务，而无需互联网网关、NAT 设备、VPN 连接或 AWS Direct Connect 连接。VPC 中的实例不需要公有 IP 地址即可与服务中的资源进行通信。您的 VPC 和其他服务之间的流量不会离开 Amazon 网络，终端节点是虚拟设备。它们是水平扩展、冗余且高度可用的 VPC 组件，允许 VPC 中的实例与服务之间进行通信，而不会对网络流量施加可用性风险或带宽限制，选项 A 和 C 是错误的，因为 NAT 网关和 Internet 网关通过 Internet 将流量路由到 Amazon S3 的公有终端节点，选项 B 是错误的，因为无法通过 VPN 连接到 Amazon S3。</p><h2 id="5-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？"><a href="#5-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？" class="headerlink" title="5.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？"></a>5.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？</h2><p><strong>A</strong>. Configure a lifecycle hook for your Auto Scaling group<br>.为您的 Auto Scaling 组配置生命周期挂钩</p><p><strong>B</strong>. Add a scaling-specific cooldown period to the scaling policy<br>.在扩展策略中添加特定于扩展的冷却期</p><p><strong>C</strong>. Adjust the CPU threshold that triggers a scaling action<br>.调整触发扩展操作的 CPU 阈值</p><p><strong>D</strong>. Attach a new launch configuration to the Auto Scaling group<br>.将新的启动配置附加到 Auto Scaling 组</p><p>正确答案是 B，因为您需要调整新添加实例的冷却时间以启动和处理流量，请参阅 AWS 文档 - Auto Scaling 冷却时间，Auto Scaling 冷却时间是 Auto Scaling 组的可配置设置，有助于确保 Auto Scaling 不会在之前的扩展活动生效之前启动或终止其他实例。在 Auto Scaling 组使用简单的扩展策略动态扩展后，Auto Scaling 会等待冷却期完成，然后再恢复扩展活动。当您手动扩展 Auto Scaling 组时，默认设置不等待冷却时间，但您可以覆盖默认值并遵守冷却时间。如果实例运行状况不佳，Auto Scaling 不会等待冷却时间结束，然后再替换运行状况不佳的实例。</p><h2 id="6-一家公司正在-AWS-上构建需要访问各种-AWS-服务的软件。应使用哪种配置来确保-AWS-凭证（即访问密钥-ID-秘密访问密钥组合）不会泄露？"><a href="#6-一家公司正在-AWS-上构建需要访问各种-AWS-服务的软件。应使用哪种配置来确保-AWS-凭证（即访问密钥-ID-秘密访问密钥组合）不会泄露？" class="headerlink" title="6.一家公司正在 AWS 上构建需要访问各种 AWS 服务的软件。应使用哪种配置来确保 AWS 凭证（即访问密钥 ID/秘密访问密钥组合）不会泄露？"></a>6.一家公司正在 AWS 上构建需要访问各种 AWS 服务的软件。应使用哪种配置来确保 AWS 凭证（即访问密钥 ID/秘密访问密钥组合）不会泄露？</h2><p><strong>A</strong>. Enable Multi-Factor Authentication for your AWS root account.<br>.为您的 AWS 根账户启用 Multi-Factor Authentication。</p><p><strong>B</strong>. Assign an IAM role to the Amazon EC2 instance<br>.将 IAM 角色分配给 Amazon EC2 实例</p><p><strong>C</strong>. Store the AWS Access Key ID/Secret Access Key combination in software comments.<br>.将 AWS 访问密钥 ID/秘密访问密钥组合存储在软件注释中。</p><p><strong>D</strong>. Assign an IAM user to the Amazon EC2 Instance.<br>.将 IAM 用户分配给 Amazon EC2 实例。</p><p>正确答案是 B，因为 EC2 实例可以使用 IAM 角色访问其他 AWS 服务，这有助于生成临时的短期凭证，请参阅 AWS 文档 - IAM 角色，IAM 角色类似于用户，因为它是具有权限策略的 AWS 身份，用于确定身份在 AWS 中可以做什么和不能做什么。但是，角色不是与一个人唯一关联，而是任何需要它的人都可以承担。此外，角色没有任何与之关联的凭据（密码或访问密钥）。相反，如果将用户分配给角色，则会动态创建访问密钥并提供给用户，选项 A 是错误的，因为 MFA 是启用双因素身份验证，选项 C 是错误的，因为不建议存储凭证，选项 D 是错误的，因为无法将 IAM 用户分配给 EC2 实例</p><h2 id="7-Web-应用程序允许客户将订单上传到-S3-存储桶。生成的-Amazon-S3-事件会触发一个-Lambda-函数，该函数将消息插入-SQS-队列。单个-EC2-实例从队列中读取消息，处理消息，并将其存储在按唯一订单-ID-分区的-DynamoDB-表中。下个月，流量预计将增加-10-倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？"><a href="#7-Web-应用程序允许客户将订单上传到-S3-存储桶。生成的-Amazon-S3-事件会触发一个-Lambda-函数，该函数将消息插入-SQS-队列。单个-EC2-实例从队列中读取消息，处理消息，并将其存储在按唯一订单-ID-分区的-DynamoDB-表中。下个月，流量预计将增加-10-倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？" class="headerlink" title="7.Web 应用程序允许客户将订单上传到 S3 存储桶。生成的 Amazon S3 事件会触发一个 Lambda 函数，该函数将消息插入 SQS 队列。单个 EC2 实例从队列中读取消息，处理消息，并将其存储在按唯一订单 ID 分区的 DynamoDB 表中。下个月，流量预计将增加 10 倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？"></a>7.Web 应用程序允许客户将订单上传到 S3 存储桶。生成的 Amazon S3 事件会触发一个 Lambda 函数，该函数将消息插入 SQS 队列。单个 EC2 实例从队列中读取消息，处理消息，并将其存储在按唯一订单 ID 分区的 DynamoDB 表中。下个月，流量预计将增加 10 倍，解决方案架构师正在审查架构中是否存在可能的扩展问题。哪个组件最有可能需要重新架构才能扩展以适应新流量？</h2><p><strong>A</strong>. Lambda function</p><p><strong>B</strong>. SQS queue</p><p><strong>C</strong>. EC2 instance</p><p><strong>D</strong>. DynamoDB table</p><p>正确答案是 C 作为单个 EC2 实例不可扩展，需要使用 Auto Scaling 改进架构以随着需求的变化而扩展或缩减，选项 B 和 D 是 AWS 托管服务，并根据配置和需求进行扩展，选项 A 是错误的，因为 Lambda 函数会根据传入的需求进行扩展。</p><h2 id="8-客户希望跟踪对其-Amazon-Simple-Storage-Service-（S3）-存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？"><a href="#8-客户希望跟踪对其-Amazon-Simple-Storage-Service-（S3）-存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？" class="headerlink" title="8.客户希望跟踪对其 Amazon Simple Storage Service （S3） 存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？"></a>8.客户希望跟踪对其 Amazon Simple Storage Service （S3） 存储桶的访问，并将此信息用于其内部安全和访问审计。以下哪项符合客户要求？</h2><p><strong>A</strong>. Enable AWS CloudTrail to audit all Amazon S3 bucket access.<br>.启用 AWS CloudTrail 以审核所有 Amazon S3 存储桶访问。</p><p><strong>B</strong>. Enable server access logging for all required Amazon S3 buckets<br>.为所有必需的 Amazon S3 存储桶启用服务器访问日志记录</p><p><strong>C</strong>. Enable the Requester Pays option to track access via AWS Billing<br>.启用 Requester Pays （申请者付款） 选项以跟踪通过 AWS Billing 的访问</p><p><strong>D</strong>. Enable Amazon S3 event notifications for Put and Post.<br>.为 Put 和 Post 启用 Amazon S3 事件通知。</p><p>正确答案是 B，为了跟踪对存储桶的访问请求，您可以启用访问日志记录。每个访问日志记录都提供有关单个访问请求的详细信息，例如请求者、存储桶名称、请求时间、请求操作、响应状态和错误代码（如果有）。访问日志信息在安全和访问审计中很有用，请参阅 AWS 文档了解 S3 服务器日志，选项 A 是错误的，因为 CloudTrail 只会提供对 S3 的 API 调用信息，而不是单个访问信息，选项 C 是错误的，因为它仅在您希望用户为对象访问付费时帮助处理计费，选项 D 是错误的，因为事件通知未涵盖所有信息</p><h2 id="9-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"><a href="#9-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题" class="headerlink" title="9.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"></a>9.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题</h2><p><strong>A</strong>. Disable sticky sessions<br>.禁用粘性会话</p><p><strong>B</strong>. Reduce the frequency of the health checks<br>.降低运行状况检查的频率</p><p><strong>C</strong>. Enable cross zone load balancer<br>.启用跨区域负载均衡器</p><p><strong>D</strong>. Amazon recommends to use two availability zone behind ELB<br>.Amazon 建议在 ELB 后面使用两个可用区</p><p>正确答案是 A，因为粘性会话可能会导致用户被路由到相同的实例，选项 B 是错误的，因为降低运行状况检查的频率只会帮助确定实例是否健康。对于跨可用区的所有实例都是一样的，选项 C 是错误的，因为启用跨区域负载均衡器只会帮助在实例之间平均路由流量，而不是在可用区之间路由流量，这里似乎不是这种情况，选项 D 是错误的，因为 AWS 建议将实例分散到所有可用可用区以使应用程序高可用</p><h2 id="0-如何保护-EBS-卷上的静态数据？"><a href="#0-如何保护-EBS-卷上的静态数据？" class="headerlink" title="0.如何保护 EBS 卷上的静态数据？"></a>0.如何保护 EBS 卷上的静态数据？</h2><p><strong>A</strong>. Encrypt the volume using the S3 server-side encryption service<br>.使用 S3 服务器端加密服务加密卷</p><p><strong>B</strong>. Attach the volume to an instance using EC2’s SSL interface.<br>.使用 EC2 的 SSL 接口将卷附加到实例。</p><p><strong>C</strong>. Create an IAM policy that restricts read and write access to the volume.<br>.创建一个 IAM 策略，以限制对卷的读取和写入访问。</p><p><strong>D</strong>. Use EBS encryption</p><p><strong>E</strong>. Use an encrypted file system on top of the EBS volume<br>.在 EBS 卷上使用加密文件系统</p><p>正确答案是D，因为EBS加密可用于加密EBS卷，EBS加密是AWS在一段时间内推出的。在 EBS 加密之前，选项 E 是正确的答案，因为您需要在 EBS 卷上使用加密文件系统，直到今天，您还需要第三方安全工具来加密 EBS 卷的数据。借助 Amazon EBS 加密，您现在可以创建加密的 EBS 卷并将其附加到支持的实例类型。然后，卷上的数据、磁盘 I/O 和从卷创建的快照都将被加密。加密发生在托管 EC2 实例的服务器上，在数据在 EC2 实例和 EBS 存储之间移动时提供数据加密。EBS 加密基于行业标准的 AES-256 加密算法，选项 A 是错误的，因为 S3 - SSE 不适用于 EBS，选项 B 是错误的，因为 SSL 用于传输中的数据，选项 C 是错误的，因为 IAM 策略无法限制对 EC2 的读写访问。</p><h2 id="11-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"><a href="#11-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？" class="headerlink" title="11.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"></a>11.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？</h2><p><strong>A</strong>. A standalone Amazon EC2 instance</p><p><strong>B</strong>. Amazon RDS in a Multi-AZ configuration</p><p><strong>C</strong>. Amazon EC2 instances in a replication configuration utilizing a single Availability Zone<br>.使用单个可用区的复制配置中的 Amazon EC2 实例</p><p><strong>D</strong>. Amazon EC2 instances in a replication configuration utilizing two different Availability Zones<br>.使用两个不同可用区的复制配置中的 Amazon EC2 实例</p><p>这里的关键点是设计一个具有操作系统权限的 HA 解决方案数据库解决方案，正确答案是 D，因为 RDS 是 AWS 的托管服务，它不提供操作系统权限，并且对于 HA，至少需要在 2 个可用区中存在实例，选项 A 是错误的，因为单个实例不提供 HA，选项 B 是错误的，因为 RDS 不提供操作系统权限，选项 C 是错误的，因为单个可用区不提供 HA</p><h2 id="12-您有一个在-Amazon-Elastic-Compute-Cloud-实例上运行的应用程序，该应用程序将-5GB-的视频对象上传到-Amazon-Simple-Storage-Service-（S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？"><a href="#12-您有一个在-Amazon-Elastic-Compute-Cloud-实例上运行的应用程序，该应用程序将-5GB-的视频对象上传到-Amazon-Simple-Storage-Service-（S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？" class="headerlink" title="12.您有一个在 Amazon Elastic Compute Cloud 实例上运行的应用程序，该应用程序将 5GB 的视频对象上传到 Amazon Simple Storage Service （S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？"></a>12.您有一个在 Amazon Elastic Compute Cloud 实例上运行的应用程序，该应用程序将 5GB 的视频对象上传到 Amazon Simple Storage Service （S3）。视频上传时间比预期的要长，导致应用程序性能不佳。哪种方法有助于提高应用程序的性能？</h2><p><strong>A</strong>. Enable enhanced networking<br>.启用增强网络</p><p><strong>B</strong>. Use Amazon S3 multipart upload</p><p><strong>C</strong>. Leveraging Amazon CloudFront, use the HTTP POST method to reduce latency.<br>.利用 Amazon CloudFront，使用 HTTP POST 方法减少延迟。</p><p><strong>D</strong>. Use Amazon Elastic Block Store Provisioned IOPS and use an Amazon EBS-optimized instance<br>.使用 Amazon Elastic Block Store 预置 IOPS 并使用 Amazon EBS 优化实例</p><p>正确答案是 B，因为分段上传允许您将单个对象作为一组分段并行上传。每个部分都是对象数据的连续部分。您可以按任意顺序独立上传这些对象部分。如果任何部件的传输失败，您可以重新传输该部件，而不会影响其他部件。上传对象的所有部分后，Amazon S3 将组装这些部分并创建对象。一般来说，当您的对象大小达到 100 MB 时，您应该考虑使用分段上传，而不是在单个操作中上传对象，请参阅 AWS 文档了解 S3 分段上传，选项 A 和 D 是错误的，因为增强联网、IOPS、EBS 优化有助于提高 EC2 实例在 AWS 网络内的性能，选项 C 是错误的，因为 CloudFront 允许从全局位置上传对象更顺畅一些，但不会改善S3 上传时间</p><h2 id="13-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？"><a href="#13-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？" class="headerlink" title="13.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？"></a>13.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon DynamoDB</p><p>正确答案是 C，因为 EFS 是创建用户主目录的理想解决方案，并且可以跨组织的个人访问，并能够对其进行配置，请参阅 AWS EFS 常见问题和创建可写的每用户目录，问。Amazon EFS 适用于哪些使用案例？，Amazon EFS 旨在为各种工作负载和应用程序提供性能，包括大数据和分析、媒体处理工作流、内容管理、Web 服务和主目录。</p><h2 id="14-您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的-EC2-定价选项是什么？"><a href="#14-您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的-EC2-定价选项是什么？" class="headerlink" title="14.您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的 EC2 定价选项是什么？"></a>14.您的公司将在即将到来的周末进行在线销售，您将需要额外的计算资源来承担额外的负载。如果必须在销售期间保证这些额外实例的可用性，那么对于此任务，最具成本效益的 EC2 定价选项是什么？</h2><p><strong>A</strong>. On-Demand Instances</p><p><strong>B</strong>. Spot Instances + On-Demand Instances</p><p><strong>C</strong>. Reserved Instances (3 year contract)<br>.预留实例（3 年合同）</p><p><strong>D</strong>. Dedicated Instances</p><p>正确答案是 A，因为与 Spot 实例相比，按需实例将有助于预置额外的容量，并保证这些额外实例的可用性，请参阅 AWS 文档 - EC2 购买选项，选项 B 是错误的，因为 Spot 实例可能具有成本效益，但不能保证可用性，选项 C 是错误的，因为使用预留实例不具有成本效益，选项 D 是错误的，因为专用实例仅提供与其他客户端隔离的硬件，并且成本最高。</p><h2 id="15-一家公司正准备向开发人员提供-AWS-管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司-Active-Directory-中的组分配的。以下哪些组合将允许开发人员访问-AWS-控制台？选择-2-个答案"><a href="#15-一家公司正准备向开发人员提供-AWS-管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司-Active-Directory-中的组分配的。以下哪些组合将允许开发人员访问-AWS-控制台？选择-2-个答案" class="headerlink" title="15.一家公司正准备向开发人员提供 AWS 管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司 Active Directory 中的组分配的。以下哪些组合将允许开发人员访问 AWS 控制台？选择 2 个答案"></a>15.一家公司正准备向开发人员提供 AWS 管理控制台访问权限。公司策略强制要求进行联合身份验证和基于角色的访问控制。角色当前是使用公司 Active Directory 中的组分配的。以下哪些组合将允许开发人员访问 AWS 控制台？选择 2 个答案</h2><p><strong>A</strong>. AWS Directory Service AD Connector<br>.AWS Directory Service AD 连接器</p><p><strong>B</strong>. AWS Directory Service Simple AD<br>.AWS Directory Service 简单 AD</p><p><strong>C</strong>. AWS Identity and Access Management groups<br>.AWS Identity and Access Management 组</p><p><strong>D</strong>. AWS Identity and Access Management roles<br>.AWS Identity and Access Management 角色</p><p><strong>E</strong>. AWS Identity and Access Management users<br>.AWS Identity and Access Management 用户</p><p>正确答案是 A 和 D，因为 AD 连接器需要连接到本地 Active Directory，IAM 角色可用于身份提供商和联合身份验证，请参阅 AWS 博客 - 如何使用 AD 连接器连接本地 Active Directory，AD Connector 是一个目录网关，您可以使用它将目录请求重定向到本地 Microsoft Active Directory，而无需在云中缓存任何信息，您的最终用户和 IT 管理员可以使用其现有的企业凭证登录 Amazon WorkSpaces、Amazon WorkDocs 或 Amazon WorkMail 等 AWS 应用程序，您可以通过对 AWS 管理控制台的基于 IAM 角色的访问来管理 Amazon EC2 实例或 Amazon S3 存储桶等 AWS 资源，选项 B 是错误的，因为 Simple AD 是独立的 AD 设置，不允许连接到本地 AD。选项C和E是错误的，因为用户和组不起作用。</p><h2 id="16-ABCD-公司最近在-AWS-上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB-表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？"><a href="#16-ABCD-公司最近在-AWS-上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB-表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？" class="headerlink" title="16.ABCD 公司最近在 AWS 上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB 表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？"></a>16.ABCD 公司最近在 AWS 上推出了一个自行车在线商务网站。他们有一个“产品”DynamoDB 表，用于存储每辆自行车的详细信息，例如制造商、颜色、价格、数量和尺寸，以便在在线商店中显示。由于客户需求，他们希望为每辆自行车提供图像以及现有详细信息。以下哪种方法对“产品”表上的预配吞吐量影响最小？</h2><p><strong>A</strong>. Serialize the image and store it in multiple DynamoDB tables<br>.序列化映像并将其存储在多个 DynamoDB 表中</p><p><strong>B</strong>. Create an “Images” DynamoDB table to store the Image with a foreign key constraint to the “Product” table.<br>.创建一个 “Images” DynamoDB 表，以存储具有外键约束的 Image，以约束 “Product” 表。</p><p><strong>C</strong>. Add an image data type to the “Product” table to store the images in binary format<br>.将图像数据类型添加到“Product”表中，以二进制格式存储图像</p><p><strong>D</strong>. Store the images in Amazon S3 and add an S3 URL pointer to the “Product” table item for each image<br>.将图像存储在 Amazon S3 中，并为每个图像添加指向“Product”表项的 S3 URL 指针</p><p>因为 DynamoDB 不适合图像存储，图像应该存储在 S3 中，图像指针在 DynamoDB 中，请参阅 AWS 存储选项白皮书，选项 A 和 B 是错误的，因为 DynamoDB 不适合图像存储，选项 C 是错误的，因为没有图像数据类型</p><h2 id="17-一家公司正在使用区域顶点-（mycompany-com）-启动静态网站。该公司希望将-Amazon-Route-53-用于-DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）"><a href="#17-一家公司正在使用区域顶点-（mycompany-com）-启动静态网站。该公司希望将-Amazon-Route-53-用于-DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）" class="headerlink" title="17.一家公司正在使用区域顶点 （mycompany.com） 启动静态网站。该公司希望将 Amazon Route 53 用于 DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）"></a>17.一家公司正在使用区域顶点 （mycompany.com） 启动静态网站。该公司希望将 Amazon Route 53 用于 DNS。公司应执行哪些步骤来实施可扩展且具有成本效益的解决方案？（选择二）</h2><p><strong>A</strong>. Host the website on an Amazon EC2 instance with ELB and Auto scaling and map a Route 53 alias record to the ELB endpoint.<br>.在具有 ELB 和 Auto Scaling 的 Amazon EC2 实例上托管网站，并将 Route 53 别名记录映射到 ELB 终端节点。</p><p><strong>B</strong>. Host the website using AWS Elastic Beanstalk and map a Route 53 alias record to the Beanstalk stack.<br>.使用 AWS Elastic Beanstalk 托管网站，并将 Route 53 别名记录映射到 Beanstalk 堆栈。</p><p><strong>C</strong>. Host the website on an Amazon EC2 instance and map a Route 53 alias record to the public IP address of the Amazon EC2 instance.<br>.在 Amazon EC2 实例上托管网站，并将 Route 53 别名记录映射到 Amazon EC2 实例的公有 IP 地址。</p><p><strong>D</strong>. Serve the website from an Amazon S3 bucket and map a Route 53 alias record to the website endpoint.<br>.从 Amazon S3 存储桶提供网站，并将 Route 53 别名记录映射到网站终端节点。</p><p><strong>E</strong>. Create a Route 53 hosted zone and set the NS records of the domain to use Route 53 name servers.<br>.创建 Route 53 托管区域并将域的 NS 记录设置为使用 Route 53 名称服务器。</p><p>正确答案是 D 和 E，因为静态网站可以托管在 S3 上，提供规模和具有成本效益的解决方案。可以在 Route 53 中创建具有托管区域的别名记录以将域指向 S3，请参阅 AWS 文档 - Route 53 路由到 S3 存储桶，Amazon Simple Storage Service （Amazon S3） 提供安全、持久、高度可扩展的云存储。您可以将 S3 存储桶配置为托管可包含网页和客户端脚本的静态网站。（S3 不支持服务器端脚本），要将域流量路由到 S3 存储桶，请使用 Amazon Route 53 创建指向存储桶的别名记录。别名记录是 Route 53 对 DNS 的扩展。它类似于 CNAME 记录，不同之处在于您可以为根域（如 example.com）和子域（如 <a href="http://www.example.com)创建别名记录.您只能为子域创建cname记录./">www.example.com）创建别名记录。您只能为子域创建CNAME记录。</a></p><h2 id="18-您正在构建一个由关系数据库支持的-Web-应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？"><a href="#18-您正在构建一个由关系数据库支持的-Web-应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？" class="headerlink" title="18.您正在构建一个由关系数据库支持的 Web 应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？"></a>18.您正在构建一个由关系数据库支持的 Web 应用程序。应用程序将是读取量很大的，数据库查询将是计算密集型的。如何提高用户的整体应用程序响应？</h2><p><strong>A</strong>. Use ElastiCache to store critical pieces of data in memory for low-latency access.<br>.使用 ElastiCache 将关键数据片段存储在内存中，以实现低延迟访问。</p><p><strong>B</strong>. Use Amazon SQS to distribute messages among workers that are less busy<br>.使用 Amazon SQS 在不太繁忙的工作线程之间分发消息</p><p><strong>C</strong>. Use an Auto Scaling group and ELB Classic Load Balancer for the application tier.<br>.将 Auto Scaling 组和 ELB Classic Load Balancer 用于应用层。</p><p><strong>D</strong>. Use Data Pipeline to replicate your relational data across all of your web tier nodes<br>.使用 Data Pipeline 跨所有 Web 层节点复制关系数据</p><p>正确答案是 A，因为 ElastiCache 可以通过缓存结果来帮助提高性能，因为操作主要是读取密集型的，并且数据库查询将是计算密集型的，请参阅 AWS 存储选项白皮书，ElastiCache 通过在内存中存储关键数据片段来实现低延迟访问来提高应用程序性能。它经常用作读取密集型应用程序中的数据库前端，通过缓存 I/O 密集型查询的结果来提高性能并减少数据库的负载。它还经常用于管理 Web 会话数据、缓存动态生成的网页以及缓存计算密集型计算的结果，例如推荐引擎的输出。对于需要比字符串更复杂的数据结构的应用程序，例如列表、集合、哈希和排序集，Redis 引擎通常用作内存中 NoSQL 数据库。</p><h2 id="19-您正在设计一个将静态资产存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的-Web-应用程序。您希望此存储桶每秒立即接收超过-150-个-PUT-请求。您应该怎么做才能确保最佳性能？"><a href="#19-您正在设计一个将静态资产存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的-Web-应用程序。您希望此存储桶每秒立即接收超过-150-个-PUT-请求。您应该怎么做才能确保最佳性能？" class="headerlink" title="19.您正在设计一个将静态资产存储在 Amazon Simple Storage Service （S3） 存储桶中的 Web 应用程序。您希望此存储桶每秒立即接收超过 150 个 PUT 请求。您应该怎么做才能确保最佳性能？"></a>19.您正在设计一个将静态资产存储在 Amazon Simple Storage Service （S3） 存储桶中的 Web 应用程序。您希望此存储桶每秒立即接收超过 150 个 PUT 请求。您应该怎么做才能确保最佳性能？</h2><p><strong>A</strong>. Use multi-part upload.</p><p><strong>B</strong>. Add a random prefix to the key names</p><p><strong>C</strong>. Amazon S3 will automatically manage performance at this scale.<br>.Amazon S3 将自动管理此规模的性能。</p><p><strong>D</strong>. Use a predictable naming scheme, such as sequential numbers or date time sequences, in the key names<br>.在键名称中使用可预测的命名方案，例如序列号或日期时间序列</p><p>正确答案是 B，注意 - 大约 2018 年 7 月，根据最近的 AWS 公告，S3 性能发生了巨大变化，文档已更新，请参阅 AWS 文档 - S3 性能，为键名引入随机性的一种方法是添加哈希字符串作为键名的前缀。例如，您可以计算您计划分配为键名称的字符序列的 MD5 哈希值，选项 A 是错误的，因为分段上传仅有助于缩短对象上传时间，选项 C 是错误的，因为 Amazon S3 可以扩展以支持非常高的请求速率。但是，如果 Amazon S3 存储桶中的工作负载通常超过每秒 100 个 PUT/LIST/DELETE 请求或每秒超过 300 个 GET 请求，则建议实施最佳实践，选项 D 是错误的，因为使用可预测的命名方案会降低性能</p><h2 id="20-您正在运行一个包含以下内容的-2-层应用程序：一个-ELB、EC2-上的三个-Web-应用程序服务器和-1-个-MySQL-RDS-数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）"><a href="#20-您正在运行一个包含以下内容的-2-层应用程序：一个-ELB、EC2-上的三个-Web-应用程序服务器和-1-个-MySQL-RDS-数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）" class="headerlink" title="20.您正在运行一个包含以下内容的 2 层应用程序：一个 ELB、EC2 上的三个 Web 应用程序服务器和 1 个 MySQL RDS 数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）"></a>20.您正在运行一个包含以下内容的 2 层应用程序：一个 ELB、EC2 上的三个 Web 应用程序服务器和 1 个 MySQL RDS 数据库。随着负载的增加，数据库查询需要的时间越来越长，并减慢了用户请求的整体响应时间。哪些选项可以提高性能？（选择3）</h2><p><strong>A</strong>. Create an RDS read-replica and redirect half of the database read request to it<br>.创建一个 RDS 只读副本，并将一半的数据库读取请求重定向到该副本</p><p><strong>B</strong>. Cache database queries in amazon ElastiCache</p><p><strong>C</strong>. Setup RDS in multi-availability zone mode.<br>.在多可用区模式下设置 RDS。</p><p><strong>D</strong>. Shard the database and distribute loads between shards.<br>.对数据库进行分片，并在分片之间分配负载。</p><p><strong>E</strong>. Use amazon CloudFront to cache database queries.<br>.使用 Amazon CloudFront 缓存数据库查询。</p><p>正确答案是 A、B 和 D，因为主要问题是数据库性能下降，只读副本，ElastiCache 可以帮助提高读取性能，而分片可以帮助提高写入性能，选项 C 是错误的 RDS 多可用区更像是一种高可用性解决方案，选项 E 是错误的，因为 CloudFront 无法缓存数据库查询。</p><h2 id="21-您在特定区域中有一个-EC2-实例。此-EC2-实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？"><a href="#21-您在特定区域中有一个-EC2-实例。此-EC2-实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？" class="headerlink" title="21.您在特定区域中有一个 EC2 实例。此 EC2 实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？"></a>21.您在特定区域中有一个 EC2 实例。此 EC2 实例上运行着预配置的软件。系统已要求您创建灾难恢复解决方案，以防该区域中的实例发生故障。以下哪项是最佳解决方案？</h2><p><strong>A</strong>. Create a duplicate EC2 Instance in another AZ. Keep it in the shutdown state. When required, bring it back up.<br>.在另一个可用区中创建重复的 EC2 实例。 使其保持关闭状态。需要时，将其恢复。</p><p><strong>B</strong>. Backup the EBS data volume. If the instance fails, bring up a new EC2 instance and attach the volume.<br>.备份 EBS 数据卷。如果实例失败，请启动新的 EC2 实例并附加卷。</p><p><strong>C</strong>. Store the EC2 data on S3. If the instance fails, bring up a new EC2 instance and restore the data from S3.<br>.将 EC2 数据存储在 S3 上。如果实例失败，请启动新的 EC2 实例并从 S3 还原数据。</p><p><strong>D</strong>. Create an AMI of the EC2 Instance and copy it to another region.<br>.创建 EC2 实例的 AMI 并将其复制到另一个区域。</p><p>正确答案是 D，因为 AMI 可以在安装软件的情况下创建，并且由于 AMI 是区域范围的，因此可以将它们复制到另一个区域以启动实例，请参阅 AWS 文档 - AMI 跨区域复制，跨地理位置不同的区域复制 AMI 具有以下好处：，选项 A 是错误的，因为它是 AZ 在区域发生故障时不提供 HA，，选项 B 是错误的，因为预配置的软件可能在根卷上有设置，并且需要跨区域复制快照才能重新创建卷，选项 C 是错误的，因为这是恢复故障实例的漫长且低效的方法。</p><h2 id="22-以下哪项最能描述什么是“堡垒主机”？"><a href="#22-以下哪项最能描述什么是“堡垒主机”？" class="headerlink" title="22.以下哪项最能描述什么是“堡垒主机”？"></a>22.以下哪项最能描述什么是“堡垒主机”？</h2><p><strong>A</strong>. Bastion hosts are instances that sit within your private subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with the bastion host, it then acts as a ‘jump’ server, allowing you to use SSH or RDP to log into other instances (within public subnets) deeper within your network.<br>.堡垒主机是位于私有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 SSH 或 RDP 登录网络更深处的其他实例（在公有子网内）。</p><p><strong>B</strong>. Bastion hosts are instances that sit within your private subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with the bastion host, it then acts as a ‘jump’ server, allowing you to use HTTPS to log into other instances (within public subnets) deeper within your network.<br>.堡垒主机是位于私有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 HTTPS 登录到网络更深处的其他实例（在公共子网内）。</p><p><strong>C</strong>. Bastion hosts are instances that sit within your public subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with the bastion host, it then acts as a ‘jump’ server, allowing you to use HTTPS to log into other instances (within private subnets) deeper within your network.<br>.堡垒主机是位于公有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 HTTPS 登录网络更深处的其他实例（在私有子网内）。</p><p><strong>D</strong>. Bastion hosts are instances that sit within your public subnet and are typically accessed using SSH or RDP. Once remote connectivity has been established with a bastion host, it then acts as a ‘jump’ server, allowing you to use SSH or RDP to log into other instances (within private subnets) deeper within your network.<br>.堡垒主机是位于公有子网中的实例，通常使用 SSH 或 RDP 进行访问。与堡垒主机建立远程连接后，它将充当“跳转”服务器，允许您使用 SSH 或 RDP 登录网络更深处的其他实例（在私有子网内）。****</p><p>正确答案是 D，因为 Bastion 主机充当公共子网中的跳转服务器，以允许 SSH/RDP 访问私有子网中的实例，选项 A 和 B 是错误的，因为 Bastion 应该在公共子网中并且可以访问 Internet，选项 C 是错误的，因为 Bastion 只允许 SSH/RDP 而不是 HTTPS 连接。</p><h2 id="23-公司要求在遍历私有子网时记录所有-IP-数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？"><a href="#23-公司要求在遍历私有子网时记录所有-IP-数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？" class="headerlink" title="23.公司要求在遍历私有子网时记录所有 IP 数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？"></a>23.公司要求在遍历私有子网时记录所有 IP 数据包的源、目标和协议。实现这一目标的最安全可靠的方法是什么？</h2><p><strong>A</strong>. Create VPC flow logs on the subnet<br>.在子网上创建 VPC 流日志</p><p><strong>B</strong>. Enable source destination check on private Amazon EC2 instances.<br>.在私有 Amazon EC2 实例上启用源目标检查。</p><p><strong>C</strong>. Enable AWS CloudTrail logging and specify an Amazon S3 bucket for storing log files.<br>.启用 AWS CloudTrail 日志记录并指定用于存储日志文件的 Amazon S3 存储桶。</p><p><strong>D</strong>. Create an Amazon CloudWatch logs to capture packet information.<br>.创建 Amazon CloudWatch 日志以捕获数据包信息。</p><p>正确答案是 A，因为只有 VPC 流允许您跟踪和捕获进出 VPC 内网络接口的所有信息，请参阅 AWS 文档 - VPC 流日志，VPC 流日志是一项功能，可让您捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据可以发布到 Amazon CloudWatch Logs 和 Amazon S3。创建流日志后，您可以在所选目标中检索和查看其数据，流日志可以帮助您完成许多任务;例如，排查特定流量未到达实例的原因，这反过来又可以帮助您诊断限制性过强的安全组规则。您还可以使用流日志作为安全工具来监控到达实例的流量，选项 B 是错误的，因为源/目标检查不跟踪数据包信息。默认情况下，每个 EC2 实例都会执行源/目标检查。这意味着实例必须是它发送或接收的任何流量的源或目标，选项 C 是错误的，因为 CloudTrail 是一项支持对您的 AWS 账户进行监管、合规性、操作审计和风险审计的服务。借助 CloudTrail，您可以记录、持续监控和保留与 AWS 基础设施中的操作相关的账户活动，选项 D 是错误的，因为 CloudWatch 不能用于跟踪数据包信息，而是一项监控和管理服务。</p><h2 id="24-一家公司正在将访问密钥（访问密钥-ID-和秘密访问密钥）存储在自定义-AMI-上的文本文件中。该公司使用访问密钥从从-AMI-创建的实例访问-DynamoDB-表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？"><a href="#24-一家公司正在将访问密钥（访问密钥-ID-和秘密访问密钥）存储在自定义-AMI-上的文本文件中。该公司使用访问密钥从从-AMI-创建的实例访问-DynamoDB-表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？" class="headerlink" title="24.一家公司正在将访问密钥（访问密钥 ID 和秘密访问密钥）存储在自定义 AMI 上的文本文件中。该公司使用访问密钥从从 AMI 创建的实例访问 DynamoDB 表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？"></a>24.一家公司正在将访问密钥（访问密钥 ID 和秘密访问密钥）存储在自定义 AMI 上的文本文件中。该公司使用访问密钥从从 AMI 创建的实例访问 DynamoDB 表。安全团队已强制要求使用更安全的解决方案。哪种解决方案可以满足安全团队的任务？</h2><p><strong>A</strong>. Put the access key in an S3 bucket and retrieve the access key on boot from the instance.<br>.将访问密钥放入 S3 存储桶中，并在启动时从实例中检索访问密钥。</p><p><strong>B</strong>. Pass the access key to the instances through instance user data.<br>.通过实例用户数据将访问密钥传递给实例。</p><p><strong>C</strong>. Obtain the access key from a key server launched in a private subnet.<br>.从私有子网中启动的密钥服务器获取访问密钥。</p><p><strong>D</strong>. Create an IAM role with permissions to access the table and launch all instances with the new role.<br>.创建一个有权访问表的 IAM 角色，并使用新角色启动所有实例。</p><p>正确答案是 D，因为 EC2 实例的 IAM 角色允许在实例上运行的应用程序访问 AWS 资源，而无需创建和存储任何访问密钥，请参阅 AWS 文档 - IAM 最佳实践，在 Amazon EC2 实例上运行的应用程序需要凭证才能访问其他 AWS 服务。要以安全的方式向应用程序提供凭证，请使用 IAM 角色。角色是具有自己的权限集的实体，但不是用户或组。角色也没有像 IAM 用户那样拥有自己的永久凭证集。对于 Amazon EC2，IAM 会动态地向 EC2 实例提供临时凭证，这些凭证会自动为您轮换，当您启动 EC2 实例时，您可以为该实例指定一个角色作为启动参数。在 EC2 实例上运行的应用程序在访问 AWS 资源时可以使用角色的凭证。角色的权限决定了允许应用程序执行的操作。</p><h2 id="25-一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的-Amazon-EC2-实例的前端队列。EC2-实例将投票推送到-RDBMS-数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？"><a href="#25-一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的-Amazon-EC2-实例的前端队列。EC2-实例将投票推送到-RDBMS-数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？" class="headerlink" title="25.一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的 Amazon EC2 实例的前端队列。EC2 实例将投票推送到 RDBMS 数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？"></a>25.一个组织为电视节目运行在线投票系统。在广播期间，数十万张选票会在几分钟内提交，并发送到自动扩展的 Amazon EC2 实例的前端队列。EC2 实例将投票推送到 RDBMS 数据库。数据库无法跟上前端连接请求。确保选票得到及时处理的最有效和最具成本效益的方法是什么？</h2><p><strong>A</strong>. Each front-end node should send votes to an Amazon SQS queue. Provision worker instances to read the SQS queue and process message information into the RDBMS database.<br>.每个前端节点都应向 Amazon SQS 队列发送投票。预置工作线程实例以读取 SQS 队列并将消息信息处理到 RDBMS 数据库中。</p><p><strong>B</strong>. As the load on the database increases, horizontally-scale the RDBMS database with additional memory-optimized instances. When voting has ended, scale down the additional instances.<br>.随着数据库负载的增加，使用其他内存优化实例水平扩展 RDBMS 数据库。投票结束后，缩减其他实例。</p><p><strong>C</strong>. Re-provision the RDBMS database with larger, memory-optimized instances. When voting end, re-provision the back-end database with smaller instances.<br>.使用更大的内存优化实例重新预置 RDBMS 数据库。投票结束时，使用较小的实例重新预配后端数据库。</p><p><strong>D</strong>. Send votes from each front-end node to Amazon DynamoDB. Provision worker instances to process the votes in DynamoDB into the RDBMS database.<br>.将投票从每个前端节点发送到 Amazon DynamoDB。预置工作线程实例以将 DynamoDB 中的投票处理到 RDBMS 数据库中。</p><p>正确答案是 A，因为 SQS 可以帮助提供松耦合并充当数据库的缓冲区。此外，由于峰值是暂时的，因此无需扩展 RDBMS，选项 B 是错误的，因为 Auto Scaling 不适用于 RDBMS，选项 C 是错误的，因为 RDBMS 无法重新预置回较小的实例，选项 D 是错误的，因为 DynamoDB 将提供单独的重复持久性数据存储，这将更昂贵地输入、处理和删除数据。</p><h2 id="26-应用程序当前将大量记录写入一个区域中的-DynamoDB-表。辅助应用程序需要每-2-小时检索一次写入-DynamoDB-表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从-DynamoDB-表中获取相关更改的理想方法？"><a href="#26-应用程序当前将大量记录写入一个区域中的-DynamoDB-表。辅助应用程序需要每-2-小时检索一次写入-DynamoDB-表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从-DynamoDB-表中获取相关更改的理想方法？" class="headerlink" title="26.应用程序当前将大量记录写入一个区域中的 DynamoDB 表。辅助应用程序需要每 2 小时检索一次写入 DynamoDB 表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从 DynamoDB 表中获取相关更改的理想方法？"></a>26.应用程序当前将大量记录写入一个区域中的 DynamoDB 表。辅助应用程序需要每 2 小时检索一次写入 DynamoDB 表的新记录，并相应地处理更新。以下哪项是确保辅助应用程序从 DynamoDB 表中获取相关更改的理想方法？</h2><p><strong>A</strong>. Insert a timestamp for each record and then scan the entire table for the timestamp as per the last 2 hours.<br>.为每条记录插入时间戳，然后扫描整个表中过去 2 小时的时间戳。</p><p><strong>B</strong>. Create another DynamoDB table with the records modified in the last 2 hours.<br>.使用过去 2 小时内修改的记录创建另一个 DynamoDB 表。</p><p><strong>C</strong>. Use DynamoDB Streams to monitor the changes in the DynamoDB table.<br>.使用 DynamoDB 流 监控 DynamoDB 表中的更改。</p><p><strong>D</strong>. Transfer records to S3 which were modified in the last 2 hours.<br>.将在过去 2 小时内修改的记录传输到 S3。</p><p>正确答案是 C，因为 DynamoDB 流有助于监控 DynamoDB 表中的更改。第二个应用程序可以检查流中的更改，请参阅 AWS 文档 - DynamoDB Streams，DynamoDB Streams 支持诸如此类的解决方案以及许多其他解决方案。DynamoDB 流 在任何 DynamoDB 表中捕获按时间排序的项目级修改序列，并将此信息存储在日志中长达 24 小时。应用程序可以近乎实时地访问此日志并查看数据项目在修改之前和之后出现的情况，DynamoDB 流是有关 Amazon DynamoDB 表中项目更改的有序信息流。当您在表上启用流时，DynamoDB 会捕获有关对表中数据项的每次修改的信息，每当应用程序创建、更新或删除表中的项目时，DynamoDB 流都会写入一条流记录，其中包含已修改项目的主键属性。流记录包含有关对 DynamoDB 表中单个项目的数据修改的信息。您可以配置流，以便流记录捕获其他信息，例如已修改项目的“之前”和“之后”图像。</p><h2 id="27-客户希望将-Amazon-Simple-Storage-Service-（S3）-和-Amazon-Glacier-用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的-Amazon-S3-存储桶的访问？"><a href="#27-客户希望将-Amazon-Simple-Storage-Service-（S3）-和-Amazon-Glacier-用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的-Amazon-S3-存储桶的访问？" class="headerlink" title="27.客户希望将 Amazon Simple Storage Service （S3） 和 Amazon Glacier 用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的 Amazon S3 存储桶的访问？"></a>27.客户希望将 Amazon Simple Storage Service （S3） 和 Amazon Glacier 用作其备份和存档基础设施的一部分。客户计划使用第三方软件来支持此集成。哪种方法会将第三方软件的访问限制为仅对名为“company-backup”的 Amazon S3 存储桶的访问？</h2><p><strong>A</strong>. A custom bucket policy limited to the Amazon S3 API in the Amazon Glacier archive “company-backup”<br>.仅限于 Amazon Glacier 存档“company-backup”中的 Amazon S3 API 的自定义存储桶策略</p><p><strong>B</strong>. A custom bucket policy limited to the Amazon S3 API in “company-backup”<br>.仅限于“company-backup”中的 Amazon S3 API 的自定义存储桶策略</p><p><strong>C</strong>. A custom IAM user policy limited to the Amazon S3 API for the Amazon Glacier archive “company-backup”.<br>.仅限于 Amazon Glacier 存档“company-backup”的 Amazon S3 API 的自定义 IAM 用户策略。</p><p><strong>D</strong>. A custom IAM user policy limited to the Amazon S3 API in “company-backup”.<br>.仅限于“company-backup”中的 Amazon S3 API 的自定义 IAM 用户策略。</p><p>正确答案是 D，因为 IAM 策略可以授予 S3 并且配置了适当的生命周期规则以将数据存档到 Glacier，请参阅 S3 IAM 策略，选项 A 和 C 是错误的，因为它们的目标是 Glacier，选项 B 是错误的，因为存储桶策略需要（现有）委托人，用户策略需要（现有）用户/组/角色</p><h2 id="28-您的公司有一组-EC2-实例，用于访问存储在-S3-存储桶中的数据对象。您的-IT-安全部门关注此架构的安全性，并希望您实现以下措施：-1）-确保-EC2-实例安全地访问存储在-S3-存储桶中的数据对象-2）-防止意外删除对象-以下哪项有助于以经济高效的方式满足-IT-安全部门的要求？选择-2-个答案"><a href="#28-您的公司有一组-EC2-实例，用于访问存储在-S3-存储桶中的数据对象。您的-IT-安全部门关注此架构的安全性，并希望您实现以下措施：-1）-确保-EC2-实例安全地访问存储在-S3-存储桶中的数据对象-2）-防止意外删除对象-以下哪项有助于以经济高效的方式满足-IT-安全部门的要求？选择-2-个答案" class="headerlink" title="28.您的公司有一组 EC2 实例，用于访问存储在 S3 存储桶中的数据对象。您的 IT 安全部门关注此架构的安全性，并希望您实现以下措施： 1） 确保 EC2 实例安全地访问存储在 S3 存储桶中的数据对象 2） 防止意外删除对象 以下哪项有助于以经济高效的方式满足 IT 安全部门的要求？选择 2 个答案"></a>28.您的公司有一组 EC2 实例，用于访问存储在 S3 存储桶中的数据对象。您的 IT 安全部门关注此架构的安全性，并希望您实现以下措施： 1） 确保 EC2 实例安全地访问存储在 S3 存储桶中的数据对象 2） 防止意外删除对象 以下哪项有助于以经济高效的方式满足 IT 安全部门的要求？选择 2 个答案</h2><p><strong>A</strong>. Create an IAM user and ensure the EC2 Instances use the IAM user credentials to access the data in the bucket.<br>.创建 IAM 用户并确保 EC2 实例使用 IAM 用户凭证访问存储桶中的数据。</p><p><strong>B</strong>. Create an IAM Role and ensure the EC2 Instances use the IAM Role to access the data in the bucket.<br>.创建 IAM 角色并确保 EC2 实例使用 IAM 角色访问存储桶中的数据。</p><p><strong>C</strong>. Use S3 Cross-Region Replication to replicate the objects so that the integrity of data is maintained.<br>.使用 S3 跨区域复制复制对象，以保持数据的完整性。</p><p><strong>D</strong>. Use a S3 bucket policy that prevents accidental deletions<br>.使用防止意外删除的 S3 存储桶策略</p><p><strong>E</strong>. Configure S3 to use versioning and enable Multi-Factor Authentication (MFA) protected access<br>.将 S3 配置为使用版本控制并启用多重身份验证 （MFA） 保护访问</p><p>正确答案是 B &amp; E，请参阅 AWS 文档 - IAM 最佳实践和 S3 版本控制，S3 对象版本控制可防止您意外覆盖或删除对象，并为您提供检索对象先前版本的机会，在 Amazon EC2 实例上运行的应用程序需要凭证才能访问其他 AWS 服务。要以安全的方式向应用程序提供凭证，请使用 IAM 角色。角色是具有自己的权限集的实体，但不是用户或组。角色也没有像 IAM 用户那样拥有自己的永久凭证集。对于 Amazon EC2，IAM 会动态地向 EC2 实例提供临时凭证，这些凭证会自动为您轮换，选项 A 是错误的，因为使用 IAM 用户不安全且不是最佳实践，选项 C 是错误的，因为跨区域复制会创建重复对象，从而增加成本，并且它们不会阻止从两个区域删除。选项 D 是错误的，因为存储桶策略无法防止意外删除和恢复</p><h2 id="一家公司正计划使用-Docker-容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？"><a href="#一家公司正计划使用-Docker-容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？" class="headerlink" title="一家公司正计划使用 Docker 容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？"></a>一家公司正计划使用 Docker 容器和必要的容器编排工具来满足其长期批处理需求。需要对关键和非关键数据进行批处理。以下哪项是此要求的最佳实施步骤，以确保有效管理成本？</h2><p><strong>A</strong>. Use Kubernetes for container orchestration and Reserved instances for all underlying instances.<br>.将 Kubernetes 用于容器编排，将预留实例用于所有底层实例。</p><p><strong>B</strong>. Use ECS orchestration and Reserved Instances for all underlying instances.<br>.将 ECS 编排和预留实例用于所有底层实例。</p><p><strong>C</strong>. Use Docker for container orchestration and a combination of Spot and Reserved Instances for the underlying instances.<br>.将 Docker 用于容器编排，并将 Spot 实例和预留实例组合用于底层实例。</p><p><strong>D</strong>. Use ECS for container orchestration and a combination of Spot and Reserved Instances for the underlying instances.<br>.将 ECS 用于容器编排，并将 Spot 实例和预留实例组合用于底层实例。</p><p>正确答案是 D，因为将预留实例用于长期关键批处理，将 Spot 实例用于非关键批处理要求具有成本效益。ECS 可用于容器编排和支持 Spot 实例，请参阅 AWS 文档 - ECS Spot 实例，选项 A 和 B 是错误的，因为它们仅使用预留实例不具有成本效益，选项 C 是错误的，因为 Docker 无法执行容器编排。</p><h2 id="30-公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？"><a href="#30-公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？" class="headerlink" title="30.公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？"></a>30.公司销售人员每天上传他们的销售数据。解决方案架构师需要为这些文档提供持久的存储解决方案，以防止用户意外删除重要文档。哪些操作可以防止用户意外操作？</h2><p><strong>A</strong>. Store data in an EBS volume and create snapshots once a week.<br>.将数据存储在 EBS 卷中，并每周创建一次快照。</p><p><strong>B</strong>. Store data in an S3 bucket and enable versioning.<br>.将数据存储在 S3 存储桶中并启用版本控制。</p><p><strong>C</strong>. Store data in two S3 buckets in different AWS regions.<br>.将数据存储在不同 AWS 区域的两个 S3 存储桶中。</p><p><strong>D</strong>. Store data on EC2 instance storage.</p><p>正确答案是 B，因为对象版本控制有助于在意外删除或覆盖的情况下恢复对象，请参阅 AWS 文档 - S3 版本控制，启用版本控制的存储桶使您能够从意外删除或覆盖中恢复对象。例如：</p><h2 id="31-一家公司正计划在-AWS-的-EC2-实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关-IT-管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？"><a href="#31-一家公司正计划在-AWS-的-EC2-实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关-IT-管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？" class="headerlink" title="31.一家公司正计划在 AWS 的 EC2 实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关 IT 管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？"></a>31.一家公司正计划在 AWS 的 EC2 实例上托管其开发、测试和生产应用程序。他们担心如何为上述每个环境的相关 IT 管理员提供访问控制权。作为架构师，您对管理相关访问有什么建议？</h2><p><strong>A</strong>. Add tags to the instances marking each environment and then segregate access using IAM Policies.<br>.向标记每个环境的实例添加标签，然后使用 IAM 策略隔离访问。</p><p><strong>B</strong>. Add Userdata to the underlying instances to mark each environment.<br>.将用户数据添加到基础实例以标记每个环境。</p><p><strong>C</strong>. Add Metadata to the underlying instances to mark each environment.<br>.将元数据添加到基础实例以标记每个环境。</p><p><strong>D</strong>. Add each environment to a separate Auto Scaling Group.<br>.将每个环境添加到单独的 Auto Scaling 组。</p><p>正确答案是A，因为使用IAM策略对资源的标签可以帮助对属于不同环境的资源进行访问控制，请参阅AWS文档-标签，标签是您分配给AWS资源的标签。每个标签都由一个键和一个可选值组成，这两个值都是您定义的，标签使您能够以不同的方式对 AWS 资源进行分类，例如，按用途、所有者或环境。当您拥有许多相同类型的资源时，这很有用 - 您可以根据分配给特定资源的标签快速识别该资源。例如，您可以为账户的 Amazon EC2 实例定义一组标签，以帮助您跟踪每个实例的所有者和堆栈级别，我们建议您设计一组满足每种资源类型需求的标签键。使用一组一致的标签键可以让您更轻松地管理资源。您可以根据添加的标签搜索和筛选资源。</p><h2 id="32-一家数据分析初创公司要求解决方案架构师为索引数据推荐-AWS-数据存储选项。数据处理引擎每天将生成超过-64-TB-的处理数据，项目大小可达-300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种-AWS-数据存储服务？"><a href="#32-一家数据分析初创公司要求解决方案架构师为索引数据推荐-AWS-数据存储选项。数据处理引擎每天将生成超过-64-TB-的处理数据，项目大小可达-300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种-AWS-数据存储服务？" class="headerlink" title="32.一家数据分析初创公司要求解决方案架构师为索引数据推荐 AWS 数据存储选项。数据处理引擎每天将生成超过 64 TB 的处理数据，项目大小可达 300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种 AWS 数据存储服务？"></a>32.一家数据分析初创公司要求解决方案架构师为索引数据推荐 AWS 数据存储选项。数据处理引擎每天将生成超过 64 TB 的处理数据，项目大小可达 300KB。这家初创公司在数据存储模型方面很灵活，并且对数据库更感兴趣，该数据库需要最少的工作量即可随着数据集大小的增长而扩展。架构师应该推荐哪种 AWS 数据存储服务？</h2><p><strong>A</strong>. Amazon RDS</p><p><strong>B</strong>. Amazon Redshift</p><p><strong>C</strong>. Amazon DynamoDB</p><p><strong>D</strong>. Amazon S3</p><p>正确答案是 C，因为 DynamoDB 将帮助存储索引数据，同时自动扩展。每个项目的属性累积大小必须符合最大 DynamoDB 项目大小 （400KB）。桌子的大小没有实际限制。表在项目数或字节数方面不受限制，选项 A 是错误的，因为 RDS 不会以每天 64TB 的数据进行扩展。此外，所有数据库实例的总存储限制为 100TiB，选项 B 是错误的，因为 Redshift 更像是一种数据分析解决方案，它不会自动扩展。它需要随着需求的变化而调整大小，选项 D 是错误的，因为 S3 不适用于索引数据</p><h2 id="33-您正在构建一个自动转录服务，Amazon-EC2-工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？"><a href="#33-您正在构建一个自动转录服务，Amazon-EC2-工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？" class="headerlink" title="33.您正在构建一个自动转录服务，Amazon EC2 工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？"></a>33.您正在构建一个自动转录服务，Amazon EC2 工作线程实例在其中处理上传的音频文件并生成文本文件。在检索到文本文件之前，必须将这两个文件存储在同一个持久存储中。您不知道存储容量要求是什么。哪种存储选项既经济高效又可扩展？</h2><p><strong>A</strong>. Multiple Amazon EBS volume with snapshots</p><p><strong>B</strong>. A single Amazon Glacier vault</p><p><strong>C</strong>. A single Amazon S3 bucket</p><p><strong>D</strong>. Multiple instance stores<br>.多个实例存储</p><p>这里的关键点是存储需要持久、经济高效和可扩展，正确答案是 C，因为 S3 提供了持久、经济高效和可扩展的存储，选项 A 是错误的，因为 EBS 卷是持久的，但价格昂贵，选项 B 是错误的，因为 Glacier 虽然持久、经济高效且可扩展，但更像是一种存档解决方案，具有不经常访问的数据需求，选项 D 是错误的，因为实例存储不是持久的，因为它们链接到实例的生命周期。如果 EC2 实例终止，数据将丢失。</p><h2 id="34-解决方案架构师正在为生产关系数据库设计存储层。数据库将在-Amazon-EC2-上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机-I-O-延迟。哪种数据存储方式满足上述要求？"><a href="#34-解决方案架构师正在为生产关系数据库设计存储层。数据库将在-Amazon-EC2-上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机-I-O-延迟。哪种数据存储方式满足上述要求？" class="headerlink" title="34.解决方案架构师正在为生产关系数据库设计存储层。数据库将在 Amazon EC2 上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机 I/O 延迟。哪种数据存储方式满足上述要求？"></a>34.解决方案架构师正在为生产关系数据库设计存储层。数据库将在 Amazon EC2 上运行。数据库由执行密集读取和写入的应用程序访问，因此数据库需要最低的随机 I/O 延迟。哪种数据存储方式满足上述要求？</h2><p><strong>A</strong>. Store data in a file system backed by Amazon Elastic File System (EFS)<br>.将数据存储在 Amazon Elastic File System （EFS） 支持的文件系统中</p><p><strong>B</strong>. Store data in Amazon S3 and use a third-party solution to expose Amazon S3 as a file system to the database server.<br>.将数据存储在 Amazon S3 中，并使用第三方解决方案将 Amazon S3 作为文件系统公开给数据库服务器。</p><p><strong>C</strong>. Store data in Amazon DynamoDB and emulate relational database semantics.<br>.将数据存储在 Amazon DynamoDB 中并模拟关系数据库语义。</p><p><strong>D</strong>. Stripe data across multiple Amazon EBS volumes using RAID 0<br>.使用 RAID 0 跨多个 Amazon EBS 卷条带化数据</p><p>正确答案是 D，因为具有 RAID 0 的 EBS 卷将有助于扩展并提供最低的随机 I/O，请参阅 AWS 文档 - EC2 Raid Config，借助 Amazon EBS，您可以使用可用于传统裸机服务器的任何标准 RAID 配置，只要您的实例的操作系统支持该特定 RAID 配置。这是因为所有 RAID 都是在软件级别完成的。为了获得比单个卷更高的 I/O 性能，RAID 0 可以将多个卷条带化在一起;对于实例冗余，RAID 1 可以将两个卷镜像在一起，选项 A 是错误的，因为 EFS 不适合数据库文件系统，选项 B 是错误的，因为 S3 不能用作数据库服务器的文件系统，选项 C 是错误的，因为 DynamoDB 不能用作关系数据库。</p><h2 id="35-解决方案架构师需要在-Amazon-EC2-实例上部署-HTTP-HTTPS-服务，并支持使用负载均衡器的-WebSocket。建筑师如何满足这些要求？"><a href="#35-解决方案架构师需要在-Amazon-EC2-实例上部署-HTTP-HTTPS-服务，并支持使用负载均衡器的-WebSocket。建筑师如何满足这些要求？" class="headerlink" title="35.解决方案架构师需要在 Amazon EC2 实例上部署 HTTP/HTTPS 服务，并支持使用负载均衡器的 WebSocket。建筑师如何满足这些要求？"></a>35.解决方案架构师需要在 Amazon EC2 实例上部署 HTTP/HTTPS 服务，并支持使用负载均衡器的 WebSocket。建筑师如何满足这些要求？</h2><p><strong>A</strong>. Configure a Network Load balancer.<br>.配置 Network Load Balancer。</p><p><strong>B</strong>. Configure an Application Load Balancer.<br>.配置 Application Load Balancer。</p><p><strong>C</strong>. Configure a Classic Load Balancer.<br>.配置 Classic Load Balancer。</p><p><strong>D</strong>. Configure a Layer-4 Load Balancer.<br>.配置四层负载均衡器。</p><p>正确答案是 B，因为 Application Load Balancer 与 Classic 和 Network Load Balancer 不同，它支持 WebSockets，请参阅 AWS 文档 - ELB Application Load Balancer，Application Load Balancer 支持基于内容的路由，并支持在容器中运行的应用程序。它们支持一对行业标准协议（WebSocket 和 HTTP/2），还提供对目标实例和容器运行状况的额外可见性。在容器或EC2实例上运行的网站和移动应用程序将受益于Application Load Balancer的使用，选项A，C和D是错误的，因为它们不支持WebSockets。</p><h2 id="36-Amazon-EC2-实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到-Amazon-CloudWatch-中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？"><a href="#36-Amazon-EC2-实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到-Amazon-CloudWatch-中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？" class="headerlink" title="36.Amazon EC2 实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到 Amazon CloudWatch 中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？"></a>36.Amazon EC2 实例上的应用程序通常会停止响应请求，并且需要重新启动才能恢复。应用程序日志已导出到 Amazon CloudWatch 中，并且您注意到问题始终遵循日志中特定消息的外观。应用程序团队正在努力解决该错误，但尚未提供修复日期。在部署修复程序之前，您可以实施哪些解决方法来自动恢复实例？</h2><p><strong>A</strong>. Create an Amazon CloudWatch alarm on an Amazon CloudWatch Logs filter for that message; based on that alarm, trigger an Amazon CloudWatch action to reboot the instance<br>.在 Amazon CloudWatch Logs 筛选条件上为该消息创建 Amazon CloudWatch 警报;根据该警报，触发 Amazon CloudWatch 操作以重启实例</p><p><strong>B</strong>. Create an AWS CloudTrail alarm on low CPU; based on that alarm, trigger an Amazon SNS message to the Operations team<br>.在 CPU 使用率较低时创建 AWS CloudTrail 警报;根据该警报，触发向运营团队发送 Amazon SNS 消息</p><p><strong>C</strong>. Create an Amazon CloudWatch alarm on instance memory usage; based on that alarm, trigger an Amazon CloudWatch action to reboot the instance<br>.创建有关实例内存使用情况的 Amazon CloudWatch 警报;根据该警报，触发 Amazon CloudWatch 操作以重启实例</p><p><strong>D</strong>. Create an AWS CloudTrail alarm to detect the deadlock, based on the alarm, trigger an Amazon SNS message to the Operations team<br>.创建 AWS CloudTrail 警报以检测死锁，根据警报触发向运营团队发送 Amazon SNS 消息</p><p>正确答案是 A，因为您可以在 CloudWatch 日志上确认 CloudWatch 警报以查找消息并重启实例，请参阅 AWS 文档 - CloudWatch 日志监控，选项 C 是错误的，因为没有内存条件，它无助于处理重启，选项 B 和 D 是错误的，因为 CloudTrail 提供您的 AWS 账户活动的事件历史记录， 包括通过 AWS 管理控制台、AWS 开发工具包、命令行工具和其他 AWS 服务执行的操作。它不提供警报。</p><h2 id="37-您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？"><a href="#37-您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？" class="headerlink" title="37.您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？"></a>37.您正在设计一个具有堡垒主机的系统。此组件需要在没有人为干预的情况下保持高可用性。您会选择以下哪种方法？</h2><p><strong>A</strong>. Run the bastion on two instances one in each AZ<br>.在两个实例上运行堡垒，每个可用区一个</p><p><strong>B</strong>. Run the bastion on an active Instance in one AZ and have an AMI ready to boot up in the event of failure<br>.在一个可用区中的活动实例上运行堡垒，并准备好在发生故障时启动 AMI</p><p><strong>C</strong>. Configure the bastion instance in an Auto Scaling group Specify the Auto Scaling group to include multiple AZs but have a min-size of 1 and max-size of 1<br>.在 Auto Scaling 组中配置堡垒实例 指定 Auto Scaling 组以包含多个可用区，但最小大小为 1，最大大小为 1</p><p><strong>D</strong>. Configure an ELB in front of the bastion instance<br>.在堡垒实例前配置ELB</p><p>正确答案是 C，因为堡垒主机允许来自外部网络的用户能够登录私有子网中的实例。堡垒主机可以通过在多个可用区中启用自动扩展（最小值和最大值为 1）来实现高可用性，这样，如果一个实例出现故障，另一个实例无需人工干预即可使用，选项 A 是错误的，因为它仍然无法处理可用区故障，选项 B 是错误的，因为它仍然需要手动干预。选项 D 是错误的，因为 ELB 不仅仅是 Web 访问。</p><h2 id="38-当您设计支持-24-小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？"><a href="#38-当您设计支持-24-小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？" class="headerlink" title="38.当您设计支持 24 小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？"></a>38.当您设计支持 24 小时限时抢购时，以下哪种方法最能描述在保持异常繁忙流量的同时降低延迟的策略？</h2><p><strong>A</strong>. Launch enhanced networking instances in a placement group to support the heavy traffic<br>.在置放群组中启动增强型联网实例，以支持繁重的流量</p><p><strong>B</strong>. Apply Service Oriented Architecture (SOA) principles instead of a 3-tier architecture<br>.应用面向服务的架构 （SOA） 原则，而不是 3 层架构</p><p><strong>C</strong>. Use Elastic Beanstalk to enable blue-green deployment<br>.使用 Elastic Beanstalk 启用蓝绿部署</p><p><strong>D</strong>. Use ElastiCache as in-memory storage on top of DynamoDB to store user sessions<br>.将 ElastiCache 用作 DynamoDB 上的内存中存储来存储用户会话</p><p>正确答案是 D，因为带有 DynamoDB 的 ElastiCache 将有助于提供可扩展、更快的读/写和内存存储以减少延迟，选项 A 是错误的，因为只会提高 EC2 实例中的内部吞吐量，选项 B 是错误的，因为它只是简化了架构但不能减少延迟，选项 C 是错误的，因为它改进了部署，最大限度地减少了应用程序的停机时间并易于回滚</p><h2 id="39-Web-应用程序在从单个客户-Amazon-系统映像-（AMI）-启动的-10-个-EC2-实例上运行。EC2-实例位于-Internet-Application-Load-Balancer-后面。Amazon-Route-53-为应用程序提供-DNS。如果-Web-服务器实例停止回复请求，解决方案架构师应如何自动恢复？"><a href="#39-Web-应用程序在从单个客户-Amazon-系统映像-（AMI）-启动的-10-个-EC2-实例上运行。EC2-实例位于-Internet-Application-Load-Balancer-后面。Amazon-Route-53-为应用程序提供-DNS。如果-Web-服务器实例停止回复请求，解决方案架构师应如何自动恢复？" class="headerlink" title="39.Web 应用程序在从单个客户 Amazon 系统映像 （AMI） 启动的 10 个 EC2 实例上运行。EC2 实例位于 Internet Application Load Balancer 后面。Amazon Route 53 为应用程序提供 DNS。如果 Web 服务器实例停止回复请求，解决方案架构师应如何自动恢复？"></a>39.Web 应用程序在从单个客户 Amazon 系统映像 （AMI） 启动的 10 个 EC2 实例上运行。EC2 实例位于 Internet Application Load Balancer 后面。Amazon Route 53 为应用程序提供 DNS。如果 Web 服务器实例停止回复请求，解决方案架构师应如何自动恢复？</h2><p><strong>A</strong>. Launch the instances in an Auto Scaling group with an Elastic Load Balancing health check.<br>.使用 Elastic Load Balancing 运行状况检查启动 Auto Scaling 组中的实例。</p><p><strong>B</strong>. Launch instances in multiple Availability Zones and set the load balancer to Multi-AZ<br>.在多个可用区中启动实例，并将负载均衡器设置为多可用区</p><p><strong>C</strong>. Add CloudWatch alarm actions for each instance to restart if the Status Check (Any) fails<br>.为每个实例添加 CloudWatch 警报操作，以便在状态检查 （Any） 失败时重新启动</p><p><strong>D</strong>. Add Route 53 records for each instance with an instance health check<br>.使用实例运行状况检查为每个实例添加 Route 53 记录</p><p>正确答案是 A，因为启用了 Auto Scaling 和运行状况检查的 ELB 将有助于处理恢复。Auto Scaling 有助于将实例替换为 Auto Scaling 配置中指定的 AMI。ELB 将帮助处理仅将流量路由到正常运行的实例。Route 53 DNS 只需指向 ELB，Auto Scaling 实例的运行状况为正常或不正常。Auto Scaling 组中的所有实例都以正常状态启动。除非 Amazon EC2 Auto Scaling 收到运行状况不佳的通知，否则假定实例运行状况良好。此通知可以来自以下一个或多个来源：Amazon EC2、Elastic Load Balancing 或自定义运行状况检查，在 Amazon EC2 Auto Scaling 将实例标记为运行状况不佳后，将计划对其进行替换。如果您不希望替换实例，可以暂停任何单个 Auto Scaling 组的运行状况检查过程，要发现 EC2 实例的可用性，负载均衡器会定期发送 ping、尝试连接或发送请求来测试 EC2 实例。这些测试称为运行状况检查。运行状况检查时运行状况良好的实例的状态为 InService。运行状况检查时运行状况不佳的任何实例的状态为 OutOfService。负载均衡器对所有已注册的实例执行运行状况检查，无论实例处于健康状态还是不健康状态，负载均衡器仅将请求路由到健康实例当负载均衡器确定某个实例运行状况不佳时，它会停止将请求路由到该实例。负载均衡器在实例恢复到正常状态后继续将请求路由到实例。，负载均衡器使用 Elastic Load Balancing 提供的默认运行状况检查配置或您配置的运行状况检查配置来检查已注册实例的运行状况，如果您已将 Auto Scaling 组与 Classic 负载均衡器关联，则可以使用负载均衡器运行状况检查来确定 Auto Scaling 组中实例的运行状况。默认情况下，Auto Scaling 组会定期确定每个实例的运行状况，选项 B 是错误的，因为多个可用区中的 ELB 和 Auto Scaling 提供 HA，但如果未配置运行状况检查，则无助于恢复，选项 C 是错误的，因为每个实例不需要 CloudWatch 警报，因为使用 Auto Scaling 组，实例会不断变化。选项 D 是错误的，因为 Route 53 需要指向 Application Load Balancer。它不提供实例的负载均衡。</p><h2 id="40-我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在-AWS-S3-存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案："><a href="#40-我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在-AWS-S3-存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案：" class="headerlink" title="40.我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在 AWS S3 存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案："></a>40.我们开发了一个移动应用程序，每周下载数百次。我们应该为移动客户端启用哪种身份验证方法来访问存储在 AWS S3 存储桶中的图像，从而为我们提供最高的灵活性并轮换凭证？选择正确答案：</h2><p><strong>A</strong>. Identity Federation based on AWS STS using an AWS IAM policy for the respective S3 bucket<br>.基于 AWS STS 的联合身份验证，使用相应 S3 存储桶的 AWS IAM 策略</p><p><strong>B</strong>. Use ACLs to restrict the access to the selects AWS accounts<br>.使用 ACL 限制对所选 AWS 账户的访问</p><p><strong>C</strong>. Set up S3 bucket policies with a conditional statement restricting IP address<br>.使用限制 IP 地址的条件语句设置 S3 存储桶策略</p><p><strong>D</strong>. IAM user per every registered client with an IAM policy that grants S3 access to the respective bucket<br>.每个注册客户端的 IAM 用户，其 IAM 策略授予对相应存储桶的 S3 访问权限</p><p>正确答案是 A，因为它是一个移动应用程序，用户可以使用 STS 的联合身份验证进行身份验证，并仅授予对相应 S3 存储桶的访问权限，请参阅 AWS 文档 - IAM Web 联合身份验证</p><h2 id="41-一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的-Web-服务器即将加载，作为架构师，您不希望使用现有的-Web-服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？"><a href="#41-一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的-Web-服务器即将加载，作为架构师，您不希望使用现有的-Web-服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？" class="headerlink" title="41.一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的 Web 服务器即将加载，作为架构师，您不希望使用现有的 Web 服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？"></a>41.一家公司正在构建一个费用跟踪系统，使用户能够上传图像。现有的 Web 服务器即将加载，作为架构师，您不希望使用现有的 Web 服务器来上传图像，因为它会产生额外的负载。如何以具有成本效益的方式处理这个问题？</h2><p><strong>A</strong>. Create a secondary S3 bucket. Then, use an AWS Lambda to sync the contents to the primary bucket.<br>.创建辅助 S3 存储桶。然后，使用 AWS Lambda 将内容同步到主存储桶。</p><p><strong>B</strong>. Use Auto Scaling and increase the capacity as demand increased<br>.使用 Auto Scaling 并随着需求的增加增加容量</p><p><strong>C</strong>. Use Pre-Signed URLs instead to upload the images.<br>.请改用预签名 URL 上传图像。</p><p><strong>D</strong>. Use ECS Containers to upload the images.<br>.使用 ECS 容器上传镜像。</p><p>正确答案是C，因为该解决方案正在寻找减少Web服务器上负载的选项，可以为上传生成预签名URL，这将允许用户直接上传到S3，而不必通过Web服务器路由请求。选项 D 是错误的，因为 ECS 容器需要额外的硬件，从而增加成本和时间。</p><h2 id="42-您目前正在为您的公司构建一个将使用-API-网关的解决方案。您希望确保在设计-API-网关时能够减少对-API-网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。"><a href="#42-您目前正在为您的公司构建一个将使用-API-网关的解决方案。您希望确保在设计-API-网关时能够减少对-API-网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。" class="headerlink" title="42.您目前正在为您的公司构建一个将使用 API 网关的解决方案。您希望确保在设计 API 网关时能够减少对 API 网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。"></a>42.您目前正在为您的公司构建一个将使用 API 网关的解决方案。您希望确保在设计 API 网关时能够减少对 API 网关的请求的延迟。您可以确保执行以下哪些操作来满足此要求。</h2><p><strong>A</strong>. Use AWS API Gateway with CloudFront<br>.将 AWS API Gateway 与 CloudFront 结合使用</p><p><strong>B</strong>. Enable API Gateway Caching</p><p><strong>C</strong>. Enable API Stages<br>.启用 API 阶段</p><p><strong>D</strong>. Enable CORS configuration for the API Gateway<br>.为 API Gateway 启用 CORS 配置</p><p>正确答案是 B，因为 API Gateway 缓存有助于缓存终端节点的响应并提高性能，请参阅 AWS 文档 - API Gateway 缓存，您可以在 Amazon API Gateway 中启用 API 缓存来缓存终端节点的响应。通过缓存，您可以减少对终端节点的调用次数，还可以改善对 API 的请求的延迟。当您为阶段启用缓存时，API Gateway 会在指定的生存时间 （TTL） 周期内（以秒为单位）缓存来自终端节点的响应。然后，API Gateway 通过从缓存中查找终端节点响应来响应请求，而不是向终端节点发出请求。API 缓存的默认 TTL 值为 300 秒。最大 TTL 值为 3600 秒。TTL=0 表示缓存被禁用，选项 A 是错误的，因为 CloudFront 已经与 API 网关一起使用，选项 C 是错误的，因为 API 阶段用于部署不同版本的 API，选项 D 是错误的，因为 CORS 启用了 API 的跨域访问</p><h2 id="43-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？"><a href="#43-用户创建了一个照片编辑软件并将其托管在-EC2-上。该软件接受用户关于照片格式和分辨率的请求，并向-S3-发送消息以相应地增强图片。在这种情况下，下面提到的哪些-AWS-服务将有助于使用-AWS-基础设施构建可扩展的软件？" class="headerlink" title="43.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？"></a>43.用户创建了一个照片编辑软件并将其托管在 EC2 上。该软件接受用户关于照片格式和分辨率的请求，并向 S3 发送消息以相应地增强图片。在这种情况下，下面提到的哪些 AWS 服务将有助于使用 AWS 基础设施构建可扩展的软件？</h2><p><strong>A</strong>. AWS Glacier</p><p><strong>B</strong>. AWS Elastic Transcoder</p><p><strong>C</strong>. AWS Simple Notification Service<br>.AWS 简单通知服务</p><p><strong>D</strong>. AWS Simple Queue Service</p><p>正确答案是D，因为SQS可用于构建可扩展和解耦的软件。SQS 可用于在 S3 中存储消息和文件，并相应地进行处理和扩展。</p><h2 id="44-解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用-Amazon-CloudWatch-监控此流量信息是否存在异常。架构师应该采取什么方法？"><a href="#44-解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用-Amazon-CloudWatch-监控此流量信息是否存在异常。架构师应该采取什么方法？" class="headerlink" title="44.解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用 Amazon CloudWatch 监控此流量信息是否存在异常。架构师应该采取什么方法？"></a>44.解决方案架构师正在设计一种解决方案，该解决方案在网络接口之间保留流量信息。信息安全团队将使用 Amazon CloudWatch 监控此流量信息是否存在异常。架构师应该采取什么方法？</h2><p><strong>A</strong>. Maintain traffic history on each Amazon EC2 instance.<br>.维护每个 Amazon EC2 实例上的流量历史记录。</p><p><strong>B</strong>. Enable Amazon VPC Flow Logs.</p><p><strong>C</strong>. Enable CloudTrail for VPC<br>.为 VPC 启用 CloudTrail</p><p><strong>D</strong>. Enable Amazon VPC Network Logs</p><p>正确答案是 B，因为只有 VPC 流日志可以帮助跟踪 VPC 中网络接口之间的流量，请参阅 AWS 文档 - VPC 流日志，VPC 流日志是一项功能，可让您捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据可以发布到 Amazon CloudWatch Logs 和 Amazon S3。创建流日志后，您可以在所选目标中检索和查看其数据，流日志可以帮助您完成许多任务;例如，排查特定流量未到达实例的原因，这反过来又可以帮助您诊断限制性过强的安全组规则。您还可以使用流日志作为安全工具来监控到达实例的流量，选项 A 是错误的，因为需要捕获传入流量才能在每个 EC2 实例中进行维护。此外，它们需要在单个外部源进行整合，选项 C 是错误的，因为 CloudTrail 无法帮助跟踪 VPC 之间的网络流量。CloudTrail 提供您的 AWS 账户活动的事件历史记录，包括通过 AWS 管理控制台、AWS 开发工具包、命令行工具和其他 AWS 服务执行的操作，选项 D 是错误的，因为有 VPC 网络日志配置。</p><h2 id="45-一家公司正在使用-AWS-Key-Management-Service-（KMS）-进行安全密钥管理。已建议该公司记录其-AWS-KMS-密钥的所有使用情况。什么是最简单的解决方案？"><a href="#45-一家公司正在使用-AWS-Key-Management-Service-（KMS）-进行安全密钥管理。已建议该公司记录其-AWS-KMS-密钥的所有使用情况。什么是最简单的解决方案？" class="headerlink" title="45.一家公司正在使用 AWS Key Management Service （KMS） 进行安全密钥管理。已建议该公司记录其 AWS KMS 密钥的所有使用情况。什么是最简单的解决方案？"></a>45.一家公司正在使用 AWS Key Management Service （KMS） 进行安全密钥管理。已建议该公司记录其 AWS KMS 密钥的所有使用情况。什么是最简单的解决方案？</h2><p><strong>A</strong>. Associate AWS KMS metrics with Amazon CloudWatch</p><p><strong>B</strong>. Use AWS CloudTrail to log AWS KMS key usage.</p><p><strong>C</strong>. Deploy a monitoring agent to the RDS instances.<br>.将监控Agent部署到RDS实例。</p><p><strong>D</strong>. Poll AWS KMS periodically with a scheduled job.<br>.使用计划作业定期轮询 AWS KMS。</p><p>正确答案是 B，因为 CloudTrail 与 AWS KMS 集成并帮助跟踪 KMS 发生的所有事件，请参阅 AWS 文档 - 使用 CloudTrail 进行 AWS KMS 日志记录，AWS KMS 与 AWS CloudTrail 集成，后者是一项服务，可在 AWS KMS 中提供用户、角色或 AWS 服务执行的操作的记录。CloudTrail 将对 AWS KMS 的所有 API 调用作为事件捕获，包括来自 AWS KMS 控制台的调用和对 AWS KMS API 的代码调用。如果您创建跟踪，则可以使 CloudTrail 事件持续传送到 Amazon S3 存储桶，包括 AWS KMS 的事件。如果您未配置跟踪，您仍然可以在 CloudTrail 控制台的 Event history （事件历史记录） 中查看最新事件。通过使用 CloudTrail 收集的信息，您可以确定向 AWS KMS 发出了什么请求、发出请求的 IP 地址、何人发出的请求、请求的发出时间以及其他详细信息。</p><h2 id="46-一位解决方案架构师正在设计一种解决方案，用于在-Amazon-S3-中存储大量事件数据。架构师预计工作负载将始终超过每秒-100-个请求。架构师应该在-Amazon-S3-中执行哪些操作来优化性能？"><a href="#46-一位解决方案架构师正在设计一种解决方案，用于在-Amazon-S3-中存储大量事件数据。架构师预计工作负载将始终超过每秒-100-个请求。架构师应该在-Amazon-S3-中执行哪些操作来优化性能？" class="headerlink" title="46.一位解决方案架构师正在设计一种解决方案，用于在 Amazon S3 中存储大量事件数据。架构师预计工作负载将始终超过每秒 100 个请求。架构师应该在 Amazon S3 中执行哪些操作来优化性能？"></a>46.一位解决方案架构师正在设计一种解决方案，用于在 Amazon S3 中存储大量事件数据。架构师预计工作负载将始终超过每秒 100 个请求。架构师应该在 Amazon S3 中执行哪些操作来优化性能？</h2><p><strong>A</strong>. Randomize the key name prefix</p><p><strong>B</strong>. Store the event data in separate buckets<br>.将事件数据存储在单独的存储桶中</p><p><strong>C</strong>. Randomize the key name suffix</p><p><strong>D</strong>. Use Amazon S3 Transfer Acceleration</p><p>正确答案是 A，因为随机性有助于将对象分布在多个分区中，从而提高性能，注意 - AWS S3 的最新增强功能现在提供了更高的性能，支持每秒至少 3,500 个请求来添加数据和每秒 5,500 个请求来检索数据，S3 性能已更新，但这是之前来自 AWS 的建议。Amazon S3 在每个 AWS 区域中维护对象键名称的索引。对象键以 UTF-8 二进制顺序存储在索引中的多个分区中。密钥名称决定了密钥存储在哪个分区中。使用顺序前缀（如时间戳或字母顺序）会增加 Amazon S3 将大量密钥作为特定分区目标的可能性，从而使分区的 I/O 容量不堪重负。如果在键名前缀中引入一些随机性，则键名以及 I/O 负载将分布在多个分区中，示例 1：在键名中添加十六进制哈希前缀，为键名引入随机性的一种方法是添加哈希字符串作为键名的前缀。例如，您可以计算计划分配为键名的字符序列的 MD5 哈希值。从哈希中，选取特定数量的字符，并将它们作为前缀添加到键名称中。以下示例显示了具有四个字符哈希的键名称。</p><h2 id="47-Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的-Facebook-帐户登录游戏，游戏会将玩家数据和得分信息直接记录到-DynamoDB-表中。对-DynamoDB-API-的请求进行签名的最安全方法是什么？"><a href="#47-Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的-Facebook-帐户登录游戏，游戏会将玩家数据和得分信息直接记录到-DynamoDB-表中。对-DynamoDB-API-的请求进行签名的最安全方法是什么？" class="headerlink" title="47.Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的 Facebook 帐户登录游戏，游戏会将玩家数据和得分信息直接记录到 DynamoDB 表中。对 DynamoDB API 的请求进行签名的最安全方法是什么？"></a>47.Games-R-Us正在为移动设备推出一款新的游戏应用程序。用户将使用其现有的 Facebook 帐户登录游戏，游戏会将玩家数据和得分信息直接记录到 DynamoDB 表中。对 DynamoDB API 的请求进行签名的最安全方法是什么？</h2><p><strong>A</strong>. Create an IAM user with access credentials that are distributed with the mobile app to sign the requests<br>.使用随移动应用程序分发的访问凭证创建一个 IAM 用户，以便对请求进行签名</p><p><strong>B</strong>. Distribute the AWS root account access credentials with the mobile app to sign the requests<br>.将 AWS 根账户访问凭证与移动应用程序一起分发，以便对请求进行签名</p><p><strong>C</strong>. Request temporary security credentials using web identity federation to sign the requests<br>.使用 Web 联合身份验证请求临时安全凭证以对请求进行签名</p><p><strong>D</strong>. Establish cross account access between the mobile app and the DynamoDB table to sign the requests<br>.在移动应用程序和 DynamoDB 表之间建立跨账户访问，以便对请求进行签名</p><p>正确答案是 C，因为使用 IAM 角色 Web 联合身份验证将有助于身份验证和生成临时凭证，请参阅 AWS 文档 - IAM Web 联合身份验证，示例流程 - Cognito 是简化 Web 联合身份验证的服务。</p><h2 id="48-您正在为读取密集型的小型数据库创建新的联机事务处理-（OLTP）-应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种-Amazon-EBS-存储选项将实现最一致的性能，以帮助保持性能？"><a href="#48-您正在为读取密集型的小型数据库创建新的联机事务处理-（OLTP）-应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种-Amazon-EBS-存储选项将实现最一致的性能，以帮助保持性能？" class="headerlink" title="48.您正在为读取密集型的小型数据库创建新的联机事务处理 （OLTP） 应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种 Amazon EBS 存储选项将实现最一致的性能，以帮助保持性能？"></a>48.您正在为读取密集型的小型数据库创建新的联机事务处理 （OLTP） 应用程序。数据库中的单个表全天持续更新，并且数据库性能的交付应保持一致。哪种 Amazon EBS 存储选项将实现最一致的性能，以帮助保持性能？</h2><p><strong>A</strong>. Provisioned IOP SSD<br>.预置 IOP SSD</p><p><strong>B</strong>. General purpose SSD</p><p><strong>C</strong>. Cold HDD .冷硬盘</p><p><strong>D</strong>. Throughtput Optimized HDD.<br>.吞吐量优化的 HDD。</p><p>正确答案是 A，因为建议将预置 IOPS SSD 用于具有持续高吞吐量的 OLTP 要求，请参阅 AWS 文档 - EBS 卷类型，预配置 IOPS SSD （io1） 卷旨在满足对存储性能和一致性敏感的 I/O 密集型工作负载的需求，尤其是数据库工作负载。</p><h2 id="49-您有一个-Web-样式的应用程序，该应用程序具有无状态但-CPU-和内存密集型-Web-层，在-VPC-内的-cc2-8xlarge-EC2-实例上运行。负载不足的实例在业务定义的-SLA-内返回请求时出现问题。应用程序在-DynamoDB-表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合-SLA-的问题？"><a href="#49-您有一个-Web-样式的应用程序，该应用程序具有无状态但-CPU-和内存密集型-Web-层，在-VPC-内的-cc2-8xlarge-EC2-实例上运行。负载不足的实例在业务定义的-SLA-内返回请求时出现问题。应用程序在-DynamoDB-表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合-SLA-的问题？" class="headerlink" title="49.您有一个 Web 样式的应用程序，该应用程序具有无状态但 CPU 和内存密集型 Web 层，在 VPC 内的 cc2.8xlarge EC2 实例上运行。负载不足的实例在业务定义的 SLA 内返回请求时出现问题。应用程序在 DynamoDB 表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合 SLA 的问题？"></a>49.您有一个 Web 样式的应用程序，该应用程序具有无状态但 CPU 和内存密集型 Web 层，在 VPC 内的 cc2.8xlarge EC2 实例上运行。负载不足的实例在业务定义的 SLA 内返回请求时出现问题。应用程序在 DynamoDB 表中保持其状态，但数据层已正确预置，并且响应速度始终很快。如何最好地解决应用程序响应不符合 SLA 的问题？</h2><p><strong>A</strong>. Add another cc2.8xlarge application instance, and put both behind an Elastic Load Balancer<br>.添加另一个 cc2.8xlarge 应用程序实例，并将这两个实例放在 Elastic Load Balancer 后面</p><p><strong>B</strong>. Move the cc2.8xlarge to the same Availability Zone as the DynamoDB table<br>.将 cc2.8xlarge 移动到与 DynamoDB 表相同的可用区</p><p><strong>C</strong>. Cache the database responses in ElastiCache for more rapid access<br>.在 ElastiCache 中缓存数据库响应，以便更快速地访问</p><p><strong>D</strong>. Move the database from DynamoDB to RDS MySQL in scale-out read-replica configuration<br>.在横向扩展只读副本配置中将数据库从 DynamoDB 移动到 RDS MySQL</p><p>这里的关键点是数据层已正确配置，响应速度始终很快，只是应用程序响应需要改进，正确答案是 A，因为性能在负载期间受到影响，解决方案可以在负载均衡器平衡负载的情况下横向扩展，选项 B 是错误的，因为它没有提高处理能力，因此没有提高响应时间和性能，选项 C 和 D 是错误的，因为数据层响应速度很快</p><h2 id="50-解决方案架构师需要使用-AWS-为本地数据中心托管的三层-Web-应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？"><a href="#50-解决方案架构师需要使用-AWS-为本地数据中心托管的三层-Web-应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？" class="headerlink" title="50.解决方案架构师需要使用 AWS 为本地数据中心托管的三层 Web 应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？"></a>50.解决方案架构师需要使用 AWS 为本地数据中心托管的三层 Web 应用程序实施试点轻型灾难恢复。哪种解决方案可以快速提供可操作的、完全扩展的生产环境？</h2><p><strong>A</strong>. Continuously replicate the production database server to Amazon RDS. Use AWS CloudFormation to deploy the application and any additional servers if necessary.<br>.将生产数据库服务器持续复制到 Amazon RDS。如有必要，请使用 AWS CloudFormation 部署应用程序和任何其他服务器。</p><p><strong>B</strong>. Continuously replicate the production database server to Amazon RDS. Create one application load balancer and register on-premises servers. Configure ELB Application Load Balancer to automatically deploy Amazon EC2 instances for application and additional servers, if the on-premises application is down.<br>.将生产数据库服务器持续复制到 Amazon RDS。创建一个 Application Load Balancer 并注册本地服务器。将 ELB Application Load Balancer 配置为在本地应用程序关闭时自动为应用程序和其他服务器部署 Amazon EC2 实例。</p><p><strong>C</strong>. Use a scheduled Lambda function to replicate the production database to AWS. Use Amazon Route 53 health checks to deploy the application automatically to Amazon S3, if production is unhealthy.<br>.使用计划的 Lambda 函数将生产数据库复制到 AWS。如果生产运行状况不佳，请使用 Amazon Route 53 运行状况检查将应用程序自动部署到 Amazon S3。</p><p><strong>D</strong>. Use a scheduled Lambda function to replicate the production database to AWS. Register on-premises servers to an Auto Scaling group and deploy the application to additional servers, if production is unavailable.<br>.使用计划的 Lambda 函数将生产数据库复制到 AWS。如果生产不可用，请将本地服务器注册到 Auto Scaling 组，并将应用程序部署到其他服务器。</p><p>请注意，对于基于 MAC 地址的软件许可，您可以使用弹性网络接口 （ENI），其 MAC 地址也可以预先分配以预配许可证。您可以将这些实例与实例关联，就像与弹性 IP 地址关联一样。 使用 Elastic Load Balancing （ELB） 将流量分配到多个实例。然后，您将更新 DNS 记录，以指向您的 Amazon EC2 实例或使用 CNAME 指向您的负载均衡器。对于不太重要的系统，我们建议将此选项用于传统的基于 Web 的应用程序，您可以确保在 AWS 中提供任何安装包和配置信息，例如，以 Amazon EBS 快照的形式。这将加快应用程序服务器的设置速度，因为您可以在多个可用区中快速创建多个卷以附加到 Amazon EC2 实例。然后，您可以进行相应的安装和配置，例如，使用备份和恢复方法，选项B是错误的，因为指示灯中不需要ALB。只有RDS需要复制，选项C是错误的，因为Lambda函数复制数据库更改不可靠，Route 53运行状况检查无法部署，S3不适合应用程序部署。 请注意，对于基于 MAC 地址的软件许可，您可以使用弹性网络接口 （ENI），其 MAC 地址也可以预先分配以预配许可证。您可以将这些实例与实例关联，就像与弹性 IP 地址关联一样。 使用 Elastic Load Balancing （ELB） 将流量分配到多个实例。然后，您将更新 DNS 记录，以指向您的 Amazon EC2 实例或使用 CNAME 指向您的负载均衡器。对于不太重要的系统，我们建议将此选项用于传统的基于 Web 的应用程序，您可以确保在 AWS 中提供任何安装包和配置信息，例如，以 Amazon EBS 快照的形式。这将加快应用程序服务器的设置速度，因为您可以在多个可用区中快速创建多个卷以附加到 Amazon EC2 实例。然后，您可以进行相应的安装和配置，例如，使用备份和恢复方法，选项B是错误的，因为指示灯中不需要ALB。只有RDS需要复制，选项C是错误的，因为Lambda函数复制数据库更改不可靠，Route 53运行状况检查无法部署，S3不适合应用程序部署。，选项 D 是错误的，因为 Lambda 函数在复制数据库更改方面不可靠，并且 Auto Scaling 无法跨本地服务器</p><h2 id="51-用户创建了一个应用程序，该应用程序将托管在-EC2-上。应用程序调用-DynamoDB-以获取某些数据。应用程序正在使用-DynamoDB-开发工具包从-EC2-实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？"><a href="#51-用户创建了一个应用程序，该应用程序将托管在-EC2-上。应用程序调用-DynamoDB-以获取某些数据。应用程序正在使用-DynamoDB-开发工具包从-EC2-实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？" class="headerlink" title="51.用户创建了一个应用程序，该应用程序将托管在 EC2 上。应用程序调用 DynamoDB 以获取某些数据。应用程序正在使用 DynamoDB 开发工具包从 EC2 实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？"></a>51.用户创建了一个应用程序，该应用程序将托管在 EC2 上。应用程序调用 DynamoDB 以获取某些数据。应用程序正在使用 DynamoDB 开发工具包从 EC2 实例进行连接。对于此方案中的安全性最佳实践，下面提到的哪项陈述是正确的？</h2><p><strong>A</strong>. The user should attach an IAM role with DynamoDB access to the EC2 instance<br>.用户应将具有 DynamoDB 访问权限的 IAM 角色附加到 EC2 实例</p><p><strong>B</strong>. The user should create an IAM user with DynamoDB access and use its credentials within the application to connect with DynamoDB<br>.用户应创建具有 DynamoDB 访问权限的 IAM 用户，并在应用程序中使用其凭证与 DynamoDB 连接</p><p><strong>C</strong>. The user should create an IAM role, which has EC2 access so that it will allow deploying the application<br>.用户应创建一个具有 EC2 访问权限的 IAM 角色，以便允许部署应用程序</p><p><strong>D</strong>. The user should create an IAM user with DynamoDB and EC2 access. Attach the user with the application so that it does not use the root account credentials<br>.用户应创建具有 DynamoDB 和 EC2 访问权限的 IAM 用户。将用户与应用程序附加，以便它不使用 root 帐户凭据</p><p>正确答案是 A，因为创建 IAM 角色并将其附加到实例是最佳实践。然后，应用程序可以使用临时凭证进行 DynamoDB 调用，选项 B 和 D 是错误的，因为不建议使用 IAM 用户，因为您需要对凭证进行硬编码以公开它们，并且很难轮换，选项 C 是错误的，因为您需要创建一个具有 DynamoDB 访问权限的角色并将其分配给 EC2。应用程序不需要具有 EC2 访问权限。</p><h2 id="52-客户将其公司网站托管在面向公众的负载均衡器后面的-Web-服务器群集上。客户还使用-Amazon-Route-53-来管理其公有-DNS。客户应如何配置-DNS-区域顶点记录以指向负载均衡器？"><a href="#52-客户将其公司网站托管在面向公众的负载均衡器后面的-Web-服务器群集上。客户还使用-Amazon-Route-53-来管理其公有-DNS。客户应如何配置-DNS-区域顶点记录以指向负载均衡器？" class="headerlink" title="52.客户将其公司网站托管在面向公众的负载均衡器后面的 Web 服务器群集上。客户还使用 Amazon Route 53 来管理其公有 DNS。客户应如何配置 DNS 区域顶点记录以指向负载均衡器？"></a>52.客户将其公司网站托管在面向公众的负载均衡器后面的 Web 服务器群集上。客户还使用 Amazon Route 53 来管理其公有 DNS。客户应如何配置 DNS 区域顶点记录以指向负载均衡器？</h2><p><strong>A</strong>. Create an A record pointing to the IP address of the load balancer<br>.创建指向负载均衡器的 IP 地址的 A 记录</p><p><strong>B</strong>. Create a CNAME record pointing to the load balancer DNS name.<br>.创建指向负载均衡器 DNS 名称的 CNAME 记录。</p><p><strong>C</strong>. Create a CNAME record aliased to the load balancer DNS name.</p><p><strong>D</strong>. Create an A record aliased to the load balancer DNS name<br>.创建别名为负载均衡器 DNS 名称的 A 记录</p><p>正确答案是 D，因为 Route 53 支持在 A 记录上为顶级域名记录设置别名记录，Q。我可以将我的顶级域名（example.com 与 <a href="http://www.example.com)指向我的/">www.example.com）指向我的</a> Elastic Load Balancer 吗？Amazon Route 53 提供了一种称为“别名”记录的特殊类型的记录，可让您将顶级域名 （example.com） DNS 名称映射到 ELB DNS 名称（即 elb1234.elb.amazonaws.com）。与 Amazon Elastic Load Balancer 关联的 IP 地址可能因扩展、缩减或软件更新而随时更改。Route 53 使用负载均衡器的一个或多个 IP 地址响应别名记录的每个请求。对映射到 ELB 负载均衡器的别名记录的查询是免费的。这些查询在 Amazon Route 53 使用情况报告中列为“AWS-DNS-Intra-Queries”。</p><h2 id="53-关于加密的-Amazon-Elastic-Block-Store-（EBS）-卷，以下哪项是正确的？选择-2-个答案"><a href="#53-关于加密的-Amazon-Elastic-Block-Store-（EBS）-卷，以下哪项是正确的？选择-2-个答案" class="headerlink" title="53.关于加密的 Amazon Elastic Block Store （EBS） 卷，以下哪项是正确的？选择 2 个答案"></a>53.关于加密的 Amazon Elastic Block Store （EBS） 卷，以下哪项是正确的？选择 2 个答案</h2><p><strong>A</strong>. Supported on all Amazon EBS volume types<br>.支持所有 Amazon EBS 卷类型</p><p><strong>B</strong>. Snapshots are automatically encrypted<br>.快照自动加密</p><p><strong>C</strong>. Available to all instance types<br>.适用于所有实例类型</p><p><strong>D</strong>. Existing volumes can be encrypted<br>.可以对现有卷进行加密</p><p><strong>E</strong>. Shared volumes can be encrypted<br>.可以对共享卷进行加密</p><p>这里的关键点是检查加密的 EBS 卷是否为 true，请参阅 AWS 文档 - EBS 加密，正确答案是 A 和 B，所有 EBS 卷类型（通用型 SSD [gp2]、预置 IOPS SSD [io1]、吞吐量优化型 HDD [st1]、Cold HDD [sc1] 和磁性 [标准]）都支持此功能，从加密卷中获取的快照会自动加密，选项 C 是错误的，因为 Amazon EBS 加密仅适用于某些实例类型。选中支持的实例类型，选项 D 错误，因为现有卷无法加密，您需要创建加密快照以重新创建加密卷，选项 E 错误，因为卷不共享，但快照共享。此外，AWS最近允许共享加密快照，但不能公开，您可以与特定的AWS账户共享加密快照，但不能将其公开</p><h2 id="54-应用程序在私有子网中的-Amazon-EC2-实例上运行。应用程序需要在-Amazon-Kinesis-Data-Streams-上读取和写入数据，并且公司策略要求此流量不应流向-Internet。如何满足这些要求？"><a href="#54-应用程序在私有子网中的-Amazon-EC2-实例上运行。应用程序需要在-Amazon-Kinesis-Data-Streams-上读取和写入数据，并且公司策略要求此流量不应流向-Internet。如何满足这些要求？" class="headerlink" title="54.应用程序在私有子网中的 Amazon EC2 实例上运行。应用程序需要在 Amazon Kinesis Data Streams 上读取和写入数据，并且公司策略要求此流量不应流向 Internet。如何满足这些要求？"></a>54.应用程序在私有子网中的 Amazon EC2 实例上运行。应用程序需要在 Amazon Kinesis Data Streams 上读取和写入数据，并且公司策略要求此流量不应流向 Internet。如何满足这些要求？</h2><p><strong>A</strong>. Configure a NAT gateway in a public subnet and route all traffic to Amazon Kinesis through the Nat gateway.<br>.在公有子网中配置 NAT 网关，并通过 NAT 网关将所有流量路由到 Amazon Kinesis。</p><p><strong>B</strong>. Configure a Gateway VPC endpoint gateway for Kinesis and route all traffic to Kinesis through the Gateway VPC endpoint.<br>.为 Kinesis 配置网关 VPC 终端节点网关，并通过网关 VPC 终端节点将所有流量路由到 Kinesis。</p><p><strong>C</strong>. Configure an Interface VPC endpoint interface for Kinesis and route all traffic to Kinesis through the Interface VPC endpoint.<br>.为 Kinesis 配置接口 VPC 终端节点接口，并通过接口 VPC 终端节点将所有流量路由到 Kinesis。</p><p><strong>D</strong>. Configure an AWS Direct Connect private virtual interface for Kinesis and route all traffic to Kinesis through the virtual interface.<br>.为 Kinesis 配置 AWS Direct Connect 私有虚拟接口，并通过该虚拟接口将所有流量路由到 Kinesis。</p><p>正确答案是 C，因为接口 VPC 终端节点允许从私有子网中的实例访问 kinesis 数据流，而无需通过 Internet 路由流量，请参阅 AWS 文档 - 具有接口 VPC 终端节点的 AWS Kinesis，您可以使用接口 VPC 终端节点来防止 Amazon VPC 和 Kinesis Data Streams 之间的流量离开 Amazon 网络。接口 VPC 终端节点不需要 Internet 网关、NAT 设备、VPN 连接或 AWS Direct Connect 连接。接口 VPC 终端节点由 AWS PrivateLink 提供支持，这是一种 AWS 技术，可在 AWS 服务之间使用弹性网络接口和 Amazon VPC 中的私有 IP 进行私有通信。</p><h2 id="55-您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态-IP-地址硬编码到后端，这会阻止您使用-ELB-部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择-2-个正确答案"><a href="#55-您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态-IP-地址硬编码到后端，这会阻止您使用-ELB-部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择-2-个正确答案" class="headerlink" title="55.您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态 IP 地址硬编码到后端，这会阻止您使用 ELB 部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择 2 个正确答案"></a>55.您的公司已将旧版应用程序从本地数据中心迁移到云中。旧版应用程序需要将静态 IP 地址硬编码到后端，这会阻止您使用 ELB 部署具有高可用性和容错能力的应用程序。您将采取哪些步骤来将高可用性和容错能力应用于此应用程序？选择 2 个正确答案</h2><p><strong>A</strong>. Do not migrate the application to the cloud until it can be converted to work with the ELB and Auto Scaling<br>.在将应用程序转换为使用 ELB 和 Auto Scaling 之前，请勿将其迁移到云中</p><p><strong>B</strong>. Ensure that the instance it’s using has an elastic IP address assigned to it<br>.确保为其使用的实例分配了弹性 IP 地址</p><p><strong>C</strong>. Write a custom script that pings the health of the instance, and, if the instance stops responding, switches the elastic IP address to a standby instance<br>.编写一个自定义脚本来 ping 实例的运行状况，如果实例停止响应，则将弹性 IP 地址切换到备用实例</p><p><strong>D</strong>. Create an AMI of the instance and launch it using Auto Scaling which will deploy the instance again if it becomes unhealthy<br>.创建实例的 AMI 并使用 Auto Scaling 启动它，如果实例运行状况不佳，它将再次部署实例</p><h2 id="56-解决方案架构师正在构建一个将数据存储到-Amazon-RDS-中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？"><a href="#56-解决方案架构师正在构建一个将数据存储到-Amazon-RDS-中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？" class="headerlink" title="56.解决方案架构师正在构建一个将数据存储到 Amazon RDS 中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？"></a>56.解决方案架构师正在构建一个将数据存储到 Amazon RDS 中的应用程序。特别是一个表的读取量很大，最小延迟至关重要。以下哪项将提供最高级别的性能？</h2><p><strong>A</strong>. Use Amazon DynamoDB Accelerator</p><p><strong>B</strong>. Use Amazon RDS read replicas</p><p><strong>C</strong>. Use Amazon CloudFront<br>.使用 Amazon CloudFront</p><p><strong>D</strong>. Use Amazon ElastiCache</p><p>正确答案是 D，因为 ElastiCache 有助于缓存结果并提供低延迟访问，请参阅 AWS 文档 - ElastiCache 常见问题，问：是否可以将 Amazon ElastiCache for Memcached 与 Amazon RDS 或 Amazon DynamoDB 等 AWS 持久性数据存储一起使用？是的，Amazon ElastiCache 是 Amazon RDS 或 Amazon DynamoDB 等数据存储的理想前端， 为具有极高请求速率和/或低延迟要求的应用程序提供高性能中间层，选项 A 是错误的，因为 DynamoDB Accelerator 仅适用于 DynamoDB，选项 B 是错误的，因为 RDS 只读副本有助于减少主数据库的负载。但是，它不提供低延迟，选项C是错误的，因为CloudFront没有帮助与RDS连接。</p><h2 id="57-您正在运行一个-Web-应用程序，该应用程序在两个可用区中具有四个-Amazon-EC2-实例。这些实例位于-ELB-Classic-Load-Balancer-后面的-Auto-Scaling-组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？"><a href="#57-您正在运行一个-Web-应用程序，该应用程序在两个可用区中具有四个-Amazon-EC2-实例。这些实例位于-ELB-Classic-Load-Balancer-后面的-Auto-Scaling-组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？" class="headerlink" title="57.您正在运行一个 Web 应用程序，该应用程序在两个可用区中具有四个 Amazon EC2 实例。这些实例位于 ELB Classic Load Balancer 后面的 Auto Scaling 组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？"></a>57.您正在运行一个 Web 应用程序，该应用程序在两个可用区中具有四个 Amazon EC2 实例。这些实例位于 ELB Classic Load Balancer 后面的 Auto Scaling 组中。扩展事件将一个实例添加到组中。事件发生后，您会注意到，尽管所有实例都在提供流量，但某些实例提供的流量比其他实例多。以下哪项可能是问题所在？</h2><p><strong>A</strong>. Cross-zone load balancing is not configured on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上未配置跨可用区负载均衡</p><p><strong>B</strong>. Access logs are not enabled on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上未启用访问日志</p><p><strong>C</strong>. A SSL/TLS certificate has not been deployed on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上尚未部署 SSL/TLS 证书</p><p><strong>D</strong>. Sticky bits is not enabled on the ELB Classic Load Balancer<br>.ELB Classic Load Balancer 上未启用粘滞位</p><p>正确答案是 A，因为可能未启用跨区域负载均衡，因此流量会在可用区之间平均分配，而不管该可用区的实例如何。启用跨区域负载均衡后，无论实例位于哪个可用区，流量都会在实例之间平均分配，请参阅 AWS 文档 - ELB 跨区域，如果 Classic Load Balancer 的负载均衡器节点可以分发请求，而不管可用区如何，这称为跨区域负载均衡。启用跨区域负载均衡后，负载均衡器节点会在为负载均衡器启用的可用区之间均匀分配传入请求。否则，每个负载均衡器节点仅将请求分发到其可用区中的实例。例如，如果您在可用区 us-west-2a 中有 10 个实例，在 us-west-2b 中有 2 个实例，则如果启用了跨区域负载均衡，则请求将均匀分布在所有 12 个实例中。否则，us-west-2b 中的 2 个实例处理的请求数与 us-west-2a 中的 10 个实例相同。</p><h2 id="58-您正在-VPC-内部管理一个旧应用程序，其配置中具有硬编码的-IP-地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？"><a href="#58-您正在-VPC-内部管理一个旧应用程序，其配置中具有硬编码的-IP-地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？" class="headerlink" title="58.您正在 VPC 内部管理一个旧应用程序，其配置中具有硬编码的 IP 地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？"></a>58.您正在 VPC 内部管理一个旧应用程序，其配置中具有硬编码的 IP 地址。哪两种机制允许应用程序在无需重新配置的情况下故障转移到新实例？</h2><p><strong>A</strong>. Create an ELB to reroute traffic to a failover instance<br>.创建 ELB 以将流量重新路由到故障转移实例</p><p><strong>B</strong>. Create a secondary ENI that can be moved to a failover instance<br>.创建可移动到故障转移实例的辅助 ENI</p><p><strong>C</strong>. Use Route53 health checks to fail traffic over to a failover instance<br>.使用 Route53 运行状况检查将流量故障转移到故障转移实例</p><p><strong>D</strong>. Assign a secondary private IP address to the primary ENI that can be moved to a failover instance<br>.为可移动到故障转移实例的主 ENI 分配辅助私有 IP 地址</p><p>正确答案是 B &amp; D，因为应用程序是遗留的，需要硬编码的 IP 地址，您可以使用辅助 ENI 或辅助 IP 地址，请参阅 AWS 文档 - 使用 ENI 的 EC2，为确保故障转移功能，请考虑对网络接口上的传入流量使用辅助私有 IPv4。如果实例发生故障，您可以将接口和/或辅助私有 IPv4 地址移动到备用实例，选项 A 和 C 是错误的，因为它们不允许维护固定的硬编码 IP 地址。</p><h2 id="59-一家公司正在使用-Spot-实例来处理其工作负载。他们希望-Spot-实例停止而不是终止，以防-Spot-实例中断。如何配置？选择-2"><a href="#59-一家公司正在使用-Spot-实例来处理其工作负载。他们希望-Spot-实例停止而不是终止，以防-Spot-实例中断。如何配置？选择-2" class="headerlink" title="59.一家公司正在使用 Spot 实例来处理其工作负载。他们希望 Spot 实例停止而不是终止，以防 Spot 实例中断。如何配置？选择 2"></a>59.一家公司正在使用 Spot 实例来处理其工作负载。他们希望 Spot 实例停止而不是终止，以防 Spot 实例中断。如何配置？选择 2</h2><p><strong>A</strong>. Spot instance should have a one-time request type<br>.竞价型实例应具有一次性请求类型</p><p><strong>B</strong>. Spot instance should have a persistent request type<br>.Spot 实例应具有持久性请求类型</p><p><strong>C</strong>. Use EBS volume with the Spot instances<br>.将 EBS 卷与 Spot 实例结合使用</p><p><strong>D</strong>. Use Instance store volume with the Spot instances<br>.将实例存储卷与 Spot 实例结合使用</p><p><strong>E</strong>. Specify it in the launch configuration<br>.在启动配置中指定它</p><p>正确答案是 B 和 C，因为 Spot 实例定义了持久性请求类型，而 EBS 支持的实例允许它们停止和启动，请参阅 AWS 文档 - 启动停止 Spot 实例，Amazon EC2 Spot 现在允许在中断时停止 Amazon EBS 支持的实例，而不是在容量不再以您首选的价格可用时终止。然后，当容量在您的价格和时间要求范围内可用时，Spot 可以通过从停止状态重新启动实例来满足您的请求。要使用此新功能，请在提交持久性 Spot 请求时选择“停止”而不是“终止”作为中断行为。当您选择“停止”时，Spot 将在中断时关闭您的实例。将保存 EBS 根设备和附加的 EBS 卷，并保留其数据。当容量在您的价格和时间要求范围内再次可用时，Spot 将重新启动您的实例。重新启动后，EBS 根设备将从其先前的状态恢复，之前附加的数据卷将重新附加，并且实例将保留其实例 ID。</p><h2 id="60-您有一个在-us-west-2-中运行的应用程序，该应用程序需要始终运行-6-个-Amazon-Elastic-Compute-Cloud-（EC2）-实例。该区域有三个可用区（us-west-2a、us-west-2b-和-us-west-2c），如果-us-west-2-中的任何单个可用区不可用，以下哪个部署可提供-100-的容错能力？选择-2-个答案"><a href="#60-您有一个在-us-west-2-中运行的应用程序，该应用程序需要始终运行-6-个-Amazon-Elastic-Compute-Cloud-（EC2）-实例。该区域有三个可用区（us-west-2a、us-west-2b-和-us-west-2c），如果-us-west-2-中的任何单个可用区不可用，以下哪个部署可提供-100-的容错能力？选择-2-个答案" class="headerlink" title="60.您有一个在 us-west-2 中运行的应用程序，该应用程序需要始终运行 6 个 Amazon Elastic Compute Cloud （EC2） 实例。该区域有三个可用区（us-west-2a、us-west-2b 和 us-west-2c），如果 us-west-2 中的任何单个可用区不可用，以下哪个部署可提供 100% 的容错能力？选择 2 个答案"></a>60.您有一个在 us-west-2 中运行的应用程序，该应用程序需要始终运行 6 个 Amazon Elastic Compute Cloud （EC2） 实例。该区域有三个可用区（us-west-2a、us-west-2b 和 us-west-2c），如果 us-west-2 中的任何单个可用区不可用，以下哪个部署可提供 100% 的容错能力？选择 2 个答案</h2><p><strong>A</strong>. Us-west-2a with two EC2 instances, us-west-2b with two EC2 instances, and us-west-2c with two EC2 instances<br>.us-west-2a 具有两个 EC2 实例，us-west-2b 具有两个 EC2 实例，us-west-2c 具有两个 EC2 实例</p><p><strong>B</strong>. Us-west-2a with three EC2 instances, us-west-2b with three EC2 instances, and us-west-2c with no EC2 instances<br>.us-west-2a 具有三个 EC2 实例，us-west-2b 具有三个 EC2 实例，us-west-2c 具有三个 EC2 实例</p><p><strong>C</strong>. Us-west-2a with four EC2 instances, us-west-2b with two EC2 instances, and us-west-2c with two EC2 instances<br>.us-west-2a 具有 4 个 EC2 实例，us-west-2b 具有 2 个 EC2 实例，us-west-2c 具有 2 个 EC2 实例</p><p><strong>D</strong>. Us-west-2a with six EC2 instances, us-west-2b with six EC2 instances, and us-west-2c with no EC2 instances<br>.us-west-2a 具有 6 个 EC2 实例，us-west-2b 具有 6 个 EC2 实例，us-west-2c 没有 EC2 实例</p><p><strong>E</strong>. Us-west-2a with three EC2 instances, us-west-2b with three EC2 instances, and us-west-2c with three EC2 instances<br>.us-west-2a 具有三个 EC2 实例，us-west-2b 具有三个 EC2 实例，us-west-2c 具有三个 EC2 实例</p><p>正确答案是 D 和 E，因为即使 AZ 宕机，也会有 6 个实例始终运行提供容错能力，选项 A 是错误的，如果 AZ 宕机，只有 4 个实例可用，选项 B 是错误的，因为如果 AZ 宕机，只有 3 个实例可用，选项 C 是错误的，因为如果 Us-west-2a AZ 宕机，只有 4 个实例可用</p><h2 id="61-解决方案架构师计划将-NAT-实例迁移到-NAT-网关。架构师具有带有脚本的-NAT-实例来管理高可用性。使用-NAT-网关实现类似高可用性的最有效方法是什么？"><a href="#61-解决方案架构师计划将-NAT-实例迁移到-NAT-网关。架构师具有带有脚本的-NAT-实例来管理高可用性。使用-NAT-网关实现类似高可用性的最有效方法是什么？" class="headerlink" title="61.解决方案架构师计划将 NAT 实例迁移到 NAT 网关。架构师具有带有脚本的 NAT 实例来管理高可用性。使用 NAT 网关实现类似高可用性的最有效方法是什么？"></a>61.解决方案架构师计划将 NAT 实例迁移到 NAT 网关。架构师具有带有脚本的 NAT 实例来管理高可用性。使用 NAT 网关实现类似高可用性的最有效方法是什么？</h2><p><strong>A</strong>. Remove source/destination check on NAT instances.<br>.删除 NAT 实例上的源/目标检查。</p><p><strong>B</strong>. Launch a NAT Gateway in each Availability Zone<br>.在每个可用区中启动 NAT 网关</p><p><strong>C</strong>. Use a mix of NAT instances and NAT gateway<br>.混合使用 NAT 实例和 NAT 网关</p><p><strong>D</strong>. Add an ELB Application Load Balancer in front of NAT gateway<br>.在NAT网关前添加ELB Application Load Balancer</p><p>正确答案是 B，因为 NAT 网关是按可用区启动的，并且应该在每个可用区中启动以确保高可用性，请参阅 AWS 文档 - NAT 网关，如果您在多个可用区中有资源，并且它们共享一个 NAT 网关，则在 NAT 网关的可用区关闭时，其他可用区中的资源将失去 Internet 访问权限。要创建独立于可用区的架构，请在每个可用区中创建一个 NAT 网关并配置路由以确保资源使用同一可用区中的 NAT 网关，选项 A 是错误的，因为删除源/目标不会将流量路由回原始实例，选项 C 是错误的，因为 NAT 实例和 NAT 网关的混合不提供高可用性。选项 D 是错误的，因为 ELB 用于负载均衡，而不是高可用性。</p><h2 id="62-在公有子网中启动要用作-NAT（网络地址转换）设备的实例后，您可以修改路由表，使-NAT-设备成为私有子网的-Internet-绑定流量的目标。当您尝试从私有子网中的实例到-Internet-建立出站连接时，您不会成功。以下哪项步骤可以解决问题？"><a href="#62-在公有子网中启动要用作-NAT（网络地址转换）设备的实例后，您可以修改路由表，使-NAT-设备成为私有子网的-Internet-绑定流量的目标。当您尝试从私有子网中的实例到-Internet-建立出站连接时，您不会成功。以下哪项步骤可以解决问题？" class="headerlink" title="62.在公有子网中启动要用作 NAT（网络地址转换）设备的实例后，您可以修改路由表，使 NAT 设备成为私有子网的 Internet 绑定流量的目标。当您尝试从私有子网中的实例到 Internet 建立出站连接时，您不会成功。以下哪项步骤可以解决问题？"></a>62.在公有子网中启动要用作 NAT（网络地址转换）设备的实例后，您可以修改路由表，使 NAT 设备成为私有子网的 Internet 绑定流量的目标。当您尝试从私有子网中的实例到 Internet 建立出站连接时，您不会成功。以下哪项步骤可以解决问题？</h2><p><strong>A</strong>. Attaching a second Elastic Network interface (ENI) to the NAT instance, and placing it in the private subnet<br>.将第二个弹性网络接口 （ENI） 附加到 NAT 实例，并将其放置在私有子网中</p><p><strong>B</strong>. Attaching an Elastic IP address to the instance in the private subnet<br>.将弹性 IP 地址附加到私有子网中的实例</p><p><strong>C</strong>. Attaching a second Elastic Network Interface (ENI) to the instance in the private subnet, and placing it in the public subnet<br>.将第二个弹性网络接口 （ENI） 附加到私有子网中的实例，并将其放置在公有子网中</p><p><strong>D</strong>. Disabling the Source/Destination Check attribute on the NAT instance<br>.禁用 NAT 实例上的 Source/Destination Check 属性</p><p>正确答案是 D，因为 NAT 上的源/目标检查属性必须禁用。EIP 和 ENI 与通过 NAT 路由流量无关，请参阅 AWS 文档 - VPC NAT，默认情况下每个 EC2 实例执行源/目标检查。这意味着实例必须是它发送或接收的任何流量的源或目标。但是，当源或目标不是其本身时，NAT 实例必须能够发送和接收流量。因此，您必须在 NAT 实例上禁用源/目标检查。</p><h2 id="63-管理员在-AWS-中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合-POSIX-标准。哪个-AWS-服务可以执行此操作？"><a href="#63-管理员在-AWS-中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合-POSIX-标准。哪个-AWS-服务可以执行此操作？" class="headerlink" title="63.管理员在 AWS 中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合 POSIX 标准。哪个 AWS 服务可以执行此操作？"></a>63.管理员在 AWS 中运行高度可用的应用程序。需要一个文件存储层，可以在实例之间共享并更轻松地扩展平台。存储也应符合 POSIX 标准。哪个 AWS 服务可以执行此操作？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon EC2 Instance store</p><p>正确答案是 C，因为 EFS 提供了创建符合 POSIX 的共享存储的能力，请参阅 AWS 文档 - EFS，Amazon EFS 提供符合 POSIX 的弹性共享文件存储。您创建的文件系统支持来自多个 Amazon EC2 实例的并发读写访问，并且可以从创建它的 AWS 区域中的所有可用区访问，选项 A 和 D 是错误的，因为实例和 EBS 卷无法共享，选项 B 是错误的，因为 S3 不符合 POSIX 标准</p><h2 id="64-一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在-Amazon-EC2-实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种-AWS-服务来存储数据并满足这些要求？"><a href="#64-一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在-Amazon-EC2-实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种-AWS-服务来存储数据并满足这些要求？" class="headerlink" title="64.一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在 Amazon EC2 实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种 AWS 服务来存储数据并满足这些要求？"></a>64.一位解决方案架构师正在设计一种解决方案，以每分钟监控天气变化。前端应用程序托管在 Amazon EC2 实例上。后端必须可扩展到无限大小，并且数据检索必须以最小的延迟进行。架构师应使用哪种 AWS 服务来存储数据并满足这些要求？</h2><p><strong>A</strong>. Amazon S3</p><p><strong>B</strong>. Amazon DynamoDB</p><p><strong>C</strong>. Amazon RDS</p><p><strong>D</strong>. Amazon EBS</p><p>正确答案是 B，因为 DynamoDB 提供了扩展到无限大小的能力，同时以最小的延迟提供对数据的访问，请参阅 AWS 文档 - DynamoDB，Amazon DynamoDB 是一种完全托管的 NoSQL 数据库服务，可提供快速且可预测的性能以及无缝的可扩展性。借助 DynamoDB，您可以减轻操作和扩展分布式数据库的管理负担，这样您就不必担心硬件预置、设置和配置、复制、软件修补或集群扩展，选项 A 是错误的，因为与 DynamoDB 相比，S3 延迟会更长，选项 C 是错误的，因为 RDS 不会扩展到无限大小，并且与 DynamoDB 相比延迟会更多，选项 D 是错误的，因为与 DynamoDB 相比，EBS 无法扩展到无限大小，并且延迟会更多</p><h2 id="您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的-IP-地址。如何将高可用性应用于运行该应用程序的实例？"><a href="#您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的-IP-地址。如何将高可用性应用于运行该应用程序的实例？" class="headerlink" title="您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的 IP 地址。如何将高可用性应用于运行该应用程序的实例？"></a>您正在运行一个旧版应用程序，该应用程序在应用程序中具有硬编码的 IP 地址。如何将高可用性应用于运行该应用程序的实例？</h2><p><strong>A</strong>. Assign a public IP address to the EC2 instance, have a backup instance running. In the event of failure, move the Public IP from the primary instance to the backup instance.<br>.为 EC2 实例分配公有 IP 地址，运行备份实例。如果发生故障，请将公网 IP 从主实例移动到备份实例。</p><p><strong>B</strong>. Assign an elastic IP address to the EC2 instance, have a backup instance running. In the event of failure, move the Elastic IP from the primary instance to the backup instance.<br>.为 EC2 实例分配弹性 IP 地址，运行备份实例。如果发生故障，请将弹性 IP 从主实例移动到备份实例。</p><p><strong>C</strong>. Use ELB for load balancing and assign the IP address and use auto scaling to manage load<br>.使用 ELB 进行负载均衡并分配 IP 地址并使用弹性伸缩来管理负载</p><p><strong>D</strong>. EC2 instance cannot be configured with hardcoded IP address<br>.无法使用硬编码的 IP 地址配置 EC2 实例</p><p>正确答案是 B，因为您可以拥有固定的静态弹性 IP 地址并分配给 EC2 实例。如果 EC2 实例发生故障，则生成一个新实例并将弹性 IP 地址分配给新实例，请参阅 AWS 文档 - Fault Tolerance 和 HA 架构，弹性 IP 地址是公有 IP 地址，可以在区域内的实例之间以编程方式映射。它们与 AWS 账户关联，而不是与特定实例或实例的生命周期关联。弹性 IP 地址可用于解决主机或可用区故障，方法是将地址快速重新映射到另一个正在运行的实例或刚刚启动的替换实例。预留实例可以帮助保证此类容量在另一个区域中可用，选项 A 是错误的，因为公有 IP 地址不是静态的，如果实例重新启动或停止并启动，选项 C 是错误的，因为无法为 ELB 分配固定 IP 地址，选项 D 是错误的，因为可以为 EC2 实例分配弹性 IP 地址。</p><h2 id="67-一位解决方案架构师正在-Amazon-VPC-中规划一个新的-Web-应用程序。客户已指定新-Web-应用程序的体系结构必须包括在高度可用的-Web-服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该"><a href="#67-一位解决方案架构师正在-Amazon-VPC-中规划一个新的-Web-应用程序。客户已指定新-Web-应用程序的体系结构必须包括在高度可用的-Web-服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该" class="headerlink" title="67.一位解决方案架构师正在 Amazon VPC 中规划一个新的 Web 应用程序。客户已指定新 Web 应用程序的体系结构必须包括在高度可用的 Web 服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该"></a>67.一位解决方案架构师正在 Amazon VPC 中规划一个新的 Web 应用程序。客户已指定新 Web 应用程序的体系结构必须包括在高度可用的 Web 服务器组之间共享会话状态的功能。为了满足这一要求，解决方案架构师应该</h2><p><strong>A</strong>. Deliver session state as messages in the Amazon SQS queue.<br>.将会话状态作为消息传送到 Amazon SQS 队列中。</p><p><strong>B</strong>. Enable session state on Amazon CloudFront.<br>.在 Amazon CloudFront 上启用会话状态。</p><p><strong>C</strong>. Store session state in Amazon ElastiCache</p><p><strong>D</strong>. Provide session state through Elastic Load Balancing sticky sessions<br>.通过 Elastic Load Balancing 粘性会话提供会话状态</p><p>正确答案是 C，因为 ElasticCache 可以帮助存储会话信息，这些信息可以在多个实例之间共享。这有助于在不内部维护状态的情况下设计应用程序，请参阅 AWS 文档 - ElastiCache 常见问题，问：使用 Amazon ElastiCache for Memcached 可以缓存哪些内容？，您可以使用该服务缓存各种对象，从持久性数据存储（例如 Amazon RDS、DynamoDB 或 EC2 上托管的自我管理数据库）中的内容到动态生成的网页（例如使用 Nginx）， 或可能不需要持久性后备存储的瞬态会话数据。您还可以使用它来实现高频计数器，以在大容量 Web 应用程序中部署准入控制，选项 A 和 B 是错误的，因为 CloudFront 和 SQS 不适合状态存储，选项 D 是错误的，因为 Elastic Load Balancing 粘性会话限制了高可用性 Web 服务器的使用，因为状态与单个实例相关联，而不是外部维护。</p><h2 id="68-解决方案架构师在-Amazon-VPC-中运行了一个多层应用程序。该应用程序具有一个-ELB-Classic-Load-Balancer-作为公有子网中的前端，以及一个基于-Amazon-EC2-的预留代理，该代理执行到私有子网中托管的两个后端-Amazon-EC2-实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）"><a href="#68-解决方案架构师在-Amazon-VPC-中运行了一个多层应用程序。该应用程序具有一个-ELB-Classic-Load-Balancer-作为公有子网中的前端，以及一个基于-Amazon-EC2-的预留代理，该代理执行到私有子网中托管的两个后端-Amazon-EC2-实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）" class="headerlink" title="68.解决方案架构师在 Amazon VPC 中运行了一个多层应用程序。该应用程序具有一个 ELB Classic Load Balancer 作为公有子网中的前端，以及一个基于 Amazon EC2 的预留代理，该代理执行到私有子网中托管的两个后端 Amazon EC2 实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）"></a>68.解决方案架构师在 Amazon VPC 中运行了一个多层应用程序。该应用程序具有一个 ELB Classic Load Balancer 作为公有子网中的前端，以及一个基于 Amazon EC2 的预留代理，该代理执行到私有子网中托管的两个后端 Amazon EC2 实例的基于内容的路由。架构师看到了巨大的流量增长，并担心备用代理和当前的后端设置将不足。架构师应该采取哪些措施来实现经济高效的解决方案，确保应用程序自动扩展以满足流量需求？（选择两个）</h2><p><strong>A</strong>. Replace the Amazon EC2 reserve proxy with an ELB internal Classic Load Balancer<br>.将 Amazon EC2 预留代理替换为 ELB 内部 Classic Load Balancer</p><p><strong>B</strong>. Add Auto Scaling to the Amazon EC2 backend fleet.<br>.将 Auto Scaling 添加到 Amazon EC2 后端队列。</p><p><strong>C</strong>. Add Auto Scaling to the Amazon EC2 reserve proxy layer.<br>.将 Auto Scaling 添加到 Amazon EC2 预留代理层。</p><p><strong>D</strong>. Use t2 burstable instance types for the backend fleet.<br>.将 t2 可突增实例类型用于后端队列。</p><p><strong>E</strong>. Replace both the frontend and reserve proxy layers with an ELB Application Load Balancer.<br>.将前端和预留代理层替换为 ELB Application Load Balancer。</p><p>正确答案是 B &amp; E，因为 AWS ALB 可以执行基于内容的路由，并可用于替换反向代理层。ALB 还由 AWS 托管，具有高度可用性和可扩展性。后端队列可以与 Auto Scaling 相关联以根据需求进行扩展，选项 A 是错误的，因为经典 ELB 不提供基于内容的路由功能，选项 C 是错误的，因为与 ALB 相比，Auto Scaling 不是一个经济高效的解决方案，选项 D 是错误的，因为 t2 可突增不提供可扩展性，但能够在有限的时间内突增到基线以上。</p><h2 id="69-解决方案架构师需要为在-Amazon-EC2-实例上运行的一组-Web-应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？"><a href="#69-解决方案架构师需要为在-Amazon-EC2-实例上运行的一组-Web-应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？" class="headerlink" title="69.解决方案架构师需要为在 Amazon EC2 实例上运行的一组 Web 应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？"></a>69.解决方案架构师需要为在 Amazon EC2 实例上运行的一组 Web 应用程序设计一个集中式日志记录解决方案。由于预算限制，该解决方案需要最少的开发工作。架构师应该推荐以下哪一项？</h2><p><strong>A</strong>. Create a crontab job script in each instance to push the logs regularly to Amazon S3<br>.在每个实例中创建一个 crontab 任务脚本，以定期将日志推送到 Amazon S3</p><p><strong>B</strong>. Install and configure Amazon CloudWatch Logs agent in the Amazon EC2<br>.在 Amazon EC2 中安装和配置 Amazon CloudWatch Logs 代理</p><p><strong>C</strong>. Enable Amazon CloudWatch Events in the AWS Management Console.<br>.在 AWS 管理控制台中启用 Amazon CloudWatch Events。</p><p><strong>D</strong>. Enable AWS CloudTrail to map all API calls invoked by the application<br>.启用 AWS CloudTrail 以映射应用程序调用的所有 API 调用</p><p>正确答案是 B，因为 CloudWatch Logs 代理可以自动将日志发送到 CloudWatch，请参阅 AWS 文档 - CloudWatch Logs 代理，CloudWatch Logs 代理提供了一种将日志数据从 Amazon EC2 实例发送到 CloudWatch Logs 的自动化方法。代理由以下组件组成：，您可以在现有 EC2 实例上使用 CloudWatch Logs 代理安装程序来安装和配置 CloudWatch Logs 代理。安装完成后，日志会自动从实例流向您在安装代理时创建的日志流。代理确认它已启动并保持运行状态，直到您禁用它，除了使用代理之外，您还可以使用 AWS CLI、CloudWatch Logs 开发工具包或 CloudWatch Logs API 发布日志数据。AWS CLI 最适合在命令行或通过脚本发布数据。CloudWatch Logs 开发工具包最适合直接从应用程序发布日志数据或构建您自己的日志发布应用程序，选项 A 是错误的，因为这需要开发工作，选项 C 是错误的，因为 Events 提供近乎实时的系统事件流，这些事件描述了 Amazon Web Services （AWS） 资源中的更改。它无助于捕获应用程序日志，选项 D 是错误的，因为 CloudTrail 仅适用于审计日志。它不处理应用程序日志。</p><h2 id="70-您有一个在-Amazon-EC2-上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的-Amazon-EC2-实例以最经济高效的方式减少积压？"><a href="#70-您有一个在-Amazon-EC2-上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的-Amazon-EC2-实例以最经济高效的方式减少积压？" class="headerlink" title="70.您有一个在 Amazon EC2 上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的 Amazon EC2 实例以最经济高效的方式减少积压？"></a>70.您有一个在 Amazon EC2 上运行的视频转码应用程序。每个实例轮询一个队列，以找出应转码的视频，然后运行转码过程。如果此过程中断，视频将由另一个基于排队系统的实例进行转码。您有大量积压的视频需要转码，并希望通过添加更多实例来减少此积压。只有在积压工作减少之前，才需要这些实例。您应该使用哪种类型的 Amazon EC2 实例以最经济高效的方式减少积压？</h2><p><strong>A</strong>. Reserved instances .预留实例</p><p><strong>B</strong>. Spot instances .竞价型实例</p><p><strong>C</strong>. Dedicated instances .独享实例</p><p><strong>D</strong>. On-demand instances .按需实例</p><p>这里的关键点是以最具成本效益的方式实现解决方案，如果这个过程被中断，视频将被另一个基于排队系统的实例转码，正确答案是B，因为Spot实例可以以最具成本效益的方式处理负载，并且Spot实例可以突然终止的情况已经处理好了。</p><h2 id="71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？"><a href="#71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？" class="headerlink" title="71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？"></a>71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon DynamoDB</p><h2 id="71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？-1"><a href="#71-您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些-AWS-服务可以满足所有这些要求？-1" class="headerlink" title="71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？"></a>71.您被要求为用户的主目录构建一个生命系统。解决方案必须可供组织中的个人同时访问。用户和组必须具有在文件或目录级别定义的权限。哪些 AWS 服务可以满足所有这些要求？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon DynamoDB</p><p>正确答案是 C，因为 EFS 是创建用户主目录的理想解决方案，并且可以跨组织的个人访问，并能够对其进行配置，请参阅 AWS EFS 常见问题和创建可写的每用户目录，问。Amazon EFS 适用于哪些使用案例？，Amazon EFS 旨在为各种工作负载和应用程序提供性能，包括大数据和分析、媒体处理工作流、内容管理、Web 服务和主目录。</p><h2 id="72-一家公司在其-200-GB-数据仓库上有两种不同类型的换盆需求-–-数据科学家运行少量并发临时-SQL-查询，每个查询可能需要几分钟才能运行。–-整个公司的显示屏运行许多快速-SQL-查询来填充仪表板，哪种设计能以最低的成本满足这些要求？"><a href="#72-一家公司在其-200-GB-数据仓库上有两种不同类型的换盆需求-–-数据科学家运行少量并发临时-SQL-查询，每个查询可能需要几分钟才能运行。–-整个公司的显示屏运行许多快速-SQL-查询来填充仪表板，哪种设计能以最低的成本满足这些要求？" class="headerlink" title="72.一家公司在其 200 GB 数据仓库上有两种不同类型的换盆需求;– 数据科学家运行少量并发临时 SQL 查询，每个查询可能需要几分钟才能运行。– 整个公司的显示屏运行许多快速 SQL 查询来填充仪表板，哪种设计能以最低的成本满足这些要求？"></a>72.一家公司在其 200 GB 数据仓库上有两种不同类型的换盆需求;– 数据科学家运行少量并发临时 SQL 查询，每个查询可能需要几分钟才能运行。– 整个公司的显示屏运行许多快速 SQL 查询来填充仪表板，哪种设计能以最低的成本满足这些要求？</h2><p><strong>A</strong>. Replicate relevant data between Amazon Redshift and Amazon DynamoDB. Data scientists use Redshift. Dashboards use DynamoDB<br>.在 Amazon Redshift 和 Amazon DynamoDB 之间复制相关数据。数据科学家使用 Redshift。控制面板使用 DynamoDB</p><p><strong>B</strong>. Configure auto-replication between Amazon Redshift and Amazon RDS. Data scientists use Redshift and Dashboards use RDS<br>.配置 Amazon Redshift 和 Amazon RDS 之间的自动复制。数据科学家使用 Redshift，控制面板使用 RDS</p><p><strong>C</strong>. Use Amazon Redshift for both requirements, with separate query queues configured in workload management.<br>.使用 Amazon Redshift 满足这两个要求，并在工作负载管理中配置单独的查询队列。</p><p><strong>D</strong>. Use Amazon Redshift for Data Scientists; Run automated dashboard queries against Redshift and store the results in Amazon ElastiCache, Dashboards query ElastiCache.<br>.将 Amazon Redshift 用于数据科学家;对 Redshift 运行自动控制面板查询并将结果存储在 Amazon ElastiCache 中，控制面板查询 ElastiCache。</p><p>正确答案是 C，因为 Redshift 提供工作负载管理，可以帮助确定交互式和长时间运行的作业的优先级。将数据存储在单个存储服务中也有助于将成本降至最低，请参阅 AWS 文档 - Redshift 的混合工作负载，混合工作负载同时运行批处理和交互式工作负载（短期运行和长时间运行的查询或报告）以支持业务需求或需求。通常，管理和配置混合工作负载需要对访问模式、系统资源的使用方式和性能要求有透彻的了解，混合工作负载通常具有某些进程比其他进程需要更高的优先级。有时，这意味着必须在给定的 SLA 内完成某项工作。其他时候，这意味着您只想防止非关键报告工作负载在任何时候消耗过多的集群资源，如果没有工作负载管理 （WLM），每个查询的优先级都相同，这可能会导致个人、团队或工作负载消耗过多的集群资源，而这些资源不如其他更关键的业务关键型作业有价值。您可以使用 WLM 来定义业务关注点的分离，并确定系统中不同类型的并发运行查询的优先级：选项 A 和 B 是错误的，因为它会导致数据重复，并且 2 个服务的成本不会很小，选项 D 是错误的，因为 ElastiCache 不会提供最新数据。</p><h2 id="73-使用以下-AWS-服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择-2-个答案"><a href="#73-使用以下-AWS-服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择-2-个答案" class="headerlink" title="73.使用以下 AWS 服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择 2 个答案"></a>73.使用以下 AWS 服务时，哪些服务应在多个可用区中实施以实现高可用性解决方案？选择 2 个答案</h2><p><strong>A</strong>. Amazon DynamoDB</p><p><strong>B</strong>. Amazon Elastic Compute Cloud (EC2)</p><p><strong>C</strong>. Amazon Elastic Load Balancing</p><p><strong>D</strong>. Amazon Simple Notification Service (SNS)</p><p><strong>E</strong>. Amazon Simple Storage Service (S3)</p><p>正确答案是 B 和 C，因为 ELB 可用于通过跨多个可用区跨多个 EC2 实例路由流量来提供高可用性，Elastic Load Balancing 会自动在多可用区的多个 Amazon EC2 实例之间分配传入的应用程序流量。它使您能够在应用程序中实现容错能力，无缝地提供路由应用程序流量所需的负载均衡容量，选项 A、D 和 E 是错误的，因为它们都是 AWS 托管服务，并且本身具有可扩展性和 HA。</p><h2 id="74-一家公司正计划在-AWS-中部署应用程序。此应用程序需要-EC2-实例才能持续执行日志处理活动，这些活动需要大约-500MiB-s-的数据吞吐量。以下哪项是满足此要求的最佳存储选项？"><a href="#74-一家公司正计划在-AWS-中部署应用程序。此应用程序需要-EC2-实例才能持续执行日志处理活动，这些活动需要大约-500MiB-s-的数据吞吐量。以下哪项是满足此要求的最佳存储选项？" class="headerlink" title="74.一家公司正计划在 AWS 中部署应用程序。此应用程序需要 EC2 实例才能持续执行日志处理活动，这些活动需要大约 500MiB/s 的数据吞吐量。以下哪项是满足此要求的最佳存储选项？"></a>74.一家公司正计划在 AWS 中部署应用程序。此应用程序需要 EC2 实例才能持续执行日志处理活动，这些活动需要大约 500MiB/s 的数据吞吐量。以下哪项是满足此要求的最佳存储选项？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS Throughput Optimized HDD</p><p><strong>C</strong>. EBS General Purpose SSD</p><p><strong>D</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p>正确答案是 B，因为吞吐量优化型 HDD 最适合通常涉及大数据、ETL 作业和日志处理的大型顺序 I/O 工作负载，请参阅 AWS 文档 - EBS 卷类型，吞吐量优化型 HDD （st1） 卷提供低成本的磁性存储，根据吞吐量而不是 IOPS 来定义性能。此卷类型非常适合大型顺序工作负载，例如 Amazon EMR、ETL、数据仓库和日志处理。不支持可启动的 st1 卷，吞吐量优化的 HDD （st1） 卷虽然类似于 Cold HDD （sc1） 卷，但旨在支持频繁访问的数据，此卷类型针对涉及大型顺序 I/O 的工作负载进行了优化，我们建议工作负载执行小型随机 I/O 的客户使用 gp2，较大的卷会线性扩展这些限制， 吞吐量上限为 500 MiB/s。</p><h2 id="75-您正在为客户设置-VPN，以将其远程网络连接到其-Amazon-VPC-环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下：-可预测的网络性能-支持-BGP-对等互连和路由策略-安全的-IPsec-VPN-连接，但不能通过-Internet-以下哪个-VPN-选项最能满足客户的要求？从以下选项中选择正确答案"><a href="#75-您正在为客户设置-VPN，以将其远程网络连接到其-Amazon-VPC-环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下：-可预测的网络性能-支持-BGP-对等互连和路由策略-安全的-IPsec-VPN-连接，但不能通过-Internet-以下哪个-VPN-选项最能满足客户的要求？从以下选项中选择正确答案" class="headerlink" title="75.您正在为客户设置 VPN，以将其远程网络连接到其 Amazon VPC 环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下： - 可预测的网络性能 - 支持 BGP 对等互连和路由策略 - 安全的 IPsec VPN 连接，但不能通过 Internet 以下哪个 VPN 选项最能满足客户的要求？从以下选项中选择正确答案"></a>75.您正在为客户设置 VPN，以将其远程网络连接到其 Amazon VPC 环境。有许多方法可以实现此目的，并帮助您确定您已获得客户指定网络需要能够执行的操作的列表。它们如下： - 可预测的网络性能 - 支持 BGP 对等互连和路由策略 - 安全的 IPsec VPN 连接，但不能通过 Internet 以下哪个 VPN 选项最能满足客户的要求？从以下选项中选择正确答案</h2><p><strong>A</strong>. Software appliance-based VPN connection with IPsec<br>.基于 IPsec 的基于软件设备的 VPN 连接</p><p><strong>B</strong>. AWS Direct Connect and IPsec Hardware VPN connection over private lines<br>.通过专线的 AWS Direct Connect 和 IPsec 硬件 VPN 连接</p><p><strong>C</strong>. AWS Direct Correct with AWS VPN CloudHub<br>.AWS Direct 使用 AWS VPN CloudHub 进行校正</p><p><strong>D</strong>. AWS VPN CloudHub<br>.AWS VPN 云中心</p><p>正确答案是B，因为使用Direct Connect将提供可预测的网络性能并支持BGP对等互连和路由策略，而VPN将提供安全的IPsec VPN连接，但不能通过Internet，请参阅AWS文档 - VPC VPN连接，选项A是错误的，因为流量仍然通过Internet路由，选项C和D是错误的，因为CloudHub有助于多个远程站点之间的通信</p><h2 id="76-照片共享服务将图片存储在-Amazon-Simple-Storage-Service-（S3）-中，并允许使用与-OpenID-Connect-兼容的身份提供商登录应用程序。对于-Amazon-S3-操作，您应该使用哪种-AWS-Security-Token-Service-临时访问方法？"><a href="#76-照片共享服务将图片存储在-Amazon-Simple-Storage-Service-（S3）-中，并允许使用与-OpenID-Connect-兼容的身份提供商登录应用程序。对于-Amazon-S3-操作，您应该使用哪种-AWS-Security-Token-Service-临时访问方法？" class="headerlink" title="76.照片共享服务将图片存储在 Amazon Simple Storage Service （S3） 中，并允许使用与 OpenID Connect 兼容的身份提供商登录应用程序。对于 Amazon S3 操作，您应该使用哪种 AWS Security Token Service 临时访问方法？"></a>76.照片共享服务将图片存储在 Amazon Simple Storage Service （S3） 中，并允许使用与 OpenID Connect 兼容的身份提供商登录应用程序。对于 Amazon S3 操作，您应该使用哪种 AWS Security Token Service 临时访问方法？</h2><p><strong>A</strong>. SAML-based Identity Federation</p><p><strong>B</strong>. Cross-Account Access</p><p><strong>C</strong>. AWS IAM users</p><p><strong>D</strong>. Web Identity Federation</p><p>正确答案是 D，请参阅 AWS 文档 - IAM Web 联合身份验证，使用 Web 联合身份验证，您无需创建自定义登录代码或管理自己的用户身份。相反，您的应用程序的用户可以使用知名身份提供商 （IdP）（例如 Login with Amazon、Facebook、Google 或任何其他与 OpenID Connect （OIDC） 兼容的 IdP）登录，接收身份验证令牌，然后将该令牌交换为 AWS 中的临时安全凭证，这些凭证映射到有权使用您 AWS 账户中的资源的 IAM 角色。使用 IdP 可帮助您确保 AWS 账户的安全，因为您不必在应用程序中嵌入和分发长期安全凭证，选项 A 是错误的，因为 SAML 主要用于符合 SAML 标准的身份提供商，选项 B 是错误的，因为跨账户访问是提供对其他 AWS 账户的访问权限，选项 C 是错误的，因为 IAM 用户是向实际用户授予访问权限</p><h2 id="77-您的任务是在-AWS-中构建应用程序。该架构将由-EC2、Classic-Load-Balancer、Auto-Scaling-和-Route-53-组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在-Route-53-中，您最好使用哪种路由策略来实现蓝绿部署？"><a href="#77-您的任务是在-AWS-中构建应用程序。该架构将由-EC2、Classic-Load-Balancer、Auto-Scaling-和-Route-53-组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在-Route-53-中，您最好使用哪种路由策略来实现蓝绿部署？" class="headerlink" title="77.您的任务是在 AWS 中构建应用程序。该架构将由 EC2、Classic Load Balancer、Auto Scaling 和 Route 53 组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在 Route 53 中，您最好使用哪种路由策略来实现蓝绿部署？"></a>77.您的任务是在 AWS 中构建应用程序。该架构将由 EC2、Classic Load Balancer、Auto Scaling 和 Route 53 组成。有一个指令可以确保在此体系结构中可以进行蓝绿部署。在 Route 53 中，您最好使用哪种路由策略来实现蓝绿部署？</h2><p><strong>A</strong>. Simple</p><p><strong>B</strong>. Multi-answer</p><p><strong>C</strong>. Latency</p><p><strong>D</strong>. Weighted .加权</p><p>正确答案是 D，因为加权路由策略有助于在不同环境中以受控方式分配流量。测试后即可进行切换，请参阅AWS蓝绿部署白皮书和路由策略</p><h2 id="78-工作负载包括从-Amazon-S3-存储桶下载映像、处理映像并将其移动到另一个-Amazon-S3-存储桶。Amazon-EC2-实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？"><a href="#78-工作负载包括从-Amazon-S3-存储桶下载映像、处理映像并将其移动到另一个-Amazon-S3-存储桶。Amazon-EC2-实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？" class="headerlink" title="78.工作负载包括从 Amazon S3 存储桶下载映像、处理映像并将其移动到另一个 Amazon S3 存储桶。Amazon EC2 实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？"></a>78.工作负载包括从 Amazon S3 存储桶下载映像、处理映像并将其移动到另一个 Amazon S3 存储桶。Amazon EC2 实例每小时运行一次计划任务来执行该操作。解决方案架构师应如何重新设计流程，使其具有高可用性？</h2><p><strong>A</strong>. Change the Amazon EC2 instance to compute optimized.<br>.将 Amazon EC2 实例更改为计算优化型。</p><p><strong>B</strong>. Launch a second Amazon EC2 instance to monitor the health of the first<br>.启动第二个 Amazon EC2 实例以监控第一个实例的运行状况</p><p><strong>C</strong>. Trigger a Lambda function when a new object is uploaded.<br>.在上传新对象时触发 Lambda 函数。</p><p><strong>D</strong>. Initially copy the images to an attached Amazon EBS volume.<br>.最初将映像复制到附加的 Amazon EBS 卷。</p><p>正确答案是 C，因为 Lambda 为流程提供了高可用性，并且消除了对任何计算基础设施的需求，请参阅 AWS 文档 - Lambda，AWS Lambda 是一种无服务器计算服务，它运行您的代码以响应事件并自动为您管理底层计算资源。您可以使用 AWS Lambda 通过自定义逻辑扩展其他 AWS 服务，或创建自己的后端服务，这些服务以 AWS 规模、性能和安全性运行。AWS Lambda 可以自动运行代码以响应多个事件，例如通过 Amazon API Gateway 的 HTTP 请求、对 Amazon S3 存储桶中的对象的修改、Amazon DynamoDB 中的表更新以及 AWS Step Functions 中的状态转换。 容量配置和自动扩展、代码和安全补丁部署，以及代码监控和日志记录。您需要做的就是提供代码，选项 A、B 和 D 是错误的，因为它们不会在实例出现故障时提供高可用性。</p><h2 id="79-一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？"><a href="#79-一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？" class="headerlink" title="79.一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？"></a>79.一家公司希望将负载均衡器用于其应用程序。但是，该公司希望在不修改任何标头的情况下转发请求。公司应该使用什么服务？</h2><p><strong>A</strong>. Classic Load Balancer</p><p><strong>B</strong>. Network Load Balancer</p><p><strong>C</strong>. Application Load Balancer</p><p><strong>D</strong>. Use Route 53 instead<br>.请改用 Route 53</p><p>正确答案是 B，因为 Network Load Balancer 在第 4 层 TCP 上工作，它将请求转发到后端实例而不修改标头，请参阅 AWS 文档 - ELB 侦听器，选项 A 和 C 是错误的，因为经典 ELB 和 ALB 可以在第 7 层上工作，它们可以修改标头，选项 D 是错误的，因为 Route 53 不执行负载均衡器的工作。</p><h2 id="80-一家公司有一个使用-S3-存储桶作为其数据层的应用程序。根据对-S3-存储桶的监控，可以看出-GET-请求的数量为每秒-400-个请求。IT-运营团队接收有关用户在访问应用程序时收到-HTTP-500-或-503-错误的服务请求。可以做些什么来解决这些错误？选择-2-个答案"><a href="#80-一家公司有一个使用-S3-存储桶作为其数据层的应用程序。根据对-S3-存储桶的监控，可以看出-GET-请求的数量为每秒-400-个请求。IT-运营团队接收有关用户在访问应用程序时收到-HTTP-500-或-503-错误的服务请求。可以做些什么来解决这些错误？选择-2-个答案" class="headerlink" title="80.一家公司有一个使用 S3 存储桶作为其数据层的应用程序。根据对 S3 存储桶的监控，可以看出 GET 请求的数量为每秒 400 个请求。IT 运营团队接收有关用户在访问应用程序时收到 HTTP 500 或 503 错误的服务请求。可以做些什么来解决这些错误？选择 2 个答案"></a>80.一家公司有一个使用 S3 存储桶作为其数据层的应用程序。根据对 S3 存储桶的监控，可以看出 GET 请求的数量为每秒 400 个请求。IT 运营团队接收有关用户在访问应用程序时收到 HTTP 500 或 503 错误的服务请求。可以做些什么来解决这些错误？选择 2 个答案</h2><p><strong>A</strong>. Add a CloudFront distribution in front of the bucket.<br>.在存储桶前面添加 CloudFront 分配。</p><p><strong>B</strong>. Add an ELB in front of the S3 bucket.<br>.在 S3 存储桶前面添加一个 ELB。</p><p><strong>C</strong>. Add randomness to the key names.<br>.为键名称添加随机性。</p><p><strong>D</strong>. Enable Versioning for the S3 bucket.<br>.为 S3 存储桶启用版本控制。</p><p>正确答案是 A 和 C，因为以 S3 为源的 CloudFront 有助于缓存请求并减少对 S3 的直接调用，随机性有助于 S3 中跨分区的数据分发，请参阅 AWS 文档 - S3 性能，Amazon S3 在每个 AWS 区域中维护对象键名称的索引。对象键以 UTF-8 二进制顺序存储在索引中的多个分区中。密钥名称决定了密钥存储在哪个分区中。使用顺序前缀（如时间戳或字母顺序）会增加 Amazon S3 将大量密钥作为特定分区目标的可能性，从而使分区的 I/O 容量不堪重负。如果您在键名前缀中引入了一些随机性，则键名以及 I/O 负载将分布在多个分区中，如果您的工作负载主要发送 GET 请求，除了上述准则外，您还应考虑使用 Amazon CloudFront 进行性能优化，将 Amazon CloudFront 与 Amazon S3 集成， 您可以以低延迟和高数据传输速率将内容分发给用户。你也会向 Amazon S3 发送更少的直接请求，这将降低你的成本，例如假设你有几个非常受欢迎的对象Amazon CloudFront 从 Amazon S3 获取这些对象并对其进行缓存。然后，Amazon CloudFront 可以从其缓存中处理对象的未来请求，从而减少它发送到 Amazon S3 的 GET 请求的数量，选项 B 是错误的，因为 ELB 用于将流量分配到 EC2 实例，不适用于 S3，选项 D 是错误的，因为版本控制有助于维护多个副本，并有助于从意外删除或覆盖中恢复。</p><h2 id="81-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？"><a href="#81-您的-Auto-Scaling-组配置为在-5-分钟间隔内总-CPU-负载超过-65-时启动一个新的-Amazon-EC2-实例。有时，Auto-Scaling-组会在第一个-Amazon-EC2-实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止-Auto-Scaling-组启动第二个实例？" class="headerlink" title="81.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？"></a>81.您的 Auto Scaling 组配置为在 5 分钟间隔内总 CPU 负载超过 65% 时启动一个新的 Amazon EC2 实例。有时，Auto Scaling 组会在第一个 Amazon EC2 实例运行之前启动第二个实例。第二个实例不是必需的，并且会带来不必要的计算成本。如何阻止 Auto Scaling 组启动第二个实例？</h2><p><strong>A</strong>. Configure a lifecycle hook for your Auto Scaling group<br>.为您的 Auto Scaling 组配置生命周期挂钩</p><p><strong>B</strong>. Add a scaling-specific cooldown period to the scaling policy<br>.在扩展策略中添加特定于扩展的冷却期</p><p><strong>C</strong>. Adjust the CPU threshold that triggers a scaling action<br>.调整触发扩展操作的 CPU 阈值</p><p><strong>D</strong>. Attach a new launch configuration to the Auto Scaling group<br>.将新的启动配置附加到 Auto Scaling 组</p><p>正确答案是 B，因为您需要调整新添加实例的冷却时间以启动和处理流量，请参阅 AWS 文档 - Auto Scaling 冷却时间，Auto Scaling 冷却时间是 Auto Scaling 组的可配置设置，有助于确保 Auto Scaling 不会在之前的扩展活动生效之前启动或终止其他实例。在 Auto Scaling 组使用简单的扩展策略动态扩展后，Auto Scaling 会等待冷却期完成，然后再恢复扩展活动。当您手动扩展 Auto Scaling 组时，默认设置不等待冷却时间，但您可以覆盖默认值并遵守冷却时间。如果实例运行状况不佳，Auto Scaling 不会等待冷却时间结束，然后再替换运行状况不佳的实例。</p><h2 id="82-一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种-AWS-服务来提供从视频游戏到数据存储的可靠数据摄取？"><a href="#82-一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种-AWS-服务来提供从视频游戏到数据存储的可靠数据摄取？" class="headerlink" title="82.一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种 AWS 服务来提供从视频游戏到数据存储的可靠数据摄取？"></a>82.一家初创公司正在开发一个应用程序来跟踪一款流行视频游戏的高分。他们的解决方案架构师的任务是设计一个解决方案，以便实时处理来自全球数百万玩家的乐谱。架构师应该使用哪种 AWS 服务来提供从视频游戏到数据存储的可靠数据摄取？</h2><p><strong>A</strong>. AWS Data Pipeline</p><p><strong>B</strong>. Amazon Kinesis Firehose</p><p><strong>C</strong>. Amazon DynamoDB Streams</p><p><strong>D</strong>. Amazon Elasticsearch Service</p><p>正确答案是 B，因为 Kinesis Firehose 可以帮助以最少的管理实现可靠的数据摄取，请参阅 AWS 文档 - Kinesis Firehose，Amazon Kinesis Data Firehose 是一项完全托管的服务，用于将实时流数据传输到 Amazon Simple Storage Service （Amazon S3）、Amazon Redshift、Amazon Elasticsearch Service （Amazon ES） 和 Splunk 等目标。Kinesis Data Firehose 与 Kinesis Data Streams、Kinesis Video Streams 和 Amazon Kinesis Data Analytics 一起是 Kinesis 流数据平台的一部分。使用 Kinesis Data Firehose，您无需编写应用程序或管理资源。您可以将数据创建器配置为将数据发送到 Kinesis Data Firehose，它会自动将数据传输到您指定的目标。您还可以将 Kinesis Data Firehose 配置为在传输数据之前对其进行转换。</p><h2 id="83-您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案："><a href="#83-您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案：" class="headerlink" title="83.您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案："></a>83.您在一家非常大的制药公司工作，该公司拥有多个应用程序，这些应用程序非常不同，并且基于不同的编程语言构建。如何尽快部署应用程序？选择正确答案：</h2><p><strong>A</strong>. Create a Lambda function deployment package consisting of code and any dependencies<br>.创建包含代码和任何依赖项的 Lambda 函数部署程序包</p><p><strong>B</strong>. Develop each app in a separate Docker container and deploy using CloudFormation<br>.在单独的 Docker 容器中开发每个应用程序，并使用 CloudFormation 进行部署</p><p><strong>C</strong>. Develop each app in one Docker container and deploy using Elastic Beanstalk<br>.在一个 Docker 容器中开发每个应用程序，并使用 Elastic Beanstalk 进行部署</p><p><strong>D</strong>. Develop each app in a separate Docker container and deploy using Elastic Beanstalk<br>.在单独的 Docker 容器中开发每个应用程序，并使用 Elastic Beanstalk 进行部署</p><p>正确答案是D，因为有了Elastic Beanstalk，每个应用程序都可以部署为一个单独的Docker容器，参考AWS文档-Elastic Beanstalk Create Deploy Docker，Elastic Beanstalk支持从Docker容器部署Web应用程序。使用 Docker 容器，您可以定义自己的运行时环境。您可以选择自己的平台、编程语言和其他平台不支持的任何应用程序依赖项（例如包管理器或工具）。Docker 容器是独立的，包括 Web 应用程序运行所需的所有配置信息和软件，通过将 Docker 与 Elastic Beanstalk 结合使用，您拥有了一个自动处理容量预置、负载均衡、扩展和应用程序运行状况监控详细信息的基础设施。您可以在支持与 Elastic Beanstalk 集成的各种服务（包括但不限于 VPC、RDS 和 IAM）的环境中管理 Web 应用程序。</p><h2 id="84-组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到-AWS，并且需要-AWS-解决方案。如何以最低的成本满足这一要求？"><a href="#84-组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到-AWS，并且需要-AWS-解决方案。如何以最低的成本满足这一要求？" class="headerlink" title="84.组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到 AWS，并且需要 AWS 解决方案。如何以最低的成本满足这一要求？"></a>84.组织存储客户文件，并且必须经常增加其本地存储系统的大小，以实现快速访问和存档。该组织希望迁移到 AWS，并且需要 AWS 解决方案。如何以最低的成本满足这一要求？</h2><p><strong>A</strong>. Use Amazon Glacier for regular storage and Amazon S3 for archiving data.<br>.使用 Amazon Glacier 进行常规存储，使用 Amazon S3 存档数据。</p><p><strong>B</strong>. Use Amazon EBS for regular storage and Amazon S3 for archiving data.<br>.使用 Amazon EBS 进行常规存储，使用 Amazon S3 存档数据。</p><p><strong>C</strong>. Use Amazon S3 for regular storage and Amazon Glacier for archiving data.<br>.使用 Amazon S3 进行常规存储，使用 Amazon Glacier 存档数据。</p><p><strong>D</strong>. Use Amazon EBS for archiving data and Amazon Glacier for regular storage.<br>.使用 Amazon EBS 存档数据，使用 Amazon Glacier 进行常规存储。</p><p>正确答案是 C，因为 S3 将为具有快速访问功能的存储和用于存档的 Glacier 提供理想的解决方案。可以定义对象转换规则以将对象从 S3 移动到 Glacier。此外，该解决方案具有成本效益，选项A是错误的，因为Glacier无法提供对数据的快速访问，选项B和D是错误的，因为EBS不是一个具有成本效益的解决方案。</p><h2 id="85-作为应用程序架构要求的一部分，您工作的公司已请求能够针对-Elastic-Load-Balancer-中的所有组合日志文件运行分析。在-AWS-环境中，哪些服务用于收集日志和处理日志文件分析？"><a href="#85-作为应用程序架构要求的一部分，您工作的公司已请求能够针对-Elastic-Load-Balancer-中的所有组合日志文件运行分析。在-AWS-环境中，哪些服务用于收集日志和处理日志文件分析？" class="headerlink" title="85.作为应用程序架构要求的一部分，您工作的公司已请求能够针对 Elastic Load Balancer 中的所有组合日志文件运行分析。在 AWS 环境中，哪些服务用于收集日志和处理日志文件分析？"></a>85.作为应用程序架构要求的一部分，您工作的公司已请求能够针对 Elastic Load Balancer 中的所有组合日志文件运行分析。在 AWS 环境中，哪些服务用于收集日志和处理日志文件分析？</h2><p><strong>A</strong>. Amazon S3 for storing the ELB log files and EC2 for processing the log files in analysis<br>.Amazon S3 用于存储 ELB 日志文件，EC2 用于处理分析中的日志文件</p><p><strong>B</strong>. Amazon EC2 for storing and processing the log files<br>.用于存储和处理日志文件的 Amazon EC2</p><p><strong>C</strong>. Amazon DynamoDB to store the logs and EC2 for running custom log analysis scripts<br>.Amazon DynamoDB 用于存储日志，EC2 用于运行自定义日志分析脚本</p><p><strong>D</strong>. Amazon S3 for storing ELB log files and Amazon EMR for processing the log files in analysis<br>.Amazon S3 用于存储 ELB 日志文件，Amazon EMR 用于在分析中处理日志文件</p><p>正确答案是D，因为S3可用于存储ELB日志文件，并让EMR执行相同的分析，选项A是错误的，因为您需要在EC2实例上部署应用程序，并且它处理EMR开箱即用的分布式并行处理，选项B和C是错误的，因为DynamoDB和EC2不适合存储日志。</p><h2 id="86-一家公司正在使用托管-VPN-连接来连接其本地数据中心。他们想监控-vpn-何时出现故障。他们如何实施监控？"><a href="#86-一家公司正在使用托管-VPN-连接来连接其本地数据中心。他们想监控-vpn-何时出现故障。他们如何实施监控？" class="headerlink" title="86.一家公司正在使用托管 VPN 连接来连接其本地数据中心。他们想监控 vpn 何时出现故障。他们如何实施监控？"></a>86.一家公司正在使用托管 VPN 连接来连接其本地数据中心。他们想监控 vpn 何时出现故障。他们如何实施监控？</h2><p><strong>A</strong>. Using TunnelState CloudWatch metrics</p><p><strong>B</strong>. Using custom CloudWatch metrics</p><p><strong>C</strong>. Use Lambda function to consume the VPN logs<br>.使用 Lambda 函数使用 VPN 日志</p><p><strong>D</strong>. Create and deploy an external service to ping the VPN endpoint<br>.创建并部署外部服务以 ping VPN 终结点</p><p>正确答案是 A，因为现在可以使用 CloudWatch 监控 VPN 连接，请参阅 AWS 文档 - CloudWatch VPN Monitoring，TunnelState，隧道的状态0 表示 DOWN，1 表示 UP，单位：布尔值</p><h2 id="87-公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种-AWS-服务可以帮助减少延迟？"><a href="#87-公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种-AWS-服务可以帮助减少延迟？" class="headerlink" title="87.公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种 AWS 服务可以帮助减少延迟？"></a>87.公司在本地托管网站。该网站混合了静态和动态内容，但用户在加载静态文件时会遇到延迟。哪种 AWS 服务可以帮助减少延迟？</h2><p><strong>A</strong>. Amazon CloudFront with on-premises servers as the origin.<br>.以本地服务器为源的 Amazon CloudFront。</p><p><strong>B</strong>. ELB Application Load Balancer.</p><p><strong>C</strong>. Amazon Route 53 latency-based routing.<br>.Amazon Route 53 基于延迟的路由。</p><p><strong>D</strong>. Amazon EFS to store and serve static files.<br>.Amazon EFS，用于存储和提供静态文件。</p><p>正确答案是 A，因为 CloudFront 可用于缓存静态资源并在本地托管时提供低延迟访问，请参阅 AWS 文档 - CloudFront Origins，CloudFront 支持使用多个 AWS 资源作为源。例如，您可以指定 Amazon S3 存储桶或 MediaStore 容器、MediaPackage 通道或自定义源，例如 Amazon EC2 实例或您自己的 HTTP Web 服务器，选项 B、C 和 D 是错误的，因为它们无助于减少延迟。</p><h2 id="88-解决方案架构师必须满足哪些要求才能指定-Amazon-EC2-实例应停止而不是终止其-Spot-实例中断？（选择两个。"><a href="#88-解决方案架构师必须满足哪些要求才能指定-Amazon-EC2-实例应停止而不是终止其-Spot-实例中断？（选择两个。" class="headerlink" title="88.解决方案架构师必须满足哪些要求才能指定 Amazon EC2 实例应停止而不是终止其 Spot 实例中断？（选择两个。"></a>88.解决方案架构师必须满足哪些要求才能指定 Amazon EC2 实例应停止而不是终止其 Spot 实例中断？（选择两个。</h2><p><strong>A</strong>. The Spot Instance request type must be one-time.<br>.Spot 实例请求类型必须为一次性。</p><p><strong>B</strong>. The Spot Instance request type must be persistent.<br>.Spot 实例请求类型必须是持久的。</p><p><strong>C</strong>. The root volume must be an Amazon EBS volume<br>.根卷必须是 Amazon EBS 卷</p><p><strong>D</strong>. The root volume must be an instance store volume.<br>.根卷必须是实例存储卷。</p><p><strong>E</strong>. The launch configuration is changed.<br>.启动配置已更改。</p><p>确答案是 B 和 C，因为 Spot 实例定义了持久性请求类型，而 EBS 支持的实例允许它们停止和启动，请参阅 AWS 文档 - 启动停止 Spot 实例，Amazon EC2 Spot 现在允许在中断时停止 Amazon EBS 支持的实例，而不是在容量不再以您首选的价格可用时终止。然后，当容量在您的价格和时间要求范围内可用时，Spot 可以通过从停止状态重新启动实例来满足您的请求。要使用此新功能，请在提交持久性 Spot 请求时选择“停止”而不是“终止”作为中断行为。当您选择“停止”时，Spot 将在中断时关闭您的实例。将保存 EBS 根设备和附加的 EBS 卷，并保留其数据。当容量在您的价格和时间要求范围内再次可用时，Spot 将重新启动您的实例。重新启动后，EBS 根设备将从其先前的状态恢复，以前附加的数据卷将重新附加，并且实例将保留其实例 ID，选项 A、D 和 E 是错误的，因为它们无效。</p><h2 id="89-您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到-Amazon-Virtual-Private-Cloud-（VPC）-之前的架构师已经部署了-3-层-VPC。配置如下：-VPC-vpc-2f8tLC447-IGW-ig-2d8bc445-NACL-acl-2080c448-子网和路由表：-Web-服务器的子网-258bc44d-应用程序服务器的子网-248DC44c-数据库服务器的子网-9189c6f9-路由表：rtb-2i8bc449-rtb-238bc44b-关联：-子网-258bc44d：-rtb-2i8bc449-子网-248DC44c：-rtb-238bc44b-子网-9189c6f9：-rtb-238bc44b-您现在可以开始将-EC2-实例部署到-VPC-中了。Web-服务器必须能够直接访问-Internet-应用程序，而数据库服务器不能直接访问-Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从-Internet-检索更新？"><a href="#89-您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到-Amazon-Virtual-Private-Cloud-（VPC）-之前的架构师已经部署了-3-层-VPC。配置如下：-VPC-vpc-2f8tLC447-IGW-ig-2d8bc445-NACL-acl-2080c448-子网和路由表：-Web-服务器的子网-258bc44d-应用程序服务器的子网-248DC44c-数据库服务器的子网-9189c6f9-路由表：rtb-2i8bc449-rtb-238bc44b-关联：-子网-258bc44d：-rtb-2i8bc449-子网-248DC44c：-rtb-238bc44b-子网-9189c6f9：-rtb-238bc44b-您现在可以开始将-EC2-实例部署到-VPC-中了。Web-服务器必须能够直接访问-Internet-应用程序，而数据库服务器不能直接访问-Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从-Internet-检索更新？" class="headerlink" title="89.您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到 Amazon Virtual Private Cloud （VPC） 之前的架构师已经部署了 3 层 VPC。配置如下： VPC vpc-2f8tLC447 IGW ig-2d8bc445 NACL acl-2080c448 子网和路由表： Web 服务器的子网-258bc44d 应用程序服务器的子网-248DC44c 数据库服务器的子网-9189c6f9 路由表：rtb-2i8bc449 rtb-238bc44b 关联： 子网-258bc44d： rtb-2i8bc449 子网-248DC44c： rtb-238bc44b 子网-9189c6f9： rtb-238bc44b 您现在可以开始将 EC2 实例部署到 VPC 中了。Web 服务器必须能够直接访问 Internet 应用程序，而数据库服务器不能直接访问 Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从 Internet 检索更新？"></a>89.您被任命为解决方案架构师，协助企业客户将电子商务平台迁移到 Amazon Virtual Private Cloud （VPC） 之前的架构师已经部署了 3 层 VPC。配置如下： VPC vpc-2f8tLC447 IGW ig-2d8bc445 NACL acl-2080c448 子网和路由表： Web 服务器的子网-258bc44d 应用程序服务器的子网-248DC44c 数据库服务器的子网-9189c6f9 路由表：rtb-2i8bc449 rtb-238bc44b 关联： 子网-258bc44d： rtb-2i8bc449 子网-248DC44c： rtb-238bc44b 子网-9189c6f9： rtb-238bc44b 您现在可以开始将 EC2 实例部署到 VPC 中了。Web 服务器必须能够直接访问 Internet 应用程序，而数据库服务器不能直接访问 Internet。以下哪种配置将使您能够远程管理应用程序和数据库服务器，并允许这些服务器从 Internet 检索更新？</h2><p><strong>A</strong>. Create a bastion and NAT Instance in subnet-258bc44d and add a route from rtb-238bc44b to subnet-258bc44d.<br>.在 subnet-258bc44d 中创建堡垒和 NAT 实例，并添加从 rtb-238bc44b 到 subnet-258bc44d 的路由。</p><p><strong>B</strong>. Add a route from rtb-238bc44b to igw-2d8bc445 and add a bastion and NAT instance within Subnet-248DC44c.<br>.添加从 rtb-238bc44b 到 igw-2d8bc445 的路由，并在 Subnet-248DC44c 中添加堡垒和 NAT 实例。</p><p><strong>C</strong>. Create a Bastion and NAT Instance in subnet-258bc44d. Add a route from rtb-238bc44b to igw-2d8bc445. And a new NACL that allows access between subnet-258bc44d and subnet-248bc44c.<br>.在 subnet-258bc44d 中创建堡垒和 NAT 实例。添加从 rtb-238bc44b 到 igw-2d8bc445 的路由。以及允许在 subnet-258bc44d 和 subnet-248bc44c 之间进行访问的新 NACL。</p><p><strong>D</strong>. Create a Bastion and NAT instance in subnet-258bc44d and add a route from rtb-238bc44b to the NAT instance.<br>.在 subnet-258bc44d 中创建堡垒和 NAT 实例，并将 rtb-238bc44b 路由添加到 NAT 实例。</p><p>正确答案是 D，因为堡垒和 NAT 应该在公有子网中。由于 Web Server 可以直接访问 Internet，因此子网 subnet-258bc44d 应该是公共的，路由 rtb-2i8bc449 指向 IGW。专用子网的路由 rtb-238bc44b 应指向 NAT 进行传出 Internet 访问，选项 A 是错误的，因为路由应指向 NAT，选项 B 是错误的，因为将 IGW 添加到路由 rtb-238bc44b 会将应用程序和数据库服务器暴露给 Internet。堡垒和 NAT 应该在公共子网中，选项 C 是错误的，因为路由应该指向 NAT 而不是 Internet 网关，否则它将可以访问 Internet。</p><h2 id="90-一家公司在-Amazon-EC2-实例上运行具有单层架构的旧版。磁盘-I-0-较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上-8-点到早上-8-点停止。哪些存储选项最适合此工作负载？"><a href="#90-一家公司在-Amazon-EC2-实例上运行具有单层架构的旧版。磁盘-I-0-较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上-8-点到早上-8-点停止。哪些存储选项最适合此工作负载？" class="headerlink" title="90.一家公司在 Amazon EC2 实例上运行具有单层架构的旧版。磁盘 I/0 较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上 8 点到早上 8 点停止。哪些存储选项最适合此工作负载？"></a>90.一家公司在 Amazon EC2 实例上运行具有单层架构的旧版。磁盘 I/0 较低，在工作时间偶尔会出现小峰值。该公司要求实例在每天晚上 8 点到早上 8 点停止。哪些存储选项最适合此工作负载？</h2><p><strong>A</strong>. Amazon EC2 instance storage</p><p><strong>B</strong>. Amazon EBS General Purpose SSD (gp2) storage</p><p><strong>C</strong>. Amazon S3</p><p><strong>D</strong>. Amazon EBS Provision IOPS SSD (io1) storage</p><p>正确答案是 B，因为使用率很低，偶尔会出现峰值，EBS 通用型 SSD （gp2） 存储将是存储的理想选择。gp2 还提供突增功能来处理偶尔出现的峰值，请参阅 AWS 文档 - EBS gp2 卷，通用型 SSD （gp2） 卷提供经济高效的存储，是各种工作负载的理想选择。这些卷提供个位数毫秒的延迟，并能够在较长时间内突增至 3,000 IOPS。在最低 100 IOPS（33.33 GiB 及以下）和最大 10,000 IOPS（3,334 GiB 及以上）之间，基准性能以每 GiB 卷大小 3 IOPS 的速度线性扩展。AWS 设计 gp2volumes 可在 99% 的时间内提供预置性能。gp2 卷的大小范围从 1 GiB 到 16 TiB，选项 A 是错误的，因为 EC2 实例存储不保持持久性，选项 C 是错误的，因为 S3 是对象存储，无法附加到 EC2 实例，选项 D 是错误的，因为使用率很低，偶尔会出现峰值 gp2 比 io1 更合适。</p><h2 id="91-一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在-ELB-Application-Load-Balancer-后面的-EC2-实例上的-VPC-中运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从-Internet-访问数据库，但群集必须能够从-Internet-获取软件修补程序。哪种-VPC-设计满足这些要求？"><a href="#91-一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在-ELB-Application-Load-Balancer-后面的-EC2-实例上的-VPC-中运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从-Internet-访问数据库，但群集必须能够从-Internet-获取软件修补程序。哪种-VPC-设计满足这些要求？" class="headerlink" title="91.一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在 ELB Application Load Balancer 后面的 EC2 实例上的 VPC 中运行。这些实例在跨多个可用区的 Auto Scaling 组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从 Internet 访问数据库，但群集必须能够从 Internet 获取软件修补程序。哪种 VPC 设计满足这些要求？"></a>91.一位解决方案架构师正在设计一个在线购物应用程序，该应用程序在 ELB Application Load Balancer 后面的 EC2 实例上的 VPC 中运行。这些实例在跨多个可用区的 Auto Scaling 组中运行。应用层必须向客户管理的数据库群集读取和写入数据。不应从 Internet 访问数据库，但群集必须能够从 Internet 获取软件修补程序。哪种 VPC 设计满足这些要求？</h2><p><strong>A</strong>. Public subnets for both the application tier and the database cluster<br>.应用层和数据库群集的公有子网Public subnets for both the application tier and the database cluster</p><p><strong>B</strong>. Public subnets for the application tier, and private subnets for the database cluster<br>.应用层的公有子网和数据库集群的私有子网</p><p><strong>C</strong>. Public subnets for the application tier and NAT Gateway, and private subnets for the database cluster<br>.应用层和 NAT 网关的公有子网，以及数据库集群的私有子网</p><p><strong>D</strong>. Public subnets for the application tier, and private subnets for the database cluster and NAT Gateway<br>.应用层的公有子网，以及数据库集群和 NAT 网关的私有子网</p><p>正确答案是 C，因为应用层需要位于公共子网中才能从 Internet 访问。数据库集群应托管在私有子网中，因为它们不应从 Internet 访问。但是，数据库集群需要访问互联网才能下载补丁，这可以通过托管在公有子网中的 NAT 网关来完成，请参阅 AWS 文档 - VPC 场景 2</p><h2 id="92-解决方案架构师被要求将存储在-Amazon-S3-上的视频内容从-Amazon-CloudFront-交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？"><a href="#92-解决方案架构师被要求将存储在-Amazon-S3-上的视频内容从-Amazon-CloudFront-交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？" class="headerlink" title="92.解决方案架构师被要求将存储在 Amazon S3 上的视频内容从 Amazon CloudFront 交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？"></a>92.解决方案架构师被要求将存储在 Amazon S3 上的视频内容从 Amazon CloudFront 交付给特定用户，同时限制未经授权的用户访问。架构师如何实施解决方案来满足这些要求？</h2><p><strong>A</strong>. Configure CloudFront to use signed-URLs to access Amazon S3<br>.将 CloudFront 配置为使用签名 URL 访问 Amazon S3</p><p><strong>B</strong>. Store the videos as private objects in Amazon S3 and let CloudFront serve the objects by using only Origin Access Identity (OAI)<br>.将视频作为私有对象存储在 Amazon S3 中，并让 CloudFront 仅使用源访问身份 （OAI） 提供对象</p><p><strong>C</strong>. Use Amazon S3 static website as the origin of CloudFront, and configure CloudFront to deliver the videos by generating a signed URL for users<br>.使用 Amazon S3 静态网站作为 CloudFront 的源，并将 CloudFront 配置为通过为用户生成签名 URL 来传输视频</p><p><strong>D</strong>. Use OAI for CloudFront to access private S3 objects and select the Restrict Viewer Access option in CloudFront cache behavior to use signed URLs.<br>.使用 OAI for CloudFront 访问私有 S3 对象，并在 CloudFront 缓存行为中选择 Restrict Viewer Access （限制查看器访问） 选项以使用签名 URL。 </p><p>正确答案是 D，因为 S3 存储桶必须是私有的，并且使用源访问身份通过 CloudFront 进行访问控制。需要启用限制访问选项才能使用签名 URL 来防止未经授权的访问，请参阅 AWS 文档 - 在 Amazon CloudFront 中访问私有内容，要在 Amazon CloudFront 中使用私有内容，您需要一个启用了私有内容的 Amazon CloudFront 分配，以及您信任的授权账户列表来访问您的私有内容。从 Amazon CloudFront 控制台的 Create Distribution Wizard （创建分配向导） 中，开始创建 Web 分配。在“Origin Settings”（源设置）部分中，选择您仅为私有内容创建的 Amazon S3 存储桶，并确保选择以下选项：，这将在您的 Amazon S3 存储桶上设置权限，以保护您的内容不被公开访问，但仍允许 CloudFront 访问您的内容。 在“默认缓存行为设置”部分的底部，确保启用“限制查看器访问”选项，并选择“self”作为受信任的签名者。这些签名者被称为受信任的签名者，因为您信任由他们签名的 URL，并允许他们访问您的私有内容。在我们的示例中，我们使用 self 作为唯一的可信签名者，这意味着只有您的账户才能对 URL 进行签名以访问您的 CloudFront 私有内容，选项 A 是错误的，因为解决方案不完整，选项 B 是错误的，因为分配需要启用限制查看器才能仅通过签名 URL 强制访问，选项 C 对于限制 S3 存储桶需要定义的私有访问是错误的。</p><h2 id="93-餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？"><a href="#93-餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？" class="headerlink" title="93.餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？"></a>93.餐厅预订应用程序需要能够维护等候名单。当客户尝试预订餐桌，但没有空位时，必须将该顾客列入等候名单，并且应用程序必须在餐桌空闲时通知客户。解决方案架构师应该推荐什么服务来确保系统遵循客户请求进入等候名单的顺序？</h2><p><strong>A</strong>. Amazon SNS</p><p><strong>B</strong>. AWS Lambda with sequential dispatch<br>.具有顺序调度功能的 AWS Lambda</p><p><strong>C</strong>. A FIFO queue in Amazon SQS</p><p><strong>D</strong>. A standard queue in Amazon SQS</p><p>正确答案是 C，因为 FIFO SQS 队列可以帮助保持序列的插入顺序，并以相同的顺序进行处理，请参阅 AWS 文档 - SQS FIFO 队列，FIFO（先进先出）队列旨在增强应用程序之间的消息传递，当操作和事件的顺序至关重要时，或者不能容忍重复，选项 A 是错误的，因为 SNS 仅帮助通知，它会将事件发布给所有订阅者，选项 B 是错误的，因为 Lambda 无法保证顺序调度，选项 D 是错误的，因为 SQS 标准队列不保证顺序。</p><h2 id="94-您的公司拥有单独的-AWS-账户用于开发和生产。在开发账户中为每个开发人员分配一个-IAM-用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建-IAM-用户？"><a href="#94-您的公司拥有单独的-AWS-账户用于开发和生产。在开发账户中为每个开发人员分配一个-IAM-用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建-IAM-用户？" class="headerlink" title="94.您的公司拥有单独的 AWS 账户用于开发和生产。在开发账户中为每个开发人员分配一个 IAM 用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建 IAM 用户？"></a>94.您的公司拥有单独的 AWS 账户用于开发和生产。在开发账户中为每个开发人员分配一个 IAM 用户。开发人员有时需要访问生产帐户才能向该环境推出更改。您的公司不允许在生产账户中创建 IAM 用户？</h2><p><strong>A</strong>. Create an IAM role in the development account. Allow IAM Users in the development account to assume the role<br>.在开发账户中创建 IAM 角色。允许开发账户中的 IAM 用户代入角色</p><p><strong>B</strong>. Create an IAM group in the production account. Grant IAM users in the development account membership in the group<br>.在生产账户中创建 IAM 组。向开发账户中的 IAM 用户授予组成员资格</p><p><strong>C</strong>. Create an IAM role in the production account. Allow IAM users in the development account to assume the role<br>.在生产账户中创建 IAM 角色。允许开发账户中的 IAM 用户代入该角色</p><p><strong>D</strong>. Create an IAM group in the development account Grant IAM users in the development account membership in the group<br>.在开发账户中创建 IAM 组 授予开发账户中的 IAM 用户组成员资格</p><p>正确答案是 C，因为您需要在生产账户中定义一个角色以授予对 S3 存储桶的访问权限，并允许开发账户代入该角色。然后，开发账户可以将对角色的访问权限委托给其 IAM 用户，请参阅 AWS 文档 - IAM 角色跨账户访问，将对一个账户中资源的访问权限授予另一个账户中的可信委托人。角色是授予跨账户访问权限的主要方式。但是，借助 AWS 提供的某些 Web 服务，您可以将策略直接附加到资源（而不是使用角色作为代理）。这些策略称为基于资源的策略，您可以使用它们向另一个 AWS 账户中的委托人授予对资源的访问权限。以下服务支持指定资源的基于资源的策略：Amazon Simple Storage Service （S3） 存储桶、Amazon Glacier 文件库、Amazon Simple Notification Service （SNS） 主题和 Amazon Simple Queue Service （SQS） 队列</p><h2 id="95-哪些情况可能导致发生多可用区-Amazon-RDS-故障转移？（选择二）"><a href="#95-哪些情况可能导致发生多可用区-Amazon-RDS-故障转移？（选择二）" class="headerlink" title="95.哪些情况可能导致发生多可用区 Amazon RDS 故障转移？（选择二）"></a>95.哪些情况可能导致发生多可用区 Amazon RDS 故障转移？（选择二）</h2><p><strong>A</strong>. RDS instance is stopped manually.<br>.RDS实例已手动停止。</p><p><strong>B</strong>. A replica of the RDS instance is created in a different region.<br>.RDS实例的副本是在不同的区域创建的。</p><p><strong>C</strong>. An Availability Zone becomes unavailable.<br>.可用区变得不可用。</p><p><strong>D</strong>. Another master user is created.<br>.将创建另一个主用户。</p><p><strong>E</strong>. A failure of the primary database instance.<br>.主数据库实例失败。</p><p>正确答案是 C 和 E 作为主实例或 AZ 关闭将导致自动故障转移，请参阅 AWS 文档 - RDS Multi-AZ，Amazon RDS 会自动处理故障转移，以便您可以尽快恢复数据库操作，而无需管理干预。如果出现以下任一情况，主数据库实例将自动切换到备用副本：选项 A、B 和 D 是错误的，因为它们不会导致自动故障转移。</p><h2 id="96-您的组织正在使用-ALB-处理服务请求。其中一个-API-请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？"><a href="#96-您的组织正在使用-ALB-处理服务请求。其中一个-API-请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？" class="headerlink" title="96.您的组织正在使用 ALB 处理服务请求。其中一个 API 请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？"></a>96.您的组织正在使用 ALB 处理服务请求。其中一个 API 请求面临一致的性能问题。检查流时，您会发现请求流经多个服务。如何以单个请求的粒度跟踪应用程序堆栈中的性能或计时问题？</h2><p><strong>A</strong>. Track the request using “X-Amzn-Trace-Id” HTTP header<br>.使用“X-Amzn-Trace-Id”HTTP 标头跟踪请求</p><p><strong>B</strong>. Track the request using “X-Amzn-Track-Id” HTTP header<br>.使用“X-Amzn-Track-Id”HTTP 标头跟踪请求</p><p><strong>C</strong>. Track the request using “X-Aws-Track-Id” HTTP header<br>.使用“X-Aws-Track-Id”HTTP 标头跟踪请求</p><p><strong>D</strong>. Track the request using “X-Aws-Trace-Id” HTTP header<br>.使用“X-Aws-Trace-Id”HTTP 标头跟踪请求</p><p>正确答案是 A，因为 ALB 注入了一个标识符“X-Amzn-Trace-Id”，该标识符可用于跨各种服务跟踪请求，请参阅 AWS 文档 - ELB Application Load Balancer，请求跟踪Application Load Balancer 在进入负载均衡器的所有请求上注入新的自定义标识符“X-Amzn-Trace-Id” HTTP 标头。请求跟踪允许您在请求通过构成网站和分布式应用程序的各种服务时通过其唯一 ID 跟踪请求。您可以使用唯一跟踪标识符以单个请求的粒度发现应用程序堆栈中的任何性能或计时问题。</p><h2 id="97-您正在-Amazon-Elastic-Cloud-Compute-（EC2）-上部署必须调用-AWS-API-的应用程序。应使用哪种方法将凭据安全地传递到应用程序？"><a href="#97-您正在-Amazon-Elastic-Cloud-Compute-（EC2）-上部署必须调用-AWS-API-的应用程序。应使用哪种方法将凭据安全地传递到应用程序？" class="headerlink" title="97.您正在 Amazon Elastic Cloud Compute （EC2） 上部署必须调用 AWS API 的应用程序。应使用哪种方法将凭据安全地传递到应用程序？"></a>97.您正在 Amazon Elastic Cloud Compute （EC2） 上部署必须调用 AWS API 的应用程序。应使用哪种方法将凭据安全地传递到应用程序？</h2><p><strong>A</strong>. Pass API credentials to the instance using instance userdata.<br>.使用实例 userdata 将 API 凭证传递到实例。</p><p><strong>B</strong>. Use AWS Identity and Access Management roles for EC2 instances.<br>.将 AWS Identity and Access Management 角色用于 EC2 实例。</p><p><strong>C</strong>. Embed the API credentials into your JAR files.<br>.将 API 凭证嵌入到 JAR 文件中。</p><p><strong>D</strong>. Store API credentials as an object in Amazon Simple Storage Service<br>.将 API 凭证作为对象存储在 Amazon Simple Storage Service 中</p><p>正确答案是 B，因为安全传递凭证可以使用 IAM 角色安全地传递，其中凭证由 AWS 维护并经常轮换，请参阅 AWS 文档 - EC2 实例的 IAM 角色，应用程序必须使用 AWS 凭证签署其 API 请求。因此，如果您是应用程序开发人员，则需要一种策略来管理在 EC2 实例上运行的应用程序的凭证。例如，您可以安全地将 AWS 凭证分发到实例，使这些实例上的应用程序能够使用您的凭证对请求进行签名，同时保护您的凭证免受其他用户的侵害。但是，将凭证安全地分发到每个实例具有挑战性，尤其是 AWS 代表您创建的实例，例如 Spot 实例或 Auto Scaling 组中的实例。在轮换 AWS 凭证时，您还必须能够更新每个实例上的凭证，我们设计了 IAM 角色，以便您的应用程序可以安全地从您的实例发出 API 请求，而无需您管理应用程序使用的安全凭证。您可以委派发出 API 请求的权限，而不是创建和分发 AWS 凭证</p><h2 id="98-解决方案架构师必须为需要非常高的顺序-I-0-的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？"><a href="#98-解决方案架构师必须为需要非常高的顺序-I-0-的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？" class="headerlink" title="98.解决方案架构师必须为需要非常高的顺序 I/0 的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？"></a>98.解决方案架构师必须为需要非常高的顺序 I/0 的大数据应用程序选择存储类型。如果实例停止，数据必须保留。以下哪种存储类型将以最低的成本为应用程序提供最佳匹配？</h2><p><strong>A</strong>. An Amazon EC2 instance store local SSD volume<br>.Amazon EC2 实例存储本地 SSD 卷</p><p><strong>B</strong>. An Amazon EBS provisioned IOPS SSD volume<br>.Amazon EBS 预置 IOPS SSD 卷</p><p><strong>C</strong>. An Amazon EBS Throughput Optimized HDD volume</p><p><strong>D</strong>. An Amazon EBS general purpose SSD volume<br>.Amazon EBS 通用型 SSD 卷</p><p>正确答案是 C，因为吞吐量优化 HDD 为具有顺序 I/O 的大数据应用程序提供了理想的存储解决方案，请参阅 AWS 文档 - EBS 卷类型，吞吐量优化 HDD （st1） 卷提供低成本的磁性存储，它根据吞吐量而不是 IOPS 来定义性能。此卷类型非常适合大型顺序工作负载，例如 Amazon EMR、ETL、数据仓库和日志处理。不支持可启动的 st1 卷，吞吐量优化的 HDD （st1） 卷虽然类似于 Cold HDD （sc1） 卷，但旨在支持频繁访问的数据，此卷类型针对涉及大型顺序 I/O 的工作负载进行了优化，我们建议工作负载执行小型随机 I/O 的客户使用 gp2</p><h2 id="99-一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种-AWS-服务来运行数据库？"><a href="#99-一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种-AWS-服务来运行数据库？" class="headerlink" title="99.一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种 AWS 服务来运行数据库？"></a>99.一家银行正在编写新软件，该软件严重依赖数据库事务来实现写入一致性。该应用程序还偶尔会生成有关数据库中数据的报告，并执行跨多个表的联接。数据库必须随着数据量的增长而自动扩展。应使用哪种 AWS 服务来运行数据库？</h2><p><strong>A</strong>. Amazon S3</p><p><strong>B</strong>. Amazon Aurora</p><p><strong>C</strong>. Amazon DynamoDB</p><p><strong>D</strong>. Amazon Redshift</p><p>正确答案是B，因为Aurora提供了一个高度可扩展的关系型数据库，参考AWS文档-Aurora常见问题，Amazon Aurora是一个关系型数据库引擎，它结合了高端商用数据库的速度和可靠性，以及开源数据库的简单性和成本效益。Amazon Aurora MySQL 的性能是 MySQL 的五倍，无需对大多数 MySQL 应用程序进行任何更改;同样，Amazon Aurora PostgreSQL 的性能是 PostgreSQL 的三倍。Amazon RDS 管理您的 Amazon Aurora 数据库，处理耗时的任务，例如预置、修补、备份、恢复、故障检测和修复。您需要为使用的每个 Amazon Aurora 数据库实例支付简单的月度费用。不需要前期成本或长期承诺，选项 A 是错误的，因为 S3 不是事务数据库，选项 C 是错误的，因为 DynamoDB 不适合需要跨多个表联接的要求，选项 D 是错误的，因为 Redshift 不是事务数据库解决方案。</p><h2 id="100-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索文件并将其上传到-Amazon-S3-存储桶。解决方案架构师应如何设计解决方案来满足这些要求？"><a href="#100-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索文件并将其上传到-Amazon-S3-存储桶。解决方案架构师应如何设计解决方案来满足这些要求？" class="headerlink" title="100.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索文件并将其上传到 Amazon S3 存储桶。解决方案架构师应如何设计解决方案来满足这些要求？"></a>100.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索文件并将其上传到 Amazon S3 存储桶。解决方案架构师应如何设计解决方案来满足这些要求？</h2><p><strong>A</strong>. Use Amazon S3 VPC endpoints<br>.使用 Amazon S3 VPC 终端节点</p><p><strong>B</strong>. Use a NAT Gateway</p><p><strong>C</strong>. Deploy a proxy server</p><p><strong>D</strong>. Use a private Amazon S3 Bucket<br>.使用私有 Amazon S3 存储桶</p><p>正确答案是 A，因为 VPC 终端节点可以帮助应用程序通过 Amazon 网络私下访问 S3，而无需浏览互联网，请参阅 AWS 文档 - VPC 终端节点，VPC 终端节点使您能够将 VPC 私下连接到受支持的 AWS 服务和由 PrivateLink 提供支持的 VPC 终端节点服务，而无需互联网网关、NAT 设备、VPN 连接、 或 AWS Direct Connect 连接。VPC 中的实例不需要公有 IP 地址即可与服务中的资源进行通信。您的 VPC 和其他服务之间的流量不会离开 Amazon 网络，终端节点是虚拟设备。它们是水平扩展、冗余且高度可用的 VPC 组件，允许 VPC 中的实例与服务之间进行通信，而不会对网络流量施加可用性风险或带宽限制。支持以下 AWS 服务：选项 B 是错误的，因为 NAT 网关仍然通过 Internet 路由请求，选项 C 是错误的，因为代理服务器仍会通过 Internet 路由请求，选项 D 是错误的，因为私有 S3 存储桶仍然需要访问 Internet。</p><h2 id="101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？"><a href="#101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？" class="headerlink" title="101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？"></a>101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？</h2><p><strong>A</strong>. Deploy the database on multiple Amazon EC2 instances backed by Amazon EBS across multiple Availability Zones.<br>.跨多个可用区将数据库部署在由 Amazon EBS 支持的多个 Amazon EC2 实例上。</p><p><strong>B</strong>. Use Amazon RDS with a multiple Availability Zone option.<br>.将 Amazon RDS 与多可用区选项结合使用。</p><p><strong>C</strong>. Use RDS with a single Availability Zone option and schedule periodic database snapshots.<br>.将 RDS 与单个可用区选项结合使用，并计划定期数据库快照。</p><p><strong>D</strong>. Use Amazon DynamoDB</p><h2 id="101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？-1"><a href="#101-客户正在-AWS-上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？-1" class="headerlink" title="101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？"></a>101.客户正在 AWS 上部署生产门户应用程序。数据库层具有结构化数据。该公司需要一种易于管理且高度可用的解决方案。如何满足这些要求？</h2><p><strong>A</strong>. Deploy the database on multiple Amazon EC2 instances backed by Amazon EBS across multiple Availability Zones.<br>.跨多个可用区将数据库部署在由 Amazon EBS 支持的多个 Amazon EC2 实例上。</p><p><strong>B</strong>. Use Amazon RDS with a multiple Availability Zone option.<br>.将 Amazon RDS 与多可用区选项结合使用。</p><p><strong>C</strong>. Use RDS with a single Availability Zone option and schedule periodic database snapshots.<br>.将 RDS 与单个可用区选项结合使用，并计划定期数据库快照。</p><p><strong>D</strong>. Use Amazon DynamoDB</p><p>正确答案是 B，因为 RDS 是最适合结构化数据的选项。RDS提供了易于管理的可管理性，并且具有多可用区选项，可以提供高可用性，请参阅AWS白皮书-存储选项，Amazon RDS非常适合依赖MySQL，Oracle或SQL Server传统关系数据库引擎的现有应用程序。由于 Amazon RDS 提供对本机数据库引擎的完全兼容性和直接访问，因此为这些数据库设计的大多数代码、库和工具都应无需修改即可与 Amazon RDS 配合使用。Amazon RDS 也非常适合具有结构化数据的新应用程序，这些应用程序需要比 Amazon 的 NoSQL 数据库产品 Amazon DynamoDB 提供的更复杂的查询和联接功能，选项 A 是错误的，因为在 EC2 实例上托管数据库不容易管理，选项 C 是错误的，因为具有单个可用区的 RDS 无法提供高可用性。选项 D 是错误的，因为 DynamoDB 不适用于结构化数据。</p><h2 id="102-一家公司正在设计混合-IT-架构，需要在本地数据中心与其-Virtual-Private-Cloud-（VPC）-之间建立私有连接。以下哪项将使公司能够实现这一目标？选择-2-个答案"><a href="#102-一家公司正在设计混合-IT-架构，需要在本地数据中心与其-Virtual-Private-Cloud-（VPC）-之间建立私有连接。以下哪项将使公司能够实现这一目标？选择-2-个答案" class="headerlink" title="102.一家公司正在设计混合 IT 架构，需要在本地数据中心与其 Virtual Private Cloud （VPC） 之间建立私有连接。以下哪项将使公司能够实现这一目标？选择 2 个答案"></a>102.一家公司正在设计混合 IT 架构，需要在本地数据中心与其 Virtual Private Cloud （VPC） 之间建立私有连接。以下哪项将使公司能够实现这一目标？选择 2 个答案</h2><p><strong>A</strong>. AWS DataPipeline</p><p><strong>B</strong>. ClassicLink</p><p><strong>C</strong>. AWS Direct Connect<br>.AWS 云专线</p><p><strong>D</strong>. Amazon Route53</p><p><strong>E</strong>. VPN connection</p><p>正确答案是 C 和 E，因为 VPN 和 Direct Connect 允许本地和 VPC 之间的私有连接，选项 A 是错误的，因为 Data Pipeline 是在存储服务（包括本地服务器）之间移动数据，但会使用 Internet，选项 B 是错误的，因为 ClassicLink 允许您将 EC2-Classic 实例链接到您账户中的 VPC， ，选项 D 是错误的，因为 Route 53 是将请求路由到 VPC 的 DNS 服务。</p><h2 id="103-您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在-AWS-环境中自动修复系统状态检查失败的过程？"><a href="#103-您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在-AWS-环境中自动修复系统状态检查失败的过程？" class="headerlink" title="103.您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在 AWS 环境中自动修复系统状态检查失败的过程？"></a>103.您的一个实例报告了运行状况不佳的系统状态检查，该检查无法自行修复。如何在 AWS 环境中自动修复系统状态检查失败的过程？</h2><p><strong>A</strong>. Write a script that queries the EC2 API for each instance status check<br>.编写一个脚本，用于查询每个实例状态检查的 EC2 API</p><p><strong>B</strong>. Create CloudWatch metrics that stop and start the instance based off of status check alarms<br>.创建基于状态检查警报停止和启动实例的 CloudWatch 指标</p><p><strong>C</strong>. Implement a third party monitoring tool such as Nagios<br>.实施第三方监控工具，例如 Nagios</p><p><strong>D</strong>. Write a script that periodically shuts down and starts instances<br>.编写一个定期关闭和启动实例的脚本</p><p>正确答案是 B，因为系统检查无法修复，您需要停止并启动实例，这将在另一台机器上启动实例。CloudWatch 可用于基于系统检查自动执行该过程，请参阅 AWS 文档 - EC2 监控系统实例状态检查</p><h2 id="104-公司的策略要求对存储在-Amazon-S3-中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？"><a href="#104-公司的策略要求对存储在-Amazon-S3-中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？" class="headerlink" title="104.公司的策略要求对存储在 Amazon S3 中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？"></a>104.公司的策略要求对存储在 Amazon S3 中的所有数据进行加密。该公司希望以最小的开销使用该选项，并且不想管理任何加密密钥。以下哪项选项符合公司的要求？</h2><p><strong>A</strong>. AWS CloudHSM</p><p><strong>B</strong>. AWS Trusted Advisor</p><p><strong>C</strong>. Server Side Encryption (SSE-S3)</p><p><strong>D</strong>. Server Side Encryption (SSE-KMS)</p><p>正确答案是 C，因为 SSE-S3 提供 S3 的服务器端加密，S3 为您管理加密密钥，请参阅 AWS 文档 - S3 服务器端加密，将服务器端加密与 Amazon S3 托管密钥结合使用 （SSE-S3） – 每个对象都使用唯一密钥进行加密。作为额外的保护措施，它使用定期轮换的主密钥对密钥本身进行加密。Amazon S3 服务器端加密使用最强大的分组密码之一 256 位高级加密标准 （AES-256） 来加密您的数据，选项 A 是错误的，因为 Cloud HSM 不是无缝的，需要您处理密钥，选项 B 是错误的，因为 Trusted Advisor 不提供加密。AWS Trusted Advisor 是一种在线工具，可为您提供实时指导，帮助您按照 AWS 最佳实践预置资源，选项 D 是错误的，因为它需要您生成和管理密钥，类似于 SSE-S3，但具有一些额外的好处以及使用此服务的一些额外费用。使用信封密钥（即保护数据加密密钥的密钥）有单独的权限，该密钥可针对 S3 中的对象进行未经授权的访问提供额外的保护。SSE-KMS 还为您提供密钥使用时间和使用者的审计跟踪。此外，还可以选择自己创建和管理加密密钥，也可以使用对你、你正在使用的服务和你所在的区域唯一的默认密钥。</p><h2 id="105-一家公司正在-Amazon-Simple-Storage-Service-（S3）-上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择-3-个答案"><a href="#105-一家公司正在-Amazon-Simple-Storage-Service-（S3）-上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择-3-个答案" class="headerlink" title="105.一家公司正在 Amazon Simple Storage Service （S3） 上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择 3 个答案"></a>105.一家公司正在 Amazon Simple Storage Service （S3） 上存储数据。该公司的安全策略要求对静态数据进行加密。以下哪种方法可以实现此目的？选择 3 个答案</h2><p><strong>A</strong>. Use Amazon S3 server-side encryption with AWS Key Management Service managed keys.<br>.将 Amazon S3 服务器端加密与 AWS Key Management Service 托管密钥结合使用。</p><p><strong>B</strong>. Use Amazon S3 server-side encryption with customer-provided keys</p><p><strong>C</strong>. Use Amazon S3 server-side encryption with EC2 key pair.<br>.将 Amazon S3 服务器端加密与 EC2 密钥对结合使用。</p><p><strong>D</strong>. Use Amazon S3 bucket policies to restrict access to the data at rest.<br>.使用 Amazon S3 存储桶策略限制对静态数据的访问。</p><p><strong>E</strong>. Encrypt the data on the client-side before ingesting to Amazon S3 using their own master key<br>.在客户端加密数据，然后使用自己的主密钥提取到 Amazon S3</p><p><strong>F</strong>. Use SSL to encrypt the data while in transit to Amazon S3.<br>.使用 SSL 在传输到 Amazon S3 时对数据进行加密。</p><p>正确答案是 A、B 和 E，请参阅 AWS S3 使用加密保护数据，使用 S3 的静态数据加密可以使用服务器端或客户端加密来实现。可以使用 KMS 提供的密钥 （SSE-KMS） 或客户提供的密钥 （SSE-C） 实现 SSE。CSE 可以通过在将数据上传到 S3 之前对数据进行加密，然后在客户端从 S3 下载数据后解密数据来实现，选项 C 是错误的，因为服务器端加密不适用于 EC2 密钥对，选项 D 是错误的，因为存储桶策略只是为了限制对 S3 的访问，选项 F 是错误的，因为它仅针对传输中的数据。</p><h2 id="106-解决方案架构师需要部署基于-node-js-的-Web-应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到-Linux-服务器的部署。使用哪种服务可以满足这些要求？"><a href="#106-解决方案架构师需要部署基于-node-js-的-Web-应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到-Linux-服务器的部署。使用哪种服务可以满足这些要求？" class="headerlink" title="106.解决方案架构师需要部署基于 node.js 的 Web 应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到 Linux 服务器的部署。使用哪种服务可以满足这些要求？"></a>106.解决方案架构师需要部署基于 node.js 的 Web 应用程序，该应用程序具有高可用性和自动扩展功能。营销团队需要快速回滚应用程序版本，并且他们需要有一个操作仪表板。营销团队不希望管理操作系统补丁到 Linux 服务器的部署。使用哪种服务可以满足这些要求？</h2><p><strong>A</strong>. Amazon EC2</p><p><strong>B</strong>. Amazon API Gateway</p><p><strong>C</strong>. AWS Elastic Beanstalk</p><p><strong>D</strong>. Amazon EC2 Container Service</p><p>正确答案是 C，因为 Elastic Beanstalk 提供了一个支持 node.js 的托管 Web 应用程序平台。它处理最新补丁和更新的部署，还提供部署版本控制，能够轻松回滚，请参阅 AWS 文档 - Elastic Beanstalk 和部署，AWS Elastic Beanstalk 是一项易于使用的服务，用于在熟悉的服务器（如 Apache）上部署和扩展使用 Java、.NET、PHP、Node.js、Python、Ruby、Go 和 Docker 开发的 Web 应用程序和服务， Nginx、Passenger 和 IIS，您只需上传代码，Elastic Beanstalk 就会自动处理部署，从容量预置、负载均衡、自动扩展到应用程序运行状况监控。同时，您保留对支持应用程序的 AWS 资源的完全控制权，并可以随时访问底层资源，Elastic Beanstalk 为您预置和运营基础设施并管理应用程序堆栈（平台），因此您不必花费时间或开发专业知识。它还将使运行应用程序的底层平台保持最新状态，并提供最新的补丁和更新。相反，您可以专注于编写代码，而不是花时间管理和配置服务器、数据库、负载平衡器、防火墙和网络，选项 A 和 C 是错误的，因为部署和回滚的处理仍然需要处理，选项 B 是错误的，因为 API 网关只提供 API 编排并且需要后端服务。</p><h2 id="107-您已经开始了一项新工作，并且正在审查贵公司在-AWS-上的基础设施-您注意到一个-Web-应用程序，其中-Elastic-Load-Balancer-（ELB）-位于-Auto-Scaling-组中的-Web-实例前面。当您在-CloudWatch-中检查-ELB-的指标时，您会在可用区-（AZ）-A-中看到-4-个正常运行的实例，在可用区-B-中看到-0-个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？"><a href="#107-您已经开始了一项新工作，并且正在审查贵公司在-AWS-上的基础设施-您注意到一个-Web-应用程序，其中-Elastic-Load-Balancer-（ELB）-位于-Auto-Scaling-组中的-Web-实例前面。当您在-CloudWatch-中检查-ELB-的指标时，您会在可用区-（AZ）-A-中看到-4-个正常运行的实例，在可用区-B-中看到-0-个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？" class="headerlink" title="107.您已经开始了一项新工作，并且正在审查贵公司在 AWS 上的基础设施 您注意到一个 Web 应用程序，其中 Elastic Load Balancer （ELB） 位于 Auto Scaling 组中的 Web 实例前面。当您在 CloudWatch 中检查 ELB 的指标时，您会在可用区 （AZ） A 中看到 4 个正常运行的实例，在可用区 B 中看到 0 个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？"></a>107.您已经开始了一项新工作，并且正在审查贵公司在 AWS 上的基础设施 您注意到一个 Web 应用程序，其中 Elastic Load Balancer （ELB） 位于 Auto Scaling 组中的 Web 实例前面。当您在 CloudWatch 中检查 ELB 的指标时，您会在可用区 （AZ） A 中看到 4 个正常运行的实例，在可用区 B 中看到 0 个运行状况不佳的实例。您需要修复哪些问题才能跨可用区平衡实例？</h2><p><strong>A</strong>. Set the ELB to only be attached to another AZ<br>.将 ELB 设置为仅附加到另一个可用区</p><p><strong>B</strong>. Make sure Auto Scaling is configured to launch in both AZs<br>.确保将 Auto Scaling 配置为在两个可用区中启动</p><p><strong>C</strong>. Make sure your AMI is available in both AZs<br>.确保您的 AMI 在两个可用区中都可用</p><p><strong>D</strong>. Make sure the maximum size of the Auto Scaling Group is greater than 4<br>.确保 Auto Scaling 组的最大大小大于 4</p><p>正确答案是 B，因为 Auto Scaling 组可能未配置为同时使用两个可用区，因此在单个可用区中启动实例，选项 A 是错误的，因为 ELB 可以在单个可用区内启动，但仍然可以将流量路由到两个可用区，选项 C 是错误的，因为 AMI 是区域性的，可用于两个可用区，选项 D 是错误的，因为在扩展的情况下，大于 4 的最大大小只会导致在可用区之间均匀启动超过 4 个实例</p><h2 id="108-需要在-EC2-实例上托管数据库。EBS-卷需要支持高-IOPS-速率，因为数据库上预计会有大量读取和写入请求。哪种-Amazon-EBS-卷类型可以满足此数据库的性能要求？"><a href="#108-需要在-EC2-实例上托管数据库。EBS-卷需要支持高-IOPS-速率，因为数据库上预计会有大量读取和写入请求。哪种-Amazon-EBS-卷类型可以满足此数据库的性能要求？" class="headerlink" title="108.需要在 EC2 实例上托管数据库。EBS 卷需要支持高 IOPS 速率，因为数据库上预计会有大量读取和写入请求。哪种 Amazon EBS 卷类型可以满足此数据库的性能要求？"></a>108.需要在 EC2 实例上托管数据库。EBS 卷需要支持高 IOPS 速率，因为数据库上预计会有大量读取和写入请求。哪种 Amazon EBS 卷类型可以满足此数据库的性能要求？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS Throughput Optimized HDD</p><p><strong>C</strong>. EBS General Purpose SSD</p><p><strong>D</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p>正确答案是 A，因为预配置 IOPS SSD （io1） 卷旨在满足对存储性能和一致性敏感的 I/O 密集型工作负载（尤其是数据库工作负载）的需求。与使用存储桶和积分模型来计算性能的 gp2 不同，io1 卷允许您在创建卷时指定一致的 IOPS 速率，并且 Amazon EBS 在给定年份内 99.9% 的时间内提供预置 IOPS 性能的 10% 以内。</p><h2 id="109-公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？"><a href="#109-公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？" class="headerlink" title="109.公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？"></a>109.公司必须近乎实时地摄取和汇总广告数据。每秒有数千条记录到达。什么服务可以满足这一要求？</h2><p><strong>A</strong>. AWS Data Pipeline</p><p><strong>B</strong>. Amazon Kinesis Data Streams</p><p><strong>C</strong>. Amazon Redshift</p><p><strong>D</strong>. Amazon S3</p><p>正确答案是 B，因为 Kinesis Data Streams 提供实时可扩展的数据摄取服务，请参阅 AWS 文档 - Kinesis Data Streams，Amazon Kinesis Data Streams （KDS） 是一种可大规模扩展且持久的实时数据流服务。KDS 每秒可以从数十万个来源（如网站点击流、数据库事件流、金融交易、社交媒体源、IT 日志和位置跟踪事件）连续捕获千兆字节的数据。收集的数据以毫秒为单位，可用于实时分析使用案例，例如实时控制面板、实时异常检测、动态定价等，选项 A 是错误的，AWS Data Pipeline 仅帮助传输数据，选项 C 是错误的，因为 Redshift 是一种数据仓库服务，不提供实时摄取，选项 D 是错误的，因为 S3 提供存储并且无法扩展以实时摄取数据作为数据聚合。</p><h2 id="110-您的任务是选择数据存储来保留新应用程序的-GPS-坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种-AWS-服务符合您的要求？"><a href="#110-您的任务是选择数据存储来保留新应用程序的-GPS-坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种-AWS-服务符合您的要求？" class="headerlink" title="110.您的任务是选择数据存储来保留新应用程序的 GPS 坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种 AWS 服务符合您的要求？"></a>110.您的任务是选择数据存储来保留新应用程序的 GPS 坐标。在任何规模下，该服务都需要一致的个位数毫秒延迟。哪种 AWS 服务符合您的要求？</h2><p><strong>A</strong>. Amazon Redshift</p><p><strong>B</strong>. Amazon DynamoDB</p><p><strong>C</strong>. Amazon S3</p><p><strong>D</strong>. Amazon RDS</p><p>正确答案是 B，因为 DynamoDB 是由 AWS 管理的 NoSQL 数据存储，可以提供毫秒级延迟，Amazon DynamoDB 是一种快速灵活的 NoSQL 数据库服务，适用于需要一致的个位数毫秒级延迟的所有应用程序。它是一个完全托管的云数据库，支持文档和键值存储模型。其灵活的数据模型、可靠的性能和吞吐能力的自动扩展，使其非常适合移动、Web、游戏、广告技术、物联网和许多其他应用程序，请参阅 AWS 文档 - DynamoDB</p><h2 id="111-您的主管已指示您为其-AWS-账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？"><a href="#111-您的主管已指示您为其-AWS-账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？" class="headerlink" title="111.您的主管已指示您为其 AWS 账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？"></a>111.您的主管已指示您为其 AWS 账户中的资源设计灾难恢复模型。设计解决方案时的关键要求是确保成本最低。在这种情况下，您将采用以下哪种灾难恢复机制？</h2><p><strong>A</strong>. Pilot Light</p><p><strong>B</strong>. Warm standby</p><p><strong>C</strong>. Multi-Site</p><p><strong>D</strong>. Backup and Restore<br>.备份和恢复</p><h2 id="113-一家公司目前有一个包含-60TB-数据的-Redshift-集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？"><a href="#113-一家公司目前有一个包含-60TB-数据的-Redshift-集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？" class="headerlink" title="113.一家公司目前有一个包含 60TB 数据的 Redshift 集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？"></a>113.一家公司目前有一个包含 60TB 数据的 Redshift 集群。作为合规性的一部分，要求在发生灾难时在单独的区域中设置恢复站点。以下哪项解决方案有助于确保满足此要求？</h2><p><strong>A</strong>. Take a copy of the underlying EBS volumes to S3, and then do Cross-Region Replication.<br>.将底层 EBS 卷复制到 S3，然后执行跨区域复制。</p><p><strong>B</strong>. Enable Cross-Region snapshots for the Redshift Cluster.<br>.为 Redshift 集群启用跨区域快照。</p><p><strong>C</strong>. Create a CloudFormation template to restore the Cluster in another region.<br>.创建 CloudFormation 模板以还原其他区域中的集群。</p><p><strong>D</strong>. Enable Cross Availability Zone snapshots for the Redshift Cluster.<br>.为 Redshift 集群启用跨可用区快照。</p><p>正确答案是 B，因为 Redshift 允许跨区域快照，这可以是在单独的区域中恢复集群，请参阅 AWS 文档 - Redshift 快照，跨区域复制快照会产生数据传输费用。将快照复制到目标区域后，它将变为活动状态并可用于还原目的，选项 A 是错误的，因为 Redshift 不会公开底层卷，选项 C 是错误的，因为 CloudFormation 有助于创建集群，但有助于处理数据，选项 D 是错误的，因为可用区快照不允许跨区域还原。</p><h2 id="114-一家公司正在使用-API-Gateway-和部署阶段来管理每个-API-的多个发布阶段，例如-alpha、beta-和生产。他们希望为-API-中的每个阶段指定不同的-AWS-Lambda-函数名称。如何设计-API-网关？"><a href="#114-一家公司正在使用-API-Gateway-和部署阶段来管理每个-API-的多个发布阶段，例如-alpha、beta-和生产。他们希望为-API-中的每个阶段指定不同的-AWS-Lambda-函数名称。如何设计-API-网关？" class="headerlink" title="114.一家公司正在使用 API Gateway 和部署阶段来管理每个 API 的多个发布阶段，例如 alpha、beta 和生产。他们希望为 API 中的每个阶段指定不同的 AWS Lambda 函数名称。如何设计 API 网关？"></a>114.一家公司正在使用 API Gateway 和部署阶段来管理每个 API 的多个发布阶段，例如 alpha、beta 和生产。他们希望为 API 中的每个阶段指定不同的 AWS Lambda 函数名称。如何设计 API 网关？</h2><p><strong>A</strong>. Swagger extensions .Swagger 扩展</p><p><strong>B</strong>. Stage Variables .阶段变量</p><p><strong>C</strong>. API Gateway variables</p><p><strong>D</strong>. Deployment variables .部署变量</p><p>正确答案是 B，因为阶段变量有助于定义环境变量，这些变量可以为不同的阶段提供不同的配置，请参阅 AWS 文档 - 阶段变量，阶段变量是名称-值对，您可以将其定义为与 API 部署阶段关联的配置属性。它们的作用类似于环境变量，可以在 API 设置和映射模板中使用，例如，您可以在阶段配置中定义阶段变量，然后将其值设置为 API 中方法的 HTTP 集成的 URL 字符串。稍后，您可以使用 API 设置中的关联阶段变量名称引用 URL 字符串。这样，您可以通过将阶段变量值重置为相应的 URL，在每个阶段使用具有不同端点的相同 API 设置。您还可以访问映射模板中的阶段变量，或者将配置参数传递到 AWS Lambda 或 HTTP 后端。</p><h2 id="115-客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到-5-个大型-EC2-实例的负载。然而，在感恩节假期前一周，他们遇到了近-20-个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？"><a href="#115-客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到-5-个大型-EC2-实例的负载。然而，在感恩节假期前一周，他们遇到了近-20-个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？" class="headerlink" title="115.客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到 5 个大型 EC2 实例的负载。然而，在感恩节假期前一周，他们遇到了近 20 个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？"></a>115.客户有一个网站，其中显示了市场上所有可用的交易。该站点通常会遇到 5 个大型 EC2 实例的负载。然而，在感恩节假期前一周，他们遇到了近 20 个大型实例。该期间的负载根据办公时间在一天中有所不同。下面提到的哪种解决方案具有成本效益，并有助于网站实现更好的性能？</h2><p><strong>A</strong>. Keep only 10 instances running and manually launch 10 instances every day during office hours.<br>.每天只运行 10 个实例，并在办公时间手动启动 10 个实例。</p><p><strong>B</strong>. Setup to run 10 instances during the pre-vacation period and only scale up during the office time by launching 10 more instances using the Auto Scaling schedule.<br>.设置为在假期前期间运行 10 个实例，并且仅在办公时间内通过使用 Auto Scaling 计划再启动 10 个实例来扩展。</p><p><strong>C</strong>. During the pre-vacation period setup a scenario where the organization has 15 instances running and 5 instances to scale up and down using Auto Scaling based on the network I/O policy.<br>.在假期前期间，设置一个场景，其中组织有 15 个实例正在运行，5 个实例可以使用基于网络 I/O 策略的 Auto Scaling 进行扩展和缩减。</p><p><strong>D</strong>. During the pre-vacation period setup 20 instances to run continuously.<br>.在假期前期间，设置 20 个实例以连续运行。</p><p>正确答案是 B 在运行 10 个实例时具有成本效益，并且仅在办公时间启动 10 个实例，选项 A 是错误的，因为手动启动实例很麻烦且不具有成本效益，选项 C 是错误的，因为与 B 相比运行 15 个实例不具有成本效益，选项 D 是错误的，因为始终运行 20 个实例是开销，因为它并不总是需要并且不具有成本效益</p><h2 id="116-一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种-Linux-EC2-实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？"><a href="#116-一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种-Linux-EC2-实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？" class="headerlink" title="116.一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种 Linux EC2 实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？"></a>116.一家媒体公司正在设计他们的媒体处理流程。他们希望文件系统能够挂载到各种 Linux EC2 实例上，并通过文件锁定功能操作大文件。以下哪项是满足此要求的理想存储服务？</h2><p><strong>A</strong>. Amazon EBS</p><p><strong>B</strong>. Amazon EFS</p><p><strong>C</strong>. Amazon S3</p><p><strong>D</strong>. Amazon EC2 Instance store</p><p>正确答案是 C，因为 EFS 提供了一个能够操作大文件的共享文件系统，请参阅 AWS 文档 - EFS 和 EFS 性能，Amazon EFS 提供文件系统访问语义，例如强大的数据一致性和文件锁定，视频编辑、演播室制作、广播处理、声音设计和渲染等媒体工作流程通常依赖于共享存储来操作大文件。具有高吞吐量和共享文件访问的强大数据一致性模型可以缩短执行这些作业所需的时间，并将多个本地文件存储库整合到一个位置供所有用户使用。选项 A 和 D 是错误的，因为 EBS 和实例存储卷无法共享，选项 B 是错误的，因为 S3 可以共享， 但是，对于操作大文件并不理想。</p><h2 id="117-您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的图片，并为您提供最高的灵活性来轮换凭证？"><a href="#117-您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在-Amazon-Simple-Storage-Service-（S3）-存储桶中的图片，并为您提供最高的灵活性来轮换凭证？" class="headerlink" title="117.您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在 Amazon Simple Storage Service （S3） 存储桶中的图片，并为您提供最高的灵活性来轮换凭证？"></a>117.您的公司构建了一个已经下载了数十万次的移动应用程序。哪种身份验证解决方案将使移动客户端能够访问存储在 Amazon Simple Storage Service （S3） 存储桶中的图片，并为您提供最高的灵活性来轮换凭证？</h2><p><strong>A</strong>. Identity federation based on AWS Security Token Service (STS) using an AWS Identity and Access Management (IAM) policy for the respective Amazon S3 bucket<br>.基于 AWS Security Token Service （STS） 的联合身份验证，使用相应 Amazon S3 存储桶的 AWS Identity and Access Management （IAM） 策略</p><p><strong>B</strong>. IAM user per registered client with an IAM policy granting Amazon S3 access to the respective bucket<br>.每个注册客户端的 IAM 用户，其 IAM 策略授予对相应存储桶的 Amazon S3 访问权限</p><p><strong>C</strong>. Amazon S3 bucket policies with a conditional statement restricting by IP address<br>.具有按 IP 地址限制的条件语句的 Amazon S3 存储桶策略</p><p><strong>D</strong>. Access Control Lists (ACL) to restrict access to selected AWS accounts<br>.访问控制列表 （ACL），用于限制对选定 AWS 账户的访问</p><p>正确答案是 A，因为这里轮换凭证的最大灵活性的关键点是使用 AWS 使用 STS 维护和管理的临时凭证，请参阅 AWS 文档 - IAM Web 联合身份验证，选项 B、C 和 D 不灵活，需要为每个用户维护。</p><h2 id="118-具有全球用户的网站在-ELB-Application-Load-Balancer-后面的-EC2-实例上运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行，并传输存储在共享-Amazon-EFS-文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？"><a href="#118-具有全球用户的网站在-ELB-Application-Load-Balancer-后面的-EC2-实例上运行。这些实例在跨多个可用区的-Auto-Scaling-组中运行，并传输存储在共享-Amazon-EFS-文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？" class="headerlink" title="118.具有全球用户的网站在 ELB Application Load Balancer 后面的 EC2 实例上运行。这些实例在跨多个可用区的 Auto Scaling 组中运行，并传输存储在共享 Amazon EFS 文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？"></a>118.具有全球用户的网站在 ELB Application Load Balancer 后面的 EC2 实例上运行。这些实例在跨多个可用区的 Auto Scaling 组中运行，并传输存储在共享 Amazon EFS 文件系统上的多个大文件。该公司需要避免每次用户请求这些数字资产时从网站提供文件。公司如何改善网站的用户体验？</h2><p><strong>A</strong>. Move the digital assets to Amazon Glacier.<br>.将数字资产迁移到 Amazon Glacier。</p><p><strong>B</strong>. Cache static content using CloudFront.<br>.使用 CloudFront 缓存静态内容。</p><p><strong>C</strong>. Resize the files so that they are smaller.<br>.调整文件的大小，使其更小。</p><p><strong>D</strong>. Use reserved EC2 Instances.</p><p>正确答案是 B，因为要求是提高下载性能并减少全局用户的系统负载，CloudFront 将帮助缓存内容并为用户提供低延迟访问，请参阅 AWS 文档 - CloudFront 缓存，Amazon CloudFront 是一种 Web 服务，可加快静态和动态 Web 内容的分发速度， 例如 .html、.css、.js 和图像文件。CloudFront 通过称为边缘站点的全球数据中心网络传输您的内容。当用户请求您使用 CloudFront 提供的内容时，用户将被路由到提供最低延迟（时间延迟）的边缘站点，以便以最佳性能交付内容。如果内容已经位于延迟最低的边缘站点中，则 CloudFront 会立即提供它，选项 A 是错误的，因为 Glacier 用于数据存档，选项 C 是错误的，因为它不能解决问题，选项 D 是错误的，因为预留的 EC2 实例有助于降低长期使用的成本，它无助于提高性能。</p><h2 id="119-您使用-S3-运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？"><a href="#119-您使用-S3-运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？" class="headerlink" title="119.您使用 S3 运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？"></a>119.您使用 S3 运行一个广告支持的照片共享网站，以向网站的访问者提供照片。在某些时候，您发现其他网站一直在链接到您网站上的照片，从而给您的业务造成损失。缓解这种情况的有效方法是什么？</h2><p><strong>A</strong>. Remove public read access and use signed URLs with expiry dates<br>.删除公共读取访问权限并使用具有到期日期的签名 URL</p><p><strong>B</strong>. Use CloudFront distributions for static content.<br>.将 CloudFront 分配用于静态内容。</p><p><strong>C</strong>. Block the IPs of the offending websites in Security Groups.<br>.在安全组中屏蔽违规网站的IP。</p><p><strong>D</strong>. Store photos on an EBS volume of the web server.<br>.将照片存储在 Web 服务器的 EBS 卷上。</p><p>正确答案是A，因为网站可以使用有限时间访问的预签名URL并不断刷新，这样其他网站就无法访问它们，请参考AWS文档-S3与预签名URL共享对象，默认情况下所有对象都是私有的。只有对象所有者才有权访问这些对象。但是，对象所有者可以选择通过创建预签名 URL 来与他人共享对象，使用他们自己的安全凭证授予下载对象的限时权限，选项 B 是错误的，因为仍然可以直接访问 CloudFront URL，选项 C 不可扩展，选项 D 不起作用，因为在 EBS 上存储图像仍需要公开。</p><h2 id="120-您计划创建一个-EC2-实例，该实例将创建-S3-对象并修改-CloudWatch-警报。部署此实例的最佳方式是什么？选择正确答案"><a href="#120-您计划创建一个-EC2-实例，该实例将创建-S3-对象并修改-CloudWatch-警报。部署此实例的最佳方式是什么？选择正确答案" class="headerlink" title="120.您计划创建一个 EC2 实例，该实例将创建 S3 对象并修改 CloudWatch 警报。部署此实例的最佳方式是什么？选择正确答案"></a>120.您计划创建一个 EC2 实例，该实例将创建 S3 对象并修改 CloudWatch 警报。部署此实例的最佳方式是什么？选择正确答案</h2><p><strong>A</strong>. Assign an S3 policy to one IAM user and a CloudWatch policy to another IAM user. Have the instance execute tasks as the appropriate IAM user for the given task<br>.将 S3 策略分配给一个 IAM 用户，将 CloudWatch 策略分配给另一个 IAM 用户。让实例以给定任务的相应 IAM 用户身份执行任务</p><p><strong>B</strong>. Assign an S3 policy and a CloudWatch policy to a single IAM user. Have the instance execute tasks as the IAM user<br>.将 S3 策略和 CloudWatch 策略分配给单个 IAM 用户。让实例以 IAM 用户身份执行任务</p><p><strong>C</strong>. Assign an S3 policy and a CloudWatch policy to a single IAM role. Assign the IAM role to the instance at deployment time<br>.将 S3 策略和 CloudWatch 策略分配给单个 IAM 角色。在部署时将 IAM 角色分配给实例</p><p><strong>D</strong>. Assign an S3 policy to one IAM role and a CloudWatch policy to another IAM role. Assign both IAM roles to the EC2 instance at deployment time<br>.将 S3 策略分配给一个 IAM 角色，将 CloudWatch 策略分配给另一个 IAM 角色。在部署时将两个 IAM 角色分配给 EC2 实例</p><p>正确答案是 C，因为方法是创建一个策略，将权限附加到单个 IAM 角色，并分配要启动的角色 EC2 实例，请参阅 AWS 文档 - IAM 最佳实践，选项 A 和 B 是错误的，因为不建议使用 IAM 用户，选项 D 是错误的，因为只能将单个角色附加到 EC2 实例</p><h2 id="121-您的安全团队要求每个-Amazon-ECS-任务都有一个-IAM-策略，该策略将任务的权限限制为仅使用其使用-AWS-服务所需的权限。你怎么能做到这一点？"><a href="#121-您的安全团队要求每个-Amazon-ECS-任务都有一个-IAM-策略，该策略将任务的权限限制为仅使用其使用-AWS-服务所需的权限。你怎么能做到这一点？" class="headerlink" title="121.您的安全团队要求每个 Amazon ECS 任务都有一个 IAM 策略，该策略将任务的权限限制为仅使用其使用 AWS 服务所需的权限。你怎么能做到这一点？"></a>121.您的安全团队要求每个 Amazon ECS 任务都有一个 IAM 策略，该策略将任务的权限限制为仅使用其使用 AWS 服务所需的权限。你怎么能做到这一点？</h2><p><strong>A</strong>. Use IAM roles for Amazon ECS tasks to associate a specific IAM role with each ECS task definition<br>.将 IAM 角色用于 Amazon ECS 任务，将特定 IAM 角色与每个 ECS 任务定义相关联</p><p><strong>B</strong>. Use IAM roles on the Amazon ECS container instances to associate IAM role with each ECS task on that instance<br>.使用 Amazon ECS 容器实例上的 IAM 角色将 IAM 角色与该实例上的每个 ECS 任务相关联</p><p><strong>C</strong>. Connect to each running amazon ECS container instance and add discrete credentials<br>.连接到每个正在运行的 Amazon ECS 容器实例并添加离散凭证</p><p><strong>D</strong>. Reboot each Amazon ECS task programmatically to generate new instance metadata for each task<br>.以编程方式重启每个 Amazon ECS 任务，以便为每个任务生成新的实例元数据</p><p>正确答案是A，因为IAM角色需要与ECS任务定义相关联，请参考AWS文档-ECS任务IAM角色，使用AMC任务的IAM角色可以指定任务中的容器可以使用的IAM角色。应用程序必须使用 AWS 凭证对其 AWS API 请求进行签名，此功能提供了一种用于管理应用程序要使用的凭证的策略，类似于 Amazon EC2 实例配置文件向 EC2 实例提供凭证的方式。您可以将 IAM 角色与 ECS 任务定义或 RunTask API 操作相关联，而不是创建 AWS 凭证并将其分发到容器或使用 EC2 实例的角色。然后，任务容器中的应用程序可以使用 AWS 开发工具包或 CLI 向授权的 AWS 服务发出 API 请求。</p><h2 id="122-您正在为-VPC-环境设计数据泄漏防护解决方案。您希望您的-VPC-实例能够访问-Internet-上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方-CDN-通过其-URL-访问。您希望明确拒绝从-VPC-实例到-Internet-上主机的任何其他出站连接。您会考虑以下哪一项选择？"><a href="#122-您正在为-VPC-环境设计数据泄漏防护解决方案。您希望您的-VPC-实例能够访问-Internet-上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方-CDN-通过其-URL-访问。您希望明确拒绝从-VPC-实例到-Internet-上主机的任何其他出站连接。您会考虑以下哪一项选择？" class="headerlink" title="122.您正在为 VPC 环境设计数据泄漏防护解决方案。您希望您的 VPC 实例能够访问 Internet 上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方 CDN 通过其 URL 访问。您希望明确拒绝从 VPC 实例到 Internet 上主机的任何其他出站连接。您会考虑以下哪一项选择？"></a>122.您正在为 VPC 环境设计数据泄漏防护解决方案。您希望您的 VPC 实例能够访问 Internet 上的软件库和发行版以获取产品更新。仓库和发行版可通过第三方 CDN 通过其 URL 访问。您希望明确拒绝从 VPC 实例到 Internet 上主机的任何其他出站连接。您会考虑以下哪一项选择？</h2><p><strong>A</strong>. Configure a web proxy server in your VPC and enforce URL-based rules for outbound access Remove default routes.<br>.在 VPC 中配置 Web 代理服务器，并强制执行基于 URL 的出站访问规则 删除默认路由。</p><p><strong>B</strong>. Implement security groups and configure outbound rules to only permit traffic to software depots.<br>.实施安全组并配置出站规则，以仅允许流向软件库的流量。</p><p><strong>C</strong>. Move all your instances into private VPC subnets remove default routes from all routing tables and add specific routes to the software depots and distributions only.<br>.将所有实例移动到私有 VPC 子网中，从所有路由表中删除默认路由，并仅将特定路由添加到软件库和分配中。</p><p><strong>D</strong>. Implement network access control lists to all specific destinations, with an Implicit deny as a rule.<br>.对所有特定目标实施网络访问控制列表，并通常使用隐式拒绝。</p><p>正确答案是A，因为安全组和NACL的规则中不能有URL，路由也不能，只能使用IP地址或其他安全组，参考AWS回答，Web代理服务器是目前最常用的代理服务器类型。Web 代理控制 HTTP 和 HTTPS 流量，并具有来自 Web 客户端（如 Web 浏览器、Web 命令行工具、编程工具和 Web 应用程序服务器）的无处不在的支持。SOCKS 代理服务器虽然不如 Web 代理常见，但利用自定义 SOCKS 代理客户端来控制任何类型的 IP 网络流量。无论哪种情况，都必须配置每个 EC2 实例（通常通过初始实例引导或应用程序部署和配置）才能在操作系统或应用程序级别利用代理解决方案。</p><h2 id="123-解决方案架构师需要设计一个-Amazon-RDS-for-MySQL-解决方案，其中用户必须仅使用-SSL-连接进行身份验证。解决方案架构师应该如何设计解决方案？"><a href="#123-解决方案架构师需要设计一个-Amazon-RDS-for-MySQL-解决方案，其中用户必须仅使用-SSL-连接进行身份验证。解决方案架构师应该如何设计解决方案？" class="headerlink" title="123.解决方案架构师需要设计一个 Amazon RDS for MySQL 解决方案，其中用户必须仅使用 SSL 连接进行身份验证。解决方案架构师应该如何设计解决方案？"></a>123.解决方案架构师需要设计一个 Amazon RDS for MySQL 解决方案，其中用户必须仅使用 SSL 连接进行身份验证。解决方案架构师应该如何设计解决方案？</h2><p><strong>A</strong>. Only allow SSL connections through a VPC security group.<br>.仅允许通过 VPC 安全组进行 SSL 连接。</p><p><strong>B</strong>. Use GRANT and ALTER commands with the REQUIRE SSL option for the user.<br>.对用户使用带有 REQUIRE SSL 选项的 GRANT 和 ALTER 命令。</p><p><strong>C</strong>. Connect with a MySQL client that references the public key.<br>.使用引用公钥的 MySQL 客户端进行连接。</p><p><strong>D</strong>. Ensure that the SSL parameters are set in the parameter group at launch.<br>.确保在启动时在参数组中设置了 SSL 参数。</p><p>正确答案是C，至于SSL连接AWS将SSL证书附加到主实例，客户端需要使用公钥进行连接，请参阅AWS文档-RDS MySQL SSL连接，Amazon RDS支持与运行MySQL数据库引擎的数据库实例进行安全套接字层（SSL）连接，Amazon RDS会创建SSL证书，并在Amazon RDS预置实例时在数据库实例上安装该证书。这些证书由证书颁发机构签名。SSL 证书包括数据库实例终端节点作为 SSL 证书的公用名 （CN），以防止欺骗攻击。公有密钥存储在 Amazon RDS 创建的 SSL 证书是受信任的根实体 <a href="https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem.,An">https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem.,An</a> 在大多数情况下应该可以工作，但如果您的应用程序不接受证书链，则可能会失败。如果您的应用程序不接受证书链，您可能需要使用中间证书连接到您的区域，要使用默认的 mysql 客户端加密连接，请使用 –ssl-ca 参数启动 mysql 客户端以引用公钥，如以下示例所示，以下示例显示了如何使用 MySQL 5.7 及更高版本的 –ssl-ca 参数启动客户端。</p><h2 id="124-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"><a href="#124-您在三个可用区中有-EC2-实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题" class="headerlink" title="124.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题"></a>124.您在三个可用区中有 EC2 实例，并在所有三个可用区上配置了负载均衡器。您观察到一个可用区接收的流量比其他可用区多，您如何有效地解决这个问题</h2><p><strong>A</strong>. Disable sticky sessions<br>.禁用粘性会话</p><p><strong>B</strong>. Reduce the frequency of the health checks<br>.降低运行状况检查的频率</p><p><strong>C</strong>. Enable cross zone load balancer<br>.启用跨区域负载均衡器</p><p><strong>D</strong>. Amazon recommends using two availability zone behind ELB<br>.Amazon 建议在 ELB 后面使用两个可用区</p><p>正确答案是 A，因为粘性会话可能会导致用户被路由到相同的实例，选项 B 是错误的，因为降低运行状况检查的频率只会帮助确定实例是否正常。对于跨可用区的所有实例都是一样的，选项 C 是错误的，因为启用跨区域负载均衡器只会帮助在实例之间平均路由流量，而不是在可用区之间路由流量，这里似乎不是这种情况，选项 D 是错误的，因为 AWS 建议将实例分散到所有可用可用区以使应用程序高可用</p><h2 id="125-一家新闻公司制作了很多视频。他们希望在-AWS-中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在-5-小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？"><a href="#125-一家新闻公司制作了很多视频。他们希望在-AWS-中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在-5-小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？" class="headerlink" title="125.一家新闻公司制作了很多视频。他们希望在 AWS 中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在 5 小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？"></a>125.一家新闻公司制作了很多视频。他们希望在 AWS 中设计存储解决方案。这些视频需要一天，之后应存档。如果需要，可以在提前通知的情况下请求视频，预计在 5 小时内提供。但是，如果有任何突发新闻，视频需要在几分钟内提供。作为解决方案架构师，您将如何以经济高效的方式设计解决方案？</h2><p><strong>A</strong>. Use AWS S3 Standard<br>.使用 AWS S3 标准</p><p><strong>B</strong>. Use AWS S3 Infrequent Access<br>.使用 AWS S3 不频繁访问</p><p><strong>C</strong>. Use AWS Glacier with Standard retrievals</p><p><strong>D</strong>. Use AWS Glacier with pay for Expedited retrievals as needed.<br>.根据需要使用 AWS Glacier 付费加急检索。</p><p>正确答案是 D，因为 Glacier 提供了最具成本效益的存档解决方案。对于默认为标准检索的正常请求，可以在 3-5 小时内检索视频。对于快速检索，可以提出加急检索请求，但需要额外付费才能在 1-5 分钟内提供视频，请参阅 AWS 文档 - Glacier 常见问题 - 数据检索，问：如何使用标准检索？，要进行标准检索，请将 InitiateJob API 请求中的“Tier”参数设置为“Standard”。如果未指定层，则请求将默认为“标准”，问：什么是加急检索？，加急检索允许您在偶尔需要紧急请求存档子集时快速访问数据。对于除最大档案 （250MB+） 外的所有档案，使用加急检索访问的数据通常在 1 到 5 分钟内可用。有两种类型的加急检索：按需检索和预置检索。按需请求类似于 EC2 按需实例，在绝大多数情况下都可用。预置的请求保证在您需要时可用，选项 A 和 B 是错误的，因为 S3 不是一个具有成本效益的解决方案，选项 C 是错误的，因为标准检索无法在几分钟内获取视频。</p><h2 id="126-您的公司正准备在-AWS-上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的-EC2-实例上运行，这些实例具有多可用区-RDS-MySQL-超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现-RDS-MySQL-上存在读取争用。满足这些要求的最佳方法是什么？选择-2。"><a href="#126-您的公司正准备在-AWS-上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的-EC2-实例上运行，这些实例具有多可用区-RDS-MySQL-超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现-RDS-MySQL-上存在读取争用。满足这些要求的最佳方法是什么？选择-2。" class="headerlink" title="126.您的公司正准备在 AWS 上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的 EC2 实例上运行，这些实例具有多可用区 RDS MySQL 超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现 RDS MySQL 上存在读取争用。满足这些要求的最佳方法是什么？选择 2。"></a>126.您的公司正准备在 AWS 上发布社交媒体网站的重大公告。该网站在跨多个可用区部署的 EC2 实例上运行，这些实例具有多可用区 RDS MySQL 超大型数据库实例。该站点每秒执行大量小的读取和写入，并依赖于最终一致性模型。经过全面测试后，您发现 RDS MySQL 上存在读取争用。满足这些要求的最佳方法是什么？选择 2。</h2><p><strong>A</strong>. Deploy ElastiCache in-memory cache running in each availability zone<br>.部署在每个可用区中运行的 ElastiCache 内存中缓存</p><p><strong>B</strong>. Implement sharding to distribute load to multiple RDS MySQL instances<br>.实施分片以将负载分配给多个 RDS MySQL 实例</p><p><strong>C</strong>. Increase the RDS MySQL Instance size and Implement provisioned IOPS<br>.增加 RDS MySQL 实例大小并实现预置 IOPS</p><p><strong>D</strong>. Add an RDS MySQL read replica in each availability zone<br>.在每个可用区中添加 RDS MySQL 只读副本</p><p>这里的关键点是存在读取争用，正确答案是 A 和 D，因为 RDS 需要使用只读副本或使用 ElastiCache 等缓存解决方案进行横向扩展，选项 B 是错误的，因为这只是一个读取争用，写入工作正常，分片将有助于改进写入，选项 C 是错误的，因为无法扩展到超出限制， 这只是一个读取争用，写入工作正常</p><h2 id="127-一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种-AWS-服务将满足上述要求？"><a href="#127-一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种-AWS-服务将满足上述要求？" class="headerlink" title="127.一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种 AWS 服务将满足上述要求？"></a>127.一家公司正在开发一个文档共享应用程序，需要一个存储层。作为一项安全措施，存储应提供对版本控制的自动支持，以便用户可以轻松地回滚到以前的版本或恢复已删除的文档。哪种 AWS 服务将满足上述要求？</h2><p><strong>A</strong>. Amazon S3</p><p><strong>B</strong>. Amazon EBS</p><p><strong>C</strong>. Amazon EFS</p><p><strong>D</strong>. Amazon Storage Gateway VTL</p><p>正确答案是 A，因为 S3 提供了持久、可扩展的对象存储。S3 还允许对文档进行版本控制，这可以帮助用户恢复到以前的版本，以便从覆盖或意外删除中恢复，请参阅 AWS 文档 - S3 版本控制，启用版本控制的存储桶使您能够从意外删除或覆盖中恢复对象。例如：选项 B 是错误的，因为 EBS 是附加到 EC2 实例的持久块存储卷，选项 C 是错误的，因为 EFS 是一种弹性且可扩展的文件存储，虽然它可以帮助共享文档，但它不提供版本控制功能，选项 D 是错误的，因为 AWS Storage Gateway VTL 有助于使用 AWS 存储扩展您的本地 IT 基础设施。</p><h2 id="128-组织已在-EC2-实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？"><a href="#128-组织已在-EC2-实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？" class="headerlink" title="128.组织已在 EC2 实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？"></a>128.组织已在 EC2 实例上托管应用程序。将有多个用户连接到实例以设置和配置应用程序。该组织正计划实施某些安全最佳做法。以下提到的指针中哪一项不会帮助组织实现更好的安全安排？</h2><p><strong>A</strong>. Apply the latest patch of OS and always keep it updated.<br>.应用最新的操作系统补丁并始终保持更新。</p><p><strong>B</strong>. Allow only IAM users to connect with the EC2 instances with their own secret access key.<br>.仅允许 IAM 用户使用自己的秘密访问密钥与 EC2 实例连接。</p><p><strong>C</strong>. Disable the password-based login for all the users. All the users should use their own keys to connect with the instance securely.<br>.为所有用户禁用基于密码的登录。所有用户都应使用自己的密钥安全地与实例连接。</p><p><strong>D</strong>. Create a procedure to revoke the access rights of the individual user when they are not required to connect to EC2 instance anymore for the purpose of application configuration.<br>.创建一个过程，当单个用户不再需要连接到 EC2 实例进行应用程序配置时，该用户将撤消其访问权限。</p><p>正确答案是 B，因为 IAM 用户无法使用其访问密钥连接到 EC2 实例。对 EC2 实例的访问由 ssh 密钥管理，请参阅 AWS 文章 - 保护 EC2 实例的提示，选项 A 是错误的，因为 EC2 实例应始终更新为最新补丁，选项 C 是错误的，因为应禁用基于密码的登录，并且对于每个用户，应将其密钥从他们添加到实例中以登录，选项 D 是错误的，因为在不需要时应删除访问权限。</p><h2 id="129-解决方案架构师正在设计一个-Lambda-函数，该函数调用-API-来列出所有正在运行的-Amazon-RDS-实例。请求应如何授权？"><a href="#129-解决方案架构师正在设计一个-Lambda-函数，该函数调用-API-来列出所有正在运行的-Amazon-RDS-实例。请求应如何授权？" class="headerlink" title="129.解决方案架构师正在设计一个 Lambda 函数，该函数调用 API 来列出所有正在运行的 Amazon RDS 实例。请求应如何授权？"></a>129.解决方案架构师正在设计一个 Lambda 函数，该函数调用 API 来列出所有正在运行的 Amazon RDS 实例。请求应如何授权？</h2><p><strong>A</strong>. Create an IAM access and secret key, and store it in the Lambda function<br>.创建 IAM 访问密钥和私有密钥，并将其存储在 Lambda 函数中</p><p><strong>B</strong>. Assign an IAM role to the Lambda function with permissions to list all Amazon RDS instances.<br>.向 Lambda 函数分配一个 IAM 角色，该角色有权列出所有 Amazon RDS 实例。</p><p><strong>C</strong>. Assign an IAM role to Amazon RDS with permissions to list all Amazon RDS instances.<br>.向 Amazon RDS 分配一个 IAM 角色，该角色有权列出所有 Amazon RDS 实例。</p><p><strong>D</strong>. Create an IAM access and secret key and store it in an encrypted RDS database.<br>.创建 IAM 访问密钥和私有密钥，并将其存储在加密的 RDS 数据库中。</p><p>正确答案是 B，因为 Lambda 函数需要分配一个具有列出 RDS 实例权限的角色，请参阅 AWS 文档 - Lambda 权限，每个 Lambda 函数都有一个与之关联的 IAM 角色（执行角色）。您可以在创建 Lambda 函数时指定 IAM 角色。您授予此角色的权限决定了 AWS Lambda 在代入该角色时可以执行的操作。您向 IAM 角色授予的权限有两种类型：选项 A 是错误的，因为不建议使用访问密钥，选项 C 是错误的，因为权限应该授予 Lambda 实例而不是 RDS，选项 D 是错误的，因为不建议使用访问密钥，并且 Lambda 也需要引用 RDS 实例的权限。</p><h2 id="130-一家公用事业公司正在构建一个应用程序，用于存储来自-10-000-多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用-Amazon-DynamoDB-的可扩展性和快速性，您如何以最经济高效的方式实施它？"><a href="#130-一家公用事业公司正在构建一个应用程序，用于存储来自-10-000-多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用-Amazon-DynamoDB-的可扩展性和快速性，您如何以最经济高效的方式实施它？" class="headerlink" title="130.一家公用事业公司正在构建一个应用程序，用于存储来自 10,000 多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用 Amazon DynamoDB 的可扩展性和快速性，您如何以最经济高效的方式实施它？"></a>130.一家公用事业公司正在构建一个应用程序，用于存储来自 10,000 多个传感器的数据。该公司希望非常快速地查询过去一周来自特定传感器的信息，之后一周内不经常访问该数据。然后需要对数据进行存档。使用 Amazon DynamoDB 的可扩展性和快速性，您如何以最经济高效的方式实施它？</h2><p><strong>A</strong>. Create tables for each week. Move the data to S3 for archival and delete the old tables<br>.为每周创建表格。将数据移动到 S3 进行存档并删除旧表</p><p><strong>B</strong>. Create tables for each week with the current week configured for higher throughput. Move the data to Glacier for archival and delete the old tables<br>.为每周创建表，并将当前周配置为更高的吞吐量。将数据移动到 Glacier 进行存档并删除旧表</p><p><strong>C</strong>. Create a single table for higher throughput. Move the data to S3 for archival.<br>.创建单个表以提高吞吐量。将数据移动到 S3 进行存档。</p><p><strong>D</strong>. Create a single table for higher throughput. Move the data to Glacier for archival.<br>.创建单个表以提高吞吐量。将数据移动到 Glacier 进行存档。</p><p>正确答案是 B，因为每周的数据提取模式都不同，因此最好为每周定义不同的 DynamoDB 表，并配置当前周更高的预置吞吐量。然后可以将数据移动到 Glacier 并删除旧的 DynamoDB 表，选项 A 是错误的，因为当前一周的表吞吐量需要配置得更高，而 S3 不是存档的理想解决方案，选项 C 和 D 是错误的，因为单个表不会执行并且旧数据不会被删除。</p><h2 id="131-一家公司已启用-CloudTrail-记录其-AWS-账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择-2-个答案"><a href="#131-一家公司已启用-CloudTrail-记录其-AWS-账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择-2-个答案" class="headerlink" title="131.一家公司已启用 CloudTrail 记录其 AWS 账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择 2 个答案"></a>131.一家公司已启用 CloudTrail 记录其 AWS 账户以进行审计。此外，IT安全部门还提到，日志需要加密，并采取措施检查日志是否被修改。如何实现这一目标？选择 2 个答案</h2><p><strong>A</strong>. Enable SSL certificates for the CloudTrail logs.</p><p><strong>B</strong>. CloudTrail, by default, encrypts the logs in S3<br>.默认情况下，CloudTrail 对 S3 中的日志进行加密</p><p><strong>C</strong>. Enable Server-Side Encryption for the trail.<br>.为跟踪启用服务器端加密。</p><p><strong>D</strong>. Enable CloudTrail Log File Integrity Validation.<br>.启用 CloudTrail 日志文件完整性验证。</p><p><strong>E</strong>. Enable Server-Side Encryption for the destination S3 bucket.<br>.为目标 S3 存储桶启用服务器端加密。</p><p><strong>F</strong>. Enable CloudTrail Log File Durability Validation.<br>.启用 CloudTrail 日志文件持久性验证。</p><p>正确答案是 B &amp; D，因为存储在 S3 中的 CloudTrail 日志由 AWS 使用服务器端加密进行加密。CloudTrail 还提供日志文件完整性验证功能，以帮助确定日志是否被篡改，请参阅 AWS 文档 - CloudTrail 加密和日志文件完整性验证，默认情况下，CloudTrail 传输到存储桶的日志文件由 Amazon 服务器端加密和 Amazon S3 托管加密密钥 （SSE-S3） 进行加密，以确定日志文件是否被修改， 在 CloudTrail 交付后删除或保持不变，您可以使用 CloudTrail 日志文件完整性验证。此功能是使用行业标准算法构建的：用于哈希的 SHA-256 和用于数字签名的带有 RSA 的 SHA-256。这使得在不检测的情况下修改、删除或伪造 CloudTrail 日志文件在计算上是不可行的。您可以使用 AWS CLI 在 CloudTrail 传输文件的位置验证文件。</p><h2 id="132-解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个-Linux-应用程序使用。哪些服务符合此要求？"><a href="#132-解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个-Linux-应用程序使用。哪些服务符合此要求？" class="headerlink" title="132.解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个 Linux 应用程序使用。哪些服务符合此要求？"></a>132.解决方案架构师正在构建一个工作负载，该工作负载需要一个高度可用且可扩展的共享块文件存储系统，该系统必须由多个 Linux 应用程序使用。哪些服务符合此要求？</h2><p><strong>A</strong>. Amazon EFS</p><p><strong>B</strong>. Amazon S3</p><p><strong>C</strong>. AWS Storage Gateway</p><p><strong>D</strong>. Amazon EBS</p><p>正确答案是 A，因为 EFS 提供了一个 AWS 托管且可扩展且高度可用的共享文件系统，请参阅 AWS 文档 - EFS，Amazon Elastic File System （Amazon EFS） 提供简单、可扩展、弹性的文件存储，用于 AWS 云服务和本地资源。它易于使用，并提供了一个简单的界面，可让您快速轻松地创建和配置文件系统。Amazon EFS 旨在在不中断应用程序的情况下按需弹性扩展，并在您添加和删除文件时自动扩展和收缩，因此您的应用程序在需要时拥有所需的存储。它旨在提供对数千个 Amazon EC2 实例的大规模并行共享访问，使您的应用程序能够实现高水平的聚合吞吐量和 IOPS，并随着文件系统的增长而扩展，并具有一致的低延迟。作为一项区域性服务，Amazon EFS 旨在实现跨多个可用区冗余存储数据的高可用性和持久性，借助这些功能，Amazon EFS 非常适合支持广泛的使用案例，包括 Web 服务和内容管理、企业应用程序、媒体和娱乐处理工作流、主目录、数据库备份、开发人员工具、容器存储、 和大数据分析工作负载，选项 B 是错误的，因为 S3 是基于对象的存储，选项 C 是错误的，因为 AWS Storage Gateway 是一种混合存储服务，使您的本地应用程序能够无缝使用 AWS 云存储。您可以将该服务用于备份和归档、灾难恢复、云数据处理、存储分层和迁移，选项 D 是错误的，因为 EBS 卷不能在多个实例之间共享。</p><h2 id="171-一家公司托管一个流行的-Web-应用程序。Web-应用程序连接到在私有-VPC-子网中运行的数据库。Web-服务器必须只能由通过-SSL-连接的客户访问。RDS-MySQL-数据库服务器必须只能从-Web-服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。"><a href="#171-一家公司托管一个流行的-Web-应用程序。Web-应用程序连接到在私有-VPC-子网中运行的数据库。Web-服务器必须只能由通过-SSL-连接的客户访问。RDS-MySQL-数据库服务器必须只能从-Web-服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。" class="headerlink" title="171.一家公司托管一个流行的 Web 应用程序。Web 应用程序连接到在私有 VPC 子网中运行的数据库。Web 服务器必须只能由通过 SSL 连接的客户访问。RDS MySQL 数据库服务器必须只能从 Web 服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。"></a>171.一家公司托管一个流行的 Web 应用程序。Web 应用程序连接到在私有 VPC 子网中运行的数据库。Web 服务器必须只能由通过 SSL 连接的客户访问。RDS MySQL 数据库服务器必须只能从 Web 服务器访问。解决方案架构师应如何在不影响正在运行的应用程序的情况下设计解决方案以满足要求。</h2><p><strong>A</strong>. Create a network ACL on the web server’s subnet and allow HTTPS inbound and MySQL outbound. Place both database and web servers on the same subnet.<br>.在 Web 服务器的子网上创建网络 ACL，并允许 HTTPS 入站和 MySQL 出站。将数据库服务器和 Web 服务器放在同一个子网上。</p><p><strong>B</strong>. Open an HTTPS port on the security group for web servers and set the source to 0.0.0.0/0. Open the MySQL port on the database security group and attach it to the MySQL instance. Set the source to Web Server Security Group.<br>.在Web服务器的安全组上打开HTTPS端口，并将源设置为0.0.0.0/0。打开数据库安全组上的 MySQL 端口，并将其附加到 MySQL 实例。将源设置为“Web 服务器安全组”。</p><p><strong>C</strong>. Create a network ACL on the web server’s subnet, allow HTTPS inbound, and specify the source as 0.0.0.0/0. Create a network ACL on a database subnet, allow MySQL port inbound for web servers, and deny all outbound traffic.<br>.在 Web 服务器的子网上创建网络 ACL，允许 HTTPS 入站，并将源指定为 0.0.0.0/0。在数据库子网上创建网络 ACL，允许 Web 服务器的 MySQL 端口入站，并拒绝所有出站流量。</p><p><strong>D</strong>. Open the MySQL port on the security group for web server and set the source to 0.0.0.0/0. Open the HTTPS port on the database security group and attach it to the MySQL instance. Set the source to Web Server Security Group.<br>.在Web服务器的安全组上打开MySQL端口，并将源设置为0.0.0.0/0。打开数据库安全组上的 HTTPS 端口并将其附加到 MySQL 实例。将源设置为“Web 服务器安全组”。</p><p>正确答案是B，因为Web服务器需要在HTTPS上向Internet开放，而MySQL数据库需要打开才能仅接受来自Web服务器的连接，请参阅AWS文档-安全规则参考，Web安全规则，数据库安全规则，选项A是错误的，因为<strong>ACL是无状态的，需要同时启用入站和出站。</strong>选项C是错误的，因为ACL是无状态的，数据库子网需要允许出站流量，选项D是错误的，因为配置相反。MySQL端口需要在DB安全组上打开，HTTPS端口需要在Web服务器安全组上打开。</p><h2 id="172-以下哪项需要自定义-CloudWatch-指标才能监控？"><a href="#172-以下哪项需要自定义-CloudWatch-指标才能监控？" class="headerlink" title="172.以下哪项需要自定义 CloudWatch 指标才能监控？"></a>172.以下哪项需要自定义 CloudWatch 指标才能监控？</h2><p><strong>A</strong>. Memory Utilization of an EC2 instance</p><p><strong>B</strong>. CPU Utilization of an EC2 instance</p><p><strong>C</strong>. Disk usage activity of an EC2 instance<br>.EC2 实例的磁盘使用活动</p><p><strong>D</strong>. Data transfer of an EC2 instance</p><p>正确答案是 A，因为内存利用率没有被捕获，并且需要为内存利用率实现相同的脚本，请参阅 AWS 文档 - 监控 EC2，CloudWatch 依赖于此管理程序提供的信息，它只能看到实例状态的最硬件端部分，包括 CPU 使用率（但不包括负载）、总内存大小（但不包括内存使用率）、 硬盘上的 I/O 操作数（但不是分区布局和空间使用情况）和网络流量（但不是生成它的进程）。</p><h2 id="173-您正在-VPC-内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择-2-个答案"><a href="#173-您正在-VPC-内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择-2-个答案" class="headerlink" title="173.您正在 VPC 内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择 2 个答案"></a>173.您正在 VPC 内部设计安全性。您正在考虑建立单独的安全区域和跨不同区域实施网络流量规则以限制实例可以通信的选项。您将如何实现这些要求？选择 2 个答案</h2><p><strong>A</strong>. Configure a security group for every zone. Configure a default allow all rule. Configure explicit deny rules for the zones that shouldn’t be able to communicate with one another<br>.为每个可用区配置一个安全组。配置默认的“全部允许”规则。为不应能够相互通信的区域配置显式拒绝规则</p><p><strong>B</strong>. Configure your instances to use pre-set IP addresses with an IP address range every security zone. Configure NACL to explicitly allow or deny communication between the different IP address ranges, as required for interzone communication<br>.将您的实例配置为使用预设的 IP 地址，每个安全区域都有一个 IP 地址范围。将 NACL 配置为显式允许或拒绝不同 IP 地址范围之间的通信，这是区域间通信的需要</p><p><strong>C</strong>. Configure a security group for every zone. Configure allow rules only between zone that need to be able to communicate with one another. Use implicit deny all rule to block any other traffic<br>.为每个可用区配置一个安全组。仅在需要能够相互通信的区域之间配置允许规则。使用隐式全部拒绝规则阻止任何其他流量</p><p><strong>D</strong>. Configure multiple subnets in your VPC, one for each zone. Configure routing within your VPC in such a way that each subnet only has routes to other subnets with which it needs to communicate, and doesn’t have routes to subnets with which it shouldn’t be able to communicate.<br>.在 VPC 中配置多个子网，每个区域一个子网。在 VPC 中配置路由，使每个子网只有到需要与之通信的其他子网的路由，并且没有到不应与之通信的子网的路由。</p><p>正确答案是 B 和 C，因为可以使用区域中所有实例的安全组或区域级别的 NACL 来控制通信，请参阅 AWS 文档 - VPC 安全性，选项 B 作为 NACL 可用于配置具有 IP 地址的规则以允许或拒绝流量，选项 C 作为安全组可以获取 IP 地址或安全组并可以允许它们。默认值为隐式拒绝，选项 A 错误，因为安全组不允许拒绝规则，选项 D 错误，因为默认路由不可修改，无法使用路由表来确定 VPC 中子网之间的路由。在 VPC 中，所有子网都可以从同一 VPC 中的所有其他子网访问。这是默认行为，无法更改。</p><h2 id="174-您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择-2-个答案"><a href="#174-您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择-2-个答案" class="headerlink" title="174.您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择 2 个答案"></a>174.您的公司正朝着跟踪网页用户的方向发展，每个页面上都加载了一个小型跟踪图像。目前，您正在从美国东部提供此映像，但开始担心为西海岸的用户加载映像所需的时间。加快提供此图像的两种最佳方法是什么？选择 2 个答案</h2><p><strong>A</strong>. Use Route 53’s Latency Based Routing and serve the image out of us-west-2 as well as us-east-1<br>.使用 Route 53 的基于延迟的路由，并从 us-west-2 和 us-east-1 中提供映像</p><p><strong>B</strong>. Serve the image out through CloudFront<br>.通过 CloudFront 提供映像</p><p><strong>C</strong>. Serve the image out of S3 so that it isn’t being served out of your web application tier<br>.从 S3 中提供映像，以便它不会从 Web 应用程序层中提供</p><p><strong>D</strong>. Use EBS PIOPs to serve the image faster out of your EC2 instances<br>.使用 EBS PIOP 更快地从 EC2 实例中提供映像</p><p>正确答案是 A 和 B，因为基于 Route 53 延迟的路由可以帮助将用户请求路由到延迟最小的服务器，并且使用 CloudFront，请求可以通过全球边缘站点分发</p><h2 id="175-一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从-Amazon-EC2-实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达-500MB-s。哪种存储类型可以满足此应用程序的性能要求？"><a href="#175-一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从-Amazon-EC2-实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达-500MB-s。哪种存储类型可以满足此应用程序的性能要求？" class="headerlink" title="175.一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从 Amazon EC2 实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达 500MB/s。哪种存储类型可以满足此应用程序的性能要求？"></a>175.一位解决方案架构师正在为一家媒体公司设计一个解决方案，该解决方案将从 Amazon EC2 实例流式传输大量数据。数据流通常很大且连续，并且必须能够支持高达 500MB/s。哪种存储类型可以满足此应用程序的性能要求？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS General Purpose SSD</p><p><strong>C</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p><strong>D</strong>. EBS Throughput Optimized HDD</p><p>正确答案是 D，因为吞吐量优化型 HDD 为大型顺序数据提供了理想的存储解决方案，支持 500 miB/s 的吞吐量，请参阅 AWS 文档 - EBS 卷类型，吞吐量优化型 HDD （st1） 卷提供低成本的磁性存储，根据吞吐量而不是 IOPS 来定义性能。此卷类型非常适合大型顺序工作负载，例如 Amazon EMR、ETL、数据仓库和日志处理。不支持可启动的 st1 卷，吞吐量优化的 HDD （st1） 卷虽然类似于 Cold HDD （sc1） 卷，但旨在支持频繁访问的数据，此卷类型针对涉及大型顺序 I/O 的工作负载进行了优化，我们建议工作负载执行小型随机 I/O 的客户使用 gp2</p><h2 id="176-移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？"><a href="#176-移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？" class="headerlink" title="176.移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？"></a>176.移动客户端需要来自多个应用层服务的数据来填充其用户界面。应用程序团队可以使用什么来将客户端接口与其背后的底层服务分离？</h2><p><strong>A</strong>. Application Load Balancer</p><p><strong>B</strong>. Amazon API Gateway</p><p><strong>C</strong>. Amazon Cognito</p><p><strong>D</strong>. AWS Device Farm</p><p>正确答案是 B，因为 API Gateway 可以为应用程序提供单点接口，以提供与底层服务的松散耦合，请参阅 AWS 文档 - AWS 上的微服务，使用 API Gateway，您可以创建一个 API，充当应用程序从后端服务访问数据、业务逻辑或功能的“前门”， 例如在 Amazon EC2 和 Amazon ECS 上运行的工作负载、在 Lambda 上运行的代码或任何 Web 应用程序。使用 API Gateway 服务定义的 API 对象是一组资源和方法。资源是 API 域中的类型化对象，可能已将数据模型或关系关联到其他资源。可以将每个资源配置为响应一个或多个方法，即标准 HTTP 谓词，如 GET、POST 或 PUT。REST API 可以部署到不同的阶段、版本化以及克隆到新版本，选项 A 是错误的，因为 Application Load Balancer 无助于跨多个底层服务解耦，选项 C 是错误的，因为 Amazon Cognito 允许您快速轻松地向 Web 和移动应用程序添加用户注册、登录和访问控制。Amazon Cognito 可扩展到数百万用户，并支持通过 SAML 2.0 登录社交身份提供商（如 Facebook、Google 和 Amazon）和企业身份提供商，选项 D 是错误的，因为 AWS Device Farm 是一项应用程序测试服务，可让您同时在多个设备上测试 Android、iOS 和 Web 应用程序并与之交互， 或在设备上实时重现问题。</p><h2 id="关于对存储在数据库（即-Amazon-RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案"><a href="#关于对存储在数据库（即-Amazon-RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案" class="headerlink" title="关于对存储在数据库（即 Amazon RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案"></a>关于对存储在数据库（即 Amazon RDS）上的数据进行加密，以下哪项陈述是正确的？从以下选项中选择正确答案</h2><p><strong>A</strong>. Encryption cannot be enabled on RDS instances unless the keys are not managed by KMS.<br>.除非密钥不受 KMS 管理，否则无法在 RDS 实例上启用加密。</p><p><strong>B</strong>. Encryption can be enabled on RDS instances to encrypt the underlying storage, and this will by default also encrypt snapshots as they are created. No additional configuration needs to be made on the client side for this to work.<br>.可以在 RDS 实例上启用加密来加密底层存储，默认情况下，这也会在创建快照时对其进行加密。无需在客户端进行其他配置即可正常工作。</p><p><strong>C</strong>. Encryption can be enabled on RDS instances to encrypt the underlying storage, and this will by default also encrypt snapshots as they are created. However, some additional configuration needs to be made on the client side for this to work.<br>.可以在 RDS 实例上启用加密来加密底层存储，默认情况下，这也会在创建快照时对其进行加密。但是，需要在客户端进行一些额外的配置才能正常工作。</p><p><strong>D</strong>. Encryption can be enabled on RDS instances to encrypt the underlying storage, but you cannot encrypt snapshots as they are created.<br>.可以在 RDS 实例上启用加密来加密底层存储，但您不能在创建快照时对其进行加密。</p><h2 id="179-您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？"><a href="#179-您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？" class="headerlink" title="179.您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？"></a>179.您正在设计一种架构，该架构可以非常快速地从灾难中恢复，同时将最终用户的停机时间降至最低。以下哪种方法最好？</h2><p><strong>A</strong>. Leverage Route 53 health checks to automatically fail over to backup site when the primary site becomes unreachable<br>.利用 Route 53 运行状况检查，在主站点无法访问时自动故障转移到备份站点</p><p><strong>B</strong>. Implement the Pilot Light DR architecture so that traffic can be processed seamlessly in case the primary site becomes unreachable<br>.实施 Pilot Light DR 架构，以便在主站点无法访问时可以无缝处理流量</p><p><strong>C</strong>. Implement either Fully Working Low Capacity Standby or Multi-site Active-Active architecture so that the end users will not experience any delay even if the primary site becomes unreachable<br>.实施完全工作的低容量备用或多站点主动-主动体系结构，以便即使主站点无法访问，最终用户也不会遇到任何延迟</p><p><strong>D</strong>. Implement multi-region architecture to ensure high availability<br>.实施多区域架构，确保高可用性</p><p>正确答案是 C，因为要求是没有任何成本限制的最短停机时间灾难恢复，因此最好实施暖备用或多站点双活实施，请参阅 AWS 博客灾难恢复或白皮书</p><h2 id="180-应用程序在单个-AWS-区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种-AWS-服务符合要求？"><a href="#180-应用程序在单个-AWS-区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种-AWS-服务符合要求？" class="headerlink" title="180.应用程序在单个 AWS 区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种 AWS 服务符合要求？"></a>180.应用程序在单个 AWS 区域中运行。业务团队添加了在第二个区域中运行应用程序的要求，以实现多区域高可用性。解决方案架构师需要将流量分发到多个区域以实现高可用性。哪种 AWS 服务符合要求？</h2><p><strong>A</strong>. Amazon Route 53</p><p><strong>B</strong>. Elastic Load Balancing</p><p><strong>C</strong>. Amazon CloudFront .亚马逊 CloudFront</p><p><strong>D</strong>. Amazon S3 Website hosting.</p><p>正确答案是 A，因为 Route 53 是 AWS 托管的 DNS 服务。它是全局的，可以配置为跨多个区域路由流量，并能够进行运行状况检查和故障转移路由。它还支持主动-主动或主动-被动路由，选项 B 是错误的，因为 ELB 不能跨区域，选项 C 是错误的，因为 CloudFront 仅允许跨边缘站点进行缓存和渲染，选项 D 是错误的，因为 S3 是区域性的，无助于跨区域路由流量。</p><h2 id="181-您有一个业务关键型两层-Web-应用程序，目前部署在单个区域的两个可用区中，使用-Elastic-Load-Balancing-和-Auto-Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且-Auto-Scaling-无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？"><a href="#181-您有一个业务关键型两层-Web-应用程序，目前部署在单个区域的两个可用区中，使用-Elastic-Load-Balancing-和-Auto-Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且-Auto-Scaling-无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？" class="headerlink" title="181.您有一个业务关键型两层 Web 应用程序，目前部署在单个区域的两个可用区中，使用 Elastic Load Balancing 和 Auto Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且 Auto Scaling 无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？"></a>181.您有一个业务关键型两层 Web 应用程序，目前部署在单个区域的两个可用区中，使用 Elastic Load Balancing 和 Auto Scaling。应用依赖于数据库层的同步复制（非常低延迟的连接）。即使一个应用程序可用区脱机，应用程序也需要保持完全可用，并且 Auto Scaling 无法在其余可用区中启动新实例。如何增强当前的架构来确保这一点？</h2><p><strong>A</strong>. Deploy in two regions using Weighted Round Robin (WRR), with Auto Scaling minimums set for 100% peak load per region.<br>.使用加权轮询 （WRR） 在两个区域进行部署，并将 Auto Scaling 最小值设置为每个区域 100% 的峰值负载。</p><p><strong>B</strong>. Deploy in three AZs, with Auto Scaling minimum set to handle 50% peak load per zone.<br>.部署在三个可用区中，Auto Scaling 最小值设置为处理每个区域 50% 的峰值负载。</p><p><strong>C</strong>. Deploy in three AZs, with Auto Scaling minimum set to handle 33% peak load per zone.<br>.在三个可用区中部署，将 Auto Scaling 最小值设置为处理每个区域 33% 的峰值负载。</p><p><strong>D</strong>. Deploy in two regions using Weighted Round Robin (WRR), with Auto Scaling minimums set for 50% peak load per region.<br>.使用加权轮询 （WRR） 在两个区域进行部署，并将 Auto Scaling 最小值设置为每个区域 50% 的峰值负载。</p><p>正确答案是 B 作为 3 个可用区，每个可用区有 50%，即使其中一个关闭并且自动扩展无法启动任何实例，50% + 50% LB 处理所有负载，选项 C 是错误的，因为它每个提供 33%，如果一个关闭，其余两个将处理 66% 的负载，选择 A 和 D 是错误的，因为 WRR 需要 Route 53。数据库还需要低延迟的同步复制，这是行不通的。此外，对于 D 来说，50% 不会以任何方式起作用</p><h2 id="182-您正在-AWS-上构建一个大型机密文档-Web-服务器，其所有文档都将存储在-S3-上。其中一项要求是不能直接从-S3-公开访问它，您需要使用-CloudFront-来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案"><a href="#182-您正在-AWS-上构建一个大型机密文档-Web-服务器，其所有文档都将存储在-S3-上。其中一项要求是不能直接从-S3-公开访问它，您需要使用-CloudFront-来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案" class="headerlink" title="182.您正在 AWS 上构建一个大型机密文档 Web 服务器，其所有文档都将存储在 S3 上。其中一项要求是不能直接从 S3 公开访问它，您需要使用 CloudFront 来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案"></a>182.您正在 AWS 上构建一个大型机密文档 Web 服务器，其所有文档都将存储在 S3 上。其中一项要求是不能直接从 S3 公开访问它，您需要使用 CloudFront 来实现此目的。下面列出的哪种方法可以满足概述的要求？从以下选项中选择一个答案</h2><p><strong>A</strong>. Create an Identity and Access Management (IAM) user for CloudFront and grant access to the objects in your S3 bucket to that IAM User.<br>.为 CloudFront 创建 Identity and Access Management （IAM） 用户，并向该 IAM 用户授予对 S3 存储桶中对象的访问权限。</p><p><strong>B</strong>. Create an Origin Access identity (OAI) for Cloud Front and grant access to the objects in your S3 bucket to that OAl.<br>.为 Cloud Front 创建源访问身份 （OAI），并向该 OAl 授予对 S3 存储桶中对象的访问权限。</p><p><strong>C</strong>. Create individual policies for each bucket the documents are stored in and in that policy grant access to only CloudFront.<br>.为存储文档的每个存储桶创建单独的策略，并在该策略中仅授予对 CloudFront 的访问权限。</p><p><strong>D</strong>. Create an S3 bucket policy that lists the CloudFront distribution ID as the Principal and the target bucket as the Amazon Resource Name (ARN).<br>.创建一个 S3 存储桶策略，将 CloudFront 分配 ID 列为委托人，将目标存储桶列为 Amazon 资源名称 （ARN）</p><p>请参考 AWS CloudFront 限制对 S3 的访问，正确答案是 B，源访问身份是与分配关联的特殊 CloudFront 用户。对于 Web 分配，它与 S3 相关联。OAI 允许在不公开 S3 内容的情况下公开内容，选项 A、C 和 D 是错误的，因为它们允许 S3 允许对 CloudFront 进行独占访问，而 CloudFront 能够分发内容。</p><p>请参考 AWS CloudFront 限制对 S3 的访问，正确答案是 B，源访问身份是与分配关联的特殊 CloudFront 用户。对于 Web 分配，它与 S3 相关联。OAI 允许在不公开 S3 内容的情况下公开内容，选项 A、C 和 D 是错误的，因为它们允许 S3 允许对 CloudFront 进行独占访问，而 CloudFront 能够分发内容。</p><h2 id="183-解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？"><a href="#183-解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？" class="headerlink" title="183.解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？"></a>183.解决方案架构师正在创建一个新的关系数据库。合规性将使用关键数据，并要求数据内容必须存储在三个不同的可用区中。架构师应使用以下哪个选项？</h2><p><strong>A</strong>. Amazon Aurora .亚马逊极光</p><p><strong>B</strong>. Amazon RDS MySQL with Multi-AZ enabled.<br>.启用了多可用区的 Amazon RDS MySQL。</p><p><strong>C</strong>. Amazon DynamoDB .Amazon DynamoDB</p><p><strong>D</strong>. Amazon ElastiCache .Amazon Elasti缓存</p><p>正确答案是 A，因为 Amazon Aurora 通过跨 3 个可用区复制数据并执行数据完整性检查来维护 6 个副本来提供高持久性，请参阅 AWS 文档 - RDS Aurora 常见问题，问：Amazon Aurora 如何提高数据库对磁盘故障的容错能力？，Amazon Aurora 会自动将您的数据库卷划分为 10GB 的段，分布在多个磁盘上。数据库卷的每个 10GB 数据块在三个可用区之间以六种方式进行复制。Amazon Aurora 旨在透明地处理最多两个数据副本的丢失，而不会影响数据库写入可用性，以及最多三个副本的丢失，而不会影响读取可用性。Amazon Aurora 存储还具有自我修复功能。数据块和磁盘会持续扫描错误并自动修复，选项 B 是错误的，因为多可用区 RDS，数据只在 2 个可用区之间复制，选项 C 和 D 是错误的，因为它们不是关系型数据库。</p><h2 id="184-管理员在单个Amazon-EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon-EC2实例分离？"><a href="#184-管理员在单个Amazon-EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon-EC2实例分离？" class="headerlink" title="184.管理员在单个Amazon EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon EC2实例分离？"></a>184.管理员在单个Amazon EC2实例上托管应用程序，用户可以通过公有主机名访问该实例，管理员正在添加第二个实例，但不希望用户在多个公共主机名之间做出决定。哪种AWS服务会将用户与特定Amazon EC2实例分离？</h2><p><strong>A</strong>. Amazon ELB .Amazon ELB</p><p><strong>B</strong>. Auto Scaling Group<br>.Auto Scaling 组</p><p><strong>C</strong>. Amazon EC2 Security Group<br>.Amazon EC2 安全组</p><p><strong>D</strong>. Amazon SQS .亚马逊 SQS</p><p>正确答案是 A，因为 Elastic Load Balancer 可以帮助为多个底层 EC2 实例提供单个访问点，请参阅 AWS 文档 - ELB，负载均衡器接受来自客户端的传入流量，并将请求路由到一个或多个可用区中的注册目标（例如 EC2 实例）。负载均衡器还会监控其已注册目标的运行状况，并确保它仅将流量路由到正常运行的目标。当负载均衡器检测到运行状况不佳的目标时，它会停止将流量路由到该目标，然后在检测到目标再次正常运行时继续将流量路由到该目标。选项 B 是错误的，因为 Auto Scaling 有助于扩展但不会提供单个访问点，选项 C 是错误的，因为 EC2 安全组充当控制一个或多个实例流量的虚拟防火墙。选项 D 是错误的，因为 SQS 提供完全托管的消息队列服务。</p><h2 id="185-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"><a href="#185-客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？" class="headerlink" title="185.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？"></a>185.客户端应用程序需要关系数据库服务器上的操作系统特权。什么是高可用性数据库体系结构的适当配置？</h2><p><strong>A</strong>. A standalone Amazon EC2 instance<br>.独立 Amazon EC2 实例</p><p><strong>B</strong>. Amazon RDS in a Multi-AZ configuration<br>.多可用区配置中的 Amazon RDS</p><p><strong>C</strong>. Amazon EC2 instances in a replication configuration utilizing a single Availability Zone<br>.使用单个可用区的复制配置中的 Amazon EC2 实例</p><p><strong>D</strong>. Amazon EC2 instances in a replication configuration utilizing two different Availability Zones<br>.使用两个不同可用区的复制配置中的 Amazon EC2 实例</p><p>这里的关键点是设计一个具有操作系统权限的 HA 解决方案数据库解决方案，正确答案是 D，因为 RDS 是 AWS 的托管服务，它不提供操作系统权限，并且对于 HA，至少需要在 2 个可用区中存在实例，选项 A 是错误的，因为单个实例不提供 HA，选项 B 是错误的，因为 RDS 不提供操作系统权限，选项 C 是错误的，因为单个可用区不提供 HA</p><h2 id="186-你需要一种解决方案，以便在Amazon-ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。"><a href="#186-你需要一种解决方案，以便在Amazon-ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。" class="headerlink" title="186.你需要一种解决方案，以便在Amazon ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。"></a>186.你需要一种解决方案，以便在Amazon ECS上运行的任务的所有容器之间均匀分配流量。任务定义为容器定义动态主机端口映射。哪些AWS功能在功能上提供此功能。</h2><p><strong>A</strong>. Application Load Balancers support dynamic host port mapping.<br>.Application Load Balancer 支持动态主机端口映射。</p><p><strong>B</strong>. CloudFront custom origins support dynamic host port mapping.<br>.CloudFront 自定义源支持动态主机端口映射。</p><p><strong>C</strong>. All Elastic Load Balancing instances support dynamic host port mapping.<br>.所有 Elastic Load Balancing 实例都支持动态主机端口映射。</p><p><strong>D</strong>. Classic Load Balancers support dynamic host port mapping.<br>.Classic Load Balancer 支持动态主机端口映射。</p><p>正确答案是 A，因为 Application Load Balancer 有助于动态端口映射并在多个 ECS 容器之间均匀分配流量，请参阅 AWS 知识文章 - ECS 动态端口映射，使用 Application Load Balancer 的动态端口映射可以更轻松地从 ECS 集群上的同一 ECS 服务运行多个任务，Classic Load Balancer 要求您在容器实例上静态映射端口号。您不能在同一实例上运行任务的多个副本，因为端口会发生冲突。Application Load Balancer 允许动态端口映射。您可以在同一容器实例上拥有来自单个服务的多个任务。</p><h2 id="187-一家公司要求其开发人员将应用程序日志存储在-S3-存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？"><a href="#187-一家公司要求其开发人员将应用程序日志存储在-S3-存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？" class="headerlink" title="187.一家公司要求其开发人员将应用程序日志存储在 S3 存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？"></a>187.一家公司要求其开发人员将应用程序日志存储在 S3 存储桶中。这些日志仅在一段时间内是必需的，之后可以将其删除。以下哪个步骤可用于有效管理此问题？</h2><p><strong>A</strong>. Create a cron job to detect the stale logs and delete them accordingly.<br>.创建一个 cron 作业来检测过时的日志并相应地删除它们。</p><p><strong>B</strong>. Use a bucket policy to manage the deletion.<br>.使用存储桶策略管理删除操作。</p><p><strong>C</strong>. Use an IAM Policy to manage the deletion.<br>.使用 IAM 策略管理删除操作。</p><p><strong>D</strong>. Use S3 Lifecycle Policies to manage the deletion.<br>.使用 S3 生命周期策略管理删除。</p><p>正确答案是 D，因为 S3 对象生命周期管理有助于在存储类和过期之间自动转换对象，请参阅 AWS 文档 - S3 对象生命周期管理，要管理您的对象，以便在整个生命周期内经济高效地存储它们，请配置它们的生命周期。生命周期配置是一组规则，用于定义 Amazon S3 应用于一组对象的操作。有两种类型的操作：选项A是错误的，尽管可能不具有成本效益，因为它需要实例轮询S3来检查过期项目并删除它们，选项B和C是错误的，因为它们允许对S3存储桶和对象进行访问控制。</p><h2 id="188-您有一个在六个-Amazon-EC2-实例上运行的-Web-应用程序，每个实例消耗大约-45-的资源。您正在使用自动扩展来确保-6-个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的-Amazon-系统映像-（AMI）。您应该做出以下哪项体系结构选择？"><a href="#188-您有一个在六个-Amazon-EC2-实例上运行的-Web-应用程序，每个实例消耗大约-45-的资源。您正在使用自动扩展来确保-6-个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的-Amazon-系统映像-（AMI）。您应该做出以下哪项体系结构选择？" class="headerlink" title="188.您有一个在六个 Amazon EC2 实例上运行的 Web 应用程序，每个实例消耗大约 45% 的资源。您正在使用自动扩展来确保 6 个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的 Amazon 系统映像 （AMI）。您应该做出以下哪项体系结构选择？"></a>188.您有一个在六个 Amazon EC2 实例上运行的 Web 应用程序，每个实例消耗大约 45% 的资源。您正在使用自动扩展来确保 6 个实例始终处于运行状态。此应用程序处理的请求数是一致的，不会出现峰值。该应用程序对您的业务至关重要，您希望始终保持高可用性。您希望负载在所有实例之间均匀分布。您还希望对所有实例使用相同的 Amazon 系统映像 （AMI）。您应该做出以下哪项体系结构选择？</h2><p><strong>A</strong>. Deploy 6 EC2 instances in one availability zone and use Amazon Elastic Load Balancer.<br>.在一个可用区中部署 6 个 EC2 实例并使用 Amazon Elastic Load Balancer。</p><p><strong>B</strong>. Deploy 3 EC2 instances in one region and 3 in another region and use Amazon Elastic Load Balancer.<br>.在一个区域部署 3 个 EC2 实例，在另一个区域部署 3 个实例，并使用 Amazon Elastic Load Balancer。</p><p><strong>C</strong>. Deploy 3 EC2 instances in one availability zone and 3 in another availability zone and use Amazon Elastic Load Balancer.<br>.在一个可用区中部署 3 个 EC2 实例，在另一个可用区中部署 3 个 EC2 实例，并使用 Amazon Elastic Load Balancer。</p><p><strong>D</strong>. Deploy 2 EC2 instances in three regions and use Amazon Elastic Load Balancer.<br>.在三个区域部署 2 个 EC2 实例并使用 Amazon Elastic Load Balancer。</p><p>正确答案是 C，因为在 2 个可用区中使用 3 个 EC2 实例进行自动扩展将提供高可用性，并且 ELB 将在所有实例上提供平均的流量分配，选项 A 是错误的，因为单个可用区不会提供高可用性，选项 B 和 D 是错误的，因为实例位于不同的区域，除非复制，否则 AMI 将不可用。此外，ELB 是一项区域性服务，无法跨区域将负载分配给实例。</p><h2 id="189-一个组织正在其共享服务-VPC-中构建-Amazon-Redshift-集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？"><a href="#189-一个组织正在其共享服务-VPC-中构建-Amazon-Redshift-集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？" class="headerlink" title="189.一个组织正在其共享服务 VPC 中构建 Amazon Redshift 集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？"></a>189.一个组织正在其共享服务 VPC 中构建 Amazon Redshift 集群。群集将托管敏感数据。组织如何控制哪些网络可以访问集群？</h2><p><strong>A</strong>. Run the cluster in a different VPC and connect through VPC peering.<br>.在不同的 VPC 中运行集群，并通过 VPC 对等连接。</p><p><strong>B</strong>. Create a database user inside the Amazon Redshift cluster only for users on the network<br>.仅在 Amazon Redshift 集群中为网络上的用户创建数据库用户</p><p><strong>C</strong>. Define a cluster security group for the cluster that allows access from the allowed networks.<br>.为集群定义一个集群安全组，该安全组允许从允许的网络进行访问。</p><p><strong>D</strong>. Only allow access to networks that connect with the shared services network via VPN.<br>.仅允许访问通过 VPN 与共享服务网络连接的网络。</p><p>正确答案是C，因为可以为Redshift集群配置安全组来控制访问，请参阅AWS文档-Redshift安全组，当您预置Amazon Redshift集群时，默认情况下它是锁定的，因此没有人可以访问它。要向其他用户授予对 Amazon Redshift 集群的入站访问权限，请将该集群与安全组关联。如果您使用的是 EC2-Classic 平台，则可以定义集群安全组并将其与集群关联，如下所述。如果您在 EC2-VPC 平台上，则可以使用现有的 Amazon VPC 安全组，也可以定义一个新安全组，然后将其与集群关联，选项 A 和 D 是错误的，因为 VPC 对等互连和 VPN 是连接服务，无法控制流量以确保安全，选项 B 是错误的，因为 Redshift 用户账户在用户级别处理身份验证和授权，并且无法控制网络流量。</p><h2 id="190-一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？"><a href="#190-一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？" class="headerlink" title="190.一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？"></a>190.一家公司选择将其冷数据存储在EBS卷上，确保最佳成本，以下哪项式托管此类数据的理想EBS卷类型？</h2><p><strong>A</strong>. EBS Provisioned IOPS SSD<br>.EBS 预配置 IOPS SSD</p><p><strong>B</strong>. EBS Throughput Optimized HDD<br>.EBS 吞吐量优化型 HDD</p><p><strong>C</strong>. EBS General Purpose SSD<br>.EBS 通用型固态硬盘</p><p><strong>D</strong>. EBS Cold HDD<br>.EBS 冷硬盘</p><p>正确答案是 D，因为 Cold HDD （sc1） 卷提供低成本的磁性存储，根据吞吐量而不是 IOPS 来定义性能。sc1 的吞吐量限制低于 st1，非常适合大型顺序冷数据工作负载。如果您需要不频繁地访问数据并希望节省成本，sc1 提供了廉价的块存储。不支持可启动的 sc1 卷。Cold HDD （sc1） 卷虽然类似于吞吐量优化型 HDD （st1） 卷，但旨在支持不经常访问的数据，请参阅 AWS 文档 - EBS 卷类型 - Cold HDD</p><h2 id="191-一位解决方案架构师正在构建一个将数据存储到-DynamoDB-中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？"><a href="#191-一位解决方案架构师正在构建一个将数据存储到-DynamoDB-中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？" class="headerlink" title="191.一位解决方案架构师正在构建一个将数据存储到 DynamoDB 中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？"></a>191.一位解决方案架构师正在构建一个将数据存储到 DynamoDB 中的应用程序。特别是一个表的读取量很大，以最小的延迟访问数据至关重要。以下哪项将提供最高级别的性能？</h2><p><strong>A</strong>. Use Amazon RDS read replicas.<br>.使用 Amazon RDS 只读副本。</p><p><strong>B</strong>. Use Amazon CloudFront<br>.使用 Amazon CloudFront</p><p><strong>C</strong>. Use Amazon ElastiCache.<br>.使用 Amazon ElastiCache。</p><p><strong>D</strong>. Use Amazon DynamoDB Accelerator<br>.使用 Amazon DynamoDB Accelerator</p><p>正确答案是 D，因为 DynamoDB Accelerator 有助于在 DynamoDB 中缓存数据并提供 10 倍的性能，请参阅 AWS 文档 - DynamoDB Accelerator，Amazon DynamoDB Accelerator （DAX） 是适用于 DynamoDB 的完全托管、高度可用的内存中缓存，即使在每秒数百万个请求的情况下，也能将性能提高多达 10 倍（从毫秒到微秒）。DAX 可以完成向 DynamoDB 表添加内存中加速所需的所有繁重工作，而无需开发人员管理缓存失效、数据填充或集群管理。现在，您可以专注于为客户构建出色的应用程序，而无需担心大规模性能问题。您无需修改应用程序逻辑，因为 DAX 与现有 DynamoDB API 调用兼容。您只需在 AWS 管理控制台中单击几下或使用 AWS 开发工具包即可启用 DAX。与 DynamoDB 一样，您只需为预置的容量付费，选项 A 是错误的，因为 RDS 只读副本不适用于 DynamoDB，选项 B 是错误的，因为 CloudFront 仅提供边缘级缓存，选项 C 是错误的，因为 ElastiCache 无法提供 DAX 的性能。</p><h2 id="192-您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在-VPC-中运行，该应用程序在应用程序层前面使用-ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？"><a href="#192-您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在-VPC-中运行，该应用程序在应用程序层前面使用-ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？" class="headerlink" title="192.您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在 VPC 中运行，该应用程序在应用程序层前面使用 ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？"></a>192.您受雇于增强一个非常大型的电子商务网站的整体安全态势。他们有一个架构良好的多层应用程序，在 VPC 中运行，该应用程序在应用程序层前面使用 ALB。哪种方法提供了有效的缓解解决方案来处理DDOS攻击？</h2><p><strong>A</strong>. EC2 instance running your WAF software is included in an Auto Scaling group and placed in between two Elastic load balancers<br>.运行 WAF 软件的 EC2 实例包含在 Auto Scaling 组中，并放置在两个 Elastic Load Balancer 之间</p><p><strong>B</strong>. Remove all but TLS 1.2 from the ALB and enable Advanced Protocol Filtering This will enable the ALB itself to perform WAF functionality<br>.从 ALB 中删除除 TLS 1.2 之外的所有内容并启用高级协议过滤 这将使 ALB 本身能够执行 WAF 功能</p><p><strong>C</strong>. Add previously identified hostile source IPs as an explicit INBOUND DENY NACL to the web tier subnet<br>.将以前标识的恶意源 IP 作为显式 INBOUND DENY NACL 添加到 Web 层子网</p><p><strong>D</strong>. Use AWS WAF with ALB to protect your web applications from common web exploits<br>.将 AWS WAF 与 ALB 结合使用，以保护您的 Web 应用程序免受常见 Web 攻击</p><p>正确答案是 D，因为 ALB 与 AWS WAF 集成，可用于保护 Web 应用程序免受常见 Web 漏洞的攻击，请参阅 AWS 文档 - ELB Application Load Balancer，Web Application Firewall - 您现在可以使用 AWS WAF 来保护 Application Load Balancer 上的 Web 应用程序。AWS WAF 是一种 Web 应用程序防火墙，可帮助保护您的 Web 应用程序免受可能影响应用程序可用性、危及安全性或消耗过多资源的常见 Web 漏洞的攻击。</p><h2 id="193-一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求"><a href="#193-一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求" class="headerlink" title="193. 一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求"></a>193. 一家公司希望将Kubernetes用作其应用程序容器的编排工具。为此他们需要一个完全托管的解决方案，以下哪项服务有助于满足要求</h2><p><strong>A</strong>. AWS EKS .AWS EKS的</p><p><strong>B</strong>. AWS Lambda .AWS Lambda的</p><p><strong>C</strong>. AWS API Gateway<br>.AWS API 网关</p><p><strong>D</strong>. AWS ELB .AWS ELB（英语：ELB）</p><p>正确答案是 A，因为 Amazon Elastic Container Service for Kubernetes （Amazon EKS） 是一项托管服务，可让您轻松地在 AWS 上运行 Kubernetes，而无需建立或维护自己的 Kubernetes 控制平面。Kubernetes 是一个开源系统，用于自动部署、扩展和管理容器化应用程序。Amazon EKS 跨多个可用区运行 Kubernetes 控制层面实例，以确保高可用性。Amazon EKS 会自动检测和替换运行状况不佳的控制层面实例，并为其提供自动版本升级和修补，请参阅 AWS 文档 - EKS</p><h2 id="194-一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？"><a href="#194-一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？" class="headerlink" title="194.一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？"></a>194.一家公司希望在托管文件存储中组织多个网站的内容。公司必须能够根据需求扩展存储，而无需配置存储。多个服务器应该能够同时访问此存储。解决方案架构师应该推荐哪些服务？</h2><p><strong>A</strong>. Amazon S3 .亚马逊 S3</p><p><strong>B</strong>. Amazon EBS .亚马逊EBS</p><p><strong>C</strong>. Amazon EFS .亚马逊 EFS</p><p><strong>D</strong>. AWS Storage Gateway - Volume gateway<br>.AWS Storage Gateway - 卷网关</p><p>正确答案是 C，因为 EFS 提供了 AWS 托管的可共享文件存储，能够从多个服务器访问，请参阅 AWS 文档 - EFS，Amazon Elastic File System （Amazon EFS） 为基于 Linux 的工作负载提供了一个简单、可扩展的弹性文件系统，以便与 AWS 云服务和本地资源一起使用。它旨在在不中断应用程序的情况下按需扩展到 PB 级，并在您添加和删除文件时自动增长和收缩，因此您的应用程序在需要时拥有所需的存储。它旨在提供对数千个 Amazon EC2 实例的大规模并行共享访问，使您的应用程序能够以一致的低延迟实现高水平的聚合吞吐量和 IOPS。Amazon EFS 是一项完全托管的服务，无需更改现有应用程序和工具，通过标准文件系统接口提供访问以实现无缝集成，选项 A 是错误的，因为 S3 是对象存储，选项 B 是错误的，因为 EBS 卷附加到实例并且无法在服务器之间共享。选项 D 是错误的，因为 Storage Gateway 是一种混合云存储服务，可将您现有的本地环境与 AWS 云连接起来</p><h2 id="195-应用程序允许制造站点上传文件。每个上传的-3-GB-文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？"><a href="#195-应用程序允许制造站点上传文件。每个上传的-3-GB-文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？" class="headerlink" title="195.应用程序允许制造站点上传文件。每个上传的 3 GB 文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？"></a>195.应用程序允许制造站点上传文件。每个上传的 3 GB 文件都会被处理以提取元数据，此过程每个文件需要几秒钟。上传的频率是不可预测的。虽然可能在几个小时内没有更新，但随后是同时上传多个文件的高峰期。哪种体系结构以最经济高效的方式解决此工作负载？</h2><p><strong>A</strong>. Use a Kinesis Data Delivery Stream to store the file. Use Lambda for processing.<br>.使用 Kinesis Data Delivery Stream 存储文件。使用 Lambda 进行处理。</p><p><strong>B</strong>. Use an SQS queue to store the file, to be accessed by a fleet of EC2 Instances.<br>.使用 SQS 队列存储文件，供 EC2 实例队列访问。</p><p><strong>C</strong>. Store the file in an EBS volume, which can then be accessed by another EC2 Instance for processing.<br>.将文件存储在 EBS 卷中，然后可由另一个 EC2 实例访问该卷进行处理。</p><p><strong>D</strong>. Store the file in an S3 bucket. Use Amazon S3 event notification to invoke a Lambda function for file processing.<br>.将文件存储在 S3 存储桶中。使用 Amazon S3 事件通知调用 Lambda 函数进行文件处理。</p><p>正确答案是 D，因为元数据提取的处理在几秒钟内完成，lambda 可用于元数据提取，S3 用于存储文件。S3 事件通知可以充当调用 lambda 函数的源，请参阅 AWS 文档 - Lambda with S3，Amazon S3 可以将事件（例如，在存储桶中创建对象时）发布到 AWS Lambda，并通过将事件数据作为参数传递来调用您的 Lambda 函数。通过此集成，您可以编写处理 Amazon S3 事件的 Lambda 函数。在 Amazon S3 中，您可以添加存储桶通知配置，用于标识您希望 Amazon S3 发布的事件类型和要调用的 Lambda 函数，选项 A 是错误的，因为 Kinesis 可以与 Lambda 集成，但 Kinesis 不能用于存储超过 1MiB 的消息。检查 Kinesis Data Streams Limit，选项 B 是错误的，因为 SQS 本身不存储文件，需要 S3。持久性 EC2 实例需要处于自动扩展模式才能扩展和处理文件，与 Lambda 相比，这将不那么划算，选项 C 是错误的，因为与 S3 存储相比，EBS 卷很昂贵，与 EC2 相比，与 Lambda 相同。</p><h2 id="196-一位解决方案架构师正在使用-AWS-Lambda-设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？"><a href="#196-一位解决方案架构师正在使用-AWS-Lambda-设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？" class="headerlink" title="196.一位解决方案架构师正在使用 AWS Lambda 设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？"></a>196.一位解决方案架构师正在使用 AWS Lambda 设计解决方案，其中不同的环境需要不同的数据库密码。架构师应该怎么做才能以安全和可扩展的方式实现这一目标？</h2><p><strong>A</strong>. Create a Lambda function for each individual environment.<br>.为每个单独的环境创建一个 Lambda 函数。</p><p><strong>B</strong>. Use Amazon DynamoDB to store environment variables.<br>.使用 Amazon DynamoDB 存储环境变量。</p><p><strong>C</strong>. Use encrypted AWS Lambda environment variables.<br>.使用加密的 AWS Lambda 环境变量。</p><p><strong>D</strong>. Implement a dedicated Lambda function for distributing environment variables.<br>.实施用于分配环境变量的专用 Lambda 函数。</p><p>正确答案是 D，因为 AWS 建议在之前加密变量并使用 Lambda 函数公开它们，这提供了更安全和可扩展的解决方案，请参阅 AWS 文档 - Lambda 环境变量，当您部署 Lambda 函数时，您指定的所有环境变量在部署过程之后（而不是在部署过程中）默认加密。然后，当调用函数时，AWS Lambda 会自动解密它们。如果您需要将敏感信息存储在环境变量中，我们强烈建议您在部署 Lambda 函数之前对该信息进行加密。</p><h2 id="197-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索数据并将其上传到-DynamoDB-表。解决方案架构师应如何设计解决方案来满足这些要求？"><a href="#197-应用程序服务器需要位于无法访问-Internet-的专用子网中。该解决方案必须检索数据并将其上传到-DynamoDB-表。解决方案架构师应如何设计解决方案来满足这些要求？" class="headerlink" title="197.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索数据并将其上传到 DynamoDB 表。解决方案架构师应如何设计解决方案来满足这些要求？"></a>197.应用程序服务器需要位于无法访问 Internet 的专用子网中。该解决方案必须检索数据并将其上传到 DynamoDB 表。解决方案架构师应如何设计解决方案来满足这些要求？</h2><p><strong>A</strong>. Use a NAT Gateway<br>.使用NAT网关</p><p><strong>B</strong>. Use Amazon VPC endpoints<br>.使用 Amazon VPC 终端节点</p><p><strong>C</strong>. Use a NAT Instance<br>.使用 NAT 实例</p><p><strong>D</strong>. Deploy a proxy server<br>.部署代理服务器</p><p>正确答案是 B，因为 VPC 终端节点可以帮助应用程序通过 Amazon 网络私下访问 DynamoDB，而无需浏览 Internet，请参阅 AWS 文档 - VPC 终端节点，VPC 终端节点使您能够将 VPC 私下连接到受支持的 AWS 服务和由 PrivateLink 提供支持的 VPC 终端节点服务，而无需互联网网关、NAT 设备、VPN 连接、 或 AWS Direct Connect 连接。VPC 中的实例不需要公有 IP 地址即可与服务中的资源进行通信。您的 VPC 和其他服务之间的流量不会离开 Amazon 网络，终端节点是虚拟设备。它们是水平扩展、冗余且高度可用的 VPC 组件，允许 VPC 中的实例与服务之间进行通信，而不会对网络流量施加可用性风险或带宽限制。支持以下AWS服务：选项A和C是错误的，因为NAT网关和NAT实例仍然通过互联网路由请求，选项D是错误的，因为代理服务器仍然会通过互联网路由请求</p><h2 id="198-您需要使用-AWS-为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问-3-个月，并可使用-5-年。哪种-AWS-服务以最具成本效益的方式满足这些要求？"><a href="#198-您需要使用-AWS-为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问-3-个月，并可使用-5-年。哪种-AWS-服务以最具成本效益的方式满足这些要求？" class="headerlink" title="198.您需要使用 AWS 为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问 3 个月，并可使用 5 年。哪种 AWS 服务以最具成本效益的方式满足这些要求？"></a>198.您需要使用 AWS 为您的公司制定备份和存档策略。出于合规原因，文档应立即可访问 3 个月，并可使用 5 年。哪种 AWS 服务以最具成本效益的方式满足这些要求？</h2><p><strong>A</strong>. Use Storage Gateway to store data to S3 and use life-cycle policies to move the data into Redshift for long-time archiving<br>.使用 Storage Gateway 将数据存储到 S3，并使用生命周期策略将数据移动到 Redshift 中进行长期存档</p><p><strong>B</strong>. Use Direct Connect to upload data to S3 and use IAM policies to move the data into Glacier for longtime archiving<br>.使用 Direct Connect 将数据上传到 S3，并使用 IAM 策略将数据移动到 Glacier 中进行长期存档</p><p><strong>C</strong>. Upload the data on EBS, use life-cycle policies to move EBS snapshots into S3 and later into Glacier for long-time archiving<br>.将数据上传到 EBS 上，使用生命周期策略将 EBS 快照移动到 S3 中，然后移动到 Glacier 中进行长期存档</p><p><strong>D</strong>. Upload data to S3 and use life-cycle policies to move the data into Glacier for long-time archiving<br>.将数据上传到 S3 并使用生命周期策略将数据移动到 Glacier 中进行长期存档</p><p>正确答案是 D，因为 S3 对象生命周期管理有助于处理来自各种存储类（包括 Glacier）的对象转换，选项 A 是错误的，因为 Redshift 是一种数据仓库解决方案，选项 B 是错误的，因为 Direct Connect 不具有成本效益并且 IAM 策略对生命周期管理没有帮助，选项 C 是错误的，因为生命周期策略不适用于 EBS</p><h2 id="199-一个组织创建了-10-个-IAM-用户。该组织希望每个-IAM-用户都有权访问单独的-DynamoDB-表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？"><a href="#199-一个组织创建了-10-个-IAM-用户。该组织希望每个-IAM-用户都有权访问单独的-DynamoDB-表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？" class="headerlink" title="199.一个组织创建了 10 个 IAM 用户。该组织希望每个 IAM 用户都有权访问单独的 DynamoDB 表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？"></a>199.一个组织创建了 10 个 IAM 用户。该组织希望每个 IAM 用户都有权访问单独的 DynamoDB 表。所有用户都添加到同一组，组织希望为此设置组级别策略。组织如何实现这一目标？</h2><p><strong>A</strong>. Define the group policy and add a condition which allows the access based on the IAM name<br>.定义组策略并添加允许基于 IAM 名称进行访问的条件</p><p><strong>B</strong>. Create a DynamoDB table with the same name as the IAM user name and define the policy rule which grants access based on the DynamoDB ARN using a variable<br>.创建一个与 IAM 用户名同名的 DynamoDB 表，并使用变量定义基于 DynamoDB ARN 授予访问权限的策略规则</p><p><strong>C</strong>. Create a separate DynamoDB database for each user and configure a policy in the group based on the DB variable<br>.为每个用户创建单独的 DynamoDB 数据库，并根据数据库变量在组中配置策略</p><p><strong>D</strong>. It is not possible to have a group level policy which allows different IAM users to different DynamoDB Tables<br>.不可能有允许不同 IAM 用户访问不同 DynamoDB 表的组级策略</p><p>正确答案是B，因为DynamoDB表可以创建与IAM用户同名，IAM策略规则定义为仅授予对特定表的访问权限。</p><h2 id="200-一家公司需要存档-6TB-的数据。与利益相关者就-8-小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？"><a href="#200-一家公司需要存档-6TB-的数据。与利益相关者就-8-小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？" class="headerlink" title="200.一家公司需要存档 6TB 的数据。与利益相关者就 8 小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？"></a>200.一家公司需要存档 6TB 的数据。与利益相关者就 8 小时商定的检索时间达成协议。以下哪项可以用作最具成本效益的存储选项？</h2><p><strong>A</strong>. AWS S3 Standard<br>.AWS S3 标准版</p><p><strong>B</strong>. AWS Glacier .AWS 冰川</p><p><strong>C</strong>. AWS S3 Infrequent Access<br>.AWS S3 不频繁访问</p><p><strong>D</strong>. AWS EBS Volumes<br>.AWS EBS 卷</p><p>正确答案是 B，因为 Glacier 提供了最具成本效益的解决方案，标准检索可在 3-5 小时内完成，请参阅 AWS 文档 - Glacier 常见问题，问：什么是标准检索？，标准检索允许您在几个小时内访问您的任何档案。标准检索通常在 3 – 5 小时内完成，问：如何使用标准检索，要进行标准检索，请将 InitiateJob API 请求中的“Tier”参数设置为“Standard”如果未指定层，则请求将默认为“标准”。</p><h2 id="201-您的任务是为您的公司创建-VPC-网络拓扑。VPC-网络必须同时支持面向-Internet-的应用程序和仅通过-VPN-访问的面向内部的应用程序。面向-Internet-和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在-VPC-中创建多少个子网才能满足这些要求？"><a href="#201-您的任务是为您的公司创建-VPC-网络拓扑。VPC-网络必须同时支持面向-Internet-的应用程序和仅通过-VPN-访问的面向内部的应用程序。面向-Internet-和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在-VPC-中创建多少个子网才能满足这些要求？" class="headerlink" title="201.您的任务是为您的公司创建 VPC 网络拓扑。VPC 网络必须同时支持面向 Internet 的应用程序和仅通过 VPN 访问的面向内部的应用程序。面向 Internet 和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在 VPC 中创建多少个子网才能满足这些要求？"></a>201.您的任务是为您的公司创建 VPC 网络拓扑。VPC 网络必须同时支持面向 Internet 的应用程序和仅通过 VPN 访问的面向内部的应用程序。面向 Internet 和面向内部的应用程序都必须能够利用至少三个可用区来实现高可用性。您至少必须在 VPC 中创建多少个子网才能满足这些要求？</h2><p><strong>A</strong>. 2</p><p><strong>B</strong>. 3</p><p><strong>C</strong>. 4</p><p><strong>D</strong>. 6</p><p>正确答案是 D，因为需要至少 3 个可用区，并且需要在公有子网和私有子网中都有实例以实现高可用性，因此每个可用区需要 6 个子网作为公有子网和私有子网。</p><h2 id="203-您的公司希望利用-AWS-存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？"><a href="#203-您的公司希望利用-AWS-存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？" class="headerlink" title="203.您的公司希望利用 AWS 存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？"></a>203.您的公司希望利用 AWS 存储选项并将其与当前的本地基础设施集成。此外，由于业务需求，必须低延迟访问所有数据。以下哪个选项最适合此方案？</h2><p><strong>A</strong>. Configure the Simple Storage Service S3</p><p><strong>B</strong>. Configure Storage Gateway Cached Volume</p><p><strong>C</strong>. Configure Storage Gateway Stored Volume.</p><p><strong>D</strong>. Configure Amazon Glacier.</p><p>正确答案是C，因为Storage Gateway存储卷有助于备份数据，同时数据也在本地维护，提供低延迟访问</p><p>提问：卷网关与以前可用的网关缓存和网关存储模式之间有什么关系？</p><p>答：卷网关代表支持基于块的卷网关系列，以前称为网关缓存模式和网关存储模式，在缓存卷模式下，你的数据存储在Amazon S3中，并且经常访问的数据的缓存由网关在本地维护。使用此模式，可以节省主存储的成本，最大限度地减少在本地扩展存储的需求，同时保留对最常用数据的低延迟访问，在存储卷模式下，数据存储在本地存储上，卷作为存储在Amazon S3中的Amazon EBS快照异步备份。这提供了持久且廉价的异地备份。例如，如果你需要替换容量进行灾难恢复，你可以将这些备份本地恢复到网关或云中恢复到Amazon EC2.</p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Question bank" scheme="https://kalyan-zitiu.github.io/categories/Basic/Question-bank/"/>
    
    
    <category term="SAA" scheme="https://kalyan-zitiu.github.io/tags/SAA/"/>
    
  </entry>
  
  <entry>
    <title>Bash for Begginners</title>
    <link href="https://kalyan-zitiu.github.io/2023/11/22/Bash%20Basic/"/>
    <id>https://kalyan-zitiu.github.io/2023/11/22/Bash%20Basic/</id>
    <published>2023-11-22T07:00:00.000Z</published>
    <updated>2023-11-30T11:47:16.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bash-Basic"><a href="#Bash-Basic" class="headerlink" title="Bash Basic"></a>Bash Basic</h1><h2 id="Shell-和-Terminal有什么区别"><a href="#Shell-和-Terminal有什么区别" class="headerlink" title="Shell 和 Terminal有什么区别"></a>Shell 和 Terminal有什么区别</h2><ol><li><p><strong>Shell</strong>：</p><ul><li>Shell 是用户与操作系统交互的接口，特别是在类Unix系统中（比如Linux和macOS）。</li><li>它是一个命令行解释器，提供了一个命令行用户界面，用户可以在其中输入命令，Shell 会解释这些命令并调用操作系统来执行。</li><li>Shell 有许多不同的变种，包括 Bourne Shell (sh), Bourne Again Shell (bash), C Shell (csh), Korn Shell (ksh), Z Shell (zsh) 等。</li><li>Shell 也可以提供编程的功能，比如变量、控制结构（if-then-else, loops）、函数等。</li></ul></li><li><p><strong>Terminal</strong>：</p><ul><li>Terminal，有时被称为终端模拟器，是一个软件程序，用来模拟早期的硬件终端。</li><li>它是一个环境，用户可以在其中使用Shell。你可以在Terminal中启动一个Shell会话，输入命令，看到命令的输出。</li><li>Terminal 程序捕获用户的输入并将其发送到Shell，同时将Shell的输出显示给用户。</li><li>现代的操作系统，如Windows、macOS和Linux，通常都有自己的终端模拟器程序，比如macOS的Terminal.app，Linux的gnome-terminal、konsole等，Windows的Command Prompt和PowerShell等。</li></ul></li></ol><p>简单来说，Shell 是用来解释和执行命令的程序，而 Terminal 是用来与 Shell 交互的界面。在日常使用中，术语 “打开一个终端” 通常意味着启动一个终端程序并在其中运行一个Shell。</p><h2 id="学习Bash的原因"><a href="#学习Bash的原因" class="headerlink" title="学习Bash的原因"></a>学习Bash的原因</h2><p>当你遇见一些需要同时操作许多不同文件的情况或场景的时候，Bash远远会比其他编程语言执行的要快和简单</p><ol><li><p>Bash有很多内建命令，例如cp，mv，rm，grep，find等，这些命令可以直接在命令行中使用，非常适合进行文件操作和文本处理</p></li><li><p>Bash支持管道|和重定向&gt;&gt;,&gt;,&lt; 能够将一个命令的输出非常容易地转换成另一个命令地输入，以此来创建复杂的命令链。</p></li><li><p>Bash可以使用通配符，如*或者？和正则表达式来匹配文件名或文本模式，这在处理多个文件时，非常有用。</p></li><li><p>Bash直接运行在操作系统中，不需要额外的运行时环境或虚拟机。意味着它可以直接访问系统资源和工具。</p></li><li><p>Bash能够允许用户编写复杂的自动化脚本来执行一系列命令，无需编译。</p></li></ol><p>6.最后一点，Bash直接余操作系统的内核交互，是没有额外的抽象层。</p><h2 id="Bash-for-Beginners"><a href="#Bash-for-Beginners" class="headerlink" title="Bash for Beginners"></a>Bash for Beginners</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122144022802.png" alt="image-20231122144022802"></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122145006070.png" alt="image-20231122145006070"></p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>学Bash最好的办法就是不要离开你的Terimnal</p><ol><li>能够帮你学习命令的一个命令 help </li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122145704095.png" alt="image-20231122145704095"></p><ol start="2"><li>能够帮助你学习的第二个命令man</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122150215508.png" alt="image-20231122150215508"></p><ol start="3"><li><p>pwd和cd</p><p>cd的底层逻辑不是记录你去过的地方，而是用一个栈来对你的目录进行推入和弹出</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122151730947.png" alt="image-20231122151730947"></p></li><li><p>tree和ls</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122152044955.png" alt="image-20231122152044955"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122152057732.png"></p><ol start="5"><li>pushd和popd，dirs</li></ol><p>在Bash中，<code>pushd</code> 和 <code>popd</code> 是用来操作目录栈的内建命令，它们与 <code>dirs</code> 命令一起工作，以帮助你在不同的目录之间快速地切换。</p><h3 id="pushd-命令"><a href="#pushd-命令" class="headerlink" title="pushd 命令"></a>pushd 命令</h3><p><code>pushd</code> 命令用于将一个目录添加到目录栈的顶部，并且将你的当前工作目录切换到那个目录。这对于临时切换到另一个目录，执行一些操作，然后返回到原始目录非常有用。</p><p>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pushd</span> /path/to/new/directory</span><br></pre></td></tr></table></figure><p>这个命令会将 <code>/path/to/new/directory</code> 放入目录栈，并且把当前工作目录切换到这个新目录。</p><h3 id="popd-命令"><a href="#popd-命令" class="headerlink" title="popd 命令"></a>popd 命令</h3><p><code>popd</code> 命令用于从目录栈中移除顶部的目录，并将当前工作目录切换到新的栈顶目录。</p><p>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">popd</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，栈顶的目录将被移除，你的当前工作目录将变为之前通过 <code>pushd</code> 添加的下一个目录。</p><h3 id="dirs-命令"><a href="#dirs-命令" class="headerlink" title="dirs 命令"></a>dirs 命令</h3><p><code>dirs</code> 命令用于显示当前目录栈的内容，即你用 <code>pushd</code> 添加的所有目录列表。</p><p>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dirs</span></span><br></pre></td></tr></table></figure><p>这个命令会列出目录栈中的所有目录，通常以空格分隔。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用 <code>pushd</code> 和 <code>popd</code> 的简单示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设当前目录是 /home/user</span></span><br><span class="line"><span class="built_in">pushd</span> /var/www    <span class="comment"># 将 /var/www 添加到目录栈并切换到该目录</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /var/www</span></span><br><span class="line"><span class="built_in">pushd</span> /etc        <span class="comment"># 将 /etc 添加到目录栈并切换到该目录</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /etc</span></span><br><span class="line"><span class="built_in">dirs</span>              <span class="comment"># 显示目录栈内容</span></span><br><span class="line"><span class="comment"># 输出可能是 /etc /var/www /home/user</span></span><br><span class="line"><span class="built_in">popd</span>              <span class="comment"># 移除栈顶目录 (/etc) 并切换到下一个目录 (/var/www)</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /var/www</span></span><br><span class="line"><span class="built_in">popd</span>              <span class="comment"># 移除栈顶目录 (/var/www) 并切换到下一个目录 (/home/user)</span></span><br><span class="line"><span class="comment"># 现在当前目录是 /home/user</span></span><br></pre></td></tr></table></figure><p>使用 <code>pushd</code> 和 <code>popd</code> 可以让你在多个工作目录之间快速切换，而无需手动输入 <code>cd</code> 命令和目录路径。这在编写脚本或进行复杂的文件系统操作时尤其有用。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122152543455.png" alt="image-20231122152543455"></p><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122201845965.png" alt="image-20231122201845965"></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122202023427.png" alt="image-20231122202023427"></p><h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122203644825.png" alt="image-20231122203644825"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231122204052818.png" alt="image-20231122204052818"></p><h4 id="标准输出重定向-gt-和-gt-gt"><a href="#标准输出重定向-gt-和-gt-gt" class="headerlink" title="标准输出重定向 (&gt; 和 &gt;&gt;)"></a>标准输出重定向 (<code>&gt;</code> 和 <code>&gt;&gt;</code>)</h4><h5 id="使用-gt-重定向标准输出"><a href="#使用-gt-重定向标准输出" class="headerlink" title="使用 &gt; 重定向标准输出"></a>使用 <code>&gt;</code> 重定向标准输出</h5><p>当你想把命令的输出保存到一个文件中时，可以使用 <code>&gt;</code> 操作符。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> &gt; hello.txt</span><br></pre></td></tr></table></figure><p>这条命令会创建（或覆盖）一个名为 <code>hello.txt</code> 的文件，并将 <code>echo</code> 命令的输出写入该文件。</p><h5 id="使用-gt-gt-追加到文件"><a href="#使用-gt-gt-追加到文件" class="headerlink" title="使用 &gt;&gt; 追加到文件"></a>使用 <code>&gt;&gt;</code> 追加到文件</h5><p>如果你不想覆盖文件中现有的内容，而是想追加内容，可以使用 <code>&gt;&gt;</code> 操作符。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Another line&quot;</span> &gt;&gt; hello.txt</span><br></pre></td></tr></table></figure><p>这会将 “Another line” 追加到 <code>hello.txt</code> 文件的末尾。</p><h4 id="标准输入重定向-lt"><a href="#标准输入重定向-lt" class="headerlink" title="标准输入重定向 (&lt;)"></a>标准输入重定向 (<code>&lt;</code>)</h4><h5 id="使用-lt-重定向标准输入"><a href="#使用-lt-重定向标准输入" class="headerlink" title="使用 &lt; 重定向标准输入"></a>使用 <code>&lt;</code> 重定向标准输入</h5><p><code>&lt;</code> 操作符用于将文件内容作为命令的输入。例如，如果你有一个名为 <code>commands.txt</code> 的文件，包含一系列命令，你可以使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt; commands.txt</span><br></pre></td></tr></table></figure><p>这条命令会执行 <code>commands.txt</code> 文件中的 Bash 命令。</p><h4 id="组合输入和输出重定向"><a href="#组合输入和输出重定向" class="headerlink" title="组合输入和输出重定向"></a>组合输入和输出重定向</h4><p>你还可以组合使用输入和输出重定向。例如，以下命令将 <code>input.txt</code> 文件中的内容作为 <code>sort</code> 命令的输入，并将结果输出到 <code>output.txt</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><h4 id="标准错误重定向-2-gt"><a href="#标准错误重定向-2-gt" class="headerlink" title="标准错误重定向 (2&gt;)"></a>标准错误重定向 (<code>2&gt;</code>)</h4><h5 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h5><p>在 Bash 中，标准错误（stderr）是一个单独的输出流，用于输出错误信息。使用 <code>2&gt;</code> 可以重定向错误信息到一个文件。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> non_existent_file 2&gt; error.log</span><br></pre></td></tr></table></figure><p>如果 <code>non_existent_file</code> 不存在，<code>ls</code> 命令的错误信息会被写入到 <code>error.log</code>。</p><h4 id="结合标准输出和标准错误重定向"><a href="#结合标准输出和标准错误重定向" class="headerlink" title="结合标准输出和标准错误重定向"></a>结合标准输出和标准错误重定向</h4><p>有时你可能想同时重定向标准输出和标准错误到同一个文件。这可以通过以下方式实现：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; output_and_error.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这条命令将 <code>command</code> 的标准输出和标准错误都重定向到 <code>output_and_error.log</code> 文件。</p><p>当然可以。以下是一篇关于如何使用 Bash 更新服务器操作系统的知识点总结的博客草稿，采用 Markdown 格式编写：</p><hr><h3 id="Bash-更新服务器操作系统"><a href="#Bash-更新服务器操作系统" class="headerlink" title="Bash 更新服务器操作系统"></a>Bash 更新服务器操作系统</h3><p>在服务器管理中，定期更新操作系统是一项重要的维护任务。使用 Bash 脚本可以简化这一过程。在本文中，我们将探讨如何使用 Bash 命令来更新服务器的操作系统。</p><h4 id="1-理解-Bash-和-Shell"><a href="#1-理解-Bash-和-Shell" class="headerlink" title="1. 理解 Bash 和 Shell"></a>1. 理解 Bash 和 Shell</h4><p>首先，了解 Bash 和 Shell 的基本概念是很重要的。Bash（Bourne Again SHell）是一种流行的命令行界面和脚本语言，用于与操作系统交互。</p><h4 id="2-检查更新"><a href="#2-检查更新" class="headerlink" title="2. 检查更新"></a>2. 检查更新</h4><p>在更新之前，你应该检查是否有可用的更新。这通常可以通过以下命令完成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>这个命令会同步包数据库，并列出可用的更新。</p><h4 id="3-安装更新"><a href="#3-安装更新" class="headerlink" title="3. 安装更新"></a>3. 安装更新</h4><p>一旦检查了可用的更新，下一步就是安装它们。这可以通过以下命令完成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>此命令会下载并安装更新。请注意，这可能需要一些时间，具体取决于更新的大小和数量。</p><h4 id="4-清理不必要的包"><a href="#4-清理不必要的包" class="headerlink" title="4. 清理不必要的包"></a>4. 清理不必要的包</h4><p>更新后，可能会有一些不再需要的包留在系统上。运行以下命令可以清理这些包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure><h4 id="5-重启服务器"><a href="#5-重启服务器" class="headerlink" title="5. 重启服务器"></a>5. 重启服务器</h4><p>某些更新（特别是内核更新）可能需要重启服务器才能生效。可以使用以下命令来安全地重启服务器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>当然可以。下面是一篇使用 Markdown 编写的关于如何使用 Bash 查找和终止异常或不需要的进程的博客文章。</p><hr><h3 id="Bash-查找和终止异常或不需要的进程"><a href="#Bash-查找和终止异常或不需要的进程" class="headerlink" title="Bash 查找和终止异常或不需要的进程"></a>Bash 查找和终止异常或不需要的进程</h3><p>在日常的系统管理和运维工作中，经常需要处理运行中的异常或不需要的进程。使用 Bash，我们可以有效地识别这些进程并安全地终止它们。本文将介绍如何使用 Bash 来查找和终止这些进程。</p><h4 id="查找进程"><a href="#查找进程" class="headerlink" title="查找进程"></a>查找进程</h4><p>要查找正在运行的进程，最常用的命令是 <code>ps</code> 和 <code>top</code>。</p><h5 id="使用-ps-命令"><a href="#使用-ps-命令" class="headerlink" title="使用 ps 命令"></a>使用 <code>ps</code> 命令</h5><p><code>ps</code> 命令可以显示当前系统中活动的进程。常见用法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>这个命令会列出所有运行中的进程及其详细信息，包括进程 ID、CPU 和内存使用率等。</p><h5 id="使用-top-命令"><a href="#使用-top-命令" class="headerlink" title="使用 top 命令"></a>使用 <code>top</code> 命令</h5><p>另一个有用的工具是 <code>top</code>，它提供了一个实时更新的进程列表，类似于 Windows 中的任务管理器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>通过 <code>top</code>，可以实时观察进程的状态和系统资源的使用情况。</p><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>一旦识别出需要终止的进程，可以使用 <code>kill</code> 命令来终止它们。</p><h5 id="使用-kill-命令"><a href="#使用-kill-命令" class="headerlink" title="使用 kill 命令"></a>使用 <code>kill</code> 命令</h5><p>要终止一个进程，首先需要知道它的进程 ID（PID）。使用 <code>kill</code> 命令后跟 PID 可以发送信号来终止进程：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> [PID]</span><br></pre></td></tr></table></figure><p>如果进程不响应普通的 <code>kill</code> 命令，可以使用 <code>-9</code> 选项强制终止：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 [PID]</span><br></pre></td></tr></table></figure><h5 id="使用-pkill-和-killall"><a href="#使用-pkill-和-killall" class="headerlink" title="使用 pkill 和 killall"></a>使用 <code>pkill</code> 和 <code>killall</code></h5><p>如果你知道进程的名称而不是 PID，可以使用 <code>pkill</code> 或 <code>killall</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill [进程名]</span><br><span class="line">killall [进程名]</span><br></pre></td></tr></table></figure><h2 id="Bash脚本基础"><a href="#Bash脚本基础" class="headerlink" title="Bash脚本基础"></a>Bash脚本基础</h2><p>Bash 脚本是 Linux 和 Unix 系统中自动化任务和管理系统的强大工具。本教程将介绍 Bash 脚本的基本概念，包括脚本的定义、使用原因、格式、权限设置，以及如何将脚本添加到 PATH 目录中。</p><h3 id="什么是-Bash-脚本？"><a href="#什么是-Bash-脚本？" class="headerlink" title="什么是 Bash 脚本？"></a>什么是 Bash 脚本？</h3><p>Bash 脚本是一系列在 Bash shell 中执行的命令集合。它们被编写在文本文件中，可被 Bash 直接执行。</p><h3 id="为什么使用-Bash-脚本？"><a href="#为什么使用-Bash-脚本？" class="headerlink" title="为什么使用 Bash 脚本？"></a>为什么使用 Bash 脚本？</h3><p>使用 Bash 脚本可以自动化复杂的、重复的任务，提高效率并减少人为错误。它们在系统管理、程序开发和数据处理等领域非常有用。</p><h3 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h3><p>一个基本的 Bash 脚本格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这里是注释</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure><p>好的，下面我会详细地介绍 Bash 脚本的基本语法和一些关键概念。</p><h3 id="1-脚本结构"><a href="#1-脚本结构" class="headerlink" title="1. 脚本结构"></a>1. <strong>脚本结构</strong></h3><ul><li><p><strong>Shebang（#!）</strong>：每个 Bash 脚本通常以 <code>#!</code> 开头，后面跟着解释器的路径。对于 Bash 脚本，这行通常是 <code>#!/bin/bash</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注释</strong>：使用 <code>#</code> 开头的行是注释，不会被执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一条注释</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. <strong>变量</strong></h3><ul><li><p><strong>声明变量</strong>：在 Bash 中，你可以通过简单地赋值来声明变量。不需要使用任何关键字。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用变量</strong>：使用 <code>$</code> 符号来引用变量的值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-命令执行"><a href="#3-命令执行" class="headerlink" title="3. 命令执行"></a>3. <strong>命令执行</strong></h3><ul><li><p><strong>执行命令</strong>：Bash 脚本中的命令和你在命令行中输入的命令一样。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-控制结构"><a href="#4-控制结构" class="headerlink" title="4. 控制结构"></a>4. <strong>控制结构</strong></h3><ul><li><p><strong>条件语句</strong>（if-else）：用于根据条件执行不同的代码块。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$name</span> == <span class="string">&quot;张三&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;名字是张三&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;名字不是张三&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p><strong>循环</strong>（for, while）：用于重复执行一段代码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这是第 <span class="variable">$i</span> 次&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;这是第 <span class="variable">$i</span> 次&quot;</span></span><br><span class="line">    i=$((i + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. <strong>函数</strong></h3><ul><li><p><strong>定义函数</strong>：函数可以帮助组织和复用代码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用函数</strong>：调用函数并传递参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">greet <span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-输入输出"><a href="#6-输入输出" class="headerlink" title="6. 输入输出"></a>6. <strong>输入输出</strong></h3><ul><li><p><strong>读取输入</strong>：使用 <code>read</code> 命令读取用户输入。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;请输入你的名字:&quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好, <span class="variable">$name</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>输出重定向</strong>：使用 <code>&gt;</code> 和 <code>&gt;&gt;</code> 将输出重定向到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是一条消息&quot;</span> &gt; file.txt    <span class="comment"># 覆盖文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是另一条消息&quot;</span> &gt;&gt; file.txt   <span class="comment"># 追加到文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-特殊变量"><a href="#7-特殊变量" class="headerlink" title="7. 特殊变量"></a>7. <strong>特殊变量</strong></h3><ul><li><p>**$0, $1, $2, …**：这些特殊变量用于访问脚本的参数。<code>$0</code> 是脚本名，<code>$1</code> 是第一个参数，依此类推。</p></li><li><p>**$#**：参数的数量。</p></li><li><p><strong>$@</strong> 和 **$***：所有参数的列表。<code>$@</code> 在双引号中使用时，每个参数都是独立的，而 <code>$*</code> 将所有参数视为单个字符串。</p></li></ul><h3 id="8-退出状态"><a href="#8-退出状态" class="headerlink" title="8. 退出状态"></a>8. <strong>退出状态</strong></h3><ul><li><p><strong>退出状态</strong>：每个命令执行完毕后都会返回一个退出状态。成功的命令返回 0，失败的命令返回非零值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment"># 显示上一个命令的退出状态</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><h3 id="5-1运行级别"><a href="#5-1运行级别" class="headerlink" title="5.1运行级别"></a><strong>5.1运行级别</strong></h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a><strong>基本</strong></h4><table><thead><tr><th align="left">0</th><th>关机</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td>单用户（找回丢失密码）</td><td></td></tr><tr><td align="left">2</td><td>多用户状态没有网络服务</td><td></td></tr><tr><td align="left">3</td><td>系统未使用保留给用户</td><td>multi-user.target</td></tr><tr><td align="left">4</td><td>图形界面</td><td></td></tr><tr><td align="left">5</td><td>系统重启</td><td>graphical.target</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>常用系统级别是3和5，也可以切换运行级别和指定默认运行级别</strong>。</p><h4 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a><strong>切换运行级别</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>init 运行级别<strong>（init 3）</strong></td><td>将运行级别切换为3（多用户状态有网络服务）</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>init 只能用来切换运行级别。下次开机后系统自动回到运行级别5。</strong></p><h4 id="设置默认运行级别"><a href="#设置默认运行级别" class="headerlink" title="设置默认运行级别"></a><strong>设置默认运行级别</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>systemctl get-default</td><td>查看当前默认运行级别</td></tr><tr><td>systemctl set-default multi-user.target</td><td>设置默认运行级别为3</td></tr><tr><td>systemctl set -default graphical.target</td><td>设置默认运行级别为5</td></tr></tbody></table><p><strong>==Note==</strong><br>-<strong>此方式永久性的修改了默认运行级别。每次开机后系统都会运行该默认运行级别。</strong></p><h4 id="开机流程说明"><a href="#开机流程说明" class="headerlink" title="开机流程说明"></a><strong>开机流程说明</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/326400f8c502421a9482254a802e0787.png" alt="img"></p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a><strong>帮助指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>man 命令或配置文件</td><td>获得命令或配置文件的帮助信息</td></tr><tr><td>help 命令</td><td>获得shell内置命令的帮助信息</td></tr></tbody></table><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a><strong>文件目录类</strong></h3><h4 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a><strong>pwd指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>pwd</td><td>显示当前工作目录的绝对途径</td></tr></tbody></table><h4 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a><strong>ls指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ls 目录或文件</td><td>显示当前目录下所有的文件和目录（不包括隐藏的）</td></tr><tr><td>ls -a 目录或文件</td><td>显示当前目录下所有的文件和目录（包括隐藏的）</td></tr><tr><td>ls -l 目录或文件 或 ll 目录或文件</td><td>以列表的方式显示信息</td></tr><tr><td>ls -lh 目录或文件</td><td>以列表的方式人性化地显示信息</td></tr></tbody></table><h4 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a><strong>cd指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的家目录</td></tr><tr><td>cd ~</td><td>切换到当前用户的家目录</td></tr><tr><td>cd .</td><td>保持当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h4 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a><strong>mkdir指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>mkdir 要创建的单级目录</td><td>创建单级目录</td></tr><tr><td>mkdir -p 要创建的多级目录</td><td>创建多级目录</td></tr></tbody></table><h4 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a><strong>rmdir指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>rmdir 要删除的空目录</td><td>删除空目录</td></tr><tr><td>rm -rf 要删除的非空目录</td><td>删除非空目录</td></tr></tbody></table><h4 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a><strong>touch指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>touch 文件名称</td><td>创建一个空文件</td></tr></tbody></table><h4 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a><strong>cp指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th><th>Remake</th></tr></thead><tbody><tr><td>cp source dest</td><td>将source拷贝到dest</td><td></td></tr><tr><td>cp -r source dest</td><td>将source递归拷贝到dest</td><td></td></tr><tr><td>\cp source dest</td><td>将source拷贝到dest(强制覆盖不提示)</td><td></td></tr></tbody></table><h4 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a><strong>rm指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>rm 要删除的文件或目录</td><td>移除文件或目录</td></tr><tr><td>rm -r 要删除的目录</td><td>递归删除目录</td></tr><tr><td>rm -f 要删除的文件或目录</td><td>强制删除目录不提示</td></tr></tbody></table><h4 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a><strong>mv指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>mv oldFileName newFileName</td><td>重命名（两者在同一目录下面）</td></tr><tr><td>mv /temp/movefile /targetFolder</td><td>移动文件</td></tr></tbody></table><h4 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a><strong>cat指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>cat 要查看的文件</td><td>查看文件的内容</td></tr><tr><td>cat -n 要查看的文件</td><td>查看文件的内容并显示行号</td></tr><tr><td>cat -n 要查看的文件  more</td><td>将cat查看的内容交给more指令来处理（为了浏览方便）</td></tr></tbody></table><h4 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a><strong>more指令</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/fb32e188764542ebb25549929c4a24ff.png" alt="img"><br>|Order|illustrate|<br>|—–|—–|<br>|more 要查看的文件|查看文件的内容（浏览更方便）|</p><h4 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a><strong>less指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>less 要查看的文件</td><td>查看文件的内容</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>less 指令用来分屏查看文件内容，它的功能与more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</strong></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/5a3f4976cdc74d8e966916588413378c.png" alt="img"></p><h4 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a><strong>echo指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>echo $PATH</td><td>输出当前PATH环境变量</td></tr><tr><td>echo $HOSTNAME</td><td>输出当前HOSTNAME环境变量（主机名）</td></tr><tr><td>echo ‘hello world’</td><td>输出hello world</td></tr></tbody></table><h4 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a><strong>head指令</strong></h4><p>==head指令用于查看文件开头的部分内容（默认情况下显示前10行）。==<br>|Order|illustrate|<br>|—–|—–|<br>|head 文件|查看文件开头的前10行内容|<br>|head -n 5 文件|查看文件开头的前5行内容|</p><h4 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a><strong>tail指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>tail 文件</td><td>查看文件尾部的后10行内容</td></tr><tr><td>tail -n 5 文件</td><td>查看文件尾部的后5行内容</td></tr><tr><td>tail -f 文件</td><td>实时追踪该文档的所有更新</td></tr></tbody></table><h4 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a><strong>&gt;指令和&gt;&gt;指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ls -l &gt; 文件</td><td>列表的内容写入（覆盖）到文件</td></tr><tr><td>ls -l &gt;&gt; 文件</td><td>列表的内容追加到文件</td></tr><tr><td>cat 文件1 &gt; 文件2</td><td>文件1的内容覆盖到文件2</td></tr><tr><td>echo ‘hello’  &gt;&gt; 文件</td><td>hello追加到文件中</td></tr></tbody></table><h4 id="In指令"><a href="#In指令" class="headerlink" title="In指令"></a><strong>In指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ln -s 原文件或目录 软链接名</td><td>给原文件创建一个软链接(这样软链接就指向了原文件或目录)</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>当工作目录为软链接所在目录，使用pwd查看的目录仍然是软链接所在目录而不是原目录。</strong></p><h4 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a><strong>history指令</strong></h4><p>==history指令用于查看已经执行过的历史命令。==</p><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>histrory</td><td>查看已经执行过的历史命令</td></tr><tr><td>histrory n</td><td>查看最近执行过的n条历史命令</td></tr><tr><td>!n</td><td>执行历史编号为n的历史命令</td></tr></tbody></table><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h4><p>date指令用于显示当前日期<br>|Order|illustrate|<br>|—–|—–|<br>|date|显示当前时间|<br>|date +%Y|显示当前年份|<br>|date +%m|显示当前月份|<br>|date +%d|显示当前是哪一天|<br>|date “+%Y-%m-%d %H:%M:%S”|显示年月日时分秒|</p><h4 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>date -s 字符串时间</td><td>设置系统当前时间</td></tr></tbody></table><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><p>cal指令用于显示日历<br>|Order|illustrate|<br>|—–|—–|<br>|cal|显示本月日历|<br>|cal 年份|显示本年所有月日历|</p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a><strong>搜索查找类</strong></h3><h4 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a><strong>find指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>find 指定目录 -name 要查找的文件或目录</td><td>按照指定目录查询文件或目录</td></tr><tr><td>find 指定目录 -user 用户名</td><td>按照指定目录查找指定用户名的所有文件或目录</td></tr><tr><td>find 指定目录 -size 文件大小</td><td>按照指定目录查找满足文件大小的所有文件或目录</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>1.文件大小：大于+，小于-，等于=</strong><br><strong>2.find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</strong><br><strong>find指令也可以不指定目录进行查找。</strong></p><h4 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a><strong>locate指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>locate 要查找的文件或目录</td><td>快速查找文件或目录</td></tr><tr><td><strong>==Note==</strong></td><td></td></tr><tr><td><strong>1.locate指令无需遍历整个文件系统，locate 指令利用事先建立的系统中所有文件名称及路径的         locate数据库实现快速定位给定的文件路径。</strong></td><td></td></tr></tbody></table><p><strong>2.为了保证查询结果的准确度，管理员必须定期更新locate时刻。</strong></p><p><strong>3.由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locatc数据库。</strong></p><h4 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a><strong>which指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>which 要查找的命令</td><td>查找指令的存放路径</td></tr></tbody></table><p><strong>==Note==</strong><br>which指令用于查找指令的存放路径。</p><h4 id="管道符“-”和grep指令"><a href="#管道符“-”和grep指令" class="headerlink" title="管道符“|”和grep指令"></a><strong>管道符“|”和grep指令</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>grep 查找内容 源文件</td><td>将源文件中的查找内容输出</td></tr><tr><td>grep -n 查找内容 源文件</td><td>将源文件中的查找内容输出，并显示行号</td></tr><tr><td>grep -i 查找内容 源文件</td><td>将源文件中的查找内容输出（不区分大小写）</td></tr></tbody></table><p><strong>==Note==</strong><br>1.管道符“|”表示将前一个命令的处理结果输出传递给后面的命令处理。<br>    grep指令用于过滤查找，可配合管道符“|”使用。</p><p>==<strong>Case study</strong><br><strong>请在 hello.txt文件中，查找”yes”所在行，并且显示行号。<br>法一：cat hello.txt | grep -n “yes”<br>法二：grep -n “yes” hello.txt</strong></p><h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><h4 id="gzip-gunzio指令"><a href="#gzip-gunzio指令" class="headerlink" title="gzip/gunzio指令"></a>gzip/gunzio指令</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>gzip 文件</td><td>压缩文件（只能将文件压缩为*.gz文件）</td></tr><tr><td>gunzip 文件.gz</td><td>解压缩文件</td></tr></tbody></table><h4 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="==zip/unzip指令=="></a>==<strong>zip/unzip指令</strong>==</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>zip XXX.zip 要压缩的文件</td><td>压缩文件</td></tr><tr><td>zip -r XXX.zip 要压缩的目录</td><td>压缩目录（递归压缩）</td></tr><tr><td>unzip XXX.zip</td><td>将压缩包解压到当前目录下</td></tr><tr><td>unzip -d 目标目录 XXX.zip</td><td>将压缩包解压到指定目录下</td></tr></tbody></table><h4 id="tar指令"><a href="#tar指令" class="headerlink" title="==tar指令=="></a>==<strong>tar指令</strong>==</h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>tar-z</td><td>压缩/解压缩</td></tr><tr><td>tar-c</td><td>产生tar打包文件</td></tr><tr><td>tar-v</td><td>显示详细信息</td></tr><tr><td>tar-f</td><td>指定压缩后的文件名</td></tr><tr><td>tar-x</td><td>解包.tar文件</td></tr><tr><td>tar-C</td><td>解压缩到指定目录（解压缩的目录必须存在）</td></tr><tr><td>tar -zcvf 打包文件.tar.gz 被打包的文件</td><td>打包压缩文件</td></tr><tr><td>tar -zxvf 打包文件.tar.gz</td><td>解包解压缩文件至当前目录下</td></tr><tr><td>tar -zxvf 打包文件.tar.gz -C 目标目录</td><td>解包解压缩文件至当前指定目录下</td></tr></tbody></table><h3 id="Bash组基本介绍"><a href="#Bash组基本介绍" class="headerlink" title="Bash组基本介绍"></a><strong>Bash组基本介绍</strong></h3><h4 id="Bash组基本介绍-1"><a href="#Bash组基本介绍-1" class="headerlink" title="Bash组基本介绍**"></a>Bash组基本介绍**</h4><p>在Bash中的每个用户必须属于一个组，且可以改变每个用户所在的组。<br>在Bash中的每个文件拥有以下概念：<br>1.所有者2.所在组3.其它组</p><h4 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件/目录所有者"></a><strong>文件/目录所有者</strong></h4><p><em><strong>一般为文件/目录的创建者，即谁创建文件/目录，谁就是该文件/目录的所有者。</strong></em></p><h4 id="查看文件-目录的所有者"><a href="#查看文件-目录的所有者" class="headerlink" title="查看文件/目录的所有者"></a><strong>查看文件/目录的所有者</strong></h4><p>ls -alh</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/e36e9c31bcb248cda9ecc05d69c2440b.png" alt="img"></p><h4 id="修改文件-目录的所有者"><a href="#修改文件-目录的所有者" class="headerlink" title="修改文件/目录的所有者"></a><strong>修改文件/目录的所有者</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chown 所有者 文件/目录</td><td>修改文件/目录的所有者</td></tr><tr><td>chown -R 所有者 目录</td><td>递归修改目录及目录内容的所有者</td></tr><tr><td>chown 所有者:所在组 文件/目录</td><td>修改文件/目录的所有者和所在组</td></tr></tbody></table><h4 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a><strong>文件/目录所在组</strong></h4><p><strong>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组(默认)。</strong></p><h3 id="查看文件-目录的所在组"><a href="#查看文件-目录的所在组" class="headerlink" title="查看文件/目录的所在组"></a><strong>查看文件/目录的所在组</strong></h3><p>ls -alh</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/966d4fe8a879494297ee9578ce9a97be.png" alt="img"></p><h4 id="修改文件-目录的所在组"><a href="#修改文件-目录的所在组" class="headerlink" title="修改文件/目录的所在组"></a><strong>修改文件/目录的所在组</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chgrp 所在组 文件/目录</td><td>修改文件/目录的所在组</td></tr><tr><td>chgrp -R 所在组 目录</td><td>递归修改目录及目录内容的所在组</td></tr></tbody></table><h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a><strong>其它组</strong></h4><p><strong>除文件的所有者和所在组的用户外，系统的其它用户都属于文件的其它组。</strong></p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p><img src="https://img-blog.csdnimg.cn/1055e2e25bcd4f32a559061862242ae5.png" alt="img"></p><p><strong>0-9位说明</strong></p><p>1.第0位确定文件类型（-、l、d、c、b）<br>        -表示普通文件<br>        l是链接，相当于windows的快捷方式<br>        d是目录，相当于windows的文件夹<br>        c是字符设备文件，例如鼠标，键盘<br>        b是块设备，例如硬盘<br>2.第1-3位确定该文件所有者拥有的权限。<br>3.第4-6位确定与该文件所有者同一组的用户拥有的权限。<br>4.第7-9位确定不与该文件所有者同一组的其他用户拥有的权限。</p><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a><strong>rwx作用到文件</strong></h4><pre><code> r表示可读（read）：可以查看文件中的内容 w表示可写（write）：可以修改文件中的内容，但是不一定可以删除该文件（因为删除一个      文件的前提是对该文件所在目录有写权限，才能删除该文件） x表示可执行（execute）：可以执行该文件</code></pre><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a><strong>rwx作用到目录</strong></h4><p><strong>1.r表示可读（read）：可以查看目录中的内容（ls查看）</strong></p><p><strong>2.w表示可写（write）：可以创建、删除目录中的内容，重命名目录</strong></p><p><strong>3.x表示可执行（execute）：可以进入该目录（cd进入）</strong></p><h4 id="ls-l扩展"><a href="#ls-l扩展" class="headerlink" title="ls -l扩展"></a><strong>ls -l扩展</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/1055e2e25bcd4f32a559061862242ae5.png" alt="img"></p><p>ls -l可显示目录下文件的详细信息,从左往右依次是：<br>     文件类型<br>     权限<br>     硬链接数（对于文件来说）或子目录数（对于目录来说，包括隐藏目录）<br>     用户<br>     组<br>     文件/文件夹大小（字节）<br>     最后修改日期<br>     文件名</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><strong>chmod</strong></h4><p><strong>chmod指令用于修改文件或者目录的权限。</strong></p><p><strong>+、-、=变更权限</strong><br>|Order|illustrate|<br>|—–|—–|<br>|chmod u=rwx,g=rx,o=x 文件/目录|给文件/目录的所有者读写执行的权限，所在组读执行的权限其它组执行的权限    |<br>|chmod o+x 文件/目录|给文件/目录的其它组增加执行的权限|<br>|chmod a-x 文件/目录|给文件/目录的所有人除去执行的权限|</p><table><thead><tr><th>Remake</th><th>—–</th></tr></thead><tbody><tr><td>u：</td><td>所有者</td></tr><tr><td>g：</td><td>所在组</td></tr><tr><td>o：</td><td>其它组</td></tr><tr><td>a：</td><td>所有人</td></tr><tr><td>=：</td><td>赋予</td></tr><tr><td>+：</td><td>增加</td></tr><tr><td>-：</td><td>除去</td></tr></tbody></table><h4 id="数字变更权限"><a href="#数字变更权限" class="headerlink" title="数字变更权限"></a><strong>数字变更权限</strong></h4><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chmod 751 文件/目录</td><td>给文件/目录的所有者读写执行的权限，所在组读执行的权限，其它组执行的权限</td></tr></tbody></table><h3 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h3><h4 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h4><p>1.任务调度：系统在某个时间执行的特定命令或者程序。<br>2.任务调度分类：<br>（1）.系统工作：有些重要的工作必须周而复始的执行<br>（2）.个别用户工作：个别用户可能希望执行某些程序</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/b8afa5a9321540b9a81ab9062238d683.png" alt="img"></p>]]></content>
    
    
    <summary type="html">Bash shell</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Basic/Study-Note/"/>
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>Azure云端防护：构建网络安全组</title>
    <link href="https://kalyan-zitiu.github.io/2023/11/20/Linux%20Bash/"/>
    <id>https://kalyan-zitiu.github.io/2023/11/20/Linux%20Bash/</id>
    <published>2023-11-20T12:00:00.000Z</published>
    <updated>2023-11-21T14:27:17.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建管理网络安全组"><a href="#创建管理网络安全组" class="headerlink" title="创建管理网络安全组"></a>创建管理网络安全组</h1><p>配置网络安全组和安全规则，以限制到特定服务器的网络流量。 你希望让应用服务器能通过 HTTP 连接到数据库服务器。 不希望数据库服务器通过 HTTP 连接到应用服务器。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121165732052.png" alt="image-20231121165732052"></p><h2 id="变量资源分配"><a href="#变量资源分配" class="headerlink" title="变量资源分配"></a>变量资源分配</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rg=learn-c5547acb-6432-4632-9c2e-17e555ac9e72</span><br></pre></td></tr></table></figure><p>  在 Azure Cloud Shell 中，将资源组分配给变量通常是为了简化管理任务和自动化脚本中的操作。当你在 Azure Cloud Shell 或任何脚本中运行命令时，经常需要引用资源组名称。如果你有一个变量，比如 <code>$rg</code>，存储了资源组的名称，你就可以在后续的命令中重复使用这个变量，而不是每次都输入完整的资源组名称。</p><p>例如，如果你将资源组名称分配给变量 <code>$rg</code>，那么你可以在创建资源、查询资源状态、删除资源等命令中使用这个变量，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分配资源组名称到变量</span></span><br><span class="line">rg=<span class="string">&quot;your-resource-group-name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用变量创建一个新的Azure虚拟机</span></span><br><span class="line">az vm create --resource-group <span class="variable">$rg</span> --name MyVm --image UbuntuLTS --generate-ssh-keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出资源组中的所有资源</span></span><br><span class="line">az resource list --resource-group <span class="variable">$rg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除资源组</span></span><br><span class="line">az group delete --name <span class="variable">$rg</span> --<span class="built_in">yes</span> --no-wait</span><br></pre></td></tr></table></figure><p>这样做有几个好处：</p><ol><li><p><strong>减少错误</strong>：每次输入资源组名称时都有可能出错，尤其是在名称很长或复杂时。使用变量可以减少这种风险。</p></li><li><p><strong>提高效率</strong>：不需要每次都输入完整的资源组名称，可以快速重复使用变量。</p></li><li><p><strong>提高可读性</strong>：在脚本中使用变量可以使代码更容易理解，尤其是对于其他可能查看或维护这些脚本的人。</p></li><li><p><strong>易于修改</strong>：如果资源组名称变更，或者你想要在不同的资源组上执行相同的一系列命令，你只需要在一个地方更新变量的值，而不是修改每一条命令。</p></li><li><p><strong>自动化和模板化</strong>：在自动化脚本中使用变量可以使脚本更加通用和可配置，这对于创建可复用的脚本模板非常有用。</p></li></ol><p>要在 Azure Cloud Shell 中分配资源组到变量 <code>rg</code>，你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rg=$(az group list --query <span class="string">&quot;[?name==&#x27;your-sandbox-resource-group-name&#x27;].name&quot;</span> -o tsv)</span><br></pre></td></tr></table></figure><p>这个命令使用 <code>az group list</code> 命令列出所有资源组，然后通过 <code>--query</code> 参数结合 JMESPath 查询语言来提取特定名称的资源组名，最后通过 <code>-o tsv</code> 输出为纯文本格式，然后将结果赋值给变量 <code>rg</code>。这样，你就可以在后续的 Azure CLI 命令中使用 <code>$rg</code> 来代表这个资源组名称了。</p><h2 id="创建ERP-servers虚拟网络和Applications子网"><a href="#创建ERP-servers虚拟网络和Applications子网" class="headerlink" title="创建ERP-servers虚拟网络和Applications子网"></a>创建ERP-servers虚拟网络和Applications子网</h2><p>  该命令是用来在Azure云服务中创建一个虚拟网络（Virtual Network，简称VNet）及其子网的。Azure的虚拟网络是一个隔离的网络环境，它允许你在Azure中自定义私有IP地址块、创建子网、配置路由和网络策略。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet create \  <span class="comment"># 调用Azure CLI的命令来创建一个虚拟网络。</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定Azure资源组的名称，该资源组是用来组织和管理Azure资源的容器。这里使用$rg变量来表示资源组名称。</span></span><br><span class="line">    --name ERP-servers \  <span class="comment"># 设置虚拟网络的名称为&quot;ERP-servers&quot;。</span></span><br><span class="line">    --address-prefixes 10.0.0.0/16 \  <span class="comment"># 定义虚拟网络的IP地址空间。这里使用了CIDR表示法，表示这个虚拟网络可以包含从10.0.0.0到10.0.255.255的IP地址。</span></span><br><span class="line">    --subnet-name Applications \  <span class="comment"># 在虚拟网络内创建一个子网，并命名为&quot;Applications&quot;。</span></span><br><span class="line">    --subnet-prefixes 10.0.0.0/24  <span class="comment"># 为&quot;Applications&quot;子网定义IP地址范围。这里的范围是10.0.0.0到10.0.0.255。</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，你将在指定的资源组中创建一个名为”ERP-servers”的虚拟网络，该网络拥有一个名为”Applications”的子网。这个子网的地址范围是10.0.0.0/24，这意味着它可以包含256个IP地址（从10.0.0.0到10.0.0.255）。</p><p>在实际执行该命令之前，确保你已经设置了<code>$rg</code>变量，它应该包含一个有效的资源组名称。如果<code>$rg</code>变量未设置或为空，命令将会失败。如果你不确定变量的当前值，可以通过以下命令来检查：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$rg</span></span><br></pre></td></tr></table></figure><p>如果变量未设置或你想要直接指定资源组名称，可以直接在命令中替换<code>$rg</code>部分，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet create \</span><br><span class="line">    --resource-group my-resource-group-name \</span><br><span class="line">    --name ERP-servers \</span><br><span class="line">    --address-prefixes 10.0.0.0/16 \</span><br><span class="line">    --subnet-name Applications \</span><br><span class="line">    --subnet-prefixes 10.0.0.0/24</span><br></pre></td></tr></table></figure><p>请确保将<code>my-resource-group-name</code>替换为实际使用的资源组名称。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121220713610.png" alt="image-20231121220713610"></p><h2 id="创建Databases子网"><a href="#创建Databases子网" class="headerlink" title="创建Databases子网"></a>创建Databases子网</h2><p>  为了在已经存在的虚拟网络 <code>ERP-servers</code> 中创建一个新的子网 <code>Databases</code>，你可以使用 <code>az network vnet subnet create</code> 命令。下面是这个命令的详细解释和格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet subnet create \  <span class="comment"># 命令用于在Azure中创建一个新的子网</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定子网所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --vnet-name ERP-servers \  <span class="comment"># 指定虚拟网络的名称，在这个例子中是&quot;ERP-servers&quot;</span></span><br><span class="line">    --address-prefixes 10.0.1.0/24 \  <span class="comment"># 定义子网的IP地址范围，这里使用CIDR表示法，表示子网可以包含从10.0.1.0到10.0.1.255的IP地址</span></span><br><span class="line">    --name Databases  <span class="comment"># 设置子网的名称为&quot;Databases&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称。如果 <code>$rg</code> 变量没有设置或者你不想使用变量，可以直接在命令中指定资源组的名称，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network vnet subnet create \</span><br><span class="line">    --resource-group my-resource-group-name \</span><br><span class="line">    --vnet-name ERP-servers \</span><br><span class="line">    --address-prefixes 10.0.1.0/24 \</span><br><span class="line">    --name Databases</span><br></pre></td></tr></table></figure><p>请将 <code>my-resource-group-name</code> 替换为你的实际资源组名称。</p><p>执行这个命令将会在 <code>ERP-servers</code> 虚拟网络中创建一个新的子网 <code>Databases</code>，其IP地址范围是 <code>10.0.1.0/24</code>。这个子网可以用于数据库服务器或相关服务，以保持网络的逻辑分隔和组织。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221015180.png" alt="image-20231121221015180"></p><h2 id="创建ERP-SERVERS-NSG网络安全组"><a href="#创建ERP-SERVERS-NSG网络安全组" class="headerlink" title="创建ERP-SERVERS-NSG网络安全组"></a>创建ERP-SERVERS-NSG网络安全组</h2><p>  要在Azure中创建一个新的网络安全组（NSG），可以使用 <code>az network nsg create</code> 命令。网络安全组用于定义入站和出站网络流量的安全规则，以此来控制对Azure虚拟网络中资源的访问。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg create \  <span class="comment"># 命令用于在Azure中创建一个新的网络安全组</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定网络安全组所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --name ERP-SERVERS-NSG  <span class="comment"># 设置网络安全组的名称为&quot;ERP-SERVERS-NSG&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称。如果 <code>$rg</code> 变量没有设置或者你不想使用变量，可以直接在命令中指定资源组的名称，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg create \</span><br><span class="line">    --resource-group my-resource-group-name \</span><br><span class="line">    --name ERP-SERVERS-NSG</span><br></pre></td></tr></table></figure><p>请将 <code>my-resource-group-name</code> 替换为你的实际资源组名称。</p><p>执行这个命令后，将会在指定的资源组中创建一个名为 <code>ERP-SERVERS-NSG</code> 的网络安全组。创建了NSG之后，你可能还需要创建和关联安全规则来定义允许或拒绝的流量类型。这些规则可以通过 <code>az network nsg rule create</code> 命令来创建。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221102757.png" alt="image-20231121221102757"></p><h2 id="创建运行Ubuntu的VM"><a href="#创建运行Ubuntu的VM" class="headerlink" title="创建运行Ubuntu的VM"></a>创建运行Ubuntu的VM</h2><p>  创建两个 VM，名称分别为 AppServer 和 DataServer。 需将 AppServer 部署到 Applications 子网，并将 DataServer 部署到 Databases 子网。 将 VM 网络接口添加到 ERP-SERVERS-NSG 网络安全组。 然后使用这些 VM 测试网络安全组。</p><h3 id="AppServer"><a href="#AppServer" class="headerlink" title="AppServer"></a>AppServer</h3><p>要生成 AppServer VM，可以使用 <code>az vm create</code> 命令。该命令将创建一个新的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N https://raw.githubusercontent.com/MicrosoftDocs/mslearn-secure-and-isolate-with-nsg-and-service-endpoints/master/cloud-init.yml &amp;&amp; \</span><br><span class="line">az vm create \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定虚拟机所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --name AppServer \  <span class="comment"># 设置虚拟机的名称为&quot;AppServer&quot;</span></span><br><span class="line">    --vnet-name ERP-servers \  <span class="comment"># 指定虚拟机所属的虚拟网络名称</span></span><br><span class="line">    --subnet Applications \  <span class="comment"># 指定虚拟机所属的子网名称</span></span><br><span class="line">    --nsg ERP-SERVERS-NSG \  <span class="comment"># 指定虚拟机所使用的网络安全组的名称</span></span><br><span class="line">    --image Ubuntu2204 \  <span class="comment"># 指定虚拟机的映像（操作系统），这里使用Ubuntu 22.04</span></span><br><span class="line">    --size Standard_DS1_v2 \  <span class="comment"># 指定虚拟机的大小/性能配置</span></span><br><span class="line">    --generate-ssh-keys \  <span class="comment"># 自动生成SSH密钥对用于远程登录</span></span><br><span class="line">    --admin-username azureuser \  <span class="comment"># 指定管理员用户名</span></span><br><span class="line">    --custom-data cloud-init.yml \  <span class="comment"># 指定自定义数据（用于配置虚拟机）</span></span><br><span class="line">    --no-wait \  <span class="comment"># 不等待虚拟机创建完成，立即返回</span></span><br><span class="line">    --admin-password &lt;password&gt;  <span class="comment"># 指定管理员密码，将 &lt;password&gt; 替换为复杂的密码</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称，并将 <code>&lt;password&gt;</code> 替换为你希望设置的复杂密码。</p><p>此命令还使用 <code>wget</code> 命令从指定的URL下载 <code>cloud-init.yml</code> 文件。该文件包含了自定义数据，用于在虚拟机创建过程中配置虚拟机。请确保可以从 Cloud Shell 访问该 URL。</p><p>执行这个命令后，将会创建一个名为 <code>AppServer</code> 的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。虚拟机将使用指定的映像（Ubuntu 22.04）和大小（Standard_DS1_v2）。管理员用户名为 <code>azureuser</code>，密码为你设置的复杂密码。虚拟机创建过程中将使用 <code>cloud-init.yml</code> 文件进行配置。</p><p>请注意，命令中的 <code>--no-wait</code> 参数将使命令立即返回，而不等待虚拟机创建完成。如果希望等待虚拟机创建完成后再返回，请删除 <code>--no-wait</code> 参数。</p><p>你可以根据需要修改命令中的参数来适应你的环境和需求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221302267.png" alt="image-20231121221302267"></p><h3 id="DataServer"><a href="#DataServer" class="headerlink" title="DataServer"></a>DataServer</h3><p>要生成 DataServer VM，可以使用 <code>az vm create</code> 命令。该命令将创建一个新的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm create \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定虚拟机所属的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --name DataServer \  <span class="comment"># 设置虚拟机的名称为&quot;DataServer&quot;</span></span><br><span class="line">    --vnet-name ERP-servers \  <span class="comment"># 指定虚拟机所属的虚拟网络名称</span></span><br><span class="line">    --subnet Databases \  <span class="comment"># 指定虚拟机所属的子网名称</span></span><br><span class="line">    --nsg ERP-SERVERS-NSG \  <span class="comment"># 指定虚拟机所使用的网络安全组的名称</span></span><br><span class="line">    --size Standard_DS1_v2 \  <span class="comment"># 指定虚拟机的大小/性能配置</span></span><br><span class="line">    --image Ubuntu2204 \  <span class="comment"># 指定虚拟机的映像（操作系统），这里使用Ubuntu 22.04</span></span><br><span class="line">    --generate-ssh-keys \  <span class="comment"># 自动生成SSH密钥对用于远程登录</span></span><br><span class="line">    --admin-username azureuser \  <span class="comment"># 指定管理员用户名</span></span><br><span class="line">    --custom-data cloud-init.yml \  <span class="comment"># 指定自定义数据（用于配置虚拟机）</span></span><br><span class="line">    --no-wait \  <span class="comment"># 不等待虚拟机创建完成，立即返回</span></span><br><span class="line">    --admin-password &lt;password&gt;  <span class="comment"># 指定管理员密码，将 &lt;password&gt; 替换为复杂的密码</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称，并将 <code>&lt;password&gt;</code> 替换为你希望设置的复杂密码。</p><p>执行这个命令后，将会创建一个名为 <code>DataServer</code> 的虚拟机，并将其配置为使用指定的资源组、虚拟网络、子网、网络安全组等。虚拟机将使用指定的映像（Ubuntu 22.04）和大小（Standard_DS1_v2）。管理员用户名为 <code>azureuser</code>，密码为你设置的复杂密码。虚拟机创建过程中将使用 <code>cloud-init.yml</code> 文件进行配置。</p><p>请注意，命令中的 <code>--no-wait</code> 参数将使命令立即返回，而不等待虚拟机创建完成。如果希望等待虚拟机创建完成后再返回，请删除 <code>--no-wait</code> 参数。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121173541435.png" alt="image-20231121173541435"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221508537.png" alt="image-20231121221508537"></p><h2 id="检查运行状态"><a href="#检查运行状态" class="headerlink" title="检查运行状态"></a>检查运行状态</h2><p>要确认 VM 是否正在运行，可以使用 <code>az vm list</code> 命令。该命令将列出指定资源组中的虚拟机，并显示其详细信息，包括虚拟机的名称、部署状态和电源状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm list \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定要列出虚拟机的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --show-details \  <span class="comment"># 显示详细信息，包括部署状态和电源状态</span></span><br><span class="line">    --query <span class="string">&quot;[*].&#123;Name:name, Provisioned:provisioningState, Power:powerState&#125;&quot;</span> \  <span class="comment"># 使用JMESPath查询语法指定要显示的属性</span></span><br><span class="line">    --output table  <span class="comment"># 以表格形式输出结果</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的Azure资源组的名称。</p><p>执行这个命令后，将会列出指定资源组中的虚拟机，并显示其名称、部署状态和电源状态。如果虚拟机正在运行，你将看到 <code>Power</code> 列的值为 <code>VM running</code>。</p><h2 id="检查默认连接"><a href="#检查默认连接" class="headerlink" title="检查默认连接"></a>检查默认连接</h2><h3 id="直接在shell里面使用SSH，"><a href="#直接在shell里面使用SSH，" class="headerlink" title="直接在shell里面使用SSH，"></a>直接在shell里面使用SSH，</h3><p>要列出分配给虚拟机的 IP 地址，以便连接到 VM，可以使用 <code>az vm list</code> 命令。该命令将列出指定资源组中的虚拟机，并显示其名称、私有 IP 地址和公共 IP 地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm list \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定要列出虚拟机的资源组，这里使用$rg变量来表示资源组名称</span></span><br><span class="line">    --show-details \  <span class="comment"># 显示详细信息，包括私有 IP 地址和公共 IP 地址</span></span><br><span class="line">    --query <span class="string">&quot;[*].&#123;Name:name, PrivateIP:privateIps, PublicIP:publicIps&#125;&quot;</span> \  <span class="comment"># 使用JMESPath查询语法指定要显示的属性</span></span><br><span class="line">    --output table  <span class="comment"># 以表格形式输出结果</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保 <code>$rg</code> 变量已经被赋值为你的 Azure 资源组的名称。</p><p>执行这个命令后，将会列出指定资源组中的虚拟机，并显示其名称、私有 IP 地址和公共 IP 地址。你可以使用公共 IP 地址来连接到相应的虚拟机。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221602944.png" alt="image-20231121221602944"></p><h3 id="公共IP地址分配给变量"><a href="#公共IP地址分配给变量" class="headerlink" title="公共IP地址分配给变量"></a>公共IP地址分配给变量</h3><p>当你运行以下命令时：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">APPSERVERIP=<span class="string">&quot;<span class="subst">$(az vm list-ip-addresses \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --resource-group $rg \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --name AppServer \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --query <span class="string">&quot;[].virtualMachine.network.publicIpAddresses[*].ipAddress&quot;</span> \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --output tsv)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">DATASERVERIP=<span class="string">&quot;<span class="subst">$(az vm list-ip-addresses \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --resource-group $rg \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --name DataServer \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --query <span class="string">&quot;[].virtualMachine.network.publicIpAddresses[*].ipAddress&quot;</span> \</span></span></span><br><span class="line"><span class="subst"><span class="string">                 --output tsv)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>这些命令会执行两个 <code>az vm list-ip-addresses</code> 命令，每个命令获取一个虚拟机的公共 IP 地址。</p><ul><li>对于 AppServer，命令如下：<ul><li><code>--resource-group $rg</code>：指定资源组的名称，这里使用 <code>$rg</code> 变量表示资源组名称。</li><li><code>--name AppServer</code>：指定虚拟机的名称，这里是 AppServer。</li><li><code>--query &quot;[].virtualMachine.network.publicIpAddresses[*].ipAddress&quot;</code>：使用 JMESPath 查询语法指定要提取的公共 IP 地址。</li><li><code>--output tsv</code>：以制表符分隔的值格式输出结果。</li></ul></li><li>对于 DataServer，命令类似于上述命令，只是虚拟机的名称改为 DataServer。</li></ul><p>这些命令会将每个虚拟机的公共 IP 地址分配给相应的变量：</p><ul><li><code>APPSERVERIP</code> 变量将保存 AppServer 的公共 IP 地址。</li><li><code>DATASERVERIP</code> 变量将保存 DataServer 的公共 IP 地址。</li></ul><p>通过将公共 IP 地址保存到变量中，你可以在后续的操作中更方便地使用这些 IP 地址，比如用于 SSH 连接到虚拟机。</p><p>若要检查能否连接到 AppServer VM，请在 Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@<span class="variable">$APPSERVERIP</span> -o ConnectTimeout=5</span><br></pre></td></tr></table></figure><p>将会收到一条 Connection timed out 消息。</p><p>若要检查能否连接到 DataServer VM，请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@<span class="variable">$DATASERVERIP</span> -o ConnectTimeout=5</span><br></pre></td></tr></table></figure><p>将会收到同样的连接失败消息。</p><p>请记住，默认规则会拒绝所有进入虚拟网络的入站流量，除非该流量来自同一虚拟网络。 “拒绝所有入站”规则阻止了刚刚尝试的入站 SSH 连接。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121203649284.png" alt="image-20231121203649284"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221741123.png" alt="image-20231121221741123"></p><h2 id="为SSH创建安全规则"><a href="#为SSH创建安全规则" class="headerlink" title="为SSH创建安全规则"></a>为SSH创建安全规则</h2><p>创建一个新的入站安全规则，允许 SSH 访问。请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg rule create \  <span class="comment"># 创建网络安全组规则的 Azure CLI 命令</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定资源组的名称，这里使用 $rg 变量表示资源组名称</span></span><br><span class="line">    --nsg-name ERP-SERVERS-NSG \  <span class="comment"># 指定网络安全组的名称，这里是 ERP-SERVERS-NSG</span></span><br><span class="line">    --name AllowSSHRule \  <span class="comment"># 指定新规则的名称，这里是 AllowSSHRule</span></span><br><span class="line">    --direction Inbound \  <span class="comment"># 指定规则的方向为入站</span></span><br><span class="line">    --priority 100 \  <span class="comment"># 指定规则的优先级为 100</span></span><br><span class="line">    --source-address-prefixes <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定源地址前缀为任意地址</span></span><br><span class="line">    --source-port-ranges <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定源端口范围为任意端口</span></span><br><span class="line">    --destination-address-prefixes <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定目标地址前缀为任意地址</span></span><br><span class="line">    --destination-port-ranges 22 \  <span class="comment"># 指定目标端口范围为 22（SSH 端口）</span></span><br><span class="line">    --access Allow \  <span class="comment"># 指定允许访问</span></span><br><span class="line">    --protocol Tcp \  <span class="comment"># 指定协议为 TCP</span></span><br><span class="line">    --description <span class="string">&quot;Allow inbound SSH&quot;</span>  <span class="comment"># 指定规则的描述为 &quot;Allow inbound SSH&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保以下事项：</p><ul><li><code>$rg</code> 变量已经被设置为你的 Azure 资源组的名称。</li><li><code>ERP-SERVERS-NSG</code> 是你要添加规则的网络安全组的名称。你可以根据实际情况修改该名称。</li></ul><p>这个命令将创建一个名为 <code>AllowSSHRule</code> 的新规则，它允许从任何来源（<code>*</code>）通过 TCP 协议（端口 22）访问目标地址（任何地址）。该规则的优先级为 100，方向为入站，并设置访问权限为允许（Allow）。描述字段提供了关于规则的说明，这里是 “Allow inbound SSH”。</p><p>执行这个命令后，将会创建一个新的安全规则，允许 SSH 连接到相应的虚拟机。请确保根据你的网络安全需求和实际情况修改命令中的参数。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221817769.png" alt="image-20231121221817769"></p><h3 id="检查是否连接"><a href="#检查是否连接" class="headerlink" title="检查是否连接"></a>检查是否连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@<span class="variable">$APPSERVERIP</span> -o ConnectTimeout=5</span><br></pre></td></tr></table></figure><p>现在应该可以进行连接。 在 Are you sure you want to continue connecting (yes/no)? 消息后，输入 yes。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121221947123.png" alt="image-20231121221947123"></p><h2 id="创建安全规则防止Web访问"><a href="#创建安全规则防止Web访问" class="headerlink" title="创建安全规则防止Web访问"></a>创建安全规则防止Web访问</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121215338383.png" alt="image-20231121215338383"></p><p>创建新的入站安全规则来拒绝端口 80 上的 HTTP 访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg rule create \  <span class="comment"># 创建网络安全组规则的 Azure CLI 命令</span></span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 指定资源组的名称，这里使用 $rg 变量表示资源组名称</span></span><br><span class="line">    --nsg-name ERP-SERVERS-NSG \  <span class="comment"># 指定网络安全组的名称，这里是 ERP-SERVERS-NSG</span></span><br><span class="line">    --name httpRule \  <span class="comment"># 指定新规则的名称，这里是 httpRule</span></span><br><span class="line">    --direction Inbound \  <span class="comment"># 指定规则的方向为入站</span></span><br><span class="line">    --priority 150 \  <span class="comment"># 指定规则的优先级为 150</span></span><br><span class="line">    --source-address-prefixes 10.0.1.4 \  <span class="comment"># 指定源地址前缀为 10.0.1.4</span></span><br><span class="line">    --source-port-ranges <span class="string">&#x27;*&#x27;</span> \  <span class="comment"># 指定源端口范围为任意端口</span></span><br><span class="line">    --destination-address-prefixes 10.0.0.4 \  <span class="comment"># 指定目标地址前缀为 10.0.0.4</span></span><br><span class="line">    --destination-port-ranges 80 \  <span class="comment"># 指定目标端口范围为 80</span></span><br><span class="line">    --access Deny \  <span class="comment"># 指定访问权限为拒绝</span></span><br><span class="line">    --protocol Tcp \  <span class="comment"># 指定协议为 TCP</span></span><br><span class="line">    --description <span class="string">&quot;Deny from DataServer to AppServer on port 80&quot;</span>  <span class="comment"># 指定规则的描述为 &quot;Deny from DataServer to AppServer on port 80&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121222017283.png" alt="image-20231121222017283"></p><h2 id="测试虚拟机之间的HTTP连接"><a href="#测试虚拟机之间的HTTP连接" class="headerlink" title="测试虚拟机之间的HTTP连接"></a>测试虚拟机之间的HTTP连接</h2><p>检查新的规则是否生效。 AppServer 应该能通过 HTTP 与 DataServer 进行通信。 DataServer 应无法通过 HTTP 与 AppServer 进行通信。</p><h3 id="APP-Data"><a href="#APP-Data" class="headerlink" title="APP - Data"></a>APP - Data</h3><p>通过 SSH 连接到 AppServer VM，并检查是否可以通过 HTTP 与 DataServer 进行通信。请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -t azureuser@<span class="variable">$APPSERVERIP</span> <span class="string">&#x27;wget http://10.0.1.4; exit; bash&#x27;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保以下事项：</p><ul><li><code>$APPSERVERIP</code> 变量已经被设置为你的 AppServer VM 的公共 IP 地址。确保该变量已经正确设置。</li><li><code>azureuser</code> 是 AppServer VM 上的用户名。如果你在创建 VM 时使用了不同的用户名，请相应地修改命令中的用户名。</li></ul><p>这个命令将通过 SSH 连接到指定的 AppServer VM，并执行以下操作：</p><ol><li>使用 <code>wget</code> 命令尝试从 DataServer VM 的 IP 地址 <code>10.0.1.4</code> 下载一个文件（这里是默认的 HTTP 请求）。</li><li>执行完 <code>wget</code> 命令后，退出 SSH 连接。</li><li>如果连接成功并且可以通过 HTTP 访问 DataServer VM，那么你将进入本地的 Bash shell。</li></ol><h3 id="Data-APP"><a href="#Data-APP" class="headerlink" title="Data - APP"></a>Data - APP</h3><p>通过 SSH 连接到 DataServer VM，并检查是否可以通过 HTTP 与 AppServer 进行通信。请在 Cloud Shell 中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -t azureuser@<span class="variable">$DATASERVERIP</span> <span class="string">&#x27;wget http://10.0.0.4; exit; bash&#x27;</span></span><br></pre></td></tr></table></figure><p>在执行这个命令之前，请确保以下事项：</p><ul><li><code>$DATASERVERIP</code> 变量已经被设置为你的 DataServer VM 的公共 IP 地址。确保该变量已经正确设置。</li><li><code>azureuser</code> 是 DataServer VM 上的用户名。如果你在创建 VM 时使用了不同的用户名，请相应地修改命令中的用户名。</li></ul><p>这个命令将通过 SSH 连接到指定的 DataServer VM，并执行以下操作：</p><ol><li>使用 <code>wget</code> 命令尝试从 AppServer VM 的 IP 地址 <code>10.0.0.4</code> 下载一个文件（这里是默认的 HTTP 请求）。</li><li>执行完 <code>wget</code> 命令后，退出 SSH 连接。</li><li>如果连接成功并且可以通过 HTTP 访问 AppServer VM，那么你将进入本地的 Bash shell。</li><li>因为已阻止端口 80 上的访问，所以此访问应该不会成功。 几分钟后，会收到一条 <code>Connection timed out</code> 消息。 若要在超时之前中止命令，请按 Ctrl+C。</li></ol><h2 id="部署应用安全组"><a href="#部署应用安全组" class="headerlink" title="部署应用安全组"></a>部署应用安全组</h2><p>创建应用安全组 “ERP-DB-SERVERS-ASG”：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network asg create \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 资源组的名称</span></span><br><span class="line">    --name ERP-DB-SERVERS-ASG  <span class="comment"># 应用安全组的名称</span></span><br></pre></td></tr></table></figure><p>将 DataServer 与应用安全组关联：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nic ip-config update \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 资源组的名称</span></span><br><span class="line">    --application-security-groups ERP-DB-SERVERS-ASG  <span class="comment"># 应用安全组的名称</span></span><br><span class="line">    --name ipconfigDataServer  <span class="comment"># NIC 配置的名称</span></span><br><span class="line">    --nic-name DataServerVMNic  <span class="comment"># NIC 的名称</span></span><br><span class="line">    --vnet-name ERP-servers  <span class="comment"># 虚拟网络的名称</span></span><br><span class="line">    --subnet Databases  <span class="comment"># 子网的名称</span></span><br></pre></td></tr></table></figure><p>更新网络安全组中的 HTTP 规则：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az network nsg rule update \</span><br><span class="line">    --resource-group <span class="variable">$rg</span> \  <span class="comment"># 资源组的名称</span></span><br><span class="line">    --nsg-name ERP-SERVERS-NSG  <span class="comment"># 网络安全组的名称</span></span><br><span class="line">    --name httpRule  <span class="comment"># 规则的名称</span></span><br><span class="line">    --direction Inbound  <span class="comment"># 流量方向为入站</span></span><br><span class="line">    --priority 150  <span class="comment"># 规则的优先级</span></span><br><span class="line">    --source-address-prefixes <span class="string">&quot;&quot;</span>  <span class="comment"># 源地址前缀为空，表示任意源地址</span></span><br><span class="line">    --source-port-ranges <span class="string">&#x27;*&#x27;</span>  <span class="comment"># 源端口范围为任意端口</span></span><br><span class="line">    --source-asgs ERP-DB-SERVERS-ASG  <span class="comment"># 源应用安全组为 &quot;ERP-DB-SERVERS-ASG&quot;</span></span><br><span class="line">    --destination-address-prefixes 10.0.0.4  <span class="comment"># 目标地址前缀为 DataServer 的 IP 地址</span></span><br><span class="line">    --destination-port-ranges 80  <span class="comment"># 目标端口范围为 80</span></span><br><span class="line">    --access Deny  <span class="comment"># 访问权限为拒绝</span></span><br><span class="line">    --protocol Tcp  <span class="comment"># 使用 TCP 协议</span></span><br><span class="line">    --description <span class="string">&quot;Deny from DataServer to AppServer on port 80 using application security group&quot;</span>  <span class="comment"># 规则的描述</span></span><br></pre></td></tr></table></figure><p>第一个命令将创建一个名为 “ERP-DB-SERVERS-ASG” 的应用安全组。<br>第二个命令将关联 DataServer VM 的网络接口配置（NIC）与应用安全组。<br>第三个命令将更新 ERP-SERVERS-NSG 网络安全组中的 HTTP 规则，将源地址设置为空，源端口设置为任意，源应用安全组设置为 “ERP-DB-SERVERS-ASG”，目标地址设置为 DataServer 的 IP 地址（10.0.0.4），目标端口设置为 80，并将访问权限设置为拒绝。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231121222134518.png" alt="image-20231121222134518"></p><p>应用安全组确认了网络安全组规则能正常运行，并且与使用源 IP 地址时相同。 如果我们添加了其他数据服务器，可以通过将新的服务器添加到 ERP-DB-SERVERS-ASG 来轻松地确保这些服务器具备适当的网络安全。</p>]]></content>
    
    
    <summary type="html">网络堡垒构筑：Azure Cloud Shell中的安全组策略</summary>
    
    
    
    <category term="Cloud" scheme="https://kalyan-zitiu.github.io/categories/Cloud/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Cloud/Study-Note/"/>
    
    
    <category term="Cloud" scheme="https://kalyan-zitiu.github.io/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes</title>
    <link href="https://kalyan-zitiu.github.io/2023/10/07/Kubernetes/"/>
    <id>https://kalyan-zitiu.github.io/2023/10/07/Kubernetes/</id>
    <published>2023-10-07T13:00:00.000Z</published>
    <updated>2023-10-08T01:53:36.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是K8s"><a href="#什么是K8s" class="headerlink" title="什么是K8s"></a>什么是K8s</h3><iframe width="956" height="538" src="https://www.youtube.com/embed/ubz3cFgxeJA" title="Kubernetes" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>k8s就是为了大规模管理容器应用的自动化工具而已</li><li>如果你的业务不是以容器方式管理或者数量非常小是没有必要玩k8s</li></ul><h2 id="架构以及核心组件"><a href="#架构以及核心组件" class="headerlink" title="架构以及核心组件"></a>架构以及核心组件</h2><ol><li><p>Master节点：Master节点是集群的控制面，包含以下几个核心组件：</p><ul><li><p>kube-apiserver：它是Kubernetes API的前端，是所有操作和通信的入口点。</p></li><li><p>etcd：这是一个高可用性键值存储系统，用于保存所有集群数据。</p></li><li><p>kube-scheduler：根据资源可用性、策略、约束等因素，调度新创建的Pod到合适的工作节点上。</p></li><li><p>kube-controller-manager：运行了一系列的控制器，如节点控制器、副本控制器、端点控制器等。</p></li><li><p>cloud-controller-manager: 这是一个链接你的集群与云提供商API的桥梁，使得集群能够在云环境中运行。</p></li></ul></li><li><p>Worker节点：Worker节点运行着实际的应用，并由master节点进行管理。它们包括以下组件：</p><ul><li><p>kubelet：负责维护Pods并且与Kubernetes master节点进行交互。</p></li><li><p>kube-proxy：在每个节点上实现了网络规则，以处理集群内部的通信。</p></li><li><p>vContainer Runtime：用于运行容器，如Docker、containerd等。</p></li></ul></li><li><p>Pods：这是Kubernetes的最小部署单元，每个Pod内包含一个或多个紧密相关的容器。</p></li><li><p>Services：定义了访问和通信Pods的方式。Service可以将网络流量路由到正确的Pod。</p></li><li><p>Volumes：提供存储功能，使得数据能够在Pod之间持久化。</p></li><li><p>Namespaces：为集群中的资源和对象提供隔离。</p></li><li><p>Ingress：管理外部访问集群内服务的规则，可实现负载均衡、SSL终止和域名基础的虚拟主机。</p></li><li><p>ConfigMaps and Secrets：允许你将配置信息和敏感数据分离出来，以便安全地传递和使用。</p></li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>  在Kubernetes中，用户通过API Server提交一个描述应用程序的YAML或JSON配置文件。Scheduler会根据集群资源使用情况，将应用部署到某个Node上。如果Node发生故障，Controller会自动将应用迁移到其他Node上。</p><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><h3 id="传统的服务进程管理方式"><a href="#传统的服务进程管理方式" class="headerlink" title="传统的服务进程管理方式"></a>传统的服务进程管理方式</h3><h4 id="手工繁琐-需要大量的自动化工具"><a href="#手工繁琐-需要大量的自动化工具" class="headerlink" title="手工繁琐:需要大量的自动化工具"></a>手工繁琐:需要大量的自动化工具</h4><ol><li><p>Ansible： Ansible 是一种配置管理和自动化工具，可用于编写声明性的配置文件来定义服务器的状态。您可以使用 Ansible 来自动化服务器的设置、软件安装、配置文件管理等操作。</p></li><li><p>Chef： Chef 是一个自动化平台，允许您编写基础设施即代码。您可以使用 Chef 来定义服务器的状态，并在需要时自动配置服务器和部署服务。</p></li><li><p>Puppet： Puppet 是另一个配置管理工具，允许您定义服务器配置的期望状态，并确保服务器始终保持一致。</p></li><li><p>SaltStack： SaltStack 是一个事件驱动的自动化工具，可以用于自动配置和管理服务器，以及执行各种任务。</p></li><li><p>Jenkins： Jenkins 是一个持续集成和持续交付工具，可以用于自动化构建、部署和测试应用程序。您可以将 Jenkins 配置为监视代码仓库，并在代码提交后自动触发部署流程。</p></li><li><p>Docker Compose： 如果您希望使用 Docker 容器来部署传统的服务进程，可以使用 Docker Compose 来定义和管理多个容器的部署。</p></li><li><p>Terraform： 虽然 Terraform 主要用于基础设施即代码，但您可以使用它来自动化创建和管理服务器、网络、存储等资源。</p></li><li><p>Kubernetes Operator： 尽管 Kubernetes 本身是一个容器编排平台，但您可以使用 Kubernetes Operator 来创建自定义控制器，以自动化管理和部署特定类型的应用程序。</p></li></ol><h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><ol><li><p>准备环境： 在目标虚拟机或物理机上设置所需的操作系统和依赖项。这可能涉及安装操作系统、更新软件包、安装运行时环境（如Java、Node.js等）等。</p></li><li><p>安装服务进程： 将服务进程的执行文件和相关文件传输到目标机器，并将其安装到适当的位置。这可能涉及将二进制文件复制到目标目录，并设置执行权限。</p></li><li><p>配置服务： 编辑服务的配置文件，配置它所需的参数，例如端口号、数据库连接、认证凭据等。这些配置可能会存储在配置文件中，也可能存储在环境变量中。</p></li><li><p>启动服务： 使用特定的命令或脚本启动服务进程。这可以是一个简单的命令，例如 ./my-service，也可能是一系列复杂的操作。</p></li><li><p>监控和日志： 配置监控和日志记录，以便能够监视服务的运行状态和性能，以及收集服务的日志信息。</p></li><li><p>管理和维护： 随着时间的推移，您可能需要执行服务的升级、修复漏洞、处理配置更改等操作。这可能需要定期的维护和管理。</p></li></ol><h3 id="容器应用管理方式"><a href="#容器应用管理方式" class="headerlink" title="容器应用管理方式"></a>容器应用管理方式</h3><ul><li>Pod：Pod是Kubernetes中最小的可部署单元，它可以包含一个或多个容器。Pod提供了一个运行容器的环境，并且这些容器共享网络和存储资源。Pod可以被创建、启动、停止、删除等操作。</li></ul><ul><li>Deployment：Deployment是用来管理Pod的对象。它定义了应用程序的期望状态，Kubernetes会根据定义的副本数来创建和管理Pod。Deployment还支持滚动升级和回滚操作，可以方便地更新应用程序。</li></ul><ul><li>Service：Service是用来暴露应用程序的网络服务的对象。它为一组Pod提供了一个稳定的网络地址，并且可以通过这个地址来访问这些Pod。Service可以提供负载均衡、服务发现和服务代理等功能。</li></ul><ul><li>Ingress：Ingress是用来管理应用程序的入口流量的对象。它可以将外部流量路由到不同的Service，实现基于域名或路径的流量分发。Ingress还支持SSL/TLS终止和基本的身份验证等功能。</li></ul><ul><li>ConfigMap和Secret：ConfigMap用来存储应用程序的配置信息，可以通过环境变量或挂载文件的方式将配置信息传递给容器。Secret用来存储敏感的配置信息，如密码、API密钥等。ConfigMap和Secret可以在应用程序中被引用和使用。</li></ul><ul><li>StatefulSet：StatefulSet用来管理有状态应用程序的对象。它可以确保每个Pod有唯一的标识和稳定的网络身份，这对于需要持久化存储和有序部署的应用程序非常重要。</li></ul><h2 id="服务发现与负载均衡"><a href="#服务发现与负载均衡" class="headerlink" title="服务发现与负载均衡"></a>服务发现与负载均衡</h2><p>服务发现和负载均衡是通过 Service 和 Ingress 对象来实现的。</p><ol><li>Service：<br> Service 是 Kubernetes 的核心概念之一，它为一组运行相同任务的 Pod 提供了一个统一的访问接口。当 Service 创建后，Kubernetes 会自动为其分配一个 IP 地址（称为 ClusterIP），并且在整个集群内部都可以使用这个 IP 地址进行访问。</li></ol><p>  当请求到达 Service 后，Kubernetes 会根据预设的策略将请求转发给后端的 Pod。这种策略通常是轮询（Round Robin）或者是基于 Session 的粘性 Session Affinity，也可以配置更复杂的网络策略。这就完成了负载均衡的功能。</p><p>  Service 还有一个重要的特性，那就是它可以做到服务发现。每个 Service 在创建时，除了会被分配一个 ClusterIP 外，还会在 Kubernetes 集群的内部 DNS 中创建一个记录。这样其他的 Pod 就可以通过 Service 的名字来找到它，而不需要知道具体的 IP 地址。</p><ol start="2"><li>Ingress：<br> 虽然 Service 可以提供内部的服务发现和负载均衡，但是如果我们希望从集群外部访问某个服务，就需要用到 Ingress。Ingress 是 Kubernetes 的一个对象，它定义了如何通过 HTTP 或 HTTPS 协议从集群外部访问内部的 Service。</li></ol><p>  当一个请求到达 Ingress 后，Ingress Controller 会根据预定义的规则将请求路由（Route）到相应的 Service。这样我们就可以用一个统一的入口来访问集群内部的多个服务，而不需要为每个服务都暴露一个端口出来。</p><p>  另外，Ingress 还可以提供其他的功能，比如 SSL/TLS 终止、基于路径或者域名的路由，甚至是负载均衡和重试等。</p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Kubernetes支持多种存储解决方案，包括本地存储、网络存储（如NFS、iSCSI、GlusterFS等）以及云存储（如AWS EBS、GCE PD等）。同时，Kubernetes还提供了Persistent Volume (PV) 和 Persistent Volume Claim (PVC) 的抽象概念，使得用户可以在不了解具体存储技术的情况下，也能使用持久化存储。</p><h3 id="本地存储："><a href="#本地存储：" class="headerlink" title="本地存储："></a>本地存储：</h3><p>  这是最简单的存储方式，即在Pod所在的节点上直接分配磁盘空间。但它的生命周期与Pod相同，当Pod被删除时，数据也会丢失。而且，如果Pod迁移到其他节点，数据将无法访问。因此，本地存储主要用于临时性的、不需要长期保存的数据。</p><h3 id="网络存储："><a href="#网络存储：" class="headerlink" title="网络存储："></a>网络存储：</h3><p>  为了解决本地存储的限制，我们可以使用网络存储。网络存储就是通过网络协议，将远程服务器上的存储资源连接到本地，使其看起来像是本地的磁盘。常见的网络存储协议包括NFS（Network File System）、iSCSI (Internet Small Computer Systems Interface) 和 GlusterFS等。这些网络存储解决方案提供了跨节点的、可共享的、持久性的存储。</p><h3 id="云存储："><a href="#云存储：" class="headerlink" title="云存储："></a>云存储：</h3><p>  对于在公有云平台上运行的Kubernetes集群，通常会使用云存储服务，如AWS的EBS (Elastic Block Store) 或者GCE的PD (Persistent Disk)。这些云存储服务通常提供了高可用、高性能和自动备份等高级功能。</p><h4 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h4><ul><li>是 Amazon Web Services 的一项服务，提供持久化、高性能、块级存储，可以与 AWS 的 EC2 实例一起使用。你可以创建一个 EBS 卷并将其附加到 EC2 实例上。然后，你可以像使用物理硬盘驱动器一样使用这个卷，包括文件系统、数据库或者应用程序等。EBS 提供了几种类型的卷，以满足不同的需求，例如：通用 SSD（gp2）、预配置 IOPS SSD（io1/io2）、吞吐优化 HDD（st1）、冷 HDD（sc1）和磁性（标准）。</li></ul><h4 id="PD"><a href="#PD" class="headerlink" title="PD"></a>PD</h4><p>Google Cloud Platform 的一项服务，为 Google Compute Engine 和 Google Kubernetes Engine 提供持久化、高性能的块存储。你可以创建一个 PD 卷并将其附加到 GCE 或 GKE 上的虚拟机实例。PD 提供了两种类型的卷：标准硬盘（HDD）和 SSD。SSD 可以分为常规 SSD 和高性能 Provisioned IOPS SSD。</p><h3 id="Persistent-Volume-PV-："><a href="#Persistent-Volume-PV-：" class="headerlink" title="Persistent Volume (PV)："></a>Persistent Volume (PV)：</h3><p>  Kubernetes引入了PV和PVC的概念，以解决存储的生命周期管理问题。PV是集群中的一块独立的存储空间，它与Pod的生命周期独立，即使Pod被删除，PV中的数据也不会丢失。管理员可以预先创建多个PV，并指定其大小、访问模式（只读、读写）等属性。</p><h3 id="Persistent-Volume-Claim-PVC-："><a href="#Persistent-Volume-Claim-PVC-：" class="headerlink" title="Persistent Volume Claim (PVC)："></a>Persistent Volume Claim (PVC)：</h3><p>  用户如果需要使用PV，必须通过创建一个PVC来申请。在PVC中，用户可以指定所需的存储空间大小、访问模式等信息。然后Kubernetes会自动匹配合适的PV给用户。当不再需要这个存储空间时，用户可以删除PVC，对应的PV会被释放，但数据不会丢失，除非管理员显式地删除PV。</p><h2 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h2><ol><li>日志：Kubernetes本身不提供一个原生的日志聚合解决方案，但是它允许使用各种通用的日志聚合工具。例如：</li></ol><p>Fluentd：一款开源数据收集器，可以整合各种类型的数据源，并将数据发送到多种类型的目标系统。</p><p>Logstash：这是Elastic Stack（ELK Stack）中的一部分，用于接收、处理和转发事件和日志消息。</p><p>Stackdriver Logging：Google Cloud Platform上的日志管理服务，也可以用于Kubernetes。</p><ol start="2"><li>监控：Kubernetes有内建的资源利用率和性能指标，比如CPU和内存使用情况。你可以使用以下工具来可视化这些数据：</li></ol><p>Prometheus：开源的监控和警告工具，与Kubernetes紧密集成，可以收集各种指标并提供强大的查询语言。</p><p>Grafana：开源的度量分析和可视化套件，经常与Prometheus一起使用，以图形方式展示Prometheus收集的数据。</p><p>Google Cloud Monitoring：Google Cloud Platform的服务，提供了完全托管的端到端IT运营管理平台，包括监控、日志管理和应用程序性能管理。</p><h2 id="Kubernetes与其他技术集成"><a href="#Kubernetes与其他技术集成" class="headerlink" title="Kubernetes与其他技术集成"></a>Kubernetes与其他技术集成</h2><ol><li>云服务提供商：Kubernetes 可以运行在各种环境中，包括公有云、私有云和混合云。AWS、Google Cloud 和 Azure 都提供了 Kubernetes 服务，如 Amazon EKS、Google GKE 和 Azure AKS。</li></ol><ol start="2"><li>CI/CD 工具：持续集成和持续部署（CI/CD）是现代 DevOps 实践的核心组成部分。Jenkins、GitLab CI、CircleCI 等工具都可以与 Kubernetes 集成，以自动化构建、测试和部署流程。</li></ol><ol start="3"><li>服务网格：服务网格用于控制服务间的通信。Istio 和 Linkerd 是两个常见的服务网格，它们可以与 Kubernetes 集成，提供高级路由、负载均衡、故障注入等功能。</li></ol><ol start="4"><li>配置管理：Helm 是 Kubernetes 的一个包管理器，类似于 Linux 中的 apt 或 yum。你可以使用 Helm 来打包、发布和管理 Kubernetes 应用。</li></ol><ol start="5"><li>安全性和策略执法：Open Policy Agent (OPA) 是一个轻量级的、通用的策略引擎，可以与 Kubernetes 集成，用于策略执法。</li></ol><ol start="6"><li>存储系统：Kubernetes 可以与各种存储系统集成，包括云存储服务（如 AWS EBS 和 Google Cloud Storage）、分布式文件系统（如 Ceph 和 GlusterFS）和数据库系统（如 MySQL 和 PostgreSQL）。</li></ol>]]></content>
    
    
    <summary type="html">一个开源的容器编排系统，用于自动化应用程序容器的部署、扩展和管理</summary>
    
    
    
    <category term="Cloud Konwleage" scheme="https://kalyan-zitiu.github.io/categories/Cloud-Konwleage/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Cloud-Konwleage/Study-Note/"/>
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>OS</title>
    <link href="https://kalyan-zitiu.github.io/2023/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://kalyan-zitiu.github.io/2023/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-10-05T06:00:00.000Z</published>
    <updated>2023-10-07T06:20:06.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="第一部分：操作系统概述"><a href="#第一部分：操作系统概述" class="headerlink" title="第一部分：操作系统概述"></a>第一部分：操作系统概述</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>  是管理计算机硬件与软件资源的程序，是计算机系统中最基本的系统软件。操作系统需要处理管理与配置内存，决定系统资源供需的优先级，控制输入设备与输出设备，操作网络和管理文件系统等基本事务。</p><p><strong>注意：</strong>执行一个程序前需要将该程序放到内存中，才能被CPU处理。</p><h4 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h4><ul><li>硬件之上</li><li>应用程序之下</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231001154949996.png" alt="image-20231001154949996"></p><ol><li>Linux,windows,Android界面属于外壳（shell）而不是内核（kernel），内核在外壳之下</li></ol><h4 id="kernel内部组件"><a href="#kernel内部组件" class="headerlink" title="kernel内部组件"></a>kernel内部组件</h4><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h3 id="1-2操作系统的类型和结构"><a href="#1-2操作系统的类型和结构" class="headerlink" title="1.2操作系统的类型和结构"></a>1.2操作系统的类型和结构</h3><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><ul><li><p>联机命令接口（Online Command Interface）：这种接口需要用户在命令执行过程中实时交互。例如，当一个程序运行时，它可能需要用户输入数据或选择选项。这种接口通常用于交互式应用程序，如文本编辑器或电子邮件客户端。在这种接口中，用户和计算机之间的交互是实时的，即用户的每个操作都会立即得到计算机的反馈。</p></li><li><p>脱机命令接口（Offline Command Interface）：这种接口允许用户在没有实时交互的情况下执行命令。用户可以预先设置一系列的命令，然后让计算机在适当的时间执行。这种接口通常用于批处理任务，如数据分析或报告生成。在这种接口中，用户和计算机之间的交互不是实时的，用户可以在任何时间设置命令，然后离开，等待计算机完成任务。</p></li></ul><h4 id="操作系统的类型"><a href="#操作系统的类型" class="headerlink" title="操作系统的类型"></a>操作系统的类型</h4><ol><li>批处理操作系统：这种类型的操作系统不与用户交互。所有需要执行的命令都被组织在批处理中，然后作为一个作业提交给系统。</li><li>多任务/多进程操作系统：也叫分时操作系统,这种类型的操作系统允许多个任务或进程同时运行。如Unix操作系统</li><li>多用户操作系统：这种类型的操作系统允许多个用户同时使用一个系统。</li><li>实时操作系统：这种类型的操作系统被设计用于实时应用程序，这些应用程序需要对事件的响应非常迅速。</li><li>分布式操作系统：这种类型的操作系统将多台机器的资源整合在一起，对用户来说就像一台机器一样。</li><li>嵌入式操作系统：这种类型的操作系统主要用于嵌入式系统，如家用电器、汽车等。</li></ol><h4 id="操作系统的基本结构"><a href="#操作系统的基本结构" class="headerlink" title="操作系统的基本结构"></a>操作系统的基本结构</h4><ol><li>单体结构：所有操作系统功能都被组织在一起并运行在同一地址空间。</li><li>分层结构：操作系统被划分为不同的层次，每一层都建立在其下一层的基础上。</li><li>微内核结构：只有最基本的系统功能（如进程调度、内存管理等）运行在内核空间，其他服务则运行在用户空间。</li><li>客户-服务器模型：这种结构将操作系统服务视为服务器，应用程序视为客户。客户通过向服务器发送请求来使用服务。</li><li>虚拟机：这是一种特殊的操作系统结构，它通过虚拟化技术模拟出一台或多台“虚拟”计算机，每台虚拟计算机都可以运行一个完整的操作系统。</li></ol><h3 id="1-3操作系统的四大特征"><a href="#1-3操作系统的四大特征" class="headerlink" title="1.3操作系统的四大特征"></a>1.3操作系统的四大特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ol><li><p>两个或多个事件在同一事件间隔内发生，这件事是在宏观上同时发生的，但微观上交替发生。</p></li><li><p>与并发不同的并行是指两个或多个事件在同一时刻同时发生。</p></li></ol><h5 id="操作系统的并发性"><a href="#操作系统的并发性" class="headerlink" title="操作系统的并发性"></a>操作系统的并发性</h5><p>操作系统就是伴随着“多道程序技术”而出现的。因此操作系统和程序并发是一起诞生的。</p><p><strong>注意：</strong></p><ol><li>单核CPU同一时刻只能执行一个程序，各个程序只能并发执行。</li><li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行执行。</li></ol><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><h5 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h5><p>在任意时刻，只允许一个进程访问资源，当一个进程正在访问某个资源时，其他需要访问资源的进程必须要等待。</p><h5 id="“同时”共享方式"><a href="#“同时”共享方式" class="headerlink" title="“同时”共享方式"></a>“同时”共享方式</h5><p>允许同一时刻，多个进程同时访问同一资源。能够被多个进程同时使用。</p><h5 id="并发和共享的关系。"><a href="#并发和共享的关系。" class="headerlink" title="并发和共享的关系。"></a>并发和共享的关系。</h5><p>  并发和共享的关系是相辅相成的，二者在操作系统中是密不可分的。并发运行的多个程序共享同一套系统资源，比如CPU时间、内存空间、文件系统和输入输出设备等。因此，共享是并发存在的基础。反过来，如果没有并发，也就没有资源共享的必要性。</p><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ol><li>是用多道程序设计技术。</li><li>操作系统将物理资源抽象为虚拟资源，如虚拟内存，虚拟处理器和虚拟设备等。虚拟性使得多个程序可以独立运行，它们实际上是共享同一组物理资源得虚拟实例。虚拟性提供了更好的资源管理和隔离性能。提高了系统的可靠性和安全性。</li></ol><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ol><li>任务的执行不需要等待前一个任务的完成才能执行下一个任务的能力。在异步操作中，任务可以并行执行或按照优先级进行调度，不依赖其他任务的完成状态。</li><li>程序的执行不是一贯到底，而是走停交接，推进的速度是不可预知的。</li><li>只要运行环境相同，OS需要保证程序运行的结果也要相同。</li></ol><h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li>DISK：存放OS，一开始是放在硬盘上，并没有在cpu上</li><li>BIOS：基本的IO处理系统，检测外设</li><li>Bootloader：加载OS，把硬盘中的OS放在CPU上</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20231001180454793.png" alt="image-20231001180454793"></li></ul><h4 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h4><ol><li>加电自检（Power-On Self-Test，POST）：计算机开机后，会进行一系列的硬件自检，包括检查内存、显示适配器、硬盘驱动器等。如果自检过程中发现硬件故障，计算机可能会发出警报或显示错误信息。</li></ol><ol start="2"><li>BIOS/UEFI 初始化：自检完成后，计算机会加载并执行基本输入/输出系统（Basic Input/Output System，BIOS）或统一固件接口（Unified Extensible Firmware Interface，UEFI）。BIOS/UEFI负责初始化硬件设备，包括检测和配置内存、硬盘驱动器、键盘、鼠标等。</li></ol><ol start="3"><li>引导加载程序（Boot Loader）：BIOS/UEFI会在启动设备（通常是硬盘驱动器）上查找引导加载程序。引导加载程序是一个小型的程序，负责加载操作系统的核心组件。</li></ol><ol start="4"><li>操作系统内核加载：引导加载程序会加载操作系统内核到计算机的内存中。内核是操作系统的核心部分，负责管理计算机的资源和提供各种系统服务。</li></ol><ol start="5"><li>初始化和配置：操作系统内核加载后，会进行初始化和配置过程。这包括初始化设备驱动程序、建立系统数据结构、加载配置文件等。</li></ol><ol start="6"><li>用户登录：一旦操作系统初始化完成，计算机会显示登录界面，用户可以输入用户名和密码进行登录。</li></ol><ol start="7"><li>桌面环境加载：用户登录后，操作系统会加载桌面环境，例如Windows的资源管理器或Linux的图形用户界面（Graphical User Interface，GUI）。桌面环境提供了用户与计算机交互的图形界面。</li></ol><h3 id="中断，异常和系统调用"><a href="#中断，异常和系统调用" class="headerlink" title="中断，异常和系统调用"></a>中断，异常和系统调用</h3><h4 id="中断（来源于外设-异步处理）"><a href="#中断（来源于外设-异步处理）" class="headerlink" title="中断（来源于外设/异步处理）"></a>中断（来源于外设/异步处理）</h4><ul><li> 来自不同的硬件设备的计时器和网络的中断。</li><li> 操作系统回中断当前正在执行的程序，保存当前状态，并跳转道中断处理程序处理该事件。</li><li> 允许操作系统对外部事件做出及时响应</li><li> 持续,对用户程序是透明的.<h5 id="及时响应"><a href="#及时响应" class="headerlink" title="及时响应"></a>及时响应</h5></li><li>合理的时间内对外部事件做出快速的反应和处理.</li><li>意味着操作系统能够迅速中断当前程序,并跳转道相应的中断处理程序来处理事件.</li></ul><h4 id="系统调用（来源于应用程序-异步或同步处理）"><a href="#系统调用（来源于应用程序-异步或同步处理）" class="headerlink" title="系统调用（来源于应用程序/异步或同步处理）"></a>系统调用（来源于应用程序/异步或同步处理）</h4><ul><li>应用程序主动向操作系统发出服务请求</li><li>等待和持续</li></ul><h4 id="异常（来源于不良的应用程序-同步处理）"><a href="#异常（来源于不良的应用程序-同步处理）" class="headerlink" title="异常（来源于不良的应用程序/同步处理）"></a>异常（来源于不良的应用程序/同步处理）</h4><ul><li>执行程序中出现错误或异常的情况,例如除零错误,无效指令或内存访问错误.</li><li>杀死或重新执行意想不到的应用程序指令</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="2-1-进程的概念"><a href="#2-1-进程的概念" class="headerlink" title="2.1 进程的概念"></a>2.1 进程的概念</h3><ul><li>进程是操作系统就进行资源分配和调度的基本单位,是由程序,数据以及进程控制块三部分组成.</li><li>每个进程都有自己独立的空间地址,无法访问其他进程的内存,它们之间的信息交换需要通过操作系统提供的机制进行<h3 id="2-2-进程的生命周期"><a href="#2-2-进程的生命周期" class="headerlink" title="2.2 进程的生命周期"></a>2.2 进程的生命周期</h3>进程的生命周期由以下五个状态组成：</li><li>新建：进程刚被创建，但还未被调度到运行的状态。</li><li>就绪：进程已经准备好运行，正在等待系统分配资源。</li><li>运行：进程正在CPU上执行。</li><li>等待（阻塞）：进程因为某些事件（比如I/O操作）而暂停执行。</li><li>结束：进程已经完成执行。</li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>除了上面的五大基本状态外还会存在一些特殊的状态:</p><ol><li><p><strong>僵尸（Zombie）状态</strong>：当一个进程完成执行（终止）后，它需要将退出状态返回给父进程。如果父进程还没有请求这个状态信息，那么终止的进程就会进入僵尸状态。僵尸进程不再执行任何操作，但仍然在进程表中占据一个位置，直到父进程获取了其状态信息。例如，如果你在Linux终端中运行一个程序并且这个程序已经结束，但是你没有关闭终端，那么这个程序就是一个僵尸进程。</p></li><li><p><strong>孤儿（Orphan）状态</strong>：如果一个进程的父进程在它之前结束，那么这个进程就会变成孤儿进程。孤儿进程将被init进程（在Unix和Linux系统中，init是一个始终运行的进程，它是所有其他进程的祖先）接管，init会周期性地收集这些孤儿进程的状态信息，防止它们变成僵尸进程。例如，如果你在Linux终端中运行一个后台程序（使用&amp;运行），然后关闭终端，那么这个程序就会成为孤儿进程。</p></li><li><p><strong>阻塞（Blocked）状态</strong>：进程因为等待某个事件（如I/O操作）完成而无法继续运行，即使CPU是空闲的，这个进程也不会被调度到CPU上运行，直到所等待的事件完成。例如，如果一个进程正在读取一个非常大的文件，而这个文件的读取需要一些时间，那么在这个时间内，进程就会处于阻塞状态。</p></li><li><p><strong>后台（Background）状态</strong>：后台进程是在后台运行的进程，它们在命令行界面中被启动并放在后台运行，不会影响用户在前台的操作。例如，如果你在Linux终端中使用&amp;运行一个程序，那么这个程序就会在后台运行。</p></li><li><p><strong>睡眠（Sleeping）状态</strong>：进程正在等待某个条件变为真，例如等待时间、等待某个信号、等待资源可用等。在睡眠状态的进程不会占用CPU资源。例如，如果一个进程正在等待用户的输入，那么在用户输入之前，这个进程就会处于睡眠状态。</p></li><li><p><strong>停止（Stopped）状态</strong>：进程由于收到信号而被停止，例如用户可以发送SIGSTOP信号来停止一个进程。停止的进程可以通过SIGCONT信号来恢复执行。例如，如果你在Linux终端中运行一个程序，并且使用Ctrl+Z暂停它，那么这个程序就会进入停止状态。</p></li></ol><h3 id="2-3-进程调度"><a href="#2-3-进程调度" class="headerlink" title="2.3 进程调度"></a>2.3 进程调度</h3><p>进程调度是操作系统的重要功能之一，它决定了哪个进程可以获得CPU的使用权，以及可以使用多长时间。这通常由操作系统的调度策略决定，比如先来先服务（FCFS）、短作业优先（SJF）、优先级调度、时间片轮转（RR）等。</p><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>进程按照它们到达的顺序进行调度。例如，打印作业通常使用FCFS调度，因为我们希望打印任务按照提交的顺序完成。</p><h4 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h4><p>选择最短的作业（进程）首先执行。例如，在批处理系统中，我们可能希望最短的作业先完成，以便快速释放系统资源。</p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>每个进程都有一个优先级，优先级高的进程先执行。例如，在实时系统中，我们可能需要某些关键任务（如飞机的飞行控制）具有高于其他任务的优先级。</p><h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h4><p>进程被赋予一个固定的时间片（或称为时间量）。当一个进程的时间片用完时，操作系统就会剥夺该进程的CPU，将其转移到就绪队列的末尾，然后将CPU分配给下一个进程。这种调度算法常用于交互式系统，例如，多用户系统中，为了让每个用户都有公平的CPU使用时间，通常使用时间片轮转调度算法。</p><h3 id="2-4-多进程和多线程"><a href="#2-4-多进程和多线程" class="headerlink" title="2.4 多进程和多线程"></a>2.4 多进程和多线程</h3><p>多进程和多线程是操作系统中两种重要的并发执行技术。它们都可以提高系统的性能和响应时间，但是它们的实现方式和使用场景有所不同。</p><ol><li>多进程：</li></ol><p>进程是操作系统进行资源分配和调度的基本单位，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。多进程意味着有多个进程同时运行。每个进程都有自己的独立地址空间，进程之间的通信需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。</p><p>优点：每个进程有自己的独立地址空间，一个进程崩溃不会影响其他进程，安全性和稳定性较高。</p><p>缺点：进程的创建和销毁以及进程切换的开销较大，进程间通信复杂。</p><ol start="2"><li>多线程：</li></ol><p>线程是进程中的执行单元，是CPU调度和分派的基本单位。一个进程可以包含多个线程，它们共享进程的地址空间和资源，线程之间的通信比进程间通信更简单。</p><p>优点：线程的创建和销毁以及线程切换的开销小于进程，线程间通信简单。</p><p>缺点：因为线程共享进程的地址空间和资源，一个线程崩溃可能会影响整个进程，安全性和稳定性较低。</p><p>在实际应用中，多进程通常用于CPU密集型任务，如科学计算、图像处理等，而多线程通常用于IO密集型任务，如网络服务、图形界面等。</p><h4 id="进程间通信（IPC）机制"><a href="#进程间通信（IPC）机制" class="headerlink" title="进程间通信（IPC）机制"></a>进程间通信（IPC）机制</h4><ol><li><p>管道（Pipe）：管道是最早的IPC机制之一，它允许一个进程向另一个进程传递数据。管道通常遵循“先进先出”（FIFO）原则，数据从管道的一端进入，从另一端出来。</p></li><li><p>消息队列（Message Queue）：消息队列允许一个或多个进程向队列中添加消息，其他进程可以从队列中读取或删除消息。消息队列是一种比管道更灵活的IPC机制，因为它允许多个进程同时读写消息。</p></li></ol><ol start="3"><li>信号（Signal）：信号是一种用于通知进程某个事件已经发生的IPC机制。当一个进程收到一个信号时，它可以选择忽略这个信号、捕获并处理这个信号，或者按照默认的方式处理这个信号。</li></ol><ol start="4"><li>共享内存（Shared Memory）：共享内存允许多个进程访问同一块内存区域。这是一种非常高效的IPC机制，因为进程可以直接读写这块内存，而无需通过操作系统进行数据传输。但是，使用共享内存需要解决数据访问的同步问题，以防止多个进程同时修改同一块内存。</li></ol><ol start="5"><li>套接字（Socket）：套接字是一种网络通信的IPC机制，它允许运行在不同机器上的进程进行通信。套接字可以支持TCP/IP、UDP等多种网络协议。</li></ol><ol start="6"><li>信号量（Semaphore）：信号量主要用于解决多进程同步问题，它是一个整数值，可以用于控制对共享资源的访问。</li></ol><h3 id="2-5-线程的概念和实现"><a href="#2-5-线程的概念和实现" class="headerlink" title="2.5 线程的概念和实现"></a>2.5 线程的概念和实现</h3><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。每个线程都有自己的一组CPU寄存器（如程序计数器，堆栈指针，累加器等），以及自己的堆栈空间，用于保存运行中的临时数据。但线程并不拥有系统资源，它与其它线程共享所属进程的资源。线程的实现主要有两种方式：用户级线程和内核级线程。</p><h4 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h4><p>用户级线程和内核级线程是两种不同的线程实现方式，它们的主要区别在于管理线程的实体不同，以及对操作系统可见性的不同。</p><ol><li><p>用户级线程（User-Level Threads）：</p><p>用户级线程是完全在用户级别运行的线程，也就是说线程的创建、调度和管理都是由用户程序自行完成的，操作系统对其一无所知。这种方式的优点是线程切换开销小，不需要进行系统调用，同时可以定制化线程调度算法。但是，缺点是如果一个线程开始进行阻塞操作，那么整个进程（包括其中的所有线程）都会被阻塞，因为操作系统只能看到进程级别的阻塞。另外，由于操作系统对用户级线程不可见，因此不能利用多处理器并行处理。</p></li><li><p>内核级线程（Kernel-Level Threads）：</p><p>内核级线程是由操作系统内核进行管理的线程。线程的创建、调度和管理都是由操作系统内核完成。这种方式的优点是，由于线程对操作系统可见，因此一个线程进行阻塞操作时，不会影响到同一进程中的其他线程，同时可以利用多处理器进行并行处理。但是，缺点是线程切换需要进行系统调用，开销比用户级线程大。</p></li></ol><h2 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h2><h3 id="3-1-并发性的概念"><a href="#3-1-并发性的概念" class="headerlink" title="3.1 并发性的概念"></a>3.1 并发性的概念</h3><p>并发性是指两个或多个事件在同一时间间隔内发生。在计算机科学中，这通常指的是能够让多个任务在一段时间内同时运行的能力。并发并不意味着这些事件必须在同一时刻发生，实际上，在多核处理器中，这可能会发生，但在单核处理器中，这些事件是交替发生的。</p><h3 id="3-2-临界区和互斥"><a href="#3-2-临界区和互斥" class="headerlink" title="3.2 临界区和互斥"></a>3.2 临界区和互斥</h3><p>临界区是一个代码区域，其中包含访问共享资源的代码，这些资源在任何时候只能被一个线程使用。为了避免资源的冲突访问，必须确保在同一时间只有一个线程能够执行临界区的代码，这就需要使用互斥机制。</p><p>互斥是一种保护共享资源不被多个线程同时访问的方法。实现互斥的一种常见方法是使用锁，一个线程在访问资源时会锁定它，阻止其他线程访问，当它完成后会解锁，允许其他线程访问。</p><h3 id="3-3-死锁的概念和处理"><a href="#3-3-死锁的概念和处理" class="headerlink" title="3.3 死锁的概念和处理"></a>3.3 死锁的概念和处理</h3><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局（即阻塞状态），若无外力作用，它们都将无法推进下去。</p><h4 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h4><ol><li><p>预防死锁：这是最直接的方式，通过确保系统在分配资源时不满足死锁的4个必要条件（互斥、占有并等待、不可抢占、循环等待）中的一个或多个，从而预防死锁的发生。例如，只允许进程在没有占有任何资源的情况下请求资源，或者只允许进程一次性请求所有需要的资源。</p></li><li><p>避免死锁：在资源分配时采用某种算法进行动态检测，例如银行家算法，通过预测分配资源后系统的状态，如果可能导致死锁，则不分配。</p></li><li><p>检测死锁：定期检查系统资源分配状态，如果发现死锁，则进行处理。这种方法需要系统维护一个资源分配图，并定期进行检查。</p></li><li><p>解除死锁：当检测到死锁后，采取一些措施来解除死锁，例如撤销进程、剥夺资源、进程回滚等。</p></li></ol><p>实践中，处理死锁的方法需要根据系统的具体需求和资源管理策略来选择。有些系统可能会选择预防或避免死锁，而有些系统可能会选择允许死锁的发生，但会设定一定的机制来检测和解除死锁。</p><h3 id="3-4-同步机制"><a href="#3-4-同步机制" class="headerlink" title="3.4 同步机制"></a>3.4 同步机制</h3><p>同步是指在多个进程（或线程）中，为了保证这些进程（或线程）之间能有序地访问某些共享资源或完成某些特定任务，需要它们之间进行某种协调或通信。</p><h4 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h4><p>信号量是一个整数值，可以用来解决临界区问题，实现进程或线程之间的同步与互斥。信号量有两种操作：P（等待）和V（信号）。P操作会检查信号量的值，如果值大于零则将其减一；如果值为零则挂起执行。V操作则会将信号量的值加一，如果有挂起的进程或线程，则唤醒它们。</p><h4 id="条件变量（Condition-Variables）"><a href="#条件变量（Condition-Variables）" class="headerlink" title="条件变量（Condition Variables）"></a>条件变量（Condition Variables）</h4><p>条件变量常与互斥锁（Mutex）一起使用，用于线程间的同步。一个线程会因为某个条件不满足而在条件变量上等待，当条件满足时，另一个线程会通知在条件变量上等待的线程。</p><h4 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h4><p>管程是一种同步机制，它将共享变量的操作和条件检查集中在一个数据结构中，通过对这个数据结构的互斥访问实现同步。管程内部通常包含共享变量、操作共享变量的一组过程、以及用于同步的条件变量。</p><h4 id="消息传递（Message-Passing）"><a href="#消息传递（Message-Passing）" class="headerlink" title="消息传递（Message Passing）"></a>消息传递（Message Passing）</h4><p>消息传递是一种进程间通信方式，进程通过发送和接收消息进行通信。消息传递可以是同步的（发送者发送消息后必须等待接收者接收消息），也可以是异步的（发送者发送消息后可以继续执行，不必等待接收者接收消息）。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="4-1-内存的概念"><a href="#4-1-内存的概念" class="headerlink" title="4.1 内存的概念"></a>4.1 内存的概念</h3><p>内存是计算机的一种重要硬件设备，它用于存储和获取数据。内存是计算机中的临时存储区域，它可以在短时间内存储大量的信息，并且可以被处理器快速访问。内存是由一系列的存储单元组成，每个存储单元都有一个唯一的地址，用于标识数据的位置。</p><h3 id="4-2-内存分配策略"><a href="#4-2-内存分配策略" class="headerlink" title="4.2 内存分配策略"></a>4.2 内存分配策略</h3><p>内存分配策略是操作系统用于管理内存的方法，主要有以下几种：</p><ul><li>首次适应（First Fit）：这种方法是在内存中查找第一个足够大的空闲区域分配给进程。</li><li>最佳适应（Best Fit）：这种方法是在内存中查找最小但足够大的空闲区域分配给进程。</li><li>最坏适应（Worst Fit）：这种方法是在内存中查找最大的空闲区域分配给进程。</li></ul><h3 id="4-3-分页和分段"><a href="#4-3-分页和分段" class="headerlink" title="4.3 分页和分段"></a>4.3 分页和分段</h3><p>分页和分段是两种内存管理技术。</p><ul><li><p>分页：是将物理内存分成固定大小的页，每页的大小通常设置为4KB。当程序需要内存时，操作系统会分配一个或多个页。分页可以减少内存碎片，提高内存利用率。</p></li><li><p>分段：是将程序分成一些逻辑上独立的段，每个段可以独立地加载到内存中。分段可以使程序更易于理解和修改，也可以提高内存利用率。</p></li></ul><h3 id="4-4-虚拟内存和页面替换算法"><a href="#4-4-虚拟内存和页面替换算法" class="headerlink" title="4.4 虚拟内存和页面替换算法"></a>4.4 虚拟内存和页面替换算法</h3><p>虚拟内存是一种内存管理技术，它使得程序可以使用比物理内存更多的内存。虚拟内存通过将内存和硬盘结合起来，使得程序可以使用硬盘上的空间作为内存使用。</p><p>页面替换算法是虚拟内存系统中的一种技术，用于决定当内存已满时，哪个页面应该被替换出内存。常见的页面替换算法有FIFO（先进先出）、LRU（最近最少使用）等。</p><h4 id="FIFO（先进先出）："><a href="#FIFO（先进先出）：" class="headerlink" title="FIFO（先进先出）："></a>FIFO（先进先出）：</h4><p>  这是一种简单直观的策略，遵循的原则是先进入的数据先出去。例如，如果你有一个缓存空间，当它满了以后，你需要为新的数据项腾出空间，那么你会选择最早进入缓存的数据项进行替换。这种策略的优点是实现简单，但可能会导致频繁访问的数据被替换出去。</p><h4 id="LRU（最近最少使用）："><a href="#LRU（最近最少使用）：" class="headerlink" title="LRU（最近最少使用）："></a>LRU（最近最少使用）：</h4><p>  这种策略的原则是最近最少使用的数据最先被替换。这意味着如果一个数据项最近被访问过，那么在将来它被再次访问的可能性就更大。因此，当缓存满了以后，LRU策略会选择最长时间未被访问的数据项进行替换。这种策略相比FIFO能更好地处理局部性原理，即最近访问过的数据在未来可能再次被访问。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="5-1-文件系统的概念"><a href="#5-1-文件系统的概念" class="headerlink" title="5.1 文件系统的概念"></a>5.1 文件系统的概念</h3><p>文件系统是操作系统用于存储、组织、管理和访问计算机中的数据的一种方法。它定义了文件的命名规则，如何存储这些文件，以及如何从存储介质中检索这些文件。文件系统可以是磁盘文件系统，网络文件系统，或者分布式文件系统等。</p><h3 id="5-2-文件的存储和管理"><a href="#5-2-文件的存储和管理" class="headerlink" title="5.2 文件的存储和管理"></a>5.2 文件的存储和管理</h3><p>文件的存储和管理涉及到文件的创建、删除、读取、写入等操作。文件系统通常将文件存储在硬盘或其他形式的存储设备上。文件系统将存储设备分成一些小的存储单位，如扇区或块，然后将文件的数据存储在这些单位中。文件系统还需要管理文件的元数据，如文件名、文件大小、文件创建时间等。</p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><ul><li>元数据（Metadata）是用来描述其他数据的数据。它提供了关于其他数据的有用信息，但并不包含数据本身。元数据可以帮助我们理解数据的来源、结构、含义、时间和空间等相关信息。</li></ul><p>例如，一张照片的元数据可能包括拍摄日期、相机类型、ISO设置、焦距等信息；一首歌曲的元数据可能包括歌曲名称、艺术家、专辑、发行日期等信息；一个文件的元数据可能包括文件名、创建日期、修改日期、文件大小等信息。</p><ul><li>在数据库中，元数据可以描述数据表的名称、列的名称和类型、约束等信息；在网页中，元数据（如HTML的meta标签）可以描述网页的标题、描述、关键词等信息，这对搜索引擎优化（SEO）非常重要。</li></ul><h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><ul><li>广泛使用的密码散列函数</li><li>MD5常常用于检查数据的完整性。例如，在文件传输或存储的过程中，为了确保文件没有在传输或存储过程中被修改，我们可以计算文件的MD5值并将其存储为文件的元数据。当我们再次需要使用文件时，可以重新计算文件的MD5值并与存储的元数据中的MD5值进行比较，如果两者一致，那么就可以认为文件没有被修改。</li></ul><h3 id="5-3-文件的保护和安全"><a href="#5-3-文件的保护和安全" class="headerlink" title="5.3 文件的保护和安全"></a>5.3 文件的保护和安全</h3><p>文件的保护和安全是文件系统的重要组成部分。文件系统通常提供一些机制来保护文件，防止未经授权的访问或修改。这些机制包括文件权限、文件所有权、访问控制列表等。此外，文件系统可能还提供数据加密功能，以增加数据的安全性。</p><h4 id="文件权限："><a href="#文件权限：" class="headerlink" title="文件权限："></a>文件权限：</h4><p>文件权限决定了哪些用户或用户组可以访问或修改文件。在Unix和Linux系统中，文件权限通常分为读（r）、写（w）和执行（x）三类，每类权限可以赋予文件的所有者、所在组的成员以及其他用户。</p><h4 id="文件所有权："><a href="#文件所有权：" class="headerlink" title="文件所有权："></a>文件所有权：</h4><p>文件所有权决定了文件的所有者和所属的用户组。文件所有者通常可以更改文件的权限，包括决定哪些用户可以读取、写入或执行文件。</p><h4 id="访问控制列表："><a href="#访问控制列表：" class="headerlink" title="访问控制列表："></a>访问控制列表：</h4><p>ACL是一种更细粒度的权限控制机制。它允许管理员为每个用户或用户组分别设置文件的访问权限，而不仅仅是基于文件所有者和用户组。ACL可以为特定用户提供更具体的权限，比如只读、只写或读写权限。</p><h3 id="5-4-目录结构"><a href="#5-4-目录结构" class="headerlink" title="5.4 目录结构"></a>5.4 目录结构</h3><p>目录结构是文件系统用来组织文件的方式。在大多数文件系统中，文件被组织成一种层次结构，称为目录树。每个文件都有一个路径，表示其在目录树中的位置。目录可以包含文件和其他目录。目录结构使用户和应用程序可以方便地找到和管理文件。</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="6-1-设备管理的概念"><a href="#6-1-设备管理的概念" class="headerlink" title="6.1 设备管理的概念"></a>6.1 设备管理的概念</h3><p>设备管理是操作系统的一部分，主要负责管理和控制所有的输入/输出设备。设备管理的主要任务包括设备驱动程序的管理，设备调度，缓冲管理等。设备管理的主要目标是提高设备的利用率和系统的吞吐量，同时也要保证系统的公平性和响应时间。</p><h3 id="6-2-设备驱动程序"><a href="#6-2-设备驱动程序" class="headerlink" title="6.2 设备驱动程序"></a>6.2 设备驱动程序</h3><p>设备驱动程序是操作系统的一部分，用于管理和控制特定硬件设备。它是硬件设备和操作系统之间的接口，用于转换操作系统的指令为硬件设备可以理解的指令。设备驱动程序通常是由硬件制造商提供的，可以根据硬件设备的特性和操作系统的要求进行定制。</p><h3 id="6-3-设备调度"><a href="#6-3-设备调度" class="headerlink" title="6.3 设备调度"></a>6.3 设备调度</h3><p>设备调度是设备管理的一部分，主要负责决定哪个进程可以使用设备，以及何时可以使用设备。设备调度的目标是提高设备的利用率和系统的吞吐量，同时也要保证系统的公平性和响应时间。设备调度策略通常包括先来先服务（FCFS），最短寻道时间优先（SSTF），扫描（SCAN）等。</p><h4 id="先来先服务（FCFS，First-Come-First-Served）："><a href="#先来先服务（FCFS，First-Come-First-Served）：" class="headerlink" title="先来先服务（FCFS，First-Come, First-Served）："></a>先来先服务（FCFS，First-Come, First-Served）：</h4><p>  这是最简单的磁盘调度算法。操作系统按照请求到达的顺序来处理它们。这种方法的主要缺点是可能会导致“饥饿”现象，即某些请求可能需要等待很长时间才能得到处理。</p><h4 id="最短寻道时间优先（SSTF，Shortest-Seek-Time-First）："><a href="#最短寻道时间优先（SSTF，Shortest-Seek-Time-First）：" class="headerlink" title="最短寻道时间优先（SSTF，Shortest Seek Time First）："></a>最短寻道时间优先（SSTF，Shortest Seek Time First）：</h4><p>  在这种算法中，磁头会移动到距离当前位置最近的磁道。这种方法可以减少磁头移动的总时间，从而提高磁盘的性能。但是，它也可能导致饥饿现象。</p><h4 id="扫描（SCAN）："><a href="#扫描（SCAN）：" class="headerlink" title="扫描（SCAN）："></a>扫描（SCAN）：</h4><p>  在这种算法中，磁头从一端开始，逐渐向另一端移动，处理所有在其路径上的请求。当磁头到达磁盘的一端时，它会改变方向并继续扫描。这种方法被比喻为电梯运行，因此也被称为电梯算法。SCAN算法相比FCFS和SSTF更公平，因为它确保了所有的请求都会得到处理。</p><h3 id="6-4-缓冲管理"><a href="#6-4-缓冲管理" class="headerlink" title="6.4 缓冲管理"></a>6.4 缓冲管理</h3><p>  缓冲管理是设备管理的一部分，主要负责管理和控制缓冲区的使用。缓冲区是一种临时存储区，用于存储从设备读取的数据或者要写入设备的数据。缓冲管理的目标是提高设备的利用率和系统的吞吐量，同时也要保证系统的公平性和响应时间。缓冲管理策略通常包括单缓冲，双缓冲，循环缓冲等。</p><h2 id="安全与保护"><a href="#安全与保护" class="headerlink" title="安全与保护"></a>安全与保护</h2><h3 id="7-1-操作系统的安全问题"><a href="#7-1-操作系统的安全问题" class="headerlink" title="7.1 操作系统的安全问题"></a>7.1 操作系统的安全问题</h3><p>操作系统是计算机系统的核心，也是最容易受到攻击的部分。例如，黑客可能通过漏洞攻击操作系统，获取系统权限，进而对系统进行不法操作。例如，勒索软件”WannaCry”就是利用Windows系统的一个漏洞，对全球范围内的计算机进行攻击，导致大量数据丢失。</p><h3 id="7-2-访问控制和用户身份验证"><a href="#7-2-访问控制和用户身份验证" class="headerlink" title="7.2 访问控制和用户身份验证"></a>7.2 访问控制和用户身份验证</h3><p>访问控制和用户身份验证是保护信息系统安全的重要手段。例如，银行系统会通过密码和二次验证（如手机短信验证码）的方式，来验证用户的身份。此外，一些高安全级别的系统，如军事系统，可能还会使用生物特征（如指纹、虹膜）进行身份验证。</p><h3 id="7-3-病毒和防火墙"><a href="#7-3-病毒和防火墙" class="headerlink" title="7.3 病毒和防火墙"></a>7.3 病毒和防火墙</h3><p>病毒是一种能够自我复制并传播的恶意软件。例如，”ILOVEYOU”病毒在2000年通过电子邮件传播，导致全球范围内的大量计算机系统崩溃。防火墙则是一种可以阻止恶意软件进入系统的设备或软件。例如，家用路由器通常都内置了防火墙，可以阻止外部网络对家庭内部网络的非法访问。</p><h3 id="7-4-加密和网络安全"><a href="#7-4-加密和网络安全" class="headerlink" title="7.4 加密和网络安全"></a>7.4 加密和网络安全</h3><p>加密技术是保护数据安全的重要手段。例如，当我们在网上购物时，信用卡信息会通过HTTPS协议进行加密，防止数据在传输过程中被窃取。网络安全则是保护网络系统不受攻击的一系列措施。例如，一些公司会定期进行网络安全演练，以提高员工对网络安全的意识，防止社会工程学攻击。</p><h2 id="现代操作系统"><a href="#现代操作系统" class="headerlink" title="现代操作系统"></a>现代操作系统</h2><h3 id="8-1-分布式操作系统"><a href="#8-1-分布式操作系统" class="headerlink" title="8.1 分布式操作系统"></a>8.1 分布式操作系统</h3><p>分布式操作系统是一种控制和协调多台计算机共同工作的操作系统。在一个分布式系统中，用户可以访问远程资源就像访问本地资源一样。分布式操作系统提供了数据的一致性、容错性和并发性。</p><p>例如，Google的分布式文件系统GFS，它将文件分割成多个块存储在不同的节点上，从而提高了数据的可靠性和访问速度。Apache Hadoop也是一个著名的分布式操作系统，专门用于处理大数据。</p><h3 id="8-2-实时操作系统"><a href="#8-2-实时操作系统" class="headerlink" title="8.2 实时操作系统"></a>8.2 实时操作系统</h3><p>实时操作系统（RTOS）是为了控制实时应用程序而设计的操作系统，它能在特定的时间内稳定且预测性地响应外部事件。RTOS通常用于嵌入式系统如飞行控制系统、工厂自动化控制系统等。</p><p>例如，VxWorks是一个广泛使用的实时操作系统，被广泛应用在航空、航天、军事、网络通信等领域。另一个例子是FreeRTOS，一种开源的微型实时操作系统，适用于各种小型嵌入式设备。</p><h3 id="8-3-嵌入式操作系统"><a href="#8-3-嵌入式操作系统" class="headerlink" title="8.3 嵌入式操作系统"></a>8.3 嵌入式操作系统</h3><p>嵌入式操作系统是专为嵌入式系统设计的，通常需要具有实时性、稳定性、小型化和低功耗等特点。嵌入式操作系统通常用于智能家电、工业控制设备、车载电子设备等。</p><p>例如，QNX是一种商业的嵌入式操作系统，被广泛应用在汽车、医疗、工业自动化等领域。另一个例子是Linux，其轻量级版本如OpenWrt、Raspbian等也被广泛应用于各种嵌入式设备。</p><h3 id="8-4-云操作系统"><a href="#8-4-云操作系统" class="headerlink" title="8.4 云操作系统"></a>8.4 云操作系统</h3><p>云操作系统是基于云计算技术开发的新型操作系统。它将计算、存储、网络等资源统一管理和调度，为用户提供了伸缩性、弹性和按需付费等特点。</p><p>例如，Google的Chrome OS就是一种云操作系统，它把大部分计算和数据存储任务都放到了云端，用户只需要一台简单的设备就可以完成各种复杂的任务。另一个例子是OpenStack，这是一种开源的云操作系统，可以让任何人建立自己的私有或公有云。</p>]]></content>
    
    
    <summary type="html">计算机操作系统文章讨论了操作系统的核心概念、功能和作用，以及如何管理和协调计算机硬件和软件资源，提高系统性能和用户体验的重要性。</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Basic/Study-Note/"/>
    
    
    <category term="OS" scheme="https://kalyan-zitiu.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://kalyan-zitiu.github.io/2023/09/18/Python/"/>
    <id>https://kalyan-zitiu.github.io/2023/09/18/Python/</id>
    <published>2023-09-18T12:00:00.000Z</published>
    <updated>2023-10-15T08:33:22.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>一种多范式编程语言。<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2></li></ul><ol><li><p>Python变量和数据类型：Python有多种基本数据类型，包括整数（int），浮点数（float），字符串（str），列表（list）和字典（dict）等，变量在Python中不需要声明，直接赋值即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;</span><br><span class="line">y = <span class="number">3.14</span>;</span><br><span class="line">z = <span class="string">&quot;Hello,world!&quot;</span></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;john&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Python条件语句: Python使用if、elif（else if的缩写）和else关键字来进行条件判断。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is positive&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is negative&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is zero&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>Python循环: Python使用for和while关键字来进行循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用for循环遍历列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用while循环</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    x += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>Python函数: Python使用def关键字来定义函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><ul><li>Python的列表是一种数据结构，可以包含任何类型的数据，如整数，字符串，元组等，列表是可变的，意味着你可以在创建列表后可更改，添加或删除列表中的元素。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//在这个列表中，我们有一个整数（<span class="number">1</span>），一个字符串（<span class="string">&#x27;Hello&#x27;</span>），一个浮点数（<span class="number">3.14</span>）和一个布尔值（<span class="literal">True</span>）。</span><br><span class="line">my_list = [<span class="number">1</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">3.14</span>,<span class="literal">True</span>]</span><br></pre></td></tr></table></figure><h4 id="特性以及操作"><a href="#特性以及操作" class="headerlink" title="特性以及操作"></a>特性以及操作</h4><ol><li><p>索引：你可以通过索引访问列表中的元素。索引是从0开始的。例如，my_list[0] 将返回第一个元素，即1。</p></li><li><p>切片：你也可以访问列表的一部分，这称为切片。例如，my_list[1:3] 将返回从索引1开始到索引（不包括）的所有元素，即[‘Hello’, 3.14]。</p></li><li><p>列表是可变的，你可以更改列表中的元素。例如，my_list[1] = ‘World’ 将把第二个元素（’Hello’）更改为’World’。</p></li><li><p>添加元素：你可以使用 append() 方法在列表的末尾添加新元素，或者使用 insert() 方法在指定位置插入新元素。</p></li><li><p>删除元素：你可以使用 remove() 方法删除指定的元素，或者使用 pop() 方法删除指定索引处的元素。</p></li><li><p>长度：你可以使用 len() 函数获取列表的长度，即它包含的元素数量。</p></li></ol><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol><li>append(item):列表末尾添加一个新的元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_list.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>2.. extend(iterable):在列表末尾添加另一个列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_list.extend([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>insert(index,item):指定索引位置插入一个元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">my_list.insert(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,&#x27;a&#x27;，2，3]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>remove(item):删除列表中第一个出现的指定元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">my_list.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment"># 输出[1,3,2]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>pop(index):删除并返回指定索引位置的元素，若没有则删除并返回最后一个元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">item = my_list.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(item) <span class="comment">#输出：2</span></span><br><span class="line"><span class="built_in">print</span>(my_list) <span class="comment">#输出[1,3]</span></span><br></pre></td></tr></table></figure><ol start="6"><li>index(item):用于查找列表中第一个出现的指定元素的索引</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">index  = my_list.index(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(index) <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure><ol start="7"><li>count(item):这个方法用于计算列表中指定元素出现的次数</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">count = my_list.count(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(count) <span class="comment"># 输出2</span></span><br></pre></td></tr></table></figure><ol start="8"><li><p>sort():这个方法用于对列表进行排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">my_list.sort()</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 1, 2, 3, 4, 5, 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>reverse():用于反转列表</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">my_list.reverse()</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br></pre></td></tr></table></figure><h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><ul><li>元组是一种不可变的序列类型，在Python中，元组是用圆括号（）创建的。元组中的元素可以是不同类型的，如整数，浮点数，字符串，甚至可以包含其他的复杂类型，如列表，字典或其他元组。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>不可变性： 一旦元组被创建，你就不能增加、修改或删除元组中的元素。这意味着元组是哈希的，可以用作字典的键。</li><li>有序性： 元组中的元素有固定的顺序，可以通过索引访问。</li><li>允许重复的元素： 元组可以包含重复的元素。</li><li>可以包含不同类型的元素： 元组的元素可以是任何类型。</li></ol><h4 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol><li>tuple.count(x):返回元组中元素x出现的次数</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t.count(<span class="number">2</span>))<span class="comment"># 输出3</span></span><br></pre></td></tr></table></figure><ol start="2"><li>tuple.index(x):返回元组中元素x第一次出现的索引，如果元组中不存在元素x，会抛出一个异常</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t.index(<span class="number">2</span>))<span class="comment"># 输出1，因为2是元组t中索引为1的元素</span></span><br></pre></td></tr></table></figure><ol start="3"><li>len(tuple):返回元组的长度</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t)) <span class="comment"># 输出6，因为元组t中有6个元素</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>max(tuple) 和 min(tuple)：返回元组中的最大值和最小值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="built_in">tuple</span>)) <span class="comment"># 输出4，因为4是元组t中的最大值 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(<span class="built_in">tuple</span>)) <span class="comment"># 输出1，因为1是元组t中的最小值</span></span><br></pre></td></tr></table></figure></li><li><p>tuple(seq):将序列seq转换为元组</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">t = <span class="built_in">tuple</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment"># 输出（1，2，3，4，5）</span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li>创建元组</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>访问元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>])  <span class="comment"># 输出 &#x27;physics&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>切片操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出 (2, 3, 4)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>合并元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)  <span class="comment"># 输出 (12, 34.56, &#x27;abc&#x27;, &#x27;xyz&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>元组解包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包（unpack）</span></span><br><span class="line">subject1, subject2, year1, year2 = tup1</span><br><span class="line"><span class="built_in">print</span>(subject1)  <span class="comment"># 输出 &#x27;physics&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(year1)  <span class="comment"># 输出 1997</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>计算元素个数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(tup1))  <span class="comment"># 输出 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检查元素是否存在</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1997</span> <span class="keyword">in</span> tup1)  <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure></li><li><p>元素索引</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1.index(<span class="number">2000</span>))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><ol start="9"><li>元素计数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1.count(<span class="number">2</span>))  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol><li><p>无序性：集合中的元素没有特定的顺序，因此不能通过索引或切片来访问元素。</p></li><li><p>唯一性：集合中的每个元素都是唯一的，即集合中不能有重复的元素。</p></li><li><p>可变性：可以添加或删除集合中的元素，但集合本身是不可哈希的，因此不能作为其他集合的元素或字典的键。</p></li></ol><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li>创建集合</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>添加元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">s.update([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3, 4, 5, 6, 7&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>删除元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line">s.discard(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;4, 5&#125;，注意这里的输出可能会有所不同，因为pop()是随机删除一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>判断元素是否存在</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 is in the set&quot;</span>)  <span class="comment"># 输出：&quot;1 is in the set&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>集合的运算<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))  <span class="comment"># 输出：&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))  <span class="comment"># 输出：&#123;3, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))  <span class="comment"># 输出：&#123;1, 2&#125;</span></span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))  <span class="comment"># 输出：&#123;1, 2, 5, 6&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li><p>discard()：删除集合中的指定元素，如果元素不存在，不会抛出错误。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.discard(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：&#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>pop()：随机删除集合中的一个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.pop()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出可能是：&#123;1, 2&#125; 或 &#123;2, 3&#125; 或 &#123;1, 3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>clear()：清空集合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：set()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>union()：返回两个集合的并集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))  <span class="comment"># 输出：&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>intersection()：返回两个集合的交集</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))  <span class="comment"># 输出：&#123;3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li><p>difference()：返回集合的差集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))  <span class="comment"># 输出：&#123;1, 2&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>symmetric_difference()：返回两个集合的对称差集</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))  <span class="comment"># 输出：&#123;1, 2, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li><p>issubset()：判断集合是不是被其他集合包含</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.issubset(s2))  <span class="comment"># 输出：True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>issuperset()：判断集合是否包含其他集合</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.issuperset(s1))  <span class="comment"># 输出：True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>并集：两个集合的并集是包含两个集合所有元素的集合。</p></li><li><p>交集：两个集合的交集是同时包含在两个集合中的元素组成的集合。</p></li><li><p>差集：集合A与集合B的差集是包含在集合A但不包含在集合B中的元素组成的集合。</p></li><li><p>对称差集：两个集合的对称差集是只包含在一个集合中但不同时包含在两个集合中的元素组成的集合。</p></li></ul><h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul><li>无序性：字典中的元素没有特定的顺序，它们并不按照插入的顺序存储</li><li>键的唯一性：字典中的键必须是唯一的，如果在创建字典时同一个键被赋值两次，后一个值会被记住。</li><li>可变性：字典是可变的，我们可以添加，删除或修改字典中的键值对。</li></ul><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li>创建字典</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号创建字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用dict()函数创建字典</span></span><br><span class="line">dict2 = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(dict2)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 25&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>访问字典中的值</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># 输出：Alice</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>修改字典</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">21</span>  <span class="comment"># 修改已有的键值对</span></span><br><span class="line">dict1[<span class="string">&#x27;gender&#x27;</span>] = <span class="string">&#x27;Female&#x27;</span>  <span class="comment"># 添加新的键值对</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 21, &#x27;gender&#x27;: &#x27;Female&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>删除字典元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;Female&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;gender&#x27;</span>]  <span class="comment"># 删除键为&#x27;gender&#x27;的键值对</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol><li><p>dict.keys():返回一个包含字典所有键的视图对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.keys()) <span class="comment">#dict_keys([&#x27;name&#x27;,&#x27;age&#x27;])</span></span><br></pre></td></tr></table></figure></li><li><p>dict.values():此方法返回一个包含字典所有值的视图对象</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.values())  <span class="comment"># 输出：dict_values([&#x27;Tom&#x27;, 20])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>dict.items(): 此方法返回一个包含字典所有（键, 值）元组的视图对象。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.items())  <span class="comment"># 输出：dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20)])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>dict.get(key, default): 此方法返回字典中键为key的值；如果没有这样的键，则返回default。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;name&#x27;</span>))  <span class="comment"># 输出：&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;N/A&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>dict.setdefault(key, default): 如果字典中包含有给定键，则返回该键对应的值，否则将该键和default值插入字典中，并返回default。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.setdefault(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;N/A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;N/A&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>dict.update(other): 将other字典的键/值对更新到当前字典中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">d.update(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 21, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>dict.pop(key, default): 删除并返回字典中键为key的值，如果没有这样的键，则返回default。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.pop(<span class="string">&#x27;age&#x27;</span>))  <span class="comment"># 输出：20</span></span><br><span class="line"><span class="built_in">print</span>(d.pop(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># 输出：&#x27;N/A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>dict.clear(): 删除字典内所有元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">d.clear()</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Python的函数"><a href="#Python的函数" class="headerlink" title="Python的函数"></a>Python的函数</h2><ol><li>定义函数:<br>你可以定义一个由自己想要功能的函数，以下是简单的规则：</li></ol><ul><li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line"><span class="string">&quot;&quot;&quot;This function prints Hello,World!&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello，World！&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello_world();</span><br></pre></td></tr></table></figure><ol start="2"><li><p>函数参数：<br>在Python中，函数的参数可以有默认值，也支持使用可变参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, msg=<span class="string">&quot;Good day!&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This function greets to the person passed in as parameter</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, name + <span class="string">&#x27;, &#x27;</span> + msg)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Kate&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Bruce&quot;</span>, <span class="string">&quot;How do you do?&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>匿名函数<br>Python使用lambda来创建匿名函数。意即不再使用def语句这样标准的形式定义一个函数。<br>lambda只是一个表达式，函数体笔def简单多</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum = lambda arg1:arg1 + arg2</span><br><span class="line">print(&quot;Value of tatal:&quot;,sum(10,20))</span><br></pre></td></tr></table></figure></li><li><p>全局和局部变量：<br>在函数内部，你可以引用全局变量。如果你需要在函数内部改变全局变量，那么global关键字就派上用场了，如果不修改全局变量，可以使用局部变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    y = <span class="number">5</span></span><br><span class="line">    x += y</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;local x:&quot;</span>, x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;local y:&quot;</span>, y)</span><br><span class="line"></span><br><span class="line">example()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;global x:&quot;</span>, x)</span><br></pre></td></tr></table></figure></li><li><p>错误和异常处理<br>try/except语句</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">diveide</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">result = x/y</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;除数不能为零！&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li><li><p>函数的递归<br>最好需要一个明确的退出条件，否则无限递归导致程序崩溃</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> n * factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>高阶函数<br>Python支持高阶函数，可以接受其他函数作为参数或返回一个函数的函数。这是函数式编程的一个重要特性，可以用来创建代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def apply_func(func,x,y)</span><br><span class="line">return func(x,y)</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><ol><li><p><strong>打开文件</strong>：我们使用内置的<code>open()</code>函数来打开一个文件。这个函数接收两个参数：文件名和模式。模式可以是<code>&#39;r&#39;</code>（读取，默认值），<code>&#39;w&#39;</code>（写入，如果文件存在则清空内容），<code>&#39;a&#39;</code>（追加，不清空文件内容，从文件末尾开始写入），或<code>&#39;b&#39;</code>（二进制模式）。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>读取文件</strong>：我们可以使用<code>read()</code>函数来读取文件的全部内容，或者使用<code>readline()</code>来一次读取一行。还可以使用<code>readlines()</code>来一次读取所有行并返回一个列表。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = f.read()</span><br><span class="line">line = f.readline()</span><br><span class="line">lines = f.readlines()</span><br></pre></td></tr></table></figure></li><li><p><strong>写入文件</strong>：我们可以使用<code>write()</code>函数来写入文件。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;Hello, World!&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭文件</strong>：当我们完成文件操作后，应该使用<code>close()</code>函数来关闭文件。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure></li><li><p><strong>with语句</strong>：在处理文件对象时，使用with关键字是一个好习惯。它的优点是文件会在语句结束后自动关闭，即使发生异常也是如此。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure></li><li><p><strong>操作文件和目录</strong>：Python的os模块提供了许多操作文件和目录的函数，如<code>os.remove()</code>删除文件，<code>os.rename()</code>重命名文件，<code>os.mkdir()</code>创建新目录，<code>os.rmdir()</code>删除目录等。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">os.rename(<span class="string">&#x27;oldname.txt&#x27;</span>, <span class="string">&#x27;newname.txt&#x27;</span>)</span><br><span class="line">os.mkdir(<span class="string">&#x27;newdir&#x27;</span>)</span><br><span class="line">os.rmdir(<span class="string">&#x27;olddir&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在Python中，异常处理涉及以下几个关键词：<code>try</code>, <code>except</code>, <code>finally</code>, <code>raise</code>。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    x = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="comment"># 如果在try部分引发了ZeroDivisionError，那么就执行这部分</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试除以零，这会引发一个 ZeroDivisionError。由于我们在 except 语句中处理了这个错误，所以程序会打印出 “You can’t divide by zero!”，而不是完全崩溃。</p><p>finally 语句是一个可选的语句，无论 <code>try</code> 块中的代码是否引发异常，它都会执行。这在需要确保文件正确关闭或网络连接正确终止等情况下非常有用。</p><p>raise 语句允许程序员自己引发异常。例如，如果你正在编写一个函数，你可以使用 <code>raise</code> 语句来引发一个 <code>TypeError</code>，如果函数的参数不是你期望的类型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(b, <span class="built_in">int</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;Inputs must be integers&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>add_numbers</code> 的参数不是整数，那么函数就会引发一个 TypeError。</p><h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><p>模块是Python代码的一种组织形式，它将相关的代码组织在一个文件中，以便于代码的复用和维护。你可以使用import语句来导入模块。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">16</span>))  <span class="comment"># 输出：4.0</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们导入了math模块，然后使用了它的sqrt函数来计算16的平方根。</p><p>Python的包是一种更高级的模块组织方式。它可以包含多个模块。一个包就是一个包含特殊文件 <strong>init</strong>.py 的目录，这个文件告诉Python这个目录应被视为一个Python包。</p><p>例如，如果你有以下目录结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line">__init__.py</span><br><span class="line">module1.py</span><br><span class="line">module2.py</span><br></pre></td></tr></table></figure><p>你可以这样导入和使用包中的模块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module1</span><br><span class="line">module1.some_function()</span><br></pre></td></tr></table></figure><p>在这个例子中，我们导入了my_package包中的module1模块，并调用了它的some_function函数。</p><h3 id="常用包和模块简介"><a href="#常用包和模块简介" class="headerlink" title="常用包和模块简介"></a>常用包和模块简介</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> numpy: 这是Python中用于数值计算的主要库。它提供了强大的多维数组对象和工具来处理这些数组。</span><br><span class="line"><span class="number">2.</span> pandas: 这是用于数据处理和分析的库。它提供了两个主要的数据结构：Series和DataFrame。</span><br><span class="line"><span class="number">3.</span> matplotlib: 这是用于绘制图形的库。你可以使用它来创建各种各样的图表，比如线图、散点图、柱状图等。</span><br><span class="line"><span class="number">4.</span> scikit-learn: 这是用于机器学习的库。它包含了大量的机器学习算法，比如分类、回归、聚类等。</span><br><span class="line"><span class="number">5.</span> requests: 这是用于发送HTTP请求的库。你可以使用它来获取网页内容，或者与Web服务交互。</span><br><span class="line"><span class="number">6.</span> flask: 这是一个轻量级的Web服务器和框架。你可以使用它来创建Web应用。</span><br><span class="line"><span class="number">7.</span> django: 这是一个高级的Web框架，它遵循MVC（Model-View-Controller）设计模式。你可以使用它来创建复杂的Web应用。</span><br><span class="line"><span class="number">8.</span> tensorflow和pytorch: 这两个库都是用于深度学习的。它们提供了创建和训练神经网络的工具。</span><br><span class="line"><span class="number">9.</span> beautifulsoup4: 这是一个用于解析HTML和XML文档的库，常常用于网页抓取。</span><br><span class="line"><span class="number">10.</span> sqlalchemy: 这是一个数据库抽象层和ORM（Object Relational Mapper）框架。你可以使用它来与各种数据库进行交互。</span><br></pre></td></tr></table></figure><h2 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><ol><li>类与对象：在Python中，几乎所有的东西都是对象，具有其属性和方法。类是对象的蓝图或圆形。我们可以使用类来创建对象，这些对象将具有类定义的属性和行为。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">p1 = MyClass() <span class="comment"># 创建对象</span></span><br><span class="line"><span class="built_in">print</span>(p1.x) <span class="comment"># 输出：5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>继承：继承允许我们定义一个继承所有办法和属性的类。父类是被继承的类，子类是继承父类的类。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fname</span>):</span><br><span class="line">    self.firstname = fname</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = Student(<span class="string">&quot;Mike&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.firstname) <span class="comment"># 输出：Mike</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>多态：多态是指同一操作作用于不同的对象，可以产生不同的结果。这意味着每个对象可以根据其类型以自己的方式响应常见的方法。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">sound</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">animal</span>):</span><br><span class="line">  <span class="built_in">print</span>(animal.sound())</span><br><span class="line"></span><br><span class="line">cat_obj = Cat()</span><br><span class="line">dog_obj = Dog()</span><br><span class="line"></span><br><span class="line">make_sound(cat_obj) <span class="comment"># 输出：Meow</span></span><br><span class="line">make_sound(dog_obj) <span class="comment"># 输出：Woof</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>封装：封装是面向对象编程的一个主要原则，隐藏了对象的内部状态和实现细节，只提供了一组接口。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.__maxprice = <span class="number">900</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Selling Price: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.__maxprice))</span><br><span class="line"></span><br><span class="line">c = Computer()</span><br><span class="line">c.sell() <span class="comment"># 输出：Selling Price: 900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用标准库"><a href="#常用标准库" class="headerlink" title="常用标准库"></a>常用标准库</h2><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>提供了许多与操作系统交互的函数，如创建目录（Mkdir）,更改当前工作目录（chdir），获取当前工作目录（getcwd）等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(<span class="string">&#x27;new_dir&#x27;</span>)</span><br><span class="line">os.chdir(<span class="string">&#x27;new_dir&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>os.name</td><td>获取当前的操作系统名称</td></tr><tr><td>os.getcwd()</td><td>获取当前的工作目录</td></tr><tr><td>os.chdir(path)</td><td>改变当前的工作目录到指定的路径</td></tr><tr><td>os.listdir(path)</td><td>列出指定路径下的所有文件和目录</td></tr><tr><td>os.mkdir(path)</td><td>在指定的路径下创建一个新的目录</td></tr><tr><td>os.rmdir(path)</td><td>删除指定的目录</td></tr><tr><td>os.rename(src, dst)</td><td>重命名文件或目录，从src到dst</td></tr><tr><td>os.remove(path)</td><td>删除指定的文件</td></tr><tr><td>os.path.join(path1, path2, …)</td><td>将多个路径组合后返回</td></tr><tr><td>os.path.split(path)</td><td>返回路径的目录名和文件名</td></tr><tr><td>os.path.exists(path)</td><td>检测指定路径是否存在</td></tr><tr><td>os.path.isdir(path)</td><td>检测指定路径是目录</td></tr><tr><td>os.path.isfile(path)</td><td>检测指定路径是文件</td></tr></tbody></table><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span><br><span class="line">json_data = json.dumps(data)  # 将Python对象转换为JSON格式</span><br><span class="line">print(json_data)  </span><br><span class="line">new_data = json.loads(json_data)  # 将JSON格式的数据转换为Python对象</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>提供了对正则表达式的支持，正则表达式是一个特殊的序列，能够帮助你匹配或者找到其他字符串，使用特定的语法规则。</p><p><strong>Python re模块函数</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>re.match()</code></td><td>从字符串的开始位置匹配正则表达式，如果开始位置匹配不成功，match()返回None</td></tr><tr><td><code>re.search()</code></td><td>扫描整个字符串并返回第一个成功的匹配</td></tr><tr><td><code>re.findall()</code></td><td>返回一个列表，包含所有匹配的子串</td></tr><tr><td><code>re.sub()</code></td><td>用于替换字符串中的匹配项</td></tr><tr><td><code>re.compile()</code></td><td>用于编译正则表达式，生成一个正则表达式对象</td></tr></tbody></table><p><strong>正则表达式元字符</strong></p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除了换行符以外的任何字符</td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td></tr><tr><td><code>*</code></td><td>匹配0次或多次前面的正则表达式</td></tr><tr><td><code>+</code></td><td>匹配1次或多次前面的正则表达式</td></tr><tr><td><code>?</code></td><td>匹配0次或1次前面的正则表达式</td></tr><tr><td><code>\d</code></td><td>匹配任何数字，等价于<code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配任何非数字字符，等价于<code>[^0-9]</code></td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，等价于<code>[\t\n\r\f\v]</code></td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符，等价于<code>[^\t\n\r\f\v]</code></td></tr><tr><td><code>\w</code></td><td>匹配任何字母数字字符，等价于<code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配任何非字母数字字符，等价于<code>[^a-zA-Z0-9_]</code></td></tr></tbody></table><h4 id="简单的re模块例子"><a href="#简单的re模块例子" class="headerlink" title="简单的re模块例子"></a>简单的re模块例子</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用match方法</span></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;100081 BIT 100082&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用search方法</span></span><br><span class="line">search = re.search(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT 100082&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> search:</span><br><span class="line">    <span class="built_in">print</span>(search.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用findall方法</span></span><br><span class="line">findall = re.findall(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;100081 BIT 100082&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(findall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用sub方法</span></span><br><span class="line">sub = re.sub(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;:zipcode&#x27;</span>, <span class="string">&#x27;100081 BIT 100082&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用compile方法</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>)</span><br><span class="line">result = pattern.search(<span class="string">&#x27;BIT 100082&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    <span class="built_in">print</span>(result.group(<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><p>实现了特殊的容器数据类型，提供了Python内置的<code>dict</code>，<code>list</code>，<code>set</code>，<code>tuple</code>之外的更多数据类型。</p><ol><li>**<code>namedtuple()</code>**：<code>namedtuple</code>是一个函数，它用来创建一个自定义的元组对象，并且规定了元组元素的个数，可以用属性而不是索引来引用元组的某个元素。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个名为&#x27;Animal&#x27;的namedtuple，它包含&#x27;name&#x27;和&#x27;age&#x27;两个字段。</span></span><br><span class="line">Animal = namedtuple(<span class="string">&#x27;Animal&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;type&#x27;</span>])</span><br><span class="line"></span><br><span class="line">cat = Animal(name=<span class="string">&#x27;Kitty&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Cat&#x27;</span>)</span><br><span class="line">dog = Animal(name=<span class="string">&#x27;Max&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以用属性访问namedtuple的元素</span></span><br><span class="line"><span class="built_in">print</span>(cat.name)  <span class="comment"># 输出: Kitty</span></span><br><span class="line"><span class="built_in">print</span>(dog.<span class="built_in">type</span>)  <span class="comment"># 输出: Dog</span></span><br></pre></td></tr></table></figure><ol start="2"><li>**<code>deque</code>**：<code>deque</code>是一个双端队列，它可以从两端添加或删除元素。在需要添加和删除元素时，deque提供了更优于list的性能。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">dq = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment">#在队列右侧添加元素</span></span><br><span class="line">dq.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dq.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在队列左侧添加元素</span></span><br><span class="line">dq.appendleft(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除队列右侧元素</span></span><br><span class="line">dq.pop()</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;c&#x27;, &#x27;a&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除队列左侧元素</span></span><br><span class="line">dq.popleft()</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># 输出: deque([&#x27;a&#x27;])</span></span><br></pre></td></tr></table></figure><ol start="3"><li>**<code>Counter</code>**：<code>Counter</code>是一个简单的计数器，例如，它可以用来统计字符的个数：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">c = Counter(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: Counter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 1, &#x27;n&#x27;: 2&#125;)</span></span><br></pre></td></tr></table></figure><p>你还可以对Counter对象执行各种数学运算操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c1 = Counter(a=<span class="number">3</span>, b=<span class="number">2</span>)</span><br><span class="line">c2 = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c1 + c2)  <span class="comment"># 输出: Counter(&#123;&#x27;a&#x27;: 4, &#x27;b&#x27;: 4&#125;)</span></span><br></pre></td></tr></table></figure><ol start="4"><li>**<code>OrderedDict</code>**：<code>OrderedDict</code>是一个字典子类，它记住了字典元素添加的顺序：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="string">&#x27;z&#x27;</span>] = <span class="number">1</span></span><br><span class="line">od[<span class="string">&#x27;y&#x27;</span>] = <span class="number">2</span></span><br><span class="line">od[<span class="string">&#x27;x&#x27;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(od.keys()))  <span class="comment"># 输出: [&#x27;z&#x27;, &#x27;y&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>**<code>defaultdict</code>**：<code>defaultdict</code>是一个字典子类，它提供了一个工厂函数为字典查询提供默认值：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dd = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(dd[<span class="string">&#x27;key&#x27;</span>])  <span class="comment"># 输出: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当键不存在的时候，返回默认值0，而不是抛出KeyError异常</span></span><br><span class="line">dd[<span class="string">&#x27;key&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(dd[<span class="string">&#x27;key&#x27;</span>])  <span class="comment"># 输出: 1</span></span><br></pre></td></tr></table></figure><h2 id="Python应用"><a href="#Python应用" class="headerlink" title="Python应用"></a>Python应用</h2><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>一个开源的Python类库，用于数据分析，数据处理，数据可视化</p><h5 id="Pandas读取数据"><a href="#Pandas读取数据" class="headerlink" title="Pandas读取数据"></a>Pandas读取数据</h5><p>Pandas 提供了多种读取数据的方法，可以读取各种类型的文件，包括 CSV、Excel、SQL 数据库等。下面是一些常用的读取数据的方法：</p><ol><li>从 CSV 文件读取数据：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;file.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>从 Excel 文件读取数据：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;file.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>从 SQL 数据库读取数据：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///:memory:&#x27;</span>)</span><br><span class="line">df = pd.read_sql(<span class="string">&#x27;SELECT * FROM my_table&#x27;</span>, engine)</span><br></pre></td></tr></table></figure><p>注意，这些方法都会返回一个 DataFrame 对象，这是 Pandas 中用于数据操纵的主要数据结构。</p><p>你可以使用 <code>df.head()</code> 来查看 DataFrame 的前几行，以确保数据已经正确加载。</p><p>此外，这些函数都有许多可选参数，可以帮助你更精细地控制数据的加载过程。例如，<code>pd.read_csv</code> 允许你指定分隔符类型、处理缺失值、跳过特定的行等。你可以查阅 Pandas 的文档以获取更多信息。</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h6><p>Series是Pandas中的一维标签化数组，可以容纳任何数据类型，包括整数，字符串，浮点数，Python对象等。它是由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签组成，可以把它看作是一个带有标签的一维数组</p><h6 id="Serise多种创建方法"><a href="#Serise多种创建方法" class="headerlink" title="Serise多种创建方法"></a>Serise多种创建方法</h6><p>Pandas的Series是一个一维的数据结构，有点类似于Python的列表或数组，但是它有一些额外的功能，例如可以为每个元素指定一个标签（或者说索引）。</p><p>以下是创建Series的一些方法：</p><ol><li>用Python列表创建Series：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><ol start="2"><li>用NumPy数组创建Series：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><ol start="3"><li>用Python字典创建Series，字典的键会被用作Series的索引：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">s = pd.Series(d)</span><br></pre></td></tr></table></figure><ol start="4"><li>用标量创建Series，该标量值会被广播到指定的索引：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(<span class="number">5.</span>, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br></pre></td></tr></table></figure><p>以上就是创建Pandas Series的四种常用方法，每种方法都有其适用的场景，你可以根据实际需要选择使用。</p><h6 id="Series索引"><a href="#Series索引" class="headerlink" title="Series索引"></a>Series索引</h6><p>在Pandas中，Series对象的索引类似于Python的字典，它可以用来访问和操作数据。</p><p>创建Series时，可以通过<code>index</code>参数来指定索引。如果不指定，Pandas将自动创建一个从0开始的整数索引。</p><p>例如，创建一个带有指定索引的Series：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>此代码将输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a    1.0</span><br><span class="line">b    3.0</span><br><span class="line">c    5.0</span><br><span class="line">d    NaN</span><br><span class="line">e    6.0</span><br><span class="line">f    8.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>你可以像字典一样使用索引来访问和修改Series中的元素：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出：1.0</span></span><br><span class="line"></span><br><span class="line">s[<span class="string">&#x27;a&#x27;</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出：100.0</span></span><br></pre></td></tr></table></figure><p>还可以使用<code>.loc</code>和<code>.iloc</code>方法来进行索引。<code>.loc</code>用于基于标签的索引，而<code>.iloc</code>用于基于位置的索引：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(s.loc[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出：100.0</span></span><br><span class="line"><span class="built_in">print</span>(s.iloc[<span class="number">0</span>])  <span class="comment"># 输出：100.0</span></span><br></pre></td></tr></table></figure><h6 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h6><p>DataFrame是Pandas中的二维标签化数据结构。你可以把它看作是一个电子表格或SQL表，或者是Series对象的字典。它通常是最常用的pandas对象。与Series一样，DataFrame可以容纳多种类型的输入。</p><h6 id="多种方法创建DataFrame"><a href="#多种方法创建DataFrame" class="headerlink" title="多种方法创建DataFrame"></a>多种方法创建DataFrame</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#从字典创建 DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从列表创建 DataFrame</span></span><br><span class="line">data = [[<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>], [<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">35</span>]]</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#从 NumPy 数组创建 DataFrame</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.array([[<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>], [<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">35</span>]])</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中读取数据创建 DataFrame</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h6 id="DataFrame特性"><a href="#DataFrame特性" class="headerlink" title="DataFrame特性"></a>DataFrame特性</h6><ol><li><p>表格结构：DataFrame是一个表格，有行有列，每一列可以包含不同的数据类型，如整数，浮点数，字符串等。</p></li><li><p>标签索引：DataFrame通过行和列的标签进行索引，你可以使用列名或行标签来访问数据。</p></li></ol><p>3.灵活性：你可以执行各种数据操作，如筛选,切片，合并，聚合和重塑，以满足数据分析和处理和需求。</p><h6 id="DataFrame基本操作"><a href="#DataFrame基本操作" class="headerlink" title="DataFrame基本操作"></a>DataFrame基本操作</h6><ol><li><p>访问列数据：使用列名或标签访问列数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;Name&#x27;</span>]  <span class="comment"># 访问 &#x27;Name&#x27; 列</span></span><br></pre></td></tr></table></figure></li><li><p>增加和删除列：你可以轻松地添加和删除列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;City&#x27;</span>] = [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>]  <span class="comment"># 添加新列</span></span><br><span class="line">df.drop(<span class="string">&#x27;Age&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除 &#x27;Age&#x27; 列</span></span><br></pre></td></tr></table></figure></li><li><p>数据筛选：使用条件筛选数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]  <span class="comment"># 筛选年龄大于 30 的行</span></span><br></pre></td></tr></table></figure></li><li><p>聚合操作：进行统计和聚合计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]  <span class="comment"># 筛选年龄大于 30 的行</span></span><br></pre></td></tr></table></figure></li><li><p>数据排序：按列的值排序 DataFrame。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]  <span class="comment"># 筛选年龄大于 30 的行</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>模拟一组数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>],</span><br><span class="line">        <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;London&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Salary&#x27;</span>: [<span class="number">5000</span>, <span class="number">6000</span>, <span class="number">7000</span>, <span class="number">8000</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><h6 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择年龄大于30的行</span></span><br><span class="line">result = df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]</span><br></pre></td></tr></table></figure><h6 id="loc-和-iloc"><a href="#loc-和-iloc" class="headerlink" title=".loc 和 .iloc"></a>.loc 和 .iloc</h6><ol><li>label指定行列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[<span class="number">0</span>, <span class="string">&#x27;City&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>使用值列表哦批量查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result  = df.loc[[<span class="string">&#x27;Alice&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],<span class="string">&#x27;City&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>使用数值区间进行范围查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;Charlie&#x27;</span>,Salary]</span><br></pre></td></tr></table></figure></li><li>使用条件表达式查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[df[<span class="string">&#x27;Salary&#x27;</span>] &lt; <span class="number">7000</span> :  ]</span><br></pre></td></tr></table></figure></li><li>调用函数查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = df.loc[<span class="keyword">lambda</span> df:(df[<span class="string">&quot;Salary&quot;</span>] &lt; = <span class="number">7000</span>) &amp; (df[<span class="string">&quot;Salary&quot;</span>] &gt; = <span class="number">5000</span>) ]</span><br></pre></td></tr></table></figure></li></ol><h6 id="isin"><a href="#isin" class="headerlink" title=".isin"></a>.isin</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择城市为&#x27;Paris&#x27;或&#x27;Tokyo&#x27;的行</span></span><br><span class="line">result = df[df[<span class="string">&#x27;City&#x27;</span>].isin([<span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>])]</span><br></pre></td></tr></table></figure><h6 id="query"><a href="#query" class="headerlink" title=".query"></a>.query</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择工资大于6000的行</span></span><br><span class="line">result = df.query(<span class="string">&#x27;Salary &gt; 6000&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="新增数据列"><a href="#新增数据列" class="headerlink" title="新增数据列"></a>新增数据列</h5><ol><li><p>使用直接赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#新增一个名为&#x27;C&#x27;的列，并赋值为一个列表</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>] = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用assign()方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建一个DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="comment">#使用assign()方法新增一个名为&#x27;C&#x27;的列，并赋值为一个列表</span></span><br><span class="line">df = df.assign(C=[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></li></ol><h5 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h5><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>sum()</code></td><td>计算数字的总和</td></tr><tr><td><code>mean()</code></td><td>计算平均值</td></tr><tr><td><code>median()</code></td><td>计算中位数</td></tr><tr><td><code>mode()</code></td><td>计算众数</td></tr><tr><td><code>variance()</code></td><td>计算方差</td></tr><tr><td><code>stddev()</code></td><td>计算标准差</td></tr><tr><td><code>min()</code></td><td>找到最小值</td></tr><tr><td><code>max()</code></td><td>找到最大值</td></tr><tr><td><code>numpy</code> 库</td><td>强大的数组和矩阵操作</td></tr><tr><td><code>pandas</code> 库</td><td>数据处理和分析，提供数据结构和统计函数</td></tr><tr><td><code>scipy</code> 库</td><td>高级的统计函数和科学计算工具</td></tr></tbody></table><p>当涉及到统计函数时，以下是每个函数的简单示例：</p><ol><li><p><code>sum()</code>: 计算数字的总和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">total = <span class="built_in">sum</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(total)  <span class="comment"># 输出：15</span></span><br></pre></td></tr></table></figure></li><li><p><code>mean()</code> 或 <code>average()</code>: 计算平均值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">12</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">36</span>]</span><br><span class="line">average = <span class="built_in">sum</span>(numbers) / <span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(average)  <span class="comment"># 输出：24.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>median()</code>: 计算中位数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">numbers.sort()</span><br><span class="line">n = <span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    median = (numbers[n//<span class="number">2</span> - <span class="number">1</span>] + numbers[n//<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    median = numbers[n//<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(median)  <span class="comment"># 输出：5</span></span><br></pre></td></tr></table></figure></li><li><p><code>mode()</code>: 计算众数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> mode</span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">result = mode(data)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure></li><li><p><code>variance()</code>: 计算方差</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> variance</span><br><span class="line">data = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>]</span><br><span class="line">result = variance(data)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：11.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>stddev()</code>: 计算标准差</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">from</span> statistics <span class="keyword">import</span> stdev</span><br><span class="line">   data = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>]</span><br><span class="line">   result = stdev(data)</span><br><span class="line">   <span class="built_in">print</span>(result)  <span class="comment"># 输出：3.3166247903554</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> `<span class="built_in">min</span>()` 和 `<span class="built_in">max</span>()`: 找到最小值和最大值</span><br><span class="line"></span><br><span class="line">   ```python</span><br><span class="line">   numbers = [<span class="number">15</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">11</span>]</span><br><span class="line">   min_val = <span class="built_in">min</span>(numbers)</span><br><span class="line">   max_val = <span class="built_in">max</span>(numbers)</span><br><span class="line">   <span class="built_in">print</span>(min_val)  <span class="comment"># 输出：3</span></span><br><span class="line">   <span class="built_in">print</span>(max_val)  <span class="comment"># 输出：22</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h4><p>首先，让我们导入numpy库。在你的Python环境中，你可以这样做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>我们使用 “as” 关键字给numpy库起了一个别名 “np”，这样在我们的代码中就可以使用 “np” 来代替 “numpy”，使代码更简洁。</p><p><strong>创建数组</strong></p><p>在numpy中，最基本的对象是ndarray对象，也就是n维数组。我们可以使用np.array()函数来创建一个数组。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure><p>这将会创建一个一维数组，并输出 <code>[1 2 3 4 5]</code>。</p><p><strong>数组的属性</strong></p><p>创建了数组之后，我们可以查看一些数组的属性。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shape of the array: &quot;</span>, arr.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Data type of the array: &quot;</span>, arr.dtype)</span><br></pre></td></tr></table></figure><p><code>shape</code> 属性返回一个元组，表示数组的形状（即各维度的大小）。<code>dtype</code> 属性则返回数组中元素的数据类型。</p><p><strong>多维数组</strong></p><p>我们不仅可以创建一维数组，还可以创建多维数组。例如，我们可以创建一个2x3的二维数组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr_2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr_2d)</span><br></pre></td></tr></table></figure><p>这将会输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br></pre></td></tr></table></figure><p><strong>数组的索引和切片</strong></p><p>我们可以使用索引和切片来访问和修改数组中的元素。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])  <span class="comment"># 输出数组的第一个元素</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># 将数组的第一个元素修改为10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr_2d[<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 输出二维数组的第一行第二列的元素</span></span><br><span class="line">arr_2d[<span class="number">1</span>, :] = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]  <span class="comment"># 将二维数组的第二行的所有元素修改为7, 8, 9</span></span><br></pre></td></tr></table></figure><h5 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h5><ol><li>加法：<code>numpy.add(x, y)</code>，对应元素相加。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))  <span class="comment"># Output: array([5, 7, 9])</span></span><br></pre></td></tr></table></figure><ol start="2"><li>减法：<code>numpy.subtract(x, y)</code>，对应元素相减。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.subtract(x, y))  <span class="comment"># Output: array([-3, -3, -3])</span></span><br></pre></td></tr></table></figure><ol start="3"><li>乘法：<code>numpy.multiply(x, y)</code>，对应元素相乘。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.multiply(x, y))  <span class="comment"># Output: array([ 4, 10, 18])</span></span><br></pre></td></tr></table></figure><ol start="4"><li>除法：<code>numpy.divide(x, y)</code>，对应元素相除。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.divide(x, y))  <span class="comment"># Output: array([0.25, 0.4 , 0.5 ])</span></span><br></pre></td></tr></table></figure><ol start="5"><li>幂运算：<code>numpy.power(x, y)</code>，对应元素做幂运算。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.power(x, y))  <span class="comment"># Output: array([  1,  32, 729], dtype=int32)</span></span><br></pre></td></tr></table></figure><ol start="6"><li>平方根：<code>numpy.sqrt(x)</code>，计算数组各元素的平方根。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.sqrt(x))  <span class="comment"># Output: array([1.        , 1.41421356, 1.73205081])</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>三角函数，如 numpy.sin(x)、numpy.cos(x)、numpy.tan(x)等。</p></li><li><p>指数和对数，如 <code>numpy.exp(x)</code>、<code>numpy.log(x)</code>、<code>numpy.log10(x)</code>等。</p></li></ol><h5 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h5><ol><li><code>numpy.random.rand(d0, d1, ..., dn)</code>: 生成一个给定形状的数组，数组中的值均匀分布在[0, 1)中。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.rand(<span class="number">3</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li><code>numpy.random.randn(d0, d1, ..., dn)</code>: 返回一个由d0, d1, …, dn确定的形状的数组，数组中的值来自标准正态分布。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.randn(<span class="number">3</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><ol start="3"><li><code>numpy.random.randint(low, high=None, size=None, dtype=&#39;l&#39;)</code>: 返回随机整数，范围区间为[low, high)，high默认为None。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">2</span>, size=<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">1</span>, size=<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(np.random.randint(<span class="number">5</span>, size=(<span class="number">2</span>, <span class="number">4</span>)))</span><br></pre></td></tr></table></figure><ol start="4"><li>numpy.random.random(size=None)`: 返回随机的浮点数，在半开区间 [0.0, 1.0)。 </li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.random())</span><br><span class="line"><span class="built_in">print</span>(np.random.random((<span class="number">5</span>,)))</span><br><span class="line"><span class="built_in">print</span>(np.random.random((<span class="number">2</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><ol start="5"><li><code>numpy.random.choice(a, size=None, replace=True, p=None)</code>: 从一个给定的一维数组中生成随机数。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.choice(<span class="number">5</span>, <span class="number">3</span>))  <span class="comment"># 从0到4中随机选择3个数</span></span><br></pre></td></tr></table></figure><p>注意：为了获得可重复的结果，我们可以使用<code>numpy.random.seed()</code>函数设置随机数种子。</p><h6 id="蒙特卡洛模拟"><a href="#蒙特卡洛模拟" class="headerlink" title="蒙特卡洛模拟"></a>蒙特卡洛模拟</h6><p>这是一个使用NumPy进行蒙特卡洛模拟的例子。在这个例子中，我们将使用蒙特卡洛模拟来估计圆周率π的值。</p><p>基本思想是这样的：我们在一个边长为1的正方形内随机撒点，然后计算落在1/4圆内（半径为1）的点的数量。由于圆的面积是πr²，正方形的面积是1，所以落在1/4圆内的点的数量除以总的点的数量，大约等于π/4。</p><p>以下是Python代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义模拟的次数</span></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在[0, 1)区间内随机生成n个点的x和y坐标</span></span><br><span class="line">points = np.random.rand(n, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算这些点到原点的距离，然后判断这些距离是否小于1（也就是判断这些点是否落在1/4圆内）</span></span><br><span class="line">inside_circle = np.<span class="built_in">sum</span>(np.square(points).<span class="built_in">sum</span>(axis=<span class="number">1</span>) &lt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#估计π的值：落在1/4圆内的点的数量除以总的点的数量，然后乘以4</span></span><br><span class="line">pi_estimate = <span class="number">4</span> * inside_circle / n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;π的估计值为：<span class="subst">&#123;pi_estimate&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个代码运行后，会打印出一个π的估计值，这个值应该会接近真实的π值（3.14159…）。随着模拟次数n的增加，这个估计值会越来越接近真实的π值。</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python&quot;&gt;&lt;a href=&quot;#Python&quot; class=&quot;headerlink&quot; title=&quot;Python&quot;&gt;&lt;/a&gt;Python&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://kalyan-zitiu.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Study-Note/"/>
    
    
    <category term="Python" scheme="https://kalyan-zitiu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HumanSystemOptimization</title>
    <link href="https://kalyan-zitiu.github.io/2023/08/31/%E4%BA%BA%E4%BD%93%E8%B0%83%E4%BC%98/"/>
    <id>https://kalyan-zitiu.github.io/2023/08/31/%E4%BA%BA%E4%BD%93%E8%B0%83%E4%BC%98/</id>
    <published>2023-08-31T14:00:00.000Z</published>
    <updated>2023-08-31T12:37:27.041Z</updated>
    
    <content type="html"><![CDATA[<p>UPDATE: 鉴于文章比较长，很多同学没有耐心读完，后续也分享录制了一个 <a href="https://www.bilibili.com/video/BV1EW4y1R7yi/">视频版</a>，基本涵盖了文章里的大部分内容。</p><p>另外在健康生活实践方面，也提供一个极简版的基础列表，供大家参考：</p><ul><li>保持睡眠时长与质量。</li><li>不要吸烟。</li><li>尽可能每天做点运动。</li><li>减少糖分的摄入。</li></ul><p>能做到这四点，就已经可以达到一个还不错的健康状态了。剩下的可以根据各自的身体状况再来做补充调整。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>去年 5 月曾经写了一篇文章介绍了下 <a href="https://zhuanlan.zhihu.com/p/371254789">Lex Fridman 大佬的日常生活安排</a>，后续我也根据他的方法对自己的日常生活做了一系列规范和改进。这一年整体实行下来，效果还是非常显著的，本文的最后会对我的一些实践以及借助的工具做一些分享。</p><p>最近几个月，偶然在油管上看到了个 <a href="https://youtu.be/2ekdc6jCu2E">Rich Roll 采访 Andrew Huberman 的 podcast</a>，介绍了如何提升我们日常工作，学习表现的相关神经科学原理与可以利用的“工具”，瞬间打开了一扇新世界的大门。后续又一连追了好几集 Huberman 自己的 podcast，从各个方面了解了一下跟我们日常生活，健康，学习，工作，锻炼等方面相关的知识。与其它很多讲“养生”的文章和视频最大的区别在于，Huberman 本身是斯坦福的神经科学教授，其中讲述的内容都是<strong>来自于高质量，peer reviewed 的科学研究成果</strong>，从机体工作原理出发，非常细致地介绍了相关的实验和结论，并给出了很多实操建议（很多都是零成本，不是搞推销的……）。</p><p>通过一系列的学习，逐渐有种学习了各种人类的“组成和操作原理”的感觉。通过一系列的工具和实践，我们也可以<strong>像调优软件程序那样来“调优”我们自身的人体系统</strong>。这篇文章就来介绍一些相关的知识内容。注意，原版的 podcast 中有非常多专业性的阐述，在这篇文章中基本都去掉了，尽量以故事性的描述来讲解，相对会比较好理解。当然准确性也会因此有所下降，如果希望获取更专业的内容，强烈建议观看 <a href="https://hubermanlab.com/">原版的 podcast 内容</a>。</p><h1 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h1><p>如果你想要获得健康，更好的工作学习状态，提升生理健康如免疫，新陈代谢，以及心理健康如更好的心情，专注能力等，最最重要的前提是拥有一个良好的睡眠。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>睡眠最重要的控制机理是我们内在的生物钟。随着生物钟的影响，我们体内的各类化学物质会发生变化，体温也随之改变，会影响我们的各种内在状态和外在行为。Huberman 教授很形象地描述了这个“生物钟”的具体作用方式：在早上，身体释放的皮质醇（cortisol）和肾上腺素（aderenaline）会让我们醒来，同时还会设定松果体释放褪黑素的倒计时钟，会在十多个小时之后让我们感到困意再次入睡。</p><p>影响这个生物钟的最大因素是光照。我们的眼睛除了能够看到东西，另外一个重大的作用就是<strong>通过黑视素神经节细胞来接收光照信息，用以设定我们的内在生物钟</strong>。这也是为什么有时候我们通宵工作之后，虽然已经持续很久时间没有睡眠了，但随着太阳升起，整体的生物钟被设定到了类似起床时的状态，各类化学物质的释放会让我们突然感觉又有精神了。后续很多最佳实践里也都跟这个原理相关，我们需要控制自己接收光照的时间点，类型和时长。</p><p>此外，<strong>体温也是一个用于控制我们生物钟的手段</strong>。一般来说我们的体温会从深睡眠中比较低的状态逐渐升高，到醒来后持续上升。到了一天的后半段会开始逐渐下降，直到再次进入睡眠。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>基于上面的原理，Huberman 教授提供了一系列提升睡眠的最佳实践：</p><ul><li>皮质醇的释放与接触阳光有关，因此如果想尽快醒来且保持日间良好的精神状态，<strong>起床后应该到外面去接触阳光，持续 2-10 分钟</strong>。这对于血压控制，心理状态，设定睡眠的“倒计时钟”等都有很大好处。户外日光的效果最好，如果是人造光源，蓝光的效果会比较好，且最好是上部（天空的位置）的光源。根据光照强度推算，隔着窗户接收日光的强度会降低 50%以上，而达到同样效果所需要的光照时间则需要 50 到 100 倍。有意思的是，这一点对于视障人士也有效，因为前面提到的黑视素神经节细胞并不是用于视觉成像的细胞。</li><li>对应的，<strong>在晚上要尽量减少光源的接触</strong>，因为这会扰乱我们的生物钟，让身体系统误以为是在白天。尤其是晚上 11 点到次日凌晨 4 点之间接收光源，会抑制后续几天的多巴胺的释放，影响心情，心理健康，专注度，学习能力，新陈代谢等等。关于多巴胺的作用和机理，后面会再单独介绍。</li><li>如果不可避免需要在晚上接触光源，处于较低位置，暗淡的红光，蜡烛之类的会相对好一些。如果要看电脑，建议使用 blue blockers 眼镜，这跟一些电脑软件会自动调节屏幕色温的效果可能类似。</li><li>傍晚观察落日，对于后续入睡也有帮助，甚至能减轻晚上摄入光照的负面影响，有点神奇。</li><li>人一天中的精神状态一般会在中间有个短暂的低谷，所以午睡对于有些人可能是有帮助的。也可以用一些其它的非睡眠深度休息的方式来替代，如 <a href="https://youtu.be/M0u9GST_j3s">Yoga Nidra</a>，<a href="https://www.headspace.com/">冥想</a>，<a href="https://www.youtube.com/c/MichaelSealey">自我催眠</a>（可以利用一些 App，如 Reveri）等。</li><li>体温对生物钟周期的影响：<ul><li>早上洗冷水澡，会让人快速升温，从而把睡眠周期往前移（早起）。</li><li>晚上锻炼身体，会让人保持高体温，从而延后周期（晚睡）。</li><li>可以选购一些自动控制体温的智能床垫来提升睡眠质量。</li></ul></li><li>一般建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点。不过总体来看好像影响度比较小。</li><li>饮食和药物因素：<ul><li>咖啡因会占据腺苷（adenosine）的受体，阻断入睡的信号。有不少文章都提到中午之后尽量不要喝咖啡，但 Huberman 表示没有科学实验表明咖啡因对所有人的效果是一样的，得根据自己的测试情况来。比如他自己在下午 5 点喝咖啡也能正常入睡。</li><li>镁，对入睡有帮助。</li><li>芹黄素也能帮助入睡，但要注意对雌性激素的影响。</li><li>建议不要摄入太多牛磺酸。</li><li>不建议通过摄入褪黑素来帮助入睡，褪黑素药物本身的规格把控不严格，且褪黑素容易引起抑郁情绪。</li><li>中午可以吃低卡路里以及含酪氨酸的食物，如坚果，大豆，部分蔬菜等，提升多巴胺，肾上腺素，保持清醒。</li><li>晚上则可以吃点淀粉，白肉等富含色氨酸的食物，进而转化为血清素，会让人更加平静，容易入睡。</li></ul></li><li>对于绝大多数人，6-8 小时的睡眠时长是比较健康的。</li><li>对于各类药物的检索可以参考：<a href="https://examine.com/">examine.com</a>。</li></ul><h1 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h1><p>在前面 Lex 的分享中，提到了他采取了生酮饮食以及 fasting（禁食）的习惯，这引起了我对于饮食习惯的注意。Huberman 教授正好也有几个 podcast 介绍了 fasting，肠道健康等话题，很有意思。</p><h2 id="Fasting-的背景"><a href="#Fasting-的背景" class="headerlink" title="Fasting 的背景"></a>Fasting 的背景</h2><p>我们可以把身体跟进食相关的化学状态分成 2 类：</p><ol><li>吃饱了的状态，也就是血糖含量较高的状态。此时我们身体会更活跃地进行体内细胞的复制与成长。</li><li>禁食的状态，也就是血糖含量较低的状态。此时我们的身体会更活跃地进行体内细胞的修复与清理（autophagic）。</li></ol><p>由于睡眠时我们天然是不吃东西的，所以一般来说睡眠中的一部分时间会使我们处于禁食状态，饮食时间的选择实际上就是在控制上述两个状态的持续时间和平衡关系。比较有意思的是世界上很多民族文化和宗教中，都有一些跟禁食相关的习俗，甚至会持续很多天。</p><p>在 2012 年，科学家开始对小白鼠做实验，把他们分成两大组，一组可以在一天中的任何时间吃东西，而另一组只能在固定的 8 小时里吃东西。在大组里再区分小组，给小白鼠吃健康的和不健康的食物。结果发现，只能在 8 小时里吃东西的小白鼠们，即使吃的是不健康的高脂肪食物，他们的健康水平仍然得到了保持甚至提高，相比所有不做限制的组都有明显的提升。</p><p>这个研究震动了学术界，后续又有非常多的针对人类，不同性别，不同年龄，不同职业（包括运动员）的各种实验与论文发表，科学家们发现这种<strong>间歇性禁食状态对于身体有非常多的好处</strong>，包括：促进肝脏健康，胆汁酸代谢，炎症自愈，保持体重，提升 brown fat 储备（对健康有益），防止非酒精性脂肪肝，血糖控制，肠道健康等等。如果养成间歇性禁食的习惯 60 天以上，还会让我们的身体倾向于代谢脂肪来供能，控制体重。</p><p>因此，Huberman 教授指出，<strong>何时进食，与吃什么东西，其实是同等重要的</strong>。这个研究也让很多学术界的研究人员自己也都养成了 fasting 的习惯，包括 Huberman 自己。</p><h2 id="Fasting-的实践"><a href="#Fasting-的实践" class="headerlink" title="Fasting 的实践"></a>Fasting 的实践</h2><p>由于长时间的禁食难度较大，所以绝大多数的研究都专注于间歇性禁食，也就是 intermittent fasting。简单来说就是跟前面的小白鼠实验一样，在一天的固定时间段来吃东西（跟睡眠周期对齐），而其它时间段都不摄入任何食物的做法。这里简单整理为基础和高阶两个版本：</p><ul><li>基础：如果想享受 fasting 的基础收益，最简单的执行原则是<strong>起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西</strong>。</li><li>高阶：目前研究结果中<strong>最理想的进食窗口是 8 小时</strong>，结合社会习俗等，一般比较合理的时间在 10-18 点或 12-20 点的范围。看起来<strong>不吃早饭并不是什么坏事</strong> :)</li><li>作者特地温馨提醒，如果想通过健身来增肌，建议可以把这个时间窗口往前移，因为早上摄入蛋白质会对肌肉增长有益。而健身的时间可以自由选择。</li><li>尽量<strong>保证这个窗口时间的稳定性</strong>，也非常重要。否则就跟频繁倒时差产生的效果差不多，会打不少收益折扣。</li><li>如果想尝试高阶 fasting，建议逐渐切换进食习惯，例如每两天缩短 1 小时的进食窗口，逐渐达到理想的 8 小时。</li></ul><p>值得注意的是，这里说的不吃任何东西，并不是说连水也不能喝。从前面的背景可以看到，是否处于禁食状态，主要依据是血糖水平，因此：</p><ul><li>喝水，茶，咖啡（不加牛奶）等，并不会中断禁食。但一勺糖的摄入就会中断。</li><li>晚饭后想尽快进入禁食状态，可以做一些轻量运动，比如散步等，加快血糖清理。</li><li>二甲双胍，黄连素（berberine）等可以直接促进血糖清理。肉桂皮，柠檬汁，也能轻微降低血糖。</li></ul><p>最后，如果禁食期间觉得有些头晕，颤抖，并不需要立刻进食或摄入糖分。可以喝一点盐水（可以加柠檬汁），一般就能很好的缓解症状。这让我想起 Lex 会提到了会服用药片来补充各种电解质元素，比如钠，镁，钾等。</p><h2 id="饮食与消化道健康"><a href="#饮食与消化道健康" class="headerlink" title="饮食与消化道健康"></a>饮食与消化道健康</h2><p>由于我个人的肠胃功能比较差，所以也特别关注了一下消化道健康的话题。Huberman 邀请了一位非常知名的微生物学家 Sonnenburg 来介绍肠胃微生物群落与我们的健康之间的关系，也是学到了很多新的知识：</p><ul><li>肠道的微生物群不仅影响消化系统的健康运作，<strong>对人体的免疫系统也起到了非常关键的因素</strong>。</li><li>婴儿出生，成长的方式会形成非常不同的肠道菌群生态。暴露在微生物环境中（但要注意会引起疾病的情况），对于维持菌群环境是有益的，比如家里养宠物，让孩子自由玩耍等，不需要过度清洁与消毒。</li><li>什么是健康的肠道菌群生态，目前没有一个标准的结论。不过总体来看，<strong>菌群的多样性程度高，一般就表示更加健康</strong>。</li><li>抗生素会严重破坏肠道菌群生态，需要谨慎使用。</li></ul><p>在访谈中，两位重点讨论了一个实验，就是什么样的饮食方式会让我们更好的维持肠道菌群的多样性和健康。实验主要对比了两种附加饮食：</p><ul><li>高纤维食物：全谷类，豆类，蔬菜，坚果。这也是传统上被认为非常健康的食物，其中很多纤维的分解都需要肠道菌群的帮助，换句话说，纤维就是它们的“食物”。</li><li>发酵类食物：酸奶，牛奶酒（kefir），康普茶，酸菜，泡菜，纳豆等。注意需要是自然发酵，一般是冷藏且非罐装的食品。而且像酸奶这类要格外注意不要加糖等添加剂。</li></ul><p>实验的结果也颇令人意外：</p><ul><li>摄入发酵类食品的组，显著提升了肠道菌群的多样性。被试者<strong>几十个免疫标志物的显著降低，对各类炎症都有更好的抑制作用</strong>。没想到吧，肠道菌群还能调节炎症。</li><li>肠道菌群本来的多样化程度比较高的人，摄入高纤维食物是有帮助的。如果不是，则摄入高纤维食物的帮助不大。在工业化进程中，人类的进食习惯已经有很多代都转变为了摄入大量肉类，加工食品等，肠道菌群的生态无法仅通过提高纤维食物的量来改变其族群结构。</li></ul><p>此外在访谈中，两位还讨论了具体食谱推荐的问题，引用了 <a href="https://youtu.be/sJLK3sVexIk">Christopher Gardner 关于生酮饮食与地中海饮食比较的研究</a>。这里总结一下实践建议：</p><ul><li><strong>如果要改善肠道菌群生态，最好的方式是一天两次摄入天然发酵类食品</strong>。</li><li>高纤维食物对于肠道菌群生态的维护是有益的，建议日常饮食以植物类食物为主，尽量避免深度加工食品的摄入，控制糖的摄入。Sonnenburg 教授还讲了个故事，说微生物学家参加的会议，一般餐厅的沙拉吧总是会供不应求 :) 前面提到的 Rich Roll 大佬也是个素食者。</li><li><strong>益生菌的效果没有广泛研究支持</strong>，且这类产品的监管很有限。<strong>益生元的效果也是好坏参半</strong>，缺乏多样性，溶解速度太快等问题都使总体效果存疑。</li><li>地中海饮食相比生酮饮食来说对健康的影响效果接近，但更容易坚持遵循。另外生酮饮食如果长期实践可能有一定的风险。所以<strong>总体更推荐地中海饮食结构</strong>。</li></ul><p>另外值得参考的是我们也有官方的 <a href="https://sspai.com/post/72984">中国居民膳食指南</a>，或许更适合东方人的饮食习惯。</p><h1 id="心态与动力"><a href="#心态与动力" class="headerlink" title="心态与动力"></a>心态与动力</h1><p>这一部分主要介绍的是人体的多巴胺系统原理，以及如何利用它来形成健康，自律的生活方式。这一集是 Huberman 开播以来播放量最高的一集，对于强健我们的心智有着非常好的指导作用。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>多巴胺是一种非常重要的化学物质，主要作用于两个神经回路：一个影响身体的运动，例如帕金森病与多巴胺的分泌不足有关；另一个则影响我们的动机，欲望与快乐，这几乎与我们从事的各种活动有关，无论是工作，学习还是社交，休闲娱乐。这里我们会主要讨论多巴胺的后者影响能力。我们为什么会“放弃”，实际上是由于在不安，压力，沮丧等情绪作用下，身体内的去甲肾上腺素水平不断提升，当超过一定阈值时，神经系统中的认知控制就会关闭，我们就放弃了。多巴胺能够抑制去甲肾上腺素作用，从而持续“激励”我们前行。</p><p>神经系统中多巴胺含量水平的高低会影响我们的情绪，当多巴胺水平低时，我们会感到情绪低落，没有动力，而多巴胺水平高时，我们会感到兴奋和快乐。在通常情况下，我们的身体处于多巴胺 baseline 的状态，当我们达成一些令人兴奋的目标（比如玩游戏胜利，考试拿高分）后，多巴胺的水平会达到一个高峰，此时我们就会获得巨大的愉悦感。在高峰之后，多巴胺水平会回落到比 baseline 更低的一个水平，且这个状态会持续一段时间。</p><p>这里有两个非常重要的原理：</p><ul><li>多巴胺绝对值含量的高低只是一方面，<strong>更重要的是其“相对变化量”的多少</strong>。比如在刷抖音时看到了一个很有趣的视频，多巴胺水平升高，你会感到快乐，刷到下一个视频时，你感到的快乐程度好像不会那么强烈了，因为多巴胺已经在一个比较高的水平，难以形成更大的变化量。而同样的视频，如果你是几天之后看到，或许你会觉得有意思的多。所以<strong>当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高</strong>。</li><li><strong>多巴胺的总体“储备”是有限的</strong>！也就是说无论你是通过学习，工作，娱乐，社交，运动等不同方式来获得快乐，所消耗的“快乐货币”都是同一种：多巴胺。举几个例子来看下这个原理带来的影响：<ul><li>很多自律的人都会说自己是 work hard，play hard 的生活方式，比如工作日通过高强度的工作来获得成就和满足感，休息日进行各种休闲娱乐，运动，社交等方式来获得快乐，其实背后都是在释放多巴胺来获取快乐。长期持续，我们身体的多巴胺 baseline 会逐渐下降，出现一种耗尽（burn out）的心理感觉，对很多事物无法保持之前的兴趣与精力。</li><li>很多人会对玩电子游戏着迷，因为它们能带来巨大的多巴胺释放刺激让人感到快乐。但要意识到，多巴胺的储备是有限的，如果对此上瘾，你的多巴胺耗尽问题就会变得非常严重：一方面能够引起你兴趣的事物会变少，可能只有玩游戏才能带来快乐；另一方面，后续甚至会导致玩游戏本身也无法触发多巴胺释放，引起严重的抑郁问题。</li></ul></li></ul><p>另外，<strong>多巴胺也具有叠加效应</strong>。比如你喜欢健身，那么运动就会刺激多巴胺的释放。而我们实际去健身时，可能会不自觉地安排了很多其它的“快乐因素”，比如选一个精神状态比较好的日子，运动前喝一些能量饮料，跟认识的朋友一起去，边健身边 social，听一些自己喜欢的音乐或 podcast，等等。这些因素也都会促进多巴胺的释放，让你感到“前所未有的快乐”。但要注意前面的原理，多巴胺的高峰越高，后面随之而来持续的低谷也会越长，而且长此以往，可能会降低你单纯从运动中获取快乐的能力。这样的例子还有很多，比如边跟朋友吃饭，边玩手机，拍照发朋友圈，可以计算一下叠加了几种快乐因素 :)</p><h2 id="影响多巴胺的外界因素"><a href="#影响多巴胺的外界因素" class="headerlink" title="影响多巴胺的外界因素"></a>影响多巴胺的外界因素</h2><p>我们来看下具体影响多巴胺释放的各类因素有哪些，首先是促进多巴胺分泌的：</p><ul><li>巧克力，提升到 1.5 倍的多巴胺 baseline</li><li>性行为，提升到 2 倍</li><li>尼古丁，提升到 2.5 倍</li><li>可卡因，提升到 2.5 倍</li><li>安非他命，提升到 10 倍</li><li>咖啡因本身只会少量提升多巴胺，但它会抑制一些多巴胺受体，提升同等多巴胺造成感受的效果</li><li>马黛茶，包含咖啡因，能控制血糖，还能保护多巴胺神经元</li><li>刺蒺藜豆也能提升多巴胺（基本等同于 L-DOPA），还能提升男性精子数量和质量</li><li>运动，带有主观成分，喜欢跑步的人，可以提升到 2 倍 baseline</li><li>健康的社交关系也会促进多巴胺释放</li></ul><p>食物方面感觉 Huberman 教授<strong>非常推荐马黛茶</strong>。</p><p>也有很多提升多巴胺释放或影响其效果的药物：</p><ul><li>L-Tyrosine（酪氨酸），提升多巴胺</li><li>Phenethylamine（PEA），巧克力中也包含，能够提升多巴胺</li><li>Huperzine A，提升多巴胺</li><li>各种“聪明药”，如 Adderall, Modafinil, Alpha-GPC, Ginkgo 等，留学党应该很多都有耳闻</li></ul><p>通常来说，<strong>不推荐持续使用这些药物</strong>，因为多巴胺释放之后的高峰会带来 baseline 水平的降低，导致无法享受活动的快乐，无法专注，限制学习能力和神经元可塑性等。Huberman 表示<strong>一周使用一次的频率应该是安全的</strong>。</p><p>最后还有一个比较特别的研究，就是<strong>冷水浴能够提升多巴胺释放到 baseline 的 2.5 倍左右</strong>，且持续时间更长，能达到 3 小时左右。建议使用 10-14 摄氏度的水温，注意安全。此外冷水浴也不需要太频繁，每周 11 分钟左右足够。如果已经习惯了冷水浴，那么也就没有释放多巴胺的效果了。</p><p>还有一些因素会降低多巴胺，如：</p><ul><li><strong>褪黑素，会引起多巴胺的减少</strong>。前面也提到过并不建议使用褪黑素来帮助入睡，或者适应时差等。</li><li>睡眠时段接触光源，也会引起接下来几天的多巴胺水平下降。<strong>半夜睡不着刷手机是很有害的哦</strong>。</li></ul><h2 id="维持健康的多巴胺水平"><a href="#维持健康的多巴胺水平" class="headerlink" title="维持健康的多巴胺水平"></a>维持健康的多巴胺水平</h2><p>了解了原理和各种影响因素后，我们来看下如何有效设计我们的生活工作方式来维持健康，可持续的多巴胺水平。</p><p>简单回顾一下，前面我们已经知道了多巴胺储备有限，且对一件事物上瘾会不断提高感受快乐的阈值，那么如何让我们能对一件事情保持长时间的兴趣和投入度，又不至于耗尽多巴胺呢？一个经典的例子是赌场的运作方式，我们并不是每一次下注都能赢，偶尔赢一次会释放多巴胺，而且根据赢得钱的多少有所上下浮动，这会吸引玩家持续参与。这就是一种非常有效的<strong>间歇性且随机的奖励机制</strong>。感觉很多游戏，社交网络产品也借鉴了这个思路来进行设计。</p><p>对于我们经常需要从事的活动，我们也可以模拟这个机制。还记得前面提到的<strong>多巴胺叠加效应</strong>吗？我们可以<strong>通过随机化叠加因素的多少，来实现多巴胺释放的差异性</strong>。还是以健身为例，我们可以随机决定今天是否要听音乐，是否去健身时带手机，是否要在健身前喝能量饮料等因素。如果其它什么都不做，只是单纯健身，那么多巴胺的释放量就会相对较低。如此就能模拟多巴胺释放有高有低的随机奖励机制。</p><h2 id="成长型思维"><a href="#成长型思维" class="headerlink" title="成长型思维"></a>成长型思维</h2><p>最后来看下如何构建良好的思维方式来利用多巴胺系统提升自我。</p><p>有一个非常知名的实验，挑选了一群天生喜爱画画的小朋友，在他们完成画作后给与一些奖励。后面在移除这些奖励后，小朋友们对于画画的兴趣和动力大大降低了。这个实验说明，当我们因为一个活动收到奖励（比如金钱，美食等）时，我们<strong>反而会降低活动本身的愉悦程度</strong>。而且多巴胺本身影响我们对时间的认知，同时也影响我们的情绪状态，如果我们<strong>始终以完成活动后的奖励为目标，则整个过程中就很少释放多巴胺，让原本困难的过程变得更加难以坚持</strong>。</p><p>仔细想一下，这是一个非常有意思的观察。多巴胺有点像我们的“本能系统”，决定了我们是否有动力做一件事。但反过来<strong>我们的主观思想却可以影响这个系统起作用的方式</strong>，这也是人类为何能摆脱动物本能，达成很多需要“反人性”的投入才能取得的成就的原因吧。上述的实验是我们的主观思想造成的一个反面作用的例子，我们自然也可以实现正面作用，那就是成长型思维。</p><p>具体来说，就是<strong>通过自我暗示，把努力过程本身当作一种“奖励”</strong>。我在努力学习，这个过程本身就是有趣的，会让我不断变得更强，这样的想法会在过程中激发身体系统释放多巴胺，而多巴胺提升了我们的情绪和动力水平，也会让努力的过程中碰到的困难变得相对容易克服。专注于这个过程的本身，而不是在过程前进行各种外界刺激（如前面提到的药物），或者在过程后给自己巨大的奖励。</p><p>这种思维方式看起来很主观，但这就是我们的神经系统工作的方式，虽然人类的“硬件系统”都差不多，但知识，思维这些运行之上的“软件”却可以千差万别。<strong>我们可以通过自律，自我暗示来改变自身对各类活动的喜好</strong>。例如通过暗示 fasting 对我们健康的益处，来获取满足感，而不是借助于 fasting 结束后的大快朵颐。通过自律抵御高油盐食物的吸引力，并且自我暗示植物类食物对身体的好处，坚持一段时间，会觉得花椰菜也挺美味的。这也是为什么我们在这篇文章中介绍了很多原理性的内容，而不仅仅是行为建议。因为这些原理知识能够让我们做更好的自我暗示 :)</p><p>多巴胺系统中也有对我们认知成长造成“障碍”的运作机理。例如当我们接受到的信息支撑我们之前的信念时，也能够激发多巴胺的释放让我们感到快乐，这从本质上会改变我们对世界的认知。由此可见，“空杯心态”是多么难得的品质，网上如此多的争论无法达成共识也有很大一部分“归功”于此。如何克服神经系统中的这类缺陷呢？一种可能的方法是尽可能调节情绪，使自己处于镇静的状态（提升血清素水平），这样才能让自己更好的去倾听和吸收跟自己认知不一致的信息，更好地协同合作。</p><p>这一节的 podcast 对我本人的冲击非常大，强烈建议大家观看这期 <a href="https://hubermanlab.com/controlling-your-dopamine-for-motivation-focus-and-satisfaction/">Mindset &amp; Drive</a>，相信也会有不同的收获。</p><h1 id="学习与专注"><a href="#学习与专注" class="headerlink" title="学习与专注"></a>学习与专注</h1><p>在了解了多巴胺的运作机制基础上，我们可以继续探究一些跟大脑健康，专注度，如何进行高效学习相关的话题。</p><h2 id="学习的原理"><a href="#学习的原理" class="headerlink" title="学习的原理"></a>学习的原理</h2><p>从脑神经科学来看，学习的本质是神经元的重新连接（rewire），进一步来看，需要大脑处在一种学习的化学状态下，也就是 Huberman 经常提到的神经可塑性（neuroplasticity）状态。要达到这个神经可塑性状态，有两个重要条件，一个是足够的专注度，另外一个是“犯错”的信号（后面会展开）。另外大脑一个比较有意思的机制是，在学习时的神经可塑状态下，乙酰胆碱会标记需要改变的神经元，而具体的神经元重连接则主要是在休息和睡眠时发生，是不是有点像 JVM 虚拟机的垃圾回收机制 :)</p><p>什么是犯错信号呢？当我们尝试做一些事情，但没有达到预期目标时，身体会给大脑发信号，“我犯错了”。处在这种犯错，沮丧的认知状态下，神经系统会释放肾上腺素（提升 alertness），乙酰胆碱（提升 focus），多巴胺（促进神经元的 change，rewire）等化学物质，激活神经元的可塑性。也就是说，<strong>犯错是我们进入学习状态的重要前提</strong>。搞机器学习的同学应该很熟悉了吧，这跟我们训练模型不是一模一样么 :) 另外很多人可能觉得心流（flow）状态是学习的最佳状态，而 Huberman 则不这么认为。<strong>心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能</strong>。</p><p>对于这个学习状态，经典的实验是给人们戴上一些能转变角度的眼镜，然后执行一些类似物体抓取的任务。由于看到的东西通过眼镜改变了其本来的位置，一开始在尝试时总会出现抓取动作的偏离。但后续在进入神经可塑性状态后，我们能逐渐适应相关的视觉偏移，协调自己的听觉，动作等都与之协同，顺利完成任务。更有意思的是，<strong>这个“神经可塑性”的化学状态是可以持续的</strong>，我们甚至可以先通过一些其它操作触发大脑的这个机制，再去进行真正的学习，以加快学习的速度。这里还有一个隐藏逻辑，当你在遇到挫折困难时，大脑进入了可塑性状态，而此时你却放弃了，那么<strong>神经元也会重新连接到这种容易放弃的行为模式，形成恶性循环</strong>。</p><p>人在年幼时期大脑天然的神经可塑性会比较好，而在 25 岁以后则会大大下降。我们后面会提到如何来进行克服。</p><p>另外，<strong>休息和睡眠时也会发生大量的神经元重连接的活动</strong>，这也是之前我们就提到过的，高质量的睡眠是实现很多生理，心理健康强壮的先决条件。</p><h2 id="利用神经可塑性"><a href="#利用神经可塑性" class="headerlink" title="利用神经可塑性"></a>利用神经可塑性</h2><p>如果正在阅读文章的你还未满 25 岁，那么恭喜你，你的神经可塑性仍然非常的好，可以<strong>尽可能广泛的学习各种知识和技能</strong>。比如你可以很快学会各种乐器，新的语言，新的运动，新的专业技能等等。通过更广阔领域的体验接触，尽量找到你最有兴趣的方向，可以后续再不断深入经营。</p><p>如果已经像我一样超过了 25 岁，那么还有很多办法来提升神经可塑性：</p><ul><li>通过实验发现，<strong>成年人对于小幅度的增量学习是完全可以适应与掌握的</strong>。例如每次视觉上的偏差只有 7 度，而不是一下子就来个 180 的大颠倒，那么成年人也能很快从错误中学习纠正。应用到实际学习中，我们每次学习的内容可以控制一下不要太多（本文有点违反了，建议收藏慢慢学习），多次积累来完成神经系统的调整学习。</li><li>对于达成目标的渴求度越高，重要性越大，奖励的刺激越大（比如为了生存），则神经可塑性就会越容易出现。这个比较符合直觉，但是现实中可操作性可能不高。</li><li>第三点最有意思，<strong>通过扰乱前庭神经系统（vestibular system），能够达到神经元可塑性的状态</strong>。简单来说，就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习。这一下子就让我想到了<strong>淘宝成立初期的“倒立文化”，没想到还真的有科学依据</strong>。需要注意的是，这个体验必须要新颖，也就是说如果你已经倒立很熟练了，那么去做倒立就是个日常行为，并不会给身体一种在犯错边缘，需要纠正的刺激。</li></ul><p>Huberman 认为，大脑的主要功能链路是感知，认知，情感，思想，行动。在尝试控制我们的神经系统来进行各种任务时（例如学习，解决困难问题，挑战运动极限），我们是很难用精神思想来控制其本身的（比如不断跟自己说我不能分心），更可行的办法是“逆向链路”，从我们的行动出发，利用神经系统的运作原理，逐渐影响思想，情感，认知甚至感知部分。这也是 Huberman 非常推崇各种“行动工具”的原因。Mood follows action。</p><h2 id="学习的理想状态"><a href="#学习的理想状态" class="headerlink" title="学习的理想状态"></a>学习的理想状态</h2><p>除了神经可塑性的化学状态外，我们也需要注意其它的因素。例如我们<strong>不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考</strong>等。这些也都跟我们体内的多巴胺，肾上腺素，乙酰胆碱，血清素，褪黑素等化学物质的水平有关，需要做好调节。在之前 Rich Roll 的访谈节目中，Huberman 提了一个非常有效的“呼吸工具”，叫<strong>生理叹息</strong>（Physiological Sigh）。操作方法上简单来说就是吸两口气，然后出一口长气。通常情况下，只要一两次生理叹息就足以使我们的压力和警觉水平迅速下降，让人感到更加平静，提升学习表现。</p><p>前面提到的成长型思维也很重要，在遇到错误导致的沮丧感觉时，可以不断增强自我暗示，失败是帮助我们学习成长的唯一路径，对我们是有益的，以此增加多巴胺的释放，提升学习动力和过程中的愉悦感。</p><p>联系到睡眠对学习的促进作用，也有一些研究提供了一些相关的 tips：</p><ul><li>在学习时听一些有规律的节拍，在入睡时也播放同样的微弱节拍，能够提升学习和记忆的效果。</li><li>一般在 90 分钟的学习后（人体生物钟的周期），可以选择进行 20 分钟的休息（non sleep deep rest），也会加强学习的效果。</li><li>Gap effect，在学习中随机停止 10 秒钟，这些停止会在睡眠中加速“播放”，提升学习效果。</li></ul><h2 id="提升专注"><a href="#提升专注" class="headerlink" title="提升专注"></a>提升专注</h2><p>“专注”背后的机理是大脑中两种“网络模式”的协调，一种叫 Default network，在我们不做任何事情时被激活，另一种叫 Task networks，在我们专注于做某些事情时被激活。普通人的大脑能够很好地协调这两个模式，两者像跷跷板一样，当一种模式被激活时另一种模式会被抑制。而具有专注障碍（比如多动症）的人来说，这两者无法很好地进行协调，因此会出现无法专注的现象。</p><p>通过提升多巴胺水平，可以有效促进这两种网络模式的协调，因此有非常多的多动症治疗药物都跟提升多巴胺有关，例如 <strong>Adderall，Modafinil</strong> 等。一些调查表明，这些药物（经常被称为聪明药，nootropics）在美国被滥用的程度甚至超过了大麻，不少“学霸”都以此来提升注意力，减少对睡眠的需求。但 Huberman 教授表示，一方面多巴胺的刺激提升后都会带来多巴胺水平的低谷，另一方面这些药物也可能导致上瘾，对新陈代谢作用造成扰动，有很多负面影响，<strong>对长期的学习与记忆效果可能并没有提升作用</strong>。在之前介绍多巴胺的章节也有提到，应该谨慎使用这类药物，并严格控制使用频率不能过高。</p><p>最好的提升专注的方法当然是前面聊过的更好的控制我们的多巴胺系统，例如把行动跟背后的意义相连接，给自己正面的心理暗示；将任务拆成多个小的里程碑，通过过程自身的激励来促进多巴胺的释放提升我们的专注度。此外一些安全有效的提升专注力的方法包括：</p><ul><li>适量补充 <strong>Omega-3 EPA 鱼油</strong>，这是神经细胞的组成原料之一，能够有效减轻抑郁，对治疗多动症（ADHD）也有帮助。</li><li><strong>通过身体其它部分释放运动，可以帮助提升注意力</strong>。教授举的例子是作为神经科医生在开刀时，如果采用半蹲半站的姿态（运动释放），拿手术刀的手更稳定不容易颤抖。这让我想起以前读书时很多同学习惯转笔，现在工作了也有不少人喜欢玩指尖陀螺，或者站立办公，可能都是类似效果。</li><li><strong>限制视野范围，能够提升专注度</strong>。比如我们经常因为眼睛瞟到了任务栏上的消息提示闪动而分心，可以通过一些设置来进入“专注模式”。</li><li>视线的高低也会影响神经状态，<strong>视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕</strong>。工作时一般至少把显示器放置在鼻子位置之上。</li><li>大脑不擅长处理大量频繁的 context switch，典型的比如刷抖音，不同的信息以非常快的速度频繁切换，这对我们的注意力是有伤害作用的。2014 年的一项研究表示，<strong>我们每天在手机上花费的时间应该少于 60 分钟（青少年）/120 分钟（成年）</strong>，以免引起注意力障碍问题。</li><li>还有研究表明，<strong>17 分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力</strong>。只要做一次就可以，完全可以尝试一下。</li></ul><h2 id="大脑健康"><a href="#大脑健康" class="headerlink" title="大脑健康"></a>大脑健康</h2><p>最后来看下提升大脑健康和效能的一些方法。</p><p>首先是前面提到过的，保证高质量的睡眠。</p><p>运动方面，<strong>对大脑直接帮助最大的是有氧运动</strong>，提升心肺功能，支持大脑供能。建议每周 150-180 分钟的有氧训练。</p><p>对于大脑健康有帮助的食物，其中前三点是比较重要的，后面的部分涉及的研究没有那么多：</p><ul><li><strong>Omega3, 尤其是 EPA 等脂肪酸</strong>，是大脑组成的重要部分，且一般人都容易摄入不足。多吃鱼，牡蛎，鱼子酱，奇亚籽，核桃，大豆。一天至少摄入 1.5 克，理想情况需要 3 克以上。不喜欢吃鱼的话可以辅助摄入鱼油。</li><li><strong>磷脂酰丝氨酸</strong>，也对认知能力有帮助。通过鱼，肉类，卷心菜来摄入。</li><li><strong>乙酰胆碱</strong>，重要的神经调质，提升注意力。摄入胆碱的重要来源是鸡蛋，尤其是蛋黄。土豆，坚果，水果中也含有，虽然没有蛋黄中的含量那么丰富。可以通过 Alpha-GPC 等补充剂来获取。</li><li>肌酸，尤其对于不吃肉的人，一天需要摄入 5 克左右。</li><li>花青素，在蓝莓，黑莓，葡萄等食物中有提供。可以降低 DNA 损伤，缓解认知下降等问题。大约每天需要 60-120 克蓝莓的补充。</li><li>谷氨酰胺，可以通过牛肉，鸡肉，鱼肉，鸡蛋，大豆，卷心菜，菠菜，芹菜等食物来摄取。提升大脑在缺氧（高海拔地区）下的表现，还能够抑制对糖的需求。</li><li>水，钠，钾，镁等电解质是神经元信号传递所需的基础元素，需要保证。</li></ul><p>这一节中还讨论了我们身体对各种食物喜好进行判断的三个渠道，前两个分别是味觉判断和营养成分的下意识判断。第三个比较有意思，也跟多巴胺有关，即我们可以<strong>通过提升大脑代谢的活跃度来增加对某种食物的喜好</strong>。比如你如果不喜欢吃鱼，一种方法是你可以把鱼跟你平时爱吃的食物一起吃，另一种是给自己足够的心理暗示，说服自己吃鱼是有益身体健康的。通过这两种办法，你都可以让大脑释放多巴胺，从而逐渐提升对鱼类食物的喜好程度。</p><p>最后，如果你对膳食补充剂感兴趣，还可以看看 <a href="https://www.thorne.com/u/huberman">Huberman 教授平时会吃的补充剂有哪些</a>。</p><h1 id="长寿"><a href="#长寿" class="headerlink" title="长寿"></a>长寿</h1><p>最后我们来看下如何延年益寿，这是 Huberman 跟这个领域的专家，来自哈佛的 David Sinclair 的一集访谈节目。</p><h2 id="衰老的本质"><a href="#衰老的本质" class="headerlink" title="衰老的本质"></a>衰老的本质</h2><p>Sinclair 认为，衰老是一种疾病，它本身导致了非常多通常意义上的疾病的出现，比如阿尔兹海默症，癌症等。我们可以通过科学的手段来“治疗”衰老，甚至逆转它。</p><p>从本质上来说，衰老是<strong>基因信息的损失</strong>，这分为两部分：</p><ul><li>DNA 本身的信息，比如细胞中的 DNA 结构会在辐射等情况下受到破坏。</li><li>控制哪些基因进行表达的信息受到了破坏，也就是所谓的表观基因组（epigenome）。这部分在衰老的因素中占了 80%。</li></ul><p>人体内有一个天然的“衰老时钟”，而且并不是以匀速走的。在年轻时我们的生长发育过程中，这个时钟走得更快。所以如果青春期发育比较迅速的人，一般来说整体的时钟走的比较快，寿命也会相对短，是不是有点吓人……而且，一般比较矮小的人，像侏儒很少会得心脏病，癌症，也会明显更长寿。不过不要紧张，前面提到了，基因本身的信息只占了衰老因素的 20%，<strong>控制基因表达这部分占了大多数</strong>。</p><p>这里有点意外的是 Sinclair 教授介绍的最重要的几个实验，都跟前面我们提到的 fasting 有关。比如一般老鼠的寿命大概是 2 年，他们实验室有一只叫 Yoda 的老鼠，活了足足 5 年。其主要的做法就是选取了侏儒基因，以及执行 fasting。</p><p>教授详细介绍了 <strong>fasting 为何能提升动物/人类 30% 以上的寿命</strong>：</p><ul><li>在低血糖水平时，身体会抑制哺乳动物雷帕霉素靶蛋白（mTOR），激活去乙酰化酶（sirtuin），形成一个非常良好的化学状态，清理旧蛋白质，提高胰岛素敏感度，提供更多能量，修复细胞等等。后面这个乙酰化酶是我们抵御衰老的一个重要武器。</li><li>当胰岛素水平低时，“长寿基因”会被激活，如 SIRT1 等。</li><li>fasting 会给细胞足够的“休息时间”。</li><li>血糖水平低，会让身体对胰岛素更敏感，更快吸收血糖，也对健康有益。</li><li>当你从来不感受饥饿时，你的衰老时钟也走的更快。</li><li>除了 24 小时周期 fasting 触发的 autophagic，还有更深层次的清理机制，会在禁食第二，三天启动。在老年老鼠上的实验表明，这种长时间的禁食可以让他们延长寿命 35%。不过这个实操难度对普通人来说有点大。</li></ul><p>Sinclair 也对比了一些上个世纪失败的研究，比如通过抗氧化剂来抵御衰老。现代长寿研究的核心思想是，如何<strong>通过一些机制手段来触发身体自身的衰老抵抗机制</strong>。</p><p>此外 Sinclair 也介绍了一些激动人心的前沿技术，例如<strong>通过基因治疗方法，可以重启我们的 DNA 表达系统</strong>。通过一次注射，可以让盲人恢复视力，这已经在老鼠身上得到了验证。或许几年后，我们可以像死侍那样实现身体各部分的逆转老化。</p><h2 id="抗衰老手段"><a href="#抗衰老手段" class="headerlink" title="抗衰老手段"></a>抗衰老手段</h2><p>先来总览看一下各种抗衰老的手段。</p><h3 id="饮食-1"><a href="#饮食-1" class="headerlink" title="饮食"></a>饮食</h3><p>包括食物结构和饮食控制。饮食控制方面前面有提到过，建议缩短进食窗口到 8 小时左右。饮食结构可以参考最新发表在 Cell 上的这篇文章 <a href="https://www.cell.com/cell/pdf/S0092-8674(22)00398-1.pdf">Nutrition, longevity and disease: From molecular mechanisms to interventions</a>。简单总结一下就是多吃植物类的蛋白（花生，藜麦，豆类，西兰花等），脂肪（橄榄油，坚果，牛油果等），减少精制碳水（白米饭，白面包，蛋糕，饼干等）；动物脂肪，动物蛋白质，糖这些总体来说是加速衰老的。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/diet_for_longevity.png" alt="长寿饮食建议"></p><h3 id="体育锻炼"><a href="#体育锻炼" class="headerlink" title="体育锻炼"></a>体育锻炼</h3><p>有氧锻炼对心肺功能，血管健康等方面的促进对延寿很有帮助。力量训练也能持续保持我们的肌肉，关节，韧带的力量水平，支撑保护能力等，在年纪大时减少各种跌倒或者受伤的风险。一般建议是一周 3 小时左右的有氧运动，搭配 2 到 3 次的力量训练。有氧运动一般比较简单，跑步，骑车，游泳都可以。力量训练有一定的门槛，个人也最近正在学习一些入门训练方式。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/workout_plan.png" alt="力量训练计划"></p><h3 id="药物"><a href="#药物" class="headerlink" title="药物"></a>药物</h3><p>药物方面的研究也非常多，不过绝大多数都还在人体实验的早期。具体可以参考发表在 Nature 上的这篇 <a href="https://www.nature.com/articles/s41573-020-0067-7">The quest to slow ageing through drug discovery</a>，总结了各种相关研究，其中就包括了著名的二甲双胍，NMN 等。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/drugs_for_longevity.png" alt="长寿药物"></p><h3 id="细胞重编程"><a href="#细胞重编程" class="headerlink" title="细胞重编程"></a>细胞重编程</h3><p>前面也提到了基因表达是影响衰老最重要的因素，那么有没有手段来控制人体细胞的基因表达呢？著名的山中因子（Yamanaka Factors）给出了一种可能。山中伸弥团队发现的诱导方法是，通过慢病毒载体将 Oct4、Sox2、c-Myc、Klf4 四种转录因子基因转入成体细胞，将其转化为类似于胚胎干细胞的多能干细胞（iPS 细胞）。iPS 细胞与胚胎干细胞拥有相似的再生能力，理论上可以分化为成体的所有器官、组织，而这一点完美地对冲了由细胞衰减带来的人体衰老。听起来是不是非常的神奇？基于这些新技术也出现了很多主攻长寿领域的科技创新公司，如 <a href="https://www.lifebiosciences.com/">Life Biosciences</a>，<a href="https://altoslabs.com/">Altos Labs</a> 等，我们可以期待一下未来这些技术的普及应用。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/cell_reprogramming.png" alt="山中因子"></p><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h2><p>这里列出一些 Sinclair 自己的实践方式，如果想要采纳还是要结合自身的情况来看。有意思的是这集节目下有个热门留言是这个教授竟然已经 52 岁了，完全看不出来……所以你懂的。</p><ul><li>不吃早饭，午饭也吃的比较少，酸奶或者橄榄油，晚饭吃蔬菜为主，加鱼和虾，基本不吃牛排。不吃糖，甜品，面包。基本达到了 2 小时进食窗口的高阶 fasting 状态。他偶尔也会尝试一整天都不吃东西，但比较难坚持。</li><li>每天摄入 1 克的白藜芦醇（resveratrol），1 克的 NMN（进而会转化为 NAD，which is sirtuin 的“燃料”），还有二甲双胍（metformin）。其中锻炼的日子可能会跳过一些补充品。他并不吃复合维生素。</li><li>以蔬菜为主食的好处：富含各种营养，维生素；包含异种激素（Xenohormesis），植物基于“压力”之下产生的物质，对长寿有益。后者也可以通过槲皮素（quercetin）来做膳食补充。</li><li>一般会隔一天进行有氧运动和力量训练。有氧运动能提升 NAD 水平。</li><li>根据家族病史来决定一些药物摄入，如他 29 岁就开始服用降胆固醇药物。</li><li>对于人造甜味剂，教授认为总体来说是安全的。他偶尔也会喝健怡可乐。</li></ul><p>对于这一系列实践，Sinclair 教授都进行了 10 多年的自身实验，并使用各种手段来监控身体数据。通过监控数据可以推测出一个人的“生理年龄”如何（不是光看脸），他自己在上述实践下，生理年龄在持续下降，现在已经达到了 30 岁左右的水平（实际年龄 52 岁）。另外，他认为每个人的身体情况不一样，医院约定俗成的生理指标范围也不一定适合每个人。<strong>未来这种健康数据的实时监控与个性化诊断会成为主流</strong>。他举了一些例子：</p><ul><li>监控血糖水平 HbA1c，观察 fasting 的影响等。</li><li>监控炎症指标 CRP，与心脏病等各种疾病的诱发相关。</li><li>监控 LDL，通过药物等进行控制。膳食胆固醇对血液胆固醇几乎没有影响，不需要戒红肉，黄油等。</li><li>补充铁元素可能加速衰老。医学指标需要个性化，低铁元素含量并不一定导致贫血。</li></ul><p>还有一些影响寿命的负面因素：</p><ul><li>肥胖症会加速衰老。</li><li>吸烟，会破坏基因表达，加速衰老。</li><li>X 光检查同理，没有必要时，避免接触。</li></ul><p>展望一下 longevity 研究的未来，还是挺激动人心的。现代科学每一年能让我们的平均寿命延长 1/4 年，如果每一年能让我们的平均寿命延长超过 1 年，则达到了<strong>寿命“逃逸速度”</strong>（类比以 1000 英里每小时的速度往西飞行，太阳永远不会落下），实现了“永生”。著名的未来学家 Ray Kurzweil 预测，大约 12 年后（2034 年）就能实现，让我们拭目以待。</p><p>除了这集 podcast，也必须附上吴承霖大佬的万星项目 <a href="https://github.com/geekan/HowToLiveLonger">程序员延寿指南</a>。</p><h1 id="个人实践"><a href="#个人实践" class="headerlink" title="个人实践"></a>个人实践</h1><p>前面介绍的内容有点多，这篇文章篇幅也有些超了。最后来简单介绍下我个人目前采纳的一些行动和辅助工具。</p><p>睡眠方面暂时没有什么特别的措施，现在带娃基本上晚上睡眠质量也比较一般。只是会稍稍注意一下晚上 11 点后尽量不接触手机光源。早起接收光照这点，基本上就是早上遛狗或者开车通勤时间来接触，基本压力不大。如果比较讲究的同学，还可以下一个 <a href="https://mycircadianclock.org/">My Circadian Clock App</a> 来追踪一下生物钟，也是 Satchin Panda 等大佬参与开发的项目，值得信赖。</p><p>饮食方面，开始尝试 8 小时进食窗口的 fasting，目前感觉良好。中饭一般吃蔬菜为主的轻食，晚上就比较放飞自我，想吃啥吃啥。早上会看情况喝点盐水，茶或者 AG1 的补充剂。膳食补充剂目前基本只有复合维生素和 EPA 鱼油在使用，后面可以参考下 <a href="https://fastlifehacks.com/andrew-huberman-supplements-list/">Huberman 的“配方”</a> 增加一些。Huberman 自己也在节目中表示<strong>对白藜芦醇和 NMN 还在观望状态</strong>，我查了些资料发现有争议的地方还不少，所以我个人建议先采纳广受认可和使用的一些补充剂，如 EPA 鱼油，二甲双胍等。个人目前考虑的补充剂列表：</p><ul><li><a href="https://www.thorne.com/products/dp/basic-nutrients-2-day">基础维生素</a>，常规补充剂，也可以根据自己的饮食结构，生活习惯选择特定的营养物质补充。</li><li><a href="https://www.thorne.com/products/dp/super-epa-sp608nc">Omega-3 EPA</a>，常年销量靠前的补充剂，好处前面已经说了很多了。</li><li><a href="https://athleticgreens.com/en">AG1</a>，超火的小绿粉，各种植物提取物 + 各种维生素矿物会，Fridman 等大佬的节目里都有提到。个人买了一次，不过看一些其它评测貌似并不是很划得来。</li><li><a href="https://www.thorne.com/products/dp/betaine-hcl-pepsin-225-s">Betaine HCL &amp; Pepsin</a>，保护肠胃，促进吸收。</li><li><a href="https://www.thorne.com/products/dp/l-tyrosine">L-Tyrosine</a>，提升多巴胺，可能会买个尝尝鲜。</li><li><a href="https://zh.m.wikipedia.org/zh/%E4%BA%8C%E7%94%B2%E5%8F%8C%E8%83%8D">二甲双胍</a>，抗衰老“神药”，不过这个药的有效性和安全性还有争议，建议谨慎。</li><li><a href="https://www.thorne.com/products/dp/resveracel">ResveraCel</a>，白藜芦醇，NR 等抗衰老组合。效果同样有争议，尤其 NMN 这块更是各种产品鱼龙混杂无法分辨，谨慎购入。</li></ul><p>很多人都关心 fasting 可能引发胆结石，这里提供一些补充信息：</p><ul><li>从这篇 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1419405/">Bloch, H. M. 等人的论文</a> 来看，fasting 过程中胆汁的饱和度有一个先上升后下降的过程，<a href="https://youtu.be/2lGuXBwudKw">Dr. Berg 也以此做了解释</a>，认为 fasting 加生酮饮食（摄入脂肪）对胆囊健康反而是有益的。</li><li>从这篇 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1405175/">Sichieri, R. 等人的论文</a> 的结果来看，long overnight fasting 和节食会提升得胆结石的概率。不过减肥（减少脂肪）本身就会提升得胆结石的概率。</li><li>持续 24 小时以上的禁食相关的研究比较少（比较难执行），但从机理上来说长时间的禁食应该会增加得胆结石的概率。</li><li>饮食结构，自身状况对胆结石的形成也会有很大影响，例如高胆固醇，高胰岛素水平，高碳水饮食等。高纤维食物，健康的脂肪摄入，有助于降低得胆结石的概率。</li></ul><p>总体看下来，我个人感觉这块的实验上没有一个定论（就跟 <a href="https://www.coffeeandhealth.org/factsheet/gallstones-factsheet">咖啡是否会引发胆结石</a> 一样），但应该不是一个概率很大的问题，起码 Huberman 教授跟这个领域的另一位权威 Satchin Panda 教授都没有提到这块的问题。理想情况是执行 fasting 时持续对你的身体状况做医学指标的跟踪。其它就看个人选择了 :)</p><p>工作，学习，专注方面，主要看自律了。这方面我总体控制还可以，在了解了多巴胺的工作原理之后就更加有自信了，主要靠各种软件的专注模式来近似执行番茄时钟法，此外也采用了升降桌，大概有 30% 的时间站立办公。工作间歇会尝试一下 Yoga Nidra。此外晚上学习时段会用 iPad 的 Books 来记录一下阅读时间，基本上每天保持 30 分钟以上，持续坚持。后面考虑试试工作时喝马黛茶，以及夏天开始尝试冷水澡。</p><p>运动方面是这一年来改观最大的一项，依靠小米手环 PAI 指数功能的督促，基本上做到了每周平均 3 次的跑步或者羽毛球活动，持续把 PAI 值保持在 200 左右。总体来说对于精神状态的改观还是很大的，肚子上的脂肪也减少了很多。唯一比较困扰的是一般下班后运动都要 9，10 点开始了，结束后会离入睡的时间比较近，有时候会对睡眠质量有所影响。</p><p>最后，Huberman 教授的 podcast 中还有很多其它内容，比如习惯养成，健身增肌，应对恐惧与创伤，情绪管理等，感兴趣的朋友可以进一步挖掘。本文以实验事实与原理假设的陈述为主，以上所有的行动方案都需要在咨询医师，专业人员的条件下，结合自身情况执行，注意自身安全，本人与 Huberman 都不负相关后果责任。</p><p>备注：这篇文章也同时发布到了 <a href="https://github.com/zijie0/HumanSystemOptimization">Github</a>，欢迎大家 Star 并提出宝贵建议，谢谢！如果你对我的其它作品感兴趣，也欢迎搜索关注公众号：RandomGenerator。</p><p>转载：<a href="https://github.com/zijie0/HumanSystemOptimization">https://github.com/zijie0/HumanSystemOptimization</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UPDATE: 鉴于文章比较长，很多同学没有耐心读完，后续也分享录制了一个 &lt;a href=&quot;https://www.bilibili.com/video/BV1EW4y1R7yi/&quot;&gt;视频版&lt;/a&gt;，基本涵盖了文章里的大部分内容。&lt;/p&gt;
&lt;p&gt;另外在健康生活实践方面，也</summary>
      
    
    
    
    <category term="Human" scheme="https://kalyan-zitiu.github.io/categories/Human/"/>
    
    <category term="daily diet" scheme="https://kalyan-zitiu.github.io/categories/Human/daily-diet/"/>
    
    
    <category term="optimization" scheme="https://kalyan-zitiu.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>AWS云计算基础</title>
    <link href="https://kalyan-zitiu.github.io/2023/07/31/AWS%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
    <id>https://kalyan-zitiu.github.io/2023/07/31/AWS%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-31T14:00:00.000Z</published>
    <updated>2023-08-12T08:12:51.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AWS云计算理论基础"><a href="#AWS云计算理论基础" class="headerlink" title="AWS云计算理论基础"></a>AWS云计算理论基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Amazon Web Services </li><li>可以理解成一群人买了一个空间，里面堆了一堆硬件然后租给你用，和网吧的原理是一样的。</li><li>AWS云计算是指亚马逊网络服务（Amazon Web Services）提供的一系列云计算服务。它允许个人、企业和组织通过互联网访问和使用IT资源</li></ul><iframe width="560" height="315" src="https://www.youtube.com/embed/a9__D53WsUs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>分别能够提供高级联网，数据分析，数据库，AWS游戏，机器学习，媒体服务，安全性，无服务器，存储等主要服务<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230807172336657.png" alt="image-20230807172336657"></li></ul><h3 id="云计算类型"><a href="#云计算类型" class="headerlink" title="云计算类型"></a>云计算类型</h3><ul><li>每种类型的云服务和部署方法都提供不同级别大的控制力，灵活性和管理功能。理解基础设施即服务和软件即服务之间的差异，以及可以使用的部署策略，有助于根据需求选用合适的服务组合。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230812141634839.png" alt="image-20230812141634839"></p><h4 id="云计算模型"><a href="#云计算模型" class="headerlink" title="云计算模型"></a>云计算模型</h4><h5 id="基础设施即服务（laaS）"><a href="#基础设施即服务（laaS）" class="headerlink" title="基础设施即服务（laaS）"></a>基础设施即服务（laaS）</h5><ul><li>提供基本的计算，存储和网络资源，用户可以在这些资源上构建和管理自己的应用程序。用户负责操作系统及以上的管理和维护，如虚拟机，存储实例等</li></ul><h5 id="平台即服务（PaaS）"><a href="#平台即服务（PaaS）" class="headerlink" title="平台即服务（PaaS）"></a>平台即服务（PaaS）</h5><ul><li>在laaS的基础上，PaaS还提供开发框架，数据库，中间件等。用户可以专注于应用程序开发，而不必关心底层基础设施的管理。</li></ul><h5 id="软件即服务（SaaS）"><a href="#软件即服务（SaaS）" class="headerlink" title="软件即服务（SaaS）"></a>软件即服务（SaaS）</h5><ul><li>提供完整的应用程序作为服务，用户无需安装，维护或管理应用程序本身。常见的有电子邮件，办公套件，客户关系，管理系统等。</li></ul><h5 id="函数即服务（FaaS）"><a href="#函数即服务（FaaS）" class="headerlink" title="函数即服务（FaaS）"></a>函数即服务（FaaS）</h5><ul><li>也称为无服务器计算，它允许开发人员编写单个函数（或功能块），并在需要时候自动触发执行，无需关心底层的服务器和基础设施。</li></ul><h5 id="容器即服务（CaaS）"><a href="#容器即服务（CaaS）" class="headerlink" title="容器即服务（CaaS）"></a>容器即服务（CaaS）</h5><ul><li>提供容器管理和编排的服务，用户可以将应用程序打包成容器，并在云平台上进行部署，扩展和管理</li></ul><h5 id="多云和混合云"><a href="#多云和混合云" class="headerlink" title="多云和混合云"></a>多云和混合云</h5><ul><li>多云指的是将应用程序和数据分布在等多个不同的云平台上，而混合云则是将云计算与传统本地基础设施相结合，使得用户可以在不同环境中灵活地部署和管理应用程序。</li></ul><h4 id="AWS核心服务"><a href="#AWS核心服务" class="headerlink" title="AWS核心服务"></a>AWS核心服务</h4><h5 id="计算服务："><a href="#计算服务：" class="headerlink" title="计算服务："></a>计算服务：</h5><p>Amazon EC2 (Elastic Compute Cloud)：提供可扩展的虚拟机实例，用于运行各种应用程序。</p><p>Amazon ECS (Elastic Container Service)：用于管理和编排Docker容器的服务。</p><p>AWS Lambda：无服务器计算服务，允许您在需要时运行代码，无需管理服务器。</p><p>Amazon Lightsail：为简单应用提供的轻量级计算实例，适用于初学者和小型项目。</p><h5 id="存储服务："><a href="#存储服务：" class="headerlink" title="存储服务："></a>存储服务：</h5><p>Amazon S3 (Simple Storage Service)：对象存储服务，用于存储和检索任意数量的数据。</p><p>Amazon EBS (Elastic Block Store)：提供持久性块存储卷，可附加到EC2实例。</p><p>Amazon Glacier：长期数据存储服务，适用于需要稳定存储而不需要频繁访问的数据。</p><p>Amazon EFS (Elastic File System)：提供可扩展的文件存储，可以在多个EC2实例之间共享。</p><h5 id="数据库服务："><a href="#数据库服务：" class="headerlink" title="数据库服务："></a>数据库服务：</h5><p>Amazon RDS (Relational Database Service)：托管的关系型数据库服务，支持多种数据库引擎。</p><p>Amazon DynamoDB：托管的NoSQL数据库服务，适用于高度可扩展和低延迟的应用程序。</p><p>Amazon Aurora：高性能、关系型数据库引擎，兼容MySQL和PostgreSQL。</p><p>Amazon Redshift：用于数据仓库和分析的大规模数据存储和处理服务。</p><h5 id="网络和内容分发："><a href="#网络和内容分发：" class="headerlink" title="网络和内容分发："></a>网络和内容分发：</h5><p>Amazon VPC (Virtual Private Cloud)：创建私有网络，允许您在AWS中隔离和配置资源。</p><p>Amazon CloudFront：内容分发网络，加速向全球用户分发静态和动态内容。</p><p>Amazon Route 53：可扩展的域名系统（DNS）服务，用于管理域名和路由流量。</p><h5 id="安全与身份管理："><a href="#安全与身份管理：" class="headerlink" title="安全与身份管理："></a>安全与身份管理：</h5><p>AWS IAM (Identity and Access Management)：身份和访问管理服务，用于管理用户、权限和资源访问。</p><p>Amazon Cognito：用于身份验证、授权和用户管理的服务。</p><h5 id="分析与大数据："><a href="#分析与大数据：" class="headerlink" title="分析与大数据："></a>分析与大数据：</h5><p>Amazon EMR (Elastic MapReduce)：大数据处理服务，支持Apache Hadoop、Spark等。</p><p>Amazon Athena：无服务器查询服务，用于分析S3中的数据。</p><p>Amazon Redshift Spectrum：扩展Redshift数据仓库，可以直接查询S3中的数据。</p><h5 id="人工智能与机器学习："><a href="#人工智能与机器学习：" class="headerlink" title="人工智能与机器学习："></a>人工智能与机器学习：</h5><p>Amazon SageMaker：用于构建、培训和部署机器学习模型的托管服务。</p><p>Amazon Rekognition：图像和视频分析服务，用于识别对象、人脸等。</p><p>Amazon Polly：文本转语音服务，可将文本转换为自然语音。</p><p>Amazon Lex：构建聊天机器人和语音交互应用的服务。</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><h5 id="AWS-CodeCommit："><a href="#AWS-CodeCommit：" class="headerlink" title="AWS CodeCommit："></a>AWS CodeCommit：</h5><p>提供托管的Git存储库，用于团队协作和版本控制。<br>可以将代码存储在私有存储库中，并管理代码的变更历史。</p><h5 id="AWS-CodeBuild："><a href="#AWS-CodeBuild：" class="headerlink" title="AWS CodeBuild："></a>AWS CodeBuild：</h5><p>托管的持续集成服务，用于构建、测试和打包应用程序。<br>自动执行构建过程，生成可部署的构建产物。</p><h5 id="AWS-CodeDeploy："><a href="#AWS-CodeDeploy：" class="headerlink" title="AWS CodeDeploy："></a>AWS CodeDeploy：</h5><p>自动化部署服务，用于将应用程序部署到不同的计算实例。<br>支持各种部署策略，如无停机部署、蓝绿部署等。</p><h5 id="AWS-CodePipeline："><a href="#AWS-CodePipeline：" class="headerlink" title="AWS CodePipeline："></a>AWS CodePipeline：</h5><p>托管的持续交付服务，用于创建、管理和自动化整个交付流程。<br>可以连接多个代码存储库、构建和部署服务，形成完整的交付流水线。</p><h5 id="AWS-CodeStar："><a href="#AWS-CodeStar：" class="headerlink" title="AWS CodeStar："></a>AWS CodeStar：</h5><p>为团队提供一站式的开发项目管理和协作工具。<br>集成了多个开发者工具，帮助您快速搭建、部署和管理应用。</p><h5 id="AWS-Cloud9："><a href="#AWS-Cloud9：" class="headerlink" title="AWS Cloud9："></a>AWS Cloud9：</h5><p>基于浏览器的集成开发环境（IDE），允许团队协作开发代码。<br>可以连接到远程服务器，编写、测试和调试代码。</p><h5 id="AWS-X-Ray："><a href="#AWS-X-Ray：" class="headerlink" title="AWS X-Ray："></a>AWS X-Ray：</h5><p>分布式应用程序性能分析服务，可帮助您识别和调试性能问题。<br>可以跟踪请求在不同服务之间的流动，并生成性能图表。</p><h5 id="AWS-Command-Line-Interface-CLI-："><a href="#AWS-Command-Line-Interface-CLI-：" class="headerlink" title="AWS Command Line Interface (CLI)："></a>AWS Command Line Interface (CLI)：</h5><p>命令行工具，使您能够通过命令管理AWS资源。<br>提供了丰富的命令和选项，用于自动化和管理任务。</p><h5 id="AWS-SAM-Serverless-Application-Model-："><a href="#AWS-SAM-Serverless-Application-Model-：" class="headerlink" title="AWS SAM (Serverless Application Model)："></a>AWS SAM (Serverless Application Model)：</h5><p>一种用于构建、测试和部署无服务器应用程序的开发框架。<br>基于CloudFormation，简化了无服务器应用程序的定义和部署。</p><h5 id="AWS-Amplify："><a href="#AWS-Amplify：" class="headerlink" title="AWS Amplify："></a>AWS Amplify：</h5><p>用于构建现代Web和移动应用程序的开发平台。<br>提供前端框架、托管、认证等功能，支持快速开发和部署。</p><h5 id="AWS的IDE和IDE工具包"><a href="#AWS的IDE和IDE工具包" class="headerlink" title="AWS的IDE和IDE工具包"></a>AWS的IDE和IDE工具包</h5><ul><li>AWS支持流行的集成开发环境（IDE）和IDE工具包提供支持，因此你可以在你的首选环境中在AWS上编写，调试和部署代码。</li></ul><h4 id="基础设施即代码（IaC）"><a href="#基础设施即代码（IaC）" class="headerlink" title="基础设施即代码（IaC）"></a>基础设施即代码（IaC）</h4><ul><li>AWS提供服务能够以编程，描述性和声明性的方式创建，部署和维护基础设施</li></ul><h5 id="AWS-CDK"><a href="#AWS-CDK" class="headerlink" title="AWS CDK"></a>AWS CDK</h5><ul><li><p>AWS云开发套件（AWS CDK）是一个软件开发框架，用于在代码中的定义云基础设施并通过AWS CloudFormation进行配置。CDK支持类似于TypeScript，JavaScript，Python，Java，C#/.Net和Go</p></li><li><p>配置云应用程序可能具有挑战性，需要编写自定义脚本，维护模板或学习特定于领域的语言。提供才成为构造的高级组件，可以使用经过验证的默认值预配置云资源，以便你可以轻松构建云应用程序。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230812151513189.png" alt="image-20230812151513189"></p><h4 id="AWS云形成"><a href="#AWS云形成" class="headerlink" title="AWS云形成"></a>AWS云形成</h4><ul><li>建模和设置AWS资源可能非常耗时，这就是AWS CloudFormation可以提供帮助的地方。CloudFormation帮助你建模和设置AWS资源，以便你可以花更少的时间管理资源，而将更多的时间专注于你的应用程序。创建模板后，CloudFormation会我为你预置这些资源。无需单独创建和配置AWS资源并且弄清楚哪些资源依赖哪些资源。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230812152841112.png" alt="image-20230812152841112"></p><h4 id="架构完善的基础设施"><a href="#架构完善的基础设施" class="headerlink" title="架构完善的基础设施"></a>架构完善的基础设施</h4><h5 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h5><ul><li>AWS Well-Architected可以帮助云架构和开发人员为各种应用程序和工作负载构建安全，高性能，弹性且高效的基础设施。AWS Well-Architected围绕六大支柱构建。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AWS云计算理论基础&quot;&gt;&lt;a href=&quot;#AWS云计算理论基础&quot; class=&quot;headerlink&quot; title=&quot;AWS云计算理论基础&quot;&gt;&lt;/a&gt;AWS云计算理论基础&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Cloud Konwleage" scheme="https://kalyan-zitiu.github.io/categories/Cloud-Konwleage/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Cloud-Konwleage/Study-Note/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>OceanBase</title>
    <link href="https://kalyan-zitiu.github.io/2023/07/15/OceanBase/"/>
    <id>https://kalyan-zitiu.github.io/2023/07/15/OceanBase/</id>
    <published>2023-07-15T14:00:00.000Z</published>
    <updated>2023-09-11T03:08:52.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OceanBase"><a href="#OceanBase" class="headerlink" title="OceanBase"></a>OceanBase</h1><h2 id="传统集中式数据库面临的挑战"><a href="#传统集中式数据库面临的挑战" class="headerlink" title="传统集中式数据库面临的挑战"></a>传统集中式数据库面临的挑战</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230718091134287.png" alt="image-20230718091134287"></p><ul><li>可扩展性方面：传统集中式数据库的扩展性有限，当数据量增加或者并发访问量增大时，集中式数据库可能无法提供足够的性能和吞吐量</li><li>单点故障：由于集中式数据库只有一个中心节点，一旦该节点发生故障，整个系统将无法正常工作。这种单点故障可能导致系统可用性和数据的丢失</li><li>单点上限：在一个数据库系统中，单个节点能够处理的最大负载或并发连接数。通常由硬件资源以及数据库软件本身的性能限制所决定的，</li><li>数据库安全：传统型集中式数据库存储所有数据的中心节点成为攻击者的目标，一旦该节点被入侵或者遭受到其他安全威胁，整个数据库的数据会面临泄露和篡改的风险</li><li>数据一致性：由于集中式数据库的数据存储都在一个节点上，当多个用户同时对数据库进行操作时，可能会出现数据一致性的问题。例如，当一个用户在修改某个数据时，另一个用户可能正在读取该数据，导致读取的数据不一致</li><li>高延迟：远程用户在访问数据库时，可能会出现高延迟，这对于要低延迟响应的应用场景是不可接受的。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230718094411164.png" alt="image-20230718094411164"></p><h3 id="数据库分布规则"><a href="#数据库分布规则" class="headerlink" title="数据库分布规则"></a>数据库分布规则</h3><ul><li>是指分布式数据库系统中，决定怎么将数据分散到不同节点上，实现分布式存储和访问。</li></ul><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul><li>将数据划分成多个片段，每个片段存储在不同的节点上。分片规则可以基于数据的某个属性进行划分，例如按照用户ID进行哈希分片或按照地理位置进行范围分片<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4></li><li>将数据复制到多个节点上以提高数据的可用性和容错性。复制规则可以确定数据的副本数量，复制的同步方式以及副本的位置选择策略<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4></li><li>根据查询或操作的条件将请求路由到正确的节点上。路由规则可以基于数据的分片键或其他属性进行路由决策的，以确保操作在正确的节点上执行。<h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4></li><li>在节点的增加，减少或数据重平衡时，如何将数据从一个节点迁移到另一个节点上，以保持数据的均衡和一致性。<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3></li><li>使用通用数据库，可以实现数据库线性的扩容</li><li>数据库是单点数据库，数据库之间没有联系，不知道其他数据库的存在，依靠中间件完成需要跨库的事务</li><li>数据库中间件连接各个数据库，实现分库分表</li></ul><p>需要注意的是单中间件整合各个数据库时候，倘若该数据库服务器时间戳不一致的时候可能会导致数据不一致的问题，可能在数据同步阶段的时候不同服务器操作时间戳或早或晚可能会被视为未来操作或者视为过时操作会丢失数据。</p><p>解决上面的问题，能够使用专门统一数据库服务器的时间的服务器或者建立时间戳校验机制，或者定期校准时间戳。</p><h4 id="非短板"><a href="#非短板" class="headerlink" title="非短板"></a>非短板</h4><ul><li>能过通过线性扩展来达到分库分表，可以快速实现数据库的水平扩展；</li><li>技术成本较低，不需要改造核心数据库引擎，或者只需要做很少的改造；</li></ul><h4 id="短板"><a href="#短板" class="headerlink" title="短板"></a>短板</h4><ul><li>跨库分布式事物，数据库核心引擎没有分布式能力，只能通过中间件来完成分布式处理，但中间件很难做到RPO = 0，因此在遇到异常和故障时无法100%保证分布式事务的ACID能力</li><li>全局一致性，由于多个数据库服务器的时间戳不一致，因此很难保证多个库之间数据版本号的全局性一致</li><li>负载均衡，在扩容和缩容时候，底层数据库引擎无法在线调整数据分布规则，因此需要暂停业务并重新导数据，对业务和运维挑战很大；</li><li>跨库复杂SQL，跨库的复杂SQL运算，只能要求中间件能够完成，而中间件不具备分布式并行计算能力，最终会限制应用对SQL的使用，产生业务侵入性。</li></ul><h2 id="原生的分布式关系型数据库架构"><a href="#原生的分布式关系型数据库架构" class="headerlink" title="原生的分布式关系型数据库架构"></a>原生的分布式关系型数据库架构</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910195837934.png" alt="image-20230910195837934"></p><ul><li>一种新型的数据库架构，能更好的处理大规模数据，并具有高并发，高可用，高扩展等特点。</li></ul><h3 id="数据高可靠，服务高可用"><a href="#数据高可靠，服务高可用" class="headerlink" title="数据高可靠，服务高可用"></a>数据高可靠，服务高可用</h3><ul><li>多副本一致性Paxos，个别节点发生故障时，保证数据零丢失和服务快速恢复。</li></ul><h4 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h4><ul><li>一种解决分布式系统中的一致性问题的协议，保证系统中多个副本在面对网络延迟，分区，信息丢失等问题时。</li></ul><h5 id="Prepare阶段"><a href="#Prepare阶段" class="headerlink" title="Prepare阶段"></a>Prepare阶段</h5><ol><li>Paxos提议者会向一组接受者发送一个提议，改提议包含一个提议编号和提议内容。</li><li>接受者会在接收到提议后，如果该提议的编号是其所接收过的所有提议中最大的，那么它就会接受这个提议，并将自己之前接受的最大编号的提议回复给提议者。</li></ol><h5 id="Accept阶段"><a href="#Accept阶段" class="headerlink" title="Accept阶段"></a>Accept阶段</h5><ol><li>议者会根据Prepare阶段的回复，选择一个提议内容，然后再次向接受者发送提议，该提议包含了在Prepare阶段中提出的提议编号和选定的提议内容。</li><li>接受者在接收到提议后，如果该提议的编号仍然是其所接收过的所有提议中最大的，那么它就会接受这个提议。</li></ol><h3 id="线性扩容"><a href="#线性扩容" class="headerlink" title="线性扩容"></a>线性扩容</h3><ul><li>指随着硬件资源的增加，数据库的处理能力或存储能力能够线性增长。</li><li>线性扩容的好处是可以让系统在面对业务增长时，能够通过简单地扩展硬件资源来满足业务需求，而无需对系统的架构进行大的修改。</li><li>实现线性扩容，需要数据库系统具有良好的分布式架构，包括数据分片、负载均衡、分布式事务处理等能力。同时，也需要数据库系统能够有效地管理和调度各个节点的资源，以确保资源的充分利用。</li></ul><h3 id="全局一致性"><a href="#全局一致性" class="headerlink" title="全局一致性"></a>全局一致性</h3><ul><li>支持分布式事务，确保全局一致性，无需使用高端小型机和存储</li></ul><h3 id="对业务透明"><a href="#对业务透明" class="headerlink" title="对业务透明"></a>对业务透明</h3><ul><li>可以像使用单点数据库一样使用分布式数据库，业务迁移改造成本低。</li></ul><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><h5 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h5><ul><li>范围分片（按照某个字段）</li><li>哈希分片（通过哈希函数将数据均匀分布到各个节点）</li><li>列表分片（根据列表中定义的值将数据分布到各个节点）<h5 id="分片键"><a href="#分片键" class="headerlink" title="分片键"></a>分片键</h5></li><li>分片键是确定数据分布到哪个分片的关键。通常，分片键应该选择能够使数据均匀分布到各个分片的字段<h5 id="数据均匀分布"><a href="#数据均匀分布" class="headerlink" title="数据均匀分布"></a>数据均匀分布</h5></li><li>为了提高系统的性能和可用性，需要尽可能地使数据均匀分布到各个分片。如果数据在分片之间的分布不均匀，可能会导致某些节点过载，而其他节点闲置，这被称为”数据倾斜”<h5 id="数据迁移-1"><a href="#数据迁移-1" class="headerlink" title="数据迁移"></a>数据迁移</h5></li><li>当添加或删除节点时，需要重新分配数据，这被称为数据迁移。数据迁移是一个复杂的过程，需要在保证数据完整性和服务可用性的同时进行。<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4></li><li>支持分布式事务，保证数据的一致性，通常通过两阶段提交（2PC）或 三阶段提交（3PC）等协议来实现。<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4></li><li>为了提高数据的可用性和容错性，原生分布式关系型数据库会将数据复制到多个节点。如果某个节点发生故障，可以从其他节点获取数据。<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4></li><li>原生分布式关系型数据库需要支持负载均衡，以保证系统的性能。这通常通过分布式哈希、一致性哈希等算法来实现。<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4></li><li>在分布式系统中，节点故障是常见的问题。原生分布式关系型数据库需要支持故障恢复，以保证系统的持续运行。</li></ul><h4 id="弹性扩展"><a href="#弹性扩展" class="headerlink" title="弹性扩展"></a>弹性扩展</h4><ul><li>需要支持弹性扩展，即可以根据需要动态增加或减少节点。</li></ul><h2 id="OceanBase-1"><a href="#OceanBase-1" class="headerlink" title="OceanBase"></a>OceanBase</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910205750757.png" alt="image-20230910205750757"></p><h4 id="多种部署方式"><a href="#多种部署方式" class="headerlink" title="多种部署方式"></a>多种部署方式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910205925780.png" alt="image-20230910205925780"><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910210114199.png" alt="image-20230910210114199"> </p><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910211314030.png" alt="image-20230910211314030"></p><ul><li><p>OceanBase是蚂蚁金服完全自主研发的通用的分布式关系型数据库。OceanBase以集群的形式存在，至少三个节点分布在三个区域（Zone），每个节点上运行一个单进程程序，进程名observer。每个observer进程都包含连个模块：SQL引擎和存储引擎，所以每个节点地位基本是平等的。稍微特殊的是每个Zone里会有一个节点的observer内还会运行总控服务，三个总控服务内容一样，角色上会有一个Leader和Follower，只有Leader提供服务。</p></li><li><p>OceanBase集群还支持多租户管理</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230719094326659.png" alt="image-20230719094326659"></p></li></ul><h4 id="RootService总控服务（RS）"><a href="#RootService总控服务（RS）" class="headerlink" title="RootService总控服务（RS）"></a>RootService总控服务（RS）</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910215101839.png" alt="image-20230910215101839"></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>OceanBase的数据存在每个节点上，observer通过分区管理数据。分区是数据的子集，一个非分区就是一个分区，一个分区表包含多个分区，一个分区不能跨节点，分区表的不同分区可以跨节点。所以分区表可以做水平跨节点扩展。分区是数据的子集，是高可用的最小粒度。分析OceanBase是否丢数据，只要分析分区的数据写是否会丢。</p><h4 id="读写模式"><a href="#读写模式" class="headerlink" title="读写模式"></a>读写模式</h4><ul><li>OceanBase在初次读入一行数据时会将该行所在块读入到内存的Block Cache中，后面修改的时候并不是直接修改这个block，而是在另外一块内存中分配少量空间记录这笔修改，并且只记录变化部分，这称为增量数据（Memtable）。前面在Block Cache里的数据称为基线数据。同一记录如果反复修改多次，多个增量会议链表形式挂在该记录下</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230719095139281.png" alt="image-20230719095139281"></p><p>OceanBase的这种方式能够比传统数据库产生的脏块要小得多，所以OceanBase会把这些Memtable一直保存在缓存中或者推迟写入磁盘。当最后落盘的时候，Memtable会冻结成历史版本，然后和对应的基线数据在内存中进行合并，生成SSTable格式写入磁盘数据文件。合并的操作对资源有较大的影响，所以会在尽可能推迟合并操作到低峰期。若专门用户Memtable的内存利用率达到了一定的阈值，它会将Memtable直接以SSTable格式临时写入磁盘中。这就是转储的操作，相对对资源消耗比较小。</p><h4 id="多个资源池（Resource-Pool）"><a href="#多个资源池（Resource-Pool）" class="headerlink" title="多个资源池（Resource Pool）"></a>多个资源池（Resource Pool）</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230910215905310.png" alt="image-20230910215905310"></p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>OceanBase的Memtable一天只落盘一次，但是记录Memtable的时候OceanBase会遵循WAL机制，生成相关的事务日志保存在日志缓冲区里。和Oracle不同的是OceanBase的这些事务日志在事务提交之前会一直在日志缓冲区里，若节点宕机，没提交的事务日志对业务来说也没有数据丢失，当提交后，OceanBase会做事务日志的持久化动作。所以可能对于一些大事务会占用不少的内存空间。而且OceanBase是没有Undo，假设业务事务回滚了，它只会有一些清理逻辑。</p><h4 id="宕机恢复"><a href="#宕机恢复" class="headerlink" title="宕机恢复"></a>宕机恢复</h4><p>OceanBase的节点宕机后，节点上部分分区的访问会受影响，但OceanBase集群会很快恢复这些分区访问，这是OceanBase的可用性特性。和传统数据库一样，宕机后恢复，它会读取事务日志，重做事务，但在不同在于observer不需要再次读入基线数据，只需要在事务日志在增量内存中构建相关分区的Memtable。相关分区被业务读取时，对应的基线数据所在块才会被再次读入Block Cache中。</p><h4 id="副本复制"><a href="#副本复制" class="headerlink" title="副本复制"></a>副本复制</h4><ul><li>Oracle一样，光支持WAL是不足以保障数据安全，OceanBase还要设法保障事务日志的可靠性。除了使用DirectIO持久化到本节点磁盘外，也需要持久化到其他节点上。</li><li>跟传统关系数据库主备两副本架构不一样，OceanBase选择了多副本架构，是如果副本数是偶数，会有传统双机房容灾的脑裂问题。脑裂问题的本质就是全体成员在局部通信中断故障时无法就哪个节点接管服务作出一致性决议。成员数是奇数，才有可能形成多数派。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230719104329304.png" alt="image-20230719104329304"></p><p>副本就是分区的别称，一个分区有三份数据，每份是一个副本。副本的内容除了数据还有事务日志。在这里我们只关心事务日志部分。三个副本在角色上是1个Leader（类似于主副本）2个Follower（类似于备副本）。只有Leader副本才会对外提供读写服务，这样就规避了单个分区多个节点同时写入的问题。但是注意每个分区只能单点写入跟OceanBase集群多个节点写入并不矛盾。因为Leader副本是可以分散到所有节点（OBServer）上。跟传统关系数据库一样，OceanBase维持三副本数据的同步是靠传输事务日志（Redo）机制实现的。</p><p>所以，为了保障事务日志的可靠性，OceanBase要把Leader副本上的事务日志持久化到本机和其他两个Follower副本上。宏观上表现就是可能存在各个节点彼此互相传输事务日志。这个跟MySQL的Master-Master架构里双向复制并不完全一样。 我们重点看看OceanBase如何认定事务日志可靠了。</p><p>使用Paxos协议，各个副本成员就事务日志持久化到磁盘进行表决。只要一半以上成员投票OK，Leader副本上的事务就可以继续提交了，Follower副本才开始应用Redo。这个协议是强制性约束，不够一半成员就会表决失败，Leader副本上事务就会回滚。这里没有类似Oracle或者MySQL的同步降级的做法。此外，剩余少数派成员最终也是要表决成功的，否则就是一个异常状态。</p><p>OceanBase会尽力自动去保障三副本成员状态的正常，否则就会告警等运维处理。这点也是强制性的约束，也是跟传统关系数据库不一样的地方。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h4 id="分布性"><a href="#分布性" class="headerlink" title="分布性"></a>分布性</h4><ul><li>集群形式部署，支持水平扩展</li><li>在线扩容/缩容，自动负载均衡</li><li>跨机房/城市部署，容灾/多活</li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul><li>基于Paxos协议，强一致性同步</li><li>少数副本故障，数据不丢，服务自动回复</li></ul><h4 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h4><ul><li>按需分配实例，即时创建和销毁</li><li>在线扩容/缩容</li><li>租户之间资源隔离</li></ul><h4 id="高兼容"><a href="#高兼容" class="headerlink" title="高兼容"></a>高兼容</h4><ul><li>Oracle/MySQL两种兼容模式</li><li>数据平滑迁移</li><li>原生的SQL和事物引擎</li></ul><h2 id="集群技术架构"><a href="#集群技术架构" class="headerlink" title="集群技术架构"></a>集群技术架构</h2><h3 id="Paxos协议与负载均衡"><a href="#Paxos协议与负载均衡" class="headerlink" title="Paxos协议与负载均衡"></a>Paxos协议与负载均衡</h3><h4 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h4><ul><li>当一个表很大，能够水平拆分为若干分区，每个分区包含表的若干记录。根据行数据到分区的映射关系不同，分为hash分区，List分区，range分区</li><li>每个分区还能过通过不同维度再分，称为二级分区</li><li>分区是OceanBase数据架构的基本单元，传统数据库的分区表在分布式系统上实现</li></ul><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><ul><li>为数据安全和高可用的数据服务，分区的数据在物理层面上会存储多份，每一份叫做分区的一个副本</li><li>副本根据负载和特定的策略，由系统自动调度分散在多个Server上。副本支持迁移，复制，增删，类型转换等管理操作</li></ul><h5 id="副本构成"><a href="#副本构成" class="headerlink" title="副本构成"></a>副本构成</h5><p>副本构成由记录事务的日志，存储再内存的Memtable，磁盘上的静态数据SSTable</p><h5 id="副本类型"><a href="#副本类型" class="headerlink" title="副本类型"></a>副本类型</h5><ul><li>一个分区在一个zone中最多由一个全功能或日志型副本</li><li>只读型副本在同一个zone可以有多个<h6 id="全能型副本"><a href="#全能型副本" class="headerlink" title="全能型副本"></a>全能型副本</h6>拥有事务日志，MemTable和SSTable等全部完整的数据和功能，它可以随时快速切换为leader对外提供服务。<h6 id="日志型副本"><a href="#日志型副本" class="headerlink" title="日志型副本"></a>日志型副本</h6>只包含日志的副本，没有Memtable和SSTable。它参与日志投票并对外提供日志服务，可以参与其他副本的恢复，但子集不能变为主提供数据库服务。因为日志型副本所消耗的物理资源更少，它可以有效降低最后副本机器的成本，降低集群的总体成本<h6 id="只读型副本"><a href="#只读型副本" class="headerlink" title="只读型副本"></a>只读型副本</h6>包含完整的日志，MemTable和SSTable等，但是它的日志比较特殊。它不作为paxos成员参与日志的投票，而是作为一个观察者实时追赶paxos成员的日志，并在本地回放。可以在业务读取数据的一致性要求不高的时候，提供只读服务。因其不加入paxos成员组，又不会造成投票成员增加导致事务提交延时的增加</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230721195400362.png" alt="image-20230721195400362"></p><p>如上图，按照ID分为三个hash分区，每个分区再按照交易时间分为四个二级的range分区，然后会生成多份副本，副本数量会因集群数量而变化，一般来说会每个zone内只会包含一个副本</p><h4 id="多副本一致性协议"><a href="#多副本一致性协议" class="headerlink" title="多副本一致性协议"></a>多副本一致性协议</h4><h5 id="以分区为单位组建Paxos协议组"><a href="#以分区为单位组建Paxos协议组" class="headerlink" title="以分区为单位组建Paxos协议组"></a>以分区为单位组建Paxos协议组</h5><p>每个分区都有多份副本（Replica），自动建立Paxos组，在分区级用多副本保证数据可靠性和服务高可用，数据管理更加灵活方便</p><h5 id="自动选举主副本"><a href="#自动选举主副本" class="headerlink" title="自动选举主副本"></a>自动选举主副本</h5><p>OB自动生成多份副本，多副本自动选举主副本，主副本提供服务</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230721224526185.png" alt="image-20230721224526185"></p><h4 id="自动负载均衡与智能路由"><a href="#自动负载均衡与智能路由" class="headerlink" title="自动负载均衡与智能路由"></a>自动负载均衡与智能路由</h4><h5 id="自动负载均衡"><a href="#自动负载均衡" class="headerlink" title="自动负载均衡"></a>自动负载均衡</h5><p>主副本均匀打散到各个服务器中，使得各个服务器都能承载业务流量</p><h5 id="OB-Server相互独立"><a href="#OB-Server相互独立" class="headerlink" title="OB Server相互独立"></a>OB Server相互独立</h5><p>每台OB Server均可以独立执行SQL，如果应用需要访问的数据不同机器上，OB Server自动将请求路由至数据所在机器，对业务完全透明。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230721225131923.png" alt="image-20230721225131923"></p><h4 id="多副本同步Redo-Log-确保数据持久化"><a href="#多副本同步Redo-Log-确保数据持久化" class="headerlink" title="多副本同步Redo Log 确保数据持久化"></a>多副本同步Redo Log 确保数据持久化</h4><ul><li>Paxos组成员通过Redo-Log的多数派强同步确保数据的持久化</li><li>Leader无需等待所有Follower的反馈，多数派完成同步即可向应用反馈成功</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724153630019.png" alt="image-20230724153630019"></p><ol><li>应用写数据到P2分区。Zone2-OB Server1的P2为主副本（Leader），承接业务需求。</li><li>将Redo-Log同步请求发送到Zone1-OB Server1和Zone3-OB Server1中的P2从副本（Follower）；</li><li>任何一个Follower完成Redo-Log落盘并将响应返回给Leader后，Leader即认为Redo-Log完成强同步，无需再等待其他Follower的反馈；</li><li>Leader反馈应用操作完成。</li></ol><h4 id="智能路由服务，应用透明访问"><a href="#智能路由服务，应用透明访问" class="headerlink" title="智能路由服务，应用透明访问"></a>智能路由服务，应用透明访问</h4><h5 id="高效路由转发"><a href="#高效路由转发" class="headerlink" title="高效路由转发"></a>高效路由转发</h5><ul><li>对SQL做基本解析，确定对应Leader所在机器；</li><li>反向代理，将请求路由至对应Leader；Leader位置无法确定时随机选择OB Server；</li><li>轻量SQL解析 + 快速转发，保证高性能，单OB Proxy每秒转发百万次请求。</li></ul><h5 id="“非”计算节点，无状态"><a href="#“非”计算节点，无状态" class="headerlink" title="“非”计算节点，无状态"></a>“非”计算节点，无状态</h5><ul><li>每个OB Proxy是一个“无状态”的服务进程，不做数据持久化，对部署位置无要求；</li><li>OB Proxy不参与数据库引擎的计算任务，不参与事务处理；</li><li>多个OB Proxy之间无联系，可通过F5/SLB组成负载均衡集群；</li><li>不需要独立服务器，可以与OB Server共用一台服务器，如果应用对实时性要求高，也可以将OB Proxy部署到应用服务器中。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724160743540.png" alt="image-20230724160743540"></p><p>OB Proxy的故障是不会影响事务的功能，事务，持久化，落盘基本是由OB Server来完成。</p><h4 id="设置Primary-Zone，业务汇聚到特定Zone"><a href="#设置Primary-Zone，业务汇聚到特定Zone" class="headerlink" title="设置Primary Zone，业务汇聚到特定Zone"></a>设置Primary Zone，业务汇聚到特定Zone</h4><p>通过为不同的租户配置不同的Primary Zone，可以将业务流量集中到若干Zone中，减少跨Zone以及服务器的操作。Zone List，逗号两侧优先级相同，分号左侧优先级高于右侧</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724161140837.png" alt="image-20230724161140837"></p><h4 id="Primary-Zone有租户，数据库和表不同的级别。"><a href="#Primary-Zone有租户，数据库和表不同的级别。" class="headerlink" title="Primary Zone有租户，数据库和表不同的级别。"></a>Primary Zone有租户，数据库和表不同的级别。</h4><ul><li>如无特殊指定，自动继承上级对象的Primary_zone:database继承租户的primary_zone设置，table继承database的primary_zone设置。</li><li>database和table可以指定各自的primary_zone，不必和上一级对象的设置保持一致；提供更加灵活的负载均衡策略。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724162242300.png" alt="image-20230724162242300"></p><h4 id="Table-Group-将多个表的相同分区ID的主副本聚集在一个OB-Server中，减少分布式事务引入的开销"><a href="#Table-Group-将多个表的相同分区ID的主副本聚集在一个OB-Server中，减少分布式事务引入的开销" class="headerlink" title="Table Group,将多个表的相同分区ID的主副本聚集在一个OB Server中，减少分布式事务引入的开销"></a>Table Group,将多个表的相同分区ID的主副本聚集在一个OB Server中，减少分布式事务引入的开销</h4><ul><li>如果多个表的分区方式完全相同（分区类型，分区键个数，分区数量等），可以在逻辑上将这些表归属到同一个Table Group中，以影响动态负载均衡的策略</li><li>同一个Table Group中的所有表，分区ID（partition_id） 相同的所有分区，他们的leader在同一个observer上：在不影响全局负载均衡的前提下，可有效减少分布式事务引入的跨机访问开销。</li><li>如果负载均衡被打破（服务器故障后，扩容缩容等），Table Group中的所有表会作为一个整体来调整分区分布和Leader分布</li><li>动态创建和删除，并且对上层应用完全透明。</li><li>如果租户的unit_num=1 且 primary_zone只有一个zone，不需要tablegroup。</li></ul><p>RDS实例，mysql扩容主备切换，ELR提前解行锁.。。。。。持续更新学习中………</p><h2 id="OBCA模拟题库"><a href="#OBCA模拟题库" class="headerlink" title="OBCA模拟题库"></a>OBCA模拟题库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【判断题】分库分表的架构虽然解决了集中式数据库的扩展性问题，但也带来了新的问题(不支持复杂SQL， 较难保证分布式事务的ACID等) 。T</span><br><span class="line">【判断题】TPC-C就是一个跑分测试， 没有什么规则限制,只要能跑高分就行 F</span><br><span class="line">【判断题】Ocean Base数据库是在阿里和蚂蚁内部孵化了10年后才逐步推广到外部市场的。T</span><br><span class="line">【判断题】Ocean Base数据库是基于开源数据库的再发行产品。 F</span><br><span class="line">【判断题】Ocean Base已发布到阿里云公有云及专有云中。 T</span><br><span class="line">【判断题】Ocean Base只支持X 86架构的CPU， 不支持国产CPU(如鲲鹏、海光、飞腾等) F</span><br><span class="line">【判断题】Zone是个逻辑概念， 是给集群内的一批机器打上同一个tag， 属于同一个tag的服务器归属一个Zone。T</span><br><span class="line">【判断题】Zone可以对应不同的城市， 或者一个城市的不同机房， 或者一个机房的不同机架。 T</span><br><span class="line">【判断题】租户的资源池一旦创建完成，就不可改变。 F</span><br><span class="line">【判断题】分区的副本只包含硬盘上的静态数据(S STable) ， 不包括Mem Table数据和日志数据。 F</span><br><span class="line">【判断题】主副本只能打散到所有Zone内， 不能聚焦到一个Zone内 F</span><br><span class="line">【判断题】每台OBServer是相对独立的， 都有自己独立的SQL引擎， 如果应用需要的数据不在当前OBServer上， 该OB&lt;br&gt;Server将协调其他OBServer的数据， 统一反馈给应用， 这个过程对应用是透明的。 T</span><br><span class="line">【判断题】主副本通过同步Redo-Log日志的方式实现可靠性， 主副本需要收到所有从副本落盘成功的消息后才能响应应用。 F</span><br><span class="line">【判断题】企业在一个城市有2个机房， 将2个Zone部署到1个机房中， 将另一个Zone部署到另一个机房中， 可以提供机房级的容灾。 F</span><br><span class="line">【判断题】 Ocean Base可以支持在一个集群中同时支持MySQL租户和Oracle租户。 T</span><br><span class="line">【判断题】使用Explain命令查看SQL执行计划时， SQL也会真正执行。 F</span><br><span class="line">【判断题】合井必须依赖Ocean Base自动完成， 无法手工启动合并。 F</span><br><span class="line">【判断题】Ocean Base的数据在磁盘中按主键有序排列。 T</span><br><span class="line">【判断题】会话变量只对当前会话生效，不影响该租户下的其他会话。 T</span><br><span class="line">【判断题】Global级(租户级) 变量修改后， 对当前已经打开的session也依然生效。 F</span><br><span class="line">【判断题】如果同时存在集群级别参数和租户级别参数，那么集群级别参数将覆盖租户级别参数。 T</span><br><span class="line"></span><br><span class="line">【多选题】传统的集中式关系型数据库面临哪些挑战? AC</span><br><span class="line">A：成本高：运行在高端服务器、小型机、高端存储等专有硬件上；</span><br><span class="line">B：生态欠缺：文档、培训、应用等都不足；</span><br><span class="line">C：扩展性差：无法摆脱单机的架构，只能纵向扩展，无法横向扩展；</span><br><span class="line">D：性能差：任何时候，传统集中式数据库的性能都比分布式数据库较差；</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base的核心特性有哪些? ABCD</span><br><span class="line">A：高扩展，可以使用普通的PC服务器进行横向扩展；</span><br><span class="line">B：高性能，峰值峰值6，100万次/秒，单表最大3，200亿行；</span><br><span class="line">C：高可用， 通过Paxos协议保证强一致性， RPO=0， R TO&lt;30秒；</span><br><span class="line">D：高兼容， 支持MySQL及Oracle两种模式， 降低业务迁移改造成本；</span><br><span class="line">E：高成本，使用小型机、高端存储等专有硬件；</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base主要有哪些产品组成? ABCD</span><br><span class="line">A：数据库内核：提供SQL引擎及存储引擎， 同时兼容MySQL和Oracle模式； 使用Paxos协议确保高可用性；</span><br><span class="line">B：OCP云管理平台：给管理员提供的管理工具， 提供集群管理、Zone管理、租户管理等功能；</span><br><span class="line">C：OMS数据迁移工具：提供基线数据和增量数据的同步功能， 可以从数据仓库订阅数据链路、从异构数据库迁移数据；</span><br><span class="line">D：ODC开发者中心：提供数据库日常开发、SQL诊断、会话管理及数据导入导出能功能。</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base支持哪些事务隔离级别 BC</span><br><span class="line">A：脏读 </span><br><span class="line">B：Read-Committed </span><br><span class="line">C：Serializable</span><br><span class="line"></span><br><span class="line">【多选题】以下对OB Proxy的描述是正确的  AD</span><br><span class="line">A：OB Proxy位于应用和OBServer之间， 将应用的请求路由到合适的OBServer；</span><br><span class="line">B：OB Proxy需要部署到一台独立的服务器上， 以保证其性能要求；</span><br><span class="line">C：OB Proxy参与数据库引擎的计算任务以及事务处理；</span><br><span class="line">D：OB Proxy是一个“无状态”的服务进程， 不做数据持久化</span><br><span class="line"></span><br><span class="line">【多选题】Ocean Base备份恢复业务支持哪些存储介质  AD</span><br><span class="line">A：NFS B：IP-SAN C：FC-SAN D：阿里云OSS</span><br><span class="line"></span><br><span class="line">【多选题】参数有哪两个级别?  AD</span><br><span class="line">A：集群级</span><br><span class="line">B：Zone级</span><br><span class="line">C：OBServer级</span><br><span class="line">D：租户级</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base是一个什么类型的数据库  C</span><br><span class="line">A：集中式数据库；</span><br><span class="line">B：No SQL数据库；</span><br><span class="line">C：分布式关系型数据库；</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base是一个集群， 以下哪个组件管理整个集群， 支持全局DDL、集群数据合并等功能。  B</span><br><span class="line">A：OB Proxy</span><br><span class="line">B：Root Service总控服务</span><br><span class="line">C：OCP管理平台 </span><br><span class="line">D：ODC开发者中心</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base集群可以同时支持MySQL和Oracle的租户， 哪个黑屏工具可以连接到Oracle租户  A</span><br><span class="line">A：Ocean Base客户端；</span><br><span class="line">B：标准MySQL客户端</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base不支持什么操作系统  B</span><br><span class="line">A：CentOS； </span><br><span class="line">B：Windows </span><br><span class="line">C：中标麒麟</span><br><span class="line">D：银河麒麟</span><br><span class="line"></span><br><span class="line">【单选题】如果一个Ocean Base集群有3个Zone， 每个Zone有5台OBSer er。那么一个分区有几份副本呢?  B</span><br><span class="line">A：10 B：3 C：6 D：5</span><br><span class="line"></span><br><span class="line">【单选题】如果一个集群有3个Zone， 每个Zone有5台OBServer。一个租户对应的资源池的Unit eNum=3， 最终该集群有多少个服务器中有该租户的资源单元呢?  B</span><br><span class="line">A： 15 B：9 C：45 D：30</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base是以() 为单位组建Paxos协议组。  D</span><br><span class="line">A：租户 B：数据库 C：表 D：分区</span><br><span class="line"></span><br><span class="line">【单选题】以下关于Ocean Base扩容和缩容描述正确的是。  C</span><br><span class="line">A：需要管理员停止业务 </span><br><span class="line">B：需要业务做一定的修改</span><br><span class="line">C：支持动态扩容和缩容，对业务无感知</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base使用两阶段提交协议保证事务的原子性， 在两阶段提交协议中， 谁是协调者呢?  B</span><br><span class="line">A：OB Proxy </span><br><span class="line">B：OBServer</span><br><span class="line">C：Root Service总控服务</span><br><span class="line">D：OCP云管理平台</span><br><span class="line"></span><br><span class="line">【单选题】Ocean Base使用哪种技术解决了读写互斥的问题。  A</span><br><span class="line">A：MVCC</span><br><span class="line">B：Paxos协议</span><br><span class="line">C：全局快照</span><br><span class="line">D：互斥锁</span><br><span class="line"></span><br><span class="line">单选题】使用JDBC连接Oracle租户时， 需要使用哪种JDBC驱动。  C</span><br><span class="line">A：MySQL标准的JDBC驱动</span><br><span class="line">B：Oracle标准的JDBC驱动</span><br><span class="line">C：Ocean Base自己开发的JDBC驱动</span><br><span class="line"></span><br><span class="line">【单选题】为了达到更好的压缩效果， Ocean Base一般会进行进行几次压缩  B</span><br><span class="line">A：1次 B：2次 C：3次 D：4次</span><br><span class="line"></span><br><span class="line">【单选题】mini freeze是简单的dump操作， 多个mini freeze的数据会(  )合并； 多个minor freeze会(  ) 合并， 但不会和S STable合并。  B</span><br><span class="line">A：实时、异步</span><br><span class="line">B：异步、实时</span><br><span class="line">C：实时、离散</span><br><span class="line">D：离散、实时</span><br><span class="line"></span><br><span class="line">【单选题】 Alter system命令可以修改集群参数和租户参数， 如该命令指定Zone或者OBServer， 最多可以同时指定几个?  A</span><br><span class="line">A：1个 B：2个C：3个D：4个</span><br><span class="line"></span><br><span class="line">【单选题】通过哪个命令可以查询参数的属性。  A</span><br><span class="line">A：show parameters like&#x27;%&lt;pattern&gt;%&#x27;；</span><br><span class="line">B：alter system set&lt;name&gt;=&lt;value&gt;；</span><br><span class="line">C：show variables like&#x27;%&lt;pattern&gt;%&#x27;；</span><br><span class="line">D：set@@global.&lt;name&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">【单选题】以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控告警等功能?  B</span><br><span class="line">A：ODC开发者中心 </span><br><span class="line">B：OCP云管理平台</span><br><span class="line">C：OB Proxy </span><br><span class="line">D：OBServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">判断：</span><br><span class="line">1.一个租户在同一个 Server 上可以有一个或多个资源单元 UNIT   错误</span><br><span class="line">2.创建资源单元仅仅指定  CPU、MEMORY 参数即可，无需指定 OPS、DISK_SIZE、SESSION_NUM参数  错误</span><br><span class="line">3.OCEANBASE 在少数副本不可用的情况下，可以实现 RPO=0,RTO&lt;30 秒    正确</span><br><span class="line">4.Zone 可以对应不同的城市，或者一个城市的不同机房、或者一个机房的不同机架，以实现不同级别的容灾   正确</span><br><span class="line">5.主副本只能打散到所有 Zone 内，实现访问流量的负载均衡，不能将主副本聚焦到一个Zone内。   错误</span><br><span class="line">6.扩容服务器加入集群后，集群会基于负载均衡的策略，将主副本及从副本迁移到扩容服务器中，以实现整体的负载均衡    正确</span><br><span class="line">7.租户逻辑上类似传统数据库实例，创建完成后，每个租户都拥有自己的专属进程     正确</span><br><span class="line">8.OceanBase 的 Paxos 协议，不同于传统的主备库或者双选方案，可以彻底规避在容灾场景下的脑裂问题（也就是同时又两个主数据库的场景）     正确</span><br><span class="line">9.修改资源池可以实现租户的另一种扩容/缩容的方式，比如在每个 zone 中增加/减少节</span><br><span class="line">点数量，可以通过修改资源池的 unit_num 来实现   正确</span><br><span class="line">10.创建租户时，需要指定租户类型为 Oracle 租户或者 MYSQL 租户，以满足不同开发者的需求。   正确</span><br><span class="line">11.同一个资源单元定义 unit cofig(比如 2C8G，或者 4C16G 等)，可以被多个资源池使用。   错误</span><br><span class="line"></span><br><span class="line">多选：</span><br><span class="line"></span><br><span class="line">1.OMS 实时同步工具是异构数据库迁移到 OceanBase 的利器，OMS 支持哪些功： BCDE</span><br><span class="line">A:支持会话管理和系统全局变量的可视化修改，用户记忆变量的难度</span><br><span class="line">B:支持多种类型数据源，支持包括 Oracle、MYSQL、DB2、OceanBase 等数据库到</span><br><span class="line">OceanBase 的全量迁移和增量实时数据同步</span><br><span class="line">C:一站式交互，数据迁移全生命周期管理，数据迁移的创建、配置和监控都在管控界面上连贯操作完成，交互简便</span><br><span class="line">D：兼容性评估和改造：异构数据迁移 OceanBase 的对象兼容性评估和改写建议，极大降低业务迁移的门槛和业务改造的难度。</span><br><span class="line">E:多重数据校验：提供多种方式校验的保护。要更加全面、省时、高效地保证数据质量</span><br><span class="line"></span><br><span class="line">2.关于 OceanBase 的 Zone，以下说法正确的是CDEF </span><br><span class="line">A:每个 Zone 可以包含一个分区的多个副本</span><br><span class="line">B:不同 Zone 一定要部署在不同机房</span><br><span class="line">C:一个分区的多个副本应分布在不同的 Zone 中，每个 Zone 有且只有分区的一个全功能副本</span><br><span class="line">D:Available Zone 的含义是可用区，通常指一个机房</span><br><span class="line">E:一个 OceanBase 集群由若干个 Zone 组成</span><br><span class="line">F:一个 Zone 包括若干物理服务器</span><br><span class="line">3.关于 OceanBase 的系统参数的生效范围，以下说法正确的是： ABC </span><br><span class="line">A:可以在某台 OBServer 生效</span><br><span class="line">B:可以在某个 Zone 生效</span><br><span class="line">C:可以在集群范围生效</span><br><span class="line">D:可以在某个 Region 生效</span><br><span class="line">4.随着业务不断发展，原有租户的资源无法满足业务需要，有哪些扩容方式？ BC </span><br><span class="line">A:无法对租户进行扩容，需要创建一个新的租户满足业务需要</span><br><span class="line">B:调整资源池中，资源单元（resource unit）的数量，如原数量是 1，可以增加为 2</span><br><span class="line">C:调整资源池里的资源单元（resource unit）的规则，比如之前规格是 2C8G,可以调整为 4C16G</span><br><span class="line">5.RootService 总控服务提供资源分配及调度功能，主要包括哪些功能： ABCD</span><br><span class="line"> A：分区及副本管理</span><br><span class="line">B: 动态负载均衡</span><br><span class="line">C:SQL 引擎</span><br><span class="line">D:扩容和缩容</span><br><span class="line">6.关于 OceanBase 的修改系统参数命令 ALTER SYSTEM SET XX=’YY’，以下说法正确的是：   BCDE</span><br><span class="line">A:如果不要任何条件，则会返回错误；</span><br><span class="line">B:可以修改该 Parameter 在某个 zone 上的值</span><br><span class="line">C:可以修改该 Parameter 在某台具体的 OBServer 上的值</span><br><span class="line">D:如果不带任何条件，则修改所有 OBServer 的值</span><br><span class="line">E:可以修改 Parameter 在某个 Region 的值</span><br><span class="line">7.关于 OceanBase 的分区 Partition，以下说法正确的是：AB</span><br><span class="line">A:数据表根据分区规则，拆分成多个分区，每个分区包括表中的若干行记录</span><br><span class="line">B：每个分区，还可以用不同的分区维度再进行分区，叫做二级分区 C:OceanBase 只支持一级分区，不支持二级分区</span><br><span class="line">D: OceanBase 的分区是数据迁移的最小单元，也是高可用切换的最小单元</span><br><span class="line">E:OceanBase 支持表的自动分区分裂</span><br><span class="line">8.关于租户的扩容方式，以下说法正确的是：  AB</span><br><span class="line">A：租户扩容，可先通过添加服务节点，完成集群扩容，再通过增加资源单元的个数完成租户扩容</span><br><span class="line">B:如果集群和节点资源足够，可以直接修改租户资源池相关的资源单元规格大小，进行扩容</span><br><span class="line">C:OceanBase 是分布式集群具有横向扩展的能力，租户扩容仅仅需要添加阶段即可，无需扩容租户的资源单元</span><br><span class="line">D:租户无法进行扩容，如果资源无法满足需求，需要重新建立更大资源池的租户。</span><br><span class="line"></span><br><span class="line">9.系统管理员可以根据业务需要创建不同的租户，租户具有哪些特性 ABCD </span><br><span class="line">A:有自己独立的系统变量</span><br><span class="line">B:有独立的 information_schema 等系统数据库</span><br><span class="line">C:可以创建自己的用户</span><br><span class="line">D:可以创建数据库，表等所有对象</span><br><span class="line">11.关于 OceanBase 的应用日志级别，以下说法正确的是： CDE </span><br><span class="line">A:warn 警告，用于记录严重错误，需要立即处理</span><br><span class="line">B：info 提示，用户记录系统运行的当前状态，该信息为错误信息</span><br><span class="line">C:ERROR 严重错误，用于记录系统的故障信息，且必须进行故障排除，否则系统不可用</span><br><span class="line">D: info 提示，用户记录系统运行的当前状态，该信息为正常信息</span><br><span class="line">E:warn 警告，用于记录可能会出现的潜在错误</span><br><span class="line"></span><br><span class="line">12.分区数据一般有多份副本，OceanBase 的 副本有什么类型：ACD</span><br><span class="line">A:全能型B 只写型 C:日志型 D:只读型</span><br><span class="line"></span><br><span class="line">13.OceanBase 开发者中心 ODC 是为 OceanBase 数据库量身打造的企业数据库开发平台，主要支持哪些功能 ABCDE </span><br><span class="line">A:提供引导式创建和可视化修改各类数据库对象的服务</span><br><span class="line">B:支持多种文件格式的导入和导出</span><br><span class="line">C:通过 WebSQL 技术为开发人员提供 SQL 语法高亮、格式化、只能提示等贴心特性、支持 PL 对象及匿名快的编译、运行调试</span><br><span class="line">D:实时管控数据库会话访问，支持查看和终止会话，且提供 SQL 执行计划分析和 SQL 调优指导服务</span><br><span class="line">E:支持会话变量和系统全局变量的可视化修改，降低用户记忆变量的难度</span><br><span class="line"></span><br><span class="line">14.关于 OceanBase 的租户权限管理,以下说法正确的是：AB</span><br><span class="line">A:任何租户（，不论是系统租户还是普通租户）下的用户不能跨租户访问其他普通租户下的用户数据</span><br><span class="line">B:只有系统租户下的管理员用户才有集群管理的权限，执行系统管理操作，如创建/删除普通租户。设置系统配置参数，开启每日合并操作</span><br><span class="line">C:系统租户下的管理员用户可以访问其他普通租户的用户数据</span><br><span class="line">D:系统租户下的管理员用户可以给其他普通租户的用户进行授权，使得普通租户的用户拥有系统管理员的权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">15.关于 OCP 的告警功能，下列说法正确的是：  ABCDEF</span><br><span class="line">A:OCP 告警依赖专有云底座</span><br><span class="line">B:可以查看告警列表</span><br><span class="line">C:可以调整告警阈值</span><br><span class="line">D:不支持用户修改告警阈值</span><br><span class="line">E:可以自定义告警发送对象</span><br><span class="line">F:可以调整告警开关，确定哪些项需要监控</span><br><span class="line"></span><br><span class="line">16.关于 OceanBase 实物引擎的 MVCC 多版本并发控制，以下说法正确的是： ACD </span><br><span class="line">A: 读操作读取特定快照版本的已提交数据</span><br><span class="line">B：写会阻塞读操作</span><br><span class="line">C: 所有修改的行加互斥锁、实现写-写互斥</span><br><span class="line">D: 读写互不阻塞</span><br><span class="line">17.OceanBase 支持哪些分区方式的分区表 ABD </span><br><span class="line">A：Range </span><br><span class="line">B：Hash </span><br><span class="line">C：Datetime </span><br><span class="line">D：list</span><br><span class="line">19.以下哪个描述不是 OceanBase 的架构特点：中心管控</span><br><span class="line">20. 租户创建完成后，可以使用黑屏客户端连接数据库，除了指定数据库的 IP、端口号、用户名、密码等信息外，OceanBase 一般用户名使用什么格式 </span><br><span class="line">用户名@租户名  例如 root@sys</span><br><span class="line">21.建立 table group 的主要目的是：减少跨机分布式事物</span><br><span class="line">22. OceanBase 产品的数据库内核是什么   完全自主研发</span><br><span class="line">23.当应用向数据库写数据时，默认会访问主副本，此次主副本会同步（）到从副本，保证数据的高可用 D</span><br><span class="line">A:undo-log 日志</span><br><span class="line">B:系统日志</span><br><span class="line">C:心跳消息</span><br><span class="line">D：redo-log 日志</span><br><span class="line"></span><br><span class="line">24.以下哪个组件提供图形化的管理界面，支持集群管理、租户管理、监控警告等功能。  OCP云管理平台</span><br><span class="line">25.部署 OceanBase 集群时，各个 OBServer 的 RPC 允许的时钟偏差最大是多少100毫秒</span><br><span class="line">26.如果一个 OceanBase 集群由 5 个 Zone，每个 Zone 有 10 台 OB Server，那么一个分区最多有几份全功能型副本   5个</span><br><span class="line">27.Linux 系统一般用什么用户来部署 OceanBaseADMIN</span><br><span class="line">28.OceanBase 服务器要求使用的磁盘类型: SSD固态磁盘</span><br><span class="line">29.假设OceanBase有3个Zone,其中2个Zone部署在一个城市的两个机房中，另外一个Zone部署在另外一个城市的一个机房中。如果同城的一个机房宕机，下面说法正确的是？    强一致同步延迟不变</span><br><span class="line">30.Major_freeze_duty_time 设置为 02:00 意味着什么每日凌晨两点，系统自动发起一次内存冻结操作</span><br><span class="line">31.关于 OceanBase 事物引擎一致性特点，描述正确的是：保证主键唯一等一致性约束</span><br><span class="line">32.关于 OceanBase 资源隔离，以下说法正确的是     OceanBase采用租户隔离</span><br><span class="line">33.管理员通过哪条命令创建资源池create resource pool</span><br><span class="line">34.OceanBase 是靠哪种基础架构实现写入高性能的 LSM-TTREE</span><br><span class="line">35.如果一个集群有 3 个 Zone，每个 Zone 有 5 台 OBServer，一个租户对应的资源池的 Unit Num=4,最终该集群有多少个服务器中有该租户的资源单元呢。    3*4=12 个</span><br></pre></td></tr></table></figure><h2 id="感谢OceanBase"><a href="#感谢OceanBase" class="headerlink" title="感谢OceanBase"></a>感谢OceanBase</h2><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230724163848260.png" alt="image-20230724163848260"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OceanBase&quot;&gt;&lt;a href=&quot;#OceanBase&quot; class=&quot;headerlink&quot; title=&quot;OceanBase&quot;&gt;&lt;/a&gt;OceanBase&lt;/h1&gt;&lt;h2 id=&quot;传统集中式数据库面临的挑战&quot;&gt;&lt;a href=&quot;#传统集中式数据库面临的挑</summary>
      
    
    
    
    <category term="数据库" scheme="https://kalyan-zitiu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Study-Note/"/>
    
    
    <category term="OceanBase" scheme="https://kalyan-zitiu.github.io/tags/OceanBase/"/>
    
  </entry>
  
  <entry>
    <title>Basic Cryptography</title>
    <link href="https://kalyan-zitiu.github.io/2023/06/29/Sercet/"/>
    <id>https://kalyan-zitiu.github.io/2023/06/29/Sercet/</id>
    <published>2023-06-29T08:50:04.000Z</published>
    <updated>2023-07-02T16:05:03.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础密码学"><a href="#基础密码学" class="headerlink" title="基础密码学"></a>基础密码学</h1><p>密码学是研究信息的保密性、完整性和认证性的学科。它在现代通信和计算机系统中起着关键作用，保护着敏感数据的安全。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密是一种加密方法，其中使用相同的密钥进行加密和解密。以下是一些常见的对称加密算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>DES</td><td>数据加密标准，使用56位密钥</td></tr><tr><td>AES</td><td>高级加密标准，使用128、192或256位密钥</td></tr><tr><td>3DES</td><td>三重数据加密标准，对数据进行三次加密</td></tr><tr><td>RC4</td><td>流密码算法，适用于嵌入式设备</td></tr></tbody></table><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密使用不同的密钥进行加密和解密。它包括公钥和私钥，其中公钥用于加密，私钥用于解密。以下是一些常见的非对称加密算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>RSA</td><td>基于大素数分解的加密算法</td></tr><tr><td>Diffie-Hellman</td><td>密钥交换算法，用于安全地共享密钥</td></tr><tr><td>ECC</td><td>椭圆曲线密码学，使用较短的密钥提供相同的安全性</td></tr></tbody></table><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数将输入数据转换为固定长度的哈希值。它的主要特点是输入的任何小改变都会导致输出值的巨大改变。以下是一些常见的哈希函数和特点：</p><table><thead><tr><th>函数</th><th>特点</th></tr></thead><tbody><tr><td>MD5</td><td>128位哈希值，易于碰撞攻击</td></tr><tr><td>SHA-1</td><td>160位哈希值，被认为不够安全</td></tr><tr><td>SHA-256</td><td>256位哈希值，广泛用于数字签名和认证</td></tr></tbody></table><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名用于验证消息的完整性和来源。它使用私钥对消息进行签名，然后使用公钥进行验证。以下是一些常见的数字签名算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>RSA</td><td>基于大素数分解的加密算法</td></tr><tr><td>DSA</td><td>数字签名算法，用于确保消息的完整性和认证</td></tr><tr><td>ECDSA</td><td>椭圆曲线数字签名算法，提供相同安全性下较短的密钥长度</td></tr></tbody></table><h2 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h2><p>密钥交换是在通信双方之间安全地共享密钥的过程。以下是一些常见的密钥交换协议和特点：</p><table><thead><tr><th>协议</th><th>特点</th></tr></thead><tbody><tr><td>Diffie-Hellman</td><td>公钥密码学协议，双方通过交换信息生成共享密钥</td></tr><tr><td>RSA 密钥交换</td><td>基于RSA算法的密钥交换协议</td></tr><tr><td>ECDH</td><td>基于椭圆曲线密码学的密钥交换协议，提供较短的密钥长度</td></tr></tbody></table><h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>消息认证码（Message Authentication Code，MAC）用于验证消息的完整性和真实性，以防止消息被篡改。以下是一些常见的消息认证码算法和特点：</p><table><thead><tr><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>HMAC</td><td>基于散列函数和密钥的消息认证码算法</td></tr><tr><td>CMAC</td><td>基于块密码的消息认证码算法</td></tr><tr><td>Poly1305</td><td>使用特殊的多项式计算的消息认证码算法</td></tr></tbody></table><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书用于验证实体的身份和确保通信的安全。它包含了实体的公钥和其他身份信息，并由数字证书颁发机构（Certificate Authority，CA）签名。以下是一些与数字证书相关的概念和术语：</p><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>公钥证书（Public Key Certificate）</td><td>包含公钥和实体身份信息的数字证书</td></tr><tr><td>数字签名（Digital Signature）</td><td>用于验证数字证书的完整性和真实性的签名</td></tr><tr><td>证书链（Certificate Chain）</td><td>由一系列数字证书组成的链，用于验证数字证书的信任链条</td></tr></tbody></table><h2 id="密码协议"><a href="#密码协议" class="headerlink" title="密码协议"></a>密码协议</h2><p>密码协议用于在不安全的通信环境中实现安全通信。它们定义了通信双方之间的消息格式、加密算法、密钥交换协议等。以下是一些常见的密码协议：</p><table><thead><tr><th>协议</th><th>特点</th></tr></thead><tbody><tr><td>SSL/TLS</td><td>安全套接层/传输层安全协议，用于保护Web通信</td></tr><tr><td>IPSec</td><td>用于保护IP网络通信的协议</td></tr><tr><td>SSH</td><td>安全外壳协议，用于远程登录和安全文件传输</td></tr></tbody></table><h2 id="抗量子密码学"><a href="#抗量子密码学" class="headerlink" title="抗量子密码学"></a>抗量子密码学</h2><p>随着量子计算机的发展，传统密码学算法的安全性受到了挑战。抗量子密码学致力于设计抵抗量子计算攻击的密码算法。以下是一些抗量子密码学的概念和算法：</p><table><thead><tr><th>概念/算法</th><th>解释</th></tr></thead><tbody><tr><td>Post-Quantum Cryptography（PQC）</td><td>用于抵抗量子计算攻击的密码学算法</td></tr><tr><td>Lattice-Based Cryptography</td><td>基于格的密码学，利用数学问题的困难性提供安全性</td></tr><tr><td>Code-Based Cryptography</td><td>基于编码的密码学，利用编码理论提供安全性</td></tr></tbody></table><h2 id="密码学应用"><a href="#密码学应用" class="headerlink" title="密码学应用"></a>密码学应用</h2><p>密码学在各个领域有广泛的应用。以下是一些常见的密码学应用和场景：</p><table><thead><tr><th>应用</th><th>描述</th></tr></thead><tbody><tr><td>数据加密</td><td>用于保护敏感数据的机密性，例如在存储和传输过程中进行加密</td></tr><tr><td>身份认证</td><td>用于验证用户的身份，例如使用密码、数字证书或生物特征识别</td></tr><tr><td>虚拟私人网络</td><td>通过加密和隧道技术实现安全的远程访问和通信</td></tr><tr><td>数字版权保护</td><td>用于保护数字内容的版权和防止非法复制和分发</td></tr><tr><td>安全电子支付</td><td>用于保护在线交易的机密性和完整性，例如使用加密货币和数字签名</td></tr></tbody></table><h2 id="密码破解与密码强度"><a href="#密码破解与密码强度" class="headerlink" title="密码破解与密码强度"></a>密码破解与密码强度</h2><p>密码破解是试图通过暴力猜测或使用各种技术手段来获取密码的过程。密码强度是衡量密码抵御密码破解攻击的程度。以下是一些与密码破解和密码强度相关的概念：</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>字典攻击</td><td>使用预先生成的密码列表进行猜测的攻击方式</td></tr><tr><td>彩虹表攻击</td><td>使用预先计算的哈希值与密码对应表进行猜测的攻击方式</td></tr><tr><td>密码策略</td><td>设定密码要求和规则的策略，如密码长度、复杂性和更改频率等</td></tr><tr><td>双因素认证</td><td>使用两个或多个不同的身份验证因素来增强安全性，如密码+OTP令牌</td></tr></tbody></table><h2 id="密码学应用-1"><a href="#密码学应用-1" class="headerlink" title="密码学应用"></a>密码学应用</h2><p>密码学在各个领域有广泛的应用。以下是一些常见的密码学应用和场景：</p><table><thead><tr><th>应用</th><th>描述</th></tr></thead><tbody><tr><td>数据加密</td><td>用于保护敏感数据的机密性，例如在存储和传输过程中进行加密</td></tr><tr><td>身份认证</td><td>用于验证用户的身份，例如使用密码、数字证书或生物特征识别</td></tr><tr><td>虚拟私人网络</td><td>通过加密和隧道技术实现安全的远程访问和通信</td></tr><tr><td>数字版权保护</td><td>用于保护数字内容的版权和防止非法复制和分发</td></tr><tr><td>安全电子支付</td><td>用于保护在线交易的机密性和完整性，例如使用加密货币和数字签名</td></tr></tbody></table><h2 id="密码破解与密码强度-1"><a href="#密码破解与密码强度-1" class="headerlink" title="密码破解与密码强度"></a>密码破解与密码强度</h2><p>密码破解是试图通过暴力猜测或使用各种技术手段来获取密码的过程。密码强度是衡量密码抵御密码破解攻击的程度。以下是一些与密码破解和密码强度相关的概念：</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>字典攻击</td><td>使用预先生成的密码列表进行猜测的攻击方式</td></tr><tr><td>彩虹表攻击</td><td>使用预先计算的哈希值与密码对应表进行猜测的攻击方式</td></tr><tr><td>密码策略</td><td>设定密码要求和规则的策略，如密码长度、复杂性和更改频率等</td></tr><tr><td>双因素认证</td><td>使用两个或多个不同的身份验证因素来增强安全性，如密码+OTP令牌</td></tr></tbody></table><h2 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h2><p>密码管理是指有效管理和保护个人或组织的密码。以下是一些常见的密码管理实践和工具：</p><table><thead><tr><th>实践/工具</th><th>描述</th></tr></thead><tbody><tr><td>密码管理器</td><td>用于安全存储和生成密码的应用程序，如LastPass和1Password等</td></tr><tr><td>多因素身份验证</td><td>在登录过程中要求提供多个验证因素，增加账户安全性</td></tr><tr><td>定期更改密码</td><td>定期更改密码以减少密码泄露和破解的风险</td></tr><tr><td>强密码生成</td><td>使用随机字符、数字和符号生成强密码，避免使用弱密码</td></tr><tr><td>社会工程学防范</td><td>提高对社会工程学攻击的意识，避免将密码泄露给不信任的来源</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">code</summary>
    
    
    
    <category term="密码学" scheme="https://kalyan-zitiu.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="https://kalyan-zitiu.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>设计模型-行为型模式</title>
    <link href="https://kalyan-zitiu.github.io/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA/"/>
    <id>https://kalyan-zitiu.github.io/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA/</id>
    <published>2023-06-15T14:00:00.000Z</published>
    <updated>2023-08-12T07:40:51.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-行为型"><a href="#设计模式-行为型" class="headerlink" title="设计模式-行为型"></a>设计模式-行为型</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>定义了对象之间一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新</li></ul><h3 id="模式组合"><a href="#模式组合" class="headerlink" title="模式组合"></a>模式组合</h3><table><thead><tr><th>角色</th><th>描述</th></tr></thead><tbody><tr><td>Subject</td><td>被观察者接口，定义了注册、移除和通知观察者的方法</td></tr><tr><td>Observer</td><td>观察者接口，定义了接收被观察者通知并进行更新的方法</td></tr><tr><td>ConcreteSubject</td><td>具体的被观察者类，实现Subject接口，维护观察者列表，当状态变化时通知观察者</td></tr><tr><td>ConcreteObserver</td><td>具体的观察者类，实现Observer接口，定义了接收通知后进行更新操作的方法</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230626152258117.png" alt="image-20230626152258117"></p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被观察者接口</span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void registerObserver(Observer observer);</span><br><span class="line">    void removeObserver(Observer observer);</span><br><span class="line">    void notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者接口</span><br><span class="line">interface Observer &#123;</span><br><span class="line">    void update(float temperature, float humidity, float pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的被观察者类</span><br><span class="line">class WeatherData implements Subject &#123;</span><br><span class="line">    private List&lt;Observer&gt; observers;</span><br><span class="line">    private float temperature;</span><br><span class="line">    private float humidity;</span><br><span class="line">    private float pressure;</span><br><span class="line">    </span><br><span class="line">    public WeatherData() &#123;</span><br><span class="line">        observers = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void registerObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void measurementsChanged() &#123;</span><br><span class="line">        // 当天气数据发生变化时调用该方法</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setMeasurements(float temperature, float humidity, float pressure) &#123;</span><br><span class="line">        this.temperature = temperature;</span><br><span class="line">        this.humidity = humidity;</span><br><span class="line">        this.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的观察者类</span><br><span class="line">class WeatherDisplay implements Observer &#123;</span><br><span class="line">    private float temperature;</span><br><span class="line">    private float humidity;</span><br><span class="line">    private float pressure;</span><br><span class="line">    </span><br><span class="line">    public void update(float temperature, float humidity, float pressure) &#123;</span><br><span class="line">        this.temperature = temperature;</span><br><span class="line">        this.humidity = humidity;</span><br><span class="line">        this.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void display() &#123;</span><br><span class="line">        // 更新天气展示板上的数据显示</span><br><span class="line">        System.out.println(&quot;当前天气情况：温度 &quot; + temperature + &quot;℃，湿度 &quot; + humidity + &quot;%，气压 &quot; + pressure + &quot;Pa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">public class ObserverPatternExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WeatherData weatherData = new WeatherData();</span><br><span class="line">        </span><br><span class="line">        WeatherDisplay display1 = new WeatherDisplay();</span><br><span class="line">        WeatherDisplay display2 = new WeatherDisplay();</span><br><span class="line">        </span><br><span class="line">        weatherData.registerObserver(display1);</span><br><span class="line">        weatherData.registerObserver(display2);</span><br><span class="line">        </span><br><span class="line">        // 模拟天气数据变化</span><br><span class="line">        weatherData.setMeasurements(28.5f, 70.2f, 1013.2f);</span><br><span class="line">        </span><br><span class="line">        // 移除一个观察者</span><br><span class="line">        weatherData.removeObserver(display2);</span><br><span class="line">        </span><br><span class="line">        // 再次模拟天气数据变化</span><br><span class="line">        weatherData.setMeasurements(30.2f, 65.8f, 1012.5f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模式特征"><a href="#模式特征" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>松耦合：被观察者和观察者之间是松耦合的关系，它们之间相互独立，可以独立地进行扩展和修改，一方的变化不会影响到另一方。 </li><li>可扩展性：可以轻松地增加新的观察者和被观察者，使系统具有更好的可扩展性。</li><li>随时通知：被观察者状态发生变化时，会立即通知所有观察者，观察者可以及时作出响应。</li><li>解耦：观察者模式将观察者和被观察者解耦，使它们之间的依赖关系降低，符合面向对象设计的原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加了复杂性：在使用观察者模式时，需要维护观察者列表并确保正确的通知顺序，这增加了系统的复杂性。</li><li>更新通知顺序：观察者的更新通知顺序是不确定的，这可能导致观察者之间的依赖关系问题。</li><li>观察者数量过多：当观察者数量过多时，被观察者通知所有观察者的时间和性能开销会增加。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>定义了一组算法类，将每个算法封装到单独的类中，并使他们可以相互替换，而不影响客户端的代码</li></ul><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色</th><th>描述</th></tr></thead><tbody><tr><td>环境类（Context）</td><td>包含对策略的引用，可在运行时切换不同的策略。将具体的算法委托给策略对象执行。</td></tr><tr><td>抽象策略类（Strategy）</td><td>定义了通用的策略接口，所有具体策略类都必须实现该接口。通常是抽象类或接口，包含一个或多个用于执行策略的方法。</td></tr><tr><td>具体策略类（Concrete Strategy）</td><td>实现策略接口，提供具体的算法实现。每个具体策略类封装了一种特定的算法，可根据需要添加、删除或替换。</td></tr></tbody></table><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/%E5%8C%85%20Strategy.png" alt="包 Strategy"></p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 环境类（Context）</span><br><span class="line">class Context &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void executeStrategy(int num1, int num2) &#123;</span><br><span class="line">        int result = strategy.doOperation(num1, num2);</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象策略类（Strategy）</span><br><span class="line">interface Strategy &#123;</span><br><span class="line">    int doOperation(int num1, int num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略类（Concrete Strategy）</span><br><span class="line">class AddStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int doOperation(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略类（Concrete Strategy）</span><br><span class="line">class SubtractStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int doOperation(int num1, int num2) &#123;</span><br><span class="line">        return num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略类（Concrete Strategy）</span><br><span class="line">class MultiplyStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int doOperation(int num1, int num2) &#123;</span><br><span class="line">        return num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line"></span><br><span class="line">        // 使用加法策略</span><br><span class="line">        context.setStrategy(new AddStrategy());</span><br><span class="line">        context.executeStrategy(5, 3); // Output: Result: 8</span><br><span class="line"></span><br><span class="line">        // 使用减法策略</span><br><span class="line">        context.setStrategy(new SubtractStrategy());</span><br><span class="line">        context.executeStrategy(5, 3); // Output: Result: 2</span><br><span class="line"></span><br><span class="line">        // 使用乘法策略</span><br><span class="line">        context.setStrategy(new MultiplyStrategy());</span><br><span class="line">        context.executeStrategy(5, 3); // Output: Result: 15</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模式特征-1"><a href="#模式特征-1" class="headerlink" title="模式特征"></a>模式特征</h4><h5 id="策略模式的优点："><a href="#策略模式的优点：" class="headerlink" title="策略模式的优点："></a>策略模式的优点：</h5><p>可扩展性：策略模式使得新增或修改算法变得简单，通过添加新的具体策略类，可以轻松地扩展系统的功能。</p><p>灵活性：客户端可以根据需要在运行时选择不同的策略，无需修改原有的代码，提供了更高的灵活性和可定制性。</p><p>代码复用：策略模式利用了面向对象的多态特性，可以让多个具体策略类共享相同的接口或抽象类，提高了代码的复用性。</p><p>解耦合：策略模式将算法的选择与使用算法的客户端代码解耦，客户端只需要关注如何使用策略，而无需关注具体的算法实现细节，降低了代码的耦合度。</p><h6 id="策略模式的缺点："><a href="#策略模式的缺点：" class="headerlink" title="策略模式的缺点："></a>策略模式的缺点：</h6><p>增加类的数量：每个具体策略类都需要一个对应的类，当策略较多时，会增加类的数量，导致代码结构复杂。</p><p>客户端需要了解不同策略的区别：客户端在选择具体策略时需要了解不同策略的特点和适用场景，增加了客户端的理解和学习成本。</p><p>策略的切换开销：在运行时切换策略时，可能需要重新设置环境类的策略，会带来一定的切换开销，尤其是在需要频繁切换策略时。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>允许多个对象依次处理请求，形成一个处理请求的链条，每个对象都有机会处理请求，但具体是哪个对象处理请求由运行时决定。<h3 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h3></li></ul><table><thead><tr><th>组成部分</th><th>描述</th></tr></thead><tbody><tr><td>抽象处理者（Abstract Handler）</td><td>定义处理请求的接口，包含一个指向下一个处理者的引用。</td></tr><tr><td>具体处理者（Concrete Handler）</td><td>实现抽象处理者接口，并决定自己能处理的请求类型，如果可以处理就进行处理，否则将请求传递给下一个处理者。</td></tr><tr><td>客户端（Client）</td><td>发起请求的对象，将请求发送给第一个处理者。</td></tr></tbody></table><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230626161056453.png" alt="image-20230626161056453"></p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 抽象处理者</span><br><span class="line">abstract class Handler &#123;</span><br><span class="line">    protected Handler successor; // 下一个处理者</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(Handler successor) &#123;</span><br><span class="line">        this.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleRequest(int request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者A</span><br><span class="line">class ConcreteHandlerA extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(int request) &#123;</span><br><span class="line">        if (request &gt;= 0 &amp;&amp; request &lt; 10) &#123;</span><br><span class="line">            System.out.println(&quot;ConcreteHandlerA 处理请求：&quot; + request);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request); // 传递给下一个处理者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者B</span><br><span class="line">class ConcreteHandlerB extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(int request) &#123;</span><br><span class="line">        if (request &gt;= 10 &amp;&amp; request &lt; 20) &#123;</span><br><span class="line">            System.out.println(&quot;ConcreteHandlerB 处理请求：&quot; + request);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request); // 传递给下一个处理者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体处理者C</span><br><span class="line">class ConcreteHandlerC extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(int request) &#123;</span><br><span class="line">        if (request &gt;= 20 &amp;&amp; request &lt; 30) &#123;</span><br><span class="line">            System.out.println(&quot;ConcreteHandlerC 处理请求：&quot; + request);</span><br><span class="line">        &#125; else if (successor != null) &#123;</span><br><span class="line">            successor.handleRequest(request); // 传递给下一个处理者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Handler handlerA = new ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = new ConcreteHandlerB();</span><br><span class="line">        Handler handlerC = new ConcreteHandlerC();</span><br><span class="line"></span><br><span class="line">        handlerA.setSuccessor(handlerB);</span><br><span class="line">        handlerB.setSuccessor(handlerC);</span><br><span class="line"></span><br><span class="line">        int[] requests = &#123; 2, 12, 25, 30 &#125;;</span><br><span class="line"></span><br><span class="line">        for (int request : requests) &#123;</span><br><span class="line">            handlerA.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模式特征-2"><a href="#模式特征-2" class="headerlink" title="模式特征"></a>模式特征</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>责任链模式将发送者和接收者解耦，发送者无需知道具体的接收者，只需将请求发送给责任链的起始点即可，由责任链负责将请求传递给合适的接收者进行处理。<br>灵活性和可扩展性：责任链模式允许动态地添加、移除或重新排列处理者，可以根据需求对责任链进行灵活的组织和调整，而无需修改客户端代码。<br>可以确保请求被处理：由于责任链中的每个处理者都有机会处理请求，可以确保请求最终会被处理，而不会被忽略或丢失。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>性能问题：如果责任链过长或者处理者的判断逻辑过于复杂，可能会导致性能下降，因为每个请求都要依次经过链中的所有处理者。<br>请求的处理不一定成功：由于责任链模式并不保证请求一定会被处理，如果没有合适的处理者或者处理者链配置错误，请求可能会被忽略或丢失。<br>可能导致调试困难：责任链模式中请求的处理路径是动态确定的，可能会导致在调试时难以确定请求的具体处理路径。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li>将请求封装成一个对象，该对象会包含了执行操作的方法，发送者将命令对象传递给调用者，并在需要执行操作的时候触发命令并执行相应操作。</li></ul><h3 id="模式组成-2"><a href="#模式组成-2" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>模式组成</th><th>描述</th></tr></thead><tbody><tr><td>命令接口</td><td>定义命令的执行方法，通常包括一个执行操作的方法。</td></tr><tr><td>具体命令</td><td>实现命令接口，持有一个接收者对象，并将请求委托给接收者执行具体的操作。</td></tr><tr><td>接收者</td><td>知道如何实施与执行一个请求相关的操作。</td></tr><tr><td>调用者</td><td>将命令对象传递给调用者，并可选择性地触发命令执行。</td></tr></tbody></table><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h4><p>当然，以下是一个简单的 Java 实例来演示命令模式：</p><p>首先，我们定义一个命令接口 <code>Command</code>，它包含了一个执行操作的方法 <code>execute()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个具体命令类 <code>ConcreteCommand</code>，它实现了 <code>Command</code> 接口，并持有一个接收者对象，用于执行具体的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.performAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个接收者类 <code>Receiver</code>，它知道如何实施与执行请求相关的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver: Performing action...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个调用者类 <code>Invoker</code>，它将接收到的命令对象传递给调用者，并在需要的时候触发命令的执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以在客户端代码中配置和使用命令模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建接收者对象</span></span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建具体命令对象并设置接收者</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用者对象并设置命令</span></span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        invoker.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702220522678.png" alt="image-20230702220522678"></p><h3 id="模式特征-3"><a href="#模式特征-3" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>解耦发送者和接收者：命令模式将请求封装成对象，使得发送者和接收者之间解耦。发送者不需要知道接收者的具体实现细节，只需通过命令对象来执行请求。</li><li>容易扩展和修改：由于命令模式将请求封装成独立的对象，因此可以很容易地添加新的命令或修改现有命令，而不会对其他部分产生影响。这种可扩展性使得系统更加灵活和可维护。</li><li>支持撤销和重做：命令模式可以记录命令的历史，从而支持撤销和重做操作。通过保存命令的执行历史，可以在需要时回溯执行，实现撤销操作。</li><li>支持命令的排队和调度：命令模式可以将命令对象进行排队或者调度，从而实现更高级的控制和管理。可以按照特定的顺序执行命令，或者延迟执行命令。</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>类的增加：在使用命令模式时，每个具体命令都需要一个独立的类，这可能会导致类的数量增加，增加了系统的复杂性。</li><li>可能导致系统过于细粒度：如果系统中有大量的命令对象，每个对象都只封装了一个操作，可能会导致系统过于细粒度，增加了管理和维护的成本。</li><li>可能引入额外的开销：命令模式需要创建额外的对象来封装请求，可能会引入一定的开销。但在大多数情况下，这种开销是可以接受的。</li></ol><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>通过将不同状态抽象为独立的类，并将其与主对象关联，实现状态之间的切换和行为的动态变化。</li></ul><h3 id="模式组成-3"><a href="#模式组成-3" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成要素</th><th>描述</th></tr></thead><tbody><tr><td>环境（Context）</td><td>环境类持有一个状态对象的引用，可以定义和维护对象的内部状态。它将状态相关的操作委托给当前状态对象，并在状态发生改变时更新当前状态对象。</td></tr><tr><td>抽象状态（State）</td><td>定义一个接口或抽象类，声明各个具体状态类共同的方法，这些方法可以是环境在某个特定状态下要执行的行为。</td></tr><tr><td>具体状态（Concrete State）</td><td>实现抽象状态接口或继承抽象状态类，具体状态类封装了特定状态下的行为。每个具体状态类负责处理与其状态相关的操作，并在必要时切换到其他状态。</td></tr></tbody></table><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：新订单状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewOrderState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理新订单...&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行新订单状态下的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：已支付状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaidOrderState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理已支付订单...&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行已支付订单状态下的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：已发货状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShippedOrderState</span> <span class="keyword">implements</span> <span class="title class_">OrderState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理已发货订单...&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行已发货订单状态下的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderState currentState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认初始状态为新订单状态</span></span><br><span class="line">        currentState = <span class="keyword">new</span> <span class="title class_">NewOrderState</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(OrderState state)</span> &#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatePatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理新订单</span></span><br><span class="line">        order.processOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换为已支付状态</span></span><br><span class="line">        order.setState(<span class="keyword">new</span> <span class="title class_">PaidOrderState</span>());</span><br><span class="line">        order.processOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换为已发货状态</span></span><br><span class="line">        order.setState(<span class="keyword">new</span> <span class="title class_">ShippedOrderState</span>());</span><br><span class="line">        order.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，抽象状态类<code>OrderState</code>定义了一个<code>processOrder()</code>方法，具体状态类<code>NewOrderState</code>、<code>PaidOrderState</code>和<code>ShippedOrderState</code>分别实现了这个方法，封装了不同状态下的具体行为逻辑。<code>Order</code>类作为环境类，维护了当前状态对象的引用，并在<code>processOrder()</code>方法中委托给当前状态对象执行相应的行为。</p><p>客户端代码创建了一个订单对象<code>order</code>，初始状态为新订单状态，然后依次处理订单并切换状态，观察不同状态下的行为执行情况。</p><h4 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702225657156.png" alt="image-20230702225657156"></p><h3 id="模式特征-4"><a href="#模式特征-4" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>状态模式将对象的状态和行为进行了解耦，使得状态的变化可以独立于对象的行为变化。这提高了代码的可维护性和扩展性。</li><li>状态模式遵循开闭原则，可以通过添加新的具体状态类来增加新的状态，而无需修改现有的代码。</li><li>状态模式使得状态转换变得更加明确和可控。状态的切换逻辑集中在具体状态类中，不会分散在对象的各个方法中，使得代码更易理解和调试。</li><li>状态模式使得对象的状态变化可见，可以方便地观察和记录对象的状态变化历史。</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>状态模式增加了系统中类的数量，特别是在具体状态类较多的情况下，可能会导致类的数量增加，增加了系统的复杂性。</li><li>如果状态转换较为复杂，可能会导致状态模式的实现变得复杂，需要维护大量的状态类和状态转换逻辑。</li><li>当状态较少且简单时，引入状态模式可能会带来不必要的复杂性，增加了代码的理解和维护成本。</li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>用于将数据结构和对数据结构的操作分离开来，允许定义新的操作而无需修改已有的数据结构。</li></ul><h3 id="模式组成-4"><a href="#模式组成-4" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成部分</th><th>描述</th></tr></thead><tbody><tr><td>元素（Element）</td><td>表示数据结构中的对象。它定义了一个接受访问者对象的方法，让访问者可以对自身进行操作。</td></tr><tr><td>具体元素（Concrete Element）</td><td>实现了元素接口的具体类。每个具体元素类都会实现自己的接受访问者的方法，并在其中调用访问者对象的操作方法。</td></tr><tr><td>访问者（Visitor）</td><td>定义了对元素进行操作的接口，其中包含了为每个具体元素类定义的操作方法。</td></tr><tr><td>具体访问者（Concrete Visitor）</td><td>实现了访问者接口的具体类。每个具体访问者类都会实现对应的操作方法，以便对具体元素进行相应的操作。</td></tr><tr><td>对象结构（Object Structure）</td><td>存储元素对象并提供访问者访问的接口。它可以是一个集合、列表、树或其他数据结构。</td></tr></tbody></table><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitConcreteElementA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteElementA operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitConcreteElementB(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteElementB operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitConcreteElementA</span><span class="params">(ConcreteElementA elementA)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitConcreteElementB</span><span class="params">(ConcreteElementB elementB)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitConcreteElementA</span><span class="params">(ConcreteElementA elementA)</span> &#123;</span><br><span class="line">        elementA.operationA();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteVisitor visits ConcreteElementA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitConcreteElementB</span><span class="params">(ConcreteElementB elementB)</span> &#123;</span><br><span class="line">        elementB.operationB();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteVisitor visits ConcreteElementB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(Element element)</span> &#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具体元素对象</span></span><br><span class="line">        <span class="type">ConcreteElementA</span> <span class="variable">elementA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteElementA</span>();</span><br><span class="line">        <span class="type">ConcreteElementB</span> <span class="variable">elementB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteElementB</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建对象结构并添加元素</span></span><br><span class="line">        <span class="type">ObjectStructure</span> <span class="variable">objectStructure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStructure</span>();</span><br><span class="line">        objectStructure.addElement(elementA);</span><br><span class="line">        objectStructure.addElement(elementB);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建具体访问者对象</span></span><br><span class="line">        <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteVisitor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象结构接受访问者访问</span></span><br><span class="line">        objectStructure.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702232125374.png" alt="image-20230702232125374"></p><h3 id="模式特征-5"><a href="#模式特征-5" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><p>当讨论访问者模式时，可以列举一些其优点和缺点，以便全面评估该模式的适用性和潜在的问题。</p><p>优点：</p><ul><li>分离关注点：访问者模式可以将数据结构和操作分离开来，使得操作可以独立变化而不影响元素类的结构。这种分离可以提高代码的可维护性和可扩展性。</li><li>增加新操作更容易：通过定义新的访问者类，可以很容易地增加新的操作，而无需修改元素类的代码。这符合开闭原则，使系统更灵活。</li><li>集中相关操作：访问者模式可以将相关操作集中到访问者类中。这样，当需要对元素进行某个操作时，只需调用相应的访问者方法，而不需要在元素类中编写重复的操作代码。</li><li>增加新元素相对容易：如果需要增加新的元素类，只需创建相应的具体元素类并实现接受访问者的方法即可。无需修改现有的访问者类。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加新元素困难：在访问者模式中，如果需要增加新的访问者类，需要修改所有已有的元素类，为它们添加接受新访问者的方法。这可能会导致元素类的修改和代码的重复。</li><li>违反封装原则：访问者模式需要将具体元素类的内部结构暴露给访问者类，以便访问者能够进行操作。这可能违反了封装原则，降低了元素类的封装性。</li><li>增加系统复杂性：引入访问者模式会增加系统中的类和接口数量，增加了代码的复杂性和理解难度。这可能使得系统变得更加复杂，特别是对于简单的数据结构而言，使用访问者模式可能过于繁琐。</li></ul><h2 id="模块方法模式"><a href="#模块方法模式" class="headerlink" title="模块方法模式"></a>模块方法模式</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li>定义了一个操作中的算法的骨架。将一些步骤延迟到子类中实现。模板方块使得子类可以在不改变算法结构的情况下重新定义算法中某些步骤<h3 id="模式组成-5"><a href="#模式组成-5" class="headerlink" title="模式组成"></a>模式组成</h3></li></ul><table><thead><tr><th>模式组成</th><th>描述</th></tr></thead><tbody><tr><td>模板方法（Template Method）</td><td>定义了算法的骨架，将算法的步骤定义为一系列抽象操作或具体操作的调用顺序。这个方法可以包含预定义的操作和钩子方法。</td></tr><tr><td>具体方法（Concrete Method）</td><td>在模板方法中定义的具体操作，是算法的固定部分。</td></tr><tr><td>抽象方法（Abstract Method）</td><td>在模板方法中定义的抽象操作，由子类实现。这些方法可以有不同的实现，以满足特定的需求。</td></tr><tr><td>钩子方法（Hook Method）</td><td>在模板方法中定义的具体操作，子类可以选择性地覆盖或扩展。这些方法在模板方法中有默认实现，但可以在子类中进行修改。</td></tr><tr><td>抽象类（Abstract Class）</td><td>包含模板方法和抽象方法的抽象类。它定义了算法的骨架，并规定了具体操作和抽象操作的调用顺序。</td></tr><tr><td>具体类（Concrete Class）</td><td>继承抽象类并实现其中的抽象方法，完成算法的具体步骤。它可以覆盖钩子方法来定制算法的行为。</td></tr></tbody></table><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><h4 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 抽象类</span><br><span class="line">abstract class AbstractClass &#123;</span><br><span class="line">    // 模板方法</span><br><span class="line">    public void templateMethod() &#123;</span><br><span class="line">        // 调用抽象方法</span><br><span class="line">        operation1();</span><br><span class="line">        // 调用具体方法</span><br><span class="line">        operation2();</span><br><span class="line">        // 调用钩子方法</span><br><span class="line">        if (hookMethod()) &#123;</span><br><span class="line">            operation3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 抽象方法</span><br><span class="line">    protected abstract void operation1();</span><br><span class="line"></span><br><span class="line">    // 具体方法</span><br><span class="line">    protected void operation2() &#123;</span><br><span class="line">        // 具体操作的实现</span><br><span class="line">        System.out.println(&quot;执行具体操作2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 钩子方法</span><br><span class="line">    protected boolean hookMethod() &#123;</span><br><span class="line">        // 默认实现，子类可以选择性地覆盖该方法</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 抽象方法</span><br><span class="line">    protected abstract void operation3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体类A</span><br><span class="line">class ConcreteClassA extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作1（来自具体类A）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void operation3() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作3（来自具体类A）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体类B</span><br><span class="line">class ConcreteClassB extends AbstractClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作1（来自具体类B）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean hookMethod() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void operation3() &#123;</span><br><span class="line">        System.out.println(&quot;执行具体操作3（来自具体类B）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractClass instanceA = new ConcreteClassA();</span><br><span class="line">        instanceA.templateMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line"></span><br><span class="line">        AbstractClass instanceB = new ConcreteClassB();</span><br><span class="line">        instanceB.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230702234441116.png" alt="image-20230702234441116"></p><h3 id="模式特征-6"><a href="#模式特征-6" class="headerlink" title="模式特征"></a>模式特征</h3><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>提供了一种框架或模板，用于定义算法的骨架，使得算法的具体步骤可以在子类中实现，提高了代码的可扩展性和复用性。</li><li>将算法的通用部分封装在模板方法中，具体实现延迟到子类中，使得算法的具体步骤可以灵活变化，而不影响算法的整体结构。</li><li>通过钩子方法，允许子类选择性地覆盖或扩展父类中的某些操作，从而实现个性化定制。</li><li>提高了代码的可维护性和可读性，将重复的代码逻辑放在模板方法中，避免了代码的重复编写。</li></ol><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ol><li>引入了抽象类和具体类之间的继承关系，增加了系统的复杂性。如果继承关系设计不当，可能会导致类的层次结构变得复杂，难以维护。</li><li>由于模板方法已经定义了算法的骨架，因此在一定程度上限制了子类的自由度，子类只能实现父类定义好的抽象方法。</li><li>如果算法的变化点过多，可能需要定义大量的抽象方法，增加了子类的实现工作量。</li><li>模板方法模式的设计初衷是为了定义算法的骨架，对于一些具有多个算法簇的情况，可能会导致类的爆炸性增长，不利于系统的扩展和维护。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-行为型&quot;&gt;&lt;a href=&quot;#设计模式-行为型&quot; class=&quot;headerlink&quot; title=&quot;设计模式-行为型&quot;&gt;&lt;/a&gt;设计模式-行为型&lt;/h1&gt;&lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Study-Note/"/>
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MP</title>
    <link href="https://kalyan-zitiu.github.io/2023/05/06/mybatis/"/>
    <id>https://kalyan-zitiu.github.io/2023/05/06/mybatis/</id>
    <published>2023-05-06T09:32:04.000Z</published>
    <updated>2023-08-12T07:41:19.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a>MyBatis Plus</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li>损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li>强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li>支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li>支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li>支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li>分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作<h4 id="什么是MyBatisPlus"><a href="#什么是MyBatisPlus" class="headerlink" title="什么是MyBatisPlus"></a>什么是MyBatisPlus</h4></li><li>MyBatis是一款优秀的持久层框架，用于简化JDBC开发</li><li>MyBatisPlus是基于MyBatis框架基础上开发的增强型工具，皆在<strong>简化开发，提高效率</strong></li></ul><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><ul><li>负责将数据保存倒数据库那一层代码</li><li>JavaEE三层架构：表现层，业务层，持久层</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>框架就是一个半成品软件，是一套可重用的，通用的，软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效，规范，通用，可扩展</li></ul><h3 id="入门案列"><a href="#入门案列" class="headerlink" title="入门案列"></a>入门案列</h3><ul><li>SpringBoot整合MyBatis开发过程<ul><li>创建SpringBoot工程</li><li>勾选配置使用的技术</li><li>设置dataSource相关属性（JDBC参数）</li><li>定义数据层接口映射配置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/mybatisplus_db?serverTimezone = UTC</span></span><br><span class="line">    username: ？</span><br><span class="line">    password: ？</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;?&gt;&#123;</span><br><span class="line"><span class="meta">@select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><h5 id="创建SpringBoot工程"><a href="#创建SpringBoot工程" class="headerlink" title="创建SpringBoot工程"></a>创建SpringBoot工程</h5><pre><code>![image-20230503171102161](https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230503171102161.png)</code></pre><h5 id="添加依赖MySQL-Driver"><a href="#添加依赖MySQL-Driver" class="headerlink" title="添加依赖MySQL Driver"></a>添加依赖MySQL Driver<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230503171325952.png" alt="image-20230503171325952"></h5><h5 id="打开xml文件，手动添加mybatis-plus-boot-start依赖"><a href="#打开xml文件，手动添加mybatis-plus-boot-start依赖" class="headerlink" title="打开xml文件，手动添加mybatis-plus-boot-start依赖"></a>打开xml文件，手动添加mybatis-plus-boot-start依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="mybatis-plus-boot-start"><a href="#mybatis-plus-boot-start" class="headerlink" title="mybatis-plus-boot-start"></a>mybatis-plus-boot-start</h6><p>这是Maven依赖，用于引入MyBatis Plus框架的快速启动器。MyBatis Plus是一个增强版的MyBatis框架，提供了许多MyBatis没有的方便实用的功能，例如自动代码生成、分页插件、多数据源支持、性能优化等。</p><p>在pom.xml中引入了这个依赖后，就可以开始使用MyBatis Plus。可以在配置文件中添加MyBatis Plus的配置，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  typeAliasesPackage: com.example.demo.entity</span><br><span class="line">  mapperLocations: classpath:/mapper/*.xml</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      column-underscore: true</span><br><span class="line">      id-type: auto</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，typeAliasesPackage是指实体类所在的包，mapperLocations是指MyBatis mapper XML文件的位置，global-config是MyBatis Plus的全局配置，在这里修改了ID的生成策略和开启了下划线到驼峰命名的自动转换。</p><p>然后，可以像平常一样编写MyBatis mapper XML文件和DAO接口，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- demo.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.dao.DemoDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.demo.entity.DemoEntity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listByParam&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from demo</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> and name = #&#123;name&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span> and age = #&#123;age&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的SQL语句... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// DemoDAO.java</span><br><span class="line">@Mapper</span><br><span class="line">public interface DemoDAO extends BaseMapper<span class="tag">&lt;<span class="name">DemoEntity</span>&gt;</span> &#123;</span><br><span class="line">    List<span class="tag">&lt;<span class="name">DemoEntity</span>&gt;</span> listByParam(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编写DAO接口时，可以继承MyBatis Plus提供的BaseMapper&lt; T &gt;接口，该接口提供了许多便捷的CRUD方法。此外，也可以编写自定义SQL语句，既具有MyBatis的灵活性，又能充分利用MyBatis Plus提供的便利性。最后，在使用DAO接口时，可以像平常一样使用Spring的@Autowired注解来注入DAO对象，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private DemoDAO demoDAO;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    QueryWrapper<span class="tag">&lt;<span class="name">DemoEntity</span>&gt;</span> queryWrapper = new QueryWrapper<span class="tag">&lt;&gt;</span>();</span><br><span class="line">    queryWrapper.eq(&quot;name&quot;, &quot;张三&quot;).eq(&quot;age&quot;, 25);</span><br><span class="line">    demoDAO.selectList(queryWrapper);</span><br><span class="line">    // TODO: 使用查询到的数据进行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打开xml文件，手动添加com-baomidou依赖"><a href="#打开xml文件，手动添加com-baomidou依赖" class="headerlink" title="打开xml文件，手动添加com.baomidou依赖"></a>打开xml文件，手动添加com.baomidou依赖</h6><p>这是Maven依赖，用于引入MyBatis Plus框架的快速启动器。MyBatis Plus是一个增强版的MyBatis框架，提供了许多MyBatis没有的方便实用的功能，例如自动代码生成、分页插件、多数据源支持、性能优化等。</p><p>在pom.xml中引入了这个依赖后，就可以开始使用MyBatis Plus。可以在配置文件中添加MyBatis Plus的配置，如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">typeAliasesPackage:</span> <span class="string">com.example.demo.entity</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">column-underscore:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><p>在这里，typeAliasesPackage是指实体类所在的包，mapperLocations是指MyBatis mapper XML文件的位置，global-config是MyBatis Plus的全局配置，在这里修改了ID的生成策略和开启了下划线到驼峰命名的自动转换。</p><p>然后，可以像平常一样编写MyBatis mapper XML文件和DAO接口，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- demo.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.dao.DemoDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.demo.entity.DemoEntity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listByParam&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from demo</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> and name = #&#123;name&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span> and age = #&#123;age&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的SQL语句... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DemoDAO.java</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoDAO</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;DemoEntity&gt; &#123;</span><br><span class="line">    List&lt;DemoEntity&gt; <span class="title function_">listByParam</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写DAO接口时，可以继承MyBatis Plus提供的BaseMapper&lt; T &gt;接口，该接口提供了许多便捷的CRUD方法。此外，也可以编写自定义SQL语句，既具有MyBatis的灵活性，又能充分利用MyBatis Plus提供的便利性。</p><p>最后，在使用DAO接口时，可以像平常一样使用Spring的@Autowired注解来注入DAO对象，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DemoDAO demoDAO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;DemoEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>).eq(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    demoDAO.selectList(queryWrapper);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 使用查询到的数据进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis Plus提供了许多易用的API，通过使用它们可以大大提升代码的开发效率。</p><h5 id="配置resources"><a href="#配置resources" class="headerlink" title="配置resources"></a>配置resources</h5><ol><li>添加datasource<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisplus?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">?</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">?</span></span><br></pre></td></tr></table></figure><h5 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上图为例</span></span><br><span class="line">ackage domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="comment">//这里用到了lombok，后续会讲</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><table><thead><tr><th>操作类型</th><th>方法调用示例</th><th>SQL示例</th></tr></thead><tbody><tr><td>插入操作</td><td><code>mapper.insert(entity);</code></td><td><code>INSERT INTO table (column1, column2, ...) VALUES (?, ?, ...);</code></td></tr><tr><td>更新操作</td><td><code>mapper.updateById(entity);</code></td><td><code>UPDATE table SET column1=?, column2=?, ... WHERE id=?;</code></td></tr><tr><td>删除操作</td><td><code>mapper.deleteById(1);</code></td><td><code>DELETE FROM table WHERE id=?;</code></td></tr><tr><td>查询单个对象</td><td><code>mapper.selectById(1);</code></td><td><code>SELECT * FROM table WHERE id=?;</code></td></tr><tr><td>查询多个对象</td><td><code>mapper.selectList(null);</code></td><td><code>SELECT * FROM table;</code></td></tr><tr><td>条件查询</td><td><code>mapper.selectList(queryWrapper);</code></td><td><code>SELECT * FROM table WHERE column1=value1 AND column2&gt;value2;</code></td></tr><tr><td>分页查询</td><td><code>mapper.selectPage(page, queryWrapper);</code></td><td><code>SELECT COUNT(1) FROM table; SELECT * FROM table WHERE column1=value1 LIMIT startIndex, pageSize;</code></td></tr></tbody></table><h3 id="实体类开发工具lombok"><a href="#实体类开发工具lombok" class="headerlink" title="实体类开发工具lombok"></a>实体类开发工具lombok</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依赖导入</span></span><br><span class="line">&lt;!-- Lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.18</span><span class="number">.20</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>以下是 Lombok 常用的注解和对应的方法：</p><table><thead><tr><th>注解</th><th>解释</th><th>方法示例</th></tr></thead><tbody><tr><td>@Data</td><td>自动生成各种方法，包括 getter/setter/toString/hashCode/equals</td><td><code>@Data class T &#123;private String name;&#125;</code></td></tr><tr><td>@Getter/@Setter</td><td>自动生成 getter/setter 方法</td><td><code>@Getter @Setter private String name;</code></td></tr><tr><td>@ToString</td><td>自动生成 toString 方法</td><td><code>@ToString(of = &#123;&quot;name&quot;, &quot;age&quot;&#125;) class T &#123;private String name; private int age;&#125;</code></td></tr><tr><td>@EqualsAndHashCode</td><td>自动生成 hashCode 和 equals 方法</td><td><code>@EqualsAndHashCode(of = &#123;&quot;name&quot;, &quot;age&quot;&#125;) class T &#123;private String name; private int age;&#125;</code></td></tr><tr><td>@NoArgsConstructor</td><td>自动生成无参构造方法</td><td><code>@NoArgsConstructor class T &#123;&#125;</code></td></tr><tr><td>@RequiredArgsConstructor</td><td>自动生成必须参数的构造方法</td><td><code>@RequiredArgsConstructor class T &#123; private final String name; private final int age; &#125;</code></td></tr><tr><td>@AllArgsConstructor</td><td>自动生成全参构造方法</td><td><code>@AllArgsConstructor class T &#123; private String name; private int age; &#125;</code></td></tr><tr><td>@Builder</td><td>自动生成建造者模式方法，用于链式调用</td><td><code>@Builder class T &#123;private String name; private int age;&#125;</code></td></tr><tr><td>@Slf4j</td><td>自动生成 log 变量，方便日志输出</td><td><code>@Slf4j class T &#123;private static final Logger log = LoggerFactory.getLogger(T.class);&#125;</code></td></tr></tbody></table><p>使用 Lombok 可以大大简化 POJO 类编写的过程。不需要手动编写重复的 getter/setter/toString/hashCode/equals 等方法，可以提高开发效率。同时，Builder 注解生成的建造者模式方法可以使代码更加简洁易读。</p><h3 id="标准分页功能"><a href="#标准分页功能" class="headerlink" title="标准分页功能"></a>标准分页功能</h3><h4 id="boot配置日志开启"><a href="#boot配置日志开启" class="headerlink" title="boot配置日志开启"></a>boot配置日志开启</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line"> configuration:</span><br><span class="line">  log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>下面是 <code>IPage&lt;T&gt;</code> 接口中常用的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>List&lt;T&gt; getRecords()</code></td><td>获取当前页数据</td></tr><tr><td><code>long getTotal()</code></td><td>获取总记录数</td></tr><tr><td><code>IPage&lt;T&gt; setTotal(long total)</code></td><td>设置总记录数，并返回当前对象</td></tr><tr><td><code>long getSize()</code></td><td>获取当前页大小</td></tr><tr><td><code>IPage&lt;T&gt; setSize(long size)</code></td><td>设置当前页大小，并返回当前对象</td></tr><tr><td><code>long getCurrent()</code></td><td>获取当前页数</td></tr><tr><td><code>IPage&lt;T&gt; setCurrent(long current)</code></td><td>设置当前页数，并返回当前对象</td></tr><tr><td><code>long getPages()</code></td><td>获取总页数</td></tr><tr><td><code>IPage&lt;T&gt; setPages(long pages)</code></td><td>设置总页数，并返回当前对象</td></tr><tr><td><code>List&lt;OrderItem&gt; orders()</code></td><td>获取排序字段信息</td></tr><tr><td><code>IPage&lt;T&gt; setOrders(List&lt;OrderItem&gt; orders)</code></td><td>设置排序字段信息，并返回当前对象</td></tr><tr><td><code>boolean optimizeCountSql()</code></td><td>是否进行 count SQL 优化</td></tr><tr><td><code>IPage&lt;T&gt; setOptimizeCountSql(boolean optimizeCountSql)</code></td><td>设置 count SQL 优化标识，并返回当前对象</td></tr><tr><td><code>boolean isSearchCount()</code></td><td>是否进行 count SQL 查询</td></tr><tr><td><code>IPage&lt;T&gt; setSearchCount(boolean isSearchCount)</code></td><td>设置 count SQL 查询标识，并返回当前对象</td></tr><tr><td><code>Map&lt;String, Object&gt; condition()</code></td><td>获取查询条件信息</td></tr><tr><td><code>IPage&lt;T&gt; setCondition(Map&lt;String, Object&gt; condition)</code></td><td>设置查询条件信息，并返回当前对象</td></tr><tr><td><code>List&lt;T&gt; getRecords(boolean optimizeCountSql, boolean isSearchCount)</code></td><td>获取当前页数据，并选择是否进行 count SQL 优化和 count SQL 查询</td></tr><tr><td><code>IPage&lt;T&gt; convert(Function&lt;? super T, ? extends U&gt; converter)</code></td><td>转换当前 <code>IPage&lt;T&gt;</code> 为 <code>IPage&lt;U&gt;</code></td></tr></tbody></table><h4 id="MP拦截器"><a href="#MP拦截器" class="headerlink" title="MP拦截器"></a>MP拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于一个插件功能，但是不实现的话就可能实现不了分页功能</span></span><br><span class="line"><span class="keyword">package</span> com.example.mybatisplus.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mpInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义MP拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mpInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2.添加具体拦截器</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同样能够实现上面的方法</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sql语句打印配置，运行日志"><a href="#sql语句打印配置，运行日志" class="headerlink" title="sql语句打印配置，运行日志"></a>sql语句打印配置，运行日志</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h4 id="杀掉多余得数据显示"><a href="#杀掉多余得数据显示" class="headerlink" title="杀掉多余得数据显示"></a>杀掉多余得数据显示</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">logback.xml</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//在Spring工程生成原生得xml进行配置</span><br><span class="line">  global-config:</span><br><span class="line">    banner: false</span><br><span class="line">  main:</span><br><span class="line">    banner-mode: off</span><br></pre></td></tr></table></figure><h3 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h3><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li>MyBatisPlus将书写复杂的SQL查询条件进行封装<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230504224141560.png" alt="image-20230504224141560"></li><li>其中Wrapper&lt; T &gt;就是对查询条件的封装</li></ul><h4 id="添加QueryWrapper对象"><a href="#添加QueryWrapper对象" class="headerlink" title="添加QueryWrapper对象"></a>添加QueryWrapper对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">qw.lt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>解释</th></tr></thead><tbody><tr><td><code>eq()</code></td><td>等于</td></tr><tr><td><code>ne()</code></td><td>不等于</td></tr><tr><td><code>gt()</code></td><td>大于</td></tr><tr><td><code>ge()</code></td><td>大于等于</td></tr><tr><td><code>lt()</code></td><td>小于</td></tr><tr><td><code>le()</code></td><td>小于等于</td></tr><tr><td><code>between()</code></td><td>在两个值之间</td></tr><tr><td><code>notBetween()</code></td><td>不在两个值之间</td></tr><tr><td><code>like()</code></td><td>模糊查询</td></tr><tr><td><code>notLike()</code></td><td>不匹配某个值的模糊查询</td></tr><tr><td><code>isNull()</code></td><td>为空</td></tr><tr><td><code>isNotNull()</code></td><td>不为空</td></tr><tr><td><code>in()</code></td><td>包含在某个集合中</td></tr><tr><td><code>notIn()</code></td><td>不包含在某个集合中</td></tr><tr><td><code>groupBy()</code></td><td>分组</td></tr><tr><td><code>orderByAsc()</code></td><td>升序排序</td></tr><tr><td><code>orderByDesc()</code></td><td>降序排序</td></tr></tbody></table><h4 id="lambda格式按条件查询"><a href="#lambda格式按条件查询" class="headerlink" title="lambda格式按条件查询"></a>lambda格式按条件查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其一</span></span><br><span class="line">QueryWrapper&lt; User &gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt; User &gt;();</span><br><span class="line">qw.lamda().lt(User::getAge,<span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其二</span></span><br><span class="line">LambadQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">qw.lambda().lt(User::getAge,<span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h4 id="null值处理"><a href="#null值处理" class="headerlink" title="null值处理"></a>null值处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserQuery</span> <span class="variable">uq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserQuery</span>();</span><br><span class="line">uq.setAge2(<span class="number">30</span>);</span><br><span class="line">lqw.lt(<span class="literal">null</span>!=uq.getAge2,User::getAge,uq.getAge2());</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h3 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通</span></span><br><span class="line">QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">lqw.select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LanbdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">lqw.select(User::getId,User::getName,User::getAge);</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure><h3 id="查询投影-1"><a href="#查询投影-1" class="headerlink" title="查询投影"></a>查询投影</h3><p>MyBatisPlus 查询投影是一种查询方式，主要用于查询部分实体类属性（字段），而不是整个实体类的所有属性。它提高了查询效率，并减少了网络传输和内存消耗。下面是 MyBatisPlus 查询投影的总结：</p><ol><li><p>查询投影可以通过在实体类中定义一个 VO（View Object）类来实现。这个 VO 类只包含我们需要查询的那些属性，而不是整个实体类。</p></li><li><p>MyBatisPlus 提供了多种查询方式来实现投影查询，包括普通查询、条件构造器查询、Lambda 表达式查询等。</p></li><li><p>在使用 MyBatisPlus 进行查询时，可以使用 <code>selectOne()</code>、<code>selectList()</code>、<code>selectMaps()</code> 等方法实现投影查询。</p></li><li><p>在投影查询中，我们可以使用 <code>select()</code> 方法指定要查询的字段，也可以使用 <code>excludeColumns()</code> 方法排除要查询的字段。</p></li><li><p>投影查询可以使用 <code>@SqlParser(filter = true)</code> 注解来关闭逻辑删除功能。这个注解告诉 MyBatisPlus 不要将逻辑删除的行返回给查询结果列表。</p></li><li><p>对于投影查询结果的处理方式，我们可以选择将结果直接映射到实体类中，或者将结果映射到 Map 对象中。</p></li></ol><h3 id="查询条件设置"><a href="#查询条件设置" class="headerlink" title="查询条件设置"></a>查询条件设置</h3><p>MyBatisPlus 提供了多种设置查询条件的方式，以下是 MyBatisPlus 查询条件设置的总结：</p><ol><li><p>使用实体类作为查询条件。MyBatisPlus 可以自动地将实体类中的非空字段作为查询条件生成 SQL 语句，并将查询结果映射到实体类中。如果存在多个非空字段，它们之间的默认关系是 <code>AND</code>，可以通过注解方式更改其关系为 <code>OR</code>。</p></li><li><p>使用 <code>Wrapper</code> 对象作为查询条件。<code>Wrapper</code> 类是 MyBatisPlus 提供的一种条件构造器，它可以实现 SQL 语句中常见的条件设置操作，例如 <code>eq()</code>（等于）、<code>ne()</code>（不等于）、<code>like()</code>（模糊查询）等。可以使用 Lambda 表达式来构造 <code>Wrapper</code> 对象，也可以直接使用传统的 SQL 片段。</p></li><li><p>使用 <code>QueryWrapper</code> 类作为查询条件。<code>QueryWrapper</code> 是 MyBatisPlus 提供的一种常用条件构造器，可以用于设置 <code>WHERE</code> 条件、排序条件、分组条件等。它支持的查询方式比 <code>Wrapper</code> 更加灵活，例如支持 <code>in()</code>（包含）、<code>between()</code>（在两个值之间）等操作。</p></li><li><p>使用 <code>UpdateWrapper</code> 类作为更新条件。<code>UpdateWrapper</code> 可以用于设置 <code>SET</code> 条件，与 <code>QueryWrapper</code> 类似，也支持 Lambda 表达式和传统的 SQL 片段。</p></li><li><p>使用 <code>LambdaQueryWrapper</code>、<code>LambdaUpdateWrapper</code> 等 Lambda 类型的查询方式，实现更加简洁的条件设置，例如 <code>lambdaQuery().eq(User::getId, 1)</code>。</p></li></ol><h3 id="映射匹配兼容性"><a href="#映射匹配兼容性" class="headerlink" title="映射匹配兼容性"></a>映射匹配兼容性</h3><p>MyBatisPlus 映射匹配兼容性主要指 MyBatisPlus 在进行映射操作时，与传统 MyBatis XML 映射文件的兼容性问题。以下是 MyBatisPlus 映射匹配兼容性的总结：</p><ol><li><p>MyBatisPlus 支持与传统 MyBatis XML 映射文件共存，并且支持使用 <code>@MapperScan</code> 注解扫描所有的 Mapper 接口。</p></li><li><p>MyBatisPlus 中内置了多种自动映射配置方式，包括 <code>AUTO</code>（自动按列名匹配）、<code>FULL</code>（自动映射所有实体属性）、<code>NONE</code>（不进行自动映射）等。</p></li><li><p>MyBatisPlus 还支持自定义类型处理器、全局配置、实体类表名映射、字段名映射等灵活的映射配置方式。</p></li><li><p>在使用 MyBatisPlus 进行开发时，需要注意一些 XML 映射文件中的配置不能与 MyBatisPlus 的自动映射方式冲突，例如 <code>resultMap</code>、<code>association</code>、<code>collection</code> 等配置，需要进行合理的调整。</p></li><li><p>对于一些特殊场景，例如需要进行多表关联查询、复杂的查询构造，或者需要使用 MyBatis 动态 SQL 等功能时，可以继续使用传统的 XML 映射文件进行开发。</p></li></ol><table><thead><tr><th>注解名称</th><th>说明</th><th>应用举例</th></tr></thead><tbody><tr><td><code>@TableId</code></td><td>主键字段的映射注解，用于标注实体类中主键字段</td><td><code>@TableId(value = &quot;id&quot;, type = IdType.AUTO)</code> 表示将 <code>id</code> 字段设置为自增长主键</td></tr><tr><td><code>@TableField</code></td><td>字段映射注解，在实体类字段上使用，用于设置字段与数据库表中列的映射关系</td><td><code>@TableField(value = &quot;name&quot;, exist = true, update = &quot;false&quot;)</code> 表示将 <code>name</code> 字段映射到数据库表的 <code>name</code> 列上，且为非更新字段</td></tr><tr><td><code>@TableName</code></td><td>表名映射注解，用于标注实体类对应的数据库表名</td><td><code>@TableName(&quot;user&quot;)</code> 表示将实体类 <code>User</code> 映射到数据库表 <code>user</code> 上</td></tr><tr><td><code>@KeySequence</code></td><td>序列映射注解，用于标注主键对应的序列名称</td><td><code>@KeySequence(value = &quot;myseq&quot;, clazz = Integer.class)</code> 表示将主键对应的序列名称设为 <code>myseq</code>，并指定序列类型为 <code>Integer</code></td></tr></tbody></table><h3 id="id生成策略"><a href="#id生成策略" class="headerlink" title="id生成策略"></a>id生成策略</h3><table><thead><tr><th>ID 生成策略</th><th>说明</th></tr></thead><tbody><tr><td><code>ASSIGN_ID</code></td><td>自定义 ID 生成器，需要在代码中自行生成 ID 值</td></tr><tr><td><code>ASSIGN_UUID</code></td><td>UUID 生成器，使用 JDK 自带的 <code>UUID.randomUUID()</code> 方法生成 UUID</td></tr><tr><td><code>ASSIGN_ID_WORKER</code></td><td>雪花算法 ID 生成器，使用 Twitter 的 Snowflake 算法生成全局唯一的 ID</td></tr><tr><td><code>IDENTITY</code></td><td>基于数据库的自增长 ID 生成器，数据库类型需要支持自增长</td></tr><tr><td><code>NONE</code></td><td>未设置 ID 生成器</td></tr><tr><td><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230506120115982.png" alt="image-20230506120115982"></td><td></td></tr></tbody></table><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法（Snowflake）是一种唯一ID生成算法。它由Twitter公司开发，用于生成全局唯一的ID。雪花算法的核心思想是在64位的ID中，对不同的部分按照规定的位数进行位移和组合，并使用timestamp作为序列的一部分，可以保证生成的ID全局唯一，且越小的timestamp的序列号越小。</p><p>雪花算法的ID格式如下：</p><p>其中：</p><p>第1位（最高位）未使用，可以根据需求使用，一般为0；<br>第2<del>42位表示timestamp，精确到毫秒级别，总共可以表示2^41-1个数字，约69年；<br>第43</del>52位是机器ID，用于表示生成ID的机器，最多支持2^10=1024个机器；<br>第53~64位是序列号，用于表示同一毫秒内生成的不同ID，支持每毫秒生成2^12-1个ID。<br>使用雪花算法生成的ID具有很高的性能和稳定性，适合用于分布式系统中，例如分布式ID生成、分布式锁等场景。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230506115329072.png" alt="image-20230506115329072"></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ol><li>在表中添加版本控制字段</li></ol><p>首先，需要在表中添加一个版本控制字段，例如在 User 表中添加一个 version 字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> version <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol><li>在实体类中添加版本控制字段</li></ol><p>接下来，在实体类中添加版本控制字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Version</span> <span class="comment">// 添加版本控制注解</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实体类中，需要添加 <code>@Version</code> 注解，来标识该字段为版本控制字段。</p><ol><li>在 Mapper 文件中使用乐观锁</li></ol><p>在 Mapper 文件中进行更新操作时，可以利用 MyBatisPlus 提供的 <code>@Version</code> 注解自动实现乐观锁功能。以下是一个更新 User 表的简单示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name&#125;,</span><br><span class="line">        age = #&#123;age&#125;,</span><br><span class="line">        email = #&#123;email&#125;,</span><br><span class="line">        version = version + 1</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line">      and version = #&#123;version&#125; <span class="comment">&lt;!-- 添加乐观锁判断 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MyBatisPlus代码生成器"><a href="#MyBatisPlus代码生成器" class="headerlink" title="MyBatisPlus代码生成器"></a>MyBatisPlus代码生成器</h3><p>MyBatisPlus 提供了一个便捷的代码生成器，可以通过该生成器自动生成 Entity、Mapper、Service 和 Controller 等基础代码，从而加快开发速度，提高效率。以下是 MyBatisPlus 代码生成器的简要总结：</p><ol><li>配置生成器</li></ol><p>在 <code>pom.xml</code> 文件中，添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，在 <code>application.yml</code> 或 <code>application.properties</code> 配置文件中，添加自己的数据库连接信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_name?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置代码生成器参数</li></ol><p>在项目中创建一个 <code>generator</code> 包，并创建一个 <code>CodeGenerator</code> 类，用于配置代码生成器参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码生成器相关配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">authorName</span> <span class="operator">=</span> <span class="string">&quot;your name&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] tables = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;table_name&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packagePath</span> <span class="operator">=</span> <span class="string">&quot;com.example&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据源配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_name&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        gc.setAuthor(authorName);</span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);</span><br><span class="line">        gc.setEntityName(<span class="string">&quot;%s&quot;</span>);</span><br><span class="line">        gc.setMapperName(<span class="string">&quot;%sMapper&quot;</span>);</span><br><span class="line">        gc.setXmlName(<span class="string">&quot;%sMapper&quot;</span>);</span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);</span><br><span class="line">        gc.setServiceImplName(<span class="string">&quot;%sServiceImpl&quot;</span>);</span><br><span class="line">        gc.setControllerName(<span class="string">&quot;%sController&quot;</span>);</span><br><span class="line">        gc.setSwagger2(<span class="literal">false</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(url);</span><br><span class="line">        dsc.setDriverName(driverName);</span><br><span class="line">        dsc.setUsername(username);</span><br><span class="line">        dsc.setPassword(password);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        pc.setParent(packagePath);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setXml(<span class="string">&quot;mapper.xml&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">&quot;service.impl&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        strategy.setTablePrefix(<span class="string">&quot;t_&quot;</span>);</span><br><span class="line">        strategy.setInclude(tables);</span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行生成</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们可以通过配置相关参数来指定生成器的输出路径、作者名、表名、数据源信息、包路径、策略配置等。在执行 <code>AutoGenerator</code> 对象的 <code>execute()</code> 方法后，MyBatisPlus 就会自动生成相应的 Entity、Mapper、Service 和 Controller 等基础代码，生成的文件都可以在指定的输出路径中找到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MyBatis-Plus&quot;&gt;&lt;a href=&quot;#MyBatis-Plus&quot; class=&quot;headerlink&quot; title=&quot;MyBatis Plus&quot;&gt;&lt;/a&gt;MyBatis Plus&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Study-Note/"/>
    
    <category term="开发工具" scheme="https://kalyan-zitiu.github.io/categories/Study-Note/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="开发工具" scheme="https://kalyan-zitiu.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>2023425</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/25/2023425%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/25/2023425%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-25T08:50:04.000Z</published>
    <updated>2023-08-12T07:41:43.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="身高排序"><a href="#身高排序" class="headerlink" title="身高排序"></a>身高排序</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组names,和一个由<strong>互不相同</strong> 的正整数组成的数组heights.两个数组的长度均为n.对每个下标 i,name[i]和heights[i] 表示第i个人的名字和身高.降序返回对应的名字数组names.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在 HashMap 中存储了身高和人名信息。接下来，利用 entrySet() 方法获取映射关系集合，并将这个集合转换成 List 类型的 entryList。接着调用了 Collections.sort() 方法来对 entryList 进行排序。通过 getKey() 和 getValue() 方法分别获取身高和人名信息，最终按照从小到大排序存储到字符串数组 result 中并返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] sortPeople(String[] names, <span class="type">int</span>[] heights) &#123;</span><br><span class="line">    HashMap&lt;Integer,String&gt; storage = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> names.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        storage.put(Integer.valueOf(heights[i]),names[i]);  <span class="comment">// 将身高和对应的人名信息存储到 HashMap 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序 HashMap，输出结果</span></span><br><span class="line">    List&lt;Map.Entry&lt;Integer, String&gt;&gt; entryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;Integer, String&gt;&gt;(storage.entrySet());</span><br><span class="line">    Collections.sort(entryList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, String&gt; o1, Map.Entry&lt;Integer, String&gt; o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.getKey() - o1.getKey();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    String[] result = <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : entryList) &#123;</span><br><span class="line">        result[i++] = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections是怎么对List里面的Map进行排序的"><a href="#Collections是怎么对List里面的Map进行排序的" class="headerlink" title="Collections是怎么对List里面的Map进行排序的."></a>Collections是怎么对List里面的Map进行排序的.</h2><ol><li>Collections.sort()方法可以对实现Comparable接口或使用自定义比较器Comparator的类进行排序.由于List中的元素是Map,我们需要使用Comparator来指定排序规则.<br>如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map1.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">map1.put(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">listMap.add(map1);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">map2.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line">listMap.add(map2);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map3.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">map3.put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">listMap.add(map3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匿名内部类 Comparator 进行排序</span></span><br><span class="line">Collections.sort(listMap, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map&lt;String, Object&gt; o1, Map&lt;String, Object&gt; o2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> (<span class="type">int</span>) o1.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age2</span> <span class="operator">=</span> (<span class="type">int</span>) o2.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age1 - age2; <span class="comment">// 正序排列</span></span><br><span class="line">        <span class="comment">// return age2 - age1; // 倒序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">for</span> (Map&lt;String, Object&gt; map : listMap) &#123;</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;：&quot;</span> + map.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="Exercises" scheme="https://kalyan-zitiu.github.io/categories/Exercises/"/>
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模型-结构型模式</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</id>
    <published>2023-04-24T14:00:00.000Z</published>
    <updated>2023-04-24T14:20:27.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-结构型模式"><a href="#设计模式-结构型模式" class="headerlink" title="设计模式-结构型模式"></a>设计模式-结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</li><li>适配器模式，定义一个包装类，用于包装不兼容接口的对象</li><li>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。适配器的模式的形式分别：为类的适配器和对象的适配器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包装类=适配器Adapter</span><br><span class="line">被包装类对象 = 适配器Adaptee = 被适配的类</span><br></pre></td></tr></table></figure></li></ul><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>原版由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>透明简单，客户端可以调用同一个接口，因而对客户端来说是透明的</li><li>复用性，需要实现现有的类，此类的接口不符合系统的需要，那么通过适配器模式可以让这些功能得到更好的复用</li><li>扩展性，实现适配器功能的时候，通过调用自己开发的功能，从而自然的扩展系统的功能</li><li>解耦性，将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改源码</li><li>符合开闭原则，同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改适配类。<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303272341418.png" alt="img"></p><h3 id="举例实例"><a href="#举例实例" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SpecificRequest</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPattern</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">mAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>()；</span><br><span class="line">        mAdapter.Request（）;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>过多的使用适配器会让系统非常凌乱，不易整体进行把握。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>系统需要复用现有类，而该类接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的类一起工作。</li><li>多个组件功能类似，接口不统一且可能会经常切换时候，可以使用适配器模式，使得客户端额可以统一的接口使用他们。</li></ul><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>抽象部分与它的实现部分分离，使它们都可以独立的变化。</li><li>抽取其中一个维度并使之成为独立的类层次</li><li>在某个类中添加一个指向某一属性对象的引用成员变量。</li></ul><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>组成</th><th>作用</th></tr></thead><tbody><tr><td>抽象类</td><td>定义抽象类的接口，定义了一个Implementor实现类接口的对象斌可以维护其对象</td></tr><tr><td>提炼抽象类</td><td>扩充抽象类定义的接口，通常属于具体类，实现抽象类中声明的抽象业务方法，在提炼抽象类中，能够调用在实现类接口的业务方法</td></tr><tr><td>实现类接口</td><td>这个接口不一定要与抽象类的接口完全一致，事实上这两个接口可以完全不同，可以仅仅提供基本操作，而抽象类接口可以实现更多复杂的操作。</td></tr><tr><td>具体实现类</td><td>具体实现实现类接口，在不同的具体实现类中提供基本操作的不同实现，在程序运行时候，具体实现类的对象将会替换其父类对象，提供给抽象类具体的业务操作方法。</td></tr></tbody></table><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>提高系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</li><li>有的时候类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，而且多继承的结构类中的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li></ul><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303272227473.png" alt="在这里插入图片描述"></p><h3 id="举例实例-1"><a href="#举例实例-1" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于画各种颜色的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">protected</span> ColorAPI colorAPI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDrawAPI</span><span class="params">(ColorAPI colorAPI)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.colorAPI = colorAPI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;长方形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//创建一个圆形</span></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="comment">//给圆形蓝色的颜料</span></span><br><span class="line">shape.setDrawAPI(<span class="keyword">new</span> <span class="title class_">BlueColorAPI</span>());</span><br><span class="line"><span class="comment">//上色</span></span><br><span class="line">shape.draw();</span><br><span class="line"><span class="comment">//创建一个长方形</span></span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"><span class="comment">//给长方形上红色的颜料</span></span><br><span class="line">shape1.setDrawAP(<span class="keyword">new</span> <span class="title class_">RedColorAPI</span>());</span><br><span class="line"><span class="comment">//上色</span></span><br><span class="line">shape1.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个时候客户需要一个绿色的三角形那么只需要新增一个三角形类即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">colorAPI.paint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenColorAPI</span> <span class="keyword">implements</span> <span class="title class_">ColorAPI</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;绿色&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line"><span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line">shape.setDrawAPI(<span class="keyword">new</span> <span class="title class_">GreenColorAPI</span>());</span><br><span class="line">shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li>桥接模式的引入会增加系统的理解与设计的难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计以及编程</li><li>桥接模式要求正确的识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>不改变现有对象结构的情况下，动态地给对象增加一些职责的模式，它属于对象结构型模式</li></ul><h3 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态地给一个对象扩展功能，即插即用。</li><li>通过不用装饰类以及这些装饰类的排列组合，可以实现不同效果</li><li>装饰器模式完全遵守开闭原则</li></ul><h3 id="模式组成-1"><a href="#模式组成-1" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th align="left">组成</th><th>作用</th></tr></thead><tbody><tr><td align="left">抽象构件</td><td>定义一个抽象接口以规范准备接收附加责任的对象</td></tr><tr><td align="left">具体构件</td><td>实现抽象构件，通过装饰角色为其添加一些职责</td></tr><tr><td align="left">抽象装饰</td><td>继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</td></tr><tr><td align="left">具体装饰</td><td>实现抽象装饰的相关方法，并给具体构件对象添加附加责任。</td></tr></tbody></table><h3 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303290039331.png" alt="image-20230329003915296"></p><h3 id="举例实例-2"><a href="#举例实例-2" class="headerlink" title="举例实例"></a>举例实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul><li>装饰器模式会增加许多子类，过度使用会增加程序的复杂性。<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3></li><li>为其他对象提供一种代理以控制这个对象的访问。</li></ul><h3 id="解决问题-3"><a href="#解决问题-3" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>职责清晰</li><li>高扩展，只要实现了接口，都可以用代理</li><li>智能化，动态代理。</li></ul><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202303290100829.png" alt="image-20230329010025796"></p><h3 id="举例实例-3"><a href="#举例实例-3" class="headerlink" title="举例实例"></a>举例实例</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ol><li>以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个提供了租房方法的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义租房的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RentHouse</span> <span class="keyword">implements</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租了一间房子。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租房找中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntermediaryProxy</span> <span class="keyword">implements</span> <span class="title class_">IRentHouse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IRentHouse rentHouse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntermediaryProxy</span><span class="params">(IRentHouse irentHouse)</span>&#123;</span><br><span class="line">        rentHouse = irentHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;交中介费&quot;</span>);</span><br><span class="line">        rentHouse.rentHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;中介负责维修管理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义租房</span></span><br><span class="line">        <span class="type">IRentHouse</span> <span class="variable">rentHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RentHouse</span>();</span><br><span class="line">        <span class="comment">//定义中介</span></span><br><span class="line">        <span class="type">IRentHouse</span> <span class="variable">intermediary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntermediaryProxy</span>(rentHouse);</span><br><span class="line">        <span class="comment">//中介租房</span></span><br><span class="line">        intermediary.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3>又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，他创建了对象组的树形结构<h3 id="模式组成-2"><a href="#模式组成-2" class="headerlink" title="模式组成"></a>模式组成</h3></li></ol><table><thead><tr><th>角色</th><th>解释</th></tr></thead><tbody><tr><td>抽象构件</td><td>为树叶构件和树枝构件声明公共接口，实现默认行为</td></tr><tr><td>树叶构件</td><td>没有子节点，用于继承或实现抽象构件，是树状结构最底层。</td></tr><tr><td>树枝构件</td><td>有子节点，是组合中的分支节点。</td></tr></tbody></table><h3 id="解决问题-4"><a href="#解决问题-4" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>一致处理单个对象和组合对象，无须关心处理的是单个对象还是组合对象。</li><li>容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码。</li></ul><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul><li>设计复杂，需要一定时间理清层次关系</li><li>不容易限制容器中的构件</li><li>不容易用继承的方法来增加构件的新功能</li></ul><h3 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用接口或者抽象类都可以的</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Region</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前节点下面的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知，上面下个政策一级一级的传递，一般都有一个动作方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树叶地区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafRegion</span> <span class="keyword">extends</span> <span class="title class_">Region</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeafRegion</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span> &#123;</span><br><span class="line"><span class="comment">//叶子节点没有下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span> &#123;</span><br><span class="line"><span class="comment">//叶子节点没有下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//叶子节点没有下级</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最底层的接到了通知</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树枝地区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositeRegion</span> <span class="keyword">extends</span> <span class="title class_">Region</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来盛放子节点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Region&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">        children.add(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">        children.remove(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Region <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*通知下级所有的部门，下级如果是树枝的话继续通知，这是个递归操作*/</span></span><br><span class="line">        <span class="keyword">for</span> (Region child : children) &#123;</span><br><span class="line">            child.notice();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使得这一子系统更加容易使用</li></ul><h3 id="模式组成-3"><a href="#模式组成-3" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色类型</th><th>作用解释</th></tr></thead><tbody><tr><td>外观(Facade)</td><td>封装系统底层功能，为客户端提供简单易用的接口</td></tr><tr><td>子系统类(SubSystem)</td><td>提供系统底层的具体实现细节</td></tr><tr><td>客户端(Client)</td><td>调用外观对象提供的简单接口，使用系统底层功能而无需了解其具体实现</td></tr></tbody></table><h3 id="解决问题-5"><a href="#解决问题-5" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>降低访问复杂系统的内部子系统时的复杂度，简化个护短之间的接口。</li><li>减少系统的互相依赖，提高灵活性，提高安全性。<h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3></li><li>不符合开闭原则</li></ul><h3 id="举例实现-1"><a href="#举例实现-1" class="headerlink" title="举例实现"></a>举例实现</h3><ol><li>假设你现在需要购买一台电脑，在购买这个过程中，有很多不同的步骤需要完成，如选择操作系统、购买CPU、选择显示屏尺寸等等。然而，如果你并不关心电脑内部如何工作，而只关注它的整体性能和使用方式，那么外观模式就可以被用来简化这个过程。</li></ol><p>具体地说，一个电脑厂商可能会实现一个电脑购买外观(Facade)，它将 CPU 购买、内存配置、显示器选择、操作系统安装等操作封装在一起，提供一个简单易用的接口让用户来购买电脑。对于客户端而言，只需要调用外观对象提供的购买接口就可以了，而不必了解具体的硬件和软件实现细节，大大简化了购买电脑的流程。当内部实现发生变化时，只需修改外观类即可，对客户端代码没有影响。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerPurchaseFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> Display display;</span><br><span class="line">    <span class="keyword">private</span> OS os;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComputerPurchaseFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        display = <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        os = <span class="keyword">new</span> <span class="title class_">OS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyComputer</span><span class="params">(<span class="type">int</span> cpuType, <span class="type">int</span> memorySize, <span class="type">int</span> displaySize, <span class="type">int</span> osType)</span> &#123;</span><br><span class="line">        cpu.selectCPU(cpuType);</span><br><span class="line">        memory.setMemorySize(memorySize);</span><br><span class="line">        display.selectDisplay(displaySize);</span><br><span class="line">        os.installOS(osType);</span><br><span class="line">        System.out.println(<span class="string">&quot;Your computer has been purchased!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCPU</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择不同种类的CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemorySize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置内存大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDisplay</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择不同尺寸的显示器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installOS</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">// 安装不同类型的操作系统</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerPurchaseFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerPurchaseFacade</span>();</span><br><span class="line">        facade.buyComputer(<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>为一个复杂的子系统提高逻辑支持</li><li>调用多个子系统完成逻辑</li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li>有两类对象：共享的享元对象和非共享的外部状态对象。享元对象包含内部状态和外部状态两部分，其中内部状态是不变的，可以被多个享元对象共享；外部状态是变化的，不能被共享，每个对象都需要单独维护。</li><li>将原本需要大量创建的相似对象合并为较少的共享对象，这样可以节省内存空间，并提高程序的运行效率。</li></ul><h3 id="解决问题-6"><a href="#解决问题-6" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>减少系统内部资源开销，通过对象共享，减少系统创建对象的数量，降低内存的开销</li><li>提高系统性能，减少垃圾回收机制的次数</li></ul><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><ul><li>对象共享会导致程序逻辑复杂化。原来对象自己拥有的内部状态和外部状态现在需要从外部导入。</li><li>对象共享是有限制的，即那些可以共享的对象需要满足一定的条件，否则无法实现对象的共享。</li></ul><h3 id="模式组成-4"><a href="#模式组成-4" class="headerlink" title="模式组成"></a>模式组成</h3><table><thead><tr><th>角色类型</th><th>作用解释</th></tr></thead><tbody><tr><td>抽象享元角色（Flyweight）</td><td>定义享元对象的接口及需要缓存的数据，充当所有具体享元类的基类。</td></tr><tr><td>具体享元角色（ConcreteFlyweight）</td><td>实现抽象享元角色所定义的接口，同时需要为内部状态增加存储空间。并且可以接受外部状态（容易变化的状态），并根据外部状态进行相应的业务逻辑处理。</td></tr><tr><td>非共享具体享元角色（UnsharedConcreteFlyweight）</td><td>通常不会出现单独的非共享具体享元角色，因为非共享具体享元角色与单纯的享元模式没有什么区别。</td></tr><tr><td>享元工厂角色（FlyweightFactory）</td><td>提供一个用于管理享元对象的工厂类。主要用于享元对象的创建和缓存，实现对象的复用，减少对象的创建次数，节省内存空间。</td></tr><tr><td>客户端角色（Client）</td><td>通过享元工厂角色获取具体的享元角色，并访问具体享元角色中的相关业务方法。</td></tr></tbody></table><h3 id="举例实现-2"><a href="#举例实现-2" class="headerlink" title="举例实现"></a>举例实现</h3><ol><li>我们正在开发一个棋类游戏，游戏中有大量的棋子需要被使用。不同的棋子有不同的颜色和形状，但是棋子的功能（如移动、吃子等）都是一样的。我们可以复用相同颜色和形状的棋子对象，避免重复创建棋子导致内存资源的浪费，提高系统的性能。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋子的共享接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护了颜色和形状的内部状态，位置等可变状态外部传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteChessPiece</span> <span class="keyword">implements</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String shape;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteChessPiece</span><span class="params">(String color, String shape)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Set position for %s %s chess to (%d,%d)&quot;</span>, color, shape, x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Draw %s %s chess&quot;</span>, color, shape));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理棋子对象并进行复用。</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChessPiece <span class="title function_">getChessPiece</span><span class="params">(String color, String shape)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> color + shape;</span><br><span class="line">        <span class="keyword">if</span> (chessPieces.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chessPieces.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ChessPiece</span> <span class="variable">piece</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteChessPiece</span>(color, shape);</span><br><span class="line">            chessPieces.put(key, piece);</span><br><span class="line">            <span class="keyword">return</span> piece;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">ChessPiece</span> <span class="variable">piece</span> <span class="operator">=</span> ChessPieceFactory.getChessPiece(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;circle&quot;</span>);</span><br><span class="line">    piece.setPosition(i, <span class="number">0</span>);</span><br><span class="line">    piece.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-结构型模式&quot;&gt;&lt;a href=&quot;#设计模式-结构型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-结构型模式&quot;&gt;&lt;/a&gt;设计模式-结构型模式&lt;/h1&gt;&lt;h2 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;he</summary>
      
    
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kalyan的训练计划</title>
    <link href="https://kalyan-zitiu.github.io/2023/04/20/Kalyan%E7%9A%84%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/"/>
    <id>https://kalyan-zitiu.github.io/2023/04/20/Kalyan%E7%9A%84%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-20T04:30:34.000Z</published>
    <updated>2023-04-23T13:49:57.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="胸"><a href="#胸" class="headerlink" title="胸"></a>胸</h2><h3 id="训练计划"><a href="#训练计划" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210444548.png" alt="image-20230423210444548"></p><h3 id="蝴蝶肌夹胸"><a href="#蝴蝶肌夹胸" class="headerlink" title="蝴蝶肌夹胸"></a>蝴蝶肌夹胸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002229315.png" alt="image-20230423002229315"></p><h3 id="平板卧推"><a href="#平板卧推" class="headerlink" title="平板卧推"></a>平板卧推</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002522177.png" alt="image-20230423002522177"></p><h3 id="上斜哑铃飞鸟"><a href="#上斜哑铃飞鸟" class="headerlink" title="上斜哑铃飞鸟"></a>上斜哑铃飞鸟</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002305022.png" alt="image-20230423002305022"></p><h3 id="杠铃上斜卧推"><a href="#杠铃上斜卧推" class="headerlink" title="杠铃上斜卧推"></a>杠铃上斜卧推</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423002830127.png" alt="image-20230423002830127"></p><h3 id="龙门架夹下胸"><a href="#龙门架夹下胸" class="headerlink" title="龙门架夹下胸"></a>龙门架夹下胸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423003136604.png" alt="image-20230423003136604"></p><h3 id="双杠臂屈伸"><a href="#双杠臂屈伸" class="headerlink" title="双杠臂屈伸"></a>双杠臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423003029827.png" alt="image-20230423003029827"></p><h2 id="背"><a href="#背" class="headerlink" title="背"></a>背</h2><h3 id="训练计划-1"><a href="#训练计划-1" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210334836.png" alt="image-20230423210334836"></p><h3 id="高位下拉"><a href="#高位下拉" class="headerlink" title="高位下拉"></a>高位下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423164327463.png" alt="image-20230423164327463"></p><h3 id="坐姿划船"><a href="#坐姿划船" class="headerlink" title="坐姿划船"></a>坐姿划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205735398.png" alt="image-20230423205735398"></p><h3 id="直臂下拉"><a href="#直臂下拉" class="headerlink" title="直臂下拉"></a>直臂下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205851519.png" alt="image-20230423205851519"></p><h3 id="窄距高位下拉"><a href="#窄距高位下拉" class="headerlink" title="窄距高位下拉"></a>窄距高位下拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423205942885.png" alt="image-20230423205942885"></p><h3 id="俯身划船"><a href="#俯身划船" class="headerlink" title="俯身划船"></a>俯身划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210151270.png" alt="image-20230423210151270"></p><h3 id="宽距坐姿划船"><a href="#宽距坐姿划船" class="headerlink" title="宽距坐姿划船"></a>宽距坐姿划船</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210236422.png" alt="image-20230423210236422"></p><h2 id="腿"><a href="#腿" class="headerlink" title="腿"></a>腿</h2><h3 id="训练计划-2"><a href="#训练计划-2" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211817734.png" alt="image-20230423211817734"></p><h3 id="坐姿腿屈伸"><a href="#坐姿腿屈伸" class="headerlink" title="坐姿腿屈伸"></a>坐姿腿屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210829948.png" alt="image-20230423210829948"></p><h3 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423210950628.png" alt="image-20230423210950628"></p><h3 id="倒蹬机腿举"><a href="#倒蹬机腿举" class="headerlink" title="倒蹬机腿举"></a>倒蹬机腿举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211530323.png" alt="image-20230423211530323"></p><h3 id="俯卧腿弯举（腰部不用力，屁股不撅）"><a href="#俯卧腿弯举（腰部不用力，屁股不撅）" class="headerlink" title="俯卧腿弯举（腰部不用力，屁股不撅）"></a>俯卧腿弯举（腰部不用力，屁股不撅）</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423211715526.png" alt="image-20230423211715526"></p><h2 id="肩"><a href="#肩" class="headerlink" title="肩"></a>肩</h2><h3 id="训练计划-3"><a href="#训练计划-3" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212631090.png" alt="image-20230423212631090"></p><h3 id="史密斯推肩"><a href="#史密斯推肩" class="headerlink" title="史密斯推肩"></a>史密斯推肩</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212110581.png" alt="image-20230423212110581"></p><h3 id="哑铃侧平举"><a href="#哑铃侧平举" class="headerlink" title="哑铃侧平举"></a>哑铃侧平举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212222249.png" alt="image-20230423212222249"></p><h3 id="蝴蝶机反向飞鸟"><a href="#蝴蝶机反向飞鸟" class="headerlink" title="蝴蝶机反向飞鸟"></a>蝴蝶机反向飞鸟</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212320016.png" alt="image-20230423212320016"></p><h3 id="绳索前平举"><a href="#绳索前平举" class="headerlink" title="绳索前平举"></a>绳索前平举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212411999.png" alt="image-20230423212411999"></p><h3 id="绳索面拉"><a href="#绳索面拉" class="headerlink" title="绳索面拉"></a>绳索面拉</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212537833.png" alt="image-20230423212537833"></p><h2 id="小臂"><a href="#小臂" class="headerlink" title="小臂"></a>小臂</h2><h3 id="训练计划-4"><a href="#训练计划-4" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213030936.png" alt="image-20230423213030936"></p><h3 id="哑铃手腕弯举"><a href="#哑铃手腕弯举" class="headerlink" title="哑铃手腕弯举"></a>哑铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212818644.png" alt="image-20230423212818644"></p><h3 id="反向哑铃手腕弯举"><a href="#反向哑铃手腕弯举" class="headerlink" title="反向哑铃手腕弯举"></a>反向哑铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212903715.png" alt="image-20230423212903715"></p><h3 id="站姿体后杠铃手腕弯举"><a href="#站姿体后杠铃手腕弯举" class="headerlink" title="站姿体后杠铃手腕弯举"></a>站姿体后杠铃手腕弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423212958122.png" alt="image-20230423212958122"></p><h2 id="二三头"><a href="#二三头" class="headerlink" title="二三头"></a>二三头</h2><h3 id="训练计划-5"><a href="#训练计划-5" class="headerlink" title="训练计划"></a>训练计划</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423214003078.png" alt="image-20230423214003078"></p><h3 id="杠铃弯举"><a href="#杠铃弯举" class="headerlink" title="杠铃弯举"></a>杠铃弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213308228.png" alt="image-20230423213308228"></p><h3 id="直杠臂屈伸"><a href="#直杠臂屈伸" class="headerlink" title="直杠臂屈伸"></a>直杠臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213746793.png" alt="image-20230423213746793"></p><h3 id="哑铃颈后臂屈伸"><a href="#哑铃颈后臂屈伸" class="headerlink" title="哑铃颈后臂屈伸"></a>哑铃颈后臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213730391.png" alt="image-20230423213730391"></p><h3 id="牧师椅杠铃弯举"><a href="#牧师椅杠铃弯举" class="headerlink" title="牧师椅杠铃弯举"></a>牧师椅杠铃弯举</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213700395.png" alt="image-20230423213700395"></p><h3 id="绳索颈后臂屈伸"><a href="#绳索颈后臂屈伸" class="headerlink" title="绳索颈后臂屈伸"></a>绳索颈后臂屈伸</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20230423213846270.png" alt="image-20230423213846270"></p><h3 id="练前篇"><a href="#练前篇" class="headerlink" title="练前篇"></a>练前篇</h3><ul><li>训练前一小时,一勺蛋白粉</li><li>训练前半小时上氮泵和肌酸</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;胸&quot;&gt;&lt;a href=&quot;#胸&quot; class=&quot;headerlink&quot; title=&quot;胸&quot;&gt;&lt;/a&gt;胸&lt;/h2&gt;&lt;h3 id=&quot;训练计划&quot;&gt;&lt;a href=&quot;#训练计划&quot; class=&quot;headerlink&quot; title=&quot;训练计划&quot;&gt;&lt;/a&gt;训练计划&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="分享" scheme="https://kalyan-zitiu.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="训练" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
</feed>
