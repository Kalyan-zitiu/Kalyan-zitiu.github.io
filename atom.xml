<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kalyan的小书房</title>
  <icon>https://www.gravatar.com/avatar/26add54e467101c6779c59a0ed4ee504</icon>
  <subtitle>Kalyan is working hard</subtitle>
  <link href="https://kalyan-zitiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://kalyan-zitiu.github.io/"/>
  <updated>2023-01-06T07:33:07.147Z</updated>
  <id>https://kalyan-zitiu.github.io/</id>
  
  <author>
    <name>Kalyan</name>
    <email>3148862192@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Goal解析以及进阶练习</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/06/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A33/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/06/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A33/</id>
    <published>2023-01-06T07:00:04.000Z</published>
    <updated>2023-01-06T07:33:07.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="goal解析"><a href="#goal解析" class="headerlink" title="goal解析"></a>goal解析</h1><p>请你设计一个可以解释字符串 command 的 Goal 解析器 。</p><ul><li>command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。</li><li>Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</li><li>给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。</li></ul><h2 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h2><p>又是偷懒的一天，直接用库函数了</p><ol><li>需要注意的是下面的括号是要转义的，不然会识别成null。</li><li>此方法的时间复杂度会较大，个人猜测是函数内部的循环或条件语句分析相对O-题解比较复杂。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">interpret</span><span class="params">(String command)</span> &#123;</span><br><span class="line">    command = command.replace(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    command = command.replaceAll(<span class="string">&quot;\\(\\)&quot;</span>,<span class="string">&quot;o&quot;</span>);</span><br><span class="line">    command = command.replaceAll(<span class="string">&quot;\\(al\\)&quot;</span>,<span class="string">&quot;al&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li>本题只会出现”G”,”()”以及”(al)”所以不符合”（）”与”G”的条件一律可以按照”（al）”处理。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interpret</span><span class="params">(String command)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; command.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                res.append(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (command.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    res.append(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.append(<span class="string">&quot;al&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;goal解析&quot;&gt;&lt;a href=&quot;#goal解析&quot; class=&quot;headerlink&quot; title=&quot;goal解析&quot;&gt;&lt;/a&gt;goal解析&lt;/h1&gt;&lt;p&gt;请你设计一个可以解释字符串 command 的 Goal 解析器 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;comman</summary>
      
    
    
    
    <category term="leetccode" scheme="https://kalyan-zitiu.github.io/categories/leetccode/"/>
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TinyURL 的加密与解密</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/05/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A32/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/05/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A32/</id>
    <published>2023-01-05T09:40:04.000Z</published>
    <updated>2023-01-05T11:31:21.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TinyURL-的加密与解密"><a href="#TinyURL-的加密与解密" class="headerlink" title="TinyURL 的加密与解密"></a>TinyURL 的加密与解密</h1><ol><li>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> 时，它将返回一个简化的URL <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a> 。请你设计一个类来加密与解密 TinyURL 。</li></ol><ul><li>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。<br>实现 Solution 类：</li><li>Solution() 初始化 TinyURL 系统对象。</li><li>String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。</li><li>String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。</li></ul><h2 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h2><p>其实我第一时间想到的就只有异或运算而已</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> syscode(longUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> syscode(shortUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">syscode</span><span class="params">(String index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">        <span class="type">char</span> mixcode[] = index.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mixcode.length;i++)&#123;</span><br><span class="line">            mixcode[i] = (<span class="type">char</span>)(mixcode[i]^key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(mixcode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h2><h3 id="来源leetcode"><a href="#来源leetcode" class="headerlink" title="(来源leetcode)"></a>(来源leetcode)</h3><h3 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h3><p>建立哈希表，用自增的id作为URL的键，每次接收一个URL都会使id递增，从而将键值对database进行存储，然后返回带有id的字符串作为shorURL。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; dataBase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        id++;</span><br><span class="line">        dataBase.put(id, longUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> shortUrl.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> Integer.parseInt(shortUrl.substring(p));</span><br><span class="line">        <span class="keyword">return</span> dataBase.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希生成"><a href="#哈希生成" class="headerlink" title="哈希生成"></a>哈希生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">K1</span> <span class="operator">=</span> <span class="number">1117</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">K2</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; dataBase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; urlToKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (urlToKey.containsKey(longUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + urlToKey.get(longUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; longUrl.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> longUrl.charAt(i);</span><br><span class="line">            key = (<span class="type">int</span>) ((key + (<span class="type">long</span>) c * base) % K2);</span><br><span class="line">            base = (base * K1) % K2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dataBase.containsKey(key)) &#123;</span><br><span class="line">            key = (key + <span class="number">1</span>) % K2;</span><br><span class="line">        &#125;</span><br><span class="line">        dataBase.put(key, longUrl);</span><br><span class="line">        urlToKey.put(longUrl, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> shortUrl.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> Integer.parseInt(shortUrl.substring(p));</span><br><span class="line">        <span class="keyword">return</span> dataBase.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TinyURL-的加密与解密&quot;&gt;&lt;a href=&quot;#TinyURL-的加密与解密&quot; class=&quot;headerlink&quot; title=&quot;TinyURL 的加密与解密&quot;&gt;&lt;/a&gt;TinyURL 的加密与解密&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;TinyURL 是一种 URL </summary>
      
    
    
    
    <category term="leetccode" scheme="https://kalyan-zitiu.github.io/categories/leetccode/"/>
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>根据给定数字划分数组</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/03/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/03/IC-%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3/</id>
    <published>2023-01-03T10:20:04.000Z</published>
    <updated>2023-01-05T09:35:45.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据给定数字划分数组"><a href="#根据给定数字划分数组" class="headerlink" title="根据给定数字划分数组"></a>根据给定数字划分数组</h2><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你将 nums 重新排列，使得以下条件均成立：</p><ul><li>所有小于 pivot 的元素都出现在所有大于 pivot 的元素 之前 。</li><li>所有等于 pivot 的元素都出现在小于和大于 pivot 的元素 中间 。</li><li>小于 pivot 的元素之间和大于 pivot 的元素之间的 相对顺序 不发生改变。<ul><li>更正式的，考虑每一对 pi，pj ，pi 是初始时位置 i 元素的新位置，pj 是初始时位置 j 元素的新位置。对于小于 pivot 的元素，如果 i &lt; j 且 nums[i] &lt; pivot 和 nums[j] &lt; pivot 都成立，那么 pi &lt; pj 也成立。类似的，对于大于 pivot 的元素，如果 i &lt; j 且 nums[i] &gt; pivot 和 nums[j] &gt; pivot 都成立，那么 pi &lt; pj 。</li></ul></li></ul><h3 id="P-题解"><a href="#P-题解" class="headerlink" title="P-题解"></a>P-题解</h3><p>总体来说时空都是比较占优的空间损耗也不大</p><ol><li>双指针left从0开始递增以及right从数组后置位开始递减，分别用作于比较大于pivot以及小于pivot的，优点在于能够按照原本的次序在新的数组里面安排位置。</li><li>其实等于pivot可以不做比较，可以在新数组的所有元素填满pivot值，然后通过与原数组比较前后开始占位变值。</li><li>其实这里的时间复杂度应该是O（N）的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span>nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span>length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> newNum[] = <span class="keyword">new</span> <span class="title class_">int</span> [length];</span><br><span class="line">    Arrays.fill(newNum,pivot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> min=<span class="number">0</span>,max=length-<span class="number">1</span>;left&lt;length&amp;&amp;right&gt;=<span class="number">0</span>;left++,right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;pivot)&#123;</span><br><span class="line">            newNum[min++]=nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]&gt;pivot)&#123;</span><br><span class="line">            newNum[max--]=nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="O-题解"><a href="#O-题解" class="headerlink" title="O-题解"></a>O-题解</h3><h4 id="简单的三次遍历"><a href="#简单的三次遍历" class="headerlink" title="简单的三次遍历"></a>简单的三次遍历</h4><p>时间较快，空间损耗相对大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] &lt; pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] == pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (nums[i] &gt; pivot) ans[k++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="划分以及拼接"><a href="#划分以及拼接" class="headerlink" title="划分以及拼接"></a>划分以及拼接</h4><p>运行时间可以说是题解里最长的了，而且空间也不是最优秀的。可能是因为增强for循环的或者计算长度的原因，比上面多一次循环的方法时间还要久。</p><ol><li>三个数据类型为Integer的ArrayList对象，分别储存三个不同的情况的数值</li><li>计算所有List的长度，建立新的数组，增强循环来依次输入顺序数值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] pivotArray(<span class="type">int</span>[] nums, <span class="type">int</span> pivot) </span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x: nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            a.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            b.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.size() + b.size() + c.size();</span><br><span class="line">    <span class="type">int</span> [] res = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : b)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : c)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;根据给定数字划分数组&quot;&gt;&lt;a href=&quot;#根据给定数字划分数组&quot; class=&quot;headerlink&quot; title=&quot;根据给定数字划分数组&quot;&gt;&lt;/a&gt;根据给定数字划分数组&lt;/h2&gt;&lt;p&gt;给你一个下标从 0 开始的整数数组 nums 和一个整数 pivot 。请你</summary>
      
    
    
    
    <category term="leetccode" scheme="https://kalyan-zitiu.github.io/categories/leetccode/"/>
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>进程耗时计算</title>
    <link href="https://kalyan-zitiu.github.io/2023/01/01/%E8%A1%8C%E7%A8%8B%E8%80%97%E6%97%B6%E8%AE%A1%E6%97%B6/"/>
    <id>https://kalyan-zitiu.github.io/2023/01/01/%E8%A1%8C%E7%A8%8B%E8%80%97%E6%97%B6%E8%AE%A1%E6%97%B6/</id>
    <published>2023-01-01T08:45:04.000Z</published>
    <updated>2023-01-01T09:04:09.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程耗时计算"><a href="#进程耗时计算" class="headerlink" title="进程耗时计算"></a>进程耗时计算</h1><p>这是一个能够计算运行进程的包。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">fmt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String title,Task task)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (title==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        title = (title==<span class="literal">null</span>)?<span class="string">&quot;&quot;</span>:(<span class="string">&quot;【&quot;</span>+title+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">        System.out.println(title);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始:&quot;</span>+fmt.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        task.execute();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束:&quot;</span>+fmt.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="type">double</span> <span class="variable">delta</span> <span class="operator">=</span> (end - begin)/<span class="number">1000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时:&quot;</span>+delta+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>在自建的软件包内建立一个TimeTool文件。</li><li>同包导入<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 软件包名字.TimeTool.Task;</span><br></pre></td></tr></table></figure></li><li>调用方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeTool.check(<span class="string">&quot;此处填写此次进程测试的名字（随便起个名字，方便对比区分）&quot;</span>,<span class="keyword">new</span> <span class="title class_">Task</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//放入你需要测试的进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程耗时计算&quot;&gt;&lt;a href=&quot;#进程耗时计算&quot; class=&quot;headerlink&quot; title=&quot;进程耗时计算&quot;&gt;&lt;/a&gt;进程耗时计算&lt;/h1&gt;&lt;p&gt;这是一个能够计算运行进程的包。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;h</summary>
      
    
    
    
    <category term="工具" scheme="https://kalyan-zitiu.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://kalyan-zitiu.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>二叉树（持续更新中）</title>
    <link href="https://kalyan-zitiu.github.io/2022/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
    <id>https://kalyan-zitiu.github.io/2022/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0/</id>
    <published>2022-12-19T01:00:00.000Z</published>
    <updated>2022-12-19T01:02:27.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h3><p>1.把左右根交换即可</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212190900221.png" alt="image-20221219090003177"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出克隆二叉树中的相同节点"><a href="#找出克隆二叉树中的相同节点" class="headerlink" title="找出克隆二叉树中的相同节点"></a>找出克隆二叉树中的相同节点</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212051005239.png" alt="image-20221205100529196"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TreeNode <span class="title function_">getTargetCopy</span><span class="params">(<span class="keyword">final</span> TreeNode original, <span class="keyword">final</span> TreeNode cloned, <span class="keyword">final</span> TreeNode target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (original == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (original == target) <span class="keyword">return</span> cloned;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> getTargetCopy(original.left, cloned.left, target);</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> getTargetCopy(original.right, cloned.right, target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HomeWork"><a href="#HomeWork" class="headerlink" title="HomeWork"></a>HomeWork</h2><h3 id="自定义树结点"><a href="#自定义树结点" class="headerlink" title="自定义树结点"></a>自定义树结点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">char</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">char</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">char</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="1-先根序列构造二叉树：A-B-null-D-null-null-C-null-null"><a href="#1-先根序列构造二叉树：A-B-null-D-null-null-C-null-null" class="headerlink" title="1. 先根序列构造二叉树：A B null D null null C null null"></a>1. 先根序列构造二叉树：A B null D null null C null null</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个全局变量，其实缺点也会很多，对于后面的方法均需要一个计时器，还有一种就是放在方法内的局部变量，跟着方法递归增加</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//题目给的是字符串，可以用toCharArray()变换字符数组</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">CteateTree</span><span class="params">(<span class="type">char</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; arr.length) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">val</span> <span class="operator">=</span> arr[count++];</span><br><span class="line">        <span class="comment">//当val值不等于空，这里把^当成空，就把新的带有val的节点赋值给真正意义上的根节点，往后的都是左右子树</span></span><br><span class="line">        <span class="keyword">if</span> (val != <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            node.left = CteateTree(arr);</span><br><span class="line">            node.right = CteateTree(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这道题你也简单点理论上可以直接把^也带入结点,不做空值处理,起码在我这里是这样,上面的自定义树节点的基本存储数据类型是用了char.这样好像也可以节省后面遍历的空值处理问题</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对于1中生成的二叉树进行前序、中序、后序遍历。"><a href="#2-对于1中生成的二叉树进行前序、中序、后序遍历。" class="headerlink" title="2.对于1中生成的二叉树进行前序、中序、后序遍历。"></a>2.对于1中生成的二叉树进行前序、中序、后序遍历。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrderTravera(node.left);</span><br><span class="line">        preOrderTravera(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        inOrderTravera(node.left);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrderTravera(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTravera</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        postOrderTravera(node.left);</span><br><span class="line">        postOrderTravera(node.right);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-计算1中生成的二叉树结点总数。"><a href="#3-计算1中生成的二叉树结点总数。" class="headerlink" title="3. 计算1中生成的二叉树结点总数。"></a>3. 计算1中生成的二叉树结点总数。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老样子,静态全局变量,你也可以局部变量,像下面一样,充当一个计数器的作用,只需要在实例方法中输入从0开始,效果是一样的,局部变量的好处就是当你使用完方法后会释放内存,也就是会比一直存在占用内存static全局变量更节省空间.</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//思路很简单,遇到非空值计数器就+1.考虑到前面提到的^直接带入结点,这里还可能要加上值不为^</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">TreeNodeNum</span><span class="params">(TreeNode node,<span class="comment">/*，int num */</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">        TreeNodeNum(node.left);</span><br><span class="line">        TreeNodeNum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算1中生成二叉树的高度"><a href="#4-计算1中生成二叉树的高度" class="headerlink" title="4. 计算1中生成二叉树的高度"></a>4. 计算1中生成二叉树的高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目的主要问题是怎么在众多的左右子树中找出最大的根深度也就是普遍说的树高</span></span><br><span class="line"><span class="comment">//思路:递归判断,当这个结点为空的时候,则返回0,每次的递归都需要一次深度比较,找出最大的深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNode</span> <span class="operator">=</span>maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> rightNode=maxDepth(root.right);</span><br><span class="line">        <span class="comment">//这里的+1是因为是根节点并没有参与计算,因此需要+上根结点</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftNode,rightNode)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。"><a href="#5-计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。" class="headerlink" title="5.计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。"></a>5.计算1中生成二叉树中度为1的节点数、度为2的结点数和叶子数。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总的思路就是判断左右指针的三种情况即可1.均为空 2.左空右不空(左不空右空)3.均不为空</span></span><br><span class="line"><span class="comment">//叶子结点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LeafNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+LeafNodeCount(root.left)+LeafNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LeafNodeCount(root.left) + LeafNodeCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">OneNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span> || root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+OneNodeCount(root.left)+OneNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OneNodeCount(root.left) + OneNodeCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">DoubleNodeCount</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+DoubleNodeCount(root.left) + DoubleNodeCount(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DoubleNodeCount(root.left) + DoubleNodeCount(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-按照下面两个序列生成二叉树：先序：ABHFDECKG-；中序：HBDFAEKCG"><a href="#6-按照下面两个序列生成二叉树：先序：ABHFDECKG-；中序：HBDFAEKCG" class="headerlink" title="6.按照下面两个序列生成二叉树：先序：ABHFDECKG ；中序：HBDFAEKCG"></a>6.按照下面两个序列生成二叉树：先序：ABHFDECKG ；中序：HBDFAEKCG</h3><p>前序+中序构造二叉树<br>先序:根 [左子树]  [右子树]<br>中序:[左子树] 根 [右子树]</p><p>思路:只要遍历中序找到根节点,利用双指针确认左右子树遍历结果的长度,再利用先序方式构造即可</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211221135621.png" alt="image-20221122113530560"></p><p>循环寻界+递归构造树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTrees</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">char</span> [] in)</span> &#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    TreeNode root=buildTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主体</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">int</span> PreLeft,<span class="type">int</span> PreRight,<span class="type">char</span> [] in,<span class="type">int</span> inLeft,<span class="type">int</span> inRight)</span> &#123;</span><br><span class="line"><span class="comment">//如果越界则表示结点为空</span></span><br><span class="line">      <span class="keyword">if</span>(PreLeft&gt;PreRight||inLeft&gt;inRight)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//开始构造,声明新结点</span></span><br><span class="line">   TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[PreLeft]);</span><br><span class="line"><span class="comment">//循环寻找中序的根节点,还能够确认左右子树边界</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=inLeft;i&lt;=inRight;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[PreLeft])&#123;</span><br><span class="line"><span class="comment">//先序构造树,指针就定义为左右子树的区间,构造左子树             </span></span><br><span class="line">    root.left=buildTree(pre,PreLeft+<span class="number">1</span>,PreLeft+i-inLeft,in,inLeft,i-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//变化右子树边界,构造右子树</span></span><br><span class="line">     root.right=buildTree(pre,i-inLeft+PreLeft+<span class="number">1</span>,PreRight,in,i+<span class="number">1</span>,inRight);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表优化循环子过程"><a href="#哈希表优化循环子过程" class="headerlink" title="哈希表优化循环子过程"></a>哈希表优化循环子过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过程几乎与上面的方法一样，只不过不需要每次递归后又进行循环来找到边界。</span></span><br><span class="line"><span class="comment">//提前把中序的所有遍历用哈希表储存起来即可。后面的取根直接依靠对应值来寻找序号，用来定界</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTreeTwo</span><span class="params">(<span class="type">char</span> [] pre,<span class="type">char</span> [] in)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">PreLen</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">InLen</span> <span class="operator">=</span> pre.length;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(PreLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;InLen;i++)&#123;</span><br><span class="line">            map.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeTwo(pre,<span class="number">0</span>,PreLen-<span class="number">1</span>,map,<span class="number">0</span>,InLen-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTreeTwo</span><span class="params">(<span class="type">char</span>[]pre,<span class="type">int</span> PreLeft,<span class="type">int</span> PreRight,Map&lt;Character,Integer&gt; map,<span class="type">int</span> InLeft,<span class="type">int</span> InRight)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(PreLeft&gt;PreRight||InLeft&gt;InRight)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">val</span> <span class="operator">=</span> pre[PreLeft];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);</span><br><span class="line">        root.left=buildTreeTwo(pre,PreLeft+<span class="number">1</span>,index-InLeft+PreLeft,map,InLeft,index-<span class="number">1</span>);</span><br><span class="line">        root.right=buildTreeTwo(pre,index-InLeft+PreLeft+<span class="number">1</span>,PreRight,map,index+<span class="number">1</span>,InRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="栈方法迭代"><a href="#栈方法迭代" class="headerlink" title="栈方法迭代"></a>栈方法迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>[] preorder, <span class="type">char</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preorderVal</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                inorderIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="建立树节点"><a href="#建立树节点" class="headerlink" title="建立树节点"></a>建立树节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">TreeNode()&#123;&#125;</span><br><span class="line">TreeNOde(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="type">this</span> <span class="variable">val</span> <span class="operator">=</span> val;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode(<span class="type">int</span> val,TreeNode left,TreeNode right)&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.left=left;</span><br><span class="line"><span class="built_in">this</span>.right=right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">preOrderTraveral(node.left);</span><br><span class="line">preOrderTraveral(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">inOrderTraveral(node.left);</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">inOrderTraveral(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTraveral</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">postTraveral(node.left);</span><br><span class="line">postTraveral(node.right);</span><br><span class="line">System.out.print(node.data+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leverOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//声明一个队列对象</span></span><br><span class="line">        Queue&lt;TreeNode&gt; storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 根节点为空，返回空值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把结点拉入队列</span></span><br><span class="line">        storage.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!storage.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//把队列首部拉出输出值并且访问左右子树结点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> storage.poll();</span><br><span class="line">            System.out.print(cur.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//若左指针不为空，就把左子树拉入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                storage.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若右指针不为空，就把右子树拉入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">                storage.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p><a href="https://zitiu.top/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/">https://zitiu.top/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/</a></p><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><h3 id="总思路"><a href="#总思路" class="headerlink" title="总思路"></a>总思路</h3><ol><li><p>只要提到树的话就几乎都会涉及到递归和回溯.</p></li><li><p>比较常用的算法思想就是深度和广度优先搜索</p><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3></li><li><p> 这道题我的思路很简单,就是递归遍历,进行创新节点的操作</p></li><li><p>可以分三种情况</p><ul><li>两个节点均为null值</li><li>一个节点为null,一个不为null值</li><li>两个节点都不是null值</li></ul></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121621158.png" alt="image-20221112162114118"></p><p>实现1:深度优先搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">merageTrees</span><span class="params">(TreeNode r1,TreeNode r2)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(r1==<span class="literal">null</span>) <span class="keyword">return</span> r2;</span><br><span class="line">   <span class="keyword">if</span>(r2==<span class="literal">null</span>) <span class="keyword">return</span> r1;</span><br><span class="line">   <span class="type">TreeNode</span> <span class="variable">metaTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(r1.val+r2.val);</span><br><span class="line">   metaTree.left = merageTrees(r1.left,r2.left);</span><br><span class="line">   metaTree.right= merageTrees(r1.right,r2.right);</span><br><span class="line">   <span class="keyword">return</span> metaTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现2:广度优先搜索</p><ol><li>主要实现:构建三个队列分别储存3颗树的每个节点</li></ol><ul><li>每次从队列种取出一个节点,判断两个原始树的结点是否为空<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t1 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> t2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> t1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      queue.offer(merged);</span><br><span class="line">      queue1.offer(t1);</span><br><span class="line">      queue2.offer(t2);</span><br><span class="line">      <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;</span><br><span class="line">          <span class="keyword">if</span> (left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                  node.left = left;</span><br><span class="line">                  queue.offer(left);</span><br><span class="line">                  queue1.offer(left1);</span><br><span class="line">                  queue2.offer(left2);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.left = left1;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.left = left2;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                  node.right = right;</span><br><span class="line">                  queue.offer(right);</span><br><span class="line">                  queue1.offer(right1);</span><br><span class="line">                  queue2.offer(right2);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                  node.right = right1;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  node.right = right2;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121840333.png" alt="image-20221112184055309"></p><ol><li>树的递归判断</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp;q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">null</span>||q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(p.val!=q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> isSameTree(p,left,q.left)&amp;&amp;isSameTree(p.right,q.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121844717.png" alt="image-20221112184440687"></p><ol><li>基本和相同树的判断思想是一样的，只要把左右两个孩子分别当作新的结点进行比较</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span>  isSameTree(root,root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode leftnode,TreeNode rightnode)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(leftnode==<span class="literal">null</span>&amp;&amp;rightnode==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftnode==<span class="literal">null</span>||rightnode==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> leftnode.val==rightnode.val&amp;&amp;isSameTree(leftnode.left,rightnode.right)&amp;&amp;isSameTree(leftnode.right,rightnode.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211121849830.png" alt="image-20221112184924806"> </p><ol><li>思路也是十分的简单，像数组的位置变换一样，定义一个辅助变量，而这边定义一个新的树对象来储存。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思想十分像数组的辅助变量位置变换的方法</span></span><br><span class="line">       <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 声明一个新的对象，先是储存右孩子的数据</span></span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> root.right;</span><br><span class="line">           root.right = invertTree(root.left);</span><br><span class="line">           root.left = invertTree(rightTree);</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><ol><li>做法几乎于最大深度差不多，只是把max改成min罢了</li><li>但是要注意的是空节点是不需要比较的。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211131358958.png" alt="image-20221113135809932"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubilc <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.right==<span class="literal">null</span>&amp;&amp;root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+minDepth(root.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+minDepth(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><ol><li>我第一反应是一定要用到层次遍历，那么每层的结点个数我是应该怎么确定呢？</li><li> 然而实际上确实需要用到层次遍历的思想，而且还需要一个计数器</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211231913942.png" alt="image-20221123191353894"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Double&gt; storage = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">       Queue&lt;TreeNode&gt; stoge = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">       stoge.offer(root);</span><br><span class="line">       <span class="keyword">while</span>(!stoge.isEmpty())&#123;</span><br><span class="line">           <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stoge.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">               root = stoge.poll();</span><br><span class="line">               sum += root.val;</span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stoge.offer(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stoge.offer(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       storage.add(sum/size);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> storage;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>步骤解析<ol><li>在while之前把根结点代入队列。</li><li>开始while循环，重置sum值，目的是为了把每层的的结点总值区分开添入List中</li><li>获取队列的长度，队列的长度在这里其实就是这层结点的总数</li><li>比如代入root后，然后元素出队，因为此时的队列中只有root一个元素，所以出队root后，队列为空，停止循环，然后计算sum值，sum值得计算是用for循环本层得结点数得次数后得到得，然后把sum/size添加入List中</li><li>判断，那么两个if语句为了让下一个左右结点得入队，空则不入，不空则入。</li></ol></li></ol><h3 id="404-左子叶之和"><a href="#404-左子叶之和" class="headerlink" title="404.左子叶之和"></a>404.左子叶之和</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211251049323.png" alt="image-20221125104925282"></p><ol><li>首先需要的是找到叶子节点，如果是就回溯到上一个结点输出左子叶，如果不是的话就往下递归。<ol><li>递归<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root.left!=<span class="literal">null</span>&amp;&amp;root.left.right==<span class="literal">null</span>&amp;&amp;root.left.left==<span class="literal">null</span>)&#123;</span><br><span class="line">           sum += root.left.val;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right)+sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>队列（广度优先搜索）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    storage.offer(root);</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!storage.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> storage.poll();</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left.right==<span class="literal">null</span>&amp;&amp;node.left.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                sum+=node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                storage.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(node.right.left==<span class="literal">null</span>&amp;&amp;node.right.right==<span class="literal">null</span>))&#123;</span><br><span class="line">                storage.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h3 id=&quot;镜像二叉树&quot;&gt;&lt;a href=&quot;#镜像二叉树&quot; class=&quot;headerlink&quot; title=&quot;镜像二叉树&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="练习" scheme="https://kalyan-zitiu.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="持续更新中" scheme="https://kalyan-zitiu.github.io/categories/%E7%BB%83%E4%B9%A0/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-传输层</title>
    <link href="https://kalyan-zitiu.github.io/2022/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/12/05/%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2022-12-05T14:00:00.000Z</published>
    <updated>2023-03-27T02:56:46.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>UDP是无连接的，减少开销和发送数据之前的时延</li><li>UDP使用最大努力交付，即不保证可靠交付</li><li>面向报文，适合一次性传输少量的数据的网络应用</li><li>没有拥塞控制，适合多实时应用</li><li>首部开销晓，8B，Tcp208<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211151804590.png" alt="image-20221115180421539"></li></ol><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><ol><li>UDP长度是指UDP用户数据报的整个长度</li><li>UDP检验和是用来检测整个UDP数据报是否有错，错就丢弃</li><li>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161119442.png" alt="image-20221116111919394"></li></ol><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><ol><li>伪首部只有在计算机检验和时才出现，不向下传送也不向上递交。</li><li>17：封装UDP报文的IP数据报首部协议字段17。</li><li>UDP长度：UDP首部8B+数据部分长度（不包括伪首部）。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161132390.png" alt="image-20221116113239359"><br>在发送端上会存在：</li><li>填上伪首部</li><li>全0填充检验和字段</li><li>全0填充数据部分（UDP数据报要看称许多4B的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入检验和字段</li><li>去掉伪首部，发送<br>在接收端上会存在：</li><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告</li></ol><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ol><li>TCP是面向连接的传输层协议。</li><li>TCP只能有两个端点，每一条TCP连接只能是点对点的（因此没办法运用多播和广播的通讯方式）</li><li>TCP提供可靠交付的服务，无差错，不丢失，不重复，按序到达</li><li>提供全双工通讯（有发送缓存和接收缓存 ）</li><li>TCP面向字节流：TCP把应用程序交下来的数据看成一连串无结构的字节流</li></ol><h3 id="报文段的首部格式"><a href="#报文段的首部格式" class="headerlink" title="报文段的首部格式"></a>报文段的首部格式</h3><ol><li>序号：在一个TCP连接中传送的字节流中的每一个字节都在按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号</li><li>确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1位置的所有数据都已正确收到。</li><li>数据偏移：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即一个数组是4B。</li><li>6个控制位<ul><li>紧急位URG：URG=1时，标明此报文段中有紧急数据，是最高优先级的数据，应该尽快传送，不用在缓存中排队，配合紧急指针字段使用（发送方）。</li><li>确认位ACK：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li>推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位RST：RST=1时，标明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li>同步位SYN：SYN=1时，表明是一个连接请求/连接接受报文。</li><li>终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul></li><li>窗口：发送本报文段的一方接受窗口，即现在允许对方发送的数据量</li><li>检验和：检验首部+数据，检验时加上12B的伪首部，第四个字段为6.</li><li>紧急指针：URF=1时才有意义，指出本报文段中紧急数据的字节数</li><li>选项：最大报文段长度MSS，窗口扩大，时间戳，选择确认</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211161310156.png" alt="image-20221116131046116"></p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><ol><li>TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器</li><li>假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用一下步骤与服务器中的TCP建立一条TCP连接<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211171124294.png" alt="image-20221117112431243"><ol><li>客户端发送连接请求报文段，无应用层数据SYN=1，seq=x（随机）</li><li>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。SYN=1，ACK=1，seq=y（随机），ack=x+1</li><li>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据SYN=0，ACK=1，seq=x+1,ack=y+1。</li></ol></li></ol><h3 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h3><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者会发送TCP SYN，SYN就是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，而那个TCP连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><p>1.参与一条TCP连接的两个进程中的任何一个都能终止连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。</p><ol><li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接FIN=1，seq=u</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了–半关闭状态ACK=1，seq=v,ack=u+1。</li><li>服务端发完数据，就发送连接释放报文段，主动关闭TCP连接。FIN=1，ACK=1，seq=w,ack=u+1</li><li>客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。ACK=1，seq=u+1，ack=w+1</li></ol><h3 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h3><ol><li>保证接受方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。也就是说明了数据帧在传输过程中既不能丢失，也不能受影响。<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4></li></ol><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><ol><li><p>一个字节占用一个序号</p></li><li><p>序号字段指的是一个报文段第一个字节的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211202009218.png" alt="image-20221120200930161"></p><h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4></li><li><p>发送方会保存一个TCP缓存报文段</p></li><li><p>接收方会在收到报文段后会发送确认报文段，当然接收方也可发送数据与确认报文段发去给发送方</p></li><li><p>若报文段在传输过程中丢失了，TCP会使用累计确认的方法，接收方会返回一个丢失报文段后的第一个字节的确认号报文段</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211202017088.png" alt="image-20221120201732026"></p><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><ol><li><p>超时重传，若在规定时间内发送方没有接收到接收方的确认数据报，就会进行重传。</p></li><li><p>TCP动态改变重传的规定时间RTTs（加权平均往返时间）</p></li><li><p>冗余ACK（冗余确认）每当期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。例子：发送方已发送1，2，3，4，5报文段</p></li></ol><ul><li>接收方收到1，返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到3，仍然返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到4，仍返回给1的确认（确认号为2的第一个字节）</li><li>接收方收到5，仍返回给1的确认（确认号为2的第一个字节）<br>如果发送方收到了3个对于报文段1的冗余ACK就会认为报文段丢失，重传2号报文段，快速重传。</li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><ol><li>利用滑动窗口机制实现流量控制</li><li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202212052140044.png" alt="image-20221205214003915"></li><li>TCP会为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就会启动持续计时器</li><li>若持续计时器设置的时间到期，就会发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值</li><li>若窗口仍然是0，那么发送方会重新设置持续计时器</li></ol><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>问题：当资源需求的总和大于可用资源的总和就会出现拥塞的条件，那么会有许多资源同时呈现供应不足就会导致网络性能变坏然后网络的吞吐量将会随输入负荷增大而下降</p><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>传输轮次：发送了一批报文段并收到了他们的确认的时间，也可以指的是往返的时延RTT</p><ol><li><p>探测网络拥塞程度后，提升拥塞窗口的数量</p></li><li><p>ssthresh的初始值指的是慢开始的值（不会再以指数增长的形式增长），会以加法的形式来增加，这就叫拥塞避免</p></li><li><p>当遇到网络拥塞的时候，就会执行断崖式减少，拥塞窗口会跌到cwnd=1，重新开始增加</p></li><li><p>在这过程中，可能会重新更新ssthresh，当遇到网络控制的时候，会把发送拥塞的cwnd值马上除以2生成新的ssthresh值，那么下一轮次的慢开始会从新的ssthresh开始。</p></li></ol><p><img src="C:/Users/86150/AppData/Roaming/Typora/typora-user-images/image-20221205221100217.png" alt="image-20221205221100217"></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>1.快重传就是等于冗余ack的算法是一致的，当某个报文段的确认帧并没有被发送方收到时候，后面发送的报文段返回的始终是还未收到的确认报文，当积累到三次的时候就会重传。<br>2.快恢复是和上面的ssthresh值是有关联的，当发送网络拥塞的时候，cwnd并不会直接降落到1，而是会降落到ssthresh值上直接进行慢开始。这样能够减少cwnd的变化幅度从而优化了速度。但是ssthresh值还是需要根据发送网络拥塞的cwnd来决定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h1&gt;&lt;h2 id=&quot;UDP协议&quot;&gt;&lt;a href=&quot;#UDP协议&quot; class=&quot;headerlink&quot; title=&quot;UDP协议&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="基础知识" scheme="https://kalyan-zitiu.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/15/Http/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/15/Http/</id>
    <published>2022-11-15T11:30:04.000Z</published>
    <updated>2023-01-03T11:48:23.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>超文本传输协议(Hyper Text Transfer Protocol，Http)是一个简单的请求-响应协议，它通常运行在TCP之上，它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求何响应消息的头以ASCII形式给出；而消息内容则具有了MIME格式。所有的WWW文件都必须遵守这个标准</li><li>Http是一个基于TCP/IP通信协议来传递数据的（HTML文件，信息，结果等）</li></ul><h2 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h2><ul><li>Http是从万维网服务器传输超文本到本地浏览器的传送协议</li><li>Https是一种通过计算机网络进行的安全通信的传输协议</li><li>端口不一样Http的URL是默认使用端口80，而Https的是默认使用端口443<h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3></li><li>Https是通过Http进行通信，利用SSL/TLS来加密数据包，Https开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私和完整性<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4></li><li>1.TCP三次同步握手</li><li>2、客户端验证服务器数字证书</li><li>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>4、SSL 安全加密隧道协商完成</li><li>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210221158748.jpeg" alt="img"></p><h5 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h5><ul><li><p>SYN</p><ul><li>指的是<strong>同步序列编号</strong>，是T<strong>CP/IP</strong>建立连接时使用的握手信号。在客户端与服务器之间建立正常的<strong>TCP网络</strong>连接时，客户机首先发出一个<strong>SYN</strong>消息，服务器使用<strong>SYN+ACK</strong>应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起<strong>可靠的TCP连接</strong>，<strong>数据</strong>才可以在客户机和服务器之间传递。</li></ul></li><li><p>MIME</p><ul><li>多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该<strong>扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</strong>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</li></ul></li><li><p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号）客户端进入<strong>SYN_SEND</strong></p></li><li><p>第二次握手，服务器接收客户端syn包并且确认，同时向客户端发送一个SYN包，即SYN+ACK包，此时服务器处于<strong>SYN_RECV状态</strong></p></li><li><p>第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入了<strong>ESTABLISHED状态</strong></p><h3 id="Http的工作原理"><a href="#Http的工作原理" class="headerlink" title="Http的工作原理"></a>Http的工作原理</h3></li><li><p>HTTP协议工作与客户端-服务端架构上</p></li><li><p>浏览器作为客户端通过URL向服务端发送所有请求</p></li><li><p>Web的服务端有Apache服务器，IIS服务器</p></li><li><p>需要注意的是</p><ul><li>HTTP是无连接，无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，断开连接以达到节省传输时间</li><li>它是一个媒体独立的，意味着，客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的MiME-type内容类型</li><li>它是无状态的：指的是对于事务的处理它是没有记忆能力的，这就说明如果后续需要处理前面的信息的话，必须得重新传输，导致每次连接的数据量增大。 </li></ul></li></ul><h3 id="Https-1"><a href="#Https-1" class="headerlink" title="Https"></a>Https</h3><ul><li>能够在不安全的网络上创建一个安全通道，并且可以使用适当的加密包和服务器证书验证且可被信任</li><li>当以下情况达成时可被信任</li><li>浏览器正确的实现了HTTPS且操作系统中安装了正确且受信任的证书颁发机构；</li><li>次协议的加密层也就是SSL./TLS能够有效的提供认证和高强度的加密</li></ul><h2 id="Http的消息结构"><a href="#Http的消息结构" class="headerlink" title="Http的消息结构"></a>Http的消息结构</h2><ul><li><p>客户端一般发送一个HTTP请求到服务器的请求消息包括以下格式：请求行，请求头部，空行和请求数据四个部分组成。</p><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210221316880.png" alt="image-20221022131636849"></li></ul></li><li><p>服务器响应也是四个部分组成，分别是：状态行，消息报头，空行和响应正文</p></li></ul><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><table><thead><tr><th>number</th><th>method</th><th>descrition</th></tr></thead><tbody><tr><td>1.</td><td>GET</td><td>请求指定的页面信息，返回实体主体</td></tr><tr><td>2.</td><td>HEAD</td><td>返回的响应中没有具体内容，用于获取报头</td></tr><tr><td>3.</td><td>POST</td><td>向指定的资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能导致新的资源的建立和/或已有的资源的修改</td></tr><tr><td>4.</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档内容</td></tr><tr><td>5.</td><td>DELETE</td><td>请求服务器伤处指定画面</td></tr><tr><td>6.</td><td>CONNECT</td><td>预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>7.</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>8.</td><td>PATCH</td><td>对PUT方法的补充，用来对已知资源进行局部更新</td></tr><tr><td>9.</td><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr></tbody></table><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><table><thead><tr><th>状态码</th><th>英文对应名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Http&quot;&gt;&lt;a href=&quot;#Http&quot; class=&quot;headerlink&quot; title=&quot;Http&quot;&gt;&lt;/a&gt;Http&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="协议" scheme="https://kalyan-zitiu.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>图存结构</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/15/%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/15/%E5%9B%BE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</id>
    <published>2022-11-15T11:00:23.000Z</published>
    <updated>2022-11-21T06:59:06.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）"><a href="#基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）" class="headerlink" title="基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）"></a>基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）</h2><h3 id="什么是图存储结构"><a href="#什么是图存储结构" class="headerlink" title="什么是图存储结构"></a>什么是图存储结构</h3><ul><li>根据有向和无向线来连接每个顶点间的关系<ul><li>有向图：如果元素之间存在单向的联系，那么这样的图结构称为有向图.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210270950517.png" alt="image-20221027095058466"></li><li>无向图：各个元素之间的联系都是双向的，这样的图存结构称为无向图。<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210270952151.png" alt="image-20221027095201129"></li></ul></li></ul><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>1.弧头和弧尾</p><ul><li>有向图中，无箭头的一端的顶点通常被称为“初始点”或“弧尾”，箭头的一段被称为“终端点”或“弧头”。</li></ul><p>2.入度和出度</p><ul><li>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。</li></ul><p>3.(V1,V2)和&lt;V1,V2&gt;的区别</p><ul><li><strong>无向图中描述两顶点V1和V2之间的关系可以用(V1,V2)来表示；有向图中描述从V1到V2的“单向”关系可以用&lt;V1,V2&gt;来表示</strong></li><li>由于图存储结构中顶点之间的关系是可以用线来表示的，因此(V1,V2)还可以用来表示无向图中连接V1和V2的线，又称为边;同样&lt;V1,V2&gt;也可用来表示有向图中从V1到V2带方向的线，又称为弧。</li></ul><p>4.集合VR</p><ul><li>图中习惯用VR表示图中所有顶点之间的关系的集合，例如，上图无向图的集合VR={(V1,V2),(V1,V4),(V1,V3),(V3,V4)}。有向图的集合 VR={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。</li></ul><p>5.路径和回路</p><ul><li>无论是无向图还是有向图，从一个顶点到另一个顶点途径的所有顶点组成的序列（包括起点和终点），称为一条路径。若路径中的<strong>某个顶点能够最后回到自己身上</strong>，那么这个路径称为<strong>环</strong>或者<strong>回路</strong></li></ul><p>6.权和网</p><ul><li>在一些图中，可能为每条边赋值一个实数表示一定的含义，这种与边（或弧）相互匹配的实数被称为“权”，而带权的图通常称为网。例如，图4就是一个网结构:<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271035591.png" alt="image-20221027103555566"></li></ul><p>7.子图</p><ul><li>指的是由图中一部分顶点和边构成的图称为原图的子图</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h4><ul><li>每个顶点都有与除开自身外的其他顶点有直接关系</li><li>若有n个顶点的完全图，则图中边的数量为n(n-1)/2;而对于具有n个顶点的有向完全图，图中的弧的数量为n(n-1)。<h4 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h4></li><li><strong>如果图中从一个顶点到达另外一个顶点，至少有一条路径，那么这两个顶点是连通着的。</strong>例如图中，虽然V1和V3没有直接关联，但从V1到V3存在两条路径，分别是V1-V2-V3和V1-V4-V3，因此称V1和V2之间是连通的<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271101163.png" alt="image-20221027110110138"><br>上面用的是无向图的例子，其实有向图也是基本差不多的啦，自己揣摩哦！！！！<h5 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h5></li><li>在有向图中两个顶点彼此都有至少有一条通路，那么这有向图为强连通图。</li><li>除此之外，若有向图不是强连通图，但其中包含的是最大连通子图具有强连通的性质，则称该子图为强连通分量<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271112764.png" alt="image-20221027111223735"></li></ul><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><ul><li>其实对连通图的遍历的过程中就已经是生成树的过程了<br>1.如图：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271122665.png" alt="image-20221027112213637"><br>2.需要注意的是连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。<br>3.连通图中的生成树必须满足以下 2 个条件：<ul><li>包含连通图中所有的顶点；</li><li>任意两顶点之间有且仅有一条通路；</li></ul></li></ul><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><h3 id="图的顺序存储结构"><a href="#图的顺序存储结构" class="headerlink" title="图的顺序存储结构"></a>图的顺序存储结构</h3><ul><li>虽然图结构的数据元素存在多对多关系，但是同样可以采用顺序储存，能够使用数组有效的储存图</li><li>需要注意的是：数组储存图时，需要一个数组存放图中顶点本身的数据（最好是一维数组），另外一个数组存储的是各顶点之间的关系（这时候就要是二维数组了）<h4 id="邻接矩阵无向图"><a href="#邻接矩阵无向图" class="headerlink" title="邻接矩阵无向图"></a>邻接矩阵无向图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixNDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//图顶点个数</span></span><br><span class="line">    <span class="type">char</span>[] vertexs;<span class="comment">//图顶点名称</span></span><br><span class="line">    <span class="type">int</span>[][] matrix;<span class="comment">//图关系矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixNDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        matrix=<span class="keyword">new</span> <span class="title class_">int</span>[size][size];<span class="comment">//设定图关系矩阵大小</span></span><br><span class="line">        <span class="built_in">this</span>.vertexs=vertexs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;<span class="comment">//设置矩阵值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(c[<span class="number">0</span>]);<span class="comment">//根据顶点名称确定对应矩阵下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(c[<span class="number">1</span>]);</span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>;<span class="comment">//无向图，在两个对称位置存储</span></span><br><span class="line">            matrix[p2][p1] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的遍历输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据顶点名称获取对应的矩阵下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i]==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line">        MatrixNDG pG;</span><br><span class="line">        <span class="comment">// 自定义&quot;图&quot;(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">// 采用已有的&quot;图&quot;</span></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">MatrixNDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接矩阵有向图"><a href="#邻接矩阵有向图" class="headerlink" title="邻接矩阵有向图"></a>邻接矩阵有向图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixDG</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">char</span>[] vertexs;</span><br><span class="line">    <span class="type">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        matrix=<span class="keyword">new</span> <span class="title class_">int</span>[size][size];</span><br><span class="line">        <span class="built_in">this</span>.vertexs=vertexs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和邻接矩阵无向图差别仅仅在这里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(c[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i]==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line">        MatrixDG pG;</span><br><span class="line">        <span class="comment">// 自定义&quot;图&quot;(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">//pG = new MatrixUDG();</span></span><br><span class="line">        <span class="comment">// 采用已有的&quot;图&quot;</span></span><br><span class="line">        pG = <span class="keyword">new</span> <span class="title class_">MatrixDG</span>(vexs, edges);</span><br><span class="line"></span><br><span class="line">        pG.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表无向表"><a href="#邻接表无向表" class="headerlink" title="邻接表无向表"></a>邻接表无向表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    Vertex[] vertexLists;<span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>&#123;<span class="comment">//邻接表节点类，单链表数据结构</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Vertex next;</span><br><span class="line"></span><br><span class="line">        Vertex(<span class="type">char</span> ch)&#123;<span class="comment">//初始化方法</span></span><br><span class="line">            <span class="built_in">this</span>.ch=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span>&#123;<span class="comment">//加到链表尾</span></span><br><span class="line">            Vertex node=<span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="keyword">new</span> <span class="title class_">Vertex</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line"></span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexLists=<span class="keyword">new</span> <span class="title class_">Vertex</span>[size];<span class="comment">//确定邻接表大小</span></span><br><span class="line">        <span class="comment">//设置邻接表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexLists[i]=<span class="keyword">new</span> <span class="title class_">Vertex</span>(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储边信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">           <span class="type">int</span> p1=getPosition(c[<span class="number">0</span>]);</span><br><span class="line">           vertexLists[p1].add(c[<span class="number">1</span>]);</span><br><span class="line">           <span class="type">int</span> p2=getPosition(c[<span class="number">1</span>]);</span><br><span class="line">           vertexLists[p2].add(c[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟据顶点名称获取链表下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].ch==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历输出邻接表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Vertex temp=vertexLists[i];</span><br><span class="line">           <span class="keyword">while</span>(temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.print(temp.ch+<span class="string">&quot; &quot;</span>);</span><br><span class="line">               temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListNDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">ListNDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接有向表"><a href="#邻接有向表" class="headerlink" title="邻接有向表"></a>邻接有向表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDG</span> &#123;</span><br><span class="line">    Vertex[] vertexLists;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>&#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        Vertex next;</span><br><span class="line"></span><br><span class="line">        Vertex(<span class="type">char</span> ch)&#123;</span><br><span class="line">            <span class="built_in">this</span>.ch=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">            Vertex node=<span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="keyword">new</span> <span class="title class_">Vertex</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListDG</span><span class="params">(<span class="type">char</span>[] vertexs,<span class="type">char</span>[][] edges)</span>&#123;</span><br><span class="line"></span><br><span class="line">        size=vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexLists=<span class="keyword">new</span> <span class="title class_">Vertex</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexLists[i]=<span class="keyword">new</span> <span class="title class_">Vertex</span>(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:edges)&#123;</span><br><span class="line">           <span class="type">int</span> p=getPosition(c[<span class="number">0</span>]);</span><br><span class="line">           vertexLists[p].add(c[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].ch==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Vertex temp=vertexLists[i];</span><br><span class="line">           <span class="keyword">while</span>(temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.print(temp.ch+<span class="string">&quot; &quot;</span>);</span><br><span class="line">               temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[][] edges = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> start=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> <span class="title class_">ListDG</span>(vexs, edges);</span><br><span class="line">            <span class="comment">//pG.print();   // 打印图 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> end=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li><p>所谓图的遍历，简单理解就是逐个访问图中的顶点，确保每个顶点都只访问一次</p></li><li><p>深度优先搜索算法遍历图1无向图的过程:<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271413712.png" alt="image-20221027141315660"></p></li></ul><p>1.初始状态下，无向图中的所有顶点都是没有被访问过的，一次可以任选一个顶点出发，遍历整个无向图，假设从V1顶点开始，先访问V1顶点。</p><p>2.紧邻V1的顶点有两个，分别是V2和V3，它们都没有被访问过，从它们中任选一个，这里选择V2</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271530315.png" alt="image-20221027153049261"></p><p>3.紧邻V2的顶点三个，分别是V1，V4，V5，尚未被访问的有V4，V5，从它们中任选一个，比如访问V4，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531571.png" alt="image-20221027153105528"></p><p>4.紧邻 V4 的顶点有两个，分别是 V2 和 V8，只有 V8 尚未被访问，因此访问 V8，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531449.png" alt="image-20221027153116398"></p><p>5.紧邻 V8 的顶点有两个，分别是 V4 和 V5，只有 V5 尚未被访问，因此访问 V5，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531351.png" alt="image-20221027153133306"></p><p>6.和 V5 相邻的顶点有两个，分别是 V2 和 V8，它们都已经访问过了。也就是说，此时从 V5 出发，找不到任何未被访问的顶点了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271531438.png" alt="image-20221027153147389"></p><p>7.这种情况下，深度优先搜索算法会回退到之前的顶点，查看先前有没有漏掉的、尚未访问的顶点：</p><ul><li>从 V5 回退到 V8，找不到尚未访问的顶点；</li><li>从 V8 回退到 V4，还是找不到尚未访问的顶点；</li><li>从 V4 回退到 V2，也还是找不到尚未访问的顶点；</li><li>从 V2 回退到 V1，发现 V3 还没有被访问。<br>于是，下一个要访问的顶点就是 V3，如下图所示：</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271532746.png" alt="image-20221027153201697"></p><p>8.紧邻 V3 的顶点有三个，分别是 V1、V6 和 V7，尚未访问的有 V6 和 V7，因此从它们中任选一个，比如访问 V6，如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210271532529.png" alt="image-20221027153214477"></p><p>9.紧邻 V6 的顶点有两个，分别是 V3 和 V7，只有 V7 还没有访问，因此访问 V7，如下图所示：</p><p>10.紧邻 V7 顶点有 V6 和 V3，但它们都已经访问过了，此时面临的情况和第 6 步完全一样，深度优先搜索算法的解决方法也是一样的：</p><ul><li>从 V7 回退到 V6，依然找不到尚未访问的顶点；</li><li>从 V6 回退到 V3，依然找不到尚未访问的顶点；</li><li>从 V3 回退到 V1，依然找不到尚未访问的顶点；</li><li>V1 是遍历图的起始顶点，回退到 V1 还找不到尚未访问的顶点，意味着以 V1 顶点为突破口，能访问的顶点全部已经访问完了。这种情况下，深度优先搜索算法会从图的所有顶点中重新选择一个尚未访问的顶点，从该顶点出发查找尚未访问的其它顶点。<br>从图 9 可以看到，图中已经没有尚未访问的顶点了，此时深度优先搜索算法才执行结束。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的存储结构&quot;&gt;&lt;a href=&quot;#图的存储结构&quot; class=&quot;headerlink&quot; title=&quot;图的存储结构&quot;&gt;&lt;/a&gt;图的存储结构&lt;/h1&gt;&lt;h2 id=&quot;基本知识（此次都是为图存储结构的基本知识，若已了解可跳至算法部分）&quot;&gt;&lt;a href=&quot;#基本知识</summary>
      
    
    
    
    <category term="数据结构" scheme="https://kalyan-zitiu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-物理层</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/14/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/14/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-11-14T13:00:04.000Z</published>
    <updated>2022-11-14T13:43:00.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><ul><li>数据：传送信息的实体，通常时有意义的符号序列</li><li>信号：数据的电气/电磁的表现，时数据传输过程中的存在形式</li><li>信源：产生和发送数据的源头</li><li>信宿：接收数据的终点</li><li>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114805.png" alt="image-20221106163817766"></li></ul><h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道</li><li>半双工通信：通信的双方都可以发送或接收消息，但任何一方都不能同时发送和接收，需要两条信道</li><li>全双工通信：通信双方可以同时发送和接收信息，也需要两条信道</li></ol><h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><ul><li>串行传输<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114004.png" alt="image-20221106165443091"></li><li>并行传输<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114090.png" alt="image-20221106165454936"></li></ul><h3 id="并口"><a href="#并口" class="headerlink" title="并口"></a>并口</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114190.png" alt="image-20221106165557385"></p><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><ol><li>指的时一个固定时长的信号波形（数字脉冲）代表不同离散数值的基本波形（码元是一个信号）</li><li>数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，该时长称为码元宽度</li><li>当码元的离散状态右M（M&gt;2）时，此时码元为M进制码元</li><li>1个码元可以携带多个比特信息量。</li></ol><ul><li>举例子：</li></ul><ol><li><p>当码元的<strong>离散状态有四种时</strong>，那么就对应了四种不同的码元<strong>00，01，11，10</strong>。每个码元都对应着自己的电平也就是<strong>数字信号。</strong></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114665.png" alt="image-20221108160327118"></p></li></ol><h3 id="速率（数据率）匹配"><a href="#速率（数据率）匹配" class="headerlink" title="速率（数据率）匹配"></a>速率（数据率）匹配</h3><ol><li>数据的传输速率，单位时间内传输的数据量</li></ol><h4 id="传输速率和传播速率的区别"><a href="#传输速率和传播速率的区别" class="headerlink" title="传输速率和传播速率的区别"></a>传输速率和传播速率的区别</h4><p>前者主要针对主机，链路开端方面的数据，即把数据发送到链路的速度。<br>后者是指数据在整个信道上，链路上传播的速度</p><h4 id="码元传输速率（波形速率，调制速率，符号速率）"><a href="#码元传输速率（波形速率，调制速率，符号速率）" class="headerlink" title="码元传输速率（波形速率，调制速率，符号速率）"></a>码元传输速率（波形速率，调制速率，符号速率）</h4><ol><li>表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud），一波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的。</li></ol><h4 id="信息传输速率（信息速率，比特率）"><a href="#信息传输速率（信息速率，比特率）" class="headerlink" title="信息传输速率（信息速率，比特率）"></a>信息传输速率（信息速率，比特率）</h4><ol><li>单位时间内数字通信系统传输的二进制码元个数（比特数），单位是比特/秒（1s传输多少比特）</li></ol><h4 id="码元传输和信息传输的关系"><a href="#码元传输和信息传输的关系" class="headerlink" title="码元传输和信息传输的关系"></a>码元传输和信息传输的关系</h4><ol><li>若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M X n bit/s。</li></ol><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><ol><li>表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”</li><li>表示网络的通信线路所能传输数据的能力。（b/s）</li></ol><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><ol><li>现实中的信道会有带宽受限以及噪音等干扰<h4 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h4></li><li>震动的速度和频率太快了，以至于接收端区别不了码元之间的清晰界限的现象。<h5 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h5></li><li>是信道能通过的最高频率和最低频率之差</li></ol><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><ol><li>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud,W是信道带宽，单位是Hz。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114527.png" alt="image-20221108164817649"></p><ol start="2"><li>码元传输当然是有上限速率的。传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能</li><li>信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。（也就是W越大）</li><li>奈氏准则给出了码元的传输速率的限制，但并没有对信息传输速率给出限制</li><li>由于码元的传输速率受奈氏准则的制约，所以提高数据的传输速率，就必须设法使每个码元携带跟多个比特的信息量，这就需要采用多元制的调制方法</li></ol><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><ol><li>噪声的随机产生会使接收端一段时间失去对码元的判断能力。</li><li>因为噪声和信号是相对的，因此引入了一个信噪比的量</li><li>信噪比=信号的平均功率/噪声的平均功率。</li></ol><ul><li>香农定理： 在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值</li></ul><ol><li>信噪比越大，极限传输速率越高</li><li>只有有传输带宽以及信噪比，就能够确定信息传输速率的上限</li><li>只要信息的传输速率低于极限值，就有可能完成无差错的传输</li><li>实际的信道传输速率会比极限值低很多<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101114164.png" alt="image-20221108170535322"></li></ol><h2 id="编码和调制以及其基础知识"><a href="#编码和调制以及其基础知识" class="headerlink" title="编码和调制以及其基础知识"></a>编码和调制以及其基础知识</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><ol><li>信道：是信号的传输媒介，一般用来表示向某个方向传送信息介质。所以会包含一根发送信道和接收信道</li><li>信道又会根据传输信号和传输介质分为模拟信道（传送模拟信号）/数字信道和无线信道/有线信道<h4 id="基带信号"><a href="#基带信号" class="headerlink" title="基带信号"></a>基带信号</h4></li></ol><ul><li>将数字信号1，0采用不同的电压表示，再送到链路上。来自于信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。直接表达了要传输信息的信号（不加任何东西）</li></ul><h4 id="宽带信号"><a href="#宽带信号" class="headerlink" title="宽带信号"></a>宽带信号</h4><ul><li>将基带信号也就是01010的数字信号进行调制形成的频分复用模拟信号，再送到模拟信道上。</li><li>宽带利用的是载波调制，信号频分，把信号放在较高频段来传输。</li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101232481.png" alt="image-20221110123237415"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101131784.png" alt="image-20221110113137741"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101132385.png" alt="image-20221110113206340"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101143934.png" alt="image-20221110114311908"></p><h5 id="非归零编码【NRZ】"><a href="#非归零编码【NRZ】" class="headerlink" title="非归零编码【NRZ】"></a>非归零编码【NRZ】</h5><ol><li>高1低0,编码容易实现,但没有检错功能,而且没法判断一个码元的开始和结束.两端的难以保持同步 </li><li>需要一个信道来发送这条信号的周期和速度,以达到发送与接收同步<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101142456.png" alt="image-20221110114258427"></li></ol><h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a><strong>曼彻斯特编码</strong></h5><ol><li>前高后低为1,前低后高为0.当然也可以反着来使用</li><li>曼彻斯特能够实现<strong>自同步接收</strong>,因为它把码元分为了<strong>两个相同的间隔</strong></li><li>编码会在码元的时间中间发生跳变,来告诉接收方时钟信号,并且还能作为数据信号传输</li><li>在一个码元时间内信号变化两次也就是进行了2次脉冲</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101151216.png" alt="image-20221110115150189"></p><h5 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a><strong>差分曼彻斯特编码</strong></h5><ol><li>同1异0,简单来说就是后半段电平的下一位遇到0的话就变化,遇到1则不变</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101159529.png" alt="image-20221110115928497"></p><h5 id="归零编码【RZ】"><a href="#归零编码【RZ】" class="headerlink" title="归零编码【RZ】"></a>归零编码【RZ】</h5><ol><li>信号的电平在每一个码元后都要恢复到0的状态</li><li>需要信道来传输时钟信号</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101146390.png" alt="image-20221110114621361"></p><h5 id="反向不归零编码【NRZI】"><a href="#反向不归零编码【NRZI】" class="headerlink" title="反向不归零编码【NRZI】"></a>反向不归零编码【NRZI】</h5><ol><li>信号的电平翻转表示0,不变表示1.也就是说遇到0就翻转一次电平,遇到1就不变</li><li>需要信道来传输时钟信号</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101148118.png" alt="image-20221110114824090"></p><h5 id="4B-5B编码"><a href="#4B-5B编码" class="headerlink" title="4B/5B编码"></a>4B/5B编码</h5><ol><li>在一个比特流中插入额外的比特来打破一连串的01数据流,就是用5个比特来编码4个比特的数据,之后再传给接收方.</li><li>每个4比特的不同排序都会对应不同排序的5比特.</li><li>剩下的5比特排序会留给作为<strong>数据的控制码,<strong>也就是</strong>定界</strong>一样的作用</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101205953.png" alt="image-20221110120535909"></p><h4 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101214059.png" alt="image-20221110121407005"></p><h4 id="模拟数据编码为数字信号（举例：音频数字化）"><a href="#模拟数据编码为数字信号（举例：音频数字化）" class="headerlink" title="模拟数据编码为数字信号（举例：音频数字化）"></a>模拟数据编码为数字信号（举例：音频数字化）</h4><ol><li><p>抽样：对模拟信号周期性扫描，把时间上的连续的信号变成时间上离散的信号（定理：f<del>采样频率</del>&gt;=2f<del>信号最高频率</del>）</p></li><li><p>量化：把取得的电平幅值分级标度转化为对应的数字值，并取整数，这就把连续的电平变为离散的数字量</p></li><li><p>编码：量化结果变为二进制编码</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101222807.png" alt="image-20221110122251757"></p></li></ol><h4 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h4><ol><li>可以使用频分复用技术，充分利用带宽资源。</li><li>模拟的声音数据是加载到模拟的载波信号中进行传输。</li></ol><h2 id="传输介质及分类"><a href="#传输介质及分类" class="headerlink" title="传输介质及分类"></a>传输介质及分类</h2><ol><li>传输介质也称传输媒体/传输媒介，它是数据传输系统中在发送设备和设备之间的<strong>物理通路</strong></li><li>它是在物理层下面的并不是物理层，有时候会把传输媒体称为体系结构的第0层</li></ol><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><ol><li>需要依赖物理媒介<h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4></li></ol><ul><li>两根采用一定的规则进行并排绞合的，相互绝缘的铜导线组成。能够减少对相邻导线的电磁干扰<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141730472.png" alt="image-20221114173045429"></li></ul><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141736886.png" alt="image-20221114173620742"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141739188.png" alt="image-20221114173936067"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141740893.png" alt="image-20221114174024782"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><h4 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h4><ul><li>信号向所有方向传播</li><li>较强的穿透能力，可远距离传输，多用于手机通信</li></ul><h4 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h4><ul><li>信号固定方向传播</li><li>微波通信频率较高，频段范围宽，因此数据率很高<h5 id="卫星通信"><a href="#卫星通信" class="headerlink" title="卫星通信"></a>卫星通信</h5></li><li>通信容量大，距离远，覆盖广，广播通信和多址通信</li><li>传播时延较长，受气候影响大，误码率高，成本高</li></ul><h4 id="红外线，激光"><a href="#红外线，激光" class="headerlink" title="红外线，激光"></a>红外线，激光</h4><ul><li>信号固定方向传播</li><li>把要传输的信号分别转换为各自的信号格式，即红外信号和激光信号在空间中传播。</li></ul><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141851879.png" alt="image-20221114185153756"></p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211141852692.png" alt="image-20221114185248596"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h1&gt;&lt;h2 id=&quot;数据通信基础知识&quot;&gt;&lt;a href=&quot;#数据通信基础知识&quot; class=&quot;headerlink&quot; title=&quot;数据通信基</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库基本操作学习笔记</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/</id>
    <published>2022-11-08T04:47:04.000Z</published>
    <updated>2022-11-10T05:23:25.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库SQL"><a href="#数据库SQL" class="headerlink" title="数据库SQL"></a>数据库SQL</h1><h2 id="数据库数据定义"><a href="#数据库数据定义" class="headerlink" title="数据库数据定义"></a>数据库数据定义</h2><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n),character(n)</td><td>长度为n的定长字符串</td></tr><tr><td>varchar(n),charactervarying(n)</td><td>最大长度为n的变长字符串</td></tr><tr><td>clob</td><td>字符串大对象</td></tr><tr><td>blob</td><td>二进制大对象</td></tr><tr><td>smallint</td><td>短整数（2B）</td></tr><tr><td>int，integet</td><td>长整数（4B）</td></tr><tr><td>bigint</td><td>大整数（8B）</td></tr><tr><td>numberic(p,d)</td><td>定点数，由p位数字（不包括符号，小数点）组成，小数点后面有d位数字</td></tr><tr><td>decimal（p，d）,dec(p,d)</td><td>同上面NUMBERIC(p,d)</td></tr><tr><td>real</td><td>取决于机器精度的单精度浮点数</td></tr><tr><td>double precision</td><td>取决于机器精度的双精度点数</td></tr><tr><td>float(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr><td>boolean</td><td>逻辑布尔量</td></tr><tr><td>date</td><td>日期，包含年，月，日，格式为YYYY—MM—DD</td></tr><tr><td>time</td><td>时间，包含一日的时，分，秒，格式为HH：MM：SS</td></tr><tr><td>timestamp</td><td>时间戳类型</td></tr><tr><td>interval</td><td>时间间隔类型</td></tr></tbody></table><h3 id="大对象简介"><a href="#大对象简介" class="headerlink" title="大对象简介"></a>大对象简介</h3><p>1.用来存储大型数据，图片，视频，音乐<br>2.可用于存储二进制数据，字符数据，引用外部文件的指针的数据类型</p><ul><li><p>大对象的4种类型</p><ul><li><p>BLOB数据类型</p><ul><li>1.它是用来存储二进制数据</li><li>2.可以存储的最大数据量（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>CLOB数据类型</p><ul><li>1.存储字符数据</li><li>2.可以存储的最大数据量（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>NCLOB数据类型</p><ul><li>1.用来存储多字节字符的数据，一般用于非英文的字符</li><li>2.可以存储的最大数据量是（4GB-1）*db_block_size,也就是128TB</li></ul></li><li><p>BFILE数据类型</p><ul><li><p>1.存储文件指针</p></li><li><p>2.数据文件可以存储再数据库之外，数据库存储对该文件的引用</p></li><li><p>3.其最多也可以存储4GB的数据   </p></li></ul></li></ul></li></ul><h3 id="一些重要的SQL语句"><a href="#一些重要的SQL语句" class="headerlink" title="一些重要的SQL语句"></a>一些重要的SQL语句</h3><ul><li>SELECT - 从数据库中提取数据</li><li>UPDATE - 更新数据库中的数据</li><li>DELETE - 从数据库中删除数据</li><li>INSERT INTO - 向数据库中插入新数据</li><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h2 id="SQL基本命令"><a href="#SQL基本命令" class="headerlink" title="SQL基本命令"></a>SQL基本命令</h2><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 datatype,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY( <span class="keyword">one</span> <span class="keyword">or</span> more columns )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><ul><li>select column_name, column_name from table_name</li></ul><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><ul><li>有时候一个列会包含多个重复值，有时候你也是只想列出不同的值而已</li><li>也就是只列出一个种类值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> column_name, column_name <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><ul><li>提取满足指定条件的记录</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> column_name operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><ul><li>注意：如果是搜索字符串的话，请注意内容的大小写，这不属于数据库SQL无视大小写字母的范畴</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>搜索某种模式</td></tr><tr><td>in</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h5 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h5><h6 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h6><ul><li>And与同时满足两个条件的值 ，查询表中数值范围内的值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span><span class="operator">*</span><span class="keyword">from</span> emp sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">and</span> sal <span class="operator">&lt;</span><span class="number">3000</span></span><br></pre></td></tr></table></figure><ul><li>逻辑运算的优先级</li></ul><table><thead><tr><th>（）</th><th>not</th><th>and</th><th>or</th></tr></thead></table><h6 id="特殊条件"><a href="#特殊条件" class="headerlink" title="特殊条件"></a>特殊条件</h6><ul><li>空值判断</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>查询表中的comm中的空值</p><ul><li>between and</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>查询范围内的值</p><ul><li>in</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span>(<span class="number">5000</span>,<span class="number">3000</span>,<span class="number">1500</span>)</span><br></pre></td></tr></table></figure><p>查询表中与值相同的值</p><ul><li>like</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;M%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询emp表中有M的值，上面为模糊信息</p><ul><li>%：表示多个字值，_表示一个字符</li><li>M%：为能配符，正则表达式，表示的意思是为模糊查询信息为M开头的</li><li>%M%：查询包含M的所有内容</li><li>%M_：表示查询以M在倒数第二位的所有内容<h2 id="AND-amp-OR-运算符"><a href="#AND-amp-OR-运算符" class="headerlink" title="AND &amp; OR 运算符"></a>AND &amp; OR 运算符</h2></li></ul><p>1.如果两个条件同时成立，则AND运算符显示一条记录<br>2.如果两个条件中只有一个条件成立，则OR运算符显示一条记录</p><h3 id="AND运算符实例"><a href="#AND运算符实例" class="headerlink" title="AND运算符实例"></a>AND运算符实例</h3><p>表示查询出表中名字叫fuck而且性别男的信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;fuck&#x27;</span> <span class="keyword">AND</span> sex <span class="operator">=</span> <span class="string">&#x27;man&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="OR运算符实例"><a href="#OR运算符实例" class="headerlink" title="OR运算符实例"></a>OR运算符实例</h3><p>表示查询出表中名字叫fuck或者性别男的信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;fuck&#x27;</span> <span class="keyword">OR</span> sex <span class="operator">=</span> <span class="string">&#x27;man&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ORDER-BY-关键字"><a href="#ORDER-BY-关键字" class="headerlink" title="ORDER BY 关键字"></a>ORDER BY 关键字</h2><ul><li>用于对结果集按照一个列或者多个列进行排序</li><li>默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，你可以使用DESC关键字<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>在表中查询信息并且按照升序或降序排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name,column_name <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h2>该语句用于插入新的记录</li></ul><ol><li>不用指定插入数据的列名，只需要提供被插入的信息即可<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">values</span>(value1,value2,value3,...)</span><br></pre></td></tr></table></figure></li><li>需要指明列名以及被插入的信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...)</span><br></pre></td></tr></table></figure></li><li>无需指定的多表插入<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">values</span></span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3),</span><br><span class="line">(value1,value2,value3);</span><br></pre></td></tr></table></figure><h2 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h2></li></ol><ul><li>更新表中的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">set</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">where</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> site <span class="keyword">set</span> pre <span class="operator">=</span> <span class="string">&#x27;kalyan&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101105753.png" alt="image-20221110110519707"></p><h2 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h2><p>用来删除表中的行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><h2 id="SELECT-TOP，LIMIT，ROWNUM子句"><a href="#SELECT-TOP，LIMIT，ROWNUM子句" class="headerlink" title="SELECT TOP，LIMIT，ROWNUM子句"></a>SELECT TOP，LIMIT，ROWNUM子句</h2><p>1.SELECT TOP 子句用于规定要返回的记录的数目<br>2.SELECT TOP子句对于拥有数千条记录的大型表来说，是非常有用的<br>3.需要注意的是不是所有数据库系统都支持select top语句。mysql支持limit语句来选取指定的条数数据，Oracle可以使用rownum来选取</p><ul><li>SQL server/MS Access语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top number<span class="operator">|</span><span class="keyword">percent</span> column_name(s) <span class="keyword">from</span> table_name LIMIT nember</span><br></pre></td></tr></table></figure></li><li>MySQL语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name limit number</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> persons limit <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li>Oracle语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> rownwm<span class="operator">&lt;=</span>number</span><br></pre></td></tr></table></figure></li></ul><h2 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h2><ul><li>ALTER TABLE语句使用与在已有表中添加，修改，删除列</li></ul><ol><li>添加<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">add</span> column_name datatype;</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> column_name;</span><br></pre></td></tr></table></figure></li><li>修改<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name datatype;</span><br></pre></td></tr></table></figure></li></ol><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>替代0个或多个字符</td></tr><tr><td>_</td><td>替代一个字符</td></tr><tr><td>[charlist]</td><td>字符列中的任何单一字符</td></tr><tr><td>[^charlist]或[!charlist]</td><td>不在字符列中的任何单一字符</td></tr></tbody></table><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>通过使用SQL，可以为表名称或者列名称修改成为你喜欢的名字<br>这能够让你的表格根据有阅览性</p><ul><li>列的SQL别名语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">AS</span> alians_name <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li>表的SQL别名语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">AS</span> alias_name</span><br></pre></td></tr></table></figure></li></ul><h2 id="连接-JOIN"><a href="#连接-JOIN" class="headerlink" title="连接(JOIN)"></a>连接(JOIN)</h2><ul><li><p>join用于把两个或者多个表结合起来。</p></li><li><p>下面有相关的七种用法<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101103442.png" alt="image-20221110110358365"></p></li><li><p>inner join:如果表中有至少一个匹配，则返回行</p></li><li><p>left join：即使右表中没有匹配，也从左表返回所有的行</p></li><li><p>right join：即使左表中没有匹配，也从右表返回所有的行</p></li><li><p>full join：只要其中一个表中存在匹配，则返回行</p></li></ul><h3 id="SQL连接查询"><a href="#SQL连接查询" class="headerlink" title="SQL连接查询"></a>SQL连接查询</h3><ul><li><p>连接查询是关系数据表中最主要的查询，主要包括内连接，外连接以及交叉连接</p></li><li><p>在关系数据库管理系统中，表建立时各数据之间的关系不一定需要确定，经常把一个实体的所有信息放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息</p></li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><ul><li>内连接是一种最常用的连接类型。内连接查询实际上是一种任意条件的查询。使用内连接时，如果两个表的相关字段满足连接条件，就从这两个表中提取数据并组合成新的记录，也就是在内连接查询中，只有满足条件的元组才能出现在结果关系中</li><li>指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--例如：要查询每个已经选课的学生的情况，查询语句为</span></span><br><span class="line"><span class="comment">--等值连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> S.Sno <span class="operator">=</span> SC.Sno</span><br><span class="line"><span class="comment">--实际使用中常常省略 inner join</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student,SC <span class="keyword">WHERE</span> S.Sno <span class="operator">=</span> SC.Sno</span><br><span class="line"></span><br><span class="line"><span class="comment">--自然连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> S.Sno <span class="operator">=</span> SC.Sno</span><br></pre></td></tr></table></figure><h5 id="左连接left-join"><a href="#左连接left-join" class="headerlink" title="左连接left join"></a>左连接left join</h5></li><li>即使右表中没有匹配，也从左表返回所有的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name A <span class="keyword">left</span> <span class="keyword">join</span> table_name B <span class="keyword">on</span> A.column_name <span class="operator">=</span> B.column_name; </span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> Monggo m <span class="keyword">left</span> <span class="keyword">join</span> site s <span class="keyword">on</span> s.pre <span class="operator">=</span> m.pre;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101104378.png" alt="image-20221110110450327"></p><h5 id="右连接right-join"><a href="#右连接right-join" class="headerlink" title="右连接right join"></a>右连接right join</h5><ul><li>原理同上</li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><ul><li>左边表数据行全部保留，右边表保留符合连接条件的行。<br>双表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure>三表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTC</span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTC.A</span><br></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5></li><li>右边表数据行全部保留，左边表保留符合连接条件的行。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB </span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure><h5 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h5></li><li>左外连接 union 右外连接。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span>  TESTA </span><br><span class="line"><span class="keyword">FULL</span>  <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  TESTB</span><br><span class="line"><span class="keyword">ON</span>  TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="SQL-CREATE-VIEW语句"><a href="#SQL-CREATE-VIEW语句" class="headerlink" title="SQL CREATE VIEW语句"></a>SQL CREATE VIEW语句</h3><ul><li>简化数据访问，让复杂的 SQL 语句简单化。用户只需要对视图写简单的代码就能返回需要的数据，一些复杂的逻辑放在视图中完成。</li><li>防止敏感的字段被选中，同时仍然提供对其它重要数据的访问。</li><li>可以对视图添加一些额外的索引，来提高查询的效率。</li><li>在SQL中，视图时基于SQL语句的结果集的可视化的表</li><li>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段</li></ul><h3 id="SQL-CREATE-VIEW基本格式"><a href="#SQL-CREATE-VIEW基本格式" class="headerlink" title="SQL CREATE VIEW基本格式"></a>SQL CREATE VIEW基本格式</h3><ul><li>视图显示的是最新的数据，每当用户查询视图时候，数据库引擎通过使用视图的SQL语句重建数据。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span> column1，column2....</span><br><span class="line"><span class="keyword">from</span> table_name <span class="keyword">where</span>[<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h3><ul><li><p>SQL CREATE OR REPLACE VIEW语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure></li><li><p>添加</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> [<span class="keyword">current</span> product list] <span class="keyword">AS</span> <span class="keyword">select</span> productID,productName,Category <span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">where</span> discontinued<span class="operator">=</span><span class="keyword">no</span></span><br></pre></td></tr></table></figure></li><li><p>在server上</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> [ schema_name . ] view_name [ ( <span class="keyword">column</span> [ ,...n ] ) ] </span><br><span class="line">[ <span class="keyword">WITH</span> <span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> [ ,...n ] ] </span><br><span class="line"><span class="keyword">AS</span> select_statement </span><br><span class="line">[ <span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION ] [ ; ]</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> ::<span class="operator">=</span> </span><br><span class="line">&#123; </span><br><span class="line">    [ ENCRYPTION ]</span><br><span class="line">    [ SCHEMABINDING ]</span><br><span class="line">    [ VIEW_METADATA ]     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL-基本函数-以下均用SQL-server"><a href="#SQL-基本函数-以下均用SQL-server" class="headerlink" title="SQL 基本函数(以下均用SQL server)"></a>SQL 基本函数(以下均用SQL server)</h2><h3 id="AVG（）"><a href="#AVG（）" class="headerlink" title="AVG（）"></a>AVG（）</h3><ul><li>返回数组列的平均值<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;平均值&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102731.png" alt="image-20221108094247557"></p><h3 id="COUNT（）"><a href="#COUNT（）" class="headerlink" title="COUNT（）"></a>COUNT（）</h3><ul><li><p>返回函数匹配指定条件的值得数目</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(site_id) <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&lt;</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102230.png" alt="image-20221108095113965"></p><h3 id="FIRST（）（SQL-server-TOP-1）"><a href="#FIRST（）（SQL-server-TOP-1）" class="headerlink" title="FIRST（）（SQL server/TOP 1）"></a>FIRST（）（SQL server/TOP 1）</h3><ul><li>返回指定得列中得第一个记录的值<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site  <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102449.png" alt="image-20221108100159623"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102570.png" alt="image-20221108100426725"></li></ol><h3 id="LAST（）（SQL-server-TOP-1-DESC）"><a href="#LAST（）（SQL-server-TOP-1-DESC）" class="headerlink" title="LAST（）（SQL server/TOP 1 + DESC）"></a>LAST（）（SQL server/TOP 1 + DESC）</h3><ul><li><p>返回指定列中的最后一个记录的值(找TOP 1 的倒序)</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TOP <span class="number">1</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&lt;</span><span class="number">100</span> <span class="keyword">order</span> <span class="keyword">by</span> count_ <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101102522.png" alt="image-20221108101150100"></p><h3 id="MAX（）"><a href="#MAX（）" class="headerlink" title="MAX（）"></a>MAX（）</h3><ul><li><p>返回指定列的最大值</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(column_name)<span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;最大值&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101148.png" alt="image-20221108102303157"></p><h3 id="MIN（）"><a href="#MIN（）" class="headerlink" title="MIN（）"></a>MIN（）</h3><ul><li><p>返回指定列的最小值</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MIN</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MIN</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;最小值&#x27;</span> <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101304.png" alt="image-20221108103744764"></p><h3 id="SUM（）"><a href="#SUM（）" class="headerlink" title="SUM（）"></a>SUM（）</h3><ul><li><p>返回返回数值列的总数</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例 </p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101932.png" alt="image-20221108104354535"></p><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li>语句用于结合聚合函数（以上的基本函数就是聚合函数），根据一个或多个列队结果集进行分组<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,aggregate_function(column_name) </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> site_id,<span class="built_in">sum</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site <span class="keyword">group</span> <span class="keyword">by</span> site_id;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101973.png" alt="image-20221108111402398"></p><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li>能够与聚合函数一起使用，用于筛选分组后的各组数据<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name,aggregate_function(column_name) </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br><span class="line"><span class="keyword">Having</span> aggregate_function(column_name) operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> site_id,<span class="built_in">sum</span>(count_) <span class="keyword">as</span> <span class="string">&#x27;总数&#x27;</span> <span class="keyword">from</span> site <span class="keyword">group</span> <span class="keyword">by</span> site_id <span class="keyword">having</span>  <span class="built_in">sum</span>(count) <span class="operator">&lt;</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101257.png" alt="image-20221108112038865"></p><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><ul><li><p>判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s) <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> count_ <span class="keyword">from</span> site <span class="keyword">where</span> count_ <span class="operator">&gt;</span> <span class="number">450</span>);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101930.png" alt="image-20221108114028592"></p><h3 id="UCASE（）-UPPER（）"><a href="#UCASE（）-UPPER（）" class="headerlink" title="UCASE（）(UPPER（）)"></a>UCASE（）(UPPER（）)</h3><ul><li><p>把字段的值转为大写</p><figure class="highlight sql"><figcaption><span>server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">UPPER</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(pre) <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101101226.png" alt="image-20221108121304926"></p><h3 id="LCASE（）-LOWER（）"><a href="#LCASE（）-LOWER（）" class="headerlink" title="LCASE（）/LOWER（）"></a>LCASE（）/LOWER（）</h3><ul><li><p>把字段的值转换为小写</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">LOWER</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">LOWER</span>(pre) <span class="keyword">from</span> site ;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101100031.png" alt="image-20221108122014010"></p><h3 id="MID（）-并不存在SQL-Server"><a href="#MID（）-并不存在SQL-Server" class="headerlink" title="MID（）(并不存在SQL Server)"></a>MID（）(并不存在SQL Server)</h3><ul><li>用于文本字段中提取字符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> MID(column_name,statr,[,length]) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LEN（）"><a href="#LEN（）" class="headerlink" title="LEN（）"></a>LEN（）</h3><ul><li>返回文本中字段的长度<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LEN(column_name)<span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li> 实例<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LEN(pre) <span class="keyword">from</span> site;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101100544.png" alt="image-20221108122515385"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库SQL&quot;&gt;&lt;a href=&quot;#数据库SQL&quot; class=&quot;headerlink&quot; title=&quot;数据库SQL&quot;&gt;&lt;/a&gt;数据库SQL&lt;/h1&gt;&lt;h2 id=&quot;数据库数据定义&quot;&gt;&lt;a href=&quot;#数据库数据定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据库" scheme="https://kalyan-zitiu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://kalyan-zitiu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>KALI之arp欺骗</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/05/KALI%E4%B9%8Barp%E6%AC%BA%E9%AA%97/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/05/KALI%E4%B9%8Barp%E6%AC%BA%E9%AA%97/</id>
    <published>2022-11-05T12:01:04.000Z</published>
    <updated>2022-11-10T02:50:34.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KALI-arp欺骗"><a href="#KALI-arp欺骗" class="headerlink" title="KALI -arp欺骗"></a>KALI -arp欺骗</h1><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ul><li>kali linux</li><li>nmap</li><li>arpspoof</li><li>ettercap</li><li>driftnet</li></ul><h2 id="欺骗原理"><a href="#欺骗原理" class="headerlink" title="欺骗原理"></a>欺骗原理</h2><ol><li><p>ARP的全称是Address Resolution Protocol，翻译而成就是地址解析，需要注意的是这是针对以太网地址解析协议的一种攻击技术，通过欺骗局域网内访问者的PC的网关MAC地址，使访问者PC错以为攻击者的MAC地址才是网关的地址，导致被攻击者的网络不同。甚至可以修改被攻击者的数据报。</p></li><li><p>总的来说改攻击手法并不是让局域网的网络瘫痪而是直接切断所有主机的所有请求和所有该收取的响应。</p></li></ol><h2 id="个人步骤"><a href="#个人步骤" class="headerlink" title="个人步骤"></a>个人步骤</h2><ol><li>用netdiscover -p嗅探局域网内的存活的主机</li><li>一般第一步是很难达到你想要的目标，那么可以改用mrt工具，它可以直接检测目标地址的路由设备。</li><li>那么既然已经找到了路由，就可以通过路由fping自己的ip，这是用自己的ip地址来发出请求嗅探报文，如果有响应的话那么能知道局域网里面哪些ip是存活的，当然也会存在自己无法嗅探到的主机</li><li>既然确定了目标的ip就可以用arpspoof工具进行攻击</li></ol><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><ol><li>目标主机：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101050888.png" alt="image-20221105195940111"></li><li>他急了<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101050924.png" alt="image-20221105200011172"></li></ol>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="KALI" scheme="https://kalyan-zitiu.github.io/categories/KALI/"/>
    
    
    <category term="Kali linux" scheme="https://kalyan-zitiu.github.io/tags/Kali-linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-链路层</title>
    <link href="https://kalyan-zitiu.github.io/2022/11/05/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/11/05/%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-11-05T11:00:04.000Z</published>
    <updated>2022-11-10T02:50:16.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul><li>数据链路层在物理层提供服务的基础上向<strong>网络层提供服务</strong> </li><li>主要作用是加强物理层传输原始比特流的功能，将物理层上提供可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li></ul><h2 id="封装成帧-帧定界"><a href="#封装成帧-帧定界" class="headerlink" title="封装成帧/帧定界"></a>封装成帧/帧定界</h2><ul><li>就是在一段数据前后添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流就可以识别到比特流的开始和结束。简称为”帧定界”</li></ul><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><ul><li>接受方应当能从接收到的二进制比特流中区分出帧的起始和终止。</li><li>组帧的四种方法：1.字符计数法  2.字符填充法  3.零比特填充法  4.违规编码法</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>在链路层上你不可能知道传输的是什么样的比特组合或者什么样类型的数据</li><li>字符计数法<ul><li>帧的首部使用的是一个计数字段来标明帧内字符数</li><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101049727.png" alt="image-20221014152411083"></li><li> 每个帧上的第一个数字代表了帧内有几个字节，但凡哪一个帧第一个字节出错了，整个也就错误了</li></ul></li><li>字符填充法<ul><li>以比特组合来判别帧边界,但传送的帧最好是由文本组成（因为文本文件的字符都是由键盘输入的，都是ASCLL码）</li><li>如果传送的帧是非ASCLL码的文本文件组成时（二进制代码的程序或图像等）。就要采用字符填充的方法来实现透明传输。  </li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161553200.png" alt=" "></li></ul></li><li>零比特填充法<ul><li>  <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161555764.png" alt="image-20221016155534713">理解就可以pass，总结就是5110.</li></ul></li><li>违规编码法<ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210161558795.png" alt="image-20221016155820755"></li></ul></li></ul><h2 id="差错控制（检错编码）"><a href="#差错控制（检错编码）" class="headerlink" title="差错控制（检错编码）"></a>差错控制（检错编码）</h2><h3 id="差错怎么来的"><a href="#差错怎么来的" class="headerlink" title="差错怎么来的"></a>差错怎么来的</h3><ul><li>差错总的概括可以说是因为线路本身电气特性所产生的随机噪声（热噪声），是固有的且随机存在的<h3 id="差错类型"><a href="#差错类型" class="headerlink" title="差错类型"></a>差错类型</h3><h4 id="位错"><a href="#位错" class="headerlink" title="位错"></a>位错</h4></li><li>比特位出错，1和0的变化<h4 id="帧错"><a href="#帧错" class="headerlink" title="帧错"></a>帧错</h4>现有[#1]-[#2]-[#3];</li><li>丢失：[#1]-[#3]；</li><li>重复：[#1]-[#2]-[#2]-[#3]；</li><li>失序：[#1]-[#3]-[#2]；</li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>差错控制（比特位）</p><h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><ul><li>奇偶校验码（1个校验元和n-1个信息元）<ul><li>奇校验码：”1”的个数为奇数，而且错误是奇数个检验错误</li><li>偶校验码：”1”的个数为偶数 ，错误是偶数个检验错误</li></ul></li><li>CRC循环冗余码<ul><li>发送端：最终发送的数据等于要发送的数据+帧检验序列FCS</li><li>计算冗余码：1.加0   2.模2除法：数据加0后处于多项式，余数就是为冗余码FCS</li><li>发送端顺序：<ul><li>1.接受发送的数据</li><li>2.采用CRC校验</li><li>3.生成多项式</li><li>4.计算冗余码</li><li>5.把发送数据加上冗余码如”1101011011”+”1110”=”11010110111110”</li></ul></li><li>接收端顺序：<ul><li>收到的每一个帧都除以同样的除数，然后检查得到的余数R。</li><li>1.余数为0，无错，接受 2.余数不为0，有错，丢弃 <h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><h5 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h5></li></ul></li></ul></li><li>注意：海明码是能发现双比特错误，但是只能纠正单比特错误。</li><li>工作流程=确认校验码位数r+确认校验码和数据的位置+求出校验码的值+检错并纠错<h5 id="确认校验码位数r"><a href="#确认校验码位数r" class="headerlink" title="确认校验码位数r"></a>确认校验码位数r</h5></li><li>海明不等式： 2^r^&gt;=k+r+1(r为冗余信息位，k为信息位)</li><li>列子：发送数据101101。数据位是6位，那么根据公式r则最小的是4位，那么海明码的位数就需要是6+4=10位，其中的原数据是6位，校验码是4位。</li></ul><h5 id="确认校验码和数据的位置"><a href="#确认校验码和数据的位置" class="headerlink" title="确认校验码和数据的位置"></a>确认校验码和数据的位置</h5><ul><li><p>校验码只能放在2的几次方上的位置</p></li><li><p>先计算好总的数据位，然后先安排校验码的放入，最后把数据按序填满</p></li><li><p>例子：<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210170854928.png" alt="image-20221017085425891"></p></li><li><p>P类为校验码，D类为数据位</p></li><li><p>看P<del>1</del>的第一位是1，所以所有第一位为一数据位和校验码都得一起异或为0，这样就能求出P<del>1</del>的值</p></li><li><p>以此类推求出其他的P值</p></li></ul><h5 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h5><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210170924679.png" alt="s"></li><li>以上图为例子数据位是101101，则加上海明码后收到的是0010111101。</li><li>令所有要校验的位继续异或运算得出的二进制序列0101恰好对应十进制的5，所以出错的位置就是5并且改为反码<h4 id="数据链路层和物理层的数据编码的区别"><a href="#数据链路层和物理层的数据编码的区别" class="headerlink" title="数据链路层和物理层的数据编码的区别"></a>数据链路层和物理层的数据编码的区别</h4></li><li>物理层针对的是单个比特，解决传输过程中比特的同步等问题，列如曼彻斯特编码</li><li>数据链路层</li></ul><h4 id="冗余编码"><a href="#冗余编码" class="headerlink" title="冗余编码"></a>冗余编码</h4><ul><li>在数据发送之前，先按某种关系附加上一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时。相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否符合原规则，从而判断是否出错。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>较高的发送速度和较低的接受能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</li><li>数据链路层的流量控制是点对点的，而传输层是端到端的</li><li>数据链路层流量控制手段：接收方收不下就不回复确认</li><li>传输层流量控制手段：接收端给发送端一个窗口公告。</li></ul><h2 id="流量控制的方法"><a href="#流量控制的方法" class="headerlink" title="流量控制的方法"></a>流量控制的方法</h2><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><ul><li><p>每发送一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧</p></li><li><p>发送窗口大小=1，接收窗口大小=1</p><h4 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h4></li><li><p>丢包：物理线路故障，设备故障，病毒攻击，路由信息错误等原因，会导致数据包的丢失</p><h5 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210251501765.png" alt="image-20221025150130693"></p><h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h5><h6 id="数据帧丢失或检测到帧出错"><a href="#数据帧丢失或检测到帧出错" class="headerlink" title="数据帧丢失或检测到帧出错"></a>数据帧丢失或检测到帧出错</h6></li><li><p>数据帧丢失或检测到帧出错，所有会存在一个超时计时器：每发送一个帧就启动一个计时器，但超时计时器设置的重传实践应当比帧的传输的平均RTT更长一些</p></li><li><p>发完一个帧后，必须保留它的副本。数据帧和确认帧必须编号</p></li></ul><h6 id="ACK确认帧的丢失或迟到"><a href="#ACK确认帧的丢失或迟到" class="headerlink" title="ACK确认帧的丢失或迟到"></a>ACK确认帧的丢失或迟到</h6><ul><li><p>丢失</p><ul><li>发送方在超时后，会重传数据帧</li><li>接收方会收到后会丢弃重传的数据帧，然后重新发送确认帧</li></ul></li><li><p>迟到</p><ul><li>如果发送方发了一个1号数据帧，1号确认帧却迟到到下一个2号帧发送后才被发送方接收到，这时候发送方会把1号的确认帧直接丢弃<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4></li></ul></li><li><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期地比率</p><h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3></li><li><p>发送窗口大小&gt;1，接收窗口大小=1</p></li><li><p>流水线技术，需要增加序号范围</p></li><li><p>发送方需要缓存多个分组</p><h4 id="GBN中的滑动窗口"><a href="#GBN中的滑动窗口" class="headerlink" title="GBN中的滑动窗口"></a>GBN中的滑动窗口</h4></li><li><p>发送窗口：发送方维持一组连续的允许发送的帧的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261712772.png" alt="image-20221026171201711"></p></li><li><p>接收窗口：接受方维持一组连续允许接收帧的序号<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261712878.png" alt="image-20221026171237832"></p><h5 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h5></li><li><p>上层的调用</p><ul><li>上层要发送数据时候，需要先查看发送方的窗口是否已满，未满则生成一个帧并且发送，若已满的， 发送方会缓存数据，等窗口空闲之后发送</li></ul></li><li><p>对ACK确认帧的响应</p><ul><li>GBN协议中，对n号的确认采用的是累积确认的方式，标明接收方已经收到了n号帧和它之前的全部帧 </li><li>累积确认：如果接收方收到了3号帧的确认帧，也就是说他已经收到了0到2号的所有帧，并且发送了确认帧</li></ul></li><li><p>超时事件 </p><ul><li>来源于出现丢失或者时延过长帧时发送方的行为。也会存在一个计时器再次用户恢复数据或者确认帧丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。<h5 id="接收方需要干的b事"><a href="#接收方需要干的b事" class="headerlink" title="接收方需要干的b事"></a>接收方需要干的b事</h5></li></ul></li><li><p>正确并且按序收到n号帧，那么会发送n号确认帧，并且把数据交付于上层</p></li><li><p>只要不是按照顺序收到的帧都会丢弃掉，并且会为需要接收的序号帧发送ACK，接收方不需要做任何缓存，只需要维护信息的有序性（比如现在我要收的是1号帧，如果其他帧来了的话，一律丢弃）</p></li></ul><h5 id="滑动窗口的长度"><a href="#滑动窗口的长度" class="headerlink" title="滑动窗口的长度"></a>滑动窗口的长度</h5><ul><li>根据n个比特对帧编号，窗口尺寸应满足：1&lt;=w&lt;=2^n^-1</li></ul><h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a><strong>选择重传协议（SR）</strong></h3><ul><li>发送窗口大小&gt;1，接收窗口大小&gt;1</li><li>GBN因为有按序列的需求，所以后面本来能够传到的数据帧都得重新传输</li></ul><h4 id="选择重传的滑动窗口"><a href="#选择重传的滑动窗口" class="headerlink" title="选择重传的滑动窗口"></a>选择重传的滑动窗口</h4><ul><li>发送方：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261909294.png" alt="image-20221026190921230"></li><li>上层调用<ul><li>大致与GBN一样，收到数据后，如果没有窗口空闲，要么将数据缓存，要么就返回上层</li></ul></li><li>ACK<ul><li>如果收到了一个ACK，确认后，发送方可以将那个帧标记为已经接收。那么等到前面的序号帧确认完毕后，可以直接把窗口移到未确定的序号帧。比如我现在可以发送序号1，2，3帧，我的1号帧是未确定的，2号帧是已经确定的，3号帧是未发生的。那么等到1号帧确认完毕后，就可以直接把窗口跳到3号帧，不必再在2号帧逗留。</li></ul></li><li>超时事件<ul><li>每个帧都有自己的计时器，一个超时事件发生后只能重传一个帧 </li></ul></li></ul><ul><li>接收方：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202210261916895.png" alt="image-20221026191658841"></li><li>在窗口内的所有帧来者不拒<ul><li>只要接收到窗口内的帧，就直接载入缓存并且返回一个ACK确认帧，只要在窗口内的有连续的帧都已经收到后就可以将窗口移出该连续帧前进。</li><li>但是如果接收方收到了窗口以外的序号帧，第一种情况时小于窗口序号的，只要在窗口长度内的所有已确定帧再次收到传来的帧就会返回一个ACK确认帧回去。第二种情况就是大于窗口序号的，就直接不接受。 </li></ul></li></ul><h4 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h4><ul><li>发送窗口最好等于接收窗口。</li><li>当有n个比特对帧编号时候，就可有2^(n-1)^个发送窗口。</li></ul><h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><h3 id="点对点链路"><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h3><ul><li><p>两个相邻的节点通过一个链路相连，没有第三者。应用：PPP协议，常用于广域网</p><h3 id="广播式链路"><a href="#广播式链路" class="headerlink" title="广播式链路"></a>广播式链路</h3></li><li><p>应用范围比较小的局域网，通信范围比较大，所有主机共享通信介质。常用于无线局域网。</p></li><li><p>典型的拓扑结构：总线型，星型也就是逻辑总线型</p></li><li><p>分别对应下图：<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021411550.png" alt="image-20221102141117479"></p><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><h4 id="静态划分信道–信道划分介质访问控制"><a href="#静态划分信道–信道划分介质访问控制" class="headerlink" title="静态划分信道–信道划分介质访问控制"></a>静态划分信道–信道划分介质访问控制</h4></li><li><p>概述：将使用介质的每个设备与来自于同一信道上的其他设备通信分隔开，把时域和频域资源合理地分配给网络上的设备</p></li><li><p>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高资源信道利用率。把一条广播信道，逻辑上分成几条用于两个节点之间通信互不干扰的子信道，实际就是把广播信道转变为点对点信道。</p><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021434326.png" alt="image-20221102143430276"></p></li><li><p>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</p></li><li><p>充分利用传输介质，系统效率较高。</p><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021441005.png" alt="image-20221102144128959"></p></li><li><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用着固定序号的时隙，所有用户轮流占用信道</p></li><li><p>举个很简单的例子：我们把<strong>TDM帧想象成一个洗澡间</strong>，现有四个人可以使用这个洗澡间洗澡，但是他们需要彼此间<strong>拿个序号</strong>分别为A，B，C，D。按照<strong>排序来轮流</strong>使用这个洗澡间。</p></li><li><p>TDM帧是在物理层传送的比特流所划分的帧，标志着一个周期。</p></li><li><p>因为大家都要轮流使用这个TDM帧，所以固定有个周期，那么某个主机需要使用信道时候，必须要等待其他三个都处于休息状态，那么信道利用率就会比较低。</p><h6 id="时分复用TDM-MAX高效率版–统计时分复用STDM"><a href="#时分复用TDM-MAX高效率版–统计时分复用STDM" class="headerlink" title="时分复用TDM MAX高效率版–统计时分复用STDM"></a>时分复用TDM MAX高效率版–统计时分复用STDM</h6></li><li><p>其实也就多了一个集中器，功能就是收集多个用户的数据一起发送到外面</p></li><li><p>注意了STDM帧并不是链路层的帧，是物理层比特流上划分的帧</p></li><li><p><strong>STDM帧中的时隙数小于连接在集中器上的用户数。</strong>用户一有数据就可以<strong>随时发往集中器中缓存</strong>，集中器再根据<strong>顺序扫描输入缓存</strong>，再放入到STDM帧中。<strong>达到了一定的时隙数就会发送一个STDM帧。</strong>当然STDM帧的时隙数并不是固定的，而是按<strong>照需求来分配时隙</strong>的，但是可以肯定地是它是会小于这个TDM帧上的用户数。</p><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h5></li><li><p>其实就是用光的频分多路复用，在一个光纤中传输多种不同地波长地光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h5></li><li><p>码分多址CDMA，1个比特分为多个码片/芯片，每个站点会制定一个唯一地m位地芯片序列。</p></li><li><p>发送1时站点发送芯片序列，发送0时则发送他的反码（通常把0写成-1）。</p></li><li><p>那么他们怎么不打架呢。多个站点同时发送数据的时候，要求各个站点芯片序列相互正交（对位相乘然后相加除以m位，等于0的话就可以一起发送）。</p></li><li><p>那么他们怎么合并呢，各路数据再信道中被线性相加（对应位置相加）</p></li><li><p>那么怎么分离呢，合并数据和源站规格化内积（对应位置相乘相加，处于总和）。</p></li></ul><h4 id="动态分配信道"><a href="#动态分配信道" class="headerlink" title="动态分配信道"></a>动态分配信道</h4><h5 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h5><h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h6><ul><li>每个局域网会有一个老大主机叫主结点，它会轮流邀请从属结点发送数据。</li><li>被邀请的主机可以选择要不要发数据，要则发不要则跳过，在老大询问主机时，其他主机均不具备发数据的能力，因为要没被邀请到。</li><li>因此它是不会发生冲突，而且还能占用全部的带宽。</li><li>1.那么就会有轮询开销，等待延迟，单点故障<h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h6></li><li>令牌：一个特殊格式的MAC控制帧，不含有任何信息。只有手持令牌的主机才能进行数据操作，能够控制信道的使用，确保同一时刻只有一个结点独占信道。</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031144247.png" alt="image-20221103114405194"></p><ul><li>主机得到令牌后如果需要进行数据发送的话，那么就需要吃下令牌，并对标志位进行修改，把令牌从空闲状态转变为繁忙状态。</li><li>主机会把自己需要发送的数据和令牌结合构成一个数据帧，发送到一个目标主机处</li><li>目标主机发现<strong>数据帧（其实就是带着数据的令牌）</strong>是给自己的，那么目标主机会把数据帧copy一份缓存，然后再把数据帧发还给源主机。</li><li>源主机收到自己的数据帧后会<strong>检查是否出错</strong>，如果出错了会进行重传，没有则会回收。并把令牌空闲下来。</li><li>那么就会存在，令牌开销（令牌可能丢失），等待延迟（其他主机需要等待发送），单点故障（因处于在星型网状网络，若一个主机宕机，那么环形将受到破坏）</li></ul><h5 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h5><h6 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h6><ul><li>纯ALOHA协议<ul><li>不会监听信道，不按时间槽发送，随机重发。想发就发。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021540073.png" alt="image-20221102154037015"></li><li>冲突检测：接收方能够检测出差错，然后不确认，发送方在一定时间内收不到确认帧，那么就判定为冲突。</li></ul></li><li>时隙ALOHA协议<ul><li>把时间分为若干相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片再发送<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021558989.png" alt="image-20221102155832935"><h6 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h6></li></ul></li><li>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机再发送数据</li><li>当几个站同时再总线上发送数据时候，总线上的信号电压摆动值将会增大，当一个站检测出信号电压摆动值超过他们设定的一个门限值后，就认为总线上至少有两个站同时发送数据，表明产生了碰撞，即发生了冲突 </li><li>MA：多点接入，表示许多计算机以多点接入的方式连接再一根总线上</li><li>总的思想就是监听信道，信道空闲就发生，忙就推迟发送，<ul><li>1- 坚持CSMA思想，监听信道，一直监听到信道不忙为止，能够在第一时间发现媒体空闲，马上发送。但是如果有两个或者两个以上的站点需要发送，那么很有可能发生冲突</li><li>非坚持CSMA思想，监听信道，信道不空闲的话，会等待一个随机时间再进行监听，能够减少冲突发生的可能性。</li><li>p-坚持CSMA，监听信道，空闲则以p概率直接传输，不等待，概率1-p等到下一个时间槽再传输。忙的话等待一个随机时间再监听，减少冲突。但是，发生冲突后还是会坚持把数据帧都发送完，造成浪费。<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211021617521.png" alt="image-20221102161719454"><h6 id="载波监听多点接入-碰撞检测CSMA-CD"><a href="#载波监听多点接入-碰撞检测CSMA-CD" class="headerlink" title="载波监听多点接入/碰撞检测CSMA/CD"></a>载波监听多点接入/碰撞检测CSMA/CD</h6>CD:碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，一边判断自己在发送数据时其他站点是否也发送数据。<br>####### 传播时延对载波监听的影响</li></ul></li><li>单程端到端的传播时延：t<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031217333.png" alt="image-20221103121744238"></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031219305.png" alt="image-20221103121939250"></p><p>####### 截断二进制指数规避算法</p><ul><li>确定基本退避(推迟)时间为争用期2tao</li><li>定义参数k，它等于重传次数，但k不超过10，即k=min[重传次数，10]。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，k就不再增大而一直等于10。</li><li>从离散的整数集合[0，1，2<del>k</del>-1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rtao</li><li>当重传大16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li><li>如果连续多次发生冲突，表明可能有很多站参与数据交流。 </li></ul><p>####### 最小帧长问题</p><ul><li>帧的传输时延至少要两倍于信号在总线中的传播时延</li><li>最小帧长=总线传播时延 x 数据传输速率 x 2。</li><li>以太网规定最短帧长为64B，凡是长度小于64B的都是由于冲突而异常终止的无效帧。 <h6 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h6></li><li>CA：碰撞避免，主要应用于无线局域网</li><li>发送数据前，监听信道是否空闲</li><li>空闲则发出RTS，RTS包括发射端的地址，接收端的地址，下一份数据将持续发送的时间等信息;信道忙则等待。</li><li>接收端收到RTS后，将响应CTS。</li><li>发送端收到CTS后，开始发送数据帧（同时：预约信道：发送方告知其他站点自己要用多久时间去传输）</li><li>接收端收到数据后，会用CRC来检验数据帧是否正确，正确则响应ACK帧</li><li>发送方收到ACK帧就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）</li><li>1.预约信道，2. ACK帧，3. RTS/CTS帧（可选）</li></ul><h2 id="局域网基本概念及体系结构"><a href="#局域网基本概念及体系结构" class="headerlink" title="局域网基本概念及体系结构"></a>局域网基本概念及体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><ul><li>简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</li><li>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>特点2：使用专门铺设的传输介质(双绞线，同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s)。</li><li>特点3：通信延迟时间短，误码率低，可靠性较高</li><li>特点4：各站为平等关系，共享传输信道</li><li>特点5：多采用分布式控制和广播式通信，能进行广播和组播</li><li>决定局域网的主要因素：网络拓扑，传输介质，介质访问控制方法</li></ul><h3 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211031505307.png" alt="image-20221103150550233"></p><ul><li>星型拓扑：中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构形简单，建网容易，便于控制和管理。但这种网络系统，网络可靠性低，网络共享能力差，有单点故障问题。</li><li>总线型拓扑：网络可靠性高，网络节点间响应速度快，共享资源能力强，设备投入量少，成本低，安装使用方便，当某个工作站节点出现故障时，对整个网络系统影响小。 </li><li>环形拓扑：系统中通信设备和线路比较节省。有单点故障问题；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低</li><li>树型拓扑：易于拓展，易于隔离故障，也容易有单点故障。</li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><ul><li>CSMA/CD常用于总线型局域网，也用于树型网络</li><li>令牌总线常用于总线型局域网，他把总线型的各个工作站按一定顺序按接口地址大小排列成一个逻辑环 ，只有令牌持有者才能控制总线，才有发送信息的权力</li><li>令牌环，用于环形局域网，如令牌环网 </li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ol><li><p>概述：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps），快速以太网，千兆以太网和10G以太网，他们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA/CD。</p></li><li><p>令牌环网：物理上采用了星型拓扑结构</p></li><li><p>FDDI网 ：物理上采用了双拓扑结构，逻辑上是环形拓扑结构</p></li><li><p>ATM网：较新型的单元交换技术，使用53字节固定长度的单元进行交换。</p></li><li><p>无线局域网：采用IEEE 802.11标准</p></li></ol><h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><ul><li>是IEEE 802 LAN/MAN标准委员会制定的局域网，城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网，令牌环，无线局域网等。这一系列标准中的每一个子标准都有委员会的一个专门工作组负责。</li></ul><p>IEEE 802.1 ：局域网体系结构、寻址、网络互联和网络</p><p>IEEE 802.1A：概述和系统结构</p><p>IEEE 802.1B：网络管理和网络互连</p><p>IEEE 802.2 ：逻辑链路控制子层（LLC）的定义。</p><p>IEEE 802.3 ：以太网介质访问控制协议 （CSMA/CD）及物理层技术规范 [1]  。</p><p>IEEE 802.4 ：令牌总线网（Token-Bus）的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.5 ：令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。</p><p>IEEE 802.7 ：宽带技术咨询组，提供有关宽带联网的技术咨询。</p><p>IEEE 802.8 ：光纤技术咨询组，提供有关光纤联网的技术咨询。</p><p>IEEE 802.9 ：综合声音数据的局域网（IVD LAN）介质访问控制协议及物理层技术规范。</p><p>IEEE 802.10：网络安全技术咨询组，定义了网络互操作的认证和加密方法。</p><p>IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。</p><p>IEEE 802.11，1997年，原始标准（2Mbit/s，播在2.4GHz）。</p><p>IEEE 802.11a，1999年，物理层补充（54Mbit/s，播在5GHz）。</p><p>IEEE 802.11b，1999年，物理层补充（11Mbit/s播在2.4GHz）。</p><p>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</p><p>IEEE 802.11d，根据各国无线电规定做的调整。</p><p>IEEE 802.11e，对服务等级（Quality of Service, QoS）的支持。</p><p>IEEE 802.11f，基站的互连性（IAPP，Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</p><p>IEEE 802.11g，2003年，物理层补充（54Mbit/s，播在2.4GHz）。</p><p>IEEE 802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</p><p>IEEE 802.11i，2004年，无线网络的安全方面的补充。.</p><p>IEEE 802.11j，2004年，根据日本规定做的升级。</p><p>IEEE 802.11l，预留及准备不使用。</p><p>IEEE 802.11m，维护标准；互斥及极限。</p><p>IEEE 802.11n，更高传输速率的改善，基础速率提升到72.2Mbit/s，可以使用双倍带宽40MHz，此时速率提升到150Mbit/s。支持多输入多输出技术（Multi-Input Multi-Output，MIMO）。</p><p>IEEE 802.11k，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</p><p>IEEE 802.11p，这个通信协定主要用在车用电子的无线通信上。它设置上是从IEEE 802.11来扩充延伸，来符合智能型运输系统（Intelligent Transportation Systems，ITS）的相关应用。</p><p>IEEE 802.11ac，802.11n的潜在继承者,更高传输速率的改善，当使用多基站时将无线速率提高到至少1Gbps，将单信道速率提高到至少500Mbps。使用更高的无线带宽(80MHz-160MHz)(802.11n只有40MHz),更多的MIMO流(最多8条流),更好的调制方式(QAM256)。目前是草案标准(draft)，预计正式标准于2012年晚些时间推出。Quantenna公司在2011年11月15日推出了世界上第一只采用802.11ac的无线路由器。Broadcom公司于2012年1月5日也发布了它的第一支支持802.11ac的芯片。</p><p>IEEE 802.11ae-2012</p><p>IEEE 802.12 ： [1]  [2-3]  需求优先的介质访问控制协议（100VG AnyLAN）。</p><p>IEEE 802.13 ：(未使用 )【不吉利的数字，没有人愿意使用它—查自《计算机网络-Andrew S. Tanebaum》 Page 63 - 1.6.2 国际标准领域中最有影响的组织】</p><p>IEEE 802.14：采用线缆调制解调器(Cable Modem)的交互式电视介质访问控制协议及网络层技术规范。</p><p>IEEE 802.15：采用蓝牙技术的无线个人网（Wireless Personal Area Networks，WPAN）技术规范。</p><p>IEEE 802.15.1：无线个人网络。</p><p>IEEE 802.15.4：低速无线个人网络</p><p>IEEE 802.16：宽带无线连接工作组，开发2~66GHz的无线接入系统空中接口。</p><p>IEEE 802.17：弹性分组环 （Resilient Packet Ring，RPR）工作组，制定了单性分组环网访问控制协议及有关标准。</p><p>IEEE 802.18：宽带无线局域网技术咨询组（Radio Regulatory）。</p><p>IEEE 802.19：多重虚拟局域网共存（Coexistence）技术咨询组。</p><p>IEEE 802.20：移动宽带无线接入（ Mobile Broadband Wireless Access ，MBWA）工作组，制定宽带无线接入网的解决 。</p><p>IEEE 802.21：媒介独立换手（Media Independent Handover）。</p><p>IEEE 802.22： [4]  无线区域网（Wireless Regional Area Network）</p><p>IEEE 802.23：紧急服务工作组 （Emergency Service Work Group）</p><h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><ul><li><p>LLC负责识别网络层协议，然后对他们进行封装，LLC报头会告诉这个数据链路层一旦帧被接收了，应当对数据包做什么处理。为网络层提供服务：无确认无连接，面向连接，带确认无连接，高速传送。</p></li><li><p>MAC子层的主要功能包括数据帧的封装和卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性</p></li></ul><h2 id="以太网（802-3局域网）"><a href="#以太网（802-3局域网）" class="headerlink" title="以太网（802.3局域网）"></a>以太网（802.3局域网）</h2><ul><li>以太网使用CSMA/CD（载波监听多路访问及冲突检测）技术。</li><li>两个标准<ul><li>DIX Ethernet V2：第一个局域网产品规约</li><li>IEEE802.3：IEEE802委员会802.3工作组指定的第一个IEEE的以太网标准</li></ul></li></ul><h3 id="无连接，不可靠服务"><a href="#无连接，不可靠服务" class="headerlink" title="无连接，不可靠服务"></a>无连接，不可靠服务</h3><ul><li>无连接：发送方和接收方之间无“握手过程”</li><li>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</li><li>以太网只实现无差错接收，不实现可靠传输</li></ul><h3 id="以太网传输介质与拓扑结构的发展"><a href="#以太网传输介质与拓扑结构的发展" class="headerlink" title="以太网传输介质与拓扑结构的发展"></a>以太网传输介质与拓扑结构的发展</h3><ul><li>粗同轴电缆到细同周电缆到双绞线+集线器。</li><li>集线器的以太网的逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。</li><li>以太网拓扑：逻辑上总线型，物理上星型。</li></ul><h3 id="10ASE-T以太网"><a href="#10ASE-T以太网" class="headerlink" title="10ASE-T以太网"></a>10ASE-T以太网</h3><ul><li>10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE—T采用的是无屏蔽双绞线（UTP），物理上是采用星型拓扑，逻辑上总线型，每段双绞线最长为100m，用的是曼彻斯特编码</li></ul><h3 id="适配器（网卡）和MAC地址"><a href="#适配器（网卡）和MAC地址" class="headerlink" title="适配器（网卡）和MAC地址"></a>适配器（网卡）和MAC地址</h3><ul><li>计算机与外界有局域网的连接时通过通信适配器的</li><li>网络接口板，网络接口卡NIC</li><li>NOW，不再使用单独网卡</li><li>适配器上装有处理器和储存器</li><li>ROM上有计算机硬件地址MAC地址。</li><li>在局域网中，硬件地址又称为物理地址或MAC地址</li><li>MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家（IEEE规定，后24位厂家自己规定，常用6个十六进制数表示）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211032141205.png" alt="image-20221103214140094"></li></ul><h3 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h3><ul><li>MAC帧最常用的是以太网V2的格式<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051442023.png" alt="image-20221105144230956"></li></ul><h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h3><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051455378.png" alt="image-20221105145531318"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051500542.png" alt="image-20221105150008469"></p><h3 id="无线局域网分类"><a href="#无线局域网分类" class="headerlink" title="无线局域网分类"></a>无线局域网分类</h3><h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051702001.png" alt="image-20221105170215891"></p><ul><li>AP<del>1</del>，AP<del>2</del>，都是这个基本服务集BSS中的一个基站</li><li>在这个基本服务集内的所有主机都可以进行数据分享</li><li>那么夸服务集交流数据的话，那么就要通过基站与基站之间交流来达到跨网传输</li></ul><h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><ul><li>各节点的地位相同，可以发送数据也可以接收数据</li><li>自己组成网络，自由度比较高</li></ul><h2 id="PPP协议和HDLC协议"><a href="#PPP协议和HDLC协议" class="headerlink" title="PPP协议和HDLC协议"></a>PPP协议和HDLC协议</h2><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><ul><li><p>通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨，几个大洲提供远距离通信，形成国际性的远程网络</p></li><li><p>通信子网主要使用分组交换技术。广域网的通信子网可以利用公网分组交换网，卫星通信网和无线分组交换网，它将分布在不同地区局域网或计算机系统互连起来，达到资源共享的目的，如因特网是世界上范围内最大的广域网。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051721183.png" alt="image-20221105172105114"></p><h3 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h3><ul><li>点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般使用PPP协议</li><li>不用需要任何纠错以及序号和流量控制</li><li>封装成帧，透明传输</li><li>多种网络层协议，封装的IP数据报可以采用多种协议</li><li>多种类型链路：串行/并行，同步/异步，电与光。</li><li>差错检测，错就丢弃</li><li>检测连接状态，链路是否能够正常工作</li><li>网络层地址协商 知道通信双方的网络层地址</li><li>数据压缩</li></ul><h4 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h4><ol><li>一个将IP数据报封装到串行链路的方法</li><li>链路控制协议LCP：建立并且维护数据链路连接，身份验证</li><li>网络层控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li></ol><h4 id="PPP协议的状态图"><a href="#PPP协议的状态图" class="headerlink" title="PPP协议的状态图"></a>PPP协议的状态图</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051748583.png" alt="image-20221105174847515"></p><h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051749395.png" alt="image-20221105174951330"></p><ol><li>F/7E（十六进制）（八进制01111110）:标志字段也就是帧定界符</li><li>转义字符详细见透明传输</li><li>A:地址字段</li><li>C:控制字段</li><li>协议部分（IP数据报，LCP数据，网络控制数据）</li><li>PPP协议是面向字节的协议</li></ol><h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h4><ol><li><p>高级数据链路控制，是一个同步网上传输数据，面向比特的数据链路层协议，它是由国际化标准化组织ISO根据IBM公司的SDLC协议扩展开发而成</p></li><li><p>数据报文可以透明传输，用的是零比特插入法，能够便于硬件实现</p></li><li><p>采用的帧检验方法是CRC检验，对信息帧进行顺序编号，防止漏收或重份，传输可靠性高</p></li></ol><h4 id="HDLC站"><a href="#HDLC站" class="headerlink" title="HDLC站"></a>HDLC站</h4><ol><li>主站的主要功能是发送命令帧，接收响应帧，负责对整个链路的控制系统的初启，流程的控制，差错检测或恢复等。</li><li>从站的主要功能是接收由主站发来的命令帧，向主站发出响应帧，并且配合主站参与差错恢复等链路控制</li><li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制</li></ol><h4 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051805237.png" alt="image-20221105180545174"></p><ul><li>信息帧(I)第一位为0，用来传输数据信息，或使用捎带技术对数据进行确认</li><li>监督帧(S)10，用于流量控制和差错控制，执行对信息帧的确认，请求重发和请求暂停发送等功能</li><li>无编号帧(U)11，用于提供对链路的建立，拆除等多种控制功能。</li></ul><h4 id="PPP与HDLC协议的区别"><a href="#PPP与HDLC协议的区别" class="headerlink" title="PPP与HDLC协议的区别"></a>PPP与HDLC协议的区别</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211051812956.png" alt="image-20221105181204864"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;h2 id=&quot;功能概述&quot;&gt;&lt;a href=&quot;#功能概述&quot; class=&quot;headerlink&quot; title=&quot;功能概述&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Articles in English#3</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/26/Englishwork(3)/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/26/Englishwork(3)/</id>
    <published>2022-10-26T13:11:04.000Z</published>
    <updated>2022-10-26T13:14:41.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Most-Unforgettable-Person-I-Ever-Know"><a href="#The-Most-Unforgettable-Person-I-Ever-Know" class="headerlink" title="The Most Unforgettable Person I Ever Know"></a>The Most Unforgettable Person I Ever Know</h1><p>​    In my main,the most unforgettable person I ever know is Stephen William Hawking. I was touched by both his achievements and difficult stories</p><p>​    In 1963, at the age of 21, Hawking developed muscular wasting lateral sclerosis (Lou Gehrig’s disease), paralyzed, unable to speak, and had only three fingers on his hands to move. From 1979 to 2009, Lucas Professor of Mathematics, his main research areas are cosmology and black holes, proving the singularity theorem of general relativity and the area theorem of black holes, proposing the theory of black hole evaporation and the boundaryless Hawking cosmological model, and taking an important step in unifying the two basic theories of physics in the 20th century, Einstein’s theory of relativity and Planck’s quantum mechanics. He has received honors such as CH (British Honorary Lord), CBE (Commander of the Order of the British Empire), FRS (Fellow of the Royal Society), FRSA (Fellow of the Royal Society of Arts).</p><p>​      In the 21st episode of the fifth season of the hit American drama “The Big Bang Theory” broadcast on April 6, 2012, Stephen Hawking starred in a cameo. In 2017, he recorded the documentary “Exploring the New Earth” for the British BBC. [1] In November of the same year, Hawking said that technology is expected to reverse some of the harm caused by industrialization to the planet and help eradicate disease and poverty, but artificial intelligence needs to be controlled [2] , and predicted that the earth may become a “fireball” in 2600 years when energy consumption increases.</p><p>​     On March 14, 2018, Hawking passed away at the age of 76. After Hawking’s death, it caused mourning from all walks of life around the world.</p><p>​    The legend of his life is really memorable and fascinating</p>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="杂谈" scheme="https://kalyan-zitiu.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="English" scheme="https://kalyan-zitiu.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>神奇的Morris遍历</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/24/Morris%20%E9%81%8D%E5%8E%86/</id>
    <published>2022-10-24T14:30:04.000Z</published>
    <updated>2022-10-25T04:26:13.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>一种遍历二叉树的方式，并且时间复杂度O(N)，额外空间复杂度O(1)。<strong>通过利用原树中大量空闲右指针的方式，达到节省空间的目的</strong>。</li><li>Morris的本质是线索二叉树（Threaded Bianry Tree）。本质是利用二叉树中n+1个指向NULL的指针。</li><li>Morris遍历的关键<ul><li><strong>利用一棵树上大量的右指针空闲空间</strong></li></ul></li><li>Morris遍历细节<ul><li>假如现在有个当前节点cur，开始时cur再root的位置</li><li>1.如果cur没有左孩子，cur向右移动</li><li>2.如果cur有左孩子，找到左子树上最右的节点 mostRight<ul><li>a.如果mostRight.right为null，就让其指向cur，也就是mostRight.right=cur,然后cur向左移动cur=cur.left。</li><li>b.如果mostRight.right=cur,则让其指向null，然后cur向右移动cur=cur.right.</li><li>3.cur为空时遍历停止。</li></ul></li></ul></li><li>morris序<ul><li>任何结点只要有左树，都会来两次，而且是在遍历完左树后，第二次回到这个结点；如果某个结点没有左树，只会到一次。</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Morris-先序遍历"><a href="#Morris-先序遍历" class="headerlink" title="Morris 先序遍历"></a>Morris 先序遍历</h3><ul><li>思路：对于能回到自己两次的结点，在第一次到的时候就处理;对于只会到达一次的结点，就直接处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; stoge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">       TreeNode mostRight=<span class="literal">null</span>;</span><br><span class="line">       TreeNode cur=root;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> stoge;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">           mostRight=cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur)&#123;</span><br><span class="line">                   mostRight=mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                   stoge.add(cur.val);</span><br><span class="line">                   mostRight.right=cur;</span><br><span class="line">                   cur=cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   mostRight.right=<span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   stoge.add(cur.val);</span><br><span class="line">               &#125;</span><br><span class="line">               cur=cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> stoge;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Morris-中序遍历"><a href="#Morris-中序遍历" class="headerlink" title="Morris 中序遍历"></a>Morris 中序遍历</h3><ul><li>思路：对于能回到自己两次的结点，在第二次到的时候就处理；对于只会到达一次的结点就直接处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; storage = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; visit = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!visit.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">               visit.push(cur);</span><br><span class="line">               cur=cur.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               cur=visit.pop();</span><br><span class="line">               storage.add(cur.val);</span><br><span class="line">               cur=cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> storage;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Morris-后序遍历"><a href="#Morris-后序遍历" class="headerlink" title="Morris 后序遍历"></a>Morris 后序遍历</h3><ul><li>思路：把处理的时机放在能回到自己两次的结点，并且是第二次回到自己的时候，但是不打印自己，而是逆序打印自己左子树的右边界。最后，Morris遍历完后，逆序打印整棵树的右边界。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; stoge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; visit = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root,mostRight =<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> stoge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            mostRight=cur.left;</span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur)&#123;</span><br><span class="line">                    mostRight=mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right=cur;</span><br><span class="line">                    cur=cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mostRight.right=<span class="literal">null</span>;</span><br><span class="line">                    addPath(stoge,cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(stoge,root);</span><br><span class="line">        <span class="keyword">return</span> stoge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPath</span><span class="params">(List&lt;Integer&gt;stoge,TreeNode node)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            stoge.add(node.val);</span><br><span class="line">            node=node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stoge.size()-count,right = stoge.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stoge.get(left);</span><br><span class="line">            stoge.set(left,stoge.get(right));</span><br><span class="line">            stoge.set(right,temp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul><li><p>问题1：逆序打印一棵树的右边界，是不是一定得用到栈呢？？？</p><ul><li>答：其实还有一种方法，那就是链表反转。</li></ul></li><li><p>问题2：Morris遍历它的每到一个结点，都会遍历该结点左子树的右边界两次，那么它的时间复杂度还会使O(n)吗？</p><ul><li>答：所有的左子树的右边界都是不重复的，也就是说，所有结过它左子树的有边界的时间复杂度也就是整棵树的规模而已。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Morris-遍历&quot;&gt;&lt;a href=&quot;#Morris-遍历&quot; class=&quot;headerlink&quot; title=&quot;Morris 遍历&quot;&gt;&lt;/a&gt;Morris 遍历&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="算法" scheme="https://kalyan-zitiu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法知识" scheme="https://kalyan-zitiu.github.io/tags/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记-网络层</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/13/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E6%B5%85%EF%BC%89/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/13/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E6%B5%85%EF%BC%89/</id>
    <published>2022-10-13T14:30:04.000Z</published>
    <updated>2022-11-15T03:52:32.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><h2 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h2><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101048607.png" alt="image-20221009151537340" style="zoom:50%;" /></li><li>IP数据报主要格式 <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047278.png" alt="image-20221009151618409"></li><li>首先发送的是首部，首部分为固定部分以及可变部分<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047494.png" alt="image-20221009151748549"  /></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047029.png" alt="image-20221009151849391"><ul><li> 版本字段：IPv4/IPv6？</li><li> 首部长度： 单位是4B，最小为5，实际会被填充成四的倍数</li><li> 区分服务：期望获得哪种类型服务</li><li> 总长度： 首部+数据，单位是1B</li><li> 生存时间（TTL）：IP分组的保质期，经过一个路由器-1，变为0则丢弃，防止无法交付的数据报无限地兜圈子。防止消耗网络资源。</li><li>协议：数据部分的协议<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047422.png" alt="image-20221009152639531"><ul><li>TCP:面向连接的服务  </li><li>UDP：不是面向连接，不建立连接是有可能产生丢包现象的</li></ul></li><li>首部检验和：只检验首部（检验首部数据是否变化或者出错） </li><li> 源地址以及IP地址：32位</li><li> 可选字段：支持排错，测量以及安全等措施</li><li> 填充：，全0，把首部补全成4B的整数倍<h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><h3 id="MTU最大传送单元"><a href="#MTU最大传送单元" class="headerlink" title="MTU最大传送单元"></a>MTU最大传送单元</h3></li></ul></li><li>链路层数据帧可封装数据的上限<ul><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047011.png" alt="image-20221009155352562"></li></ul></li><li>以太网的MTU是1500字节</li><li>过长就会分片，不分则不传递，返回ICMP的差错报文</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101047353.png" alt="image-20221009161328524"><ul><li> 标识：同一数据报的分片使用同一标识</li><li>标志：只有两位有意义<ul><li>中间位DF，DF=1（禁止分片），DF=0（允许分片）</li><li>最低位MF，MF=1（后面还有分片），MF=0（代表最后一片/没分片）（只有经过DF=0的前提下才能进行）</li></ul></li><li>片位移：指出较长分组分片后，某片在原分组中的相对位置。以8B为单位。<ul><li>离开头0字节的距离/8;  <h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2></li></ul></li></ul></li><li>全世界唯一的32位/4字节标识符</li><li>组成{&lt;网络号&gt;,&lt;主机号&gt;}</li><li>采用点分十进制 </li><li>网桥：不能分割广播域，仍然是一个局域网以及一个网络号 <h3 id="分类的地址"><a href="#分类的地址" class="headerlink" title="分类的地址"></a>分类的地址</h3><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101046452.png" alt="image-20221009163738683"><h3 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h3></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101046300.png" alt="image-20221009165513754"><h3 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h3><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045404.png" alt="image-20221009170129863"><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3></li><li>在传用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全国IP地址<h3 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a>子网划分与子网掩码</h3></li><li>分类的IP地址的弱点：</li></ul><p>1.IP地址空间的利用率有时很低<br>2.两级IP地址不够灵活</p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ul><li>三级IP地址组成<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045548.png" alt="image-20221010121507901"></li><li>某单位划分子网后，对外仍然表现为一个网络，即本单位外的网络看不见本单位内的子网的划分<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4></li><li>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045323.png" alt="image-20221010123420588">橙色的代表网络号，蓝色代表主机号</li><li>两级与三级的IP地址的子网掩码很简单，只要是网络号全是1，只要是主机号就是全0.</li><li>怎么识别发送数据报的目标IP地址：子网掩码与IP地址<strong>相与</strong>，得到的就是子网的网络地址</li></ul><h2 id="无分类编址CIDR（超网）"><a href="#无分类编址CIDR（超网）" class="headerlink" title="无分类编址CIDR（超网）"></a>无分类编址CIDR（超网）</h2><ul><li>无分类域间路由选择CIDR：<ul><li>1.消除了传统的A类，B类和C类地址以及划分子网的概念</li><li>2.CIDR记法：IP地址后加上/，然后写上网络前缀（可以任意长度）的位数</li><li>3.融合子网地址与子网掩码，方便了子网划分</li></ul></li><li>CIDR地址块<ul><li>只要网络前缀都相同的连续IP地址就同属于一个地址块 </li></ul></li><li>构成超网：将多个子网聚合成一个较大的子网或叫路由聚合<ul><li>方法：将网络前缀缩短。</li></ul></li><li>最长前缀匹配<ul><li>使用CIDR时候，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由</li><li>前缀越长，地址块越小，路由越具体</li></ul></li></ul><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><ul><li>发送数据的过程<ul><li>ARP高速缓存（IP地址与MAC地址的映射）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101045967.png" alt="image-20221011144044073"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101044761.png" alt="image-20221011144024726"></li><li>除此之外还得价格目的地址的MAC地址</li><li>首先广播一个ARP请求（先封装成数据帧）<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101044249.png" alt="image-20221011144140528"><ul><li>当交换机收到广播端口，会把它从所有端口发出。</li><li>其实说白了就是MAC1地址在寻找MAC3地址的一个过程</li></ul></li><li>当目的MAC地址收到请求消息则会返回一个单播ARP响应分组<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042483.png" alt="image-20221011144437812"><ul><li>其实就是和源地址说明我在哪个位置。<br>注意：以上都是一个子网内的方法</li></ul></li></ul></li><li>如果IP1想发送分组到IP5，</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101044074.png" alt="image-20221011145058836"><ul><li>1.还是先储存源地址和目的地址的信息以及MAC1地址</li><li><ol start="2"><li>因为是一个跳网段的传输，因此首先会查询自己默认网关的目的地址。</li></ol></li><li>3.所以下一跳，一定先跳到默认网关上，也就是寻找MAC6而不是MAC5</li><li>4.所以响应分组先是由默认网关返回</li><li>然后会被封装成<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042554.png" alt="image-20221011150015189"></li><li>如上图就是说源地址与目的地址并没有变化，但物理地址缺发生了变化。</li><li>到达MAC8后再封装成<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042780.png" alt="image-20221011150307293"></li><li>继续发送ARP请求分组寻找MAC5<br>最终的总局：</li></ul></li><li>IP1 &gt; IP5(始终不变)</li><li>Mac1 &gt; Mac 6           Mac7&gt;Mac8     Mac9&gt;Mac5</li></ul><p><strong>总结：</strong></p><ul><li>由于在实际网络的链路上传送数据帧时候，最终必须使用MAC地址</li><li>ARP协议：完成主机或路由器IP地址到MAC地址的映射。</li><li>ARP协议使用过程：<ul><li>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能 收到该请求。</li><li>目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存</li><li>ARP协议4种经典情况：<ul><li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址；</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址；</li><li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址</li><li>路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。</li></ul></li></ul></li></ul><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><ul><li><p>动态主机配置协议DHCP是<strong>应用层协议</strong>，使用的是<strong>客户/服务器方式</strong>，客户端和服务端通过<strong>广播</strong>方式进行交互，基于UDP。</p></li><li><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址，子网掩码，默认网关，DNS服务器名称与IP地址，且允许地址重用，支持移动用户加入网络，支持在用地址续租。</p></li><li><p>主要流程：</p><ul><li>主机进入后会寻找DHCP服务器，广播一个DHCP发现报文</li><li>DHCP服务器广播DHCP提供报文</li><li>主机广播DHCP请求报文</li><li>DHCP服务器广播DHCP确认报文</li></ul></li></ul><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><ul><li>ICMP差错报告报文（5种）<ul><li>1.终点不可达：当路由器或者主机不能交付数据报时候就向源点发送终点不可达报文。</li><li>2.时间超过：但路由器收到生存事件TTL=0的数据报时候，除了丢弃该数据报以外，还要向源点发送事件超过报文。当终点再预先规定的时间内不能收到一个数据报全部的数据报片时，就把已经收到的数据报片都丢弃掉，并向源点发送时间超过报文。</li><li>3.参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确，就丢弃该数据报，并向源点发送参数问题报文。</li><li>4.改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发给另外的路由器（可通过更好的路由）。</li><li>5.源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率缓慢（注意：很多都已经停止使用了）</li></ul></li><li>ICMP差错报告报文数据字段<ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101042268.png" alt="image-20221011160932524"></li></ul></li><li>不应该发送ICMP差错报文<ul><li>ICMP差错报告报文不再发送ICMP差错报告报文。（因为ICMP差错报告报文也是一个IP数据报）</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错数据报文</li></ul></li><li>ICMP询问报文 、<ul><li>1.回送请求和回答报文：主机或路由器向特定目的主机发送的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。（测试目的站是否可达以及了解其相关状态）</li><li>2.时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。（用来进行时钟同步和测量时间） </li></ul></li><li>ICMP应用<ul><li>PING：测试 两个主机之间的连通性，使用了ICMP回送请求和回答报文</li><li>Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul><li>IPv6数据报格式</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041253.png" alt="image-20221011200337302"></li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041407.png" alt="image-20221011213629483"><ul><li>优先级： 区分数据报的类别和处理优先级</li><li>流标签：“流”是互联网上从特定源点到特定终点的一系列数据报，所有属于同一个流的数据报都具有同样的流标签</li><li>有效载荷长度：（扩展首部+数据）的大小</li><li>下一个首部：标识下一个扩展首部或上层协议首部</li><li>跳数限制：类似于生存时间TT，不过依然是返回一个ICMP差错报文</li></ul></li></ul><h2 id="IPv4与IPv6区别"><a href="#IPv4与IPv6区别" class="headerlink" title="IPv4与IPv6区别"></a>IPv4与IPv6区别</h2><ul><li><p>IPv6将地址从32位扩大到128位，扩展了更大的地址空间</p></li><li><p>IPv6将IPv4的校验和字段彻底删除，以减少每跳的处理时间</p></li><li><p>加快了路由器的处理效率</p></li><li><p>IPv6支持了即插即用的自动配置，不需要了DHCP协议</p></li><li><p>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍</p></li><li><p>IPv6只能在主机处分片，IPv4可以在路由器以及主机上分片</p></li><li><p>但IPv6的分组过大就会返回一个附加报文：ICMPv6</p></li><li><p>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用</p></li><li><p>IPv6取消了协议字段，改成了下一个首部字段</p></li><li><p>IPv6取消了总长度字段，改用有效载荷长度字段</p></li><li><p>IPv6取消了服务类型字段</p></li><li><p>IPv6地址表示形式</p><ul><li>冒号十六进制记法<br> +<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041906.png" alt="image-20221011220335686"></li></ul></li><li><p>IPv6基本地址类型</p><ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul></li><li><p>IPv6向IPv4的过渡</p><ul><li>双栈协议：<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041422.png" alt="image-20221011221301471"></li><li>隧道技术： <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041985.png" alt="image-20221011221311689"></li></ul></li></ul><h2 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a>RIP协议及距离向量算法</h2><ul><li><p>路由选择协议</p><ul><li>1.内部网关协议IGP：一个AS内使用的RIP，OSPF</li><li>2.外部网关协议EGP：AS之间使用的是BGP </li><li>RIP使用的是距离向量：面对较小的网络</li><li>OSPF使用的是链路状态：面对较大的网络</li></ul></li><li><p>RIP协议</p><ul><li>是一种分布式的基于距离向量的路由选择协议。 </li><li>要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录</li></ul></li><li><p>距离（俗称跳数）</p><ul><li>从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1.</li><li>RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达</li></ul></li><li><p>RIP协议交换 </p><ul><li>仅能和相邻的路由器交换消息</li><li>路由器交换的信息是自己的路由表</li><li>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。</li><li>如果超过了180s后，没有收到邻居路由器的通告，则判定为邻居已经死了，并且更新自己的路由表</li></ul></li><li><p>收敛</p><ul><li>经过多次更新后，所有的路由器最终都会知道到达本自治体系任何一个网络的最短距离和下一跳路由器的地址</li></ul></li><li><p>距离向量算法</p><ul><li>1.对地址为X的相邻路由器发来的RIP报文。修改此报文中的所有项目：把下一跳字段中的地址改为X，并把所有的“距离”字段+1.</li><li>对修改后的RIP报文中的每一个项目，进行一下步骤：</li><li>R1路由表中没有Net3，则把该项目填入R1路由表中</li><li>R1路由表中若没有Net3，则查看下一跳的路由器地址：若下一跳是X。则用收到的项目替换路由表中的项目；若没有，原来距离比从X走的距离远则更新，否则不处理</li><li>若180s还没有收到路由器的X的更新路由表，则把X记为不可达路由器，即把距离设置为16.</li></ul></li><li><p>RIP协议的报文格式</p><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041843.png" alt="image-20221012165443308"></li></ul></li></ul><h2 id="OSPF协议以及链路状态算法"><a href="#OSPF协议以及链路状态算法" class="headerlink" title="OSPF协议以及链路状态算法"></a>OSPF协议以及链路状态算法</h2><ul><li><p>OSPF协议</p><ul><li>路由器会使用类似于广播的叫做洪泛法向自治系统内所有路由器发送信息。</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态。</li><li>只有当链路状态发生变化时候，路由器才向所有路由器洪泛发送信息。</li></ul></li><li><p>链路状态路由算法</p><ul><li>1.路由器会向邻居发送<strong>Hello问候分组</strong>，并且了解邻居节点的网络地址</li><li>2.设置它邻居的成本度量metric</li><li>3.构造一个<strong>DD数据库描述分组</strong>，向邻居给出自己的链路状态数据库中的所有链路信息</li><li>4.如果数据库里面的摘要，自己都有的话，则不会做出任何处理。如果没有的话则会请求更新发送<strong>LSR链路状态请求分组</strong>请求得到自己没有的信息</li><li>如果一个路由器收到了LSR分组以后，他会发送<strong>LSU链路状态更新分组</strong>进行更新</li><li>更新后，邻居会和你说<strong>LSAsk链路状态确认分组</strong>进行确认</li></ul></li><li><p>只要有一个路由器变化：</p><ul><li>洪泛发送<strong>LSU链路状态更新分组</strong>进行更新</li><li>更新后,其他站返回一个<strong>LSAsk链路状态确认分组</strong>进行确认</li><li>使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径</li></ul></li><li><p>OSPF分组的格式</p></li><li><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041419.png" alt="image-20221012173536847"></p><ul><li>OSPF直接使用的是IP数据报的格式传送。 </li></ul></li><li><p>特点</p><ul><li>每隔30min，刷新一次数据库的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离响亮协议RIP要好的。</li><li>OSPF协议不存在坏消息传的慢，他的收敛速度很快。</li></ul></li></ul><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><ul><li><p>BGP可以是一个AS边缘路由器</p></li><li><p>它会与其他AS的邻站BGP发言人交换信息</p></li><li><p>交换是网络可达性信息，即到达某个网络所要经过的一系列AS</p></li><li><p>发生变化时候更新有变化的部分</p></li><li><p>BGP协议报文格式</p><ul><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101041196.png" alt="image-20221012213451408"></li><li> 一个BGP发言人与其他自治系统中的BGP发言人要求交换路由信息，就要建立TCP连接，即通过TCP传送，然后在此链接上交换BGP报文以建立BGP会话，利用BGP会话交换路由信息</li><li> BGP是应用层协议，借助TCP传送</li></ul></li><li><p>特点</p><ul><li>BGP支持CIDR </li><li>节省网络资源</li></ul></li><li><p>BGP-4四种报文</p><ul><li>OPEN报文：用来与相邻的另一个BGP发言人建立关系，并认证发送者</li><li>UPDATE报文：通告新路径或撤销源路径</li><li>KEEPALIVE报文：在无UPDATE时，周期性证实邻站的连通性；作为OPEN的确认</li><li>NOTIFICATION报文：报告先前报文的差错：也被用于关闭连接</li></ul></li></ul><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><ul><li>IP数据报的三种传输方式<ul><li>单播：用于发送数据包到单个目的地，且每发一份单播报文都用一个单播IP地址作为目的地址，是点对点传输方式</li><li>广播：发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式</li><li>组播：仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点的传输方式</li></ul></li><li>特点<ul><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</li><li>对组播数据报不产生ICMP差错报文。</li><li>并非所有D类地址都可以作为组播地址 </li></ul></li></ul><h2 id="IGMP网际组管理协议"><a href="#IGMP网际组管理协议" class="headerlink" title="IGMP网际组管理协议"></a>IGMP网际组管理协议</h2><ul><li>IGMP协议让路由器知道本局域网上是否有主机（的进程）参加或退出某个组播组。</li><li>1.某主机想要加入组播组时，该主机会向组播组发送一个IGMP报文，声明自己要成为改组成员本地收到IGMP报文后，利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器</li><li>2.本地组播组路由器周期查询本地局域网上的主机，清楚这些主机是否还是该组播组成员，只要有一个主机对某个分组响应，则该组播组会认定该主机是活跃的，如果没有组播路由器则认定网络上没有这个组播组的主机。因此不会再把这组的成员关系发给其他组播路由器。</li></ul><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><ul><li>相关术语<ul><li>移动结点：具有永久的IP地址的移动设备</li><li>移动IP技术：以固定的网络IP地址，实现跨越不同网段的漫游功能，并且保证了基于网络IP的网络权限在漫游过程中不发生任何改变</li><li>归属代理（本地代理）：一个移动结点拥有的“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理</li><li>外部代理（外地代理）：在外部网络中帮助移动节点完成移动管理功能得实体称为外部代理</li><li>永久地址：移动站点在归属网络中得原始地址</li><li>转交地址：移动结点在外部网络使用的临时地址</li></ul></li><li>移动IP通信过程<ul><li>A刚进入外地网络<ul><li>1.在外部代理登记获得一个转交地址，离开时候注销</li><li>2.外部代理向本地代理登记转交地址。</li></ul></li><li>B给A发送数据报<ul><li>1.本地代理截获数据报</li><li>2.本地代理再封装数据报，新的数据报目的地址是转交地址，发送给外部代理（隧道）</li><li>3.外部代理拆封数据报并发给A</li></ul></li><li>A给B发送数据报<ul><li>A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址 </li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IP数据报格式&quot;&gt;&lt;a href=&quot;#IP数据报格式&quot; class=&quot;headerlink&quot; title=&quot;IP数据报格式&quot;&gt;&lt;/a&gt;IP数据报格式&lt;/h2&gt;&lt;h2 id=&quot;TCP-IP协议栈&quot;&gt;&lt;a href=&quot;#TCP-IP协议栈&quot; class=&quot;header</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Grammarly</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/10/Grammarly/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/10/Grammarly/</id>
    <published>2022-10-10T02:30:04.000Z</published>
    <updated>2022-11-10T02:53:23.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分享一个比较好用的英语文章润色工具"><a href="#分享一个比较好用的英语文章润色工具" class="headerlink" title="分享一个比较好用的英语文章润色工具"></a>分享一个比较好用的英语文章润色工具</h1><h2 id="Grammarly"><a href="#Grammarly" class="headerlink" title="Grammarly"></a>Grammarly</h2><h3 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h3><ul><li><p>打开网址<br><a href="https://www.grammarly.com/">https://www.grammarly.com/</a></p><ul><li>Grammarly有三种形式</li><li>1.可以放在手机上</li><li>2.可以下载在视窗上，无论你在哪个窗口都可以识别你的英语字段</li><li>3.网页版，把文档上传自动润色提醒<h3 id="高级版本"><a href="#高级版本" class="headerlink" title="高级版本"></a>高级版本</h3></li></ul></li><li><p>高级版可支持句子润色替换</p></li><li><p>打开网址<a href="https://www.linkstricks.com/cookies/grammarly-cookies/">https://www.linkstricks.com/cookies/grammarly-cookies/</a></p><ul><li><p>1.下载Cookie-Editor<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053924.png" alt="image-20221010100120460"></p></li><li><p>一般在Chrome应用商店能搜的到</p></li><li><p>2.下载工作语法Cookie如果一个不行换第二个</p></li></ul><p> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053069.png" alt="image-20221010100312864"></p><ul><li>3.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053196.png" alt="image-20221010100432487">右上角复制代码</li><li>4.<img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/202211101053371.png" alt="img">在网页右上角点cookie，点垃圾桶删除(是要进入Grammarly网页进行操作)</li><li>点击import，把刚刚复制的代码黏贴下去</li><li>6.刷新 </li></ul></li></ul>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="分享" scheme="https://kalyan-zitiu.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="tools" scheme="https://kalyan-zitiu.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Articles in English#2</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/09/Englishwork%20(2)/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/09/Englishwork%20(2)/</id>
    <published>2022-10-09T04:30:04.000Z</published>
    <updated>2022-10-09T04:30:10.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Do-we-Need-Never-give-up？"><a href="#Do-we-Need-Never-give-up？" class="headerlink" title="Do we Need Never give up？"></a>Do we Need Never give up？</h1><p>Quite a few people think that Never giving up is the attitude of life, But is this really the case? I encounter many citizens who use them as an excuse, though they stay on this path and make a great contribution. But practically, they cannot profit    anything. Not only wasting their time ,but also paying out their energy.</p><p>In our dailylife, we can find something which we want to pay more attention to it.But we need to contrast habits and work. This thing you love may only be what you need for a while. When enthusiasm subsides,you will find it not your love things. So,The reality is harsh, you must ensure you have some gifts in what you want to do.</p><p>Life is hard to avoid, you must try doing something again and again. Utill you seek you can stand on it firmly. It means that you need to relinquish something and pick something back. Fail is not lose face, when you hit a wall that you really cannot get over,you have to stop and look elsewhere.</p>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="杂谈" scheme="https://kalyan-zitiu.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="English" scheme="https://kalyan-zitiu.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>Linux实用命令</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/08/%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/08/%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2022-10-08T14:20:04.000Z</published>
    <updated>2023-03-27T03:17:53.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h2 id="5-1运行级别"><a href="#5-1运行级别" class="headerlink" title="==5.1运行级别=="></a>==<strong>5.1运行级别</strong>==</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a><strong>基本</strong></h3><table><thead><tr><th align="left">0</th><th>关机</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td>单用户（找回丢失密码）</td><td></td></tr><tr><td align="left">2</td><td>多用户状态没有网络服务</td><td></td></tr><tr><td align="left">3</td><td>系统未使用保留给用户</td><td>multi-user.target</td></tr><tr><td align="left">4</td><td>图形界面</td><td></td></tr><tr><td align="left">5</td><td>系统重启</td><td>graphical.target</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>常用系统级别是3和5，也可以切换运行级别和指定默认运行级别</strong>。</p><h3 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a><strong>切换运行级别</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>init 运行级别<strong>（init 3）</strong></td><td>将运行级别切换为3（多用户状态有网络服务）</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>init 只能用来切换运行级别。下次开机后系统自动回到运行级别5。</strong></p><h3 id="设置默认运行级别"><a href="#设置默认运行级别" class="headerlink" title="设置默认运行级别"></a><strong>设置默认运行级别</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>systemctl get-default</td><td>查看当前默认运行级别</td></tr><tr><td>systemctl set-default multi-user.target</td><td>设置默认运行级别为3</td></tr><tr><td>systemctl set -default graphical.target</td><td>设置默认运行级别为5</td></tr></tbody></table><p><strong>==Note==</strong><br>-<strong>此方式永久性的修改了默认运行级别。每次开机后系统都会运行该默认运行级别。</strong></p><h3 id="开机流程说明"><a href="#开机流程说明" class="headerlink" title="开机流程说明"></a><strong>开机流程说明</strong></h3><p><img src="https://img-blog.csdnimg.cn/326400f8c502421a9482254a802e0787.png" alt="img"></p><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="==帮助指令=="></a>==<strong>帮助指令</strong>==</h2><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>man 命令或配置文件</td><td>获得命令或配置文件的帮助信息</td></tr><tr><td>help 命令</td><td>获得shell内置命令的帮助信息</td></tr></tbody></table><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="==文件目录类=="></a>==<strong>文件目录类</strong>==</h2><h3 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a><strong>pwd指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>pwd</td><td>显示当前工作目录的绝对途径</td></tr></tbody></table><h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a><strong>ls指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ls 目录或文件</td><td>显示当前目录下所有的文件和目录（不包括隐藏的）</td></tr><tr><td>ls -a 目录或文件</td><td>显示当前目录下所有的文件和目录（包括隐藏的）</td></tr><tr><td>ls -l 目录或文件 或 ll 目录或文件</td><td>以列表的方式显示信息</td></tr><tr><td>ls -lh 目录或文件</td><td>以列表的方式人性化地显示信息</td></tr></tbody></table><h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a><strong>cd指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的家目录</td></tr><tr><td>cd ~</td><td>切换到当前用户的家目录</td></tr><tr><td>cd .</td><td>保持当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a><strong>mkdir指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>mkdir 要创建的单级目录</td><td>创建单级目录</td></tr><tr><td>mkdir -p 要创建的多级目录</td><td>创建多级目录</td></tr></tbody></table><h3 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a><strong>rmdir指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>rmdir 要删除的空目录</td><td>删除空目录</td></tr><tr><td>rm -rf 要删除的非空目录</td><td>删除非空目录</td></tr></tbody></table><h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a><strong>touch指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>touch 文件名称</td><td>创建一个空文件</td></tr></tbody></table><h3 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a><strong>cp指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th><th>Remake</th></tr></thead><tbody><tr><td>cp source dest</td><td>将source拷贝到dest</td><td></td></tr><tr><td>cp -r source dest</td><td>将source递归拷贝到dest</td><td></td></tr><tr><td>\cp source dest</td><td>将source拷贝到dest(强制覆盖不提示)</td><td></td></tr></tbody></table><h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a><strong>rm指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>rm 要删除的文件或目录</td><td>移除文件或目录</td></tr><tr><td>rm -r 要删除的目录</td><td>递归删除目录</td></tr><tr><td>rm -f 要删除的文件或目录</td><td>强制删除目录不提示</td></tr></tbody></table><h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a><strong>mv指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>mv oldFileName newFileName</td><td>重命名（两者在同一目录下面）</td></tr><tr><td>mv /temp/movefile /targetFolder</td><td>移动文件</td></tr></tbody></table><h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a><strong>cat指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>cat 要查看的文件</td><td>查看文件的内容</td></tr><tr><td>cat -n 要查看的文件</td><td>查看文件的内容并显示行号</td></tr><tr><td>cat -n 要查看的文件  more</td><td>将cat查看的内容交给more指令来处理（为了浏览方便）</td></tr></tbody></table><h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a><strong>more指令</strong></h3><p><img src="https://img-blog.csdnimg.cn/fb32e188764542ebb25549929c4a24ff.png" alt="img"><br>|Order|illustrate|<br>|—–|—–|<br>|more 要查看的文件|查看文件的内容（浏览更方便）|</p><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a><strong>less指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>less 要查看的文件</td><td>查看文件的内容</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>less 指令用来分屏查看文件内容，它的功能与more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</strong></p><p><img src="https://img-blog.csdnimg.cn/5a3f4976cdc74d8e966916588413378c.png" alt="img"></p><h3 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a><strong>echo指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>echo $PATH</td><td>输出当前PATH环境变量</td></tr><tr><td>echo $HOSTNAME</td><td>输出当前HOSTNAME环境变量（主机名）</td></tr><tr><td>echo ‘hello world’</td><td>输出hello world</td></tr></tbody></table><h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a><strong>head指令</strong></h3><p>==head指令用于查看文件开头的部分内容（默认情况下显示前10行）。==<br>|Order|illustrate|<br>|—–|—–|<br>|head 文件|查看文件开头的前10行内容|<br>|head -n 5 文件|查看文件开头的前5行内容|</p><h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a><strong>tail指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>tail 文件</td><td>查看文件尾部的后10行内容</td></tr><tr><td>tail -n 5 文件</td><td>查看文件尾部的后5行内容</td></tr><tr><td>tail -f 文件</td><td>实时追踪该文档的所有更新</td></tr></tbody></table><h3 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a><strong>&gt;指令和&gt;&gt;指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ls -l &gt; 文件</td><td>列表的内容写入（覆盖）到文件</td></tr><tr><td>ls -l &gt;&gt; 文件</td><td>列表的内容追加到文件</td></tr><tr><td>cat 文件1 &gt; 文件2</td><td>文件1的内容覆盖到文件2</td></tr><tr><td>echo ‘hello’  &gt;&gt; 文件</td><td>hello追加到文件中</td></tr></tbody></table><h3 id="In指令"><a href="#In指令" class="headerlink" title="In指令"></a><strong>In指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>ln -s 原文件或目录 软链接名</td><td>给原文件创建一个软链接(这样软链接就指向了原文件或目录)</td></tr></tbody></table><p><strong>==Note==</strong><br><strong>当工作目录为软链接所在目录，使用pwd查看的目录仍然是软链接所在目录而不是原目录。</strong></p><h3 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a><strong>history指令</strong></h3><p>==history指令用于查看已经执行过的历史命令。==</p><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>histrory</td><td>查看已经执行过的历史命令</td></tr><tr><td>histrory n</td><td>查看最近执行过的n条历史命令</td></tr><tr><td>!n</td><td>执行历史编号为n的历史命令</td></tr></tbody></table><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h3><p>date指令用于显示当前日期<br>|Order|illustrate|<br>|—–|—–|<br>|date|显示当前时间|<br>|date +%Y|显示当前年份|<br>|date +%m|显示当前月份|<br>|date +%d|显示当前是哪一天|<br>|date “+%Y-%m-%d %H:%M:%S”|显示年月日时分秒|</p><h3 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>date -s 字符串时间</td><td>设置系统当前时间</td></tr></tbody></table><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><p>cal指令用于显示日历<br>|Order|illustrate|<br>|—–|—–|<br>|cal|显示本月日历|<br>|cal 年份|显示本年所有月日历|</p><h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="==搜索查找类=="></a>==<strong>搜索查找类</strong>==</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a><strong>find指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>find 指定目录 -name 要查找的文件或目录</td><td>按照指定目录查询文件或目录</td></tr><tr><td>find 指定目录 -user 用户名</td><td>按照指定目录查找指定用户名的所有文件或目录</td></tr><tr><td>find 指定目录 -size 文件大小</td><td>按照指定目录查找满足文件大小的所有文件或目录</td></tr><tr><td><strong>==Note==</strong></td><td></td></tr><tr><td><strong>1.文件大小：大于+，小于-，等于=</strong></td><td></td></tr><tr><td><strong>2.find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</strong></td><td></td></tr><tr><td><strong>find指令也可以不指定目录进行查找。</strong></td><td></td></tr></tbody></table><h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a><strong>locate指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>locate 要查找的文件或目录</td><td>快速查找文件或目录</td></tr><tr><td><strong>==Note==</strong></td><td></td></tr><tr><td><strong>1.locate指令无需遍历整个文件系统，locate 指令利用事先建立的系统中所有文件名称及路径的         locate数据库实现快速定位给定的文件路径。</strong></td><td></td></tr></tbody></table><p><strong>2.为了保证查询结果的准确度，管理员必须定期更新locate时刻。</strong></p><p><strong>3.由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locatc数据库。</strong></p><h3 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a><strong>which指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>which 要查找的命令</td><td>查找指令的存放路径</td></tr></tbody></table><p><strong>==Note==</strong><br>which指令用于查找指令的存放路径。</p><h3 id="管道符“-”和grep指令"><a href="#管道符“-”和grep指令" class="headerlink" title="管道符“|”和grep指令"></a><strong>管道符“|”和grep指令</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>grep 查找内容 源文件</td><td>将源文件中的查找内容输出</td></tr><tr><td>grep -n 查找内容 源文件</td><td>将源文件中的查找内容输出，并显示行号</td></tr><tr><td>grep -i 查找内容 源文件</td><td>将源文件中的查找内容输出（不区分大小写）</td></tr></tbody></table><p><strong>==Note==</strong><br>1.管道符“|”表示将前一个命令的处理结果输出传递给后面的命令处理。<br>    grep指令用于过滤查找，可配合管道符“|”使用。</p><p>==<strong>Case study</strong><br><strong>请在 hello.txt文件中，查找”yes”所在行，并且显示行号。<br>法一：cat hello.txt | grep -n “yes”<br>法二：grep -n “yes” hello.txt</strong></p><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><h3 id="gzip-gunzio指令"><a href="#gzip-gunzio指令" class="headerlink" title="gzip/gunzio指令"></a>gzip/gunzio指令</h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>gzip 文件</td><td>压缩文件（只能将文件压缩为*.gz文件）</td></tr><tr><td>gunzip 文件.gz</td><td>解压缩文件</td></tr></tbody></table><h3 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="==zip/unzip指令=="></a>==<strong>zip/unzip指令</strong>==</h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>zip XXX.zip 要压缩的文件</td><td>压缩文件</td></tr><tr><td>zip -r XXX.zip 要压缩的目录</td><td>压缩目录（递归压缩）</td></tr><tr><td>unzip XXX.zip</td><td>将压缩包解压到当前目录下</td></tr><tr><td>unzip -d 目标目录 XXX.zip</td><td>将压缩包解压到指定目录下</td></tr></tbody></table><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="==tar指令=="></a>==<strong>tar指令</strong>==</h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>tar-z</td><td>压缩/解压缩</td></tr><tr><td>tar-c</td><td>产生tar打包文件</td></tr><tr><td>tar-v</td><td>显示详细信息</td></tr><tr><td>tar-f</td><td>指定压缩后的文件名</td></tr><tr><td>tar-x</td><td>解包.tar文件</td></tr><tr><td>tar-C</td><td>解压缩到指定目录（解压缩的目录必须存在）</td></tr><tr><td>tar -zcvf 打包文件.tar.gz 被打包的文件</td><td>打包压缩文件</td></tr><tr><td>tar -zxvf 打包文件.tar.gz</td><td>解包解压缩文件至当前目录下</td></tr><tr><td>tar -zxvf 打包文件.tar.gz -C 目标目录</td><td>解包解压缩文件至当前指定目录下</td></tr></tbody></table><h2 id="Linux组基本介绍"><a href="#Linux组基本介绍" class="headerlink" title="Linux组基本介绍"></a><strong>Linux组基本介绍</strong></h2><h3 id="Linux组基本介绍-1"><a href="#Linux组基本介绍-1" class="headerlink" title="Linux组基本介绍**"></a>Linux组基本介绍**</h3><p>在linux中的每个用户必须属于一个组，且可以改变每个用户所在的组。<br>在linux中的每个文件拥有以下概念：<br>1.所有者2.所在组3.其它组</p><h3 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件/目录所有者"></a><strong>文件/目录所有者</strong></h3><p><em><strong>一般为文件/目录的创建者，即谁创建文件/目录，谁就是该文件/目录的所有者。</strong></em></p><h3 id="查看文件-目录的所有者"><a href="#查看文件-目录的所有者" class="headerlink" title="查看文件/目录的所有者"></a><strong>查看文件/目录的所有者</strong></h3><p>ls -alh</p><p><img src="https://img-blog.csdnimg.cn/e36e9c31bcb248cda9ecc05d69c2440b.png" alt="img"></p><h3 id="修改文件-目录的所有者"><a href="#修改文件-目录的所有者" class="headerlink" title="修改文件/目录的所有者"></a><strong>修改文件/目录的所有者</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chown 所有者 文件/目录</td><td>修改文件/目录的所有者</td></tr><tr><td>chown -R 所有者 目录</td><td>递归修改目录及目录内容的所有者</td></tr><tr><td>chown 所有者:所在组 文件/目录</td><td>修改文件/目录的所有者和所在组</td></tr></tbody></table><h3 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a><strong>文件/目录所在组</strong></h3><p><strong>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组(默认)。</strong></p><h3 id="查看文件-目录的所在组"><a href="#查看文件-目录的所在组" class="headerlink" title="查看文件/目录的所在组"></a><strong>查看文件/目录的所在组</strong></h3><p>ls -alh</p><p><img src="https://img-blog.csdnimg.cn/966d4fe8a879494297ee9578ce9a97be.png" alt="img"></p><h3 id="修改文件-目录的所在组"><a href="#修改文件-目录的所在组" class="headerlink" title="修改文件/目录的所在组"></a><strong>修改文件/目录的所在组</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chgrp 所在组 文件/目录</td><td>修改文件/目录的所在组</td></tr><tr><td>chgrp -R 所在组 目录</td><td>递归修改目录及目录内容的所在组</td></tr></tbody></table><h3 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a><strong>其它组</strong></h3><p><strong>除文件的所有者和所在组的用户外，系统的其它用户都属于文件的其它组。</strong></p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h3><p><img src="https://img-blog.csdnimg.cn/1055e2e25bcd4f32a559061862242ae5.png" alt="img"></p><p><strong>0-9位说明</strong></p><p>1.第0位确定文件类型（-、l、d、c、b）<br>        -表示普通文件<br>        l是链接，相当于windows的快捷方式<br>        d是目录，相当于windows的文件夹<br>        c是字符设备文件，例如鼠标，键盘<br>        b是块设备，例如硬盘<br>2.第1-3位确定该文件所有者拥有的权限。<br>3.第4-6位确定与该文件所有者同一组的用户拥有的权限。<br>4.第7-9位确定不与该文件所有者同一组的其他用户拥有的权限。</p><h3 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a><strong>rwx作用到文件</strong></h3><pre><code> r表示可读（read）：可以查看文件中的内容 w表示可写（write）：可以修改文件中的内容，但是不一定可以删除该文件（因为删除一个      文件的前提是对该文件所在目录有写权限，才能删除该文件） x表示可执行（execute）：可以执行该文件</code></pre><h3 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a><strong>rwx作用到目录</strong></h3><p><strong>1.r表示可读（read）：可以查看目录中的内容（ls查看）</strong></p><p><strong>2.w表示可写（write）：可以创建、删除目录中的内容，重命名目录</strong></p><p><strong>3.x表示可执行（execute）：可以进入该目录（cd进入）</strong></p><h3 id="ls-l扩展"><a href="#ls-l扩展" class="headerlink" title="ls -l扩展"></a><strong>ls -l扩展</strong></h3><p><img src="https://img-blog.csdnimg.cn/1055e2e25bcd4f32a559061862242ae5.png" alt="img"></p><p>ls -l可显示目录下文件的详细信息,从左往右依次是：<br>     文件类型<br>     权限<br>     硬链接数（对于文件来说）或子目录数（对于目录来说，包括隐藏目录）<br>     用户<br>     组<br>     文件/文件夹大小（字节）<br>     最后修改日期<br>     文件名</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><strong>chmod</strong></h3><p><strong>chmod指令用于修改文件或者目录的权限。</strong></p><p><strong>+、-、=变更权限</strong><br>|Order|illustrate|<br>|—–|—–|<br>|chmod u=rwx,g=rx,o=x 文件/目录|给文件/目录的所有者读写执行的权限，所在组读执行的权限其它组执行的权限    |<br>|chmod o+x 文件/目录|给文件/目录的其它组增加执行的权限|<br>|chmod a-x 文件/目录|给文件/目录的所有人除去执行的权限|</p><table><thead><tr><th>Remake</th><th>—–</th></tr></thead><tbody><tr><td>u：</td><td>所有者</td></tr><tr><td>g：</td><td>所在组</td></tr><tr><td>o：</td><td>其它组</td></tr><tr><td>a：</td><td>所有人</td></tr><tr><td>=：</td><td>赋予</td></tr><tr><td>+：</td><td>增加</td></tr><tr><td>-：</td><td>除去</td></tr></tbody></table><h3 id="数字变更权限"><a href="#数字变更权限" class="headerlink" title="数字变更权限"></a><strong>数字变更权限</strong></h3><table><thead><tr><th>Order</th><th>illustrate</th></tr></thead><tbody><tr><td>chmod 751 文件/目录</td><td>给文件/目录的所有者读写执行的权限，所在组读执行的权限，其它组执行的权限</td></tr></tbody></table><h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><h3 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h3><p>1.任务调度：系统在某个时间执行的特定命令或者程序。<br>2.任务调度分类：<br>（1）.系统工作：有些重要的工作必须周而复始的执行<br>（2）.个别用户工作：个别用户可能希望执行某些程序</p><p><img src="https://img-blog.csdnimg.cn/b8afa5a9321540b9a81ab9062238d683.png" alt="img"></p>]]></content>
    
    
    <summary type="html">Linux</summary>
    
    
    
    <category term="knowledge" scheme="https://kalyan-zitiu.github.io/categories/knowledge/"/>
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络应用层</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/08/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/08/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-10-08T14:20:04.000Z</published>
    <updated>2023-03-16T05:32:12.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p><strong>应用层协议：每个应用层协议都是为了解决一类应用问题，而解决问题需要通过位于不同主机的多个应用进程之间的通信和协同来完成，应用层的具体内容就是定义这些通信规则</strong></p></li><li><p>**应用层的具体内容就是规定应用进程在通讯时候所遵循的协议</p><ul><li><strong>客户/服务器（C/S，Client/Server）方式</strong></li><li>**对等（P2P，Peer to Peer）方式</li></ul></li></ul><h3 id="应用进程"><a href="#应用进程" class="headerlink" title="应用进程"></a>应用进程</h3><p>   <strong>为解决具体应用问题而彼此通信的进程</strong></p><hr><h2 id="应用进程的通讯方式"><a href="#应用进程的通讯方式" class="headerlink" title="应用进程的通讯方式"></a>应用进程的通讯方式</h2><h3 id="①客户-服务器（C-S-Client-Server）方式"><a href="#①客户-服务器（C-S-Client-Server）方式" class="headerlink" title="①客户/服务器（C/S, Client/Server）方式"></a><strong>①客户/服务器（C/S, Client/Server）方式</strong></h3><ul><li><strong>应用层的许多协议是基于C/S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端</strong><ul><li><strong>客户(client)和服务器(server)是指通信中所涉及的2个应用进程</strong></li><li><strong>客户/服务器方式描述的是应用进程之间服务和被服务的关系</strong></li><li><strong>客户是服务请求方（主动请求服务，被服务</strong></li><li><strong>服务器是服务提供方（被动接受服务请求，提供服务）</strong></li></ul></li><li><strong>C/S方式可以是面向连接的，也可以是无连接的</strong></li><li><strong>面向连接时，C/S通信关系一旦建立，通信就是双向的，双方地位平等，都可发送和接收数据</strong></li></ul><h4 id="客户进程的特点"><a href="#客户进程的特点" class="headerlink" title="客户进程的特点"></a>客户进程的特点</h4><ul><li>在进行通信时临时成为客户，它也可以在本地进行其他的计算</li><li>用户计算机上运行，在打算通信时主动向远地服务器发起通信</li><li><strong>客户方必须知道服务器所在的主机的IP地址才能发出服务请求</strong></li><li>需要时可以与多个服务器进行通信</li></ul><h4 id="服务器进程的特点"><a href="#服务器进程的特点" class="headerlink" title="服务器进程的特点"></a>服务器进程的特点</h4><ul><li>专门用来提供某种服务的程序，可同时处理多个远地和本地客户的请求</li><li><strong>必须始终处于运行状态才有可能提供服务</strong></li><li>通信开始之前服务器进程不需要知道客户进程所在的IP地址，无论客户请求来自哪里，服务器进程被动等待服务请求的到来即可</li><li>通常是当系统启动时即自动调用并一直运行着。某些服务器程序也可以由用户或其他的进程在通信前启动</li><li>被动等待并接受来自多个客户的通信请求</li></ul><h3 id="②对等（P2P，Peer-to-Peer）方式"><a href="#②对等（P2P，Peer-to-Peer）方式" class="headerlink" title="②对等（P2P，Peer to Peer）方式"></a><strong>②对等（P2P，Peer to Peer）方式</strong></h3><ul><li>对等方式是指两个进程在通讯时并不区分服务的请求方和服务的提供方。<ul><li>只要两个主机都运行P2P软件，那么就可以进行平等，对等的通信。</li><li>如果权限允许的话，双方都可以下载彼此存储在硬盘中的共享文件。</li></ul></li><li>音频以及视频应用推动了P2P的对等通信方式的发展（BitTorrent）。</li><li>音频以及视频流量已经是占主要比。</li><li>P2P方式从本质上看仍然是使用了C/S方式，但强调的是通信过程中的对等，<strong>这时每一个P2P进程是客户的同时也是服务器</strong>。</li></ul><h2 id="服务器进程-工作方式"><a href="#服务器进程-工作方式" class="headerlink" title="服务器进程 工作方式"></a>服务器进程 工作方式</h2><ul><li>循环方式(iterative mode)<ul><li>一次只运行一个服务器</li><li>当有多个客户进程请求服务时,服务进程就会按照请求的先后顺序来依次做出响应**(阻塞方式)**</li><li>并发方式(concurrent mode)</li><li>可以同时运行多个服务器进程,</li><li>每个服务器进程都对某个特定的客户进程进行响应(非阻塞方式)</li></ul></li><li>无连接循环方式服务<ul><li>使用无连接的UDP服务进程通常都工作在循环方式,即一个服务器进程在同一时间只能向一个客户进程提供服务.(顺序服务)</li><li>服务器进程收到客户进程的请求后,会发送UDP用户数据报响应该客户</li><li>对其他客户进程发送的请求则暂时不予理睬,这些请求都在服务端的队列中排队等候服务进程的处理</li><li>当服务进程处理完一个请求时,会从队列中读取来自下一个客户进程的请求,然后继续处理 </li></ul></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702104216597.png" alt="图1.1"></p><ul><li><strong>面向链接的并发方式服务</strong><ul><li>面向连接的<strong>TCP服务进程</strong>通常都在工作在并发服务方式,服务进程可在同一时间同时向多个客户进程提供服务(<strong>并发服务</strong>)</li><li>在TCP服务进程与多个客户进程之间必须建立多条TCP连接,每条TCP连接在其数据传送完毕后释放</li><li>一个TCP连接对应一个(熟知)服务端口</li><li>主服务进程在熟知端口等待客户进程发送请求,一旦接受到客户进程的请求,就会创建一个从属服务进程,并指明从属服务进程使用临时的套接字与该客户建立TCP连接,然后主服务进程会继续在熟知端口等待其他客户进程的请求.</li></ul></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702104304442.png" alt="在这里插入图片描述"></p><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>域名系统：</strong>是互联网使用的命名系统，用来便于人们使用的机器名字转换为IP地址<br>许多应用层软件进程使用域名系统DNS，但是计算机的用户只是间接而不是直接使用DNS。<br>互联网采取层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS。DNS使大多数的名字放在本地分析，仅留下少量的解析需要互联网上通信。</p><h3 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a><strong>域名的解析过程</strong></h3><p>首先是把主机名字<strong>解析成为IP地址</strong>，然后应用进程会调用解析程序，并且<strong>成为DNS的一名客户</strong>，把待解析的域名放在DNS的请求报告中，<strong>以UDP用户数据报方式</strong>发给本地域名服务器，本地域名服务器在查找域名后，会<strong>把IP地址</strong>放在回答报文中<strong>返回</strong>，应用进程<strong>获得</strong>目的主机的<strong>IP地址</strong>后即<strong>可通信</strong>。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/2021070210481257.png" alt="在这里插入图片描述"></p><hr><h4 id="域名的递归查询"><a href="#域名的递归查询" class="headerlink" title="域名的递归查询"></a><strong>域名的递归查询</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702105147777.png" alt="在这里插入图片描述"></p><hr><h4 id="域名的迭代查询"><a href="#域名的迭代查询" class="headerlink" title="域名的迭代查询"></a><strong>域名的迭代查询</strong></h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702105303958.png" alt="在这里插入图片描述"></p><h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><ul><li>互联网是采取层次结构的命名方法</li><li>任何一个连接在互联网的主机或路由器都有一个唯一的层次结构名字，即域名。</li><li>域时名字空间中可以被管理的划分，域还可以被划分成子域，而子域还能继续划分</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702104833729.png" alt="在这里插入图片描述"></p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议"><a href="#简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议" class="headerlink" title="简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议"></a>简单邮件传输协议SMTP—-邮件服务器之间传递邮件使用的协议</h3><ul><li>最终交付(邮件访问)<br> +第三版邮局协议 POP3<ul><li>Internet邮件访问协议 IMAP</li><li>基于Web的电子邮件 Webmail（HTTP）</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702105700634.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="Webmail"><a href="#Webmail" class="headerlink" title="Webmail"></a>Webmail</h3><ul><li>提供电子邮件服务的IMAP和SMTP替代方案</li><li>使用Web作为界面，用户代理就是普通的浏览器</li><li>用户以及其远程邮件之间的通信通过HTTP进行</li></ul><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><h3 id="HTTP服务器与客户端"><a href="#HTTP服务器与客户端" class="headerlink" title="HTTP服务器与客户端"></a>HTTP服务器与客户端</h3><ul><li><p>服务器</p><ul><li>Web页面（HTML文档）：包含多种对象或者连接</li><li>Web对象（包含：静态对象以及动态对象）：可以是HTML文档，视频文件，音频文件，图像文件以及脚本文件等</li><li>对象用URL（统一资源定位符）编址：协议类型：//主机名：端口//路径和文件名</li></ul></li><li><p>客户端</p><ul><li>发出请求，接收响应，解析HTML文档并显示</li><li>有些对象需要浏览器安装插件</li><li> <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702110058685.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="www协议"><a href="#www协议" class="headerlink" title="www协议"></a>www协议</h3><ul><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702110204885.png" alt="在这里插入图片描述"></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>超文本传输协议HTTP在传输层通常使用TCP协议，缺省使用TCP的80端口</li><li>HTTP为无状态协议：服务器端不保留之前请求的状态信息<ul><li>无状态协议：效率低，但简单</li><li>有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出翔故障时，需要保持状态的一致性等。</li></ul></li></ul><h2 id="Web安全隐私：Cookie"><a href="#Web安全隐私：Cookie" class="headerlink" title="Web安全隐私：Cookie"></a>Web安全隐私：Cookie</h2><p>HTTP无状态协议，服务器用cookies保持用户状态</p><ul><li>HTTP在响应的首部行里面使用一个关键字Set-cookie：选择的cookie号具有唯一性</li><li>后继的HTTP请求中使用服务器响应分配的cookie</li><li>Cookie文件保存在用户的主机之中，内容是服务器返回的附加消息，由用户的主机的浏览器管理</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/20210702111728805.png" alt="在这里插入图片描述"></li></ul><h2 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul><li>流媒体概念<ul><li>连续媒体（音视频）经压缩编码，数据打包后，经过网络发送给接收方</li><li>接受方对数据进行重组，解码和播放</li></ul></li><li>流媒体的特性<ul><li>端到端时延约束</li><li>时序性约束：流媒体数据必须按照一定的顺序连续播放</li><li>具有一定程度的容错性：丢失部分数据包也可以完成基本功能</li></ul></li><li>流媒体面临的挑战<ul><li>网络特性（宽带有限，动态变化，延迟与抖动，丢失，异构性）</li><li>目标：流媒体服务质量要素（画质，启动延迟，平滑，交互性）</li></ul></li></ul><h3 id="流媒体动态自适应传输"><a href="#流媒体动态自适应传输" class="headerlink" title="流媒体动态自适应传输"></a>流媒体动态自适应传输</h3><ul><li>DASH<ul><li>动态自适应流媒体协议DASH，由MPEG组织制定的标准</li><li>类似协议：苹果HTTP Live Streaming；Adobe的HTTP Dynamic Streaming,微软的Microsoft Smooth Streaming</li></ul></li><li>基本思想<ul><li>完整视频被拆分为固定时长的视频片段，每段提供不同码率</li><li>视频片段与其对应的元文件（URL）一同存放于DASH服务器</li><li>客户端基于网络条件，缓冲大小等，对每个视频片段，自适应选择合适的视频码率来下载</li></ul></li></ul>]]></content>
    
    
    <summary type="html">计算机网络应用层基础知识</summary>
    
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://kalyan-zitiu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Articles in English#1</title>
    <link href="https://kalyan-zitiu.github.io/2022/10/08/Englishwork/"/>
    <id>https://kalyan-zitiu.github.io/2022/10/08/Englishwork/</id>
    <published>2022-10-08T07:11:04.000Z</published>
    <updated>2022-10-08T14:17:59.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-balance-work-and-leisure"><a href="#How-to-balance-work-and-leisure" class="headerlink" title="How to balance work and leisure"></a>How to balance work and leisure</h1><p>Currently, quite a few citizens will choose to take their hearts into work and learning because they are increasingly competitive in society. As a consequence, more people will make themselves more knowledgeable. It can enrich the quality of life.</p><p>But sometimes, you should get a good balance of work and leisure. It can make your life more comfortable and efficient. Somebody thinks it better work time less than 6 hours. And then the brain enters a state of exhaustion.</p><p>But how do you kill the rest of the time? You can do the best sports you like, or read a book quietly with soothing music. In addition, you can raise a pet to accompany you. In a word, doing something that can make you happy. Someone found a very novel method which calls the Pomodoro technique. It can improve your focus during one working time.</p><p>Hold the view that the best method to balance work and leisure. It depends on your mind. Somebody will consider the work is regarded as a pleasure. So they tend to enjoy it. The most important is what attitude you keep. Suppose you maintain an active mind. You will have inexhaustible power.</p>]]></content>
    
    
    <summary type="html">Leisure articles about work and life</summary>
    
    
    
    <category term="杂谈" scheme="https://kalyan-zitiu.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="English" scheme="https://kalyan-zitiu.github.io/tags/English/"/>
    
  </entry>
  
</feed>
