<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kalyan的小书房</title>
  <icon>https://www.gravatar.com/avatar/26add54e467101c6779c59a0ed4ee504</icon>
  <subtitle>Kalyan is working hard</subtitle>
  <link href="https://kalyan-zitiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://kalyan-zitiu.github.io/"/>
  <updated>2024-07-23T08:10:28.035Z</updated>
  <id>https://kalyan-zitiu.github.io/</id>
  
  <author>
    <name>Kalyan</name>
    <email>3148862192@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prometheus基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/</id>
    <published>2024-07-23T08:10:02.000Z</published>
    <updated>2024-07-23T08:10:28.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>一个开源的监控和告警系统</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="多维数据模型"><a href="#多维数据模型" class="headerlink" title="多维数据模型"></a>多维数据模型</h4><ul><li>使用时间序列数据，每个序列有一个度量指标（metricname）和一组键值对（labels）标识，这样可以灵活对同一类进行细分。<h5 id="度量指标"><a href="#度量指标" class="headerlink" title="度量指标"></a>度量指标</h5></li><li>counter：计数器，用于记录累计值，例如请求次数。</li><li>gauge：测量值，可增可减，例如当前内存使用量。</li><li>histogram：直方图，用于记录值分布，例如请求延迟。</li><li>summary：摘要，用于统计分位数和总和，例如响应时间的分位数。</li></ul><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ul><li>一组键值对，用于对时间序列进行细分和区分。例如，监控一个 HTTP 请求的计数器可以通过标签区分不同的请求路径和状态码</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;200&quot;</span>&#125;</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;500&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们有一个 Web 服务，它记录了每个请求的数量和响应时间。我们可以定义以下指标：</p><ol><li>记录请求数量的计数器：<ul><li>Metric Name: <code>http_requests_total</code></li><li>Labels: <code>method</code>, <code>handler</code>, <code>status</code></li></ul></li><li>记录响应时间的直方图：<ul><li>Metric Name: <code>http_request_duration_seconds</code></li><li>Labels: <code>method</code>, <code>handler</code></li></ul></li></ol><p>每次有新的请求进来，计数器和直方图都会更新。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;200&quot;</span>&#125; 1234</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;500&quot;</span>&#125; 56</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.1&quot;</span>&#125; 5</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.5&quot;</span>&#125; 50</span><br></pre></td></tr></table></figure><h4 id="支持PromQL"><a href="#支持PromQL" class="headerlink" title="支持PromQL"></a>支持PromQL</h4><p>查询所有 POST 请求的数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;method=&quot;POST&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询 <code>/api/v1</code> 接口的所有请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;handler=&quot;/api/v1&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询状态码为 200 的请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;status=&quot;200&quot;&#125;)</span><br></pre></td></tr></table></figure><h5 id="优化使用标签"><a href="#优化使用标签" class="headerlink" title="优化使用标签"></a>优化使用标签</h5><ul><li><strong>标签数目不要过多</strong>：过多的标签会导致时间序列爆炸，影响性能。</li><li><strong>标签值尽量稳定</strong>：标签值变化太频繁会增加存储和查询负担。</li><li><strong>合理设计标签</strong>：确保标签的选择能够满足查询需求，同时不过度细化。</li></ul><h4 id="时间序列数据库"><a href="#时间序列数据库" class="headerlink" title="时间序列数据库"></a>时间序列数据库</h4><h5 id="TSDB-Prometheus自带时序数据库"><a href="#TSDB-Prometheus自带时序数据库" class="headerlink" title="TSDB Prometheus自带时序数据库"></a>TSDB Prometheus自带时序数据库</h5><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><p>高效写入：Prometheus 的 TSDB 能够每秒写入数百万个样本，适合高频数据采集。<br>高效查询：针对时间序列数据优化的查询性能。<br>数据压缩：使用差分编码和 Gorilla 压缩算法减少存储空间。<br>局部存储：数据默认存储在本地磁盘上，可以通过远程存储扩展。</p><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>样本 (Sample)：包含一个时间戳和一个值。<br>时间序列 (Time Series)：由一个度量名和一组标签唯一标识的一组样本。<br>块 (Block)：TSDB 中的数据以块的形式存储，每个块通常覆盖 2 小时的数据。<br>WAL (Write-Ahead Log)：在写入到块之前，数据先写入 WAL，以确保数据持久化。</p><h6 id="数据存储和管理"><a href="#数据存储和管理" class="headerlink" title="数据存储和管理"></a>数据存储和管理</h6><ol><li>数据存储路径：默认存储路径为 /var/lib/prometheus，可以在 Prometheus 配置文件中通过 storage.tsdb.path 参数修改。</li><li>数据保留策略：默认保留 15 天的数据，可以通过 –storage.tsdb.retention.time 参数设置。</li><li>数据压缩和删除：Prometheus 会自动压缩和删除过期数据。<h4 id="独立抓取模型："><a href="#独立抓取模型：" class="headerlink" title="独立抓取模型："></a>独立抓取模型：</h4></li></ol><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol><li><strong>Scrape</strong>：Prometheus 从目标处获取监控数据的过程。</li><li><strong>Target</strong>：被监控的对象，可以是服务器、应用程序、数据库等。</li><li><strong>Job</strong>：一组相似目标的集合。</li><li><strong>Exporter</strong>：用于将目标的数据暴露给 Prometheus 的组件，通常是 HTTP 端点</li></ol><h5 id="配置文件’prometheus-yml’"><a href="#配置文件’prometheus-yml’" class="headerlink" title="配置文件’prometheus.yml’"></a>配置文件’prometheus.yml’</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s     <span class="comment"># 每15秒抓取一次数据</span></span><br><span class="line">  evaluation_interval: 15s <span class="comment"># 每15秒评估一次规则</span></span><br></pre></td></tr></table></figure><h6 id="抓取配置"><a href="#抓取配置" class="headerlink" title="抓取配置"></a>抓取配置</h6><p>抓取配置定义了 Prometheus 如何发现和抓取目标数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br></pre></td></tr></table></figure><h6 id="动态服务发现"><a href="#动态服务发现" class="headerlink" title="动态服务发现"></a>动态服务发现</h6><p>Prometheus 支持多种服务发现机制，允许动态发现目标。例如，可以使用 Kubernetes、Consul、Etcd 等进行服务发现。</p><p>####### Exporter<br>Exporter 是将监控数据暴露给 Prometheus 的组件，不同的应用和系统有不同的 Exporter。例如：</p><ul><li>Node Exporter：用于监控操作系统的资源使用情况。</li><li>Blackbox Exporter：用于进行探测和检查（如 HTTP、HTTPS、TCP）。</li><li>MySQL Exporter：用于监控 MySQL 数据库。</li></ul><h4 id="多种数据支持："><a href="#多种数据支持：" class="headerlink" title="多种数据支持："></a>多种数据支持：</h4><p>支持包括通过导出器（exporters）收集第三方系统的数据，支持服务发现（Service Discovery），如 Kubernetes、Consul、Etcd 等</p><h4 id="告警："><a href="#告警：" class="headerlink" title="告警："></a>告警：</h4><p>内置了 Alertmanager，用于处理告警通知和管理告警规则。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol><li>Prometheus Server：<br>存储：使用基于时间序列数据库（TSDB）的本地存储来存储监控数据。<br>抓取（Scrape）：定期从目标端点（如应用程序、数据库等）拉取指标数据。<br>PromQL 查询引擎：允许用户通过 PromQL 查询存储的数据。</li><li>数据导出器（Exporters）：<br>节点导出器（Node Exporter）：收集系统级别的指标，如 CPU、内存、磁盘使用等。<br>应用程序导出器：如 MySQL Exporter、Redis Exporter，专门用于从特定应用中收集指标。</li><li>服务发现（Service Discovery）：<br>支持多种服务发现机制，如 Kubernetes、Consul、DNS 等，自动发现并监控动态变化的服务和主机。</li><li>Alertmanager：<br>告警规则：定义告警规则，当满足条件时触发告警。<br>告警通知：管理告警的路由和发送，支持多种通知方式，如电子邮件、Slack、PagerDuty 等。<br>告警抑制和分组：可以配置告警抑制规则和告警分组，避免告警风暴。</li><li>Pushgateway：<br>用于接收临时性任务（如批处理任务）的指标数据，这些任务无法被 Prometheus 定期拉取。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>配置和服务发现：通过配置文件或服务发现机制，Prometheus 确定需要监控的目标。</li><li>抓取数据：Prometheus 定期从目标端点拉取指标数据。</li><li>存储数据：将拉取到的指标数据存储在本地的时间序列数据库中。</li><li>查询和可视化：通过 PromQL 查询数据，结合 Grafana 等可视化工具展示监控结果。</li><li>告警处理：根据定义的告警规则，Prometheus 触发告警并通过 Alertmanager 发送通知。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prometheus&quot;&gt;&lt;a href=&quot;#Prometheus&quot; class=&quot;headerlink&quot; title=&quot;Prometheus&quot;&gt;&lt;/a&gt;Prometheus&lt;/h2&gt;&lt;p&gt;一个开源的监控和告警系统&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://kalyan-zitiu.github.io/categories/kubernetes/"/>
    
    
    <category term="Prometheus" scheme="https://kalyan-zitiu.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>简单ansible操作</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/</id>
    <published>2024-07-22T06:59:35.000Z</published>
    <updated>2024-07-22T07:00:01.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><p>用于配置管理、应用程序部署、任务自动化</p><h3 id="ansible主机清单"><a href="#ansible主机清单" class="headerlink" title="ansible主机清单"></a>ansible主机清单</h3><h4 id="定义组"><a href="#定义组" class="headerlink" title="定义组"></a>定义组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[webservers] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dbserver] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dce5_nodes]</span><br><span class="line">10.70.49.17[2:4]</span><br><span class="line"></span><br><span class="line">[all:vars] <span class="comment"># 定义全局变量适用于全部主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 用户名，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_user: guest2admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 密码，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_pass: @<span class="built_in">users</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible 使用的 Python 解释器路径</span></span><br><span class="line">ansible_python_interpreter: /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接的通用参数，这里指定了加密算法为 AES-256-CBC</span></span><br><span class="line">ansible_ssh_common_args: -c aes256-cbc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Ansible 连接到主机的方式，这里使用 SSH</span></span><br><span class="line">ansible_connection: ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权操作时使用的密码（例如切换到 root 用户时的密码）</span></span><br><span class="line">ansible_become_password: root@root@su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权方法，这里使用 su 命令切换用户</span></span><br><span class="line">ansible_become_method: su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权执行命令，这里指定了使用 sudo su - 命令来切换到超级用户</span></span><br><span class="line">ansible_become_exe: sudo su -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以组别变量</span></span><br><span class="line">[webserver:vars]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h3><ol><li><p><strong>Ping 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><p>通过 Ping 模块测试所有主机是否可达。</p></li><li><p><strong>Shell 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;uptime&#x27;</span></span><br></pre></td></tr></table></figure><p>在所有主机上执行 <code>uptime</code> 命令。</p></li><li><p><strong>Command 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&#x27;ls /tmp&#x27;</span></span><br></pre></td></tr></table></figure><p>使用 <code>command</code> 模块列出 <code>/tmp</code> 目录下的文件。</p></li><li><p><strong>Copy 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">&#x27;src=/path/to/source dest=/path/to/destination&#x27;</span></span><br></pre></td></tr></table></figure><p>将本地文件复制到远程主机。</p></li><li><p><strong>File 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m file -a <span class="string">&#x27;path=/tmp/testfile state=touch&#x27;</span></span><br></pre></td></tr></table></figure><p>在远程主机上创建一个空文件。</p></li><li><p><strong>Service 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m service -a <span class="string">&#x27;name=httpd state=started&#x27;</span></span><br></pre></td></tr></table></figure><p>启动所有主机上的 httpd 服务。</p></li><li><p><strong>User 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m user -a <span class="string">&#x27;name=johndoe state=present&#x27;</span></span><br></pre></td></tr></table></figure><p>创建一个名为 <code>johndoe</code> 的用户。</p></li></ol><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-i &lt;inventory&gt;</code>：指定主机清单文件。例如 <code>-i hosts</code>。</li><li><code>--list-hosts</code>：列出将运行任务的主机。</li><li><code>-l &lt;subset&gt;</code>：指定要执行任务的主机子集。例如 <code>-l webservers</code>。</li><li><code>-u &lt;user&gt;</code>：指定远程主机用户。例如 <code>-u root</code>。</li><li><code>-k</code>：提示输入 SSH 密码。</li><li><code>--ask-become-pass</code>：提示输入 sudo 密码。</li><li><code>-e &lt;extra_vars&gt;</code>：传递额外变量。例如 <code>-e &quot;var1=value1 var2=value2&quot;</code>。</li></ul><h3 id="示例详解"><a href="#示例详解" class="headerlink" title="示例详解"></a>示例详解</h3><ol><li><p><strong>列出主机</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all --list-hosts</span><br></pre></td></tr></table></figure><p>列出所有在清单中的主机。</p></li><li><p><strong>指定用户和密码执行命令</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;df -h&#x27;</span> -u root -k</span><br></pre></td></tr></table></figure><p>使用 root 用户执行 <code>df -h</code> 命令，并提示输入密码。</p></li><li><p><strong>传递额外变量</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;echo &#123;&#123; var_name &#125;&#125;&#x27;</span> -e <span class="string">&#x27;var_name=HelloWorld&#x27;</span></span><br></pre></td></tr></table></figure><p>传递变量 <code>var_name</code>，并在命令中使用。</p></li></ol><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ol><li><p><strong>使用标签</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;systemctl restart httpd&#x27;</span> --tags <span class="string">&quot;restart&quot;</span></span><br></pre></td></tr></table></figure><p>使用标签来组织和执行特定的任务。</p></li><li><p><strong>检查主机连通性</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping -i inventory/hosts</span><br></pre></td></tr></table></figure><p>使用指定的主机清单文件检查连通性。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h2&gt;&lt;p&gt;用于配置管理、应用程序部署、任务自动化&lt;/p&gt;
&lt;h3 id=&quot;ansible主机清单&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="ansible" scheme="https://kalyan-zitiu.github.io/categories/ansible/"/>
    
    
    <category term="ansible" scheme="https://kalyan-zitiu.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes服务网格</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</id>
    <published>2024-07-22T03:31:12.000Z</published>
    <updated>2024-07-22T03:35:22.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kubernetes服务网格"><a href="#kubernetes服务网格" class="headerlink" title="kubernetes服务网格"></a>kubernetes服务网格</h2><p>是一种架构，为了解决服务和服务之间的通信。</p><h3 id="服务网格接口（打算理解）"><a href="#服务网格接口（打算理解）" class="headerlink" title="服务网格接口（打算理解）"></a>服务网格接口（打算理解）</h3><h4 id="SMI"><a href="#SMI" class="headerlink" title="SMI"></a>SMI</h4><p>  用于定义服务网格标准化接口的规范，旨在提供一个通用的接口，让不同的服务网格实现可以互操作。SMI的主要目的是简化服务网格的使用和集成，使用户可以使用统一的API管理不同的服务网格实现，如Istio、Linkerd、Consul Connect等。</p><h4 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h4><p>  是Kubernetes中的一种机制，用于扩展Kubernetes API，使用户可以定义自己的资源类型。通过CRD，用户可以创建自定义资源（CR），这些资源可以与Kubernetes内置资源（如Pod、Service）一样进行管理和操作。</p><h3 id="数据平面代理"><a href="#数据平面代理" class="headerlink" title="数据平面代理"></a>数据平面代理</h3><p>负责处理和管理服务间流量的代理组件。</p><p>核心职责:<br>流量转发：代理组件负责接收、转发和负载均衡服务之间的流量。这包括 HTTP、gRPC、TCP 等多种协议。<br>服务发现：代理可以自动发现 Kubernetes 中的服务，根据服务的配置进行相应的流量路由。<br>流量管理：包括流量控制、重试策略、断路器、故障注入等功能，以保证服务间通信的可靠性和稳定性。<br>安全：提供 mTLS（双向 TLS）加密来确保服务间通信的安全性，支持认证和授权策略。<br>监控和可观测性：代理会收集并上报各种流量指标和日志，帮助管理员监控和诊断服务间的通信问题。</p><h4 id="数据平面架构"><a href="#数据平面架构" class="headerlink" title="数据平面架构"></a>数据平面架构</h4><h5 id="代理附件"><a href="#代理附件" class="headerlink" title="代理附件"></a>代理附件</h5><p>一般部署在工作负载的pod上，后续会拦截进出服务的所有通信，但是在一些升级上，代理附件不能保证在不重建Pod的条件下进行升级</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112524609.png" alt="image-20240722112524609"></p><h5 id="代理节点"><a href="#代理节点" class="headerlink" title="代理节点"></a>代理节点</h5><p>由代理节点来处理运行服务的所有流量。但是会存在很大的网络瓶颈。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112926402.png" alt="image-20240722112926402"></p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>  一个高性能的开源边缘和服务代理，主要用于微服务架构中的通信管理</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722102428515.png" alt="image-20240722102428515"></p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><h6 id="API网关："><a href="#API网关：" class="headerlink" title="API网关："></a>API网关：</h6><p>Envoy可以作为API网关，处理外部请求并将其路由到内部服务，同时提供认证、限流、缓存等功能。</p><h6 id="边车代理："><a href="#边车代理：" class="headerlink" title="边车代理："></a>边车代理：</h6><ul><li>是一种设计模式，在这种模式下，一个代理程序（如Envoy）被部署在每个服务实例的旁边，这样每个服务实例都有一个独立的代理来处理进出流量。</li><li>在服务网格架构中，Envoy通常以边车代理的形式部署在每个服务实例旁，拦截和处理所有入站和出站流量。</li><li>边车注入是将边车代理自动注入到服务实例的Pod中，以便在微服务架构中实现服务网格功能的过程。分为手动与自动，自动注入似乎能够用istio来进行自动注入。</li><li>Sidecar 模式：Envoy 通常以 sidecar 容器的形式部署在每个微服务 Pod 内，与应用容器共享网络命名空间。所有进出微服务的流量都会通过 Envoy 代理。</li></ul><h6 id="中介层代理："><a href="#中介层代理：" class="headerlink" title="中介层代理："></a>中介层代理：</h6><p>Envoy可以部署在不同的服务层之间，作为中介层代理，处理跨服务的流量和策略管理。</p><h5 id="模块化架构"><a href="#模块化架构" class="headerlink" title="模块化架构"></a>模块化架构</h5><p>Listener：<br>作用：Listener是Envoy用于监听网络端口的组件，负责接受客户端的连接请求。每个Listener都绑定到一个特定的IP地址和端口，并根据配置将流量传递给相应的处理模块。<br>配置：Listener的配置包括监听的地址和端口、使用的协议（如HTTP、TCP）、以及关联的过滤器链。</p><p>Filter：<br>作用：Filter是Envoy用于处理请求和响应的中间处理模块。Filter可以用于修改请求、添加日志、执行身份验证、路由选择等。Envoy的Filter分为多种类型，包括网络过滤器、HTTP过滤器和TCP过滤器。<br>类型：<br>网络过滤器：处理TCP连接层面的流量，如TLS终止、连接限速等。<br>HTTP过滤器：处理HTTP请求和响应，如修改头部信息、执行认证和授权、负载均衡等。<br>TCP过滤器：处理TCP层流量，如TCP代理、流量镜像等。</p><p>Cluster：<br>作用：Cluster是Envoy用于表示一组上游服务实例的组件。Cluster负责服务发现、负载均衡、健康检查等。每个Cluster包含多个主机（即上游服务实例），并定义了如何将流量分配到这些主机上。<br>配置：Cluster的配置包括服务发现类型（静态、DNS、EDS等）、负载均衡策略（如轮询、随机、加权轮询等）、健康检查配置等。</p><p>Route：<br>作用：Route组件定义了Envoy如何将请求路由到不同的Cluster。Route规则基于请求的属性（如路径、头部信息、方法等）来决定具体的路由目标。<br>配置：Route的配置包括匹配规则、路由目标Cluster、重试策略、超时设置等。</p><p>Admin：<br>作用：Admin组件提供了管理和监控Envoy的接口。通过Admin接口，用户可以查看Envoy的运行状态、统计信息、配置详情，并进行管理操作。<br>配置：Admin接口通常通过HTTP API暴露，可以在Envoy配置中指定Admin的监听地址和端口。</p><h5 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h5><p>配置管理<br>Envoy的配置管理可以通过静态文件配置，也可以通过动态配置API（xDS）实现。xDS（Envoy Dynamic Configuration API）包括以下几个部分：<br>ADS（Aggregated Discovery Service）：聚合配置服务，统一管理其他xDS服务。<br>CDS（Cluster Discovery Service）：动态管理Cluster的配置。<br>EDS（Endpoint Discovery Service）：动态管理Cluster中上游服务实例的配置。<br>LDS（Listener Discovery Service）：动态管理Listener的配置。<br>RDS（Route Discovery Service）：动态管理路由配置。<br>SDS（Secret Discovery Service）：动态管理密钥和证书。</p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>负责管理和协调数据平面代理</p><p>配置管理：提供统一的配置接口，管理服务网格中所有代理的配置，包括路由规则、负载均衡策略、故障恢复策略等。<br>服务发现：集成服务发现机制，实时感知集群中服务的变化，并通知数据平面代理更新其配置。<br>安全管理：实现服务间的认证和授权，管理 TLS 证书的分发和轮换，确保服务间通信的安全性。<br>流量管理：提供流量路由、灰度发布、A/B 测试等高级流量控制功能，帮助开发和运维人员灵活管理服务间的流量。<br>可观测性：收集和聚合数据平面代理的监控指标、日志和分布式追踪数据，提供全局的可观测性视图，帮助排查和诊断问题。</p><h4 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h4><p>istiod为基于envoy的服务网络提供控制平面，他包括三个核心组件，Galley，Pilot，Citidel</p><p>Pilot：一个Envoy的配置服务器，实现 xDS API，并将配置流向与应用程序一起运行的Envoy代理。</p><p>Citadel：负责网格内的证书管理，建立服务器身份和相互TLS。</p><p>Galley：与外部系统互动，Kubernetes等。</p><h4 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h4><p>用于在 Kubernetes 集群中实现动态配置和策略控制的关键组件。 Istio 中的主要用途包括服务网格控制、资源变更管理和策略执行等。</p><ul><li>自动注入 Sidecar 容器:Istio 使用一个变异（Mutating）Webhook 自动将 Envoy 代理（Sidecar）注入到新创建的 Kubernetes Pod 中。这个过程确保每个服务都能被 Istio 管理和监控。当你为集群启用了自动注入，Webhook 会拦截 Pod 创建请求，在 Pod 完成调度之前往其定义中添加 Envoy 容器以及必要的配置信息。</li><li>配置验证（Validating Webhook）:验证（Validating）Webhook 用于在新的 Istio 配置资源（如 VirtualService、DestinationRule 等）创建或更新时执行验证过程，确保这些配置符合要求，避免因错误配置导致服务故障。这个 Webhook 会在配置提交到 etcd 之前进行执行，起到一个“守门人”的作用，阻止不符合标准的配置生效。</li><li>动态配置和策略控制:Webhook 还可以用于执行动态配置和策略决策。例如，通过 Webhook，可以向运行时注入配置参数或更新策略以应对瞬时需求或安全要求。</li></ul><h4 id="通过iptable达到工作负载通过Envoy发送流量。"><a href="#通过iptable达到工作负载通过Envoy发送流量。" class="headerlink" title="通过iptable达到工作负载通过Envoy发送流量。"></a>通过iptable达到工作负载通过Envoy发送流量。</h4><p>Istio的iptables规则是通过init-containner来进行安装，拦截pod网络流量路由到Envoy。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722111557580.png" alt="image-20240722111557580"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="string">”argS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">istio-iptables</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--envoy-port</span> <span class="comment">#捕获出站的所有流量，并且发送到Envoy这个端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15001&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--inbound-capture-port</span> <span class="comment">#捕获入站的所有流量，并且发送Envoy这个端口1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15006&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--proxy-uid</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;1337”</span></span><br><span class="line"><span class="string">- --istio-inbound-interception-mode</span></span><br><span class="line"><span class="string">- REDIRECT</span></span><br><span class="line"><span class="string">--istio-service-cidr </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">--istio-inbound-ports </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">- --istio-local-exclude-ports</span></span><br><span class="line"><span class="string">- 15090,15021,15020</span></span><br><span class="line"><span class="string">image: docker.io/istio/proxyv2:1.6.7</span></span><br><span class="line"><span class="string">imagePullPolicy: Always</span></span><br><span class="line"><span class="string">name: istio-init</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kubernetes服务网格&quot;&gt;&lt;a href=&quot;#kubernetes服务网格&quot; class=&quot;headerlink&quot; title=&quot;kubernetes服务网格&quot;&gt;&lt;/a&gt;kubernetes服务网格&lt;/h2&gt;&lt;p&gt;是一种架构，为了解决服务和服务之间的通信。&lt;</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes ingress基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/19/Kubernetes_ingress/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/19/Kubernetes_ingress/</id>
    <published>2024-07-19T01:21:03.000Z</published>
    <updated>2024-07-19T08:02:55.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><p>  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，可以简单的理解为一个外包，现在在互联网上很多的流量都使用了TLS/SSL协议继续加密，但是这也会增加服务器的负担，因此SSL终止可以理解成<code>外包</code>一个机器处理这个问题。一般这个外包工作会给到负载均衡器和反向代理。</p><h3 id="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"><a href="#为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？" class="headerlink" title="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"></a>为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？</h3><ul><li>好像就是因为service不够用:dog:所以才有了ingress的存在，而且似乎ingress在处理HTTP和HTTPS流量的能力上十分出色。</li><li>除此之外ingress跳脱到应用层进行负载和流量路由的功能，大大减少统一访问策略和路由规则:boom:</li><li>而且ingress似乎为每一个集群提供了单一入口，流量能够精准投送。:fish:</li></ul><h3 id="ingress-配置冲突"><a href="#ingress-配置冲突" class="headerlink" title="ingress 配置冲突"></a>ingress 配置冲突</h3><p>不同团队或租户尝试使用相同的域名来暴露他们的应用程序时，可能会发生的问题。简单来说，就是两个团队都想用同一个域名，比如<code>app.bearcanoe.com</code>，来让外界访问他们的应用程序。这会导致冲突，因为Ingress控制器（管理这些网络流量的组件）不明确如何处理这种情况</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>准入控制器：在配置被应用到集群之前，验证并确保域名的唯一性。可以使用开放策略代理（OPA）来实现这个功能。</li><li>Contour Ingress 控制器：使用HTTPProxy自定义资源，创建一个根HTTPProxy资源，分配给特定团队。这种方法将域名管理集中化，避免冲突。</li></ol><h3 id="Ingress控制器"><a href="#Ingress控制器" class="headerlink" title="Ingress控制器"></a>Ingress控制器</h3><p>是用来实现Ingress资源定义的路由规则和流量管理的组件，以Pod的形式存在运行，负责解析Ingress资源，配置底层反向代理或负载均衡以处理HTTP和HTTPS流量 。</p><ol><li>解析 Ingress 资源：Ingress 控制器会监视 :eye: Kubernetes API，解析和处理定义在 Ingress 资源中的路由规则和配置。</li><li>配置反向代理/负载均衡器：根据解析到的 Ingress 规则，Ingress 控制器会动态配置底层的反向代理（如 NGINX、HAProxy）或云 :cloud: 提供商的负载均衡器（如 AWS ELB、GCP Load Balancer）。</li><li>管理外部访问：Ingress 控制器 :control_knobs: 负责将外部请求路由到集群内相应的服务，管理 HTTP/HTTPS 流量的转发、负载均衡以及 SSL/TLS 终止等功能。</li><li>支持高级特性：许多 Ingress 控制器支持高级功能，如基于 Cookie 的会话保持、限速、访问控制和基于 IP 的访问限制等。</li></ol><h3 id="流量模式"><a href="#流量模式" class="headerlink" title="流量模式"></a>流量模式</h3><h4 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h4><p>:question:什么是HTTP代理呢，想象一下你需要借一本书，但是这本书在一个封闭的空间内，你不能够直接自己拿到，这个时候你就需要一个中间人来帮你去借。这个时候这个中间人就可以理解成代理人。就是当客户进行一个HTTP请求，这个请求会通过代理服务器转发到目标服务器。反向代理也是这么理解，目标服务器的资源通过代理服务器传输出去。</p><p>:boy:ingress处理HTTP流量很简单，就是通过host头进行路由转发</p><h4 id="HTTPS代理"><a href="#HTTPS代理" class="headerlink" title="HTTPS代理"></a>HTTPS代理</h4><p>:question:HTTPS流量处理的有些特别，ingress在获取流量的时候进行SSL终止，然后建立新的HTTP请求进行转发。</p><p>但是特殊情况为了安全起见。ingress也会进行SSL终止之后再进行TLS加密与后端pod建立连接。</p><h4 id="OCI-3-4层代理"><a href="#OCI-3-4层代理" class="headerlink" title="OCI 3/4层代理"></a>OCI 3/4层代理</h4><p>:calendar:不懂往后点再研究…….</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="control-knobs-nginx-ingress-controller"><a href="#control-knobs-nginx-ingress-controller" class="headerlink" title=":control_knobs:nginx ingress controller"></a>:control_knobs:nginx ingress controller</h4><p>常用于HTTP和反向代理</p><ul><li>支持SSL/TLS终止</li><li>基于主机名和路径的路由</li><li>支持URL重写和重定向</li></ul><h4 id="control-knobs-Istio-ingress-Gateway"><a href="#control-knobs-Istio-ingress-Gateway" class="headerlink" title=":control_knobs:Istio ingress Gateway"></a>:control_knobs:Istio ingress Gateway</h4><p>Istio Ingress Gateway 是 Istio 服务网格中的一个组件，专门用于管理进入服务网格的外部 HTTP 和 HTTPS 流量。与传统的 Kubernetes Ingress 不同，Istio Ingress Gateway 提供了更多的高级流量管理和安全功能，如细粒度的流量控制、策略管理和监控。</p><h5 id="Istio-Ingress-Gateway-组件"><a href="#Istio-Ingress-Gateway-组件" class="headerlink" title="Istio Ingress Gateway 组件"></a>Istio Ingress Gateway 组件</h5><ol><li>:door: Gateway：定义哪些外部流量可以进入服务网格，以及如何路由这些流量。</li><li>VirtualService：定义流量的具体路由规则，可以包含多种匹配条件和路由行为。</li></ol><h4 id="control-knobs-HAProxy-Ingress"><a href="#control-knobs-HAProxy-Ingress" class="headerlink" title=":control_knobs: HAProxy Ingress"></a>:control_knobs: HAProxy Ingress</h4><p>高性能和高级路由功能，路由灵活，低延迟，负载均衡算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ingress&quot;&gt;&lt;a href=&quot;#ingress&quot; class=&quot;headerlink&quot; title=&quot;ingress&quot;&gt;&lt;/a&gt;ingress&lt;/h2&gt;&lt;p&gt;  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes服务基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-07-17T05:26:24.000Z</published>
    <updated>2024-07-17T07:34:53.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes服务基础"><a href="#Kubernetes服务基础" class="headerlink" title="Kubernetes服务基础"></a>Kubernetes服务基础</h1><h2 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl get svc &lt;svc-name&gt;</span><br><span class="line">kubectl describe svc &lt;svc-name&gt;</span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">kubectl expose deployment &lt;d-name&gt; --port&lt;port&gt; --target-port=&lt;target-port&gt;</span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">kubectl get endpoints &lt;svc-name&gt;：查看服务端点</span><br><span class="line">kubectl port-forward svc/&lt;svc-name&gt;&lt;local-port&gt;:&lt;svc-port&gt;:本地端口转发服务端口</span><br></pre></td></tr></table></figure><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h3><ul><li>ClusterIP: 分配一个集群内部的ip地址，使得服务只能集群内部访问</li><li>NodePort: 在每个节点上分配一个端口，是的可以外部访问服务</li><li>LoadBalancer: 使用负载均衡来暴露服务，让服务加入后端池</li><li>ExternalName: 通过返回的CNAME记录来映射另一个外部的DNS名称</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717132825010.png" alt="image-20240717132825010"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717145241179.png" alt="image-20240717145241179"></p><h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>用于定义一组Pod的逻辑集合，并且可以通过一个稳定的IP地址和端口进行访问。<code>ClusterIP</code>服务类型会在集群内部分配一个虚拟IP地址，这个IP地址只能在集群内部访问，不能从外部直接访问。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ClusterIP</code>类型的Service时，Kubernetes会为这个Service分配一个虚拟IP地址（Cluster IP）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>内部负载均衡</strong>: 当集群内的其他Pod或服务通过Cluster IP访问这个Service时，Kubernetes会自动将请求负载均衡到后端的Pod上。</li></ol><h5 id="yaml参考"><a href="#yaml参考" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: 855d96b0-c9e8-4ef2-afe5-bdb86e21adc3</span><br><span class="line">  resourceVersion: <span class="string">&#x27;194&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-12T07:36:07Z&#x27;</span></span><br><span class="line">  labels:</span><br><span class="line">    component: apiserver</span><br><span class="line">    provider: kubernetes</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: https</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 6443</span><br><span class="line">  clusterIP: 10.233.0.1</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.0.1</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>NodePort</code>类型的Service时，Kubernetes会在每个节点上分配一个端口（范围通常是30000-32767）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>节点端口（NodePort）</strong>: Kubernetes会在每个节点上开放一个指定的端口，并将这个端口的流量转发到Service的Cluster IP，然后再负载均衡到后端的Pod上。</li></ol><h4 id="yaml参考-1"><a href="#yaml参考-1" class="headerlink" title="yaml参考"></a>yaml参考</h4><h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>ps：这里的LoadBalancer和云上的不同，是为了解决nodeport不清晰问题。</p><h5 id="外部流量策略"><a href="#外部流量策略" class="headerlink" title="外部流量策略"></a>外部流量策略</h5><ol><li>cluster</li></ol><ul><li>把流量分配给所有集群中所有节点的可用实例上</li><li>能够做到全局分配和高利用，但是可能会造成比较高的延迟</li><li>场景：适合需要整体稳定可用的</li></ul><ol start="2"><li>local</li></ol><ul><li>优先把流量分给同一节点或同一区域的可用实例上</li><li>能够低延迟访问服务，本地优先</li><li>场景：适合游戏或者视频流媒体</li></ul><h5 id="yaml参考-2"><a href="#yaml参考-2" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: loadbalancer-01</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: c4093644-e423-4737-94e1-8fd92606933d</span><br><span class="line">  resourceVersion: <span class="string">&#x27;3774606&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-16T03:04:31Z&#x27;</span></span><br><span class="line">  annotations:</span><br><span class="line">    kpanda.io/alias-name: loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: tcp-loadbalaner</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 8081</span><br><span class="line">      targetPort: 8081</span><br><span class="line">      nodePort: 30683</span><br><span class="line">  selector:</span><br><span class="line">    app: baize-notebook-ssh</span><br><span class="line">  clusterIP: 10.233.59.228</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.59.228</span><br><span class="line">  <span class="built_in">type</span>: LoadBalancer</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  allocateLoadBalancerNodePorts: <span class="literal">true</span></span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h4><h5 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ExternalName</code>类型的Service时，你需要指定一个外部的DNS名称。</li><li><strong>DNS解析</strong>: Kubernetes的DNS服务会为这个Service创建一个CNAME记录，将Service名称解析为指定的外部DNS名称。</li><li><strong>访问外部服务</strong>: 集群内的Pod可以通过Service名称访问外部的服务，Kubernetes的DNS服务会将这个名称解析为外部的DNS名称</li></ol><h5 id="yaml参考-3"><a href="#yaml参考-3" class="headerlink" title="yaml参考"></a>yaml参考</h5><p>不许参考，懒得cv了都基本一样就其他字段和type不同。</p>]]></content>
    
    
    <summary type="html">了解服务以及服务网格的作用</summary>
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux文件</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/</id>
    <published>2024-07-10T03:47:16.000Z</published>
    <updated>2024-07-10T05:44:03.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h3><h4 id="1-lsof-List-Open-Files"><a href="#1-lsof-List-Open-Files" class="headerlink" title="1. lsof (List Open Files)"></a>1. lsof (List Open Files)</h4><p><code>lsof</code>命令用于列出当前系统中已打开的文件。它可以显示哪个进程正在使用哪个文件，并提供有关这些文件的详细信息。这个命令在排查文件占用、删除不成功或挂载卸载问题时非常有用。</p><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof [选项] [文件]</span><br></pre></td></tr></table></figure><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-u</code>：显示指定用户打开的文件。</li><li><code>-p</code>：显示指定进程ID打开的文件。</li><li><code>+D</code>：递归显示指定目录下的所有打开文件。</li><li><code>-i</code>：显示与网络相关的文件（例如端口使用情况）。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>列出所有打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>查看用户<code>user</code>打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u user</span><br></pre></td></tr></table></figure><p>显示进程ID为1234的进程打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure><h4 id="2-cp-Copy-Files"><a href="#2-cp-Copy-Files" class="headerlink" title="2. cp (Copy Files)"></a>2. cp (Copy Files)</h4><p><code>cp</code>命令用于复制文件和目录。</p><h5 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-r</code>：递归复制目录及其内容。</li><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时复制。</li><li><code>-p</code>：保留源文件的属性。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>复制文件<code>file1</code>到<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> file1 file2</span><br></pre></td></tr></table></figure><p>递归复制目录<code>dir1</code>到<code>dir2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r dir1 dir2</span><br></pre></td></tr></table></figure><h4 id="3-mv-Move-Rename-Files"><a href="#3-mv-Move-Rename-Files" class="headerlink" title="3. mv (Move/Rename Files)"></a>3. mv (Move/Rename Files)</h4><p><code>mv</code>命令用于移动或重命名文件和目录。</p><h5 id="基本语法：-2"><a href="#基本语法：-2" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时移动。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>重命名文件<code>file1</code>为<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 file2</span><br></pre></td></tr></table></figure><p>移动文件<code>file1</code>到目录<code>dir1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 dir1/</span><br></pre></td></tr></table></figure><h4 id="4-ln-Link-Files"><a href="#4-ln-Link-Files" class="headerlink" title="4. ln (Link Files)"></a>4. ln (Link Files)</h4><p><code>ln</code>命令用于创建硬链接或符号链接（软链接）。</p><h5 id="基本语法：-3"><a href="#基本语法：-3" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [选项] 目标文件 链接文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-s</code>：创建符号链接。</li><li><code>-f</code>：覆盖已有的链接文件。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><p>创建文件<code>file1</code>的硬链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><p>创建文件<code>file1</code>的符号链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file1 link1</span><br></pre></td></tr></table></figure><p>在Linux系统中，建立文件链接（Link）是非常有用的，它提供了多种文件管理和使用的灵活性。文件链接主要分为两种类型：硬链接（Hard Link）和符号链接（Symbolic Link，也称为软链接）。以下是建立链接的原因和它们的用途：</p><h5 id="硬链接（Hard-Link）"><a href="#硬链接（Hard-Link）" class="headerlink" title="硬链接（Hard Link）"></a>硬链接（Hard Link）</h5><p>硬链接是对文件的直接引用。每个硬链接都指向文件的相同物理数据块，因此它们是完全等价的。</p><h6 id="建立硬链接的原因："><a href="#建立硬链接的原因：" class="headerlink" title="建立硬链接的原因："></a>建立硬链接的原因：</h6><ol><li><strong>冗余与备份</strong>：硬链接允许在不同位置访问同一文件内容，可以在不同目录中保持文件的多个访问点，从而提高冗余度，避免文件意外删除。</li><li><strong>节省空间</strong>：硬链接不会占用额外的存储空间，因为它们只是指向同一个物理数据块。</li><li><strong>一致性</strong>：硬链接确保文件的多个实例始终保持同步。对其中一个硬链接的修改会影响所有其他硬链接，因为它们指向相同的数据块。</li></ol><h6 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><h5 id="符号链接（Symbolic-Link-Soft-Link）"><a href="#符号链接（Symbolic-Link-Soft-Link）" class="headerlink" title="符号链接（Symbolic Link / Soft Link）"></a>符号链接（Symbolic Link / Soft Link）</h5><p>符号链接是指向另一个文件路径的引用。它们类似于快捷方式，包含了目标文件或目录的路径。</p><h6 id="建立符号链接的原因："><a href="#建立符号链接的原因：" class="headerlink" title="建立符号链接的原因："></a>建立符号链接的原因：</h6><ol><li><strong>灵活性</strong>：符号链接可以跨文件系统边界创建，而硬链接只能在同一文件系统内使用。它们可以指向目录或文件。</li><li><strong>便捷访问</strong>：通过符号链接，用户可以创建对常用文件或目录的快捷访问点，简化路径的输入和操作。</li><li><strong>组织结构</strong>：符号链接可以帮助组织文件系统，使某些文件或目录在多个位置都能方便地访问，而不需要复制实际数据。</li><li><strong>共享资源</strong>：在多用户环境中，符号链接可以用于共享公共资源，例如库文件、配置文件等，而不必在每个用户目录中复制一份。</li></ol><h6 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/original /path/to/symlink</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux文件管理&quot;&gt;&lt;a href=&quot;#Linux文件管理&quot; class=&quot;headerlink&quot; title=&quot;Linux文件管理&quot;&gt;&lt;/a&gt;Linux文件管理&lt;/h3&gt;&lt;h4 id=&quot;1-lsof-List-Open-Files&quot;&gt;&lt;a href=&quot;#1-l</summary>
      
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="file" scheme="https://kalyan-zitiu.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux网络</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/</id>
    <published>2024-07-10T01:39:02.000Z</published>
    <updated>2024-07-10T03:39:24.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-tcpdump"><a href="#1-tcpdump" class="headerlink" title="1. tcpdump"></a>1. <code>tcpdump</code></h3><p><code>tcpdump</code> 是一个网络抓包工具，可以捕获并分析网络流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上的所有数据包。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.1</span><br></pre></td></tr></table></figure><p>捕获与特定主机 <code>192.168.1.1</code> 相关的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上所有通过端口 <code>80</code> 的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -w capture.pcap</span><br></pre></td></tr></table></figure><p>将捕获的数据包保存到文件 <code>capture.pcap</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r capture.pcap</span><br></pre></td></tr></table></figure><p>读取并分析 <code>capture.pcap</code> 文件中的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#x27;</span></span><br></pre></td></tr></table></figure><p>捕获所有带有 SYN 或 ACK 标志的 TCP 包。</p><h3 id="2-lsof"><a href="#2-lsof" class="headerlink" title="2. lsof"></a>2. <code>lsof</code></h3><p><code>lsof</code> 显示系统中打开的文件，常用于查看打开的网络连接。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p>显示所有打开的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><p>显示所有使用端口 <code>80</code> 的网络连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>显示特定进程 <code>&lt;PID&gt;</code> 打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u &lt;username&gt;</span><br></pre></td></tr></table></figure><p>显示特定用户打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof /path/to/file</span><br></pre></td></tr></table></figure><p>显示哪个进程打开了指定文件。</p><h3 id="3-net-tools"><a href="#3-net-tools" class="headerlink" title="3. net-tools"></a>3. <code>net-tools</code></h3><p><code>net-tools</code> 包含 <code>ifconfig</code>、<code>netstat</code> 等工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure><p>显示接口 <code>eth0</code> 的配置信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p>显示所有活动的网络连接及其状态。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.100 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>配置接口 <code>eth0</code> 的 IP 地址和子网掩码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p>显示路由表信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><p>显示网络接口统计信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -plnt</span><br></pre></td></tr></table></figure><p>显示所有监听的 TCP 端口及其关联的进程。</p><h3 id="4-iproute2"><a href="#4-iproute2" class="headerlink" title="4. iproute2"></a>4. <code>iproute2</code></h3><p><code>iproute2</code> 是 <code>net-tools</code> 的替代品，提供 <code>ip</code> 命令。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure><p>显示所有网络接口。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>显示所有接口的 IP 地址信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add 192.168.1.100/24 dev eth0</span><br></pre></td></tr></table></figure><p>为接口 <code>eth0</code> 添加 IP 地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure><p>启用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add default via 192.168.1.1</span><br></pre></td></tr></table></figure><p>设置默认网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down</span><br></pre></td></tr></table></figure><p>禁用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 1</span><br></pre></td></tr></table></figure><p>添加路由规则，使来自 <code>192.168.1.0/24</code> 的流量使用路由表 <code>1</code>。</p><h3 id="5-NetworkManager"><a href="#5-NetworkManager" class="headerlink" title="5. NetworkManager"></a>5. <code>NetworkManager</code></h3><p><code>NetworkManager</code> 是管理网络配置的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>交互命令窗口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device status</span><br></pre></td></tr></table></figure><p>查看当前设备的连接状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure><p>列出所有已保存的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>列出可用的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi connect SSID password PASSWORD</span><br></pre></td></tr></table></figure><p>连接到指定的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add <span class="built_in">type</span> ethernet ifname eth0 con-name my-eth0</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>my-eth0</code> 的以太网连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con modify my-eth0 ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1</span><br></pre></td></tr></table></figure><p>修改连接 <code>my-eth0</code> 的 IP 地址和网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con up my-eth0</span><br></pre></td></tr></table></figure><p>启用连接 <code>my-eth0</code>。</p><h3 id="6-firewalld"><a href="#6-firewalld" class="headerlink" title="6. firewalld"></a>6. <code>firewalld</code></h3><p><code>firewalld</code> 提供动态的防火墙管理工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p>启动 <code>firewalld</code> 服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><p>查看当前活动的区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>列出当前区域的所有规则。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久打开端口 <code>80</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>重新加载防火墙配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br></pre></td></tr></table></figure><p>将 <code>http</code> 服务添加到 <code>public</code> 区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久关闭端口 <code>80</code>。</p><h3 id="7-iptables"><a href="#7-iptables" class="headerlink" title="7. iptables"></a>7. <code>iptables</code></h3><p><code>iptables</code> 是 Linux 内核中的包过滤工具。</p><h4 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/1343683-20190523094912972-1910501182.png" alt="img"></p><p>iptables 是 Linux 系统中用于配置网络地址转换（NAT）、包过滤和包修改规则的工具。iptables 使用四个表和五个链来处理数据包。以下是对四个表和五个链的详细解释：</p><h5 id="四个表（Tables）"><a href="#四个表（Tables）" class="headerlink" title="四个表（Tables）"></a>四个表（Tables）</h5><ol><li><p><strong>filter 表</strong>：</p><ul><li><strong>用途</strong>：这是默认的表，用于网络包过滤。</li><li><strong>链</strong>：包含 INPUT、FORWARD 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有进入本地网络接口的流量</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许所有从本地网络接口发出的流量</span></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝所有从外部到达本机的流量</span></span><br><span class="line">iptables -A INPUT -i eth0 -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>nat 表</strong>：</p><ul><li><strong>用途</strong>：用于网络地址转换（NAT），比如源 NAT（SNAT）和目标 NAT（DNAT）。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将外部访问的80端口重定向到内部服务器的8080端口</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将发往外部的流量的源IP地址更改为指定的IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mangle 表</strong>：</p><ul><li><strong>用途</strong>：用于修改 IP 包头信息，如 TOS、TTL 等。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT、INPUT、FORWARD 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改流经本机的包的TTL值</span></span><br><span class="line">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 128</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>raw 表</strong>：</p><ul><li><strong>用途</strong>：用于在连接跟踪（conntrack）机制之前对数据包进行处理。</li><li><strong>链</strong>：包含 PREROUTING 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标记流经本机的包，以不进行连接跟踪</span></span><br><span class="line">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="五个链（Chains）"><a href="#五个链（Chains）" class="headerlink" title="五个链（Chains）"></a>五个链（Chains）</h5><ol><li><p><strong>INPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理入站流量，即目标为本机的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拒绝所有到达本机的入站流量</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>FORWARD 链</strong>：</p><ul><li><strong>用途</strong>：处理转发流量，即通过本机路由的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有通过本机的转发流量</span></span><br><span class="line">iptables -A FORWARD -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>OUTPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理出站流量，即从本机发出的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有从本机发出的出站流量</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>PREROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之前处理入站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之前修改入站包的目的IP地址</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>POSTROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之后处理出站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之后修改出站包的源IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure><p>列出所有当前规则。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有进入的 TCP 连接通过端口 <code>80</code>。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p icmp -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有 ICMP 出站流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>保存当前规则到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-restore &lt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>从文件恢复规则。</p><h3 id="8-nftables"><a href="#8-nftables" class="headerlink" title="8. nftables"></a>8. <code>nftables</code></h3><p>NFTables 是一个用于包过滤、网络地址转换 (NAT) 和流量控制的框架。它替代了 iptables、ip6tables、arptables 和 ebtables。NFTables 的配置文件通常使用简单的脚本语言来定义规则。以下是 NFTables 的表、链和规则的基本结构和语法。</p><h4 id="一、基础结构"><a href="#一、基础结构" class="headerlink" title="一、基础结构"></a>一、基础结构</h4><ol><li><p><strong>表（table）</strong></p><ul><li>表是规则集的容器。每张表可以包含多个链。</li></ul></li><li><p><strong>链（chain）</strong></p><ul><li>链是规则的有序列表。链可以是内置的（如 <code>input</code>、<code>output</code>、<code>forward</code>）或用户定义的。</li></ul></li><li><p><strong>规则（rule）</strong></p><ul><li>规则定义了特定条件下应执行的动作。</li></ul></li></ol><h4 id="二、表、链和规则的语法"><a href="#二、表、链和规则的语法" class="headerlink" title="二、表、链和规则的语法"></a>二、表、链和规则的语法</h4><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;family&gt;</code>: 地址族，常见的有 <code>ip</code>（IPv4）、<code>ip6</code>（IPv6）、<code>inet</code>（支持 IPv4 和 IPv6）、<code>arp</code>（ARP）、<code>bridge</code>（网桥）。</li><li><code>&lt;table_name&gt;</code>: 表的名称。</li></ul></li><li><p><strong>删除表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出现有表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list tables</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &#123; type &lt;type&gt; hook &lt;hook&gt; priority &lt;priority&gt;; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;type&gt;</code>: 链的类型，可以是 <code>filter</code>、<code>nat</code> 等。</li><li><code>&lt;hook&gt;</code>: 钩子点，可以是 <code>input</code>、<code>output</code>、<code>forward</code>、<code>prerouting</code>、<code>postrouting</code> 等。</li><li><code>&lt;priority&gt;</code>: 优先级。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; type filter hook input priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &lt;expression&gt; &lt;action&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;expression&gt;</code>: 匹配条件，例如 <code>ip saddr 192.168.1.1</code>。</li><li><code>&lt;action&gt;</code>: 动作，例如 <code>accept</code>、<code>drop</code>、<code>reject</code>、<code>log</code> 等。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure></li><li><p><strong>删除规则</strong><br> 可以通过规则句柄删除：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; handle &lt;handle_number&gt;</span><br></pre></td></tr></table></figure><p> 首先列出链中的规则以找到句柄：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h4><p>假设我们要创建一个简单的防火墙配置，允许入站 SSH 连接并拒绝所有其他入站流量。</p><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table ip filter</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip filter input &#123; type filter hook input priority 0\; &#125;</span><br><span class="line">nft add chain ip filter forward &#123; type filter hook forward priority 0\; &#125;</span><br><span class="line">nft add chain ip filter output &#123; type filter hook output priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip protocol tcp tcp dport 22 accept</span><br><span class="line">nft add rule ip filter input drop</span><br></pre></td></tr></table></figure></li><li><p><strong>查看配置</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><p>这样，我们就配置了一个简单的防火墙，允许入站 SSH 连接并拒绝所有其他入站流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>列出当前规则集。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>添加规则，允许通过端口 <code>80</code> 的 TCP 连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft delete rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add table ip mytable</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>mytable</code> 的表。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; <span class="built_in">type</span> filter hook input priority 0 \; &#125;</span><br></pre></td></tr></table></figure><p>在 <code>mytable</code> 表中添加一个名为 <code>mychain</code> 的链。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain counter</span><br></pre></td></tr></table></figure><p>在 <code>mychain</code> 链中添加一个计数规则。</p><h3 id="9-curl"><a href="#9-curl" class="headerlink" title="9. curl"></a>9. <code>curl</code></h3><p><code>curl</code> 是用于传输数据的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I http://example.com</span><br></pre></td></tr></table></figure><p>获取 HTTP 响应头信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/api</span><br></pre></td></tr></table></figure><p>发送 POST 请求。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password http://example.com</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://example.com</span><br></pre></td></tr></table></figure><p>忽略 SSL 证书错误。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://example.com</span><br></pre></td></tr></table></figure><p>跟随重定向。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -C - -O http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><h3 id="10-wget"><a href="#10-wget" class="headerlink" title="10. wget"></a>10. <code>wget</code></h3><p><code>wget</code> 是另一个下载文件的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q http://example.com/file</span><br></pre></td></tr></table></figure><p>静默模式下载文件，不输出任何信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./local http://example.com</span><br></pre></td></tr></table></figure><p>递归下载整个网站，并将文件保存到 <code>./local</code> 目录中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=100k http://example.com/file</span><br></pre></td></tr></table></figure><p>限制下载速度为 <code>100kB/s</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --user=username --password=password http://example.com/file</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><h3 id="11-iptop"><a href="#11-iptop" class="headerlink" title="11. iptop"></a>11. <code>iptop</code></h3><p><code>iptop</code> 是一个实时显示网络流量的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop</span><br></pre></td></tr></table></figure><p>启动 <code>iptop</code>，显示实时网络流量。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -i eth0</span><br></pre></td></tr></table></figure><p>显示特定接口 <code>eth0</code> 的网络流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f src net 192.168.1.0/24</span><br></pre></td></tr></table></figure><p>显示来自特定子网 <code>192.168.1.0/24</code> 的流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f dst port 80</span><br></pre></td></tr></table></figure><p>显示发送到端口 <code>80</code> 的流量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-tcpdump&quot;&gt;&lt;a href=&quot;#1-tcpdump&quot; class=&quot;headerlink&quot; title=&quot;1. tcpdump&quot;&gt;&lt;/a&gt;1. &lt;code&gt;tcpdump&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; 是一个网络抓</summary>
      
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="net" scheme="https://kalyan-zitiu.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux磁盘</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/</id>
    <published>2024-07-08T08:49:36.000Z</published>
    <updated>2024-07-09T07:35:51.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="磁盘方面"><a href="#磁盘方面" class="headerlink" title="磁盘方面"></a>磁盘方面</h3><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><h5 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h5><p>在linux系统中，磁盘分区是一种物理硬盘分割成多个逻辑部分的方法，每个分区可以独立地进行管理和使用通常会分为</p><ul><li>主分区：每个磁盘最多可以有四个主分区。需要更多地分区可以使用扩展分区。</li><li>扩展分区： 扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li><li>逻辑分区： 位于扩展分区内地分区，可以超过四个限制。</li></ul><h5 id="分区职责"><a href="#分区职责" class="headerlink" title="分区职责"></a>分区职责</h5><ul><li>主分区：用于安装操作系统，存储数据，以及引导系统</li><li>扩展分区：是用于包含逻辑分区的一个容器，解决主分区的限制，创建多个逻辑分区</li><li>逻辑分区：可以用来存储操作系统，应用程序和数据。</li></ul><h5 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h5><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，包含系统中所有文件和目录的起点。</td></tr><tr><td><code>/bin</code></td><td>基本命令的二进制文件，如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等。</td></tr><tr><td><code>/boot</code></td><td>存放启动加载器相关的文件和内核文件。</td></tr><tr><td><code>/dev</code></td><td>设备文件目录，包含所有设备的接口文件（如硬盘、终端）。</td></tr><tr><td><code>/etc</code></td><td>配置文件目录，包含系统和应用程序的所有配置文件。</td></tr><tr><td><code>/home</code></td><td>用户家目录，每个用户都有一个单独的子目录，用于存放个人文件和配置。</td></tr><tr><td><code>/lib</code></td><td>系统库文件目录，包含基本系统库和内核模块。</td></tr><tr><td><code>/media</code></td><td>自动挂载的可移动媒体设备（如CD-ROM、USB驱动器）。</td></tr><tr><td><code>/mnt</code></td><td>临时挂载文件系统的挂载点。</td></tr><tr><td><code>/opt</code></td><td>可选软件包目录，用于安装附加的第三方应用程序。</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，提供系统和进程信息。</td></tr><tr><td><code>/root</code></td><td>超级用户（root）家目录。</td></tr><tr><td><code>/run</code></td><td>运行时数据，存放系统启动后产生的临时文件（如进程ID文件）。</td></tr><tr><td><code>/sbin</code></td><td>系统管理员命令的二进制文件，如 <code>fdisk</code>、<code>ifconfig</code> 等。</td></tr><tr><td><code>/srv</code></td><td>服务数据目录，存放特定服务的数据（如Web服务器文件）。</td></tr><tr><td><code>/sys</code></td><td>虚拟文件系统，提供内核设备和驱动程序信息。</td></tr><tr><td><code>/tmp</code></td><td>临时文件目录，存放临时文件，系统重启后可能会清空。</td></tr><tr><td><code>/usr</code></td><td>用户程序目录，包含二进制文件、库文件、文档等（如 <code>/usr/bin</code>、<code>/usr/lib</code>）。</td></tr><tr><td><code>/var</code></td><td>可变数据文件目录，存放日志文件、邮件、临时文件等（如 <code>/var/log</code>、<code>/var/mail</code>）。</td></tr></tbody></table><h4 id="MBR-Master-Boot-Record"><a href="#MBR-Master-Boot-Record" class="headerlink" title="MBR (Master Boot Record)"></a>MBR (Master Boot Record)</h4><ul><li>MBR是一种传统的磁盘分区表格式，它位于磁盘的第一个扇区。</li><li>MBR分区表最多支持4个主分区，如果需要更多分区，必须将其中一个主分区转换为扩展分区，再在扩展分区内创建逻辑分区。</li><li>由于使用32位地址，MBR最多支持2TB的磁盘。</li></ul><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>主引导记录 (Master Boot Record)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0）。</li><li>大小为512字节。</li></ul></li><li><p><strong>主引导代码 (Boot Code)</strong></p><ul><li>前446字节存储主引导代码，用于启动操作系统。</li></ul></li><li><p><strong>分区表 (Partition Table)</strong></p><ul><li>紧随其后64字节（每个分区条目16字节，共4个条目）。</li><li>描述最多四个主分区或一个扩展分区的起始位置和大小。</li></ul></li><li><p><strong>签名 (Signature)</strong></p><ul><li>最后2字节为磁盘签名（0x55AA），标志主引导记录的结束。</li></ul></li><li><p><strong>扩展分区</strong></p><ul><li>如果需要超过四个分区，可以创建一个扩展分区（Extended Partition）。</li><li>扩展分区包含一个扩展引导记录 (EBR)，每个逻辑分区包含一个EBR。</li></ul></li></ol><h4 id="GPT-GUID-Partition-Table"><a href="#GPT-GUID-Partition-Table" class="headerlink" title="GPT (GUID Partition Table)"></a>GPT (GUID Partition Table)</h4><ul><li>GPT是一种现代的磁盘分区表格式，取代了传统的MBR。</li><li>GPT使用64位地址，可以支持超过8ZB的磁盘容量。</li><li>GPT最多可以支持128个主分区，没有扩展分区的限制。</li><li>GPT分区表有冗余备份和CRC校验，提高了数据的安全性和可靠性。</li></ul><h5 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>保护性MBR (Protective MBR)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0），防止旧版工具误读GPT磁盘。</li></ul></li><li><p><strong>主GPT头 (Primary GPT Header)</strong></p><ul><li>位于LBA 1，描述GPT分区表的总体信息。</li><li>包含GPT版本、头部大小、CRC32校验和等。</li></ul></li><li><p><strong>主分区表 (Primary Partition Table)</strong></p><ul><li>紧随其后，从LBA 2开始，一般占用32个扇区。</li><li>每个分区条目128字节，通常最多支持128个分区条目。</li></ul></li><li><p><strong>分区条目 (Partition Entries)</strong></p><ul><li>每个条目描述一个分区的GUID、类型GUID、起始LBA、结束LBA、属性标志等。</li></ul></li><li><p><strong>用户分区</strong></p><ul><li>从主分区表结束位置开始，存储实际的数据和文件系统。</li></ul></li><li><p><strong>备份分区表 (Backup Partition Table)</strong></p><ul><li>位于磁盘末尾，用于恢复主GPT头和分区表。</li></ul></li><li><p><strong>备份GPT头 (Backup GPT Header)</strong></p><ul><li>位于磁盘倒数第二个扇区，记录备份分区表的信息。</li></ul></li></ol><h4 id="Legacy-BIOS-引导"><a href="#Legacy-BIOS-引导" class="headerlink" title="Legacy / BIOS 引导"></a>Legacy / BIOS 引导</h4><p>Legacy/BIOS（Basic Input/Output System）引导是一种传统的计算机启动模式。它是PC兼容系统的早期固件接口，负责初始化硬件并引导操作系统。以下是详细的说明：</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><p><strong>电源自检（POST）</strong>:</p><ul><li>计算机启动时，BIOS首先进行电源自检（Power-On Self-Test），检查和初始化系统硬件，如内存、CPU、硬盘和外设。</li><li>如果POST过程中检测到错误，BIOS会通过蜂鸣声或屏幕错误信息提示用户。</li></ul></li><li><p><strong>查找引导设备</strong>:</p><ul><li>POST完成后，BIOS会根据预设的引导顺序查找可启动设备（如硬盘、光盘、U盘等）。</li><li>引导顺序通常可以在BIOS设置界面中配置。</li></ul></li><li><p><strong>加载引导扇区</strong>:</p><ul><li>一旦找到一个可引导的设备，BIOS会读取该设备的主引导记录（MBR，Master Boot Record），这通常是设备的第一个扇区（512字节）。</li><li>MBR包含了启动加载程序的初始部分以及分区表信息。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>BIOS将控制权交给MBR中的引导加载程序。这个程序进一步加载操作系统或更多的引导代码（例如，GRUB、LILO等引导加载程序）。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序最终加载操作系统内核，并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="特点和限制"><a href="#特点和限制" class="headerlink" title="特点和限制"></a>特点和限制</h5><ul><li><strong>地址空间限制</strong>: BIOS模式只能使用传统的32位地址模式，无法利用超过4GB的内存空间。</li><li><strong>MBR分区限制</strong>: MBR分区表限制最大支持4个主分区，每个分区最大只能是2TB。</li><li><strong>兼容性</strong>: 由于其长期存在，BIOS模式具有广泛的硬件和软件兼容性。</li></ul><h5 id="设置和配置"><a href="#设置和配置" class="headerlink" title="设置和配置"></a>设置和配置</h5><ul><li><strong>进入BIOS设置</strong>: 通常通过在启动时按下特定的键（如F2、Del、Esc）进入BIOS设置界面。</li><li><strong>配置引导顺序</strong>: 在BIOS设置界面中，用户可以配置引导设备的优先级。</li><li><strong>启用/禁用设备</strong>: 可以在BIOS中启用或禁用某些硬件设备，以优化系统性能或解决兼容性问题。</li></ul><h4 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h4><p>UEFI（统一可扩展固件接口）是一种现代固件接口，用于替代传统的BIOS。它提供更强大的功能和更灵活的引导方式。以下是详细的UEFI启动流程和相关设置的教学：</p><h5 id="UEFI-启动流程"><a href="#UEFI-启动流程" class="headerlink" title="UEFI 启动流程"></a>UEFI 启动流程</h5><ol><li><p><strong>电源开启和硬件初始化</strong>:</p><ul><li>计算机启动时，UEFI固件首先进行硬件初始化和电源自检（POST，Power-On Self-Test）。</li><li>检查CPU、内存、存储设备和外设，确保它们工作正常。</li></ul></li><li><p><strong>进入UEFI固件界面</strong>:</p><ul><li>在启动过程中，用户可以按特定的键（如F2、Del、Esc）进入UEFI固件设置界面。</li></ul></li><li><p><strong>查找EFI系统分区（ESP）</strong>:</p><ul><li>UEFI固件会查找包含EFI系统分区（ESP）的存储设备。ESP是一个特殊的分区，用于存储EFI引导加载程序和相关文件。</li><li>ESP通常格式化为FAT32文件系统，并且标记为“EFI System Partition”。</li></ul></li><li><p><strong>加载EFI引导加载程序</strong>:</p><ul><li>在ESP中，UEFI固件查找引导加载程序文件，通常位于 <code>\EFI\Boot\bootx64.efi</code>（对于64位系统）。</li><li>用户可以在UEFI设置中指定特定的引导加载程序路径或更改引导顺序。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>UEFI将控制权交给引导加载程序。这个程序进一步加载操作系统的引导程序或内核。</li><li>常见的引导加载程序包括Windows Boot Manager、GRUB、Clover等。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序加载操作系统内核并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="设置和配置UEFI"><a href="#设置和配置UEFI" class="headerlink" title="设置和配置UEFI"></a>设置和配置UEFI</h5><ol><li><p><strong>进入UEFI设置界面</strong>:</p><ul><li>重启计算机，在启动过程中按下特定的键（如F2、Del、Esc）进入UEFI设置界面。</li><li>不同品牌的主板可能有不同的按键，具体请参考主板或计算机手册。</li></ul></li><li><p><strong>配置引导顺序</strong>:</p><ul><li>在UEFI设置界面中，找到“Boot”或“启动”选项卡。</li><li>配置引导设备的优先级，将希望首先引导的设备设置为第一优先级。</li><li>如果需要从特定的EFI引导文件启动，可以手动指定路径。</li></ul></li><li><p><strong>启用/禁用设备</strong>:</p><ul><li>在“Advanced”或“高级”选项卡中，可以启用或禁用某些硬件设备。</li><li>例如，启用/禁用USB端口、网卡、SATA接口等。</li></ul></li><li><p><strong>安全启动（Secure Boot）</strong>:</p><ul><li>安全启动是一项UEFI功能，用于防止加载未签名或未经授权的操作系统引导程序。</li><li>在“Security”或“安全”选项卡中，可以启用或禁用安全启动。</li><li>如果需要安装非官方签名的操作系统，可能需要暂时禁用安全启动。</li></ul></li><li><p><strong>保存和退出</strong>:</p><ul><li>完成设置后，选择“Save &amp; Exit”或“保存并退出”选项。</li><li>保存设置后，系统将重新启动并应用新的设置。</li></ul></li></ol><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p><code>sar</code>（System Activity Reporter）是一个强大的工具，用于在Linux系统上收集、报告和保存系统活动信息。它可以提供有关系统性能的详细数据，包括CPU、内存、网络、磁盘I/O等多个方面。<code>sar</code>命令通常与<code>sysstat</code>软件包一起使用。下面是如何使用<code>sar</code>命令来监控磁盘活动的步骤：</p><h5 id="安装sysstat包"><a href="#安装sysstat包" class="headerlink" title="安装sysstat包"></a>安装sysstat包</h5><p>在大多数Linux发行版中，可以通过包管理器安装<code>sysstat</code>包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于基于Debian的系统（如Ubuntu）</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于基于RHEL的系统（如CentOS）</span></span><br><span class="line">sudo yum install sysstat</span><br></pre></td></tr></table></figure><h5 id="启用和配置sysstat"><a href="#启用和配置sysstat" class="headerlink" title="启用和配置sysstat"></a>启用和配置sysstat</h5><p>安装完成后，确保<code>sysstat</code>服务已启用并正在运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用sysstat服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sysstat</span><br><span class="line">sudo systemctl start sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置sysstat以启用数据收集</span></span><br><span class="line">sudo nano /etc/default/sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ENABLED=&quot;false&quot;修改为ENABLED=&quot;true&quot;</span></span><br><span class="line">ENABLED=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存并退出编辑器</span></span><br></pre></td></tr></table></figure><h5 id="使用sar监控磁盘I-O"><a href="#使用sar监控磁盘I-O" class="headerlink" title="使用sar监控磁盘I/O"></a>使用sar监控磁盘I/O</h5><p><code>sar</code>可以通过<code>-d</code>选项来监控磁盘I/O活动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实时监控磁盘I/O，每1秒报告一次，共报告10次</span></span><br><span class="line">sar -d 1 10</span><br></pre></td></tr></table></figure><h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><ul><li><code>-d</code>：报告磁盘I/O统计信息。</li><li><code>-p</code>：将设备名称从设备编号翻译为设备名称。</li><li><code>-r</code>：报告内存和交换空间使用情况。</li><li><code>-n</code>：报告网络统计信息（如<code>-n DEV</code>报告网络接口统计信息）。</li><li><code>-u</code>：报告CPU使用情况。</li></ul><h5 id="查看历史数据"><a href="#查看历史数据" class="headerlink" title="查看历史数据"></a>查看历史数据</h5><p><code>sar</code>命令可以查看过去的系统性能数据，这些数据通常保存在<code>/var/log/sa/</code>目录中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定日期的磁盘I/O活动（例如2024年7月5日）</span></span><br><span class="line">sar -d -f /var/log/sa/sa05</span><br></pre></td></tr></table></figure><h5 id="示例输出解读"><a href="#示例输出解读" class="headerlink" title="示例输出解读"></a>示例输出解读</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709151241420.png" alt="image-20240709151241420"></p><p>以下是<code>sar -d</code>命令的示例输出及其含义：</p><ul><li><code>tps</code>：每秒传输数（读+写）。</li><li><code>rd_sec/s</code>：每秒读取的扇区数。</li><li><code>wr_sec/s</code>：每秒写入的扇区数。</li><li><code>avgrq-sz</code>：平均请求大小（扇区）。</li><li><code>avgqu-sz</code>：平均请求队列长度。</li><li><code>await</code>：每个I/O操作的平均等待时间（毫秒）。</li><li><code>svctm</code>：每个I/O操作的平均服务时间（毫秒）。</li><li><code>%util</code>：设备的I/O使用百分比。</li></ul><p>使用<code>sar</code>工具可以帮助系统管理员深入了解系统性能瓶颈并进行相应的优化。</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID（Redundant Array of Independent Disks，即独立磁盘冗余阵列）是一种将多个物理硬盘驱动器组合成一个逻辑单元的存储技术。其主要目的是提高数据存储的性能、容量和可靠性。RAID技术通过不同的配置（称为RAID级别）来实现这些目标。以下是几种常见的RAID级别：</p><ol><li><p><strong>RAID 0</strong>：</p><ul><li><strong>条带化（Striping）</strong>：数据在多个磁盘上分割并并行写入。</li><li><strong>优点</strong>：提高读写速度。</li><li><strong>缺点</strong>：没有冗余，任何一个磁盘故障都会导致数据丢失。</li></ul></li><li><p><strong>RAID 1</strong>：</p><ul><li><strong>镜像（Mirroring）</strong>：每个数据块都在两个或多个磁盘上复制。</li><li><strong>优点</strong>：提供高冗余，数据安全性高。</li><li><strong>缺点</strong>：磁盘利用率低（50%），只使用了一半的存储容量。</li></ul></li><li><p><strong>RAID 5</strong>：</p><ul><li><strong>分布式奇偶校验（Distributed Parity）</strong>：数据和奇偶校验信息分布在所有磁盘上。</li><li><strong>优点</strong>：平衡了性能、容量和数据安全性，至少需要3个磁盘。</li><li><strong>缺点</strong>：写操作较慢，因为需要计算和写入奇偶校验数据。</li></ul></li><li><p><strong>RAID 6</strong>：</p><ul><li><strong>双奇偶校验（Double Parity）</strong>：类似RAID 5，但有两组奇偶校验数据，容忍两块磁盘同时故障。</li><li><strong>优点</strong>：更高的数据安全性。</li><li><strong>缺点</strong>：写操作更慢，磁盘利用率较低。</li></ul></li><li><p><strong>RAID 10（或1+0）</strong>：</p><ul><li><strong>条带化和镜像结合</strong>：先进行镜像，再进行条带化。</li><li><strong>优点</strong>：结合了RAID 0和RAID 1的优点，高性能和高冗余。</li><li><strong>缺点</strong>：需要较多的磁盘，成本较高。</li></ul></li><li><p><strong>RAID 50（或5+0）</strong>：</p><ul><li><strong>条带化和分布式奇偶校验结合</strong>：将RAID 5阵列条带化。</li><li><strong>优点</strong>：提高了性能和冗余，适合大规模存储需求。</li><li><strong>缺点</strong>：复杂度增加，需要更多磁盘。</li></ul></li></ol><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 MBR 分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>m</td><td>显示帮助菜单</td><td>显示所有可用命令的列表和简要说明。</td></tr><tr><td>p</td><td>显示当前分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>n</td><td>添加一个新分区</td><td>根据提示选择主分区或逻辑分区，并设置分区的开始和结束位置。</td></tr><tr><td>d</td><td>删除一个分区</td><td>选择要删除的分区编号。</td></tr><tr><td>l</td><td>列出已知分区类型</td><td>显示支持的所有分区类型代码和说明。</td></tr><tr><td>t</td><td>更改一个分区的系统ID</td><td>选择分区后，输入新的类型代码。</td></tr><tr><td>a</td><td>切换启动标志</td><td>设置或取消某个分区的启动标志（使其可引导）。</td></tr><tr><td>w</td><td>写入分区表并退出</td><td>将对分区所做的更改写入磁盘，并退出fdisk。</td></tr><tr><td>q</td><td>不保存更改并退出</td><td>退出fdisk而不保存对分区表的任何更改。</td></tr></tbody></table><h5 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h5><ol><li>输入<code>n</code>创建新分区。</li><li>选择分区类型（主分区<code>p</code>或逻辑分区<code>e</code>）。</li><li>指定分区号（例如<code>1</code>）。</li><li>指定分区的起始扇区和结束扇区。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h5><ol><li>输入<code>p</code>查看当前分区表。</li><li>输入<code>d</code>删除分区。</li><li>输入要删除的分区编号（例如<code>1</code>）。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="更改分区类型"><a href="#更改分区类型" class="headerlink" title="更改分区类型"></a>更改分区类型</h5><ol><li>输入<code>t</code>更改分区类型。</li><li>输入分区编号（例如<code>1</code>）。</li><li>输入新的类型代码（例如<code>83</code>用于Linux分区）。</li><li>输入<code>w</code>保存并退出。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709125834777.png" alt="image-20240709125834777"></p><h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 GPT分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>mklabel</td><td>创建新的磁盘标签（分区表）</td><td>格式：<code>mklabel &lt;label&gt;</code>，其中<code>label</code>可以是<code>gpt</code>、<code>msdos</code>等。</td></tr><tr><td>mkpart</td><td>创建新分区</td><td>格式：<code>mkpart &lt;part-type&gt; &lt;fs-type&gt; &lt;start&gt; &lt;end&gt;</code>，例如<code>mkpart primary ext4 1MiB 500MiB</code>。</td></tr><tr><td>rm</td><td>删除分区</td><td>格式：<code>rm &lt;number&gt;</code>，其中<code>number</code>是分区编号。</td></tr><tr><td>print</td><td>显示分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>name</td><td>给分区命名</td><td>格式：<code>name &lt;number&gt; &lt;name&gt;</code>，给指定编号的分区命名。</td></tr><tr><td>set</td><td>设置分区标志</td><td>格式：`set <number> <flag> &lt;on</td></tr><tr><td>resizepart</td><td>调整分区大小</td><td>格式：<code>resizepart &lt;number&gt; &lt;end&gt;</code>，将分区调整到新的结束位置。</td></tr><tr><td>move</td><td>移动分区</td><td>格式：<code>move &lt;number&gt; &lt;start&gt; &lt;end&gt;</code>，移动分区到新的位置。</td></tr><tr><td>mkfs</td><td>创建文件系统</td><td>格式：<code>mkfs &lt;number&gt; &lt;fs-type&gt;</code>，例如<code>mkfs 1 ext4</code>。</td></tr><tr><td>align-check</td><td>检查分区对齐</td><td>格式：<code>align-check &lt;opt&gt; &lt;number&gt;</code>，例如<code>align-check optimal 1</code>。</td></tr><tr><td>rescue</td><td>尝试恢复丢失的分区</td><td>格式：<code>rescue &lt;start&gt; &lt;end&gt;</code>，尝试在指定范围内恢复分区。</td></tr><tr><td>quit</td><td>退出parted</td><td>退出parted交互模式。</td></tr><tr><td>unit</td><td>设置显示单位</td><td>格式：<code>unit &lt;unit&gt;</code>，其中<code>unit</code>可以是<code>s</code>(扇区)、<code>MB</code>、<code>GB</code>等。</td></tr></tbody></table><h5 id="启动parted"><a href="#启动parted" class="headerlink" title="启动parted"></a>启动parted</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo parted /dev/sdb</span><br></pre></td></tr></table></figure><h5 id="创建新的分区表（GPT）"><a href="#创建新的分区表（GPT）" class="headerlink" title="创建新的分区表（GPT）"></a>创建新的分区表（GPT）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br></pre></td></tr></table></figure><h5 id="创建新分区-1"><a href="#创建新分区-1" class="headerlink" title="创建新分区"></a>创建新分区</h5><p>创建一个从1MiB开始，500MiB结束的主分区，文件系统类型为ext4：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br></pre></td></tr></table></figure><h5 id="删除分区-1"><a href="#删除分区-1" class="headerlink" title="删除分区"></a>删除分区</h5><p>删除刚才创建的第一个分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">rm</span> 1</span><br></pre></td></tr></table></figure><h5 id="调整分区大小"><a href="#调整分区大小" class="headerlink" title="调整分区大小"></a>调整分区大小</h5><p>假设重新创建了一个分区，现在调整其大小到1000MiB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br><span class="line">(parted) resizepart 1 1000MiB</span><br></pre></td></tr></table></figure><h5 id="设置分区标志"><a href="#设置分区标志" class="headerlink" title="设置分区标志"></a>设置分区标志</h5><p>设置第一个分区的启动标志：</p><p>可设置的标识有：</p><p><code>boot</code>：引导分区</p><p><code>esp</code>：EFI系统分区（通常用于UEFI引导）</p><p><code>lvm</code>：逻辑卷管理</p><p><code>raid</code>：RAID分区</p><p><code>swap</code>：交换分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">set</span> &lt;分区编号&gt; &lt;标识&gt; on</span><br></pre></td></tr></table></figure><h5 id="显示分区表"><a href="#显示分区表" class="headerlink" title="显示分区表"></a>显示分区表</h5><p>显示当前的分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h5 id="给分区命名"><a href="#给分区命名" class="headerlink" title="给分区命名"></a>给分区命名</h5><p>给第一个分区命名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) name 1 my_partition</span><br></pre></td></tr></table></figure><h5 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h5><p>在第一个分区上创建ext4文件系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkfs 1 ext4</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><ol><li><p><strong>ext4</strong>：</p><ul><li>目前最广泛使用的Linux文件系统，ext4具有良好的性能、稳定性和兼容性，支持大文件和大容量存储，适用于大多数应用场景。</li></ul></li><li><p><strong>XFS</strong>：</p><ul><li>XFS是一个高性能的日志文件系统，擅长处理大文件和高并发环境，常用于需要高性能和可扩展性的服务器和存储系统。</li></ul></li><li><p><strong>Btrfs</strong>：</p><ul><li>Btrfs（B-tree FS）支持快照、压缩、多设备存储池、在线文件系统检查和修复等高级功能，适用于需要高级数据管理和灵活性的环境。</li></ul></li><li><p>**ZFS on Linux (ZoL)**：</p><ul><li>ZFS具有高度的数据完整性、快照和复制等高级特性，适用于高存储要求的环境，如服务器和大型存储系统。</li></ul></li></ol><h5 id="检查分区对齐"><a href="#检查分区对齐" class="headerlink" title="检查分区对齐"></a>检查分区对齐</h5><p>检查第一个分区的对齐情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) align-check optimal 1</span><br></pre></td></tr></table></figure><h5 id="尝试恢复丢失的分区"><a href="#尝试恢复丢失的分区" class="headerlink" title="尝试恢复丢失的分区"></a>尝试恢复丢失的分区</h5><p>假设分区丢失，尝试在指定范围内恢复分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) rescue 1MiB 1000MiB</span><br></pre></td></tr></table></figure><h5 id="退出parted"><a href="#退出parted" class="headerlink" title="退出parted"></a>退出parted</h5><p>退出parted：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) quit</span><br></pre></td></tr></table></figure><h5 id="验证操作"><a href="#验证操作" class="headerlink" title="验证操作"></a>验证操作</h5><p>为了验证这些操作，可以使用<code>lsblk</code>或<code>fdisk -l</code>来查看分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsblk</span><br><span class="line">sudo fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure><p>系统中没有parted工具，可以通过以下命令安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install parted  <span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo yum install parted      <span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo dnf install parted      <span class="comment"># Fedora</span></span><br></pre></td></tr></table></figure><h4 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h4><p>LVM 是一种逻辑卷管理器，允许对硬盘和其他存储设备进行灵活的分区管理。</p><p>ps: 逻辑卷是由LVM创建和管理的虚拟存储单元，可以跨越多个物理磁盘或分区。逻辑卷是建立在物理卷之上，物理卷可以是整个磁盘分区或RAID设备。</p><h5 id="为什么要用到LVM"><a href="#为什么要用到LVM" class="headerlink" title="为什么要用到LVM"></a>为什么要用到LVM</h5><p>有工具就是因为有需求，传统的分区因为固定分区大小，需要停机调整分区，影响服务可用。所以需要用到LVM，在线扩展逻辑卷的大小无需停机，只需要添加新的物理硬盘到卷组（VG）中，然后扩展逻辑卷（LV）大小。除此之外，还能够快速创建备份，不需要传统的长时间锁定数据库，还能够整合多个磁盘设备成为一个存储池，能够在数据迁移阶段，避免长时间停机。</p><h5 id="怎么查看逻辑卷"><a href="#怎么查看逻辑卷" class="headerlink" title="怎么查看逻辑卷"></a>怎么查看逻辑卷</h5><h6 id="了解大概的可用块设备"><a href="#了解大概的可用块设备" class="headerlink" title="了解大概的可用块设备"></a>了解大概的可用块设备</h6><p>这张图片显示了<code>lsblk</code>命令的输出，列出了系统中的所有块设备及其挂载点。以下是对这张图片的详细描述：</p><ol><li><p><strong>loop设备</strong>：</p><ul><li><strong>loop0</strong>: 111.9M, 类型为loop，挂载在<code>/snap/lxd/24322</code></li><li><strong>loop1</strong>: 87M, 类型为loop，挂载在<code>/snap/lxd/28373</code></li><li><strong>loop2</strong>: 53.3M, 类型为loop，挂载在<code>/snap/snapd/19457</code></li><li><strong>loop3</strong>: 38.8M, 类型为loop，挂载在<code>/snap/core20/1974</code></li><li><strong>loop4</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2318</code></li><li><strong>loop5</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2456</code></li></ul></li><li><p><strong>物理磁盘</strong>：</p><ul><li><p>sda</p><p>: 25G, 类型为disk</p><ul><li><strong>sda1</strong>: 1M, 类型为part，没有挂载点（这可能是BIOS引导分区或其他用途的特殊分区）</li><li><strong>sda2</strong>: 2G, 类型为part，挂载在<code>/boot</code></li><li><strong>sda3</strong>: 23G, 类型为part，没有挂载点（这可能是LVM物理卷）</li></ul></li></ul></li><li><p><strong>逻辑卷管理器（LVM）</strong>：</p><ul><li><strong>ubuntu–vg-ubuntu–lv</strong>: 12.5G, 类型为lvm，挂载在<code>/</code></li></ul></li><li><p><strong>光驱设备</strong>：</p><ul><li><strong>sr0</strong>: 2G, 类型为rom，没有挂载点</li></ul></li><li></li></ol><ul><li><p><strong>loop设备</strong>：这些是虚拟设备，通常用于挂载磁盘映像文件。</p></li><li><p>sda</p><p>：这是系统中的一个物理磁盘，包含三个分区（sda1, sda2, sda3）。</p><ul><li><strong>sda1</strong>：非常小，只有1M，通常用于系统引导或其他特殊用途。</li><li><strong>sda2</strong>：挂载在<code>/boot</code>，通常用于存放启动加载程序和内核。</li><li><strong>sda3</strong>：较大，为23G，可能用于LVM管理。</li></ul></li><li><p><strong>LVM逻辑卷</strong>：<code>ubuntu--vg-ubuntu--lv</code>是一个逻辑卷，挂载在根目录<code>/</code>。这表示LVM在管理这个分区的存储。</p></li><li><p><strong>光驱设备（sr0）</strong>：显示为2G，未挂载。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709110545123.png" alt="image-20240709110545123"></p><h6 id="扩展逻辑卷大概步骤"><a href="#扩展逻辑卷大概步骤" class="headerlink" title="扩展逻辑卷大概步骤"></a>扩展逻辑卷大概步骤</h6><ol><li>添加新物理硬盘</li><li>将新的物理硬盘初始化为物理卷(PV)</li><li>将PV添加到现在的卷组VG</li><li>扩展逻辑卷LV的大小</li></ol><ul><li><strong>示例</strong>: 创建一个逻辑卷</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建物理卷</span></span><br><span class="line">pvcreate /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建卷组</span></span><br><span class="line">vgcreate myvg /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建逻辑卷</span></span><br><span class="line">lvcreate -L 10G -n mylv myvg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化逻辑卷</span></span><br><span class="line">mkfs.ext4 /dev/myvg/mylv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载点</span></span><br><span class="line">mkdir /mnt/kalyantest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载载目录上（ps：一个逻辑卷只能挂载一个目录）</span></span><br><span class="line">mount /mnt/kalyantest</span><br></pre></td></tr></table></figure><h6 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h6><p>创建lvm分区以及扩容</p><ol><li>首先增加物理盘<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114035255.png" alt="image-20240709114035255"></li><li>然后查询存储块</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114244596.png" alt="image-20240709114244596"></p><ol start="3"><li>为物理盘建立分区</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114615916.png" alt="image-20240709114615916"></p><ol start="4"><li>创建PV，VG，LV</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115109564.png" alt="image-20240709115109564"></p><ol start="5"><li>格式化lv<pre><code>![image-20240709115309348](https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115309348.png)</code></pre></li><li>创建挂载目录（也可挂载在你想挂载的地方），并进行挂载(ps:记得修改etc/fstab文件，不然重启会丢失mount点)</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115612877.png" alt="image-20240709115612877"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;磁盘方面&quot;&gt;&lt;a href=&quot;#磁盘方面&quot; class=&quot;headerlink&quot; title=&quot;磁盘方面&quot;&gt;&lt;/a&gt;磁盘方面&lt;/h3&gt;&lt;h4 id=&quot;磁盘分区&quot;&gt;&lt;a href=&quot;#磁盘分区&quot; class=&quot;headerlink&quot; title=&quot;磁盘分区&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="linux" scheme="https://kalyan-zitiu.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://kalyan-zitiu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Blog脚本编写</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2024-07-07T03:03:50.000Z</published>
    <updated>2024-07-07T03:34:02.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺好的，公司的前辈们挺有趣的，而且感觉在这里努力下去会有收获的感觉。回到正题，因为运维实习的原因，在正式上岗工作之前都会有一段培训，所以写博客的机会就变多了，因为我的博客框架原因，我每次写博客都需要处理一下页头的一些参数，而且需要用git进行仓库上传，这些重复的工作有点繁琐，所以打算写两个脚本来处理一下。</p><h2 id="页头处理"><a href="#页头处理" class="headerlink" title="页头处理"></a>页头处理</h2><p> 我的页头格式是这样的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707111114634.png" alt="image-20240707111114634"></p><h3 id="模块确定"><a href="#模块确定" class="headerlink" title="模块确定"></a>模块确定</h3><p>基本涉及到一些题目，时间，分类，标签，图片，作者之类的，有时候还会涉及到是否加密等。所以第一时间需要考虑的是，这个脚本需要能够获取时间，其次要能够快捷输入题目，标签以及分类和用的图片序号，所以需要GUI，然后还需要能够处理文件系统。故基本能够确定三个模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime  <span class="comment"># 导入datetime模块，用于处理日期和时间</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  <span class="comment"># 从pathlib导入Path，用于处理文件系统路径</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 导入tkinter，用于创建GUI应用程序</span></span><br></pre></td></tr></table></figure><h3 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h3><p>然后就可以开始写专门用来生成头部的函数，根据一些页头的结构和格式，进行编写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_markdown_header</span>(<span class="params">title, categories, tags, wallpaper_index</span>):</span><br><span class="line">    now = datetime.datetime.now()  <span class="comment"># 获取当前日期和时间</span></span><br><span class="line">    date_str = now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="comment"># 将日期和时间格式化为字符串</span></span><br><span class="line">    author = <span class="string">&quot;Kalyan&quot;</span>  <span class="comment"># 作者名称</span></span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的类别项字符串</span></span><br><span class="line">    categories_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;cat.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> cat <span class="keyword">in</span> categories.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的标签项字符串</span></span><br><span class="line">    tags_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;tag.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> tag <span class="keyword">in</span> tags.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 使用提供的信息构建完整的Markdown头部</span></span><br><span class="line">    markdown_header = <span class="string">f&quot;&quot;&quot;---</span></span><br><span class="line"><span class="string">title: <span class="subst">&#123;title&#125;</span></span></span><br><span class="line"><span class="string">date: <span class="subst">&#123;date_str&#125;</span></span></span><br><span class="line"><span class="string">categories:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;categories_str&#125;</span></span></span><br><span class="line"><span class="string">tags:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;tags_str&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">description: </span></span><br><span class="line"><span class="string">top_img: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">cover: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">copyright_author: <span class="subst">&#123;author&#125;</span></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> markdown_header  <span class="comment"># 返回构建的Markdown头部</span></span><br></pre></td></tr></table></figure><h3 id="GUI事件处理"><a href="#GUI事件处理" class="headerlink" title="GUI事件处理"></a>GUI事件处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理GUI中提交按钮点击的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_submit</span>():</span><br><span class="line">    title = title_entry.get()  <span class="comment"># 从文本输入小部件获取标题</span></span><br><span class="line">    categories = categories_entry.get()  <span class="comment"># 从文本输入小部件获取类别</span></span><br><span class="line">    tags = tags_entry.get()  <span class="comment"># 从文本输入小部件获取标签</span></span><br><span class="line">    wallpaper_index = wallpaper_entry.get()  <span class="comment"># 从文本输入小部件获取壁纸序号</span></span><br><span class="line">    header = generate_markdown_header(title, categories, tags, wallpaper_index)  <span class="comment"># 生成Markdown头部</span></span><br><span class="line">    desktop = Path.home() / <span class="string">&#x27;Desktop&#x27;</span>  <span class="comment"># 获取桌面路径</span></span><br><span class="line">    file_name = title.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.md&quot;</span>  <span class="comment"># 创建文件名</span></span><br><span class="line">    full_path = desktop / file_name  <span class="comment"># 完整的文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(full_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 打开文件进行写入</span></span><br><span class="line">        f.write(header)  <span class="comment"># 写入Markdown头部</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件已保存在桌面: <span class="subst">&#123;full_path&#125;</span>&quot;</span>)  <span class="comment"># 打印文件保存位置</span></span><br><span class="line"></span><br><span class="line">    root.destroy()  <span class="comment"># 关闭GUI</span></span><br></pre></td></tr></table></figure><h3 id="窗口UI调整"><a href="#窗口UI调整" class="headerlink" title="窗口UI调整"></a>窗口UI调整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = tk.Tk()</span><br><span class="line">root.title(<span class="string">&quot;文章信息输入&quot;</span>)  <span class="comment"># 设置窗口标题</span></span><br><span class="line">root.geometry(<span class="string">&quot;400x200&quot;</span>)  <span class="comment"># 设置窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并放置各种标签和输入框</span></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;文章标题:&quot;</span>).pack()</span><br><span class="line">title_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">title_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;分类（用逗号分隔）-&quot;</span>).pack()</span><br><span class="line">categories_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">categories_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;标签（用逗号分隔）:&quot;</span>).pack()</span><br><span class="line">tags_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">tags_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;壁纸序号:&quot;</span>).pack()</span><br><span class="line">wallpaper_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">wallpaper_entry.pack()</span><br><span class="line"></span><br><span class="line">submit_button = tk.Button(root, text=<span class="string">&quot;提交&quot;</span>, command=on_submit)  <span class="comment"># 创建提交按钮</span></span><br><span class="line">submit_button.pack()</span><br><span class="line"></span><br><span class="line">root.mainloop()  <span class="comment"># 启动GUI事件循环</span></span><br></pre></td></tr></table></figure><p>以上搞定，然后就是打包创建可执行文件就好了。感觉还不错。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112220421.png" alt="image-20240707112220421"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112235909.png" alt="image-20240707112235909"></p><h2 id="上传处理"><a href="#上传处理" class="headerlink" title="上传处理"></a>上传处理</h2><p>这次并用不上写python脚本，只需要用批处理就好了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112640400.png" alt="image-20240707112640400"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺</summary>
      
    
    
    
    <category term="python" scheme="https://kalyan-zitiu.github.io/categories/python/"/>
    
    
    <category term="脚本" scheme="https://kalyan-zitiu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>VMware vSphere</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/07/VMware%20vSphere/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/07/VMware%20vSphere/</id>
    <published>2024-07-07T03:01:04.000Z</published>
    <updated>2024-07-08T02:36:43.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是vmware官方开发的一套虚拟化平台</p><h2 id="能够干什么"><a href="#能够干什么" class="headerlink" title="能够干什么"></a>能够干什么</h2><ol><li>虚拟化：将物理服务器的资源分配给多个VM，提高硬件资源利用率，减少硬件成本。</li><li>集中管理：统一管理监控整个虚拟化环境，包括虚拟机，主机，网络和存储</li><li>高可用提供：能够自动重启故障的物理服务器，保持业务连续。</li><li>资源优化：提供分布式资源调度DRS功能，动态调整VM资源，性能和负载</li><li>安全：能够网络隔离，访问控制，数据加密</li><li>数据保护：提供快照和备份，支持快速恢复</li><li>自动化和编排，通过脚本和工具实现虚拟机的快速部署。</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="ESXi"><a href="#ESXi" class="headerlink" title="ESXi"></a>ESXi</h3><p>是VMware vSphere虚拟化平台的核心组件。它是一种小型的、专用的操作系统，直接安装在物理服务器上，用于运行和管理虚拟机（VM）。可以说有ESXi的OS的物理服务器就是宿主机Host。</p><h3 id="vSwitch"><a href="#vSwitch" class="headerlink" title="vSwitch"></a>vSwitch</h3><p>运行在VMware ESXi主机上的软件交换机，用于管理虚拟网络。它类似于物理交换机，但功能更灵活，能够在虚拟化环境中提供网络连接和管理。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>网络连接：提供VM之间的网络连接，以及虚拟机与外部物理网络的连接。</p></li><li><p>流量隔离和管理：通过VLAN（虚拟局域网）标签，vSwitch可以隔离和管理不同虚拟机的网络流量，提高网络安全性和性能。</p></li><li><p>网络适配器绑定：vSwitch支持将多个物理网络适配器（NIC）绑定在一起，提供冗余和负载均衡，提高网络的可用性和带宽。</p></li></ol><p>ps: NIC即网络接口卡，是计算机硬件组件，用于计算机与网络的连接。它通常以插卡形式存在，插入计算机主板的扩展槽中，也有集成在主板上的形式。</p><ol start="4"><li><p>流量整形：vSwitch能够对进出网络流量进行整形（Traffic Shaping），控制流量速率，确保网络性能的稳定性。</p></li><li><p>安全特性：vSwitch具备安全特性，如防止MAC地址欺骗和IP地址欺骗，提升虚拟网络的安全性。 </p></li></ol><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="标准虚拟交换机（vSS）"><a href="#标准虚拟交换机（vSS）" class="headerlink" title="标准虚拟交换机（vSS）"></a>标准虚拟交换机（vSS）</h5><ul><li>独立管理：每台ESXi主机上的vSS独立管理，不同主机上的vSS配置相互独立</li><li>本地主机管理：配置和管理通过ESXi主机的Host Client或vSphere Clinet进行。</li><li>手动配置：手动为每个ESXi主机上分别配置，配置工作量大。</li><li>适用小型环境：适合规模较小或独立的环境，网络配置相对简单<br>ps：缺乏跨主机的集中管理和高级网络功能。</li></ul><h5 id="分布式虚拟交换机（vDS）"><a href="#分布式虚拟交换机（vDS）" class="headerlink" title="分布式虚拟交换机（vDS）"></a>分布式虚拟交换机（vDS）</h5><ul><li>集中管理：能够跨多个ESXi主机统一配置管理</li><li>视图统一：提供网络配置视图，简化大规模环境中的网络管理。</li><li>集中配置：可以在vCenter Server中一次性配置和管理所有相关ESXi主机上的网络设备</li><li>适用于大环境：适合规模大，复杂的，网络配置需求高的。</li></ul><p>ps：拥有比较高级的功能，入Private VLAN，网络IO控制（NetIOC），分布式端口镜像（Port Mirroring）/简化迁移能够网络配置一起迁移，无需重新配置。</p><h5 id="VLAN-和Private-VALN"><a href="#VLAN-和Private-VALN" class="headerlink" title="VLAN 和Private VALN"></a>VLAN 和Private VALN</h5><ol><li>VLAN: </li></ol><ul><li>主要通过交换机端口配置，将交换机端口分到不同的VLAN中。每个VLAN都有唯一的VLAN ID</li><li>设备之间通信得在同一VLAN进行，不同VLAN之间通信需要通过三层设备（如路由器，三层交换机）</li></ul><ol start="2"><li>Private VLAN</li></ol><ul><li>进一步细分VLAN内部的子VLAN，从而提供更精细的流量隔离和控制。</li><li>避免VLAN ID的浪费，适合大规模网络环境。</li></ul><h6 id="Private实现"><a href="#Private实现" class="headerlink" title="Private实现"></a>Private实现</h6><ol><li>Private VLAN将一个VLAN划分为主VLAN（Primary VLAN）和子VLAN（Secondary VLAN）。子VLAN又分为两种类型：Isolated VLAN和Community VLAN。</li></ol><ul><li>Primary VLAN：主VLAN，包含所有的Secondary VLAN。</li><li>Isolated VLAN：隔离VLAN，主机只能与Promiscuous端口通信，不能与其他任何端口通信。</li><li>Community VLAN：社区VLAN，主机可以与同一个Community VLAN内的其他主机和Promiscuous端口通信，但不能与其他Community VLAN或Isolated VLAN内的主机通信。</li><li>Promiscuous端口：可以与所有子VLAN内的端口通信，通常用于连接网关或路由器等设备。</li></ul><h5 id="vDS和vSS的区别"><a href="#vDS和vSS的区别" class="headerlink" title="vDS和vSS的区别"></a>vDS和vSS的区别</h5><p>管理上，vSS独立管理（每个ESXi独立配置），vDS集中管理（跨多个ESXi主机统一配置）<br>功能上，vSS网络配置简单，vDS提供高级网络功能。</p><h3 id="Datastore"><a href="#Datastore" class="headerlink" title="Datastore"></a>Datastore</h3><ul><li>Datastore是一个逻辑存储单元，由ESXi主机创建和管理。</li><li>它可以基于不同类型的物理存储，如本地硬盘、NFS共享、iSCSI目标和SAN存储。</li><li>Datastore用于存储虚拟机的虚拟磁盘文件（.vmdk）、配置文件（.vmx）、ISO映像文件以及其他虚拟机相关的数据。</li></ul><h4 id="数据存储类型及其特点"><a href="#数据存储类型及其特点" class="headerlink" title="数据存储类型及其特点"></a>数据存储类型及其特点</h4><ol><li>本地</li></ol><ul><li>直接连接单个ESXi主机的存储设备，SATA，SAS，SSD硬盘</li></ul><ol start="2"><li>SAN（Storage Area Network）</li></ol><ul><li>高性能，低延迟的存储网络，通常使用光纤通道或iSCSI协议连接</li><li>提供集中管理和共享存储</li></ul><ol start="3"><li>NAS（Network Attached Storage）</li></ol><ul><li>通过标准网络协议（IFS或SMB）访问存储设备</li><li>适用于文件级存储需求</li></ul><ol start="4"><li>vSAN（Virtual SAN）</li></ol><ul><li>VM的分布式存储解决方案，集群中所有ESXi主机的本地存储集合成一个逻辑数据存储。</li><li>提供高性能，可扩展共享存储，支持高可用性。</li></ul><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><ul><li>VMFS： 块存储，如SAN和本地存储。</li><li>NFS：网络附加存储如NAS。</li><li>vSAN:分布式存储解决方案。</li></ul><h3 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h3><p>用于管理和分配计算资源（如CPU和内存）。</p><h4 id="资源池的关键特性"><a href="#资源池的关键特性" class="headerlink" title="资源池的关键特性"></a>资源池的关键特性</h4><ol><li><strong>资源分配</strong>：<ul><li><strong>预留（Reservation）</strong>：确保虚拟机或资源池可以使用的最小资源量。预留的资源保证在所有者需要时始终可用。</li><li><strong>限制（Limit）</strong>：资源池或虚拟机可以使用的最大资源量。限制防止单个实体使用过多资源，影响其他实体的性能。</li><li><strong>份额（Shares）</strong>：定义资源争用时的相对优先级。份额是一个权重，用于确定在资源紧张时各个虚拟机或资源池的优先级。</li></ul></li><li><strong>灵活的资源管理</strong>：<ul><li>动态调整资源：管理员可以在不影响虚拟机运行的情况下动态调整资源池的配置。</li><li>自动化资源分配：配合VMware的DRS（分布式资源调度），可以自动平衡资源池之间的负载。</li></ul></li><li><strong>资源池的层次结构</strong>：<ul><li><strong>根资源池（Root Resource Pool）</strong>：默认存在于每个主机或集群中，是最顶层的资源池。</li><li><strong>子资源池（Child Resource Pool）</strong>：创建在根资源池或其他资源池下，形成树状结构。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;是vmware官方开发的一套虚拟化平台&lt;/p&gt;
&lt;h2 id=&quot;能够干什么&quot;&gt;&lt;a href=&quot;#能够干什么&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="VMware" scheme="https://kalyan-zitiu.github.io/categories/VMware/"/>
    
    
    <category term="虚拟化" scheme="https://kalyan-zitiu.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CNI</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/05/CNI/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/05/CNI/</id>
    <published>2024-07-05T01:51:24.000Z</published>
    <updated>2024-07-05T03:01:35.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>定义容器运行时，如何配置网络接口，以便容器可以网络通信。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ul><li>关注网络连接和网络解除连接</li><li>支持各种不同的网络配置要求</li><li>通过各种不同的网络解决方案解决网络配置。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>当一个Pod被创建时，k8s调用CNI插件来为pod配置网络，通常包括分配IP地址，设置网络路由和创建网络接口等任务。CNI插件负责把pod连接到一个预先的环境，保证pod之间的网络通信。</p><h2 id="常见的-CNI-插件："><a href="#常见的-CNI-插件：" class="headerlink" title="常见的 CNI 插件："></a>常见的 CNI 插件：</h2><ul><li><strong>Calico</strong>：提供高性能的网络和网络策略，支持跨主机的网络隔离。</li><li><strong>Flannel</strong>：简单易用，主要用于创建一个覆盖网络，允许 Pod 跨节点通信。</li><li><strong>Weave Net</strong>：提供一个强大的网络和网络策略，支持自动发现和网络隔离。</li><li><strong>Cilium</strong>：使用 BPF（Berkeley Packet Filter）来提供网络安全、策略执行和负载均衡功能。</li></ul><h3 id="1-Calico"><a href="#1-Calico" class="headerlink" title="1. Calico"></a>1. <strong>Calico</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>高性能</strong>：Calico 使用 BGP（边界网关协议）进行路由，避免了封装和解封装的开销，从而提供高性能的网络连接。</li><li><strong>网络策略</strong>：Calico 提供强大的网络策略功能，允许用户定义细粒度的访问控制规则。</li><li><strong>可扩展性</strong>：适用于大规模集群，能够处理成千上万的节点和 Pod。</li><li><strong>安全性</strong>：支持网络隔离和加密，确保数据在传输过程中安全。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>大规模生产环境</strong>：由于其高性能和可扩展性，Calico 非常适合大规模生产环境。</li><li><strong>需要严格网络策略的环境</strong>：如果需要细粒度的网络访问控制和安全策略，Calico 是一个理想的选择。</li></ul><h3 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. <strong>Flannel</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>简单易用</strong>：Flannel 设计简单，易于部署和管理。</li><li><strong>覆盖网络</strong>：主要提供覆盖网络，使用 UDP、VXLAN 或 host-gw 模式来封装跨主机的容器流量。</li><li><strong>轻量级</strong>：适合中小规模的集群，不需要复杂的配置。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>中小规模集群</strong>：由于其简单性和轻量级特性，Flannel 适用于中小规模的 Kubernetes 集群。</li><li><strong>快速部署</strong>：如果需要快速部署一个 Kubernetes 集群，Flannel 是一个不错的选择。</li></ul><h3 id="3-Weave-Net"><a href="#3-Weave-Net" class="headerlink" title="3. Weave Net"></a>3. <strong>Weave Net</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>自发现网络</strong>：Weave Net 能够自动发现和管理网络配置，简化了网络管理。</li><li><strong>网络加密</strong>：支持网络流量加密，确保数据在传输过程中的安全性。</li><li><strong>多云支持</strong>：能够跨多个云提供商和本地数据中心创建统一的网络。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>多云环境</strong>：Weave Net 非常适合需要跨多个云提供商和本地数据中心的环境。</li><li><strong>需要网络加密的环境</strong>：如果需要确保网络流量的安全性，Weave Net 是一个理想的选择。</li></ul><h3 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. <strong>Cilium</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>基于 BPF</strong>：Cilium 使用 Linux 内核的 BPF 技术来实现高性能和可扩展的网络功能。</li><li><strong>Layer 7 支持</strong>：支持 HTTP/HTTPS、gRPC 等 Layer 7 协议的负载均衡和安全策略。</li><li><strong>可见性和监控</strong>：提供丰富的网络可见性和监控功能，帮助用户了解网络流量和性能。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要高级网络功能的环境</strong>：Cilium 非常适合需要高级网络功能和安全策略的环境。</li><li><strong>微服务架构</strong>：由于其对 Layer 7 协议的支持，Cilium 非常适合微服务架构。</li></ul><h3 id="5-Canal"><a href="#5-Canal" class="headerlink" title="5. Canal"></a>5. <strong>Canal</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>结合了 Flannel 和 Calico</strong>：Canal 将 Flannel 的简单性和 Calico 的网络策略功能结合在一起。</li><li><strong>灵活性</strong>：提供了 Flannel 的覆盖网络和 Calico 的网络策略，适用于多种场景。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要简单网络和策略控制的环境</strong>：Canal 适用于需要简单网络配置和基本网络策略控制的环境。</li><li><strong>中小规模集群</strong>：由于其灵活性和简单性，Canal 适用于中小规模的 Kubernetes 集群。</li></ul><h3 id="6-Kube-Router"><a href="#6-Kube-Router" class="headerlink" title="6. Kube-Router"></a>6. <strong>Kube-Router</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>综合功能</strong>：Kube-Router 提供网络路由、网络策略和服务代理功能。</li><li><strong>高性能</strong>：使用 BGP 进行路由，提供高性能的网络连接。</li><li><strong>易于部署</strong>：集成了多个网络功能，简化了部署和管理。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要综合网络功能的环境</strong>：Kube-Router 适用于需要综合网络功能（如路由、策略和服务代理）的环境。</li><li><strong>高性能需求</strong>：由于其高性能特性，Kube-Router 适用于对网络性能有较高要求的环境。</li></ul><h3 id="7-Multus"><a href="#7-Multus" class="headerlink" title="7. Multus"></a>7. <strong>Multus</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>多网络支持</strong>：Multus 允许一个 Pod 连接到多个网络，支持多种 CNI 插件的组合使用。</li><li><strong>灵活性</strong>：提供了极大的灵活性，适用于复杂的网络需求。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>复杂网络需求</strong>：Multus 适用于需要多个网络接口和复杂网络配置的环境。</li><li><strong>多 CNI 插件组合</strong>：如果需要同时使用多个 CNI 插件，Multus 是一个理想的选择。</li></ul>]]></content>
    
    
    <summary type="html">容器网络接口</summary>
    
    
    
    <category term="K8s" scheme="https://kalyan-zitiu.github.io/categories/K8s/"/>
    
    <category term="CNI" scheme="https://kalyan-zitiu.github.io/categories/K8s/CNI/"/>
    
    
    <category term="Kubernets" scheme="https://kalyan-zitiu.github.io/tags/Kubernets/"/>
    
  </entry>
  
  <entry>
    <title>CRI容器运行时接口</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/04/CRI/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/04/CRI/</id>
    <published>2024-07-04T08:22:37.000Z</published>
    <updated>2024-07-22T01:26:10.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRI-容器运行时接口"><a href="#CRI-容器运行时接口" class="headerlink" title="CRI (容器运行时接口)"></a>CRI (容器运行时接口)</h1><p>了解CRI之前，我们先了解一下什么是RPC</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  一种常用的通信机制，运行程序调用位于远程计算机上的行数或方法，就像调用本地对象一眼。RPC抽象了底层的网络通信细节，使得开发者可以更加专注与业务逻辑的开发，不必过多担心网络相关性的复杂性。</p><h3 id="RPC工作原理"><a href="#RPC工作原理" class="headerlink" title="RPC工作原理"></a>RPC工作原理</h3><h4 id="客户端调用过程"><a href="#客户端调用过程" class="headerlink" title="客户端调用过程"></a>客户端调用过程</h4><ol><li>客户端程序调用一个本地的存根（stub）函数，这个存根代表远程函数</li><li>存根将函数调用的参数打包成一个消息，通过网络发送给服务端</li><li>客户端等待服务端响应</li></ol><h4 id="服务端处理过程"><a href="#服务端处理过程" class="headerlink" title="服务端处理过程"></a>服务端处理过程</h4><ol><li>服务器收到消息，解包得到调用参数。</li><li>服务端调用本地实际函数，执行必要的处理。</li><li>处理完毕后，服务端将结果打包并发送回客户端。<h4 id="客户端接收过程"><a href="#客户端接收过程" class="headerlink" title="客户端接收过程"></a>客户端接收过程</h4></li><li>客户端存根收到响应消息，解包得到结果</li><li>客户端的调用像本地执行一样，得到从远程服务器返回的结果。</li></ol><h3 id="RPC特点"><a href="#RPC特点" class="headerlink" title="RPC特点"></a>RPC特点</h3><ul><li>封装:隐藏网络通信细节，开发者无需直接处理socket编程或其他通信协议细节</li><li>同步:默认同步，即客户端调用一个远程方法时候，回阻塞知道得到结果，尽管如此，许多现代RPC框架支持异步调用。</li><li>透明:</li></ul><h3 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h3><ul><li><p>Finagle：一个构建高并发，分布式系统的异步RPC库，用Scala语言编写，但可以与其他JVM语言一起使用，适合用于高扩展，弹性和容错（异步编程模型，有效地处理大量并发请求，不会阻塞线程，支持多种协议，内置负载均衡）</p></li><li><p>gRPC：由Google开发，基于HTTP/2协议，支持多种语言，能够提供高性能的通信。gRPC使用Protocol Buffers作为其接口定义语言和消息序列化格式。</p></li><li><p>Apache Thrift：由Facebook开发，支持跨语言服务的开发，使用自定义的IDL (Interface Definition Language) 来定义数据类型和服务接口。</p></li><li><p>JSON-RPC和XML-RPC：这些是较轻量级的RPC实现，使用JSON和XML格式分别进行数据序列化，易于与Web技术集成。</p></li></ul><h3 id="RPC应用场景"><a href="#RPC应用场景" class="headerlink" title="RPC应用场景"></a>RPC应用场景</h3><ul><li><p>微服务架构：在微服务架构中，各个服务组件常常需要进行网络通信，RPC提供了一种高效的方式来实现服务间的调用。</p></li><li><p>分布式计算：在需要多个节点共同完成计算任务的场景中，RPC可以用来协调各个节点之间的工作。</p></li></ul><p>让我再在了解CRI之前，先清楚什么是容器的执行以及生命周期</p><h2 id="容器执行和生命周期"><a href="#容器执行和生命周期" class="headerlink" title="容器执行和生命周期"></a>容器执行和生命周期</h2><p>容器的执行和生命周期是指容器从创建到终止的整个过程，涉及到创建，启动，运行，停止和删除。</p><ul><li>创建（Pre-production/Planning）：<br>就像电影制作前的筹备阶段，需要确定剧本、演员、场地等。在 Kubernetes 中，创建容器涉及配置容器的环境，如定义容器的镜像、资源限制（CPU、内存）、网络设置等。</li><li>启动（Production/Shooting）：<br>类似于电影开始拍摄。容器的启动阶段是指实际上将容器镜像运行起来。在这个阶段，容器内部的应用开始执行其预定任务，比如启动一个 Web 服务器、数据库服务等。</li><li>运行（Release/Screening）：<br>就像电影的放映过程。容器成功启动后，它会进入运行状态。在这个阶段，容器内的应用对外提供服务，如处理网络请求、执行数据处理等。</li><li>停止（Ending）：<br>类似于电影放映结束。当容器需要更新或不再需要时，它会被停止。停止容器通常意味着停止容器内部的应用进程。</li><li>删除（Post-production/Cleanup）：<br>就像电影拍摄后的清理阶段。在容器的生命周期的最后阶段，容器会被彻底删除，包括其在节点上的所有数据。这确保了不会留下无用的资源或数据。</li></ul><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>允许用户在容器的特殊阶段进行自定义操作。</p><h4 id="PostStart"><a href="#PostStart" class="headerlink" title="PostStart"></a>PostStart</h4><p><code>PostSrart</code>是在容器创建并启动后立即执行的钩子，这个钩子的执行时间是容器入口命令开始执行之后，但是并不保证是容器的应用程序完全启动之后再再执行。</p><p>ps：若是PostStart钩子启动失败，那么容器不会被杀死或者重启，钩子启动失败的记录会写入日志中。</p><h4 id="PreStop"><a href="#PreStop" class="headerlink" title="PreStop"></a>PreStop</h4><p><code>PreStop</code>是容器被终止钱执行的钩子。当k8s需要停止容器时，首先调用PreStop钩子，然后才会执行容器的终止过程。经常用于优雅的关闭应用程序，保存状态，执行清理任务。</p><p>ps：钩子是会延迟容器的终止过程的，因为k8s会等待钩子执行完成后才会发送SIGTERM信号停止容器。</p><h2 id="CRI是什么"><a href="#CRI是什么" class="headerlink" title="CRI是什么"></a>CRI是什么</h2><p>简单理解的话可以理解成一个适配器，就是为了管理不同容器运行时进行交互的一套标准接口。主要的作用是为了解决k8s直接依赖特定容器运行时的问题。主要是启动停止容器，拉取容器镜像，查询容器状态，管理容器生命周期。</p><ol><li>统一接口是通过RPC内gRPC框架实现的。</li><li>解耦合，完成了k8s与docker直接集成的紧密耦合关系。</li><li>可以让开发者通过自我需求或喜爱来选择合适的容器进行时。</li></ol><h3 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h3><ul><li>首先是使用了能够适应高并发低延迟的通信的HTTP/2，再头部压缩和多路复用请求等高效传输机制。</li><li>gRPC支持双向流，允许服务器和客户端再长连接中实时发送和接受消息。</li></ul><p>只有了解这么多了，gRPC还有很多有用的功能，适用场景也比较广，可能日后碰上这种场景后再继续了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRI-容器运行时接口&quot;&gt;&lt;a href=&quot;#CRI-容器运行时接口&quot; class=&quot;headerlink&quot; title=&quot;CRI (容器运行时接口)&quot;&gt;&lt;/a&gt;CRI (容器运行时接口)&lt;/h1&gt;&lt;p&gt;了解CRI之前，我们先了解一下什么是RPC&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="K8s" scheme="https://kalyan-zitiu.github.io/categories/K8s/"/>
    
    <category term="CRI" scheme="https://kalyan-zitiu.github.io/categories/K8s/CRI/"/>
    
    
    <category term="CRI" scheme="https://kalyan-zitiu.github.io/tags/CRI/"/>
    
  </entry>
  
  <entry>
    <title>Linux从核心到边缘</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-01T15:42:37.000Z</published>
    <updated>2024-07-02T03:52:51.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux从核心到边缘"><a href="#Linux从核心到边缘" class="headerlink" title="Linux从核心到边缘"></a>Linux从核心到边缘</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>  今天有面试一家专注云原生产品的企业，有问到一个问题，就是你还有用过其他的Linux发行版吗，突然顿时觉得很惭愧，而且有一些基础的Linux问题居然发现我忘记了没有回答出来。而且仔细思考了一下，确实在大学期间仅仅只了解过Ubuntu偏向新手和私人开发的linux发行版，而且在命令上似乎只是停留在一些基础的操作（甚至有一些基础命令还忘记了），并没有深入的了解过Linux的内核。而且今天面试官说了一句话，就是从需求出发的科技探索更有利于我们进步。有的时候确实会把某些技术当作工具，但事实上确实是工具，作为一名希望在IT行业继续深耕的我，似乎越来越缺乏对技术美的欣赏，在大学没有多少生活压力的时期最应该体验这种美感的时候，却好像被一些<strong>保姆级</strong>教学一步步蒙蔽了眼睛。结果虽然出来了，但是可能对过程保留不多的记忆或者理解。只能说有时候学习的结果并不重要，重要的是一些有容错的过程。</p><h2 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h2><ul><li>内核类似一个资源的管理程序，负载资源调度到需要的系统进程，我看有些理解可以把内核理解成一个库，有了一组面向系统命令，系统调用应用程序来说，就像调用普通函数一样。其实内核也可以理解成一个桥梁，能够练习硬件和上层应用点的桥梁。一涉及到底层的东西就越来越抽象，还是能够用一些比喻理解比较好。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/3435502-20240507214431792-1257148225.png" alt="img"></li></ul><h2 id="内核的角色"><a href="#内核的角色" class="headerlink" title="内核的角色"></a>内核的角色</h2><ul><li>内核是管理计算机的硬件资源的重要角色，就比如CPU，内存，存储设备和输入输出的设别。</li><li>内核主要威威上层提供了抽象的操作接口，让我们不需要关心硬件的细节。</li><li>内核维护不同程序和用户之间的安全界限，确保学习通的稳定和安全。</li></ul><h2 id="内核的主要组成部分"><a href="#内核的主要组成部分" class="headerlink" title="内核的主要组成部分"></a>内核的主要组成部分</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程调度："><a href="#进程调度：" class="headerlink" title="进程调度："></a>进程调度：</h4><ul><li>Linux内核使用多种调度算法，决定那个进程获得CPU时间，确保各个进程公平使用CPU资源。<h4 id="进程同步："><a href="#进程同步：" class="headerlink" title="进程同步："></a>进程同步：</h4></li><li>内核提供了多种机制，处理进程或线程之间的同步，防止数据争抢，确保线程安全。</li></ul><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul><li>支持多种进程间通信IPC方法，包括信号，管道，消息队列，共享内存和套接字。</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>虚拟内存：程序使用比实际物理内存更多的地址空间，通过使用分页/分段来实现</li><li>内存分配：内核提供多级分配框架，包括页分配器，slab分配器（说实话有够抽象的。）</li><li>交换空间：当物理内存不足时，内核可以将内存页移动到磁盘上的交换控件，以来释放内存。<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3></li><li>支持ext4，XFS，Btrfs，NFS和更多，以适应不同的存储需求和性能特点。</li><li>虚拟文件系统，VFS提供一个统一接口来访问不同文件系统</li><li>文件操作，内核提供系统调用，open，read，write，close。<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3></li><li>字符设备和块设备：Linux区分字符设备，键盘鼠标和块设备硬盘驱动器。</li><li>模块化驱动：Linux支持动态加载和卸载设备驱动模块，这允许不重启系统的情况下添加或更新驱动程序。<h3 id="网络栈"><a href="#网络栈" class="headerlink" title="网络栈"></a>网络栈</h3></li><li>协议实现：内核实现了各种网络协议，IP，TCP，UDP和ICMP</li><li>网络接口：通过网络接口与各种网络硬件进行交互，如以太网卡，无限适配</li><li>网络数据处理：内核处理数据包路由，转发，过滤，支持高级网络功能，如虚拟网络，网络安全规则等。</li></ul><h2 id="linux防火墙"><a href="#linux防火墙" class="headerlink" title="linux防火墙"></a>linux防火墙</h2><ul><li>防火墙系统主要基于iptable，以及比较新的nftables系统，运行管理员配置规则，控制进出网络接口的数据包。</li></ul><ol><li>iptables是一个广泛使用防火墙工具，使用一组表来组织规则，每个表包含多个链，链中包含具体规则，主要有 filter默认表，nat网络地址转换（处理进出接口的地址和端口转换），mangle用来修改数据包的内容，raw配置免除连接跟踪机制的数据包。</li></ol><h2 id="APT包管理"><a href="#APT包管理" class="headerlink" title="APT包管理"></a>APT包管理</h2><ul><li>使用的是.deb包格式，通过apt源来管理和安装软件包。</li><li>一般是使用的linux发行版有Ubuntu，Debian，Linux Mint等</li></ul><h3 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h3><p>  一般可以通过编辑/etc/apt/sourcer.list文件或者在sources.list.d目录下面，创建一个新的源。然后通过更新apt索引的方式。deb标识这是一个二进制的源，一般都会需要导入公钥，验证软件包的真实性，APT使用的是PGP签名，如果你源头是签名的，你需要的导入并信任该公钥，通常，源提供者会提供公钥和相应的导入命令。一般都是会直接把源echo进去，比较快捷。</p><h4 id="sources-list文件结构"><a href="#sources-list文件结构" class="headerlink" title="sources.list文件结构"></a>sources.list文件结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type uri suite &#123;component&#125;</span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted</span><br></pre></td></tr></table></figure><ul><li>type:源的类型，通常是 <code>deb</code> 用于二进制包，或 <code>deb-src</code> 用于源代码包</li><li>uri:源的URI</li><li>suite:发行版的代号,buster,bullseye,focal,bionic</li><li>component:可选，指定源中的区域或分区 </li></ul><h2 id="YUM-DNF包管理"><a href="#YUM-DNF包管理" class="headerlink" title="YUM,DNF包管理"></a>YUM,DNF包管理</h2><ul><li>基于RPM的Linux发行版，使用.repo文件来定义软件仓库。</li><li>一般是使用的linux发行版有Fedora，CentOS和RHEL等</li></ul><h3 id="添加源-1"><a href="#添加源-1" class="headerlink" title="添加源"></a>添加源</h3><p>一般添加源可以创建一个新的文件或者编辑指定现有文件，这个和apt包管理的添源方式类似。但是他们的文件结构格式大不相同</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仓库的唯一标识符。这个ID在 .repo 文件中必须是唯一的</span></span><br><span class="line"><span class="section">[docker-ce-stable]</span></span><br><span class="line"><span class="comment"># 仓库的描述性名称</span></span><br><span class="line"><span class="attr">name</span>=Docker CE Stable - <span class="variable">$basearch</span> </span><br><span class="line"><span class="comment"># 仓库的基本URL，指向包含RPM包的目录</span></span><br><span class="line"><span class="attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="number">7</span>/<span class="variable">$basearch</span>/stable</span><br><span class="line"><span class="comment"># 定是否启用该仓库。设置为 1 表示启用，0 表示禁用</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指定是否检查GPG签名。设置为 1 表示启用GPG签名检查</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指向GPG公钥文件的路径，用于验证包的签名。</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br></pre></td></tr></table></figure><h3 id="更新方式也和apt管理不同"><a href="#更新方式也和apt管理不同" class="headerlink" title="更新方式也和apt管理不同"></a>更新方式也和apt管理不同</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum(dnf) makecache fast</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里为止，我依然觉得我还是不够了解Linux内核，总感觉没有想象的那么简单。可能过几天忙过了可以开始了解和学习一下KVM可能那里会给我一些答案。希望自己也能开始重新拾取对知识的渴望和动力吧。</p>]]></content>
    
    
    <summary type="html">一次对Linux的探讨以及自我端正</summary>
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/tags/Linux/"/>
    
    <category term="内核" scheme="https://kalyan-zitiu.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>简易高弹性B/S架构</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/</id>
    <published>2024-04-12T12:00:00.000Z</published>
    <updated>2024-06-24T07:59:40.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VPC架构设计"><a href="#VPC架构设计" class="headerlink" title="VPC架构设计"></a><strong>VPC架构设计</strong></h3><p>一个虚拟私有云（VPC）的结构，名称为“MyVPC”。该VPC包含4个子网，分布在两个可用区（us-east-1a和us-east-1b）中。其中，us-east-1a包含PublicSubnet1和PrivateSubnet1，us-east-1b包含PublicSubnet2和PrivateSubnet2。此外，该VPC还配置了两个路由表：PrivateRouteTable和PublicRouteTable，其中一个路由表的ID为“rtb-08c231d3d0fbbf2c2”。最后，图中显示了两个网络设备：MyInternetGateway和MyNatGateway。这些组件共同构成了一个典型的VPC架构，用于管理和控制网络流量的路由和访问。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154008942.png" alt="image-20240624154008942"></p><h3 id="B-S架构设计"><a href="#B-S架构设计" class="headerlink" title="B/S架构设计"></a><strong>B/S架构设计</strong></h3><p>这幅图展示了一个详细的虚拟私有云（VPC）架构，包含多个AWS组件和服务。该架构包括一个名为”MyVPC”的VPC，内部包含多个子网（如PublicSubnetA、PublicSubnetB、PrivateSubnetA、PrivateSubnetB）和路由表（如PublicRouteTable、PrivateRouteTable）。此外，还配置了网络ACL（如PublicNetworkACL、PrivateNetworkACL）来控制子网的入站和出站流量。网络设备方面，包含一个InternetGateway用于公共子网的互联网访问，以及一个NATGateway和其对应的弹性IP用于私有子网的互联网访问。安全组（如PublicInstanceSecurityGroup、PrivateInstanceSecurityGroup）用于实例的流量控制。实例部分，包括PublicInstanceA、PublicInstanceB、PrivateInstanceA、PrivateInstanceB等。</p><p>该架构使用堡垒机来登录实例，VPC通过CloudFormation模板构建，并基于CloudWatch指标实现自动扩展（AutoScaling）。会话状态保存在DynamoDB中，数据库缓存使用Amazon<br>ElastiCache for<br>Redis。此外，还使用消息队列SQS来处理消息。这些组件通过复杂的连接关系，构成了一个集成的、高度可扩展和可靠的网络架构，用于管理和控制流量的路由、访问和安全性，适用于在云环境中部署和管理各种应用和服务。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154015927.png" alt="image-20240624154015927"></p><h3 id="Auto-Scaling组配置"><a href="#Auto-Scaling组配置" class="headerlink" title="Auto Scaling组配置"></a><strong>Auto Scaling组配置</strong></h3><p>定义了一个自动扩展启动配置（Launch<br>Configuration），指定了使用的AMI镜像、实例类型、安全组、用户数据等信息，确保新实例能够按照指定的配置启动并运行。接着创建了一个自动扩展组（Auto<br>Scaling<br>Group），设置了VPC子网、启动配置、最小和最大实例数量、目标组等参数，以便根据负载情况自动调整实例数量。同时，配置了CloudWatch告警监控CPU利用率高低，当CPU利用率超过或低于阈值时，会触发相应的扩展或缩容策略。具体而言，定义了两个告警，分别用于CPU利用率超过70%和低于30%时的自动扩展和缩容操作。此外，还设置了扩展和缩容策略，包括调整实例数量、冷却时间等参数，以确保系统能够根据负载情况自动调整实例数量，实现自动化弹性扩展和收缩。整体而言，这个配置文件实现了一个基于CPU利用率的自动扩展机制，能够根据实际负载情况动态调整实例数量，提高系统的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154021722.png" alt="image-20240624154021722"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154027789.png" alt="image-20240624154027789"></p><h3 id="ALB配置"><a href="#ALB配置" class="headerlink" title="ALB配置"></a><strong>ALB配置</strong></h3><p>这个应用负载均衡器（ALB）在你的架构中担任了至关重要的角色，确保了应用的高效运行和用户体验的优化。具体来说，ALB将进入的应用程序流量智能地分配到多个目标（如EC2实例），平衡了负载并防止了单点故障，从而保证了系统的高可用性和可扩展性。通过定期进行健康检查，ALB确保只有健康的实例接收流量，如果某个实例出现故障，它会自动将流量重定向到其他健康的实例，提高了应用的可靠性。</p><p>此外，ALB支持基于内容的路由功能，可以根据请求的URL路径、HTTP头、查询字符串等，将流量路由到不同的目标组，使得你可以更灵活地管理流量，比如将静态内容和动态内容分开处理，从而优化资源使用。ALB还可以与AWS的安全服务（如AWS<br>WAF和ACM）集成，提供强大的安全防护，支持SSL/TLS终止，确保传输层的安全，同时简化了证书管理。通过与Auto<br>Scaling集成，ALB可以根据流量负载自动增加或减少目标实例的数量，确保了应用能够应对流量高峰，同时优化了成本。ALB还与CloudWatch无缝集成，提供详细的监控和日志记录功能，让你可以实时监控流量模式、请求响应时间等关键指标，快速识别和解决潜在问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154059526.png" alt="image-20240624154059526"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154041177.png" alt="image-20240624154035908"></p><h3 id="通过CloudFormation进行快速实施过程"><a href="#通过CloudFormation进行快速实施过程" class="headerlink" title="通过CloudFormation进行快速实施过程"></a><strong>通过CloudFormation进行快速实施过程</strong></h3><p>首先，通过CloudFormation创建一个VPC和多个子网，配置Internet网关和NAT网关以实现公共和私有网络的连接。然后设置安全组并启动Bastion主机作为跳板机。接着，配置目标组和创建应用负载均衡器，设置监听器以将流量引导到后端实例。定义启动配置并基于此配置创建自动伸缩组，实现根据负载情况动态调整实例数量。继续创建RDS子网组和部署RDS实例，确保数据库服务的高可用性和持久性。创建DynamoDB表以存储非结构化数据，实现快速读写和扩展性。配置ElastiCache子网组并部署ElastiCache集群，提供高性能的缓存服务，加速数据访问。最后，创建SQS队列用于处理消息队列，确保应用程序之间的异步通信。在完成上述步骤后，获取关键资源的信息，包括Bastion主机的公有IP地址用于远程访问，负载均衡器的DNS名称用于访问应用程序，RDS实例的终端节点用于数据库连接，DynamoDB表名用于数据存储，Redis缓存的终端节点用于快速数据缓存，以及SQS队列的URL用于消息处理。这样可以确保整个架构的部署和运行顺利进行。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154107810.png" alt="image-20240624154107810"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154125600.png" alt="image-20240624154125600"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154118431.png" alt="image-20240624154114091"></p><h3 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a><strong>遇到的问题与解决方案</strong></h3><p>权限问题：如果遇到权限不足的问题，确保使用的IAM用户或角色具有必要的权限，比如创建VPC、子网、EC2实例、RDS实例等权限。</p><p>资源限制问题：如果遇到资源限制（如EC2实例配额不足），可以通过联系AWS支持来提升配额。</p><p>网络配置问题：确保VPC和子网的CIDR块配置正确，避免重叠。确保安全组规则配置正确，允许所需的入站和出站流量。</p><p>模板语法错误：使用AWS<br>CloudFormation的模板验证工具来检查模板语法是否正确。</p><h3 id="测试方案与结果"><a href="#测试方案与结果" class="headerlink" title="测试方案与结果"></a><strong>测试方案与结果</strong></h3><h4 id="基于CloudWatch的AutoScaling"><a href="#基于CloudWatch的AutoScaling" class="headerlink" title="基于CloudWatch的AutoScaling"></a><strong>基于CloudWatch的AutoScaling</strong></h4><p>CloudWatch的Auto<br>Scaling是一种动态调整计算资源以匹配应用需求的机制，通过监控关键指标（如CPU利用率）来触发扩展或缩减操作。CloudWatch会收集和监控这些指标，并基于设定的阈值触发警报。当警报触发时，Auto<br>Scaling组会根据预定义的策略自动增加或减少EC2实例的数量。例如，当CPU利用率超过某个阈值时，Auto<br>Scaling会增加实例数量以处理高负载；当CPU利用率低于阈值时，Auto<br>Scaling会减少实例数量以节约成本。通过这种方式，Auto<br>Scaling确保了应用程序的高可用性和性能，同时优化了资源使用和成本效益。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154158215.png" alt="image-20240624154158215"></p><h4 id="DynamoDB保存会话状态"><a href="#DynamoDB保存会话状态" class="headerlink" title="DynamoDB保存会话状态"></a><strong>DynamoDB保存会话状态</strong></h4><p>在Web应用中，会话（Session） 是在用户与服务器之间的交互过程中维持状态的一种方式。HTTP协议本身是无状态的，这意味着每个请求都是独立的，服务器默认不会记住前一个请求的信息。会话状态技术允许服务器记住用户的状态信息（如用户是否已登录、用户的偏好设置等），这对于创建交互式Web应用是必要的。DynamoDB作为会话存储的后端，帮助Web应用维护用户的状态，提供连贯的用户体验，并且能够在用户数量激增时保持高性能和可靠性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154209751.png" alt="image-20240624154209751"></p><h4 id="使用消息队列SQS"><a href="#使用消息队列SQS" class="headerlink" title="使用消息队列SQS"></a><strong>使用消息队列SQS</strong></h4><p>使用AWS<br>SDK（例如Python的Boto3）向队列发送消息。首先，确保你已安装Boto3并配置了AWS凭证。接收消息也很简单。使用同样的SQS客户端，你可以从队列中拉取消息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154216362.png" alt="image-20240624154216362"></p><h4 id="使用ElastiCache-for-Redis数据库缓存"><a href="#使用ElastiCache-for-Redis数据库缓存" class="headerlink" title="使用ElastiCache for Redis数据库缓存"></a><strong>使用ElastiCache for Redis数据库缓存</strong></h4><p>ElastiCache for Redis 是一种由 AWS<br>托管的内存缓存服务，通过在内存中存储数据，提供极低的延迟和高吞吐量的数据访问能力，适用于实时分析、会话存储和排行榜等应用场景。它支持水平和垂直扩展，可以根据应用需求动态调整节点数量和实例规格，确保在流量高峰期依然高效运行。通过多可用区部署和自动故障转移功能，ElastiCache<br>for Redis<br>提供了高可用性和数据持久性，确保在节点故障时数据不丢失并迅速恢复。此外，ElastiCache<br>for Redis 是完全托管的服务，AWS<br>负责基础设施管理、软件更新、安全补丁和备份恢复，简化了管理工作，使开发者可以专注于应用开发。它还支持VPC、子网、安全组和加密功能，确保数据传输和存储的安全性。总之，ElastiCache<br>for Redis<br>提供了一个高效、可靠和安全的缓存解决方案，显著提升了数据访问速度和系统响应能力，简化了缓存管理和运维工作，使开发者能够专注于核心业务逻辑的开发。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154224745.png" alt="image-20240624154224745"></p><h4 id="实例与数据库连接"><a href="#实例与数据库连接" class="headerlink" title="实例与数据库连接"></a><strong>实例与数据库连接</strong></h4><p>为了使EC2实例与RDS实例互联，需要创建并配置两个安全组，一个用于EC2实例，另一个用于RDS实例。然后在RDS实例的安全组中添加入站规则，允许从EC2实例的安全组IP地址范围通过数据库端口（如3306）进行访问。最后，在EC2实例中配置数据库客户端，使用RDS实例的端点和端口号进行连接，从而实现网络通信与数据库操作。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154229517.png" alt="image-20240624154229517"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154234077.png" alt="image-20240624154234077"></p><h4 id="用CloudFormation进行VPC内容创建"><a href="#用CloudFormation进行VPC内容创建" class="headerlink" title="用CloudFormation进行VPC内容创建"></a><strong>用CloudFormation进行VPC内容创建</strong></h4><p>使用CloudFormation进行VPC创建可以自动化管理和部署完整网络架构。通过编写CloudFormation模板，可以创建一个VPC，设置其CIDR块，配置公共和私有子网，创建并连接Internet网关和NAT网关，并配置路由表和关联。这样不仅提高了部署效率，还减少了人为配置错误，确保网络架构的可重复性和一致性。例如，模板中配置了一个CIDR为10.0.0.0/16的VPC，包含两个公共子网和两个私有子网，并分别配置了路由表和NAT网关，以保证私有子网具有访问外部网络的能力。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="string">&#x27;2010-09-09&#x27;</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">AWS</span> <span class="string">CloudFormation</span> <span class="string">Template</span> <span class="string">for</span> <span class="string">B/S</span> <span class="string">Architecture</span> <span class="string">with</span> <span class="string">VPC,</span> <span class="string">Subnets,</span> <span class="string">RDS,</span> <span class="string">EC2,</span> <span class="string">Auto</span> <span class="string">Scaling,</span> <span class="string">DynamoDB,</span> <span class="string">ElastiCache,</span> <span class="string">and</span> <span class="string">SQS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">MyVPC:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPC</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">EnableDnsSupport:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">EnableDnsHostnames:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyVPC</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.3</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">InternetGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::InternetGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyInternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">GatewayAttachment:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPCGatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">InternetGatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGatewayEIP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::EIP</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Domain:</span> <span class="string">vpc</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGatewayEIP</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::NatGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">AllocationId:</span> <span class="type">!GetAtt</span> <span class="string">NatGatewayEIP.AllocationId</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPublicRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">DependsOn:</span> <span class="string">GatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">GatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPrivateRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">NatGatewayId:</span> <span class="type">!Ref</span> <span class="string">NatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">WebServerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">HTTP,</span> <span class="string">RDP,</span> <span class="string">and</span> <span class="string">SSH</span> <span class="string">access</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">bastion</span> <span class="string">host</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Instance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostInstance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Load Balancer Security Group</span></span><br><span class="line">  <span class="attr">LoadBalancerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">access</span> <span class="string">to</span> <span class="string">Load</span> <span class="string">Balancer</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Application Load Balancer</span></span><br><span class="line">  <span class="attr">ApplicationLoadBalancer:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::LoadBalancer</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Name:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Subnets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line">      <span class="attr">Scheme:</span> <span class="string">internet-facing</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Target Group for Load Balancer</span></span><br><span class="line">  <span class="attr">TargetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">TargetGroupTwo:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Listener for Load Balancer</span></span><br><span class="line">  <span class="attr">LoadBalancerListenerHTTP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">LoadBalancerListenerCustomPort:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Auto Scaling Launch Configuration</span></span><br><span class="line">  <span class="attr">LaunchConfiguration:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::LaunchConfiguration</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">UserData:</span></span><br><span class="line">        <span class="attr">Fn::Base64:</span> <span class="type">!Sub</span> <span class="string">|</span></span><br><span class="line"><span class="string">          #!/bin/bash</span></span><br><span class="line"><span class="string">          yum update -y</span></span><br><span class="line"><span class="string">          yum install -y httpd nodejs unzip</span></span><br><span class="line"><span class="string">          systemctl start httpd</span></span><br><span class="line"><span class="string">          systemctl enable httpd</span></span><br><span class="line"><span class="string">          cd /var/www/html</span></span><br><span class="line"><span class="string">          aws s3 cp s3://myawsbucketkalyanzitiu/mysqlViewer.zip</span></span><br><span class="line"><span class="string">          unzip mysqlViewer.zip</span></span><br><span class="line"><span class="string">          rm mysqlViewer.zip</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          node /var/www/html/start.js &amp;</span></span><br><span class="line"><span class="string">          /opt/aws/bin/cfn-signal -e $? --stack $&#123;AWS::StackName&#125; --resource AutoScalingGroup --region $&#123;AWS::Region&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="comment"># Auto Scaling Group</span></span><br><span class="line">  <span class="attr">AutoScalingGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::AutoScalingGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VPCZoneIdentifier:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">LaunchConfigurationName:</span> <span class="type">!Ref</span> <span class="string">LaunchConfiguration</span></span><br><span class="line">      <span class="attr">MinSize:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">MaxSize:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">DesiredCapacity:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">TargetGroupARNs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyAutoScalingGroup</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Environment</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">Production</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># CloudWatch Alarm for Auto Scaling</span></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmHigh:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale up if CPU &gt; 70% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">70</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">GreaterThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleUpPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmLow:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale down if CPU &lt; 30% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">LessThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleDownPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scaling Policies</span></span><br><span class="line">  <span class="attr">ScaleUpPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ScaleDownPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">-1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DynamoDB Table</span></span><br><span class="line">  <span class="attr">DynamoDBTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::DynamoDB::Table</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TableName:</span> <span class="string">SessionTable</span></span><br><span class="line">      <span class="attr">AttributeDefinitions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">AttributeType:</span> <span class="string">S</span></span><br><span class="line">      <span class="attr">KeySchema:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">KeyType:</span> <span class="string">HASH</span></span><br><span class="line">      <span class="attr">ProvisionedThroughput:</span></span><br><span class="line">        <span class="attr">ReadCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">WriteCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">SessionTable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ElastiCache for Redis</span></span><br><span class="line">  <span class="attr">RedisCacheCluster:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::CacheCluster</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CacheNodeType:</span> <span class="string">cache.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">NumCacheNodes:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">VpcSecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">RedisCacheCluster</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">RedisSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::SubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Description:</span> <span class="string">&quot;Subnet group for Redis cache&quot;</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># SQS Queue</span></span><br><span class="line">  <span class="attr">SQSQueue:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::SQS::Queue</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">QueueName:</span> <span class="string">MyQueue</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MySQSQueue</span></span><br><span class="line">          </span><br><span class="line">  <span class="attr">MyDBSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBSubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBSubnetGroupDescription:</span> <span class="string">My</span> <span class="string">DB</span> <span class="string">Subnet</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RDS Instance for Multi-AZ Deployment</span></span><br><span class="line">  <span class="attr">DBInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBInstance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBName:</span> <span class="string">MyDatabase</span></span><br><span class="line">      <span class="attr">AllocatedStorage:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">DBInstanceClass:</span> <span class="string">db.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MasterUsername:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">MasterUserPassword:</span> <span class="string">admin123</span></span><br><span class="line">      <span class="attr">VPCSecurityGroups:</span> []</span><br><span class="line">      <span class="attr">DBSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line">      <span class="attr">MultiAZ:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyRDSInstance</span></span><br><span class="line">    <span class="attr">DeletionPolicy:</span> <span class="string">Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Outputs:</span></span><br><span class="line">  <span class="attr">DBInstanceEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the RDS instance&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">DBInstance.Endpoint.Address</span></span><br><span class="line">  <span class="attr">BastionHostPublicIp:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The public IP address of the bastion host&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">BastionHostInstance.PublicIp</span></span><br><span class="line">  <span class="attr">LoadBalancerDNSName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The DNS name of the Application Load Balancer&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">ApplicationLoadBalancer.DNSName</span></span><br><span class="line">  <span class="attr">DynamoDBTableName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The name of the DynamoDB table&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">DynamoDBTable</span> </span><br><span class="line">  <span class="attr">RedisCacheEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the Redis cache cluster&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">RedisCacheCluster.RedisEndpoint.Address</span></span><br><span class="line">  <span class="attr">SQSQueueURL:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The URL of the SQS queue&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">SQSQueue</span></span><br></pre></td></tr></table></figure><h4 id="使用堡垒机登录实例"><a href="#使用堡垒机登录实例" class="headerlink" title="使用堡垒机登录实例"></a><strong>使用堡垒机登录实例</strong></h4><p>首先，通过SSH连接到堡垒机，以便安全地访问私有子网内的Web实例。登录堡垒机后，利用存储在堡垒机上的SSH密钥登录私有子网内的Web实例进行部署操作。有时使用密钥登录可能会显示“权限被拒绝”的错误，这通常是由于密钥文件权限设置不正确导致的。此时，可以通过运行chmod<br>400<br>path_to_your_private_key命令重新设置密钥文件权限，确保只有当前用户可以读取该文件，从而解决登录被拒绝的问题。通过这种方式，能够安全有效地管理和部署私有子网内的实例。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154256449.png" alt="image-20240624154256449"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154303065.png" alt="image-20240624154303065"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154308929.png" alt="image-20240624154308929"></p><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a><strong>性能评估</strong></h3><h4 id="负载均衡测试"><a href="#负载均衡测试" class="headerlink" title="负载均衡测试"></a><strong>负载均衡测试</strong></h4><p>通过性能监控对实例进行分流，显示不同ip型号的实例</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154334381.png" alt="image-20240624154334381"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154338428.png" alt="image-20240624154338428"></p><h4 id="数据库性能测试"><a href="#数据库性能测试" class="headerlink" title="数据库性能测试"></a><strong>数据库性能测试</strong></h4><p>显示了数据库性能测试中的几个关键指标，包括剩余存储空间、读写操作次数（IOPS）、网络接收与发送吞吐量等。图中显示在测试初期读写操作和网络传输活动较高，随后逐渐趋于平稳，表明数据库在高负载初期经过密集活动后恢复到稳定状态。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154345250.png" alt="image-20240624154345250"></p><h4 id="自动伸缩功能测试"><a href="#自动伸缩功能测试" class="headerlink" title="自动伸缩功能测试"></a><strong>自动伸缩功能测试</strong></h4><p>进行自动伸缩功能测试时，首先配置一个Auto<br>Scaling组，并设置其最小实例数为2，最大实例数为3。此外，创建缩放策略，当CPU利用率低于30%时减少实例数量，当CPU利用率高于70%时增加实例数量。启动测试后，可以观察到，当负载增加时，Auto<br>Scaling组中的实例数量从2个自动扩展到3个，而在负载减小时，实例数量则会减少回2个。这种自动调整实例数量的功能确保了应用在高负载时有足够的资源，同时在低负载时节省资源成本。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154404728.png" alt="image-20240624154404728"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154356696.png" alt="image-20240624154351414"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154414919.png" alt="image-20240624154414919"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154424766.png" alt="image-20240624154424766"></p><h4 id="项目部署效果测试"><a href="#项目部署效果测试" class="headerlink" title="项目部署效果测试"></a><strong>项目部署效果测试</strong></h4><p>项目架构部署在AWS云平台上，使用包含两个可用区的VPC，配置有公有和私有子网，互联网网关和NAT网关。核心部分是通过配置在互联网网关内的应用程序负载均衡器和Auto<br>Scaling组，实现Web实例的自动扩展，并将这些实例分布在两个可用区内。同时，RDS数据库配置了主备实例，确保数据的高可用性和可靠性。安全组进一步管理网络安全，确保系统的高可用性和灵活扩展性。</p><p>当负载均衡器正常运行时，提示项目成功启动。您可以通过访问以下URL连接到数据库并查看Web项目：</p><p><a href="http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/">http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/</a></p><p>这将能够直接访问部署在AWS上的Web应用，并与底层的数据库实例交互，确保应用的可靠运行和性能优化。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154510878.png" alt="image-20240624154510878"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154514651.png" alt="image-20240624154514651"></p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>EKS概述</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/</id>
    <published>2024-04-10T12:00:00.000Z</published>
    <updated>2024-06-30T10:38:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EKS"><a href="#EKS" class="headerlink" title="EKS"></a>EKS</h1><p>学校给的AWS沙盒快过期了，剩下几十🔪也不想浪费，突然发现居然有给EKS的权限，想到前几天自建K8S集群的经历，虽然可以熟悉集群流程，但是倘若在生产环境下，还是有安全高可用的托管平台舒服。</p><h2 id="架构结构"><a href="#架构结构" class="headerlink" title="架构结构"></a>架构结构</h2><p>学习一个东西，肯定是先了解概念以及大概的结构，由大入微，最重要的是要不断实践和尝试，通过实际操作来加深对该工具或技术的理解。</p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>首先是k8s，一个开源容器编排平台，源于Google的Borg。主要就是能够多平台进行自动化调度，修复，扩展，服务发现和负载，存储编排等重要功能。</p><p><img src="https://github.com/ben1234560/k8s_PaaS/raw/master/assets/1582188308711.png" alt="1582188308711"></p><h4 id="经典七大件"><a href="#经典七大件" class="headerlink" title="经典七大件"></a>经典七大件</h4><ol><li><p><strong>kube-apiserver</strong>：Kubernetes API服务器，提供了Kubernetes集群的API接口，负责接收和处理来自用户、控制器和其他组件的请求。</p></li><li><p><strong>kube-controller-manager</strong>：Kubernetes控制器管理器，包含多个控制器，负责监控集群状态并根据预定义的控制器逻辑进行调整，确保集群中的资源达到预期状态。</p></li><li><p><strong>kube-scheduler</strong>：Kubernetes调度器，负责根据Pod的调度策略（如资源需求、亲和性、反亲和性等）选择合适的Node节点来运行Pod。</p></li><li><p><strong>kubelet</strong>：每个Node节点上运行的Kubernetes代理，负责管理Node节点上的Pod和容器，与kube-apiserver通信，执行Pod的生命周期管理和监控。</p></li><li><p><strong>kube-proxy</strong>：Kubernetes网络代理，负责为Pod提供网络代理和负载均衡功能，实现Pod之间和Pod与外部网络的通信。</p></li><li><p><strong>etcd</strong>：分布式键值存储系统，用于存储Kubernetes集群的所有配置数据、状态信息和元数据，保证集群的一致性和可靠性。</p></li><li><p><strong>Container Runtime</strong>：容器运行时，负责在Node节点上创建和管理容器，常见的容器运行时包括Docker、containerd、CRI-O等。</p></li></ol><h3 id="EKS-1"><a href="#EKS-1" class="headerlink" title="EKS"></a>EKS</h3><p>EKS能够简化云上K8S的复杂性，提供一个高可用安全的控制平台，主要还可以集成其他服务，比如IAM、VPC、CloudWatch、ELB等。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630155419294.png" alt="image-20240630155419294"></p><p>上面的一个架构图，也是能够很清晰的看出来EKS Conrtol Plane成为了管理k8集群的核心组件，然后通过网络负载均衡余kubectl通信。咋一看好像中间少了API Server，scheduler，controller-manager这些组件，但是估计是由在集成在EKS Control里面的，而且相比于自建k8s集群的一个vpc内，这里却分为了两个VPC一个是管理的VPC，另一个是节点的VPC。这应该是属于一种网络隔离方法。可能是为了集群的稳定。其次就是责任分离了。然后工作节点的服务通过ELB来进行负载均衡给用户。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>首先配置eks集群</li><li>创建一个或多个工作节点</li><li>选择工具。并且连接到EKS</li><li>在pod上部署应用程序</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630165310994.png" alt="image-20240630165310994"></p><h2 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h2><p>不得不说是真的方便，还能够同时集成多个插件和统一的管理。可惜了，后面有一些操作，权限不够用不了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630183047481.png" alt="image-20240630183047481"></p>]]></content>
    
    
    <summary type="html">瞎玩EKS</summary>
    
    
    
    <category term="EKS" scheme="https://kalyan-zitiu.github.io/categories/EKS/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/EKS/K8S/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/EKS/K8S/AWS/"/>
    
    
    <category term="Academy" scheme="https://kalyan-zitiu.github.io/tags/Academy/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker部署Kubernetes</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/</id>
    <published>2024-04-08T06:00:00.000Z</published>
    <updated>2024-06-30T05:34:01.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Docker部署Kubernetes"><a href="#基于Docker部署Kubernetes" class="headerlink" title="基于Docker部署Kubernetes"></a>基于Docker部署Kubernetes</h1><h2 id="学习环境架构搭建"><a href="#学习环境架构搭建" class="headerlink" title="学习环境架构搭建"></a>学习环境架构搭建</h2><h3 id="创建VPC"><a href="#创建VPC" class="headerlink" title="创建VPC"></a>创建VPC</h3><p>在AWS创建一个拥有一个子网的VPC</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629213836702.png" alt="image-20240629213836702"></p><h3 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h3><p>安全组为了方便最好把ssh的22端口以及Kubernetes API服务的端口6443设置为入站规则。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214700104.png" alt="image-20240629214700104"></p><h3 id="启动模板创建"><a href="#启动模板创建" class="headerlink" title="启动模板创建"></a>启动模板创建</h3><p>根据最小配置。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214828795.png" alt="image-20240629214828795"></p><p>编写用户数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Docker</span></span><br><span class="line">apt-get install -y docker.io</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Kubernetes官方APT软件仓库的密钥和仓库</span></span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新APT索引并安装kubelet, kubeadm和kubectl</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swap（Kubernetes不支持运行在启用了Swap的机器上）</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>问题来了，当我试图用用户数据来做启动后的自动安装配置，由于Ubuntu版本命令已经不用apt-key了，所以在实例启动后并没有得到相应的环境，不过没有问题。</p><h2 id="Master主节点"><a href="#Master主节点" class="headerlink" title="Master主节点"></a>Master主节点</h2><h3 id="配置主节点环境以及准备初始化主节点"><a href="#配置主节点环境以及准备初始化主节点" class="headerlink" title="配置主节点环境以及准备初始化主节点"></a>配置主节点环境以及准备初始化主节点</h3><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. <strong>安装docker</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新本地的包索引数据库，这样在安装新软件时能获取到最新的软件包。</span></span><br><span class="line">sudo apt-get update </span><br><span class="line"><span class="comment"># 安装Docker。docker.io是Ubuntu官方仓库中Docker的软件包名称，-y参数表示自动同意安装过程中的询问。</span></span><br><span class="line">sudo apt-get install docker.io -y</span><br><span class="line"><span class="comment"># 启动Docker服务，并设置为开机自启动。</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><h3 id="2-关闭Swap"><a href="#2-关闭Swap" class="headerlink" title="2.关闭Swap"></a><strong>2.关闭Swap</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用swap（交换空间）。Kubernetes要求禁用swap，因为需要严格的资源控制和隔离，swap存在可能会影响性能和调度决策。</span></span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><h3 id="3-安装-cri-dockerd"><a href="#3-安装-cri-dockerd" class="headerlink" title="3.安装 cri-dockerd"></a>3.安装 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br><span class="line"><span class="comment"># cri-dockerd是一个桥接组件，允许Kubernetes通过CRI（容器运行时接口）与Docker交互。</span></span><br><span class="line">dpkg -i cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br></pre></td></tr></table></figure><ul><li></li></ul><h3 id="4-启动并配置开机启动-cri-dockerd"><a href="#4-启动并配置开机启动-cri-dockerd" class="headerlink" title="4.启动并配置开机启动 cri-dockerd"></a>4.启动并配置开机启动 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.socket</span><br></pre></td></tr></table></figure><ul><li>这些命令设置<code>cri-docker</code>服务和socket的启动和开机自启动，确保Kubernetes可以正确与Docker通信。</li></ul><h3 id="5-安装-kubeadm、kubelet、kubectl"><a href="#5-安装-kubeadm、kubelet、kubectl" class="headerlink" title="5.安装 kubeadm、kubelet、kubectl"></a>5.安装 kubeadm、kubelet、kubectl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装网络传输和证书相关的工具，为后续下载和验证Kubernetes包做准备。</span></span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并安装Kubernetes的GPG密钥，用于验证后续安装包的完整性。</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加Kubernetes的软件源，以便安装kubeadm、kubelet和kubectl。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] http://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><ul><li>测试拉取，然后查看需要的images</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630104435917.png" alt="image-20240630104435917"></p><ul><li>拉取镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/etcd:3.5.7-0</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630111103161.png" alt="image-20240630111103161"></p><h4 id="第一次尝试初始化"><a href="#第一次尝试初始化" class="headerlink" title="第一次尝试初始化"></a>第一次尝试初始化</h4><p>粗心大意,podSubnet没有注意大小写</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630113034682.png" alt="image-20240630113034682"></p><h4 id="第二次尝试初始化"><a href="#第二次尝试初始化" class="headerlink" title="第二次尝试初始化"></a>第二次尝试初始化</h4><p>需要reset一下kubeeadm</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们用的是docker</span></span><br><span class="line">sudo kubeadm reset -f --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630114542529.png" alt="image-20240630114542529"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>出现了两个问题,总的来说就是权限问题和连接问题.</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115125908.png" alt="image-20240630115125908"></p><h5 id="权限问题解决"><a href="#权限问题解决" class="headerlink" title="权限问题解决"></a>权限问题解决</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> ubuntu:ubuntu /etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>解决完权限问题后,连接问题也解决了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115354437.png" alt="image-20240630115354437"></p><p> 经过一定的搜寻和思考,</p><ul><li>运行上述命令后，你实际上是在改变 <code>/etc/kubernetes/admin.conf</code> 文件的所有权，将其从 <code>root</code> 用户和组更改为 <code>ubuntu</code> 用户和组。这样做的直接结果是，普通用户 <code>ubuntu</code> 现在有权限读取这个文件。</li><li>在k8s中集群中,<code>admin.conf</code> 文件包含了连接到集群的 K8s API 服务器的必要凭证和连接信息。这包括 API 服务器的地址、端口、使用的证书等。当你以 <code>ubuntu</code> 用户身份运行 <code>kubectl</code> 命令时，<code>kubectl</code> 会尝试读取这个配置文件来获取连接到 K8s 集群的必要信息。</li></ul><h4 id="先观察一下kubelet日志"><a href="#先观察一下kubelet日志" class="headerlink" title="先观察一下kubelet日志"></a>先观察一下kubelet日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl -u kubelet -f</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630120005623.png" alt="image-20240630120005623"></p><h4 id="再看一眼pod的日志"><a href="#再看一眼pod的日志" class="headerlink" title="再看一眼pod的日志"></a>再看一眼pod的日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定namespace;</span></span><br><span class="line">sudo kubectl logs coredns-5dd5756b68-jd25s --namespace=kube-system</span><br></pre></td></tr></table></figure><p>这种情况,大概率是网络上的,问题,经过查找需要安装一些网络插件</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630121445618.png" alt="image-20240630121445618"></p><h4 id="安装部署-Calico-网络插件"><a href="#安装部署-Calico-网络插件" class="headerlink" title="安装部署 Calico 网络插件"></a>安装部署 Calico 网络插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure><h2 id="Node-节点加入集群"><a href="#Node-节点加入集群" class="headerlink" title="Node 节点加入集群"></a>Node 节点加入集群</h2><h3 id="先在master节点查看加入命令"><a href="#先在master节点查看加入命令" class="headerlink" title="先在master节点查看加入命令"></a>先在master节点查看加入命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入命令,并指定cri-socket</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.0.1.237:6443 --token a69ewm.uvje3ei8zhox3xar --discovery-token-ca-cert-hash sha256:64db0e4e2ddc13e1a06390ac6b90b4f38a965fdc7cbfd2e3baa80a668e7cd74d --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><h3 id="为了node节点加入必备组件"><a href="#为了node节点加入必备组件" class="headerlink" title="为了node节点加入必备组件"></a>为了node节点加入必备组件</h3><p>成功后会显示</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630124600952.png" alt="image-20240630124600952"></p><p>然后主节点查看加入集群的节点</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630125420559.png" alt="image-20240630125420559"></p><p>ps:如果报couldn’t get current server API group list: Get “<a href="http://localhost:8080/api?timeout=32s&quot;">http://localhost:8080/api?timeout=32s&quot;</a>: dial tcp 127.0.0.1:8080: connect: connection refused的话，大概率是终端断连导致之前export的环境变量失效了，可以在/etc/environment文件中加入KUBECONFIG=”/etc/kubernetes/admin.conf”以使环境变量永久生效</p>]]></content>
    
    
    <summary type="html">基于Docker部署Kubernetes</summary>
    
    
    
    <category term="docker" scheme="https://kalyan-zitiu.github.io/categories/docker/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/docker/K8S/"/>
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>javaEE</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/02/javaEE/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/02/javaEE/</id>
    <published>2024-04-02T07:00:00.000Z</published>
    <updated>2024-06-30T11:29:41.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码连接"><a href="#代码连接" class="headerlink" title="代码连接"></a>代码连接</h2><p><a href="https://github.com/Kalyan-zitiu/Studyroomreservationsystem">https://github.com/Kalyan-zitiu/Studyroomreservationsystem</a></p><h2 id="需求说明以及功能分析"><a href="#需求说明以及功能分析" class="headerlink" title="需求说明以及功能分析"></a>需求说明以及功能分析</h2><h3 id="用户用例需求分析及其功能"><a href="#用户用例需求分析及其功能" class="headerlink" title="用户用例需求分析及其功能"></a>用户用例需求分析及其功能</h3><p>  如下图，普通用户：1.查看自习室情况：普通用户可以查看自习室的预约情况。2.预约自习室：普通用户可以预约自习室。3.取消预约：普通用户可以取消已预约的自习室。4.查看预约情况：普通用户可以查看自己的预约情况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630190654093.png" alt="image-20240630190654093"></p><p>如下图管理员用例图，1.删除自习室：管理员可以删除系统中的自习室。2.添加自习室：管理员可以在系统中新增自习室。3.修改自习室：管理员可以对现有的自习室信息进行修改。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191300868.png" alt="image-20240630191300868"></p><p>如下图超级管理员用例图，1.添加自习室：超级管理员可以在系统中新增自习室。2.删除自习室：超级管理员可以删除系统中的自习室。3.修改自习室：超级管理员可以对现有的自习室信息进行修改。4.查看使用统计：超级管理员可以查看自习室的使用统计数据。5.管理用户：超级管理员可以管理系统中的用户，包括添加删除修改用户信息。6.搜索普通用户：超级管理员可以搜索普通用户的信息。</p><p>​                                                                      <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps3.jpg" alt="img"> </p><h3 id="系统总操作流程分析"><a href="#系统总操作流程分析" class="headerlink" title="系统总操作流程分析"></a>系统总操作流程分析</h3><p>如下图，操作流程图展示了一个自习室预约系统的总操作流程。用户首先进行登录，输入用户名和密码后，系统会检查输入是否为空。如果为空，系统会提示信息不为空并要求重新输入。如果不为空，系统继续检查用户名和密码是否正确。如果不正确，系统会提示信息不正确并返回重新输入步骤。如果正确，系统会进行身份权限判断，根据用户权限执行相应的功能处理。整个过程在执行完相关功能处理后结束。这个流程图主要描述了登录验证和权限判断的过程，但缺少注册、找回密码、不同权限的具体功能分支及错误处理等环节。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191401981.png" alt="image-20240630191401981"></p><h2 id="系统概要设计"><a href="#系统概要设计" class="headerlink" title="系统概要设计"></a>系统概要设计</h2><h3 id="系统概述以及设计"><a href="#系统概述以及设计" class="headerlink" title="系统概述以及设计"></a>系统概述以及设计</h3><p>自习室预约系统是一种在线平台，旨在为学生和教职员工提供便捷、高效的自习室预订服务。该系统通过采用先进的数字化管理手段，实现了自习室资源的合理分配和高效利用，用户可以随时随地进行自习室的查看、预订、取消和管理，以满足其个性化学习需求。如下图系统工作原理图，展示了自习室预约系统的执行过程：客户端向Web服务器发送请求，Web服务器对请求进行验证后，向数据库检索相关数据或更新信息。数据库完成操作后，将结果传送回Web服务器，Web服务器再将最终结果回发给客户端。整个流程确保数据的实时性和准确性</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191517073.png" alt="image-20240630191517073"></p><h3 id="系统结构设计"><a href="#系统结构设计" class="headerlink" title="系统结构设计"></a>系统结构设计</h3><p>如下图系统结构图，展示自习室预约系统的功能结构图，包含普通用户、管理员和超级管理员三个角色。普通用户可以查看自习室情况、进行预约和取消预约；管理员可以管理预约情况、添加、修改和删除自习室信息；超级管理员则具有更高级别的权限，不仅可以管理用户，还能查看使用统计，以及添加、修改和删除自习室信息。图中用方框和连接线清晰地展示了各角色的功能模块和操作权限。</p><p>​                                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps6.jpg" alt="img"> </p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><ol><li>数据存储</li></ol><p>数据库包含以下主要实体：用户、角色、自习室、自习室详情、预约信息、用户角色。各实体表的设计如下：</p><p>用户表存储用户ID、用户名、密码、手机号和邮箱。</p><p>角色表存储角色ID、角色名称、角色标识和角色状态。</p><p>自习室表存储自习室ID、自习室编号、容量、设施和类型。</p><p>自习室详情表存储自习室地址、预约次数和使用次数。</p><p>预约信息表记录预约ID、用户ID、自习室详情ID、预约时间、状态原因和结束时间。</p><ol start="2"><li>数据管理</li></ol><p>数据库通过标准的SQL命令行管理工具以及数据库管理软件进行管理，包括数据的插入、更新、删除和查询。此外，视图、存储过程和触发器简化了数据管理操作和维护数据完整性。</p><ol start="3"><li>数据检索</li></ol><p>通过SQL查询语句进行数据检索。例如：</p><p>查询用户的预约记录。</p><p>查询某段时间内某自习室的使用情况。</p><p>在重要字段（如用户ID、自习室ID、预约时间）上建立索引，以提高检索效率。</p><ol start="4"><li>数据安全</li></ol><p>数据安全包括：</p><p>用户认证：使用加密和散列技术保护用户密码。</p><p>权限控制：通过角色和权限管理控制不同用户对数据库的访问权限。</p><p>数据传输：使用SSL/TLS保护数据传输安全。</p><p>日志记录：记录数据库访问和修改行为，以便审计。</p><ol start="5"><li>数据一致性</li></ol><p>数据库通过以下策略确保数据一致性：</p><p>主键约束：保证每个表的主键唯一且非空。</p><p>外键约束：确保引用完整性（如预约记录的用户ID必须在用户表中存在）。</p><p>触发器：自动检查和修正数据的一致性。</p><ol start="6"><li>数据完整性</li></ol><p>数据库使用以下方法保证数据完整性：</p><p>实体完整性：确保每个表的主键唯一且非空。</p><p>参照完整性：通过外键约束保持表间关系一致。</p><p>业务规则：使用存储过程和触发器实现业务逻辑，防止数据失效。</p><p>如下图用户信息实体图，用户信息实体包含以下属性：用户ID、用户名、密码、手机号和邮箱。用户实体与预约信息（reservation）实体之间存在一对多的关系，即每个用户可以有多个预约记录。用户实体还与用户角色（user_role）实体存在一对多的关系，表示每个用户可以对应多个角色，从而实现不同的权限和功能。该设计保证了用户的基本信息与其预约和角色信息的有效关联。</p><p>如下图角色信息实体图，角色信息实体（role）包含以下属性：角色ID、角色名字、角色标识和角色状态。角色信息实体与用户角色（user_role）实体之间存在一对多的关系，即每个角色可以对应多个用户角色记录。这个设计确保了每个角色的信息能够与多个用户相关联，从而在系统中实现多用户角色的管理和权限分配。</p><p>​                                                                          <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps8.jpg" alt="img"> </p><p>如下图自习室详情信息实体图，自习室详情信息实体包含以下属性：自习室详情ID、自习室地址、自习室ID、自习室预约次数和自习室使用次数。自习室详情信息实体与自习室信息实体之间存在一对一的关系，即每个自习室对应唯一的自习室详情记录。这个设计确保了每个自习室都有独立且详细的预订和使用情况描述，从而可以有效管理和监控每个自习室的使用状态。</p><p>​                                                                         <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps9.jpg" alt="img"> </p><p>如下图预约系统实体图，预约信息实体包含以下属性：预约ID、用户ID、自习室详情ID、预约开始时间、预约状态、取消或拒绝理由以及预约结束时间。预约信息实体与用户信息实体之间存在多对一关系，即多个预约记录可以对应同一个用户。同时，预约信息实体与自习室详情实体之间也存在多对一关系，即多个预约记录可以对应同一个自习室详情。这种设计确保了预约信息能够准确关联到具体的用户和自习室详情，从而实现全面的预约管理。</p><p>​                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192344417.png" alt="image-20240630192344417"></p><p>如下图，自习室实体图，自习室信息实体包含以下属性：自习室ID、自习室编号、总容量、可用设备和自习室类型。自习室信息实体与自习室详情信息实体之间存在一对一的关系，即每个自习室对应唯一的自习室详情记录。这个设计确保了每个自习室在系统中都有详细且独立的描述，从而可以准确记录和管理自习室的使用情况、容量和设备等信息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192355875.png" alt="image-20240630192355875"></p><p>如下表3-1，自习室表存储每个自习室的基本信息，包括自习室ID、自习室编号、容量、设施和类型。在系统内，自习室表用于记录和管理所有自习室的基础信息，并与自习室详情表存在一对一关系。这种关系确保每个自习室都有唯一的详细信息记录，用于详细描述自习室的位置和使用情况。</p><p>表3-1 自习室表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>study_room_id</td><td>int</td><td>11</td><td>主键非空</td><td>Id</td></tr><tr><td>study_room_num</td><td>varchar</td><td>50</td><td>无</td><td>自习室可用数量</td></tr><tr><td>capacity</td><td>int</td><td>50</td><td>无</td><td>总容量</td></tr><tr><td>Type</td><td>varchar</td><td>50</td><td>无</td><td>自习室类型</td></tr><tr><td>facilities</td><td>varchar</td><td>50</td><td>无</td><td>自习室设备</td></tr></tbody></table><p>如下表3-2，自习室详情表包含自习室的详细信息，包括位置、自习室ID、预约频率和使用频率。在系统内，自习室详情用于进一步描述自习室的具体信息，如地理位置和使用统计信息。它与自习室表存在一对一关系，确保每个自习室都有唯一的详细信息记录。</p><p>表3-2 自习室详情表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>自习室Id</td></tr><tr><td>Location</td><td>varchar</td><td>50</td><td>无</td><td>自习室地址</td></tr><tr><td>study_room_id</td><td>int</td><td>11</td><td>无</td><td>自习室归属Id</td></tr><tr><td>reservation_frequency</td><td>int</td><td>11</td><td>无</td><td>自习室预约状态</td></tr><tr><td>usage_frequency</td><td>int</td><td>11</td><td>无</td><td>自习室使用次数</td></tr><tr><td>capecity</td><td>int</td><td>11</td><td>无</td><td>容量</td></tr></tbody></table><p>  如下表3-3，用户表包含用户的基本信息，包括用户ID、用户名、密码、手机号和邮箱。系统内，用户表用于存储和管理所有用户的信息，并通过多对一关系与预约记录和用户角色关联，以便管理用户的预约活动和角色分配。</p><p>表3-3 用户表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>User_id</td><td>int</td><td>11</td><td>主键非空</td><td>用户Id</td></tr><tr><td>password</td><td>varchar</td><td>50</td><td>无</td><td>密码</td></tr><tr><td>phone</td><td>mediumtext</td><td>11</td><td>无</td><td>用户手机号码</td></tr><tr><td>email</td><td>varchar</td><td>11</td><td>无</td><td>用户邮箱</td></tr><tr><td>User_name</td><td>varchar</td><td>50</td><td>无</td><td>用户姓名</td></tr></tbody></table><p>  如下表3-4，预约表记录每个预约的详细信息，包括预约ID、用户ID、自习室详情ID、预约时间、状态、取消或拒绝的原因和结束时间。在系统内，预约表用于跟踪和管理所有的自习室预约记录。它通过多对一关系与用户表和自习室详情表关联，确保每个预约记录都与特定的用户和自习室关联。</p><p>表3-4 预约信息表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>reservation_id</td><td>int</td><td>11</td><td>主键非空</td><td>预约Id</td></tr><tr><td>User_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>Study_details_id</td><td>int</td><td>11</td><td>无</td><td>自习室详情Id</td></tr><tr><td>time_start</td><td>datetime</td><td>50</td><td>无</td><td>预约开始时间</td></tr><tr><td>time_end</td><td>datetime</td><td>50</td><td>无</td><td>预约结束时间</td></tr><tr><td>status</td><td>tinyint</td><td>11</td><td>无</td><td>预约状态</td></tr><tr><td>reason</td><td>varchar</td><td>50</td><td>无</td><td>申请原因</td></tr></tbody></table><p>  如下表3-5，角色表包含每个角色的信息，包括角色ID、角色名称、角色标识和状态。在系统内，角色表用于定义和存储不同的角色，并与用户角色表存在多对一关系。这样，每个角色可以分配给多个用户，方便进行权限管理和角色分配。</p><p>表3-5 角色表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色Id</td></tr><tr><td>role_name</td><td>varchar</td><td>255</td><td>无</td><td>角色名字</td></tr><tr><td>role_sign</td><td>varchar</td><td>30</td><td>无</td><td>角色标识</td></tr><tr><td>status</td><td>tinyint</td><td>11</td><td>无</td><td>角色状态</td></tr></tbody></table><p>  如下表3-6，用户角色表记录用户与其分配角色之间的关系，包括用户角色ID、用户ID和角色ID。在系统内，用户角色表用来管理和存储用户与角色的映射关系。它通过多对一关系与用户表和角色表关联，确保用户可以拥有相应的角色和权限。</p><p>表3-6 用户角色表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>user_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>role_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr></tbody></table><p>  如下表3-7，自习室管理员表包含管理员的信息，包括管理员ID、用户ID和自习室ID。在系统内，自习室管理员表用于指定和管理自习室的管理员。它通过多对一关系与用户表和自习室表关联，确保每个自习室有特定的管理员进行管理和维护。</p><p>表3-7 自习室管理表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>admin_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>user_id</td><td>int</td><td>11</td><td>无</td><td>用户Id</td></tr><tr><td>study_room_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr></tbody></table><p>  如下表3-8，角色权限表存储角色与权限之间的关系，包括角色权限ID、角色ID和权限ID。在系统内，角色权限表用于管理和记录每个角色与其权限之间的映射关系。它通过多对一关系与角色表和权限表关联。</p><p>表3-8 角色权限表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>11</td><td>主键非空</td><td>角色权限Id</td></tr><tr><td>role_id</td><td>int</td><td>11</td><td>无</td><td>角色Id</td></tr><tr><td>permission_id</td><td>int</td><td>11</td><td>无</td><td>权限Id</td></tr></tbody></table><p>如下表3-9，权限表存储权限的信息，包括权限ID、权限名称和权限简化表示。在系统内，权限表用于定义和存储不同的权限，并通过多对一关系与角色权限表关联。这样，每个权限可以分配给多个角色，实现灵活的权限管理。</p><p>表3-9 权限表</p><table><thead><tr><th>列名</th><th>数据类型</th><th>长度</th><th>约束</th><th>详情</th></tr></thead><tbody><tr><td>permsission_id</td><td>int</td><td>11</td><td>主键非空</td><td>角色用户Id</td></tr><tr><td>permission_simplify</td><td>varchar</td><td>20</td><td>无</td><td>权限简化标识</td></tr><tr><td>permsission_name</td><td>varchar</td><td>255</td><td>无</td><td>权限名称</td></tr></tbody></table><h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><p>用户认证：采用安全认证机制，如密码哈希存储用户密码，使用令牌或会话管理用户登录状态。</p><p>权限控制：根据用户角色进行权限控制，确保只有具有相应权限的用户才能执行特定操作。</p><p>数据保护：对敏感数据进行加密存储和传输，确保数据的机密性和完整性。</p><h2 id="系统详细设计"><a href="#系统详细设计" class="headerlink" title="系统详细设计"></a>系统详细设计</h2><h3 id="登录功能模块"><a href="#登录功能模块" class="headerlink" title="登录功能模块"></a>登录功能模块</h3><p>如下图，在自习室预约系统的登录时序图中，用户首先在浏览器中输入用户名和密码并点击登录。接着，浏览器通过HTTP请求将表单数据发送到服务器，服务器查询数据库以验证用户名和密码。如验证成功，服务器生成会话令牌，如JWT或Session ID，并将其发送回浏览器，同时浏览器将令牌保存在CookieLocalStorage中。最后，服务器发送登录成功的信息，并可能重定向用户到主页面或个人主页。这一过程清晰展示了用户登录流程的各个关键步骤及各组件间的交互</p><p>​                               <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630191841675.png" alt="image-20240630191841675"></p><p>如下图3,用户首先在浏览器中打开自习室预约系统的登录页面，并在页面的表单中输入用户名和密码。然后，用户点击“登录”按钮，表单数据通过HTTP请求发送到服务器。服务器接收到请求后，提取用户名和密码，并查询数据库以验证用户名是否存在。如果用户名存在，服务器会对比存储的哈希密码和用户输入的密码。如果用户名或密码不匹配，服务器向用户返回登录失败的信息。如果用户名密码匹配，服务器生成会话令牌，并将令牌发送给用户的浏览器。随后，浏览器收到会话令牌（如JWT或Session ID）并将其保存到Cookie或LocalStorage中。最后，服务器向用户浏览器返回登录成功的信息，并重定向到系统的主页面或用户的个人主页。把这部分的时序图的从上面内容提取出来。</p><p>​                                                   <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps13.jpg" alt="img"> </p><h3 id="管理员功能模块"><a href="#管理员功能模块" class="headerlink" title="管理员功能模块"></a>管理员功能模块</h3><p>添加自习室：</p><p>如下图，浏览器将这些信息通过HTTP请求发送到服务器。服务器接收到请求后，首先对数据进行完整性和合法性检查，确保所有必填字段都有值且数据格式正确。然后，服务器将验证通过的自习室信息存入数据库。如果存储成功，服务器返回成功信息给浏览器；如果失败，则返回错误信息。最后，浏览器接收到服务器的响应并更新页面，根据返回的信息显示添加成功或失败的结果提示。</p><p>​                               <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192418134.png" alt="image-20240630192418134"></p><p>如下图所示，管理员访问自习室预约系统的添加自习室页面，在表单中输入自习室的详细信息并点击“添加”按钮</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192428678.png" alt="image-20240630192428678"></p><p>删除自习室：</p><p>如下图，该请求通过HTTP发送到服务器。服务器接收到请求后，会进行权限检查和请求有效性验证，确保管理员具有相应的操作权限。一旦验证通过，服务器指示数据库删除相关的自习室记录。数据库执行删除操作，服务器将结果返回给浏览器，显示该自习室已被成功删除或删除失败的信息。</p><p>​                                                        <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps16.jpg" alt="img"> </p><p>如下图所示，管理员首先登录到自习室预约系统，并访问自习室管理页面，该页面列出了所有注册的自习室信息。管理员找到并选择他们想要删除的自习室，并点击该自习室旁的“删除”按钮以发起删除请求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192435966.png" alt="image-20240630192435966"></p><p>修改自习室：</p><p>如下图，编辑完成后，管理员点击“提交”按钮，浏览器会将修改后的信息以HTTP请求的形式发送到服务器。服务器接收这些信息后进行权限验证和数据合法性检查，一旦确认无误，服务器会指示数据库更新这些自习室信息。数据库完成更新操作后，服务器根据操作结果向管理员返回一个成功或失败的响应。浏览器接收到响应后，将页面更新以显现修改成功或失败的通知。这个过程不仅确保了数据的准确性和操作的安全性，还通过即时反馈帮助管理员确认修改操作的最终结果。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192447410.png" alt="image-20240630192447410"></p><p>如下图所示，在自习室预约系统中，管理员首先登录并导航到自习室管理页面，这里列出了所有自习室的详细信息。管理员选择需要修改的自习室，并点击相对应的“编辑”按钮，这将打开一个带有当前自习室信息的表单。管理员在此表单中可以更新自习室的各类信息，如名称、容量、地点及开放时间等。</p><p>​                                                                    <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps19.jpg" alt="img"> </p><h3 id="用户功能模块"><a href="#用户功能模块" class="headerlink" title="用户功能模块"></a>用户功能模块</h3><p>预约自习室：</p><p>如下图，编辑完成后，管理员点击“提交”按钮，浏览器会将修改后的信息以HTTP请求的形式发送到服务器。服务器接收这些信息后进行权限验证和数据合法性检查，一旦确认无误，服务器会指示数据库更新这些自习室信息。数据库完成更新操作后，服务器根据操作结果向管理员返回一个成功或失败的响应。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192457889.png" alt="image-20240630192457889"></p><p>如下图，3-22所示，在自习室预约系统中，管理员首先登录并导航到自习室管理页面，这里列出了所有自习室的详细信息。管理员选择需要修改的自习室，并点击相对应的“编辑”按钮，这将打开一个带有当前自习室信息的表单。管理员在此表单中可以更新自习室的各类信息，如名称、容量、地点及开放时间等。</p><p>​                                                         <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps21.jpg" alt="img"> </p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192512225.png" alt="image-20240630192512225"></p><p>取消预约：</p><p>如下图所示，用户首先登录到系统并导航到自己的预约历史或当前预约页面。在这里，所有的活跃预约都会被列出，包括每个预约的时间、自习室编号以及取消预约的选项。用户选择需要取消的预约后，点击“取消预约”按钮，系统会提示用户确认是否要取消。一旦用户确认取消，系统将自动发送取消请求到服务器，服务器验证请求的有效性后，更新数据库以反映预约被取消的状态。完成后，系统会通知用户预约已成功取消，并更新页面以显示最新的预约状态。用户首先登录到系统并导航到自己的预约历史或当前预约</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192521588.png" alt="image-20240630192521588"></p><p>查看自习室情况：</p><p>如下图所示，用户可以通过系统提供的自习室状态页面来查看各自习室的当前状态和预约情况。用户访问该页面后，系统展示所有自习室的列表，包括每间自习室的位置、容量和当前的占用情况。用户可以查看每个自习室的详细信息，如开放时间和特定时间段内的预约状况，这有助于用户在预约前做出更明智的选择。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192525619.png" alt="image-20240630192525619"></p><p>查看预约情况：</p><p>如下图所示，用户需要了解自己的预约历史，以便于管理和规划个人时间。系统允许用户访问一个专门的页面，列出他们过去和即将进行的所有预约详情。这包括预约的日期、时间、自习室号码以及预约的状态。用户可以通过这一功能轻松跟踪自己的预约状况，并进行相应的规划和调整。</p><p>​                                                           <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps25.jpg" alt="img"> </p><h3 id="超级管理员功能模块"><a href="#超级管理员功能模块" class="headerlink" title="超级管理员功能模块"></a>超级管理员功能模块</h3><p>搜索用户：</p><p>如下图，服务器接收到请求后，解析其中的搜索关键字，并基于这些关键字对数据库进行查询操作，以找到符合条件的用户信息。一旦数据库查询完成，服务器会根据查询结果生成相应的响应信息。如果查询成功并找到了匹配的用户，服务器会将这些用户数据作为响应发送回浏览器；如果没有找到匹配的用户，则会发送一个表示无结果的提示信息。浏览器接收到这些信息后，便会更新用户管理页面，显示出搜索结果或者是没有找到任何用户的提示。整个过程不仅保证了超级管理员能够快速准确地获取用户信息，还优化了用户管理的效率。</p><p>​                                                             <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps26.jpg" alt="img"> </p><p>如下图所示，超级管理员首先需要登录到自习室预约系统，并导船到用户管理页面。这个页面包括一个搜索框，允许超级管理员输入特定的搜索条件，如用户的用户名、邮箱或其他相关属性。输入完成后，超级管理员点击“搜索”按钮，此时浏览器会将这些搜索条件通过HTTP请求形式发送给服务器。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192544783.png" alt="image-20240630192544783"></p><p>管理用户：</p><p>如下图，此时系统会将这一角色更改请求通过HTTP请求发送到服务器。服务器接收到请求后，首先进行权限验证，确保当前操作员有权执行这一角色修改操作。若权限验证通过，服务器则指令数据库更新该用户的角色信息。数据库更新完成后，服务器会根据操作的结果生成响应，并将其发送回浏览器。浏览器接收到这一信息后，会更新用户管理页面，并向超级管理员显示角色更新成功或失败的提示。这个完整的流程不仅保证了用户角色管理的灵活性和系统的权限控制，还通过实时反馈使得超级管理员能够即刻知晓操作结果，从而提升了用户管理的效率和准确性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192553947.png" alt="image-20240630192553947"></p><p>如下图所示，在自习室预约系统中，超级管理员首先需要通过浏览器登录系统，并导航至用户管理页面。此页面详细展示了系统中所有用户的列表，包括他们的基本信息和当前分配的角色。超级管理员浏览这个列表，并选择想要修改角色的特定用户。选择用户后，超级管理员可以通过一个界面元素（通常是下拉菜单）来指定新的用户角色，比如将用户从普通用户改为管理员或其他角色。一旦选择了新的角色，超级管理员会点击“更新”或“提交”按钮。</p><p>​                                                                <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192605509.png" alt="image-20240630192605509"></p><p>​                                                                                  <img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps30.jpg" alt="img"> </p><p>查看使用统计：</p><p>如下图所示，通过合法的认证流程登录系统。登录后，超级管理员可以导航到系统提供的“统计”或“报表”页面，这里集中展示了自习室使用的各种统计数据。这些统计数据通常包括但不限于用户预约次数、自习室使用频率、高峰使用时段、取消预约的次数以及任何特定时间段内的用户活动情况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192613060.png" alt="image-20240630192613060"></p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="系统测试综述"><a href="#系统测试综述" class="headerlink" title="系统测试综述"></a>系统测试综述</h3><p>综述：</p><p>在自习室预约系统中，我们聚焦于测试查看自习室情况、预约和取消预约功能以确认普通用户的交互正确性；同时，管理员的添加、删除和修改自习室信息功能进行深入测试以保证系统信息的准确更新；对于超级管理员功能，特别测试了查看使用统计、管理用户以及搜索用户信息的准确性和效率。这些测试是为了确保系统各功能模块不仅符合设计要求，同时也提供了用户友好、安全和高效的操作体验，从而在系统投入实际使用前，能够识别并修正潜在问题，进一步提升服务的质量和用户满意度。通过全面的测试策略，我们的目标是确保自习室预约系统在提供必需服务的同时，保护用户信息的安全，同时确保系统跨平台的兼容性和高效性。测试覆盖了从基本功能到用户最终接受的每个阶段，确保发现并修复潜在的问题，从而提供一个既易于使用也高度可靠的系统，满足最终用户的期望和需求。这些测试不仅提高了系统的整体质量，也提升了用户信任。</p><p>测试类型及其目的：</p><p>功能测试：主要验证系统中的核心功能，如预约准确性、用户管理、通知系统以及时间选择功能。这项测试确保所有功能按预期工作，没有逻辑错误或缺陷，从而保证系统操作的正确性和预期行为。</p><p>性能测试：着重检查系统在高负载或高压力条件下的表现。该测试评估系统的响应速度和稳定性，确保在大量用户同时使用时系统能够有效地处理请求，从而提供持续的服务质量。</p><p>安全性测试：保证用户数据的安全性和隐私。通过这项测试，我们评估系统防止未授权访问以及数据泄露的能力，关注保护用户信息和转输安全。</p><p>兼容性测试：验证软件在不同的设备、操作系统和浏览器上的运行稳定性。这确保所有用户无论使用何种技术平台都能获得一致的体验。</p><p>用户接受测试：通过实际用户的操作反馈来评估系统的实用性和满意度。这项测试帮助我们了解用户在日常使用中遇到的问题和不便，以便进行调整和优化，提升用户体验。</p><h3 id="关键测试"><a href="#关键测试" class="headerlink" title="关键测试"></a>关键测试</h3><p>接口测试：</p><p>如下图所示，登录接口测试用Postman进行用户登录测试的过程。其中，发送了一个包含用户名和密码的POST请求到本地服务器，并成功接收到JSON格式响应数据。这表明登录操作被成功处理，用户被验证为“普通用户”。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192633876.png" alt="image-20240630192633876"></p><p>如下图所示，预约查询接口测试使用Postman来获取预约信息的过程。在图中，执行了一个GET请求至<a href="http://localhost:8989/reservations%E4%BB%A5%E6%9F%A5%E8%AF%A2%E9%A2%84%E7%BA%A6%E6%95%B0%E6%8D%AE%E3%80%82%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81200%E8%A1%A8%E6%98%8E%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E9%A1%BA%E5%88%A9%E3%80%82%E8%BF%94%E5%9B%9E%E7%9A%84JSON%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%90%AB%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E9%A2%84%E7%BA%A6%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%BF%99%E9%87%8C%E6%98%BE%E7%A4%BA%E4%BA%86%E4%B8%80%E6%9D%A1%E9%A2%84%E7%BA%A6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E3%80%82%E8%AF%A5%E9%A2%84%E7%BA%A6%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9A%E9%A2%84%E7%BA%A6ID%E4%B8%BA1%EF%BC%8C%E9%A2%84%E7%BA%A6%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%BA2%EF%BC%88%E5%8F%AF%E8%83%BD%E8%A1%A8%E7%A4%BA%E6%9F%90%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%94%E5%A6%82&quot;%E5%B7%B2%E7%A1%AE%E8%AE%A4&quot;%EF%BC%89%EF%BC%8C%E7%94%A8%E6%88%B7%E5%A7%93%E5%90%8D%E4%B8%BA%E7%A9%BA%EF%BC%8C%E9%A2%84%E7%BA%A6%E7%B1%BB%E5%9E%8B%E4%B8%BA&quot;%E8%AE%BE%E6%96%BD%E9%A2%84%E7%BA%A6&quot;%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BD%8D%E7%BD%AE%E4%B8%BA&quot;A2-209&quot;%EF%BC%8C%E9%A2%84%E7%BA%A6%E5%8E%9F%E5%9B%A0%E6%98%AF&quot;%E5%AD%A6%E4%B9%A0%E8%AE%A8%E8%AE%BA&quot;%E3%80%82%E9%A2%84%E7%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%BE%E6%96%BD%E5%8C%85%E6%8B%AC&quot;%E7%94%B5%E8%84%91%E5%92%8C%E6%8A%95%E5%BD%B1%E4%BB%AA&quot;%E3%80%82%E8%BF%99%E5%9B%BE%E6%9C%89%E6%95%88%E6%BC%94%E7%A4%BA%E4%BA%86%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87API%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BA%A6%E8%AF%A6%E6%83%85%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%91%E7%9D%A3%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F%E5%B0%A4%E4%B8%BA%E9%87%8D%E8%A6%81%E3%80%82">http://localhost:8989/reservations以查询预约数据。请求成功，状态码200表明查询过程顺利。返回的JSON响应数据包含一系列的预约信息，这里显示了一条预约的详细信息。该预约包含多个字段：预约ID为1，预约状态码为2（可能表示某种状态，比如&quot;已确认&quot;），用户姓名为空，预约类型为&quot;设施预约&quot;，具体位置为&quot;A2-209&quot;，预约原因是&quot;学习讨论&quot;。预约相关的设施包括&quot;电脑和投影仪&quot;。这图有效演示了如何通过API接口获取系统中的预约详情，这对于管理和监督预约系统尤为重要。</a></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630192639167.png" alt="image-20240630192639167"></p><p>如下图所示，审核接口测试使用Postman执行PUT请求以修改预约信息的操作。请求成功执行，返回表明预约信息已经被成功更新。这表明API已经正确处理了修改预约信息的请求。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps34.jpg" alt="img"> </p><p>如下图所示，获取用户列表接口测试使用Postman执行GET请求从服务器获取用户角色信息的过程。请求成功返回，展示了包括用户名、角色、电邮、电话和用户ID在内的详细信息，用于描绘系统中某个用户的权限和角色概况。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/wps35.jpg" alt="img"> </p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>如下表3-10，这组测试用例关注于验证系统管理用户的功能，包括添加新用户，修改现有用户信息，以及删除用户。各个用例检验系统是否能够成功执行用户管理任务并给出适当的反馈消息。</p><p>表3-10 管理用户测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>添加新用户</td><td>检验添加用户功能的执行</td><td>成功添加用户，系统显示添加成功消息</td><td>成功添加，消息正确显示</td></tr><tr><td>修改现有用户信息</td><td>检验修改用户信息的正确性</td><td>成功修改用户信息，系统显示更新成功消息</td><td>修改成功，消息正确显示</td></tr><tr><td>删除用户</td><td>检验删除用户的功能</td><td>成功删除用户，系统显示删除成功消息</td><td>用户成功删除，确认消息显示</td></tr></tbody></table><p>如下表3-11，测试用例集中于系统的用户搜索功能，包括对存在的用户的精确搜索，对不存在用户的搜索处理，以及使用模糊匹配进行的多用户搜索，确认系统能否在这些情况下准确显示用户信息或相关提示。</p><p>表3-11 搜索用户测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>搜索存在的用户</td><td>检验搜索功能的准确性</td><td>系统正确显示匹配的用户信息</td><td>搜索成功，用户信息准确显示</td></tr><tr><td>搜索不存在的用户</td><td>测试系统的搜索容错能力</td><td>系统显示无结果，提示用户找不到匹配信息</td><td>搜索结果为空，系统正确显示无匹配信息提示</td></tr><tr><td>使用模糊匹配搜索多个用户</td><td>检验模糊搜索功能的效果</td><td>系统显示所有相关匹配的用户信息</td><td>模糊搜索成功，相关用户信息被展示</td></tr></tbody></table><p>如下表3-12，这些测试用例旨在评估系统在显示自习室使用统计信息上的表现，无论是在没有使用记录的情况下还是有使用记录时，系统都应正确显示相关统计信息。</p><p>表3-12 查看使用统计测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>没有任何自习室使用记录时查看统计</td><td>检验统计功能正常情况下的显示</td><td>统计结果显示无使用记录</td><td>系统正确显示无使用记录</td></tr><tr><td>自习室有使用记录时查看统计</td><td>检验统计功能反映实际使用情况</td><td>统计结果详细反映每个自习室的使用情况</td><td>统计正确，详细展示每个自习室的使用记录</td></tr></tbody></table><p>如下表3-13，这一组测试用例检查系统在不同情况下（全部空闲、部分预约、全部预约满）展示自习室状态的准确性。</p><p>表3-13 查看自习室情况测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>自习室全部空闲时进行查看</td><td>检查系统显示所有自习室空闲情况</td><td>系统显示所有自习室处于空闲状态</td><td>系统正确显示所有自习室空闲状态</td></tr><tr><td>自习室部分被预约时进行查看</td><td>检查系统显示部分自习室预约情况</td><td>系统显示部分自习室被预约，其余空闲</td><td>系统正确反映部分自习室被预约，其余空闲</td></tr><tr><td>自习室全部被预约满时查看</td><td>检查系统显示所有自习室被预约情况</td><td>系统显示所有自习室处于被预约状态</td><td>系统正确显示所有自习室被预约状态</td></tr></tbody></table><p>如下表3-14，用例专注于系统处理自习室预约的能力，包括成功预约空闲的自习室、处理预约冲突以及连续预约多间自习室的情况，确保系统在这些场景下能正确执行并提供反馈。</p><p>表3-14 预约自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>预约一间未被预约的自习室</td><td>测试能否成功预约自习室</td><td>成功预约，系统显示预约成功信息</td><td>预约成功，系统显示预约成功信息</td></tr><tr><td>尝试预约已被他人预约满的自习室</td><td>测试系统处理冲突预约的能力</td><td>系统显示错误信息，指出自习室已被预约</td><td>尝试失败，系统正确显示错误信息</td></tr><tr><td>连续预约多间自习室</td><td>测试系统处理多项预约的能力</td><td>成功预约多间自习室，显示预约成功信息</td><td>成功预约多间，系统正确显示预约成功信息</td></tr></tbody></table><p>如下表3-15，测试集包括检验用户取消自己之前成功的自习室预约，并测试系统防止用户撤销他人预约的安全性和权限管理。目的是确保系统在处理取消操作时既符合预期又维护了适当的访问控制。</p><p>表3-15 取消预约测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>取消自己之前成功预约的自习室</td><td>测试能否取消自己的预约</td><td>成功取消预约，系统显示取消成功信息</td><td>预约取消成功，实际结果与预期相符</td></tr><tr><td>尝试取消他人的预约</td><td>测试系统的安全性和权限管理</td><td>系统显示错误信息，不允许取消他人预约</td><td>系统正确显示错</td></tr></tbody></table><p>如下表3-16，这些用例测试系统如何处理自习室的删除请求，包括已安排和未安排预约的自习室，以及尝试删除不存在的自习室。这一系列测试旨在确保删除操作在不同状况下被正确处理，提供适当的反馈和错误处理。</p><p>表3-16 删除自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>删除系统中未被预约的自习室</td><td>检验删除功能的正常逻辑</td><td>成功删除，系统更新状态表示自习室已删除</td><td>成功删除自习室，系统正确显示删除状态</td></tr><tr><td>删除系统中已被预约的自习室</td><td>检验系统如何处理预约中的删除请求</td><td>系统阻止删除或需特殊处理</td><td>系统成功阻止删除，提示自习室正在被预约中</td></tr><tr><td>尝试删除不存在的自习室</td><td>测试系统的错误处理能力</td><td>系统显示错误信息，删除失败</td><td>系统正确显示错误信息，指出自习室不存在</td></tr></tbody></table><p>如下表3-17，此部分测试用例关注于系统添加新自习室的功能，验证系统如何处理新自习室的添加，包括重复自习室编号的错误处理和在信息输入不完整时的系统反馈。</p><p>表3-17 添加自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>成功在系统中添加一个新的自习室</td><td>检验添加功能的正常逻辑</td><td>系统显示添加成功并更新自习室列表</td><td>添加成功，系统正确显示自习室列表更新</td></tr><tr><td>尝试添加已存在的自习室编号</td><td>测试系统处理重复添加的能力</td><td>系统显示错误，指出自习室编号重复</td><td>系统成功显示错误信息，防止重复添加</td></tr><tr><td>添加自习室时未填写完整信息</td><td>测试系统的输入验证功能</td><td>系统显示错误并要求必要信息完整</td><td>系统正确显示错误，要求填写必要信息</td></tr></tbody></table><p>如下表3-18，这组测试用例评估了修改自习室信息的功能，测试了合法和非法修改案例，包括尝试修改不存在的自习室以及输入非法数据时的系统响应。目标是验证系统在更新自习室信息时的可靠性和错误处理能力。</p><p>表3-18 修改自习室测试用例表</p><table><thead><tr><th>测试用例描述</th><th>目标</th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>修改自习室的信息</td><td>检验修改功能的正常逻辑</td><td>成功修改，系统显示更新成功消息</td><td>修改成功，系统正确显示更新成功消息</td></tr><tr><td>尝试修改不存在的自习室信息</td><td>测试系统的错误处理能力</td><td>系统显示错误信息，修改失败</td><td>系统正确显示错误信息，指出自习室不存在</td></tr><tr><td>修改自习室信息时输入非法数据</td><td>测试系统的输入验证功能</td><td>系统显示错误信息，阻止修改</td><td>系统正确显示错误，防止了无效的修改</td></tr></tbody></table><h3 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h3><p>在对自习室预约系统进行细致的测试后，我们发现系统在多数关键功能上运作正常且符合预设需求。通过模拟普通用户的各种情境，如查看自习室预约状态、预约和取消自习室，系统显示了良好的反馈和正确管理冲突的能力。管理员功能测试表明，添加、删除和修改自习室的操作均得以准确执行，系统妥善处理了包括预约中的自习室不能被删除的逻辑。超级管理员的权限测试也验证了其对整个系统用户和统计信息的完全控制能力。模拟的实际结果与预期结果大致一致，验证了系统的可靠性和用户界面的友好性。然而，存在的一些预期外情况建议我们在未来增强输入验证、错误提示和系统的异常处理机制，特别是在处理重复数据和非法输入时。总体来说，自习室预约系统表现出了良好的稳定性和功能完整性，适合进行下一阶段的用户验收测试和进一步开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个项目中，我使用Spring Boot作为后端框架，并结合Element Plus和Vue作为前端框架，构建了一个功能齐全的应用程序。Spring Boot提供了快速搭建后端服务的方式，支持依赖注入、自动配置和开发工具，极大地提升了开发效率，并能轻松集成各种第三方库。前端方面，Element Plus提供了一套漂亮易用的UI组件，而Vue则简化了数据绑定和组件开发，使前端代码更易维护和扩展。通过将后端和前端分离开发和部署，利用RESTful API进行通信，系统保持了松散耦合和易扩展性。我实现了用户管理功能，如登录、注册、获取和修改个人信息、搜索用户和查看所有用户等，并使用Spring Security进行权限控制，确保只有特定权限的用户能访问相应接口。项目中，用户管理功能包括注册、登录、获取和修改个人信息，这些操作通过Spring Boot的RESTful API实现，前端通过Axios进行请求处理。为了确保系统的安全性，我使用Spring Security进行权限控制，确保只有特定权限的用户可以访问相应的接口。这个项目集成了Spring Boot、Element Plus和Vue等技术，增强了我对这些技术的理解，并为今后的开发工作提供了良好的基础和参考。通过这个项目，我深刻体会到合适的技术栈能够极大地提升开发效率和系统质量，前后端分离开发的优势使得开发过程更加高效，细粒度的权限控制确保了系统的安全性，而组件化开发使得代码更加模块化和可维护。总之，这个项目不仅提升了我的技术能力，也让我对系统架构设计、用户体验和安全性有了更深刻的理解。</p>]]></content>
    
    
    <summary type="html">一次基于javaEE系统的设计</summary>
    
    
    
    <category term="javaEE" scheme="https://kalyan-zitiu.github.io/categories/javaEE/"/>
    
    
    <category term="java" scheme="https://kalyan-zitiu.github.io/tags/java/"/>
    
    <category term="springboot" scheme="https://kalyan-zitiu.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>AWS Server Details</title>
    <link href="https://kalyan-zitiu.github.io/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/"/>
    <id>https://kalyan-zitiu.github.io/2024/03/04/AWS%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E7%BB%86/</id>
    <published>2024-03-04T07:00:00.000Z</published>
    <updated>2024-06-24T07:27:59.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><ul><li>是AWS Elastic Block Store(EBS)提供了用于EC2实例的<strong>块存储卷</strong></li><li>设计用来提供高可靠性和高性能的存储<h2 id="块存储卷"><a href="#块存储卷" class="headerlink" title="块存储卷"></a>块存储卷</h2></li><li>是一种数据存储技术，将存储空间分割成固定大小的“块”，每个块可以像独立硬盘一样被单独管理和操作</li><li>低级别数据处理（能够在较低的操作系统级别进行数据处理），高性能（块存储可以与操作系统直接交互），独立性（在没有文件系统的情况下存在，不会存储任何文件结构或元数据），灵活性（轻松扩展或调整大小），可访问性（能够通过存储区域网络（san），互联网协议（ip）网络或本地连接进行访问。）</li></ul><h2 id="持久性存储"><a href="#持久性存储" class="headerlink" title="持久性存储"></a>持久性存储</h2><p>EBS卷在EC2实例终后仍然存在，可以在创建EC3实例时候将其删除。</p><h2 id="多种卷类型"><a href="#多种卷类型" class="headerlink" title="多种卷类型"></a>多种卷类型</h2><h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><ul><li>是一个衡量计算存储设备性能的指标，表示每秒可以完成的输入/输出操作次数。这个指标通常用于评估硬盘驱动器（HDD）、固态硬盘（SSD）、存储区域网络（SAN）和网络附加存储（NAS）等存储设备的性能。</li></ul><p>IOPS高低的因素：</p><ol><li>存储介质：SSD通常提供比HDD更高的IOPS，因为SSD没有移动部件，数据访问速度更快。</li><li>数据块大小：通常较小的数据块会产生更高的IOPS数，每个操作处理的数据量更少。</li><li>读写模式：IOPS性能可能会根据读写操作的比例而变化。一般来说，读写操作的IOPS高于写操作</li><li>并发和队列深度：多个并发操作和更深的队列深度可以提高IOPS，但也可能增加延迟。</li><li>随机与顺序访问：随机I/O操作通常比顺序I/O操作有更低的IOPS，存储设备需要在不同位置寻找数据，尤其是在使用传统的机械硬盘时。</li></ol><h4 id="硬盘驱动器（HDD）"><a href="#硬盘驱动器（HDD）" class="headerlink" title="硬盘驱动器（HDD）"></a>硬盘驱动器（HDD）</h4><ul><li>一种创痛的机械存储设备，具有较大的存储容量和较低的成本</li></ul><h4 id="固态硬盘（SSD）"><a href="#固态硬盘（SSD）" class="headerlink" title="固态硬盘（SSD）"></a>固态硬盘（SSD）</h4><ul><li>是一种基于闪存存储技术的存储设备，具有更快的数据访问速度，更多的访问延迟和更高的可靠性，但是SSD的加个通常比HDD高，存储容量也很较小</li></ul><h4 id="存储区域网络（SAN）"><a href="#存储区域网络（SAN）" class="headerlink" title="存储区域网络（SAN）"></a>存储区域网络（SAN）</h4><ul><li>是一种专用网络，用于连接存储设备和计算设备。SAN通过高速网络连接将存储资源提供给计算设备，使其能够访问和共享存储数据，SAN通常用于大规模企业环境中，提供高性能，高可靠性和可扩展性的存储解决方案。</li></ul><h4 id="网络附加存储（NAS）"><a href="#网络附加存储（NAS）" class="headerlink" title="网络附加存储（NAS）"></a>网络附加存储（NAS）</h4><ul><li>通过网络连接提供文件级别存储服务的设备，NAS设备通常是独立的存储服务器，可以通过网络协议（NFS或SMB）共享文件，使多个计算设备能够访问和共享存储数据。NAS适用与小型办公环境或家庭用户，提供简单的文件共享和备份功能。</li></ul><h3 id="通用型SSD（gp2和gp3）"><a href="#通用型SSD（gp2和gp3）" class="headerlink" title="通用型SSD（gp2和gp3）"></a>通用型SSD（gp2和gp3）</h3><ul><li>提供平衡的性能和成本，适用与广泛的应用。gp2卷提供基于卷大小的IOPS，而gp3则允许用户独立选择和调整IOPS和吞吐量，与卷大小没有关系</li><li><strong>应用场景：</strong> gp2适用于大多数工作负载，如虚拟桌面，中小型数据库，开发和测试环境。gp3是更新的版本，适用于需要可预测的性能和价格的应用程序</li></ul><h3 id="预置IOPS-SSD（io1和io2）"><a href="#预置IOPS-SSD（io1和io2）" class="headerlink" title="预置IOPS SSD（io1和io2）"></a>预置IOPS SSD（io1和io2）</h3><ul><li>提供高性能的IOPS，适用于I/O密集型的数据库和应用程序，io2提供更高的耐久性和IOPS效率</li><li><strong>应用场景：</strong>高性能数据库，如大型关系型数据库或NoSQL数据库，以及需要高吞吐量和低延迟的关键业务应用程序。</li></ul><h3 id="吞吐量优化HDD（st1）"><a href="#吞吐量优化HDD（st1）" class="headerlink" title="吞吐量优化HDD（st1）"></a>吞吐量优化HDD（st1）</h3><ul><li>低成本HDD卷。适用于频繁访问的，吞吐量密集型工作负载。</li><li><strong>应用场景：</strong>大数据，数据仓库，日志处理等需要大量顺序读写操作的应用程序。</li></ul><h3 id="Cold-HDD（st1）"><a href="#Cold-HDD（st1）" class="headerlink" title="Cold HDD（st1）"></a>Cold HDD（st1）</h3><ul><li>最低成本的HDD卷，适用于较少访问的工作负载。</li><li><strong>应用场景：</strong>适合用于冷数据存储，如备份和灾难恢复。</li></ul><h3 id="磁带（standard）"><a href="#磁带（standard）" class="headerlink" title="磁带（standard）"></a>磁带（standard）</h3><ul><li>之前的基础性能HDD卷，现在以及不推荐使用，因为AWS提供更高性能和成本效益更高的选项。</li></ul><h3 id="选择EBS卷类型，考虑因素"><a href="#选择EBS卷类型，考虑因素" class="headerlink" title="选择EBS卷类型，考虑因素"></a>选择EBS卷类型，考虑因素</h3><ul><li>性能：IOPS，吞吐，延迟</li><li>数据访问频率，频繁访问的数据适合SSD，偶尔访问的数据适合HDD。</li><li>成本：预算和成本效益</li><li>耐久性和可用性：重要应用程序可能需要更高的耐久性和可用性</li></ul><h2 id="快照功能"><a href="#快照功能" class="headerlink" title="快照功能"></a>快照功能</h2><ul><li>创建EBS卷的快照，并存储在S3中，用于数据备份和恢复</li><li>快照捕获了某一时刻卷上的数据状态，并将这些数据存储在S3中<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3>对一个EBS卷进行快照备份时，仅仅是新的或者被修改过的块会被保存在S3。如果创建了多个快照，S3不会为未更改的块进行重复存储，而是自上次快照以来变化的块。</li></ul><h3 id="持久性和可靠性"><a href="#持久性和可靠性" class="headerlink" title="持久性和可靠性"></a>持久性和可靠性</h3><p>快照在S3上，是一个高持久性的存储服务，数据会自动复制到多个设施，确保其耐久性。</p><h3 id="点对点复制"><a href="#点对点复制" class="headerlink" title="点对点复制"></a>点对点复制</h3><p>可以跨AWS区域复制，对于灾难恢复和数据中心迁移非常有用。</p><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>原始EBS卷加密，快照也会自动加密。同样，从加密快照创建任何新的EBS卷也会自动假面。</p><h3 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h3><p>快照是增量的，所以它们通常比完整卷备份更加经济。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>允许自动创建和删除快照，便于用户按照自定义的策略维护快照</p><h3 id="共享或私有"><a href="#共享或私有" class="headerlink" title="共享或私有"></a>共享或私有</h3><p>快照可以与特定的AWS账户共享，或者公开共享给所有AWS用户。允许数据和配置的共享，同时支持软件供应商分发产品。</p><h1 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h1><ul><li>是Amazon Simple Storage Service一个对象存储服务</li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><ul><li>无限存储：S3提供几乎无限的存储空间，可以在需要时随时存储和检索任意数量数据</li><li>自动扩展：其实没有s3自动扩展这说法，只是他会适应存储数据量，无需手动去干预</li></ul><h2 id="数据可用性和持久性"><a href="#数据可用性和持久性" class="headerlink" title="数据可用性和持久性"></a>数据可用性和持久性</h2><ul><li>高持久性：S3提供99.999999999%的持久性，确保数据不会因为硬件问题而丢失<h3 id="多区域复制"><a href="#多区域复制" class="headerlink" title="多区域复制"></a>多区域复制</h3></li><li>多区域复制是一项功能，允许自动复制S3存储桶中对象到一个或者多个不同AWS区域的目标存储桶中<h4 id="数据复制策略"><a href="#数据复制策略" class="headerlink" title="数据复制策略"></a>数据复制策略</h4></li><li>可以设置复制策略来指定哪些数据需要被复制，可以是存储桶中的所有数据，也可以是符合特定前缀或标签的数据</li></ul><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><ul><li>多区域复制要求源存储桶启动版本控制，确保每个版本对象都会被复制到目标存储桶</li></ul><h4 id="延迟和一致性"><a href="#延迟和一致性" class="headerlink" title="延迟和一致性"></a>延迟和一致性</h4><p>复制操作通常是异步的，到目标区域会有延迟</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><p>多区域复制会产生额外的成本，包括数据传输费用和目标区域存储的费用</p><h4 id="数据加密-1"><a href="#数据加密-1" class="headerlink" title="数据加密"></a>数据加密</h4><p>支持复制过程中，用AWS提供的加密键（SSE-S3或SSE-KMS）或自己的加密键位（SSE-C）</p><h5 id="SSE-S3"><a href="#SSE-S3" class="headerlink" title="SSE-S3"></a>SSE-S3</h5><ul><li>是Amazon S3提供的服务端加密的一种方式，会自动使用多租户硬件安全模块HSM管理的密钥进行数据加密<br>如何工作：</li><li>当上传文件到S3时，可以指定使用SSE-S3进行加密</li><li>S3会为每个保存的对象生成一个唯一的密钥，使用该密钥对数据进行加密，把加密的数据保存的存储中</li><li>将每个对象的密钥进一步使用一个主密钥进行加密，这个主密钥是定期轮换的</li><li>访问数据时，会自动处理解密过程，可以像访问未加密的数据一样访问加密数据</li></ul><p>特点：<br>简单易用：SSE-S3 的操作非常简单，只需要在上传对象时指定使用 SSE-S3 加密即可，其余的加密和解密过程都由 Amazon S3 自动管理。<br>透明：对于使用 SSE-S3 加密的数据，用户在访问时不会感觉到任何不同，因为加密和解密都是透明进行的。<br>安全性：使用 SSE-S3 加密的数据，其密钥管理和保护是由 AWS 的硬件安全模块（HSM）来完成的，这提供了很高的安全保障。<br>自动加密：默认情况下，所有新的 S3 存储桶都会自动使用 SSE-S3 加密新上传的对象，除非您指定了其他加密方式。</p><p>注意事项：<br>性能影响：使用 SSE-S3 加密可能会对性能产生微小的影响，因为每次读取和写入操作都需要进行加密和解密操作。<br>成本：虽然 AWS 不额外收费用于 SSE-S3 加密，但是如果您使用了 S3 提供的额外密钥管理功能，如 AWS Key Management Service (KMS)，则可能会产生额外费用。<br>权限：如果您的 AWS Identity and Access Management (IAM) 策略不允许使用 SSE-S3，那么尝试上传文件时可能会遇到权限问题。</p><h5 id="SSE-KMS"><a href="#SSE-KMS" class="headerlink" title="SSE-KMS"></a>SSE-KMS</h5><ul><li>是Amazon S3的另一种服务端加密选项，提供更多的用户控制权和审计跟踪</li><li>如何工作：<br>当您启用 SSE-KMS 时，您可以选择使用由 KMS 管理的默认服务密钥，也可以在 KMS 中创建自己的客户主密钥（CMK）。<br>当您上传数据到 S3 时，您需要指定使用 KMS 密钥进行加密。<br>S3 将与 KMS 通信，使用指定的 CMK 对数据进行加密，并将加密的数据保存到存储中。<br>当您需要读取数据时，S3 将请求 KMS 解密数据，然后将解密后的数据返回给您。</li></ul><p>特点：<br>用户控制的密钥：您可以创建、管理和使用您自己的加密密钥，也可以使用由 AWS 管理的默认密钥。<br>密钥轮换：KMS 支持自动轮换密钥，提高了安全性。<br>审计日志：与 KMS 集成的 AWS CloudTrail 提供了密钥使用情况的审计日志，方便审计和合规。<br>细粒度权限：您可以使用 IAM 策略精确控制谁可以使用哪些密钥来加密和解密数据。</p><p>注意事项：<br>性能影响：与 SSE-S3 类似，使用 SSE-KMS 也可能会对性能产生微小的影响，尤其是在加密和解密操作时。<br>成本：使用 KMS 管理的密钥可能会产生额外的费用，包括密钥存储费用和密钥使用费用。<br>权限管理：需要确保适当的 IAM 策略和权限设置，以便用户可以正确地使用 KMS 密钥。</p><h4 id="权限和角色"><a href="#权限和角色" class="headerlink" title="权限和角色"></a>权限和角色</h4><p>适当IAM角色和权限来设置和管理多区域复制</p><h2 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h2><ul><li>数据加密：S3支持服务端加密数据，以及在传输过程中使用SSL/TLS加密数据</li></ul><h3 id="过程中SSL-TLS加密"><a href="#过程中SSL-TLS加密" class="headerlink" title="过程中SSL/TLS加密"></a>过程中SSL/TLS加密</h3><ul><li>机密协议：AWS S3使用的是SSL/TLS协议在加密传输中的数据，确保互联网安全</li><li>自动加密： 通过HTTPS向S3上传或从S3下载数据时候，SSL/TLS加密是自动应用的，以为这无需进行额外的配置</li><li>端点安全：使用HTTPS连接可以确保您的数据在从客户端到S3端点的整个路径上都是加密的。</li><li>与存储中加密的区别：需要注意的是，传输中加密与存储中加密（例如S3的服务器端加密）是不同的。存储中加密关注的是数据在S3存储桶中处于静止状态时的加密，而传输中加密关注的是数据移动时的安全性。</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>优化的性能：S3 提供了优化的性能，尤其是对于分布式应用和大数据工作负载。<br>并行传输：S3 支持多部分上传和下载，使得大文件可以分成小块并行处理，提高数据传输速度。</p><h2 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h2><p>生命周期管理：S3 提供了生命周期管理策略，允许你自动转移或删除在一定时间后不再需要的数据。<br>存储类别：S3 提供多种存储类别，如 S3 Standard、S3 Intelligent-Tiering、S3 Standard-IA（低频访问）、S3 One Zone-IA（单可用区低频访问）和 S3 Glacier（用于长期存档），以适应不同的成本和访问频率需求。<br>监控和日志记录：S3 提供了监控工具，如 S3 访问日志和 AWS CloudTrail，以及与 Amazon CloudWatch 的集成，以便于监控和记录存储操作。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>存储在S3的数据可以用各种AWS的分析服务</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>数据分析服务可以有<a href="#amazon-athena">Amazon Athena</a>,<a href="#amozon-redshift">Amozon Redshift</a>,<a href="#amazon-emr">Amazon EMR</a></p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>数据转换服务可以有<a href="#aws-glue">AWS Glue</a> ，<a href="#aws-data-pipeline">AWS Data Pipeline</a> ，<a href="#aws-lambda">AWS Lambda</a></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>AWS提供了一系列机器学习服务，如<a href="#amazon-sagemaker">Amazon SageMaker</a>、<a href="#amazon-rekognition">Amazon Rekognition</a>、<a href="#amazon-comprehend">Amazon Comprehend</a>等，可以在S3上的数据上构建和训练机器学习模型。</p><h2 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h2><h3 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h3><ul><li>检索速度必然是比S3存储要长的，主要是因为大数量和低频访问</li><li>S3 Glacier的检索会产生额外的检索费用，取决于数据大小和检索速度</li><li>可指定检索选项</li></ul><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>可以用生命周期策略自动将数据从S3标准存储转移到S3 Glacier</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一般都是在需要存储大量数据但又不经常访问的场景</p><h1 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h1><h2 id="DNS功能"><a href="#DNS功能" class="headerlink" title="DNS功能"></a>DNS功能</h2><p>域名注册与转移：Route 53 允许用户注册新的域名或将现有域名从其他注册商转移到 AWS。</p><p>托管区域（Hosted Zones）：在 Route 53 中，托管区域是一个容器，它包含了处理一个域名及其子域名的 DNS 记录。托管区域分为公有托管区域和私有托管区域。</p><p>DNS 记录类型：Route 53 支持多种 DNS 记录类型，包括 A (地址记录)，AAAA (IPv6 地址记录)，CNAME (规范名称记录)，MX (邮件交换记录)，TXT (文本记录)，NS (名称服务器记录) 和 SOA (起始授权机构记录) 等。</p><p>路由策略：Route 53 提供多种路由策略，如简单路由、加权路由、延迟路由、故障转移路由和地理位置路由等，允许用户根据不同的条件来路由流量。</p><p>别名记录：Route 53 的别名记录允许将一个域名映射到 AWS 资源，例如 Amazon S3 存储桶、Elastic Load Balancing (ELB) 负载均衡器或另一个 Route 53 托管区域中的域名。与 CNAME 记录不同，别名记录可以用于域名的根节点（例如 example.com）。</p><p>DNS 查询日志：用户可以配置 Route 53 以记录所有对托管区域的 DNS 查询，这有助于调试和监控 DNS 活动。</p><p>DNSSEC：Route 53 支持 DNS 安全扩展 (DNSSEC)，这是一种增强 DNS 安全性的协议，可以保护域名解析过程不被篡改。</p><p>全球分布的 DNS 服务器：Route 53 使用全球分布的 DNS 服务器和 Anycast 路由技术，确保 DNS 查询响应迅速且可靠。</p><h3 id="DNSSEC安全扩展"><a href="#DNSSEC安全扩展" class="headerlink" title="DNSSEC安全扩展"></a>DNSSEC安全扩展</h3><p>保护互联网用户免受伪造DNS数据（缓存投毒）的攻击，通过对DNS响应进行数字签名</p><p>主要步骤：<br>生成密钥：为每一个DNS区域生成一次公钥和私钥。</p><p>签名记录：使用私钥对DNS区域中RRsets进行签名，签名存储再DNS作为性的记录类型，称为DNSSEC签名（RRSIG）记录。</p><p>分发公钥：将公钥作为DNSKEY记录分发再DNS中，以便任何人都可以用它来验证签名</p><p>链式信任：DNSSEC 使用一种链式信任模型，其中每个级别的 DNS 区域都会签署其下一级别的区域的密钥。这个链条一直延伸到根域名服务器，它的密钥被称为根密钥，是整个信任链的基础。</p><p>验证：当客户端（如 DNS 解析器）收到 DNSSEC 保护的响应时，它会使用存储在 DNS 中的公钥来验证响应的签名。如果验证成功，客户端可以确信该响应是未被篡改的。</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><h4 id="简单路由："><a href="#简单路由：" class="headerlink" title="简单路由："></a>简单路由：</h4><p>到单个资源，域名指向一个IP地址或一个Amazon S3 存储桶</p><h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><ul><li>单一资源服务，单个web服务器或单个Amazon S3存储桶</li><li>不需要复杂的路由决策的简单域名分析</li></ul><h4 id="加权路由："><a href="#加权路由：" class="headerlink" title="加权路由："></a>加权路由：</h4><p>允许你分配不同的权重给相同域名下的多个资源，从而控制流量的分配比例。这对于流量切换和 A/B 测试非常有用。</p><h5 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h5><ul><li>A/B 测试，将流量按照一定比例分配给不同的应用版本。</li><li>平滑的流量迁移，逐渐增加指向新资源的流量比例。</li><li>负载分配，根据服务器能力分配不同的权重。</li></ul><h4 id="延迟路由"><a href="#延迟路由" class="headerlink" title="延迟路由"></a>延迟路由</h4><p>根据用户到 AWS 区域的网络延迟自动路由用户请求。这有助于向用户提供最低延迟的响应。</p><h5 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h5><ul><li>多区域部署，根据用户到 AWS 区域的延迟选择最佳路由。</li><li>性能优化，确保用户获得最快的响应时间。</li></ul><h4 id="故障转移路由"><a href="#故障转移路由" class="headerlink" title="故障转移路由"></a>故障转移路由</h4><p>在主要资源发生故障时，自动将流量切换到备份资源。这对于实现高可用性和灾难恢复非常关键。</p><h5 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h5><ul><li>灾难恢复，当主要资源发生故障时自动切换到备用资源。</li><li>高可用性配置，配合健康检查确保服务不间断<h4 id="地理位置路由"><a href="#地理位置路由" class="headerlink" title="地理位置路由"></a>地理位置路由</h4>根据用户的地理位置将流量路由到特定的资源。这可以用于内容本地化或遵守地理位置相关的法律法规。</li></ul><h5 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h5><ul><li>地理目标定位，向特定地理区域的用户提供定制化内容。</li><li>法规遵从，确保数据存储和处理遵守特定地区的法律法规。</li><li>负载分散，将用户流量分散到不同的区域以减轻特定服务器的负载。<h4 id="地理位置优先路由"><a href="#地理位置优先路由" class="headerlink" title="地理位置优先路由"></a>地理位置优先路由</h4>根据用户和资源之间的地理位置距离来路由流量。可以通过使用“偏置值”来调整流量的分配<h5 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h5></li><li>地理位置敏感的负载均衡，更精细地控制基于用户位置的流量分配。</li><li>业务扩展，根据业务需求和用户位置动态调整流量。<h4 id="多值答案路由"><a href="#多值答案路由" class="headerlink" title="多值答案路由"></a>多值答案路由</h4>当你想要 Route 53 返回多个资源的 IP 地址，并且希望 Route 53 对这些资源进行健康检查时，可以使用这种策略。</li></ul><h5 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h5><ul><li>提供了内置健康检查的简单负载均衡。</li><li>当有多个资源可以提供服务时，增加系统的容错能力。</li><li>需要从多个资源中返回单个或多个健康资源的 IP 地址。</li></ul><h2 id="Route-53-的Best-Match"><a href="#Route-53-的Best-Match" class="headerlink" title="Route 53 的Best Match"></a>Route 53 的Best Match</h2><h3 id="与EC2配合实现静态网站托管"><a href="#与EC2配合实现静态网站托管" class="headerlink" title="与EC2配合实现静态网站托管"></a>与EC2配合实现静态网站托管</h3><ul><li>Route 53 可以将流量路由运行在Amazon EC2实例上的应用程序</li><li>使用故障转移路由来监控EC2实例的健康状况，在需要时将流量自动切换到备用实例</li></ul><h3 id="与ELB配合实现高可用性和负载均衡"><a href="#与ELB配合实现高可用性和负载均衡" class="headerlink" title="与ELB配合实现高可用性和负载均衡"></a>与ELB配合实现高可用性和负载均衡</h3><ul><li>ELB自动分配进来的应用流量到多个EC2实例，以提高容错能力和可伸缩性</li><li>Route 53可以直接与ELB集成，将域名解析到ELB的DNS名称，而不是特定的IP地址</li></ul><h3 id="与S3配合实现静态网站托管"><a href="#与S3配合实现静态网站托管" class="headerlink" title="与S3配合实现静态网站托管"></a>与S3配合实现静态网站托管</h3><ul><li>可以以将域名解析到一个Amazon存储桶，这个存储桶配置为静态网站</li></ul><h3 id="与Lambda和API-Gateway配合实现无服务器架构"><a href="#与Lambda和API-Gateway配合实现无服务器架构" class="headerlink" title="与Lambda和API Gateway配合实现无服务器架构"></a>与Lambda和API Gateway配合实现无服务器架构</h3><ul><li>Route 53 可以将流量路由到一个API Gateway，后者触发Lambda函数来处理请求</li><li>架构可以构建完全无服务器的应用，轻松扩展且成本效益高</li></ul><h3 id="与CloudFront配合实现全球内容分发"><a href="#与CloudFront配合实现全球内容分发" class="headerlink" title="与CloudFront配合实现全球内容分发"></a>与CloudFront配合实现全球内容分发</h3><ul><li>将用户请求解析到最近的CloudFront边缘位置，加速内容的分发</li></ul><h3 id="与shield配合实现防御分布式拒绝服务DDOS攻击"><a href="#与shield配合实现防御分布式拒绝服务DDOS攻击" class="headerlink" title="与shield配合实现防御分布式拒绝服务DDOS攻击"></a>与shield配合实现防御分布式拒绝服务DDOS攻击</h3><ul><li>托管型DDos防护服务，可以保护在AWS上运行的应用不受DDos攻击</li></ul><h3 id="与WAF配合实现应用层防护"><a href="#与WAF配合实现应用层防护" class="headerlink" title="与WAF配合实现应用层防护"></a>与WAF配合实现应用层防护</h3><ul><li>是一种Web应用防火墙，保护Web应用免受常见的网络和应用层攻击。</li><li>为域名提供基于规则的控制，防止恶意流量到达应用</li></ul><h3 id="与RDS实现数据库故障转移"><a href="#与RDS实现数据库故障转移" class="headerlink" title="与RDS实现数据库故障转移"></a>与RDS实现数据库故障转移</h3><ul><li>Route 53 可以与Amazon RDS配合实现数据库的故障转移和读取复制</li></ul><h3 id="与VPC配合使用构建私有云解析和内部域名服务"><a href="#与VPC配合使用构建私有云解析和内部域名服务" class="headerlink" title="与VPC配合使用构建私有云解析和内部域名服务"></a>与VPC配合使用构建私有云解析和内部域名服务</h3><ul><li>通过私有托管区域，企业可以管理内部域名，而这些域名不会被路由到公共互联网上</li></ul><h3 id="与Transit-Gateway实现多区域网络连接"><a href="#与Transit-Gateway实现多区域网络连接" class="headerlink" title="与Transit Gateway实现多区域网络连接"></a>与Transit Gateway实现多区域网络连接</h3><ul><li>AWS Transit Gateway 允许连接多个 VPC 和本地网络，形成一个中心式的网络枢纽。</li><li>Route 53 可以用来解析跨这些连接的 VPCs 内部的服务名称。</li></ul><h3 id="与-AWS-Direct-Connect-配合混合云环境"><a href="#与-AWS-Direct-Connect-配合混合云环境" class="headerlink" title="与 AWS Direct Connect 配合混合云环境"></a>与 AWS Direct Connect 配合混合云环境</h3><ul><li>AWS Direct Connect 通过私有连接将企业数据中心连接到 AWS，绕过公共互联网，提高安全性和带宽。</li><li>Route 53 可以用来解析通过 Direct Connect 连接的资源，保证内部和外部解析的一致性。</li></ul><h3 id="与ACM构建SSL-TLS证书管理"><a href="#与ACM构建SSL-TLS证书管理" class="headerlink" title="与ACM构建SSL/TLS证书管理"></a>与ACM构建SSL/TLS证书管理</h3><ul><li>简化了SSL/TLS证书的获取，管理和部署过程</li><li>自动使用DNS验证来验证域名的所有权并且自动续签证书</li></ul><h3 id="与EC2和EKS构建容器化应用和微服务"><a href="#与EC2和EKS构建容器化应用和微服务" class="headerlink" title="与EC2和EKS构建容器化应用和微服务"></a>与EC2和EKS构建容器化应用和微服务</h3><ul><li>ECS和EKS提供容器服务</li><li>Route 53可以与ECS和EKS集成，通过服务发现机制自动注册和解除注册容器实例，使微服务架构中的服务能够相互发现和通信</li></ul><h1 id="稍微理解"><a href="#稍微理解" class="headerlink" title="稍微理解"></a>稍微理解</h1><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend +"></a>Amazon Comprehend +</h2><ul><li>一项自然语言（NLP）服务，使用机器学习技术赖解析文本中的洞察和关系</li></ul><ol><li><strong>实体识别（Entity Recognition）</strong>：能够识别文本中的具体实体，如人名、地点、品牌或其他专有名词。</li><li><strong>情感分析（Sentiment Analysis）</strong>：分析文本的情感倾向，判断它是正面的、负面的、中性的还是复合情感的。</li><li><strong>关键词提取（Key Phrase Extraction）</strong>：从文本中提取重要的或者有意义的短语。</li><li><strong>语言识别（Language Detection）</strong>：自动识别文本所使用的语言。</li><li><strong>句法分析（Syntax Analysis）</strong>：分析文本中的语言构成，比如词性标注和句子成分分析。</li><li><strong>主题建模（Topic Modeling）</strong>：识别文档集合中的主题模式。</li></ol><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p><strong>Amazon Rekognition</strong> 是一项基于深度学习的图像和视频分析服务。它可以识别图像和视频中的对象、场景、文字以及人脸。Rekognition 提供了多种功能，包括：</p><ul><li><strong>人脸分析</strong>：识别人脸、检测面部特征、评估情绪等。</li><li><strong>人脸比对</strong>：比对两张人脸图像，判断它们是否属于同一个人。</li><li><strong>人脸搜索</strong>：在大型图像库中搜索特定人脸。</li><li><strong>文本识别</strong>：检测和识别图像中的文字。</li><li><strong>场景分析</strong>：识别图像中的场景和对象。</li></ul><p>开发者可以通过简单的 API 调用来使用这些功能，从而构建各种视觉分析应用。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p><strong>Amazon SageMaker</strong> 是一项全面的机器学习平台，旨在简化机器学习模型的构建、训练和部署过程。SageMaker 提供了以下功能：</p><ul><li><strong>数据标注</strong>：帮助准备训练数据。</li><li><strong>模型训练</strong>：使用各种机器学习算法训练模型。</li><li><strong>模型调优</strong>：优化模型性能。</li><li><strong>模型部署</strong>：将训练好的模型部署到生产环境中。</li></ul><p>SageMaker 支持多种常见的机器学习算法和框架，同时提供了一个交互式的开发环境，方便开发者快速迭代和部署模型。</p><h2 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h2><p><strong>AWS Lambda</strong> 是一项无服务器计算服务，开发者可以在 Lambda 上运行代码而无需管理服务器。Lambda 可以根据各种事件（如 API 调用、文件上传等）触发执行代码，支持多种编程语言，包括 Python、Node.js、Java 等。Lambda 的特点包括：</p><ul><li><strong>弹性扩展</strong>：根据请求量自动扩展计算资源。</li><li><strong>按需计费</strong>：只需为实际使用的计算资源付费。</li><li><strong>事件驱动</strong>：可以与多种 AWS 服务集成，响应各种事件。</li></ul><p>Lambda 适用于构建无服务器应用、自动化任务、数据处理等场景。</p><h2 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h2><p><strong>AWS Data Pipeline</strong> 是一项数据处理服务，用于自动化和调度数据处理工作流程。开发者可以使用 Data Pipeline 来定义数据处理流程、调度任务执行、跟踪任务状态等。Data Pipeline 提供了以下功能：</p><ul><li><strong>数据源连接</strong>：支持多种数据源，包括 AWS 服务和外部数据存储。</li><li><strong>灵活调度</strong>：可以根据时间表、事件触发等条件调度任务。</li><li><strong>任务监控</strong>：提供任务状态监控和报警功能。</li></ul><p>Data Pipeline 可以帮助简化数据处理流程，提高数据处理的效率和可靠性。</p><h2 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h2><p><strong>AWS Glue</strong> 是一项全托管的数据集成服务，用于抽取、转换和加载数据。Glue 可以自动发现数据源、推断数据模式、执行数据转换操作，并将数据加载到目标数据存储中。Glue 的主要功能包括：</p><ul><li><strong>数据目录</strong>：自动创建和维护数据目录。</li><li><strong>ETL 转换</strong>：支持数据抽取、转换和加载。</li><li><strong>数据目录版本控制</strong>：管理数据目录版本。</li></ul><p>AWS Glue 可以帮助用户简化数据集成和数据准备的过程，加速数据处理和分析的流程。</p><h2 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h2><p><strong>Amazon EMR</strong> 是一项大数据处理服务，基于开源的 Apache Hadoop 和 Apache Spark 构建。EMR 可以帮助用户快速搭建、扩展和管理大数据处理集群，用于分析、处理大规模数据集。EMR 提供了以下特点：</p><ul><li><strong>弹性扩展</strong>：根据需求自动扩展集群规模。</li><li><strong>多种框架支持</strong>：支持 Hadoop、Spark、Presto 等多种大数据处理框架。</li><li><strong>安全性和可靠性</strong>：提供数据加密、访问控制等安全特性。</li></ul><p>EMR 可以帮助用户快速搭建大数据处理环境，进行数据分析和处理。</p><h2 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p><strong>Amazon Redshift</strong> 是一种云数据仓库服务，用于分析大规模数据集。Redshift 提供了高性能的数据查询和分析能力，支持列式存储、压缩和并行查询等特性。Redshift 的特点包括：</p><ul><li><strong>高性能</strong>：支持大规模数据并行处理，提供快速的查询性能。</li><li><strong>可扩展性</strong>：可以根据需求扩展集群规模。</li><li><strong>SQL 兼容</strong>：支持标准 SQL 查询语言。</li></ul><p>Redshift 可以帮助用户构建数据仓库和商业智能应用，进行复杂的数据分析和查询。</p><h2 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h2><p><strong>Amazon Athena</strong> 是一项交互式查询服务，用于在亚马逊 S3 存储中执行 SQL 查询。Athena 可以帮助用户快速分析存储在 S3 中的数据，无需预先加载数据到数据库中。Athena 的特点包括：</p><ul><li><strong>无服务器</strong>：无需管理基础设施，按需执行查询。</li><li><strong>标准 SQL</strong>：支持标准 SQL 查询语言。</li><li><strong>数据格式支持</strong>：支持多种数据格式，如 CSV、JSON 等。</li></ul><p>Athena 可以帮助用户快速进行数据查询和分析，适用于需要快速查询大规模数据集的场景。</p><h1 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h1><h2 id="无服务器集成"><a href="#无服务器集成" class="headerlink" title="无服务器集成"></a>无服务器集成</h2><p>无服务器集成是能够将API端点直接连接到无服务器后端服务，如Lambda和DynamoDB，不需要运行或管理任何服务器，这种集成方式简化了API部署和管理，因为AWS负责所有的基础设置管理。</p><h3 id="Lambda集成"><a href="#Lambda集成" class="headerlink" title="Lambda集成"></a>Lambda集成</h3><p>API Gateway可以将请求直接路由到Lambda函数，当API被调用时，触发一个Lambda函数，该函数执行业务逻辑然后返回响应，允许你构建强大的后端逻辑，无需担心服务器的运行和维护</p><h3 id="DynamoDB集成"><a href="#DynamoDB集成" class="headerlink" title="DynamoDB集成"></a>DynamoDB集成</h3><p>API Gateway可以直接与DynamoDB集成，运行API直接执行DynamoDB表上的操作，如获取项目，写入项目等。API Gateway，创建一个完全无服务的后端，用于存储和检索数据。</p><h3 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h3><p>创建Lambda函数或DynamoDB表，设置API Gateway资源，创建新的API，配置集成请求和响应，部署，用CloudWatch监控API调用和Lambda函数执行，确保性能和可靠性</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>API Gateway 提供了几种流量控制机制，帮助开发者防止过载后端服务</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>默认节流：对每个账户提供默认的节流限制，这些限制是以每秒请求数TPS和并发限制来定义的，如果超过限制则会返回429错误</li><li>自定义节流</li></ul><h3 id="使用计划"><a href="#使用计划" class="headerlink" title="使用计划"></a>使用计划</h3><ul><li>允许用户创建使用计划，并与API密钥关联，可定义API密钥允许请求频率的限制和配额限制</li></ul><h3 id="突发限制"><a href="#突发限制" class="headerlink" title="突发限制"></a>突发限制</h3><ul><li>突发限制是指在短时间内允许的最大请求数。这对于处理短时间内的突然流量增加很有用，同时确保后端服务不会因为大量并发请求而过载。</li></ul><h3 id="客户端限流"><a href="#客户端限流" class="headerlink" title="客户端限流"></a>客户端限流</h3><ul><li>开发者可以在客户端实施限流措施，这通常是通过重试逻辑和指数退避策略来实现的。这有助于在客户端自动处理和平滑处理 429 错误。</li></ul><h2 id="数据转换-1"><a href="#数据转换-1" class="headerlink" title="数据转换"></a>数据转换</h2><p>API Gateway 中实现数据转换的主要工具是模板和模型：</p><h3 id="模板（Mapping-Templates）"><a href="#模板（Mapping-Templates）" class="headerlink" title="模板（Mapping Templates）"></a>模板（Mapping Templates）</h3><p>API Gateway 允许你使用 Velocity Template Language (VTL) 和 JSONPath 表达式来创建映射模板。这些模板定义了如何将客户端请求转换为后端服务所期望的格式，以及如何将后端服务的响应转换为客户端所期望的格式。</p><p>请求模板：在请求模板中，你可以添加逻辑来定制请求有效载荷，例如添加或删除 JSON 字段，修改头部信息，或者根据请求参数构建一个全新的请求体。<br>响应模板：响应模板允许你修改从后端服务返回的数据。你可以转换数据格式，只返回客户端需要的部分数据，或者处理错误响应。</p><h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>模型是 API Gateway 中定义的数据结构，它们使用 JSON Schema 描述了 API 的请求和响应数据。模型可以帮助你标准化数据结构，并为你的 API 用户提供清晰的数据格式文档。<br>请求模型：定义了 API 接收的数据结构，可以用来校验请求数据。<br>响应模型：定义了 API 返回的数据结构，可以用来校验响应数据。<br>利用这些数据转换功能，开发者可以确保 API 的前端和后端之间的通信是平滑和一致的，即使它们可能使用不同的数据格式或标准。这也使得 API Gateway 成为一个强大的工具，用于在不修改后端服务的情况下，快速适应前端应用程序的变化需求。</p><h2 id="RESTful-API-和-WebSocket-API"><a href="#RESTful-API-和-WebSocket-API" class="headerlink" title="RESTful API 和 WebSocket API"></a>RESTful API 和 WebSocket API</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>RESTful API 是一种基于 HTTP 协议的 Web API。它遵循 REST 架构原则，通常使用标准的 HTTP 方法，如 GET、POST、PUT、DELETE 等。API Gateway 中的 RESTful API 提供以下特性：</p><p>无服务器集成：可以直接与 AWS Lambda 函数或其他 AWS 服务集成，无需运行或管理服务器。<br>数据转换：通过映射模板对请求和响应进行转换和重写。<br>流量控制：包括节流、使用计划和配额管理。<br>安全性：支持 API 密钥、AWS IAM 角色和权限以及 Cognito 用户池进行身份验证和授权。<br>版本管理和生命周期管理：支持多个发布阶段和版本控制。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控API调用和记录日志。<br>缓存：可以配置 API 缓存以减少延迟和后端负载。<br>RESTful API 适用于大多数标准的 Web 应用程序场景，特别是那些需要严格的状态无关和资源导向架构的场景。</p><h3 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h3><p>WebSocket API 提供了全双工通信通道，允许服务器和客户端之间进行实时、双向的通信。API Gateway 中的 WebSocket API 具有以下特性：</p><p>连接管理：API Gateway 负责连接的建立和维护。<br>规模扩展：可以根据连接数自动扩展，支持大量并发WebSocket连接。<br>路由选择：基于传入的消息内容，将不同的消息路由到不同的后端服务，如 AWS Lambda 或 HTTP 终端节点。<br>集成后端服务：与 AWS Lambda 和 HTTP API 直接集成，无需管理服务器。<br>安全性：可以使用 AWS IAM、Lambda 授权器或自定义授权器来管理连接和消息的授权。<br>监控和日志记录：与 Amazon CloudWatch 集成，以监控连接和消息传递。<br>WebSocket API 适用于需要实时通信的应用程序，如聊天应用、实时游戏、实时通知和协作工具。</p><h2 id="SDK集成"><a href="#SDK集成" class="headerlink" title="SDK集成"></a>SDK集成</h2><p>Amazon API Gateway 提供了与各种编程语言的 SDK 集成支持，这样开发者可以在他们选择的编程语言中更容易地调用由 API Gateway 托管的 API。这些 SDKs，通常称为客户端 SDKs，是自动生成的，并且可以针对已经部署的 API 生成。</p><p>以下是 API Gateway 与 SDK 集成的一些关键点：</p><h3 id="SDK-生成"><a href="#SDK-生成" class="headerlink" title="SDK 生成"></a>SDK 生成</h3><p>对于 RESTful API，API Gateway 允许开发者生成客户端 SDK 来调用 API。这些 SDK 可以针对以下平台生成：</p><ul><li>Android</li><li>iOS (Objective-C 和 Swift)</li><li>JavaScript (适用于浏览器和 Node.js)</li></ul><p>生成 SDK 的过程通常涉及到在 API Gateway 控制台中选择你的 API 阶段，然后选择你想要生成的 SDK 的类型。API Gateway 会为你生成一个包含所有必要调用逻辑和数据结构的压缩文件。</p><h3 id="SDK-的使用"><a href="#SDK-的使用" class="headerlink" title="SDK 的使用"></a>SDK 的使用</h3><p>生成的 SDK 会包含对应语言的库和工具，使得客户端应用程序可以轻松地与 API Gateway 进行通信。例如，生成的 JavaScript SDK 会包含 API 调用的 AJAX 请求代码，而 iOS SDK 会包含构建网络请求的代码。</p><p>使用这些 SDK，开发者可以快速地在他们的应用程序中实现以下功能：</p><ul><li>调用 API Gateway 托管的 API。</li><li>处理请求和响应，包括错误处理。</li><li>传递身份验证和授权信息，如果 API 使用了 API 密钥、AWS IAM 或 Amazon Cognito 用户池。</li></ul><h3 id="SDK-定制和优化"><a href="#SDK-定制和优化" class="headerlink" title="SDK 定制和优化"></a>SDK 定制和优化</h3><p>尽管 SDK 是自动生成的，但开发者仍然可以根据需要对其进行定制。例如，他们可以添加额外的逻辑来处理特定的应用程序场景，或者改进错误处理和重试策略。</p><p>此外，开发者可能需要考虑 SDK 如何影响应用程序的性能和大小，特别是在移动应用程序中。他们可能需要优化网络请求，或者去除未使用的 SDK 部分以减小应用程序的体积。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>使用 SDK 时，安全性是一个重要考虑因素。开发者需要确保他们的应用程序安全地存储和传递任何敏感信息，如 API 密钥或用户凭证。此外，他们可能需要实施额外的安全措施，如使用 HTTPS 来保护数据在传输过程中的安全，或者使用 OAuth 和 Amazon Cognito 来为用户提供安全的身份验证和授权。</p><p>总的来说，API Gateway 的 SDK 集成简化了客户端应用程序与后端服务的交互，允许开发者专注于构建应用程序的核心功能，而不是编写重复的代码来处理 API 调用。通过自动化的 SDK 生成和简单的集成过程，API Gateway 使得从客户端应用程序到云端服务的开发变得更加快捷和高效。</p><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>AWS Lambda 是亚马逊网络服务（Amazon Web Services, 简称AWS）提供的一项无服务器计算服务。它允许你运行代码，而无需预置或管理服务器。</p><h2 id="事件驱动执行"><a href="#事件驱动执行" class="headerlink" title="事件驱动执行"></a>事件驱动执行</h2><ul><li>通过事件触发执行，也可以来自于应用程序的自定义事件</li></ul><h3 id="举例场景：Lambda处理在S3上传新文件时触发"><a href="#举例场景：Lambda处理在S3上传新文件时触发" class="headerlink" title="举例场景：Lambda处理在S3上传新文件时触发"></a>举例场景：Lambda处理在S3上传新文件时触发</h3><p>1.需要创建一个新的Lambda函数，选为某编程语言运行<br>2.把函数分配一个执行角色，这里就是有权读取S3的对象，写入CloudWatch日志<br>3.在S3中设置事件通知，在上传时触发Lambda函数，可以在S3存储属性中找到，把Lambda函数作为目标。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例代码</span></span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote_plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志记录</span></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 S3 客户端</span></span><br><span class="line">s3_client = boto3.client(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># 获取存储桶名称和文件键值</span></span><br><span class="line">    bucket_name = event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;bucket&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    file_key = unquote_plus(event[<span class="string">&#x27;Records&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;s3&#x27;</span>][<span class="string">&#x27;object&#x27;</span>][<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录到 CloudWatch 日志中</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;New file uploaded: <span class="subst">&#123;file_key&#125;</span> in bucket: <span class="subst">&#123;bucket_name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里可以添加更多处理逻辑，例如读取文件内容、转换文件格式等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;File processed successfully!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="无服务器架构"><a href="#无服务器架构" class="headerlink" title="无服务器架构"></a>无服务器架构</h2><p>不需要服务器和任何环境，Lambda负责运行你的代码并自动管理底层计算资源</p><h2 id="自动扩展"><a href="#自动扩展" class="headerlink" title="自动扩展"></a>自动扩展</h2><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>一个事件触发器激活一个Lambda函数，如果有多个事件几乎同时到达，Lambda会自动启动多个实例来处理事件</p><h3 id="冷启动与热启动"><a href="#冷启动与热启动" class="headerlink" title="冷启动与热启动"></a>冷启动与热启动</h3><ul><li><p>冷启动：当一个函数被触发而当前没有可用的运行实例时，Lambda会进行一个“冷启动”，即创建一个新的函数实例。过程基本涉及到加载代码，初始化运行时，运行初始化代码（如全局变量声明）等步骤。冷启动通常需要更长启动时间。</p></li><li><p>热启动：如果一个函数实例在执行完一个时间后仍然处于空闲状态，可以被用来快速响应新的时间，这称为热启动，热启动跳过了实例创建过程比冷启动快</p></li></ul><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>Lambda在账户级别有并发执行限制。这个限制是指任何时刻，一个AWS账户可以同时运行的Lambda函数实例的数量。这个限制既保护了用户免受意外的高费用，确保资源的合理分配</p><h3 id="预热行为"><a href="#预热行为" class="headerlink" title="预热行为"></a>预热行为</h3><p>避免冷启动延迟，用户可以实现预热策略，通过定期触发Lambda函数来保持一定数量的热实例。</p><h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><h3 id="IAM角色和策略"><a href="#IAM角色和策略" class="headerlink" title="IAM角色和策略"></a>IAM角色和策略</h3><ul><li><p>创建一个 Lambda 函数时，您需要指定一个执行角色（IAM 角色）。Lambda 函数将使用这个角色的权限来访问 AWS 服务和资源。</p><h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><p>资源策略包含以下部分：</p></li><li><p>Statement：资源策略由一个或多个语句（Statement）组成，每个语句都是一个权限声明，指定了一个允许或拒绝的权限。</p></li><li><p>Effect：每个语句的 Effect 决定了这个语句是允许（Allow）还是拒绝（Deny）某项操作。</p></li><li><p>Action：Action 定义了可以在 Lambda 函数上执行的操作，例如 lambda:InvokeFunction。</p></li><li><p>Resource：Resource 指定了策略适用的资源，对于 Lambda 函数策略来说，这通常是函数的 ARN（Amazon Resource Name）。</p></li><li><p>Principal：Principal 定义了哪些 AWS 账户、用户、角色或服务可以执行在 Action 中定义的操作。</p></li><li><p>Condition：条件（Condition）用于指定策略的有效性取决于一系列预定义的条件是否满足。</p></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>下面是一个资源策略的示例，它允许另一个 AWS 账户的用户调用 Lambda 函数：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Version&quot;:</span> <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Statement&quot;:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;Effect&quot;:</span> <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Principal&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;AWS&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;Action&quot;:</span> <span class="string">&quot;lambda:InvokeFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Resource&quot;:</span> <span class="string">&quot;arn:aws:lambda:us-west-2:111122223333:function:MyFunction&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Condition&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;StringEquals&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceAccount&quot;:</span> <span class="string">&quot;123456789012&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ArnLike&quot;:</span> &#123;</span><br><span class="line">          <span class="attr">&quot;AWS:SourceArn&quot;:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/ExampleUser&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，只有在条件满足时（即请求来自特定账户和用户），指定的用户才能调用 MyFunction。通过使用资源策略，您可以跨账户共享 Lambda 函数，或者允许来自 AWS 服务（如 Amazon S3 事件、Amazon SNS 主题、Amazon DynamoDB 更新流等）的触发器调用您的函数。这是实现跨账户功能和集成 AWS 服务的一种强大方式。</p><h3 id="环境变量加密"><a href="#环境变量加密" class="headerlink" title="环境变量加密"></a>环境变量加密</h3><ul><li> 允许您为函数设置环境变量，用于存储配置信息。您可以使用 AWS Key Management Service (KMS) 加密这些环境变量，以保护敏感信息。<h3 id="VPC集成"><a href="#VPC集成" class="headerlink" title="VPC集成"></a>VPC集成</h3></li><li>Lambda函数可配置在VPC内运行</li></ul><h3 id="网络隔离和防火墙"><a href="#网络隔离和防火墙" class="headerlink" title="网络隔离和防火墙"></a>网络隔离和防火墙</h3><ul><li>配置 Lambda 函数在 VPC 中运行，您可以使用网络 ACL 和安全组作为网络层的防火墙，来控制流入和流出资源的流量。<h3 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h3></li><li>调用和执行情况可以通过 Amazon CloudWatch 进行监控和记录日志。您可以配置日志记录，以便在函数执行时捕获调用请求和响应数据。</li></ul><h2 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h2><p>一个经典的多服务场景，使用 AWS Lambda 的例子是一个自动化的图像处理平台。在这个场景中，用户上传图片到 Amazon S3，这会触发一个 Lambda 函数来处理这些图片（例如，压缩、转换格式、添加水印等），然后结果可以被存储在另一个 S3 桶中，或者被发送到其他服务进行进一步处理或分析。</p><p>以下是服务之间的作用和交互：</p><ol><li><p><strong>Amazon S3 (Simple Storage Service)</strong>:</p><ul><li>作为图像和处理后文件的存储位置。</li><li>触发 Lambda 函数以响应新上传的图像。</li></ul></li><li><p><strong>AWS Lambda</strong>:</p><ul><li>执行图像处理逻辑，如调整大小、格式转换或应用水印。</li><li>读取和写入 S3 桶中的文件。</li><li>可以调用其他 AWS 服务，如 Amazon Rekognition 进行图像分析。</li></ul></li><li><p><strong>Amazon Rekognition</strong>:</p><ul><li>提供图像和视频分析，如识别对象、场景和名人。</li><li>Lambda 函数可以将图像发送到 Rekognition 以获取元数据，并根据这些信息进一步处理或分类图像。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>:</p><ul><li>用于存储图像的元数据，如文件名、大小、图像类型、处理状态和 Rekognition 提供的任何分析数据。</li><li>Lambda 函数可以更新 DynamoDB 表以反映处理状态或存储分析结果。</li></ul></li><li><p><strong>Amazon SNS (Simple Notification Service)</strong> 或 <strong>Amazon SQS (Simple Queue Service)</strong>:</p><ul><li>用于通知系统的其他部分，例如，当图像处理完成时。</li><li>Lambda 函数可以发布消息到 SNS 主题或 SQS 队列，以触发其他处理流程或通知用户。</li></ul></li><li><p><strong>AWS Step Functions</strong>:</p><ul><li>管理和协调复杂的多步骤 Lambda 函数工作流。</li><li>Lambda 函数可以作为步骤函数状态机中的一个步骤，以确保处理逻辑按照预定顺序执行。</li></ul></li><li><p><strong>Amazon CloudWatch</strong>:</p><ul><li>监控 Lambda 函数的性能和日志。</li><li>Lambda 函数执行时会自动记录日志和各种指标，以供分析和调试。</li></ul></li></ol><p>在这个场景中，用户上传图片到 S3 桶，这个上传操作自动触发一个 Lambda 函数。Lambda 函数读取新上传的图片，进行必要的处理，然后将处理后的图片存储到另一个 S3 桶中。如果启用了图像分析，Lambda 函数还会调用 Amazon Rekognition。处理结果（包括图像元数据和分析数据）可以被存储到 DynamoDB。Lambda 函数还可以将处理完成的事件通过 SNS 或 SQS 发布出去，以便其他应用组件可以响应这些事件。整个处理流程可以用 AWS Step Functions 来协调。最后，Amazon CloudWatch 被用来监控整个过程，包括 Lambda 函数的性能和日志记录。</p><h1 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h1><h2 id="Classic-Load-Balancer（CLB）"><a href="#Classic-Load-Balancer（CLB）" class="headerlink" title="Classic Load Balancer（CLB）"></a>Classic Load Balancer（CLB）</h2><ul><li>支持基于TCP和HTTP/HTTPS的负载均衡</li><li>提供固定性能，但没有ALB和NLB那样灵活</li><li>支持一个简单的健康检查<h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3></li></ul><ul><li>旧的或遗留的应用程序，这些应用程序不需要复杂的路由规则，只需简单地在多个服务器之间分发流量。</li><li>示例：一个简单的网站或应用程序，客户端通过HTTP/HTTPS请求服务，CLB将请求均匀地分配给后端的多个EC2实例。</li></ul><h2 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h2><ul><li>ALB是为HTTP/HTTPS流量设计的，提供高级的请求路由功能，比如基于内容的路由。</li><li>支持路径、主机、HTTP头部、HTTP方法和查询参数等多种路由条件。</li><li>可以直接与容器化服务和微服务架构进行集成。</li><li>提供了更细粒度的健康检查。</li><li>支持WebSocket和HTTP/2。</li></ul><h3 id="场景举例-1"><a href="#场景举例-1" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>面向现代应用程序，特别是在微服务架构中，需要根据URL的不同路径将流量路由到不同的服务。</li><li>示例：一个电子商务网站，其中/catalog路径指向商品目录服务，而/cart路径指向购物车服务。ALB可以根据路径将流量路由到不同的服务或容器。</li></ul><h2 id="3-Network-Load-Balancer-NLB"><a href="#3-Network-Load-Balancer-NLB" class="headerlink" title="3. Network Load Balancer (NLB)"></a>3. Network Load Balancer (NLB)</h2><ul><li>NLB是在第4层（传输层）工作的负载均衡器，专门设计用于处理极高的性能和低延迟需求。</li><li>支持静态IP地址或Elastic IP地址。</li><li>适用于处理TCP、UDP和TLS流量。</li><li>能够处理数百万请求每秒，同时保持极低的延迟。</li><li>支持长连接，适合需要保持TCP连接的应用程序。</li></ul><h3 id="场景举例-2"><a href="#场景举例-2" class="headerlink" title="场景举例"></a>场景举例</h3><ul><li>高性能的实时游戏、股票交易平台或需要处理大量TCP连接的任何其他类型的应用程序。</li><li>示例：实时多人在线游戏服务器，玩家的连接需要低延迟和高吞吐量，NLB可以有效地在多个游戏服务器实例之间分配TCP流量。</li></ul><h2 id="其他服务集成"><a href="#其他服务集成" class="headerlink" title="其他服务集成"></a>其他服务集成</h2><p>AWS的Elastic Load Balancing (ELB)服务可以与许多其他AWS服务集成，以提供更完整、更强大的解决方案。以下是一些常与ELB集成使用的AWS服务：</p><h3 id="1-Amazon-EC2-Elastic-Compute-Cloud"><a href="#1-Amazon-EC2-Elastic-Compute-Cloud" class="headerlink" title="1. Amazon EC2 (Elastic Compute Cloud)"></a>1. Amazon EC2 (Elastic Compute Cloud)</h3><ul><li>ELB通常用来分配流量给后端的EC2实例。当实例的健康检查通过时，它们会被加入负载均衡器的目标池中。</li></ul><h3 id="2-Amazon-ECS-Elastic-Container-Service"><a href="#2-Amazon-ECS-Elastic-Container-Service" class="headerlink" title="2. Amazon ECS (Elastic Container Service)"></a>2. Amazon ECS (Elastic Container Service)</h3><ul><li>对于容器化的应用程序，ALB可以直接与ECS服务集成，自动注册容器实例作为负载均衡器的目标。</li></ul><h3 id="3-AWS-Fargate"><a href="#3-AWS-Fargate" class="headerlink" title="3. AWS Fargate"></a>3. AWS Fargate</h3><ul><li>Fargate提供了无服务器的容器执行环境，与ELB（特别是ALB）集成时，可以动态地负载均衡到Fargate任务。</li></ul><h3 id="4-Amazon-EKS-Elastic-Kubernetes-Service"><a href="#4-Amazon-EKS-Elastic-Kubernetes-Service" class="headerlink" title="4. Amazon EKS (Elastic Kubernetes Service)"></a>4. Amazon EKS (Elastic Kubernetes Service)</h3><ul><li>对于Kubernetes管理的容器应用程序，ELB可以用来平滑地分配流量到EKS集群中的Pods。</li></ul><h3 id="5-AWS-Lambda"><a href="#5-AWS-Lambda" class="headerlink" title="5. AWS Lambda"></a>5. AWS Lambda</h3><ul><li>ALB可以直接触发Lambda函数，允许无服务器架构的应用程序响应HTTP/HTTPS请求。</li></ul><h3 id="6-AWS-Auto-Scaling"><a href="#6-AWS-Auto-Scaling" class="headerlink" title="6. AWS Auto Scaling"></a>6. AWS Auto Scaling</h3><ul><li>ELB与Auto Scaling紧密集成，可以根据流量增减自动调整EC2实例的数量。</li></ul><h3 id="7-Amazon-RDS-Relational-Database-Service"><a href="#7-Amazon-RDS-Relational-Database-Service" class="headerlink" title="7. Amazon RDS (Relational Database Service)"></a>7. Amazon RDS (Relational Database Service)</h3><ul><li>虽然ELB不直接与RDS集成，但是可以配置应用程序在ELB后面连接到RDS数据库，从而使数据库层与应用层分离，提高可扩展性。</li></ul><h3 id="8-Amazon-S3-Simple-Storage-Service"><a href="#8-Amazon-S3-Simple-Storage-Service" class="headerlink" title="8. Amazon S3 (Simple Storage Service)"></a>8. Amazon S3 (Simple Storage Service)</h3><ul><li>对于静态内容，可以配置ALB通过HTTP(S)重定向到S3存储桶，以便高效地提供静态资源。</li></ul><h3 id="9-AWS-WAF-Web-Application-Firewall"><a href="#9-AWS-WAF-Web-Application-Firewall" class="headerlink" title="9. AWS WAF (Web Application Firewall)"></a>9. AWS WAF (Web Application Firewall)</h3><ul><li>可以将AWS WAF与ALB和NLB集成，为应用程序提供基于规则的防护，以防止常见的网络攻击。</li></ul><h3 id="10-AWS-Certificate-Manager-ACM"><a href="#10-AWS-Certificate-Manager-ACM" class="headerlink" title="10. AWS Certificate Manager (ACM)"></a>10. AWS Certificate Manager (ACM)</h3><ul><li>与ACM集成可以轻松地在ELB上部署SSL/TLS证书，以实现安全的数据传输。</li></ul><h3 id="11-Amazon-CloudWatch"><a href="#11-Amazon-CloudWatch" class="headerlink" title="11. Amazon CloudWatch"></a>11. Amazon CloudWatch</h3><ul><li>ELB与CloudWatch集成，提供了监控和日志记录功能，以跟踪和分析负载均衡器的性能。</li></ul><h3 id="12-AWS-CloudTrail"><a href="#12-AWS-CloudTrail" class="headerlink" title="12. AWS CloudTrail"></a>12. AWS CloudTrail</h3><ul><li>CloudTrail与ELB集成，可以记录所有ELB事件，帮助用户进行安全分析和操作审计。</li></ul><h3 id="13-AWS-Global-Accelerator"><a href="#13-AWS-Global-Accelerator" class="headerlink" title="13. AWS Global Accelerator"></a>13. AWS Global Accelerator</h3><ul><li>对于全球分布的应用程序，可以使用Global Accelerator提高用户到ELB的连接速度和可靠性。</li></ul><h3 id="14-AWS-Shield"><a href="#14-AWS-Shield" class="headerlink" title="14. AWS Shield"></a>14. AWS Shield</h3><ul><li>与ELB集成的AWS Shield提供了DDoS保护，以保护应用程序免受分布式拒绝服务攻击。</li></ul>]]></content>
    
    
    <summary type="html">AWS server for learning</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Basic for SAA</title>
    <link href="https://kalyan-zitiu.github.io/2023/12/24/SAA%E6%8F%90%E7%BA%B2/"/>
    <id>https://kalyan-zitiu.github.io/2023/12/24/SAA%E6%8F%90%E7%BA%B2/</id>
    <published>2023-12-24T12:00:00.000Z</published>
    <updated>2023-12-25T09:05:54.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SAA"><a href="#SAA" class="headerlink" title="SAA"></a>SAA</h1><h3 id="领域-1：-设计安全的架构"><a href="#领域-1：-设计安全的架构" class="headerlink" title="领域 1： 设计安全的架构"></a><strong>领域</strong> <strong>1</strong>： 设计安全的架构</h3><h3 id="跨多个账户的访问控制和管理："><a href="#跨多个账户的访问控制和管理：" class="headerlink" title="跨多个账户的访问控制和管理："></a>跨多个账户的访问控制和管理：</h3><p>跨多个AWS账户的访问控制和管理是一项复杂任务，它涉及到使用AWS的服务和功能来创建一个安全、高效且易于管理的多账户环境。以下是详细介绍如何实现这一目标的步骤：</p><h4 id="1-使用AWS-Organizations："><a href="#1-使用AWS-Organizations：" class="headerlink" title="1. 使用AWS Organizations："></a>1. 使用AWS Organizations：</h4><p>AWS Organizations是一个服务，允许您集中管理和治理您的多个AWS账户。使用AWS Organizations，您可以：</p><ul><li><strong>创建组织</strong>：将所有账户集合成一个组织，方便管理。</li><li><strong>创建组织单位（OUs）</strong>：将账户分组，以便对一组账户执行策略。</li><li><strong>服务控制策略（SCPs）</strong>：为OUs或单个账户设置策略，限制可执行的AWS服务和操作。</li></ul><h5 id="实践步骤："><a href="#实践步骤：" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>登录到AWS Management Console。</li><li>寻找并选择AWS Organizations服务。</li><li>创建一个新组织，邀请现有账户或创建新账户。</li><li>创建OUs，按功能、部门或其他逻辑方式组织账户。</li><li>应用SCPs以限制OU或账户级别的权限。</li></ol><h4 id="2-使用IAM进行用户管理："><a href="#2-使用IAM进行用户管理：" class="headerlink" title="2. 使用IAM进行用户管理："></a>2. 使用IAM进行用户管理：</h4><p>在AWS中，IAM允许您创建和管理用户、组、角色和权限策略。在多账户环境中，您应该：</p><ul><li><strong>创建IAM用户</strong>：为每个需要访问AWS服务的人员创建IAM用户。</li><li><strong>创建IAM组</strong>：根据用户的角色和职责，将用户分组，并将权限策略附加到组上。</li><li><strong>使用IAM角色跨账户访问</strong>：为需要在多个账户间进行操作的用户创建IAM角色。</li></ul><h5 id="实践步骤：-1"><a href="#实践步骤：-1" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在每个AWS账户中设置IAM用户和组。</li><li>定义IAM权限策略，明确用户和组可以执行的操作。</li><li>创建IAM角色以供跨账户访问，并定义信任关系以允许其他账户的用户扮演角色。</li></ol><h4 id="3-使用AWS-IAM-Identity-Center-SSO-："><a href="#3-使用AWS-IAM-Identity-Center-SSO-：" class="headerlink" title="3. 使用AWS IAM Identity Center (SSO)："></a>3. 使用AWS IAM Identity Center (SSO)：</h4><p>AWS IAM Identity Center (SSO)允许用户使用单一凭据登录到多个AWS账户和第三方应用程序。</p><h5 id="实践步骤：-2"><a href="#实践步骤：-2" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>设置AWS IAM Identity Center (SSO)。</li><li>配置身份源，例如Microsoft Active Directory。</li><li>设置SSO集成以连接到您的AWS账户。</li><li>为用户分配SSO访问权限，允许他们访问指定的账户和资源。</li></ol><h4 id="4-监控和审计："><a href="#4-监控和审计：" class="headerlink" title="4. 监控和审计："></a>4. 监控和审计：</h4><p>使用AWS CloudTrail和Amazon CloudWatch等服务来监控和记录所有账户的活动。</p><h5 id="实践步骤：-3"><a href="#实践步骤：-3" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在所有账户中启用AWS CloudTrail。</li><li>使用Amazon CloudWatch创建警报，监控关键活动和性能指标。</li><li>定期审计账户活动，确保遵守策略和最佳实践。</li></ol><h4 id="5-定期审查和优化："><a href="#5-定期审查和优化：" class="headerlink" title="5. 定期审查和优化："></a>5. 定期审查和优化：</h4><p>定期审查账户使用情况、权限策略和安全设置，以确保它们仍然适用于您的业务需求，并遵循最低权限原则。</p><h5 id="实践步骤：-4"><a href="#实践步骤：-4" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>使用IAM Access Advisor查看用户和角色的服务使用情况。</li><li>使用IAM Policy Simulator测试权限策略。</li><li>定期进行权限和安全设置的审计。</li></ol><h3 id="AWS-联合访问和身份服务（例如，AWS-Identity-and-Access-Management-IAM-、AWS-IAM-Identity-Center-AWS-Single-Sign-On-）"><a href="#AWS-联合访问和身份服务（例如，AWS-Identity-and-Access-Management-IAM-、AWS-IAM-Identity-Center-AWS-Single-Sign-On-）" class="headerlink" title="AWS 联合访问和身份服务（例如，AWS Identity and Access Management[IAM]、AWS IAM Identity Center [AWS Single Sign-On]）"></a>AWS 联合访问和身份服务（例如，AWS Identity and Access Management[IAM]、AWS IAM Identity Center [AWS Single Sign-On]）</h3><p>AWS提供了一系列服务来帮助您管理访问和身份验证，确保只有经过授权的用户才能访问您的资源。以下是对AWS联合访问和身份服务的详细指导，重点介绍AWS Identity and Access Management (IAM)和AWS IAM Identity Center（以前称为AWS Single Sign-On或AWS SSO）。</p><h4 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h4><p>IAM是AWS的核心服务之一，它允许您安全地控制对AWS服务和资源的访问。以下是如何使用IAM的步骤：</p><h5 id="1-创建IAM用户和组"><a href="#1-创建IAM用户和组" class="headerlink" title="1. 创建IAM用户和组"></a>1. 创建IAM用户和组</h5><ul><li><strong>IAM用户</strong>：代表个人或服务的身份，可以是一个人或一个系统/应用程序。</li><li><strong>IAM组</strong>：是一组IAM用户，可以让您更容易地管理多个用户的权限。</li></ul><h5 id="实践步骤：-5"><a href="#实践步骤：-5" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>登录到AWS管理控制台。</li><li>导航到IAM控制台。</li><li>创建新用户：<ul><li>选择“用户”然后点击“添加用户”。</li><li>输入用户名，选择“程序访问”和/或“AWS管理控制台访问”。</li><li>设置密码和密码策略（如果选择了控制台访问）。</li></ul></li><li>创建新组：<ul><li>选择“用户组”然后点击“创建新组”。</li><li>输入组名，选择适当的权限策略。</li><li>将用户添加到组。</li></ul></li></ol><h5 id="2-创建和管理访问密钥"><a href="#2-创建和管理访问密钥" class="headerlink" title="2. 创建和管理访问密钥"></a>2. 创建和管理访问密钥</h5><ul><li>对于需要通过API、CLI或SDK访问AWS服务的用户，您需要创建访问密钥。</li></ul><h4 id="实践步骤：-6"><a href="#实践步骤：-6" class="headerlink" title="实践步骤："></a>实践步骤：</h4><ol><li>在IAM用户的“安全凭证”选项卡下创建新的访问密钥。</li><li>安全地保存访问密钥ID和秘密访问密钥。</li></ol><h5 id="3-使用IAM角色和策略"><a href="#3-使用IAM角色和策略" class="headerlink" title="3. 使用IAM角色和策略"></a>3. 使用IAM角色和策略</h5><ul><li><strong>IAM角色</strong>：是一种权限集合，可以被分配给任何一个用户、服务或其他角色。</li><li><strong>IAM策略</strong>：定义了具体的权限，描述了可以对哪些资源执行哪些操作。</li></ul><h5 id="实践步骤：-7"><a href="#实践步骤：-7" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>创建新角色并选择信任关系（例如，EC2、Lambda等）。</li><li>附加策略到角色以定义权限。</li><li>将角色分配给AWS资源或服务。</li></ol><h4 id="4-使用条件和细粒度的权限控制"><a href="#4-使用条件和细粒度的权限控制" class="headerlink" title="4. 使用条件和细粒度的权限控制"></a>4. 使用条件和细粒度的权限控制</h4><ul><li>通过使用条件和细粒度的权限控制，您可以定义更精确的访问规则。</li></ul><h5 id="实践步骤：-8"><a href="#实践步骤：-8" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在IAM策略中定义条件。</li><li>使用策略模拟器测试策略。</li></ol><h4 id="AWS-IAM-Identity-Center-AWS-SSO"><a href="#AWS-IAM-Identity-Center-AWS-SSO" class="headerlink" title="AWS IAM Identity Center (AWS SSO)"></a>AWS IAM Identity Center (AWS SSO)</h4><p>AWS IAM Identity Center允许您中心化管理用户对多个AWS账户和业务应用程序的访问。以下是如何使用AWS IAM Identity Center的步骤：</p><h5 id="1-设置AWS-IAM-Identity-Center"><a href="#1-设置AWS-IAM-Identity-Center" class="headerlink" title="1. 设置AWS IAM Identity Center"></a>1. 设置AWS IAM Identity Center</h5><ul><li>通过AWS IAM Identity Center，您可以连接到现有的身份源，如Microsoft Active Directory，或者使用AWS SSO内置的身份存储。</li></ul><h5 id="实践步骤：-9"><a href="#实践步骤：-9" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>打开AWS IAM Identity Center控制台。</li><li>配置您的身份源。</li><li>启用AWS SSO。</li></ol><h5 id="2-配置AWS账户和应用程序"><a href="#2-配置AWS账户和应用程序" class="headerlink" title="2. 配置AWS账户和应用程序"></a>2. 配置AWS账户和应用程序</h5><ul><li>将AWS账户集成到AWS IAM Identity Center，并配置任何内部或第三方应用程序以使用AWS SSO。</li></ul><h5 id="实践步骤：-10"><a href="#实践步骤：-10" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在AWS IAM Identity Center控制台中，选择“AWS组织”来管理账户访问。</li><li>为每个账户分配用户或组。</li><li>配置单个应用程序访问。</li></ol><h5 id="3-分配用户权限"><a href="#3-分配用户权限" class="headerlink" title="3. 分配用户权限"></a>3. 分配用户权限</h5><ul><li>为用户分配在AWS账户和应用程序中的权限。</li></ul><h5 id="实践步骤：-11"><a href="#实践步骤：-11" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>在AWS IAM Identity Center中，选择“用户”或“组”。</li><li>分配访问权限到AWS账户或应用程序。</li></ol><h5 id="4-用户登录和访问管理"><a href="#4-用户登录和访问管理" class="headerlink" title="4. 用户登录和访问管理"></a>4. 用户登录和访问管理</h5><ul><li>用户可以使用单一登录访问他们有权访问的AWS账户和应用程序。</li></ul><h5 id="实践步骤：-12"><a href="#实践步骤：-12" class="headerlink" title="实践步骤："></a>实践步骤：</h5><ol><li>用户访问AWS IAM Identity Center的用户门户。</li><li>用户使用他们的单一凭证登录。</li><li>用户选择他们有权访问的账户或应用程序。</li></ol><h3 id="AWS-全球基础设施（例如，可用区、AWS-区域）"><a href="#AWS-全球基础设施（例如，可用区、AWS-区域）" class="headerlink" title="AWS 全球基础设施（例如，可用区、AWS 区域）"></a>AWS 全球基础设施（例如，可用区、AWS 区域）</h3><h4 id="AWS-全球基础设施概述"><a href="#AWS-全球基础设施概述" class="headerlink" title="AWS 全球基础设施概述"></a>AWS 全球基础设施概述</h4><p>AWS 全球基础设施是由数据中心组成的广泛网络，这些数据中心分布在世界各地的多个地理区域中。这个基础设施支持运行亚马逊网络服务（Amazon Web Services，简称AWS）的所有服务，为用户提供了高可用性、高可靠性和高扩展性的云计算资源。</p><h4 id="AWS-区域"><a href="#AWS-区域" class="headerlink" title="AWS 区域"></a>AWS 区域</h4><p>AWS 区域是物理位置的集合，每个区域都包含多个独立的可用区。每个AWS区域都是一个独立的地理区域，比如美国东部（北弗吉尼亚）、欧洲（爱尔兰）、亚太（孟买）等。</p><h5 id="设计原则和优势"><a href="#设计原则和优势" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>隔离性</strong>：每个区域都是独立运行的，故障不会传播到其他区域。</li><li><strong>低延迟</strong>：用户可以选择离他们的客户或用户最近的区域，以减少延迟。</li><li><strong>合规性</strong>：用户可以选择将数据存储在特定的法律或合规性要求的区域。</li></ul><h5 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>登录AWS管理控制台。</li><li>在控制台顶部，选择您希望部署资源的区域。</li><li>部署AWS服务（例如EC2实例、S3存储桶等）时，确保您在正确的区域操作。</li></ol><h4 id="AWS-可用区"><a href="#AWS-可用区" class="headerlink" title="AWS 可用区"></a>AWS 可用区</h4><p>AWS 可用区是指在单个区域内的一个或多个离散的数据中心，每个数据中心都有独立的电源、冷却和网络连接，以降低单点故障的风险。</p><h5 id="设计原则和优势-1"><a href="#设计原则和优势-1" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>高可用性</strong>：通过在多个可用区中部署应用程序和数据，可以提高容错能力和业务持续性。</li><li><strong>独立性</strong>：每个可用区都设计为与其他可用区隔离，即使在极端情况下也能保持运行。</li></ul><h5 id="实践步骤-1"><a href="#实践步骤-1" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设计应用程序架构时，确保使用多个可用区以实现高可用性。</li><li>在创建资源（如EC2实例）时，选择多个可用区进行部署。</li><li>配置负载均衡器和数据库服务以跨多个可用区分布。</li></ol><h4 id="AWS-边缘位置"><a href="#AWS-边缘位置" class="headerlink" title="AWS 边缘位置"></a>AWS 边缘位置</h4><p>AWS 边缘位置是位于世界各地的站点，用于缓存数据，从而减少对用户的响应时间。这些边缘位置是由Amazon CloudFront（AWS的内容分发网络服务）和AWS Lambda@Edge使用的。</p><h5 id="设计原则和优势-2"><a href="#设计原则和优势-2" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>性能优化</strong>：边缘位置可以减少数据传输的延迟，加快内容的交付速度。</li><li><strong>可扩展性</strong>：AWS的全球网络可以轻松处理大量请求，满足不断增长的需求。</li></ul><h5 id="实践步骤-2"><a href="#实践步骤-2" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>通过Amazon CloudFront创建分发，选择一个或多个原始位置。</li><li>为常用内容配置缓存行为和TTL（生存时间）设置。</li><li>使用Lambda@Edge来运行自定义代码，它会响应CloudFront事件。</li></ol><h4 id="结合使用区域和可用区"><a href="#结合使用区域和可用区" class="headerlink" title="结合使用区域和可用区"></a>结合使用区域和可用区</h4><p>在AWS中，最佳实践是结合使用区域和可用区来设计和部署应用程序和服务。这样可以优化性能，同时确保业务连续性和灾难恢复。</p><h5 id="实践步骤-3"><a href="#实践步骤-3" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>根据用户群体选择合适的区域部署服务。</li><li>在该区域的多个可用区中创建和配置资源，以实现高可用性。</li><li>使用AWS服务，如Amazon RDS和Amazon EC2 Auto Scaling，跨多个可用区自动管理资源。</li></ol><h3 id="AWS-安全最佳实践（例如，最低权限原则）"><a href="#AWS-安全最佳实践（例如，最低权限原则）" class="headerlink" title="AWS 安全最佳实践（例如，最低权限原则）"></a>AWS 安全最佳实践（例如，最低权限原则）</h3><h4 id="AWS-安全最佳实践概述"><a href="#AWS-安全最佳实践概述" class="headerlink" title="AWS 安全最佳实践概述"></a>AWS 安全最佳实践概述</h4><p>在使用AWS时，遵循安全最佳实践是至关重要的，因为它有助于保护您的云资源免受未经授权的访问和潜在的安全威胁。AWS提供了强大的工具和服务来帮助用户实现这些最佳实践。</p><h4 id="遵循最低权限原则"><a href="#遵循最低权限原则" class="headerlink" title="遵循最低权限原则"></a>遵循最低权限原则</h4><p>最低权限原则是指仅授予必要的权限，以执行特定任务的最小权限集。在AWS中，这通常涉及IAM（Identity and Access Management）的精细权限管理。</p><h5 id="设计原则和优势-3"><a href="#设计原则和优势-3" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>风险降低</strong>：限制权限可以减少安全风险和潜在的数据泄露。</li><li><strong>易于管理</strong>：精确的权限使得权限管理更加清晰和容易维护。</li></ul><h5 id="实践步骤-4"><a href="#实践步骤-4" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个IAM用户创建唯一的身份，而不是共享凭证。</li><li>为每个用户分配最小的必要权限，以完成其工作。</li><li>使用IAM策略来精细控制访问权限。</li><li>定期审查和调整权限，确保它们仍然符合需要。</li></ol><h4 id="使用IAM角色和策略"><a href="#使用IAM角色和策略" class="headerlink" title="使用IAM角色和策略"></a>使用IAM角色和策略</h4><p>IAM角色允许您在不共享安全凭证的情况下，将权限委托给用户、应用程序或服务。</p><h5 id="设计原则和优势-4"><a href="#设计原则和优势-4" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>安全性</strong>：角色不需要永久性凭证，使用时会临时提供安全令牌。</li><li><strong>灵活性</strong>：可以轻松地向用户或服务分配和撤销角色。</li></ul><h5 id="实践步骤-5"><a href="#实践步骤-5" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建IAM角色并定义其权限策略。</li><li>将角色分配给需要特定权限的AWS服务或用户。</li><li>当任务完成或角色不再需要时，撤销对该角色的访问权限。</li></ol><h4 id="保护数据"><a href="#保护数据" class="headerlink" title="保护数据"></a>保护数据</h4><p>在AWS中，保护存储和传输中的数据是保证安全的关键组成部分。</p><h5 id="设计原则和优势-5"><a href="#设计原则和优势-5" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>数据加密</strong>：确保数据在传输和静态时都是加密的。</li><li><strong>数据备份</strong>：定期备份数据以防止丢失或损坏。</li></ul><h5 id="实践步骤-6"><a href="#实践步骤-6" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS服务（如S3、EBS、RDS）时，启用加密功能。</li><li>对敏感数据实施端到端加密。</li><li>定期备份数据，并测试恢复过程。</li></ol><h4 id="监控和日志记录"><a href="#监控和日志记录" class="headerlink" title="监控和日志记录"></a>监控和日志记录</h4><p>使用AWS提供的监控和日志记录工具可以帮助您检测和响应安全事件。</p><h5 id="设计原则和优势-6"><a href="#设计原则和优势-6" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>可见性</strong>：日志提供了对环境中发生的活动的洞察。</li><li><strong>审计</strong>：监控和日志记录有助于满足合规性要求。</li></ul><h5 id="实践步骤-7"><a href="#实践步骤-7" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS CloudTrail来记录用户活动和API使用情况。</li><li>配置Amazon CloudWatch来监控资源和应用程序。</li><li>定期审查日志文件，并设置警报以监控可疑活动。</li></ol><h4 id="定期审计和合规性检查"><a href="#定期审计和合规性检查" class="headerlink" title="定期审计和合规性检查"></a>定期审计和合规性检查</h4><p>定期进行安全审计和合规性检查，以确保持续遵守安全最佳实践。</p><h5 id="设计原则和优势-7"><a href="#设计原则和优势-7" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>持续改进</strong>：审计有助于识别和修复潜在的安全问题。</li><li><strong>合规性</strong>：检查有助于确保符合法律和行业标准。</li></ul><h5 id="实践步骤-8"><a href="#实践步骤-8" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Config来跟踪资源配置的变化和合规性。</li><li>利用AWS Trusted Advisor来获取安全优化建议。</li><li>定期进行安全评估，如使用AWS Inspector。</li></ol><h3 id="AWS-责任共担模式"><a href="#AWS-责任共担模式" class="headerlink" title="AWS 责任共担模式"></a>AWS 责任共担模式</h3><h4 id="AWS-责任共担模式概述"><a href="#AWS-责任共担模式概述" class="headerlink" title="AWS 责任共担模式概述"></a>AWS 责任共担模式概述</h4><p>AWS 责任共担模式是一个安全和合规性框架，其中AWS和客户共同承担确保云环境安全的责任。在这个模型中，AWS负责保护云计算基础设施的安全，而客户则负责在AWS云中运行的内容、平台、应用程序和数据的安全。</p><h4 id="AWS-的责任"><a href="#AWS-的责任" class="headerlink" title="AWS 的责任"></a>AWS 的责任</h4><p>在责任共担模式中，AWS负责“云的安全”，这涉及到保护其基础设施的安全，包括硬件、软件、网络和设施。</p><h5 id="设计原则和优势-8"><a href="#设计原则和优势-8" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>基础设施安全</strong>：AWS负责保护全球数据中心的物理安全。</li><li><strong>服务安全</strong>：AWS负责其服务的底层软件和硬件的安全性。</li></ul><h5 id="实践步骤-9"><a href="#实践步骤-9" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>AWS定期维护其数据中心的物理安全措施。</li><li>AWS管理云服务的底层操作系统和虚拟化层。</li><li>AWS实施网络基础设施的安全性和弹性。</li></ol><h4 id="客户的责任"><a href="#客户的责任" class="headerlink" title="客户的责任"></a>客户的责任</h4><p>客户负责“云中的安全”，这包括客户设置和管理的数据、应用程序以及其他资源的安全性。</p><h5 id="设计原则和优势-9"><a href="#设计原则和优势-9" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>数据保护</strong>：客户负责管理自己的数据加密和访问控制。</li><li><strong>身份管理</strong>：客户负责使用IAM工具管理用户访问权限。</li><li><strong>操作安全</strong>：客户负责操作系统、网络配置和应用程序的安全性。</li></ul><h5 id="实践步骤-10"><a href="#实践步骤-10" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>客户应加密敏感数据，并管理加密密钥。</li><li>客户应配置IAM策略，实施最低权限原则。</li><li>客户应定期更新和打补丁自己的应用程序和操作系统。</li></ol><h4 id="共同责任的例子"><a href="#共同责任的例子" class="headerlink" title="共同责任的例子"></a>共同责任的例子</h4><p>在责任共担模式下，某些安全责任是由AWS和客户共同承担的。</p><h5 id="设计原则和优势-10"><a href="#设计原则和优势-10" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>合作防御</strong>：通过AWS和客户的共同努力，可以建立更强大的安全防线。</li><li><strong>明确职责</strong>：清晰地划分责任有助于避免安全漏洞和责任模糊。</li></ul><h5 id="实践步骤-11"><a href="#实践步骤-11" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>AWS提供网络防火墙和DDoS保护服务，客户负责配置这些服务。</li><li>AWS提供身份和访问管理服务，客户负责使用这些服务来控制对资源的访问。</li><li>AWS提供日志服务，客户负责监控和分析日志数据。</li></ol><h4 id="理解责任共担模式的重要性"><a href="#理解责任共担模式的重要性" class="headerlink" title="理解责任共担模式的重要性"></a>理解责任共担模式的重要性</h4><p>理解并执行责任共担模式对于在AWS上运营的任何组织都是至关重要的，因为它有助于确保整个IT环境的安全性。</p><h5 id="设计原则和优势-11"><a href="#设计原则和优势-11" class="headerlink" title="设计原则和优势"></a>设计原则和优势</h5><ul><li><strong>安全合作</strong>：确保所有安全层面都得到适当的关注和资源。</li><li><strong>风险管理</strong>：帮助组织更好地理解和管理其在云中的风险。</li></ul><h5 id="实践步骤-12"><a href="#实践步骤-12" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>客户应该了解和评估其在云中的责任。</li><li>客户应该实施必要的策略和控制措施来管理其资源。</li><li>客户应该定期进行安全评估和合规性审查。</li></ol><h3 id="将AWS安全最佳实践应用于IAM用户和根用户"><a href="#将AWS安全最佳实践应用于IAM用户和根用户" class="headerlink" title="将AWS安全最佳实践应用于IAM用户和根用户"></a>将AWS安全最佳实践应用于IAM用户和根用户</h3><ol><li><p><strong>为根用户和IAM用户启用多重验证（MFA）</strong>：</p><ul><li>根用户：AWS账户的根用户拥有完全的访问权限，因此保护它至关重要。应启用MFA，以添加一层额外的安全性。</li><li>IAM用户：对于具有重要权限的IAM用户，也应启用MFA。这可以减少因密码泄露导致的安全风险。</li></ul></li><li><p><strong>最小权限原则</strong>：</p><ul><li>仅授予必要的权限。每个IAM用户和角色都应只拥有完成其任务所需的最少权限。</li></ul></li><li><p><strong>定期审核和更新权限</strong>：</p><ul><li>定期审查IAM用户和根用户的权限，确保它们仍符合当前的业务需求。</li></ul></li><li><p><strong>使用强密码策略</strong>：</p><ul><li>为IAM用户实施强密码策略，包括密码复杂度、更换频率和历史密码的限制。</li></ul></li></ol><h3 id="设计包含IAM用户、组、角色和策略的灵活授权模型"><a href="#设计包含IAM用户、组、角色和策略的灵活授权模型" class="headerlink" title="设计包含IAM用户、组、角色和策略的灵活授权模型"></a>设计包含IAM用户、组、角色和策略的灵活授权模型</h3><ol><li><p><strong>使用IAM组管理用户权限</strong>：</p><ul><li>将具有相似权限需求的IAM用户组合到组中，这样可以更容易地管理它们的权限。</li></ul></li><li><p><strong>创建和管理IAM策略</strong>：</p><ul><li>使用IAM策略精确控制用户、组和角色的权限。可以使用AWS管理的策略或创建自定义策略。</li></ul></li><li><p><strong>利用条件语句提高安全性</strong>：</p><ul><li>在IAM策略中使用条件语句，根据需求对权限进行细粒度控制，如基于IP地址限制访问。</li></ul></li></ol><h3 id="设计基于角色的访问控制策略"><a href="#设计基于角色的访问控制策略" class="headerlink" title="设计基于角色的访问控制策略"></a>设计基于角色的访问控制策略</h3><ol><li><p><strong>使用AWS Security Token Service (AWS STS) 临时凭证</strong>：</p><ul><li>使用AWS STS生成临时安全凭证，使用户可以在有限的时间内访问AWS资源，这提高了安全性并降低了长期凭证泄露的风险。</li></ul></li><li><p><strong>角色切换</strong>：</p><ul><li>允许用户切换到具有不同权限的IAM角色，这样可以避免创建具有广泛权限的单个用户。</li></ul></li><li><p><strong>跨账户访问</strong>：</p><ul><li>通过创建IAM角色并定义信任关系，允许从一个AWS账户访问另一个账户中的资源。</li></ul></li></ol><h3 id="为多个AWS账户设计安全策略"><a href="#为多个AWS账户设计安全策略" class="headerlink" title="为多个AWS账户设计安全策略"></a>为多个AWS账户设计安全策略</h3><ol><li><p><strong>使用AWS Control Tower</strong>：</p><ul><li>AWS Control Tower提供了一种简单的方法来设置和管理多个AWS账户的安全性和合规性。</li></ul></li><li><p><strong>服务控制策略（SCP）</strong>：</p><ul><li>SCPs用于管理AWS组织中的账户权限。它们可以限制账户中可以执行的操作，从而提高整体安全性。</li></ul></li></ol><h3 id="确定AWS服务的资源策略的正确用法"><a href="#确定AWS服务的资源策略的正确用法" class="headerlink" title="确定AWS服务的资源策略的正确用法"></a>确定AWS服务的资源策略的正确用法</h3><ol><li><p><strong>利用资源策略控制访问</strong>：</p><ul><li>资源策略（如S3桶策略、Lambda函数策略）允许定义哪些实体可以执行哪些操作。</li></ul></li><li><p><strong>与IAM策略结合使用</strong>：</p><ul><li>结合使用IAM和资源策略，以实现更精细的访问控制。</li></ul></li></ol><h3 id="确定何时将Directory-Service与IAM角色联合"><a href="#确定何时将Directory-Service与IAM角色联合" class="headerlink" title="确定何时将Directory Service与IAM角色联合"></a>确定何时将Directory Service与IAM角色联合</h3><ol><li><p><strong>联合身份管理</strong>：</p><ul><li>当需要与企业目录服务（如Active Directory）集成时，可以使用联合身份管理。这允许企业用户使用其现有的身份凭证来访问AWS资源。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>当企业需要将其用户身份管理集中在现有的目录服务中时，或者需要对</li></ul></li></ol><p>访问AWS服务的用户进行详细审计时，应考虑使用联合身份管理。</p><p>以上是应用AWS安全最佳实践的一些关键方面。通过合理的设计和持续的管理，可以显著提高AWS环境的安全性。</p><h3 id="应用程序配置和凭证安全"><a href="#应用程序配置和凭证安全" class="headerlink" title="应用程序配置和凭证安全"></a>应用程序配置和凭证安全</h3><h4 id="应用程序配置和凭证安全-1"><a href="#应用程序配置和凭证安全-1" class="headerlink" title="应用程序配置和凭证安全"></a>应用程序配置和凭证安全</h4><p>在现代云基础设施中，确保应用程序配置和凭证的安全是至关重要的。不当的凭证管理和配置错误是导致安全漏洞的常见原因。以下是一些关键的最佳实践，可以帮助确保应用程序配置和凭证的安全性。</p><h4 id="管理和保护凭证"><a href="#管理和保护凭证" class="headerlink" title="管理和保护凭证"></a>管理和保护凭证</h4><p>凭证，如密码、密钥和令牌，是访问资源的关键。不正确的管理可能导致安全风险。</p><h5 id="最佳实践原则"><a href="#最佳实践原则" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>集中管理</strong>：使用集中的身份管理系统来存储和管理凭证。</li><li><strong>定期轮换</strong>：定期更换凭证，以减少被泄露的风险。</li></ul><h5 id="实践步骤-13"><a href="#实践步骤-13" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Secrets Manager或类似服务存储敏感凭证。</li><li>定期自动更换数据库和服务的密码。</li><li>实施凭证轮换策略，确保旧凭证在一定时间后失效。</li></ol><h4 id="使用环境变量存储配置"><a href="#使用环境变量存储配置" class="headerlink" title="使用环境变量存储配置"></a>使用环境变量存储配置</h4><p>将应用程序配置存储在环境变量中，而不是硬编码在应用程序代码中，可以提高灵活性和安全性。</p><h5 id="最佳实践原则-1"><a href="#最佳实践原则-1" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>分离配置</strong>：将配置与代码分离，使之可以在不同环境中重复使用。</li><li><strong>避免硬编码</strong>：不要在代码中硬编码敏感信息。</li></ul><h5 id="实践步骤-14"><a href="#实践步骤-14" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序的启动脚本中设置环境变量。</li><li>使用AWS Elastic Beanstalk、AWS Lambda或其他服务的配置选项来管理环境变量。</li><li>确保不在源代码仓库中暴露环境变量的值。</li></ol><h4 id="实施应用层加密"><a href="#实施应用层加密" class="headerlink" title="实施应用层加密"></a>实施应用层加密</h4><p>对敏感数据进行应用层加密可以保护数据，即使在传输过程中或在数据存储时被截获也能保持其安全性。</p><h5 id="最佳实践原则-2"><a href="#最佳实践原则-2" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>端到端加密</strong>：加密数据传输和存储过程中的所有敏感信息。</li><li><strong>使用强加密标准</strong>：使用行业标准的加密算法和协议。</li></ul><h5 id="实践步骤-15"><a href="#实践步骤-15" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用TLS/SSL协议加密数据在传输中的敏感信息。</li><li>在数据库或存储层加密敏感数据。</li><li>使用AWS KMS或类似服务管理加密密钥。</li></ol><h4 id="定期审计和监控"><a href="#定期审计和监控" class="headerlink" title="定期审计和监控"></a>定期审计和监控</h4><p>通过定期审计和监控，可以发现潜在的安全问题，并确保凭证和配置的安全性。</p><h5 id="最佳实践原则-3"><a href="#最佳实践原则-3" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>持续监控</strong>：实时监控配置和凭证的使用情况。</li><li><strong>定期审计</strong>：定期审查配置和凭证的安全性。</li></ul><h5 id="实践步骤-16"><a href="#实践步骤-16" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>利用AWS CloudTrail监控对敏感凭证的访问。</li><li>定期检查IAM权限和凭证的使用情况。</li><li>使用自动化工具检测配置的不一致性和潜在的安全问题。</li></ol><h4 id="敏感数据的访问控制"><a href="#敏感数据的访问控制" class="headerlink" title="敏感数据的访问控制"></a>敏感数据的访问控制</h4><p>确保只有授权用户和系统能够访问敏感数据。</p><h5 id="最佳实践原则-4"><a href="#最佳实践原则-4" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>最小权限</strong>：遵循最小权限原则，仅授予必要的访问权限。</li><li><strong>细粒度控制</strong>：实施细粒度的访问控制策略。</li></ul><h5 id="实践步骤-17"><a href="#实践步骤-17" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用IAM角色和策略来限制对敏感数据的访问。</li><li>在数据库和文件存储级别实现访问控制。</li><li>审查和更新访问权限，以反映组织变化或人员变动。</li></ol><h3 id="AWS-服务终端节点"><a href="#AWS-服务终端节点" class="headerlink" title="AWS 服务终端节点"></a>AWS 服务终端节点</h3><h4 id="AWS-服务终端节点（VPC-Endpoints）"><a href="#AWS-服务终端节点（VPC-Endpoints）" class="headerlink" title="AWS 服务终端节点（VPC Endpoints）"></a>AWS 服务终端节点（VPC Endpoints）</h4><p>AWS服务终端节点允许你在Amazon Virtual Private Cloud (VPC)内部安全地连接到AWS服务，而无需通过公共互联网。这样可以减少数据被截获的风险，并可能提高连接速度。</p><h4 id="理解服务终端节点"><a href="#理解服务终端节点" class="headerlink" title="理解服务终端节点"></a>理解服务终端节点</h4><p>服务终端节点是AWS为了提高网络安全和效率而设计的一种机制，它们与传统的通过公网访问AWS服务的方式不同。</p><h5 id="最佳实践原则-5"><a href="#最佳实践原则-5" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：通过私有网络访问AWS服务，减少对公共互联网的依赖。</li><li><strong>性能</strong>：可能提高访问速度，因为数据不必离开Amazon网络。</li></ul><h5 id="实践步骤-18"><a href="#实践步骤-18" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在VPC控制台中创建终端节点。</li><li>选择你需要连接的AWS服务（例如S3或DynamoDB）。</li><li>指定VPC和子网，以及要关联的路由表。</li><li>设置安全组，以控制流向服务的流量。</li></ol><h4 id="配置服务终端节点"><a href="#配置服务终端节点" class="headerlink" title="配置服务终端节点"></a>配置服务终端节点</h4><p>配置服务终端节点时，需要确定哪些资源需要通过终端节点进行通信，并相应地配置网络。</p><h5 id="最佳实践原则-6"><a href="#最佳实践原则-6" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>精确配置</strong>：确保仅允许必要的流量通过终端节点。</li><li><strong>细粒度访问控制</strong>：使用IAM策略来控制对服务的访问。</li></ul><h5 id="实践步骤-19"><a href="#实践步骤-19" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为需要访问AWS服务的资源创建终端节点。</li><li>配置路由表，以确保流量定向到终端节点。</li><li>设定安全组规则，限制通过终端节点的流量类型。</li><li>如果可能，使用IAM策略进一步限制对服务的访问。</li></ol><h4 id="监控服务终端节点"><a href="#监控服务终端节点" class="headerlink" title="监控服务终端节点"></a>监控服务终端节点</h4><p>监控是确保服务终端节点安全和高效运行的关键环节。AWS提供了多种工具来帮助监控这些终端节点。</p><h5 id="最佳实践原则-7"><a href="#最佳实践原则-7" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>可见性</strong>：确保你可以监控和记录通过终端节点的所有流量。</li><li><strong>报告</strong>：定期查看终端节点的性能和安全性报告。</li></ul><h5 id="实践步骤-20"><a href="#实践步骤-20" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用VPC流日志来捕获有关网络流量的信息。</li><li>利用AWS CloudWatch监控终端节点的性能指标。</li><li>定期审查安全日志，以检测异常或未授权的访问尝试。</li></ol><h4 id="故障排除服务终端节点"><a href="#故障排除服务终端节点" class="headerlink" title="故障排除服务终端节点"></a>故障排除服务终端节点</h4><p>当服务终端节点出现问题时，需要能够快速诊断和解决问题。</p><h5 id="最佳实践原则-8"><a href="#最佳实践原则-8" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>响应性</strong>：迅速识别和响应终端节点的问题。</li><li><strong>详细日志</strong>：保持详细的日志记录，以便于故障排除。</li></ul><h5 id="实践步骤-21"><a href="#实践步骤-21" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>验证路由表和网络ACLs配置是否正确。</li><li>检查安全组规则，确保它们没有阻止预期的流量。</li><li>查看VPC流日志和CloudWatch指标，寻找任何异常。</li><li>如果使用了IAM策略，确认策略允许预期的访问。</li></ol><h3 id="控制-AWS-上的端口、协议和网络流量"><a href="#控制-AWS-上的端口、协议和网络流量" class="headerlink" title="控制 AWS 上的端口、协议和网络流量"></a>控制 AWS 上的端口、协议和网络流量</h3><h4 id="控制-AWS-上的端口、协议和网络流量-1"><a href="#控制-AWS-上的端口、协议和网络流量-1" class="headerlink" title="控制 AWS 上的端口、协议和网络流量"></a>控制 AWS 上的端口、协议和网络流量</h4><p>在AWS中，对端口、协议和网络流量的控制是通过网络访问控制列表（Network Access Control Lists, NACLs）、安全组（Security Groups）和路由表来实现的。这些工具共同作用于AWS的虚拟私有云（VPC）中，确保了网络流量的安全和合规。</p><h4 id="理解端口和协议"><a href="#理解端口和协议" class="headerlink" title="理解端口和协议"></a>理解端口和协议</h4><p>在网络通信中，端口和协议是数据传输的基础。端口是网络连接的逻辑端点，而协议则定义了数据如何在网络中传输。</p><h5 id="最佳实践原则-9"><a href="#最佳实践原则-9" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>明确定义</strong>：清晰定义哪些端口和协议对业务是必需的。</li><li><strong>最小暴露</strong>：仅开放必要的端口和协议，以减少潜在的攻击面。</li></ul><h5 id="实践步骤-22"><a href="#实践步骤-22" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>识别应用程序和服务所需的端口和协议。</li><li>确定哪些端口需要对外开放，哪些可以仅在内部网络中访问。</li><li>规划公共和私有子网中的资源布局，以控制端口和协议的暴露。</li></ol><h4 id="使用安全组控制访问"><a href="#使用安全组控制访问" class="headerlink" title="使用安全组控制访问"></a>使用安全组控制访问</h4><p>安全组是AWS中控制实例访问的主要工具。它们允许或拒绝到达实例的流量，并且是状态性的，这意味着返回流量自动允许。</p><h5 id="最佳实践原则-10"><a href="#最佳实践原则-10" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>实例级别保护</strong>：为每个实例配置安全组，以提供精细的访问控制。</li><li><strong>默认拒绝所有</strong>：默认情况下拒绝所有入站流量，仅按需开放。</li></ul><h5 id="实践步骤-23"><a href="#实践步骤-23" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建安全组并定义入站和出站规则。</li><li>为每个服务和应用程序配置专用的安全组。</li><li>定期审查和更新安全组规则，以保持最新的安全状态。</li></ol><h4 id="利用-NACLs-控制子网流量"><a href="#利用-NACLs-控制子网流量" class="headerlink" title="利用 NACLs 控制子网流量"></a>利用 NACLs 控制子网流量</h4><p>NACLs提供了一种在子网级别控制流量的方法。与安全组不同，NACLs是无状态的，需要为入站和出站流量分别定义规则。</p><h5 id="最佳实践原则-11"><a href="#最佳实践原则-11" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>子网级别保护</strong>：使用NACLs为整个子网提供一层额外的安全。</li><li><strong>明确规则</strong>：明确地定义允许和拒绝的规则，以防止未授权的访问。</li></ul><h5 id="实践步骤-24"><a href="#实践步骤-24" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个子网创建NACL。</li><li>配置入站和出站规则，以控制流量。</li><li>定期检查和维护NACL规则，确保它们符合当前的安全策略。</li></ol><h4 id="管理路由表"><a href="#管理路由表" class="headerlink" title="管理路由表"></a>管理路由表</h4><p>路由表决定了网络包在VPC内以及VPC外的目的地。通过管理路由表，可以控制网络流量的方向。</p><h5 id="最佳实践原则-12"><a href="#最佳实践原则-12" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>明确路由</strong>：确保路由表中的路由清晰，且正确地反映了网络设计。</li><li><strong>安全路由</strong>：避免创建可能导致数据泄露的不安全路由。</li></ul><h5 id="实践步骤-25"><a href="#实践步骤-25" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为VPC和每个子网创建和配置路由表。</li><li>确保路由表中的条目正确地指向网络流量的预期目的地。</li><li>定期审查路由表，确保它们没有过时的或不必要的路由。</li></ol><h4 id="监控和审计网络流量"><a href="#监控和审计网络流量" class="headerlink" title="监控和审计网络流量"></a>监控和审计网络流量</h4><p>要确保网络安全，需要对网络流量进行持续的监控和审计。</p><h5 id="最佳实践原则-13"><a href="#最佳实践原则-13" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>持续监控</strong>：实时监控网络流量，以便快速发现异常。</li><li><strong>审计日志</strong>：保留审计日志，以便在需要时回溯和分析。</li></ul><h5 id="实践步骤-26"><a href="#实践步骤-26" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS CloudTrail和VPC流日志进行网络流量监控。</li><li>定期审查日志文件，寻找异常或不符合策略的流量模式。</li><li>利用AWS服务和第三方工具自动化异常检测和报警。</li></ol><h3 id="安全应用程序访问"><a href="#安全应用程序访问" class="headerlink" title="安全应用程序访问"></a>安全应用程序访问</h3><h4 id="安全应用程序访问-1"><a href="#安全应用程序访问-1" class="headerlink" title="安全应用程序访问"></a>安全应用程序访问</h4><p>在云环境中，安全地控制对应用程序的访问是至关重要的。这涉及到确保只有授权用户能够访问应用程序，并且应用程序的数据传输是安全的。以下是如何在AWS环境中实现安全应用程序访问的指导。</p><h4 id="实施身份和访问管理-IAM"><a href="#实施身份和访问管理-IAM" class="headerlink" title="实施身份和访问管理 (IAM)"></a>实施身份和访问管理 (IAM)</h4><p>AWS的身份和访问管理（IAM）允许你精确控制谁可以在AWS中做什么。它是保证应用程序访问安全的基础。</p><h5 id="最佳实践原则-14"><a href="#最佳实践原则-14" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>最小权限</strong>：确保用户和服务仅具有执行其任务所必需的权限。</li><li><strong>角色分离</strong>：为不同的任务和责任创建不同的角色。</li></ul><h5 id="实践步骤-27"><a href="#实践步骤-27" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个用户和应用程序创建IAM用户和角色。</li><li>为每个角色分配最小的权限集。</li><li>定期审计IAM策略和权限，确保它们仍然符合业务需求。</li></ol><h4 id="启用多因素认证-MFA"><a href="#启用多因素认证-MFA" class="headerlink" title="启用多因素认证 (MFA)"></a>启用多因素认证 (MFA)</h4><p>多因素认证（MFA）为AWS账户添加了一个额外的安全层，要求用户在登录时提供两个或更多的验证因素。</p><h5 id="最佳实践原则-15"><a href="#最佳实践原则-15" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>强制MFA</strong>：对所有用户，特别是具有高权限的用户，强制使用MFA。</li><li><strong>多样化认证方式</strong>：使用不同类型的认证因素，如密码、手机应用或硬件令牌。</li></ul><h5 id="实践步骤-28"><a href="#实践步骤-28" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在IAM设置中为用户启用MFA。</li><li>教育用户如何正确设置和使用MFA设备。</li><li>定期检查确保所有用户都启用了MFA。</li></ol><h4 id="配置网络安全"><a href="#配置网络安全" class="headerlink" title="配置网络安全"></a>配置网络安全</h4><p>网络安全设置是保护应用程序不受恶意访问的关键组成部分。</p><h5 id="最佳实践原则-16"><a href="#最佳实践原则-16" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全组和NACLs</strong>：正确配置安全组和NACLs来控制进出网络流量。</li><li><strong>私有链接</strong>：使用VPC私有链接确保内部应用程序之间的安全通信。</li></ul><h5 id="实践步骤-29"><a href="#实践步骤-29" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>根据需要创建和配置安全组和NACLs。</li><li>使用VPC Endpoints连接到AWS服务，避免流量经过公共互联网。</li><li>对于不应公开访问的内部应用程序，确保它们部署在私有子网中。</li></ol><h4 id="加密数据传输"><a href="#加密数据传输" class="headerlink" title="加密数据传输"></a>加密数据传输</h4><p>确保数据在传输过程中被加密，以防止数据在途中被截获或篡改。</p><h5 id="最佳实践原则-17"><a href="#最佳实践原则-17" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>强制TLS</strong>：对所有传入和传出的通信使用传输层安全性（TLS）加密。</li><li><strong>证书管理</strong>：使用AWS Certificate Manager或其他工具来管理和自动更新TLS证书。</li></ul><h5 id="实践步骤-30"><a href="#实践步骤-30" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>配置应用程序使用HTTPS进行所有通信。</li><li>使用AWS Certificate Manager为应用程序获取和管理SSL/TLS证书。</li><li>确保所有的API和服务端点都强制使用加密连接。</li></ol><h4 id="实施应用程序层防火墙"><a href="#实施应用程序层防火墙" class="headerlink" title="实施应用程序层防火墙"></a>实施应用程序层防火墙</h4><p>AWS Web Application Firewall (WAF) 可以帮助保护你的应用程序不受网络攻击。</p><h5 id="最佳实践原则-18"><a href="#最佳实践原则-18" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定制规则</strong>：根据应用程序的具体需求定制WAF规则。</li><li><strong>实时监控</strong>：监控应用程序的流量，并根据需要调整WAF规则。</li></ul><h5 id="实践步骤-31"><a href="#实践步骤-31" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序的入口点配置AWS WAF。</li><li>创建和实施包含SQL注入和跨站脚本保护的规则集。</li><li>定期审查和更新WAF规则，以应对新出现的威胁。</li></ol><h4 id="审计日志和持续监控"><a href="#审计日志和持续监控" class="headerlink" title="审计日志和持续监控"></a>审计日志和持续监控</h4><p>持续监控和记录审计日志是发现和响应安全事件的关键。</p><h5 id="最佳实践原则-19"><a href="#最佳实践原则-19" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>日志记录</strong>：启用AWS CloudTrail和其他日志服务来记录所有操作。</li><li><strong>监控系统</strong>：使用Amazon CloudWatch等工具实时监控系统性能和安全事件。</li></ul><h5 id="实践步骤-32"><a href="#实践步骤-32" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>配置CloudTrail来记录所有AWS API调用。</li><li>使用CloudWatch来监控和报警异常行为。</li><li>利用AWS Lambda等服务自动化响应策略。</li></ol><h3 id="AWS-外部的威胁向量（例如，DDoS、SQL-注入）"><a href="#AWS-外部的威胁向量（例如，DDoS、SQL-注入）" class="headerlink" title="AWS 外部的威胁向量（例如，DDoS、SQL 注入）"></a>AWS 外部的威胁向量（例如，DDoS、SQL 注入）</h3><h4 id="AWS-外部威胁向量介绍"><a href="#AWS-外部威胁向量介绍" class="headerlink" title="AWS 外部威胁向量介绍"></a>AWS 外部威胁向量介绍</h4><p>在AWS环境中，外部威胁向量指的是那些源自互联网的攻击和风险，它们可能会对运行在AWS上的服务和数据造成损害。理解这些威胁向量及其防御措施对于确保AWS资源的安全至关重要。</p><h4 id="防御分布式拒绝服务-DDoS-攻击"><a href="#防御分布式拒绝服务-DDoS-攻击" class="headerlink" title="防御分布式拒绝服务(DDoS)攻击"></a>防御分布式拒绝服务(DDoS)攻击</h4><p>分布式拒绝服务(DDoS)攻击是一种常见的网络攻击，旨在通过超载目标的网络或服务器资源来使其不可用。</p><h5 id="最佳实践原则-20"><a href="#最佳实践原则-20" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>缓解和吸收</strong>：使用AWS Shield等服务来缓解和吸收DDoS攻击。</li><li><strong>弹性架构</strong>：设计弹性架构以分散流量和减轻攻击影响。</li></ul><h5 id="实践步骤-33"><a href="#实践步骤-33" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS Shield Standard或AWS Shield Advanced来提供自动化的DDoS防护。</li><li>利用Amazon CloudFront和Amazon Route 53来分散流量和提高可用性。</li><li>实施自动缩放策略，以便在流量激增时增加资源。</li></ol><h4 id="防护SQL注入攻击"><a href="#防护SQL注入攻击" class="headerlink" title="防护SQL注入攻击"></a>防护SQL注入攻击</h4><p>SQL注入攻击是一种代码注入技术，攻击者试图通过在应用程序的输入中注入恶意SQL语句来操纵后端数据库。</p><h5 id="最佳实践原则-21"><a href="#最佳实践原则-21" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>输入验证</strong>：对所有用户输入进行严格的验证。</li><li><strong>使用参数化查询</strong>：避免直接在SQL语句中拼接用户输入。</li></ul><h5 id="实践步骤-34"><a href="#实践步骤-34" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用预编译的SQL语句或数据库存储过程来避免注入风险。</li><li>在应用程序层面实现输入验证和清理措施。</li><li>对数据库访问权限进行最小化，限制数据库用户的权限。</li></ol><h4 id="防御跨站脚本-XSS-攻击"><a href="#防御跨站脚本-XSS-攻击" class="headerlink" title="防御跨站脚本(XSS)攻击"></a>防御跨站脚本(XSS)攻击</h4><p>跨站脚本(XSS)攻击允许攻击者在用户浏览器中执行恶意脚本，通常是通过注入未经过滤的用户输入到网页中。</p><h5 id="最佳实践原则-22"><a href="#最佳实践原则-22" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>内容安全策略</strong>：实施内容安全策略(CSP)来限制可以执行的脚本。</li><li><strong>输出编码</strong>：对所有用户生成的输出进行编码。</li></ul><h5 id="实践步骤-35"><a href="#实践步骤-35" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>对所有用户输入进行过滤和转义，尤其是在输出到HTML页面时。</li><li>实施CSP，并将其设置为只允许信任的脚本来源。</li><li>使用Web应用程序防火墙(WAF)来识别和阻止XSS攻击。</li></ol><h4 id="防御钓鱼攻击"><a href="#防御钓鱼攻击" class="headerlink" title="防御钓鱼攻击"></a>防御钓鱼攻击</h4><p>钓鱼攻击通常通过伪装成可信实体来诱骗用户提供敏感信息，如用户名、密码和信用卡详情。</p><h5 id="最佳实践原则-23"><a href="#最佳实践原则-23" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>用户教育</strong>：教育用户识别钓鱼邮件和链接。</li><li><strong>安全协议</strong>：使用HTTPS和电子邮件安全协议如SPF、DKIM和DMARC。</li></ul><h5 id="实践步骤-36"><a href="#实践步骤-36" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为所有网站和在线服务启用SSL/TLS加密。</li><li>教育员工关于钓鱼攻击的识别和响应方法。</li><li>配置SPF、DKIM和DMARC来验证发出的电子邮件并减少钓鱼邮件。</li></ol><h4 id="防御恶意软件和病毒"><a href="#防御恶意软件和病毒" class="headerlink" title="防御恶意软件和病毒"></a>防御恶意软件和病毒</h4><p>恶意软件和病毒可以通过多种途径感染AWS资源，包括通过电子邮件附件、下载链接或通过感染的设备。</p><h5 id="最佳实践原则-24"><a href="#最佳实践原则-24" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期扫描</strong>：定期进行恶意软件和病毒扫描。</li><li><strong>访问控制</strong>：限制对敏感系统的访问，仅限必要的服务和用户。</li></ul><h5 id="实践步骤-37"><a href="#实践步骤-37" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Marketplace中的安全解决方案来扫描和监控AWS环境。</li><li>实施强大的端点保护策略，包括反病毒软件和入侵检测系统。</li><li>定期更新操作系统和应用程序，以修补已知的安全漏洞。</li></ol><h3 id="设计带安全组件的VPC架构"><a href="#设计带安全组件的VPC架构" class="headerlink" title="设计带安全组件的VPC架构"></a>设计带安全组件的VPC架构</h3><h4 id="安全组和网络ACL"><a href="#安全组和网络ACL" class="headerlink" title="安全组和网络ACL"></a>安全组和网络ACL</h4><ul><li><strong>安全组（SG）</strong>：作为虚拟防火墙，控制着对EC2实例的访问。为每个EC2实例配置合适的入站和出站规则，确保只允许必要的流量。</li><li><strong>网络访问控制列表（ACL）</strong>：作为VPC内各子网的附加安全层，用于控制进出子网的流量。配置网络ACL以允许或拒绝特定类型的流量。</li></ul><h4 id="路由表和NAT网关"><a href="#路由表和NAT网关" class="headerlink" title="路由表和NAT网关"></a>路由表和NAT网关</h4><ul><li><strong>路由表</strong>：确定网络流量如何从VPC的一个子网路由到另一个子网或外部网络。为每个子网分配合适的路由表。</li><li><strong>NAT网关</strong>：在私有子网中的实例需要访问互联网时使用NAT网关。它使私有子网中的实例能够发起向外部互联网的连接，同时阻止来自互联网的直接访问。</li></ul><h3 id="确定网络分段策略"><a href="#确定网络分段策略" class="headerlink" title="确定网络分段策略"></a>确定网络分段策略</h3><h4 id="公有子网和私有子网"><a href="#公有子网和私有子网" class="headerlink" title="公有子网和私有子网"></a>公有子网和私有子网</h4><ul><li><strong>公有子网</strong>：包含需要从互联网直接访问的资源（如Web服务器）。公有子网中的实例通常配置有公网IP地址。</li><li><strong>私有子网</strong>：用于不需要直接从互联网访问的资源（如数据库）。私有子网中的实例无法直接从互联网访问，提供了更高的安全性。</li></ul><h3 id="将AWS服务集成到安全应用程序"><a href="#将AWS服务集成到安全应用程序" class="headerlink" title="将AWS服务集成到安全应用程序"></a>将AWS服务集成到安全应用程序</h3><h4 id="AWS-Shield、AWS-WAF和IAM-Identity-Center"><a href="#AWS-Shield、AWS-WAF和IAM-Identity-Center" class="headerlink" title="AWS Shield、AWS WAF和IAM Identity Center"></a>AWS Shield、AWS WAF和IAM Identity Center</h4><ul><li><strong>AWS Shield</strong>：提供DDoS保护，保护AWS资源（如EC2、Elastic Load Balancing等）免受DDoS攻击。</li><li><strong>AWS WAF（Web Application Firewall）</strong>：保护应用程序免受Web攻击，可以创建自定义的Web安全规则。</li><li><strong>IAM Identity Center（原AWS SSO）</strong>：提供单点登录（SSO），管理对AWS账户和应用程序的访问。</li></ul><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li><strong>AWS Secrets Manager</strong>：保护访问密钥和其他敏感信息，可以轻松地在应用中管理和检索机密。</li></ul><h3 id="保护与AWS云的外部网络连接"><a href="#保护与AWS云的外部网络连接" class="headerlink" title="保护与AWS云的外部网络连接"></a>保护与AWS云的外部网络连接</h3><h4 id="VPN和AWS-Direct-Connect"><a href="#VPN和AWS-Direct-Connect" class="headerlink" title="VPN和AWS Direct Connect"></a>VPN和AWS Direct Connect</h4><ul><li><strong>VPN（虚拟私人网络）</strong>：安全地将本地网络连接到AWS VPC。利用IPSec VPN连接，可以建立加密的通道，保护数据传输。</li><li><strong>AWS Direct Connect</strong>：通过私有网络连接来访问AWS服务，提供更可靠、更高带宽的连接选项，同时降低网络成本。</li></ul><p>以上是构建安全AWS VPC架构的关键组件和策略。通过结合使用这些服务和配置，可以创建一个既安全又高效的网络环境。</p><h3 id="数据访问和监管"><a href="#数据访问和监管" class="headerlink" title="数据访问和监管"></a>数据访问和监管</h3><h4 id="数据访问和监管概述"><a href="#数据访问和监管概述" class="headerlink" title="数据访问和监管概述"></a>数据访问和监管概述</h4><p>在AWS云环境中，数据访问和监管涉及确保数据的安全性和合规性，以及控制和监视数据的访问。这包括实施策略和技术措施来保护数据，确保只有授权用户才能访问敏感信息，并遵守相关的法律和行业标准。</p><h4 id="实施数据访问控制"><a href="#实施数据访问控制" class="headerlink" title="实施数据访问控制"></a>实施数据访问控制</h4><p>数据访问控制是确保数据安全性的关键部分，它涉及到限制对数据的访问和操作。</p><h5 id="最佳实践原则-25"><a href="#最佳实践原则-25" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>基于角色的访问控制</strong> (RBAC): 为不同的用户分配基于角色的权限。</li><li><strong>最小权限原则</strong>: 限制用户只能访问他们执行职责所必需的数据。</li></ul><h5 id="实践步骤-38"><a href="#实践步骤-38" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义数据访问角色，并为每个角色分配适当的权限。</li><li>使用AWS IAM来创建和管理用户、组、角色和权限策略。</li><li>定期审查和调整IAM策略，确保它们符合最小权限原则。</li></ol><h4 id="监管数据访问"><a href="#监管数据访问" class="headerlink" title="监管数据访问"></a>监管数据访问</h4><p>监管数据访问是指监控和记录对数据的所有访问尝试，无论是成功还是失败的。</p><h5 id="最佳实践原则-26"><a href="#最佳实践原则-26" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>全面的审计日志</strong>: 记录所有数据访问尝试的详细日志。</li><li><strong>实时监控</strong>: 使用工具实时监控数据访问模式和潜在的异常活动。</li></ul><h5 id="实践步骤-39"><a href="#实践步骤-39" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>启用AWS CloudTrail来记录和监控API调用。</li><li>配置Amazon S3存储桶访问日志记录所有请求。</li><li>利用Amazon CloudWatch或AWS Config来创建自定义监控和警报。</li></ol><h4 id="数据保护和加密"><a href="#数据保护和加密" class="headerlink" title="数据保护和加密"></a>数据保护和加密</h4><p>保护数据的完整性和保密性需要在传输和静态时对数据进行加密。</p><h5 id="最佳实践原则-27"><a href="#最佳实践原则-27" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>传输中加密</strong>: 使用SSL/TLS等协议在传输过程中加密数据。</li><li><strong>静态数据加密</strong>: 存储数据时使用服务器端加密。</li></ul><h5 id="实践步骤-40"><a href="#实践步骤-40" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>对所有传输中的数据使用HTTPS和其他安全协议。</li><li>在Amazon S3等服务中启用服务器端加密（如SSE-S3、SSE-KMS）。</li><li>管理加密密钥，使用AWS Key Management Service (KMS)来创建和控制加密密钥。</li></ol><h4 id="遵守合规性要求"><a href="#遵守合规性要求" class="headerlink" title="遵守合规性要求"></a>遵守合规性要求</h4><p>合规性要求可能来自行业标准、法律法规或公司政策，需要确保数据访问和处理符合这些要求。</p><h5 id="最佳实践原则-28"><a href="#最佳实践原则-28" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>了解合规性框架</strong>: 熟悉适用于组织的合规性框架，如GDPR、HIPAA。</li><li><strong>实施合规性控制</strong>: 根据合规性要求实施相应的控制措施。</li></ul><h5 id="实践步骤-41"><a href="#实践步骤-41" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>评估适用的合规性要求，并将其整合到数据访问策略中。</li><li>利用AWS的合规性报告和认证，如AWS Artifact提供的文档。</li><li>实施定期的合规性审计和自我评估，确保持续合规。</li></ol><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="数据恢复概述"><a href="#数据恢复概述" class="headerlink" title="数据恢复概述"></a>数据恢复概述</h4><p>数据恢复是指在数据丢失或损坏后恢复数据的过程。在AWS云中，数据恢复策略是确保业务连续性和灾难恢复计划的重要组成部分。这包括备份数据、确保备份的完整性以及在必要时迅速有效地恢复数据。</p><h4 id="设计数据备份策略"><a href="#设计数据备份策略" class="headerlink" title="设计数据备份策略"></a>设计数据备份策略</h4><p>有效的数据备份策略是数据恢复计划的核心。它应该包括定期备份的计划和确保备份数据的安全性和可用性。</p><h5 id="最佳实践原则-29"><a href="#最佳实践原则-29" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期自动备份</strong>：自动定期备份数据以减少人为错误和遗漏。</li><li><strong>多地域冗余存储</strong>：在多个地理位置存储备份，以防止单点故障。</li></ul><h5 id="实践步骤-42"><a href="#实践步骤-42" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用AWS Backup服务来集中管理和自动化备份任务。</li><li>利用Amazon S3的跨区域复制功能来存储备份数据的副本。</li><li>确保备份数据的加密，以保护数据在传输和存储中的安全。</li></ol><h4 id="测试和验证备份"><a href="#测试和验证备份" class="headerlink" title="测试和验证备份"></a>测试和验证备份</h4><p>备份数据的存在并不足以确保数据恢复的成功。定期测试和验证备份是必要的步骤。</p><h5 id="最佳实践原则-30"><a href="#最佳实践原则-30" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期恢复测试</strong>：定期进行恢复测试以验证备份数据的完整性。</li><li><strong>监控备份活动</strong>：监控备份过程，确保没有失败或遗漏。</li></ul><h5 id="实践步骤-43"><a href="#实践步骤-43" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定期执行恢复测试，以验证备份的完整性和可用性。</li><li>使用AWS CloudTrail和Amazon CloudWatch来监控备份和恢复活动。</li><li>记录和分析测试结果，确保符合恢复时间目标(RTO)和恢复点目标(RPO)。</li></ol><h4 id="实施灾难恢复计划"><a href="#实施灾难恢复计划" class="headerlink" title="实施灾难恢复计划"></a>实施灾难恢复计划</h4><p>灾难恢复(DR)计划是确保在发生灾难时能够快速恢复操作的详细指南。</p><h5 id="最佳实践原则-31"><a href="#最佳实践原则-31" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>多层次备份策略</strong>：实施多层次的备份策略，包括快照、复制和归档。</li><li><strong>自动化恢复流程</strong>：自动化恢复流程以减少恢复时间。</li></ul><h5 id="实践步骤-44"><a href="#实践步骤-44" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义业务影响分析(BIA)并建立恢复优先级。</li><li>设计并实施灾难恢复方案，如AWS的Pilot Light、Warm Standby或Multi-Site方案。</li><li>编写和维护详细的灾难恢复文档，并定期进行演练。</li></ol><h3 id="数据留存和分类"><a href="#数据留存和分类" class="headerlink" title="数据留存和分类"></a>数据留存和分类</h3><h4 id="数据留存和分类概述"><a href="#数据留存和分类概述" class="headerlink" title="数据留存和分类概述"></a>数据留存和分类概述</h4><p>数据留存和分类是数据管理策略的关键组成部分，涉及保留数据的时间长度以及如何组织数据以便于访问和合规性。在AWS云中，这意味着使用合适的服务和工具来存储、分类和管理数据的生命周期。</p><h4 id="确定数据留存策略"><a href="#确定数据留存策略" class="headerlink" title="确定数据留存策略"></a>确定数据留存策略</h4><p>数据留存策略决定了数据应该保留多久，以及何时应该删除或归档数据。</p><h5 id="最佳实践原则-32"><a href="#最佳实践原则-32" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>合规性和业务需求</strong>：根据法律法规和业务需求确定数据留存期限。</li><li><strong>成本效益分析</strong>：考虑数据留存的成本和价值，进行成本效益分析。</li></ul><h5 id="实践步骤-45"><a href="#实践步骤-45" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>审查法律法规和业务政策，确定数据留存的最小和最大期限。</li><li>使用AWS的数据生命周期管理策略来自动删除过期的数据。</li><li>配置Amazon S3生命周期策略，自动将数据转移到更低成本的存储类别或归档服务。</li></ol><h4 id="实施数据分类"><a href="#实施数据分类" class="headerlink" title="实施数据分类"></a>实施数据分类</h4><p>数据分类是对数据进行标记和分组的过程，以便于管理和检索。</p><h5 id="最佳实践原则-33"><a href="#最佳实践原则-33" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>数据敏感性和重要性</strong>：根据数据的敏感性和业务重要性进行分类。</li><li><strong>一致的标签系统</strong>：使用一致的标签系统来简化数据分类和检索。</li></ul><h5 id="实践步骤-46"><a href="#实践步骤-46" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为数据定义分类标准，如公开、机密、高度机密等。</li><li>使用AWS资源标签来分类和管理数据和其他AWS资源。</li><li>利用Amazon Macie等服务自动发现和分类敏感数据。</li></ol><h4 id="管理数据留存和分类"><a href="#管理数据留存和分类" class="headerlink" title="管理数据留存和分类"></a>管理数据留存和分类</h4><p>有效的数据留存和分类管理不仅要设置策略，还需要持续监控和调整这些策略。</p><h5 id="最佳实践原则-34"><a href="#最佳实践原则-34" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期审查</strong>：定期审查数据留存和分类策略，确保它们仍然适用。</li><li><strong>自动化流程</strong>：尽可能自动化数据留存和分类的流程。</li></ul><h5 id="实践步骤-47"><a href="#实践步骤-47" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定期进行内部或外部审计，以确保遵守数据留存政策。</li><li>利用AWS的自动化工具，如AWS Lambda，来自动执行数据分类和留存策略的更新。</li><li>教育员工关于数据留存和分类的最佳实践，确保组织内部的一致性。</li></ol><h4 id="数据留存和分类的监控与报告"><a href="#数据留存和分类的监控与报告" class="headerlink" title="数据留存和分类的监控与报告"></a>数据留存和分类的监控与报告</h4><p>监控和报告是确保数据留存和分类策略有效执行的重要组成部分。</p><h5 id="最佳实践原则-35"><a href="#最佳实践原则-35" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>透明度</strong>：确保数据留存和分类的过程具有高度透明度。</li><li><strong>可审计性</strong>：保持记录，确保数据留存和分类的过程可审计。</li></ul><h5 id="实践步骤-48"><a href="#实践步骤-48" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用Amazon CloudWatch来监控数据留存和分类相关的指标和警报。</li><li>利用AWS CloudTrail来记录和审计数据相关的操作。</li><li>生成定期报告，以向管理层展示数据留存和分类的状态和活动。</li></ol><p>要调整AWS技术以满足合规性要求并实现数据的安全保护，可以遵循以下步骤：</p><h3 id="对数据进行静态加密"><a href="#对数据进行静态加密" class="headerlink" title="对数据进行静态加密"></a>对数据进行静态加密</h3><ol><li><strong>使用AWS Key Management Service (AWS KMS)</strong>: AWS KMS允许您创建和管理加密密钥，并通过使用硬件安全模块控制它们的使用。这些密钥可以用来加密存储在AWS服务中的数据。</li><li><strong>创建密钥</strong>: 在AWS KMS中创建一个新的客户主键（CMK）。可以选择密钥用途和自动轮换设置。</li><li><strong>加密数据</strong>: 使用创建的CMK对需要静态加密的数据进行加密。这可以通过集成的AWS服务（如S3、EBS等）或直接通过KMS API实现。</li></ol><h3 id="对数据进行传输中加密"><a href="#对数据进行传输中加密" class="headerlink" title="对数据进行传输中加密"></a>对数据进行传输中加密</h3><ol><li><strong>使用AWS Certificate Manager (ACM)</strong>: ACM允许您轻松地部署、管理和自动续订SSL/TLS证书。</li><li><strong>创建和部署证书</strong>: 在ACM中创建一个SSL/TLS证书，并将其部署到支持HTTPS的AWS服务（如ELB、CloudFront）。</li><li><strong>配置TLS加密</strong>: 确保所有的数据传输都通过TLS加密通道进行，以保证数据在传输过程中的安全。</li></ol><h3 id="对加密密钥实施访问策略"><a href="#对加密密钥实施访问策略" class="headerlink" title="对加密密钥实施访问策略"></a>对加密密钥实施访问策略</h3><ol><li><strong>创建IAM策略</strong>: 为需要访问加密密钥的IAM角色或用户创建策略，明确指定哪些操作是允许的。</li><li><strong>绑定策略到用户或角色</strong>: 将策略应用于适当的IAM用户或角色，以控制对KMS密钥的访问。</li></ol><h3 id="实施数据备份和复制"><a href="#实施数据备份和复制" class="headerlink" title="实施数据备份和复制"></a>实施数据备份和复制</h3><ol><li><strong>自动备份</strong>: 利用AWS服务（如RDS、EBS的快照功能）进行定期数据备份。</li><li><strong>跨区域复制</strong>: 对于关键数据，使用跨区域复制功能以增加数据的耐久性和可用性。</li></ol><h3 id="实施数据访问、生命周期和保护策略"><a href="#实施数据访问、生命周期和保护策略" class="headerlink" title="实施数据访问、生命周期和保护策略"></a>实施数据访问、生命周期和保护策略</h3><ol><li><strong>数据访问控制</strong>: 使用IAM和资源级别的策略控制对数据的访问权限。</li><li><strong>数据生命周期管理</strong>: 利用S3的生命周期管理策略自动转移或删除旧数据。</li><li><strong>数据保护</strong>: 使用AWS Shield等工具保护数据免受DDoS攻击等安全威胁。</li></ol><h3 id="轮换加密密钥和续订证书"><a href="#轮换加密密钥和续订证书" class="headerlink" title="轮换加密密钥和续订证书"></a>轮换加密密钥和续订证书</h3><ol><li><strong>定期轮换加密密钥</strong>: 在KMS中设置密钥轮换，自动或手动更新加密密钥。</li><li><strong>监控和续订证书</strong>: 利用ACM的自动续订功能，确保SSL/TLS证书始终有效。</li></ol><h2 id="设计弹性架构"><a href="#设计弹性架构" class="headerlink" title="设计弹性架构"></a>设计弹性架构</h2><h3 id="API-创建和管理（例如，Amazon-API-Gateway、REST-API）"><a href="#API-创建和管理（例如，Amazon-API-Gateway、REST-API）" class="headerlink" title="API 创建和管理（例如，Amazon API Gateway、REST API）"></a>API 创建和管理（例如，Amazon API Gateway、REST API）</h3><h4 id="API-创建和管理概述"><a href="#API-创建和管理概述" class="headerlink" title="API 创建和管理概述"></a>API 创建和管理概述</h4><p>API（应用程序编程接口）是软件间交互的一套规则和定义，允许不同的系统和应用程序之间进行通信。Amazon API Gateway 是一个完全托管的服务，它使开发者能够轻松地创建、发布、维护、监控和保护任何规模的API。</p><h4 id="设计-REST-API"><a href="#设计-REST-API" class="headerlink" title="设计 REST API"></a>设计 REST API</h4><p>在使用Amazon API Gateway创建REST API之前，需要设计API的架构，包括资源、方法和状态码。</p><h5 id="最佳实践原则-36"><a href="#最佳实践原则-36" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>使用RESTful原则</strong>：设计符合REST架构风格的API，这意味着使用HTTP方法和状态码，资源的表述等。</li><li><strong>版本控制</strong>：通过API路径或头部信息实现API版本控制。</li></ul><h5 id="实践步骤-49"><a href="#实践步骤-49" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义API的资源（如用户、产品等）和子资源。</li><li>为每个资源定义CRUD（创建、读取、更新和删除）操作对应的HTTP方法（如GET、POST、PUT、DELETE）。</li><li>设计API的请求和响应模型，包括状态码和错误消息。</li></ol><h4 id="创建-API-与部署"><a href="#创建-API-与部署" class="headerlink" title="创建 API 与部署"></a>创建 API 与部署</h4><p>使用Amazon API Gateway创建API涉及到设置资源、方法、方法请求和响应等。</p><h5 id="最佳实践原则-37"><a href="#最佳实践原则-37" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：确保API的每个部分都采用适当的安全措施，如API密钥、身份验证和授权。</li><li><strong>性能优化</strong>：使用缓存和节流等技术来优化API性能。</li></ul><h5 id="实践步骤-50"><a href="#实践步骤-50" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在Amazon API Gateway中创建一个新的API。</li><li>设置API的资源和方法，并配置请求和响应的模型。</li><li>配置API的授权和认证机制。</li><li>部署API到一个或多个阶段（如开发、测试、生产）。</li></ol><h4 id="管理-API-生命周期"><a href="#管理-API-生命周期" class="headerlink" title="管理 API 生命周期"></a>管理 API 生命周期</h4><p>API的管理包括监控、维护、版本更新和退役。</p><h5 id="最佳实践原则-38"><a href="#最佳实践原则-38" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>监控和日志记录</strong>：监控API的使用情况和性能，记录日志以便于故障排查。</li><li><strong>持续迭代</strong>：定期更新API以添加新功能或改进现有功能。</li></ul><h5 id="实践步骤-51"><a href="#实践步骤-51" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用Amazon CloudWatch监控API的调用次数、错误率和延迟。</li><li>利用AWS CloudTrail记录API的管理事件。</li><li>为API发布新版本和更新，同时保持旧版本的稳定性。</li><li>当API退役时，通知消费者，并提供迁移路径。</li></ol><h4 id="确保-API-安全"><a href="#确保-API-安全" class="headerlink" title="确保 API 安全"></a>确保 API 安全</h4><p>保护API以防止未授权访问和攻击是至关重要的。</p><h5 id="最佳实践原则-39"><a href="#最佳实践原则-39" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>使用HTTPS</strong>：确保所有API调用都通过HTTPS进行，以保证数据传输的安全性。</li><li><strong>访问控制</strong>：使用IAM角色和策略控制对API的访问。</li></ul><h5 id="实践步骤-52"><a href="#实践步骤-52" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>强制执行SSL/TLS，确保API仅通过HTTPS提供服务。</li><li>配置API Gateway资源策略，限制IP地址或IAM用户的访问。</li><li>使用API Gateway的API密钥和使用计划来控制和限制客户端的API请求。</li><li>实施AWS WAF（Web应用程序防火墙）以防止常见的网络攻击。</li></ol><h4 id="监控和优化-API-性能"><a href="#监控和优化-API-性能" class="headerlink" title="监控和优化 API 性能"></a>监控和优化 API 性能</h4><p>API性能的监控和优化是确保API可靠和高效的关键。</p><h5 id="最佳实践原则-40"><a href="#最佳实践原则-40" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>性能指标</strong>：关注API的延迟和错误率等关键性能指标。</li><li><strong>缓存策略</strong>：合理设置API缓存以提高响应速度和减轻后端负载。</li></ul><h5 id="实践步骤-53"><a href="#实践步骤-53" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设置Amazon CloudWatch警报，当API的性能指标超出预定阈值时接收通知。</li><li>使用API Gateway缓存减少后端服务的调用次数。</li><li>分析API使用模式，并据此调整请求节流限制。</li></ol><h3 id="具有合适使用案例的-AWS-Managed-Services（例如，AWS-Transfer-Family、Amazon-Simple-Queue-Service-Amazon-SQS-、Secrets-Manager）"><a href="#具有合适使用案例的-AWS-Managed-Services（例如，AWS-Transfer-Family、Amazon-Simple-Queue-Service-Amazon-SQS-、Secrets-Manager）" class="headerlink" title="具有合适使用案例的 AWS Managed Services（例如，AWS Transfer Family、Amazon Simple Queue Service [Amazon SQS]、Secrets Manager）"></a>具有合适使用案例的 AWS Managed Services（例如，AWS Transfer Family、Amazon Simple Queue Service [Amazon SQS]、Secrets Manager）</h3><h4 id="AWS-Transfer-Family-使用案例"><a href="#AWS-Transfer-Family-使用案例" class="headerlink" title="AWS Transfer Family 使用案例"></a>AWS Transfer Family 使用案例</h4><p>AWS Transfer Family 提供安全的文件传输服务，使您能够轻松地在AWS上接收、存储和共享数据。</p><h5 id="最佳实践原则-41"><a href="#最佳实践原则-41" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>安全性</strong>：确保传输过程中使用加密协议，如SFTP、FTPS和FTP。</li><li><strong>集成</strong>：与AWS服务（如Amazon S3和Amazon EFS）集成以存储和处理数据。</li></ul><h5 id="实践步骤-54"><a href="#实践步骤-54" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建一个AWS Transfer Family服务器，并指定服务类型（SFTP、FTPS、或FTP）。</li><li>配置用户，并将它们与IAM角色关联，以便控制对S3桶的访问。</li><li>设置网络访问，通过VPC或互联网进行传输。</li></ol><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>文件共享</strong>：企业可以使用AWS Transfer Family 安全地与合作伙伴共享文件。</li><li><strong>数据迁移</strong>：将本地数据迁移到AWS，作为云存储的一部分。</li><li><strong>内容分发</strong>：媒体公司可以将大型媒体文件上传到云端，供全球分发。</li></ul><h4 id="Amazon-Simple-Queue-Service-Amazon-SQS-使用案例"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS-使用案例" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS) 使用案例"></a>Amazon Simple Queue Service (Amazon SQS) 使用案例</h4><p>Amazon SQS 是一种完全托管的消息队列服务，它可以帮助您在软件组件之间解耦和扩展应用程序。</p><h5 id="最佳实践原则-42"><a href="#最佳实践原则-42" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>解耦组件</strong>：使用消息队列来解耦生产者和消费者进程。</li><li><strong>扩展性</strong>：根据工作负载动态调整消费者的数量。</li></ul><h5 id="实践步骤-55"><a href="#实践步骤-55" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>创建一个新的SQS队列。</li><li>配置消息保留策略和传递延迟设置。</li><li>在生产者应用程序中发送消息到队列。</li><li>在消费者应用程序中从队列接收和处理消息。</li></ol><h5 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>异步处理</strong>：应用程序可以将任务发送到SQS队列进行异步处理。</li><li><strong>应用程序扩展</strong>：在用户请求量增加时，通过增加消费者实例数量来处理更多的消息。</li><li><strong>容错性</strong>：在处理消息失败时，SQS可以重新尝试或将消息移动到死信队列。</li></ul><h4 id="AWS-Secrets-Manager-使用案例"><a href="#AWS-Secrets-Manager-使用案例" class="headerlink" title="AWS Secrets Manager 使用案例"></a>AWS Secrets Manager 使用案例</h4><p>AWS Secrets Manager 是一项服务，用于保护访问应用程序的敏感信息，如数据库密码、API密钥和其他秘密。</p><h5 id="最佳实践原则-43"><a href="#最佳实践原则-43" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定期轮换秘密</strong>：自动更换秘密以提高安全性。</li><li><strong>集中管理</strong>：集中存储和访问所有秘密。</li></ul><h5 id="实践步骤-56"><a href="#实践步骤-56" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在AWS Secrets Manager中存储新的秘密。</li><li>配置秘密的自动轮换策略。</li><li>通过IAM策略控制对秘密的访问权限。</li><li>在应用程序中使用SDK或CLI获取秘密，而不是硬编码。</li></ol><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><ul><li><strong>数据库凭证管理</strong>：存储和管理数据库登录信息，自动处理密码更换。</li><li><strong>API密钥安全</strong>：安全地存储第三方服务的API密钥，并在需要时轻松访问。</li><li><strong>应用配置</strong>：存储应用程序配置详情，如端口、域和更多环境特定的秘密。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>AWS Managed Services 提供了一系列工具，以帮助组织在AWS云环境中高效、安全地操作。AWS Transfer Family 适用于需要安全文件传输的场景，Amazon SQS 适合于需要消息队列来实现应用程序解耦和扩展的情况，而AWS Secrets Manager 非常适合需要安全管理敏感信息的应用程序。通过这些服务，AWS用户可以提高应用程序的安全性、可靠性和扩展性，同时简化运维工作。</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="缓存策略基础"><a href="#缓存策略基础" class="headerlink" title="缓存策略基础"></a>缓存策略基础</h4><p>缓存策略是优化数据检索性能的关键组成部分。它涉及存储数据的临时副本，以便快速访问，减少对原始数据源的请求次数，从而提高应用程序的响应速度和减少延迟。</p><h5 id="最佳实践原则-44"><a href="#最佳实践原则-44" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li>**有效期 (TTL)**：为缓存的数据设置合适的生命周期。</li><li><strong>一致性</strong>：确保缓存数据的一致性，以防止过期或不正确的信息被提供。</li><li><strong>无效化</strong>：当原始数据更改时，及时无效化缓存。</li></ul><h5 id="实践步骤-57"><a href="#实践步骤-57" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>选择合适的缓存策略（如LRU、FIFO等）。</li><li>配置缓存存储，可以是内存中的、本地的或分布式的。</li><li>实施缓存失效逻辑，确保数据的一致性。</li></ol><h4 id="应用层缓存策略"><a href="#应用层缓存策略" class="headerlink" title="应用层缓存策略"></a>应用层缓存策略</h4><p>应用层缓存通常指在应用程序代码中实现的缓存，例如使用内存中的数据结构来存储计算结果或频繁访问的数据。</p><h5 id="最佳实践原则-45"><a href="#最佳实践原则-45" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>选择性缓存</strong>：仅缓存那些读取操作频繁且相对不经常更新的数据。</li><li><strong>内存管理</strong>：监控缓存占用的内存，并确保它不会导致应用程序崩溃。</li></ul><h5 id="实践步骤-58"><a href="#实践步骤-58" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在应用程序代码中标识高延迟或高计算成本的操作。</li><li>使用合适的数据结构（如哈希表）来存储这些操作的结果。</li><li>在数据更新时，更新缓存或标记为无效。</li></ol><h4 id="数据库缓存策略"><a href="#数据库缓存策略" class="headerlink" title="数据库缓存策略"></a>数据库缓存策略</h4><p>数据库缓存涉及在数据库系统中缓存查询结果，以减少对数据库引擎的查询次数。</p><h5 id="最佳实践原则-46"><a href="#最佳实践原则-46" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>查询优化</strong>：缓存那些执行成本高昂的查询结果。</li><li><strong>自动化</strong>：利用数据库管理系统提供的自动缓存机制。</li></ul><h5 id="实践步骤-59"><a href="#实践步骤-59" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>使用数据库查询分析器找出成本高昂的查询。</li><li>配置数据库级别的缓存设置，如MySQL的Query Cache或SQL Server的In-Memory OLTP。</li><li>监控缓存的效率并根据需要调整配置。</li></ol><h4 id="CDN-缓存策略"><a href="#CDN-缓存策略" class="headerlink" title="CDN 缓存策略"></a>CDN 缓存策略</h4><p>内容分发网络（CDN）缓存是一种分布式网络缓存，它存储静态资源，如图片、视频、CSS和JavaScript文件，以便于快速交付给全球用户。</p><h5 id="最佳实践原则-47"><a href="#最佳实践原则-47" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>地理分布</strong>：缓存内容应靠近用户，以减少延迟。</li><li><strong>版本控制</strong>：使用文件版本命名来管理缓存的更新。</li></ul><h5 id="实践步骤-60"><a href="#实践步骤-60" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>选择CDN提供商，并配置CDN缓存规则。</li><li>为静态资源实现版本控制，例如通过添加查询字符串或文件指纹。</li><li>设置缓存的TTL，确保内容的及时更新。</li></ol><h4 id="HTTP-缓存策略"><a href="#HTTP-缓存策略" class="headerlink" title="HTTP 缓存策略"></a>HTTP 缓存策略</h4><p>HTTP缓存策略涉及客户端（如浏览器）和服务器之间的缓存控制，通常通过HTTP头部来控制。</p><h5 id="最佳实践原则-48"><a href="#最佳实践原则-48" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>缓存控制头部</strong>：使用<code>Cache-Control</code>头部指令来控制资源的缓存行为。</li><li><strong>协商缓存</strong>：当可能时，使用<code>ETag</code>和<code>Last-Modified</code>头部进行缓存验证。</li></ul><h5 id="实践步骤-61"><a href="#实践步骤-61" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>在服务器响应中设置<code>Cache-Control</code>头部，如<code>max-age</code>和<code>must-revalidate</code>。</li><li>使用<code>ETag</code>头部提供资源的特定版本标记。</li><li>通过<code>Last-Modified</code>头部提供资源最后修改的时间戳。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存策略是提高应用程序性能和用户体验的重要组成部分。无论是应用层缓存、数据库缓存、CDN缓存还是HTTP缓存，合理的缓存策略都可以显著减少数据检索时间，减轻后端服务的压力，并提供更快的响应速度。实施缓存时，重要的是要考虑数据的一致性、有效期和无效化策略，以确保用户始终访问到最新和最准确的信息。</p><h3 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h3><h4 id="微服务架构概述"><a href="#微服务架构概述" class="headerlink" title="微服务架构概述"></a>微服务架构概述</h4><p>微服务架构是一种设计方法，它通过将一个大型应用程序拆分成一组小型、松散耦合的服务来促进敏捷开发和部署。每个服务通常围绕特定业务功能构建，并且可以独立于其他服务进行开发、部署和扩展。</p><h5 id="最佳实践原则-49"><a href="#最佳实践原则-49" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>服务自治</strong>：每个服务应该是自包含的，并拥有特定的业务逻辑。</li><li><strong>松耦合</strong>：服务之间的依赖关系应该最小化。</li><li><strong>可维护性和可测试性</strong>：服务应该容易维护和测试。</li></ul><h5 id="实践步骤-62"><a href="#实践步骤-62" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>确定业务域，并围绕这些域设计服务。</li><li>设计服务API，并确保它们清晰和一致。</li><li>实现服务的持续集成和部署（CI/CD）。</li></ol><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责原则指的是微服务应该围绕一个核心功能构建，并且只做好一件事情。这有助于确保服务的复杂性保持在可管理的水平。</p><h5 id="最佳实践原则-50"><a href="#最佳实践原则-50" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>聚焦业务能力</strong>：服务应该围绕单一的业务能力构建。</li><li><strong>避免臃肿服务</strong>：避免创建大型服务，这些服务难以维护和扩展。</li></ul><h5 id="实践步骤-63"><a href="#实践步骤-63" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>明确界定服务的业务边界。</li><li>避免在单个服务中实现多个业务功能。</li><li>定期评估服务的职责，确保它们没有变得过于复杂。</li></ol><h4 id="服务自治和独立性"><a href="#服务自治和独立性" class="headerlink" title="服务自治和独立性"></a>服务自治和独立性</h4><p>服务自治是微服务设计的核心原则之一。每个服务都应该是自主的，能够独立于其他服务运行和演进。</p><h5 id="最佳实践原则-51"><a href="#最佳实践原则-51" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>独立部署</strong>：服务应该能够独立于其他服务进行部署。</li><li><strong>自主数据管理</strong>：服务应该拥有并管理自己的数据模型和数据库。</li></ul><h5 id="实践步骤-64"><a href="#实践步骤-64" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>为每个服务实现独立的部署流程。</li><li>确保服务有自己的数据库或数据存储，不与其他服务共享。</li><li>使用服务发现机制，使服务能够独立地找到并与其他服务通信。</li></ol><h4 id="服务的松耦合和内聚"><a href="#服务的松耦合和内聚" class="headerlink" title="服务的松耦合和内聚"></a>服务的松耦合和内聚</h4><p>微服务应该是松耦合的，这意味着它们之间的依赖关系应该尽可能地少。同时，服务内部应该是高度内聚的，意味着服务内部的组件紧密相关且为同一目标工作。</p><h5 id="最佳实践原则-52"><a href="#最佳实践原则-52" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>定义良好的接口</strong>：服务之间的交互应该通过定义良好的API进行。</li><li><strong>事件驱动通信</strong>：使用事件来减少服务间的直接依赖。</li></ul><h5 id="实践步骤-65"><a href="#实践步骤-65" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>设计清晰的API和服务契约。</li><li>使用异步消息传递和事件来促进服务间的通信。</li><li>限制直接的服务到服务调用，以减少耦合。</li></ol><h4 id="可维护性和可测试性"><a href="#可维护性和可测试性" class="headerlink" title="可维护性和可测试性"></a>可维护性和可测试性</h4><p>微服务应该容易维护和测试，这有助于快速迭代和提高系统的稳定性。</p><h5 id="最佳实践原则-53"><a href="#最佳实践原则-53" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>模块化设计</strong>：服务应该是模块化的，以便于理解和更改。</li><li><strong>自动化测试</strong>：服务应该有一套完善的自动化测试套件。</li></ul><h5 id="实践步骤-66"><a href="#实践步骤-66" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>构建模块化的服务，使其能够容易地添加或修改功能。</li><li>开发单元测试、集成测试和端到端测试。</li><li>实施持续集成和持续部署流程。</li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>微服务设计原则旨在支持构建可维护、可扩展和可持续的服务。通过遵循单一职责原则、确保服务自治和独立性、实现服务的松耦合和内聚、以及强调可维护性和可测试性，团队可以创建出强大而灵活的微服务架构。这些原则有助于微服务在快速变化的市场中保持竞争力，同时降低长期的技术债务风险。</p><h3 id="事件驱动型架构"><a href="#事件驱动型架构" class="headerlink" title="事件驱动型架构"></a>事件驱动型架构</h3><p>事件驱动型架构是一种软件架构范式，它通过事件来触发和通信各个服务或应用程序组件之间的交互。在这种架构中，事件是一个重要的状态改变，它可以由系统内部或外部的动作产生，并且被系统内的其他组件所监听和响应。</p><h5 id="最佳实践原则-54"><a href="#最佳实践原则-54" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h5><ul><li><strong>解耦生产者和消费者</strong>：生产者产生事件而不需要知道哪些消费者会处理这些事件。</li><li><strong>异步通信</strong>：系统组件应该异步地处理事件，以提高性能和响应性。</li><li><strong>可伸缩性</strong>：事件驱动架构应该能够水平扩展，以处理大量的事件流。</li></ul><h5 id="实践步骤-67"><a href="#实践步骤-67" class="headerlink" title="实践步骤"></a>实践步骤</h5><ol><li>定义明确的事件模型和事件列表。</li><li>实现事件生产者，它负责发布系统中发生的事件。</li><li>实现事件消费者，它订阅感兴趣的事件并作出响应。</li><li>使用消息队列或事件总线来传输事件，确保系统的可靠性和可伸缩性。</li></ol><h3 id="水平扩展与垂直扩展"><a href="#水平扩展与垂直扩展" class="headerlink" title="水平扩展与垂直扩展"></a>水平扩展与垂直扩展</h3><p>水平扩展（Scaling Out）和垂直扩展（Scaling Up）是两种不同的系统扩展策略，用于提高应用程序或服务的处理能力。</p><h5 id="水平扩展（Scaling-Out）"><a href="#水平扩展（Scaling-Out）" class="headerlink" title="水平扩展（Scaling Out）"></a>水平扩展（Scaling Out）</h5><p>水平扩展指的是增加更多的节点来分摊负载，例如添加更多的服务器实例。</p><h6 id="最佳实践原则-55"><a href="#最佳实践原则-55" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h6><ul><li><strong>无状态服务</strong>：确保服务无状态，使得任何实例都能处理任何请求。</li><li><strong>负载均衡</strong>：使用负载均衡器来分配跨多个节点的请求。</li></ul><h6 id="实践步骤-68"><a href="#实践步骤-68" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>设计无状态的服务。</li><li>在多个服务器或容器中部署服务的实例。</li><li>配置负载均衡器来分配流量到不同的实例。</li></ol><h5 id="垂直扩展（Scaling-Up）"><a href="#垂直扩展（Scaling-Up）" class="headerlink" title="垂直扩展（Scaling Up）"></a>垂直扩展（Scaling Up）</h5><p>垂直扩展指的是增强单个节点的处理能力，如增加CPU、内存或存储资源。</p><h6 id="最佳实践原则-56"><a href="#最佳实践原则-56" class="headerlink" title="最佳实践原则"></a>最佳实践原则</h6><ul><li><strong>资源优化</strong>：优化应用程序以充分利用增强的硬件资源。</li><li><strong>成本效益</strong>：评估垂直扩展的成本效益，因为它可能涉及昂贵的硬件升级。</li></ul><h6 id="实践步骤-69"><a href="#实践步骤-69" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>识别性能瓶颈，确定需要增强的资源（CPU、内存等）。</li><li>升级硬件或迁移到更强大的机器。</li><li>优化应用程序配置以利用新的硬件资源。</li></ol><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>事件驱动型架构通过促进组件之间的松耦合交互，提高了系统的响应性和可伸缩性。它允许系统更灵活地处理大量并发事件，而不会受到单点故障的影响。水平扩展和垂直扩展是两种主要的系统扩展策略，它们可以用来应对不同的性能和资源需求。水平扩展通过增加更多的处理节点来提升系统的并发处理能力，而垂直扩展则通过增强单个节点的资源来提升其处理能力。选择合适的扩展策略取决于应用程序的需求、成本考虑以及预期的负载增长。</p><h3 id="边缘加速器的正确使用（例如，内容分发网络-CDN-）"><a href="#边缘加速器的正确使用（例如，内容分发网络-CDN-）" class="headerlink" title="边缘加速器的正确使用（例如，内容分发网络 [CDN]）"></a>边缘加速器的正确使用（例如，内容分发网络 [CDN]）</h3><h4 id="边缘加速器的概念"><a href="#边缘加速器的概念" class="headerlink" title="边缘加速器的概念"></a>边缘加速器的概念</h4><p>边缘加速器，如内容分发网络（CDN），是一种分布式网络基础设施，用于通过在全球多个地点缓存内容来加快内容的交付速度。CDN 的工作机制是将内容复制到距离用户更近的服务器上，从而减少数据传输的延迟，提高访问速度和用户体验。</p><h5 id="CDN的工作原理"><a href="#CDN的工作原理" class="headerlink" title="CDN的工作原理"></a>CDN的工作原理</h5><ul><li><strong>缓存静态资源</strong>：将网站的静态资源（如图片、CSS、JavaScript文件）缓存到全球分布的边缘节点。</li><li><strong>内容复制</strong>：根据用户的地理位置，从最近的边缘节点提供内容，减少数据旅行的距离。</li><li><strong>负载均衡</strong>：动态地将用户请求分配到最近或响应最快的边缘节点。</li></ul><h4 id="正确使用CDN"><a href="#正确使用CDN" class="headerlink" title="正确使用CDN"></a>正确使用CDN</h4><p>使用CDN时，需要考虑资源的缓存策略、内容的更新频率以及如何确保内容的安全性和合规性。</p><h5 id="缓存策略-1"><a href="#缓存策略-1" class="headerlink" title="缓存策略"></a>缓存策略</h5><ul><li><strong>设置合理的缓存时间</strong>：为不同类型的资源设置适当的缓存时间（TTL），以优化性能和更新频率之间的平衡。</li><li><strong>版本控制</strong>：使用资源版本控制，如文件指纹（hash），以确保更新后的内容能够被用户及时获取。</li></ul><h6 id="实践步骤-70"><a href="#实践步骤-70" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>为网站上的静态资源配置CDN。</li><li>设置缓存头信息，如<code>Cache-Control</code>，以控制资源在CDN节点的缓存时间。</li><li>当资源更新时，更改资源的文件名或添加查询字符串，以使缓存失效。</li></ol><h5 id="内容更新"><a href="#内容更新" class="headerlink" title="内容更新"></a>内容更新</h5><ul><li><strong>即时清除缓存</strong>：当内容更新时，使用CDN提供的清除缓存的功能，以确保用户能够访问到最新的内容。</li><li><strong>预缓存新内容</strong>：在发布新内容前，预先将其推送到CDN节点，以加快首次访问速度。</li></ul><h6 id="实践步骤-71"><a href="#实践步骤-71" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>配置CDN的缓存清除机制，以便在内容更新时能够快速清除旧版本。</li><li>利用CDN的API或控制面板来管理缓存和预加载新内容。</li></ol><h5 id="安全性和合规性"><a href="#安全性和合规性" class="headerlink" title="安全性和合规性"></a>安全性和合规性</h5><ul><li><strong>使用HTTPS</strong>：确保CDN节点支持HTTPS，加密用户和CDN之间的数据传输。</li><li><strong>遵守数据合规</strong>：选择支持数据地理位置合规的CDN提供商，尤其是在处理有地理位置限制的内容时。</li></ul><h6 id="实践步骤-72"><a href="#实践步骤-72" class="headerlink" title="实践步骤"></a>实践步骤</h6><ol><li>启用CDN的SSL/TLS功能，为所有缓存内容提供HTTPS加密。</li><li>确保CDN提供商符合地区的数据保护法规，如GDPR。</li></ol><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>正确使用CDN可以显著提升网站的加载速度和用户体验，同时减轻原始服务器的负载。为了最大化CDN的效果，应当设计合理的缓存策略，确保内容的及时更新，并且遵循最佳的安全和合规实践。通过这些步骤，可以确保内容以最高效和最安全的方式分发给全球的用户。</p><h3 id="将应用程序迁移到容器中"><a href="#将应用程序迁移到容器中" class="headerlink" title="将应用程序迁移到容器中"></a>将应用程序迁移到容器中</h3><h4 id="将应用程序迁移到容器中的概念"><a href="#将应用程序迁移到容器中的概念" class="headerlink" title="将应用程序迁移到容器中的概念"></a>将应用程序迁移到容器中的概念</h4><p>将应用程序迁移到容器中是一种将应用程序与其依赖项打包在一起的方式，以便在不同的环境中进行部署和运行。容器化应用程序具有独立性、可移植性和可扩展性，使得应用程序的部署和管理更加简化和灵活。</p><h5 id="容器化的工作原理"><a href="#容器化的工作原理" class="headerlink" title="容器化的工作原理"></a>容器化的工作原理</h5><ul><li><strong>容器引擎</strong>：使用容器引擎（如Docker）创建和管理容器。</li><li><strong>容器镜像</strong>：将应用程序及其依赖项打包为容器镜像，其中包含了应用程序运行所需的一切。</li><li><strong>容器运行时</strong>：将容器镜像部署到容器运行时环境中，如Docker引擎，以便在不同的主机上运行。</li></ul><h4 id="将应用程序迁移到容器中的步骤"><a href="#将应用程序迁移到容器中的步骤" class="headerlink" title="将应用程序迁移到容器中的步骤"></a>将应用程序迁移到容器中的步骤</h4><h5 id="1-容器化应用程序"><a href="#1-容器化应用程序" class="headerlink" title="1. 容器化应用程序"></a>1. 容器化应用程序</h5><ul><li><strong>创建Dockerfile</strong>：编写一个Dockerfile，定义如何构建容器镜像。在Dockerfile中指定应用程序的依赖项、环境变量和运行命令。</li><li><strong>构建容器镜像</strong>：使用Docker命令构建容器镜像，将Dockerfile与应用程序代码放在同一个目录中，并执行构建命令。</li></ul><h5 id="2-测试容器化应用程序"><a href="#2-测试容器化应用程序" class="headerlink" title="2. 测试容器化应用程序"></a>2. 测试容器化应用程序</h5><ul><li><strong>本地测试</strong>：在本地环境中使用Docker运行容器镜像，确保应用程序能够在容器中正常运行。</li><li><strong>验证功能</strong>：测试应用程序的功能和性能，确保在容器中的运行与原始环境中一致。</li></ul><h5 id="3-配置容器编排工具"><a href="#3-配置容器编排工具" class="headerlink" title="3. 配置容器编排工具"></a>3. 配置容器编排工具</h5><ul><li><strong>选择容器编排工具</strong>：选择适合的容器编排工具（如Kubernetes），用于管理和编排容器集群。</li><li><strong>配置集群</strong>：根据应用程序的需求，配置容器编排工具以创建、扩展和管理容器集群。</li></ul><h5 id="4-部署容器化应用程序"><a href="#4-部署容器化应用程序" class="headerlink" title="4. 部署容器化应用程序"></a>4. 部署容器化应用程序</h5><ul><li><strong>创建容器编排文件</strong>：编写容器编排文件（如Kubernetes的YAML文件），描述应用程序的部署配置和资源要求。</li><li><strong>部署应用程序</strong>：使用容器编排工具部署应用程序，将容器镜像部署到容器集群中的节点上。</li></ul><h5 id="5-监控和管理容器化应用程序"><a href="#5-监控和管理容器化应用程序" class="headerlink" title="5. 监控和管理容器化应用程序"></a>5. 监控和管理容器化应用程序</h5><ul><li><strong>监控应用程序</strong>：配置监控工具，监视容器化应用程序的性能和运行状态。</li><li><strong>容器管理</strong>：使用容器编排工具管理容器集群，包括扩展、缩减、更新和回滚应用程序。</li></ul><h4 id="容器化应用程序的最佳实践"><a href="#容器化应用程序的最佳实践" class="headerlink" title="容器化应用程序的最佳实践"></a>容器化应用程序的最佳实践</h4><ul><li><strong>最小化容器镜像</strong>：确保容器镜像尽可能小，只包含应用程序运行所需的依赖项。</li><li><strong>使用版本控制</strong>：将应用程序代码和Dockerfile纳入版本控制，以便跟踪和管理变更。</li><li><strong>配置环境变量</strong>：使用环境变量来传递应用程序的配置，以便在不同环境中进行配置更改。</li><li><strong>持久化数据</strong>：将应用程序生成的数据存储在持久化存储卷或外部存储中，以便在容器重新启动时不丢失数据。</li></ul><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>将应用程序迁移到容器中可以提供更好的应用程序管理和部署方式。通过容器化，应用程序可以更加独立、可移植和可扩展。迁移到容器中的步骤包括容器化应用程序、测试容器化应用程序、配置容器编排工具、部署容器化应用程序以及监控和管理容器化应用程序。遵循最佳实践原则，可以确保容器化应用程序的高效性和可靠性。</p><h3 id="负载均衡概念（例如，Application-Load-Balancer）"><a href="#负载均衡概念（例如，Application-Load-Balancer）" class="headerlink" title="负载均衡概念（例如，Application Load Balancer）"></a>负载均衡概念（例如，Application Load Balancer）</h3><h4 id="负载均衡的概念"><a href="#负载均衡的概念" class="headerlink" title="负载均衡的概念"></a>负载均衡的概念</h4><p>负载均衡是一种在多个服务器之间分配工作负载的技术，以提高应用程序的可用性、性能和可扩展性。负载均衡器（Load Balancer）作为中间层，接收客户端请求并将其分发到后端服务器，以确保请求能够被高效地处理。</p><h5 id="负载均衡的工作原理"><a href="#负载均衡的工作原理" class="headerlink" title="负载均衡的工作原理"></a>负载均衡的工作原理</h5><ul><li><strong>请求分发</strong>：负载均衡器接收客户端请求，并根据特定的算法将请求分发到后端服务器。</li><li><strong>流量管理</strong>：负载均衡器监控后端服务器的负载情况，并根据负载情况动态地分配请求，以确保各个服务器的负载均衡。</li><li><strong>故障处理</strong>：负载均衡器检测后端服务器的健康状态，并自动将请求从故障服务器转发到正常的服务器上。</li></ul><h4 id="Application-Load-Balancer（应用程序负载均衡器）的概念"><a href="#Application-Load-Balancer（应用程序负载均衡器）的概念" class="headerlink" title="Application Load Balancer（应用程序负载均衡器）的概念"></a>Application Load Balancer（应用程序负载均衡器）的概念</h4><p>Application Load Balancer（ALB）是云平台（如AWS）上的一种负载均衡服务，专门用于分发应用程序流量。ALB能够根据请求的内容和上下文信息，智能地将请求分发到不同的后端服务器上。</p><h5 id="ALB的特点和功能"><a href="#ALB的特点和功能" class="headerlink" title="ALB的特点和功能"></a>ALB的特点和功能</h5><ul><li><strong>应用层负载均衡</strong>：ALB在应用层（第7层）进行负载均衡，可以根据请求的内容进行路由和转发。</li><li><strong>多协议支持</strong>：ALB支持HTTP、HTTPS和WebSocket等多种协议。</li><li><strong>容器集成</strong>：ALB可以与容器服务（如ECS、EKS）集成，实现自动服务发现和动态端口映射。</li><li><strong>SSL/TLS终止</strong>：ALB可以终止SSL/TLS连接，并将请求以明文形式转发给后端服务器。</li><li><strong>身份验证和授权</strong>：ALB支持基于身份验证和授权的访问控制，以保护应用程序的安全性。</li></ul><h4 id="使用Application-Load-Balancer的步骤"><a href="#使用Application-Load-Balancer的步骤" class="headerlink" title="使用Application Load Balancer的步骤"></a>使用Application Load Balancer的步骤</h4><h5 id="1-创建Application-Load-Balancer"><a href="#1-创建Application-Load-Balancer" class="headerlink" title="1. 创建Application Load Balancer"></a>1. 创建Application Load Balancer</h5><ul><li><strong>配置监听器</strong>：定义负载均衡器监听的端口和协议（如HTTP或HTTPS）。</li><li><strong>配置目标组</strong>：创建目标组，指定后端服务器的信息（如IP地址和端口）。</li></ul><h5 id="2-配置目标组"><a href="#2-配置目标组" class="headerlink" title="2. 配置目标组"></a>2. 配置目标组</h5><ul><li><strong>添加后端服务器</strong>：将后端服务器添加到目标组中，以便负载均衡器将请求分发到这些服务器上。</li><li><strong>配置健康检查</strong>：定义健康检查规则，用于监测后端服务器的健康状态。</li></ul><h5 id="3-配置路由规则"><a href="#3-配置路由规则" class="headerlink" title="3. 配置路由规则"></a>3. 配置路由规则</h5><ul><li><strong>创建规则</strong>：定义路由规则，根据请求的路径、主机名或其他条件将请求转发到相应的目标组。</li><li><strong>配置目标组权重</strong>：根据服务器的性能和资源配置，调整目标组的权重，以实现负载均衡。</li></ul><h5 id="4-监控和调优"><a href="#4-监控和调优" class="headerlink" title="4. 监控和调优"></a>4. 监控和调优</h5><ul><li><strong>监控负载均衡器</strong>：使用云平台提供的监控工具，监测负载均衡器的性能和可用性。</li><li><strong>调整负载均衡策略</strong>：根据实际情况，调整负载均衡器的算法和配置，以满足应用程序的需求。</li></ul><h4 id="Application-Load-Balancer的最佳实践"><a href="#Application-Load-Balancer的最佳实践" class="headerlink" title="Application Load Balancer的最佳实践"></a>Application Load Balancer的最佳实践</h4><ul><li><strong>多区域部署</strong>：将负载均衡器部署在多个区域，以提高应用程序的冗余性和可用性。</li><li><strong>安全性配置</strong>：启用SSL/TLS终止，使用安全证书保护数据传输。</li><li><strong>优化目标组</strong>：根据应用程序的特点和负载情况，调整目标组的健康检查设置和目标服务器权重。</li><li><strong>日志记录和监控</strong>：启用负载均衡器的日志记录和监控功能，以便及时发现和解决问题。</li></ul><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>Application Load Balancer（应用程序负载均衡器）是一种用于分发应用程序流量的负载均衡服务。通过配置监听器、目标组和路由规则，可以实现请求的智能分发和负载均衡。使用ALB可以提高应用程序的可用性、性能和可扩展性。在使用ALB时，应遵循最佳实践，以确保负载均衡器的安全性和高效性。</p><h3 id="多层架构"><a href="#多层架构" class="headerlink" title="多层架构"></a>多层架构</h3><h4 id="多层架构的概念"><a href="#多层架构的概念" class="headerlink" title="多层架构的概念"></a>多层架构的概念</h4><p>多层架构是一种软件设计模式，将应用程序分为多个层级，每个层级负责不同的功能和责任。每个层级都有明确定义的接口，层与层之间通过接口进行通信和交互。多层架构的目标是实现分离关注点、提高可维护性和可扩展性。</p><h5 id="多层架构的层级"><a href="#多层架构的层级" class="headerlink" title="多层架构的层级"></a>多层架构的层级</h5><ul><li><strong>表示层</strong>：负责处理用户界面和用户交互，将用户请求传递给下一层处理，并将处理结果呈现给用户。</li><li><strong>应用层</strong>：包含应用程序的业务逻辑和处理规则，负责协调各个层级的工作，并处理业务逻辑。</li><li><strong>领域层</strong>：包含应用程序的核心业务逻辑和业务实体，负责处理业务规则和数据验证。</li><li><strong>数据访问层</strong>：负责与数据存储交互，包括数据库访问、数据持久化和数据操作。</li></ul><h4 id="多层架构的优势"><a href="#多层架构的优势" class="headerlink" title="多层架构的优势"></a>多层架构的优势</h4><p>多层架构具有以下优势：</p><ul><li><strong>分离关注点</strong>：不同层级负责不同的功能，使得代码易于理解、维护和扩展。</li><li><strong>可测试性</strong>：每个层级都可以独立进行单元测试，方便进行测试和调试。</li><li><strong>可扩展性</strong>：每个层级可以独立进行扩展，增加新的功能或修改现有功能。</li><li><strong>可维护性</strong>：各个层级之间的松耦合性使得代码的修改和维护更加容易。</li><li><strong>团队协作</strong>：不同的开发团队可以同时开发不同的层级，提高开发效率。</li></ul><h4 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h4><p>表示层负责处理用户界面和用户交互，将用户的请求传递给下一层处理，并将处理结果呈现给用户。</p><p>表示层的功能包括：</p><ul><li><strong>用户界面</strong>：设计和开发用户界面，包括网页、移动应用等。</li><li><strong>用户输入处理</strong>：接收用户的输入请求，验证和解析用户输入。</li><li><strong>用户输出呈现</strong>：将处理结果呈现给用户，生成并发送响应。</li></ul><h4 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h4><p>应用层包含应用程序的业务逻辑和处理规则，负责协调各个层级的工作，并处理业务逻辑。</p><p>应用层的功能包括：</p><ul><li><strong>业务逻辑处理</strong>：实现应用程序的业务规则和处理逻辑。</li><li><strong>协调层级</strong>：协调表示层、领域层和数据访问层之间的交互和通信。</li><li><strong>异常处理</strong>：处理和管理应用程序的异常情况。</li></ul><h4 id="领域层（Domain-Layer）"><a href="#领域层（Domain-Layer）" class="headerlink" title="领域层（Domain Layer）"></a>领域层（Domain Layer）</h4><p>领域层包含应用程序的核心业务逻辑和业务实体，负责处理业务规则和数据验证。</p><p>领域层的功能包括：</p><ul><li><strong>业务实体</strong>：定义和实现业务实体，包括对象和数据模型。</li><li><strong>业务规则</strong>：实现业务规则和业务逻辑，确保数据的有效性和一致性。</li><li><strong>数据验证</strong>：验证和验证输入数据的有效性和完整性。</li></ul><h4 id="数据访问层（Data-Access-Layer）"><a href="#数据访问层（Data-Access-Layer）" class="headerlink" title="数据访问层（Data Access Layer）"></a>数据访问层（Data Access Layer）</h4><p>数据访问层负责与数据存储交互，包括数据库访问、数据持久化和数据操作。</p><p>数据访问层的功能包括：</p><ul><li><strong>数据库访问</strong>：与数据库进行交互，执行数据查询、插入、更新和删除操作。</li><li><strong>数据持久化</strong>：将数据持久化到数据库或其他数据存储介质中。</li><li><strong>数据操作</strong>：封装对数据的操作，提供高层次的数据访问接口。</li></ul><h4 id="多层架构的最佳实践"><a href="#多层架构的最佳实践" class="headerlink" title="多层架构的最佳实践"></a>多层架构的最佳实践</h4><ul><li><strong>单一职责原则</strong>：每个层级应该具有清晰的职责和功能，避免功能交叉和混乱。</li><li><strong>松耦合</strong>：各个层级之间应该松散耦合，通过接口进行通信，降低依赖性。</li><li><strong>抽象和封装</strong>：使用接口和抽象类来定义层级之间的交互和通信。</li><li><strong>分层架构图</strong>：绘制和维护分层架构图，以便开发人员理解和遵循架构设计。</li><li><strong>测试驱动开发</strong>：每个层级都应该进行单元测试，确保各个层级的功能和交互正常。</li></ul><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>多层架构将应用程序分为表示层、应用层、领域层和数据访问层，每个层级负责不同的功能和责任。多层架构的优势包括分离关注点、</p><h3 id="队列和消息收发概念（例如，发布-订阅）"><a href="#队列和消息收发概念（例如，发布-订阅）" class="headerlink" title="队列和消息收发概念（例如，发布/订阅）"></a>队列和消息收发概念（例如，发布/订阅）</h3><h4 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h4><p>队列是一种常用的数据结构，用于存储和管理元素。它遵循先进先出（FIFO）的原则，即先进入队列的元素将首先被处理，后进入队列的元素将在后续被处理。</p><p>队列的操作包括：</p><ul><li><strong>入队（Enqueue）</strong>：将元素添加到队列的末尾。</li><li><strong>出队（Dequeue）</strong>：从队列的头部移除并返回元素。</li><li><strong>查看队头元素（Peek）</strong>：查看队列头部的元素，但不将其移除。</li></ul><p>队列常用于处理异步任务、消息传递和事件处理等场景，其中消息收发是队列的一个重要应用。</p><h4 id="消息收发的概念"><a href="#消息收发的概念" class="headerlink" title="消息收发的概念"></a>消息收发的概念</h4><p>消息收发是一种用于在分布式系统中进行通信的模式。在消息收发模式中，消息发送者将消息发送到消息队列，而消息接收者从队列中接收和处理消息。</p><h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h5><p>发布/订阅（Publish/Subscribe）是一种常见的消息收发模式。在发布/订阅模式中，消息发送者（发布者）将消息发布到特定的主题（Topic），而消息接收者（订阅者）订阅感兴趣的主题，从而接收与该主题相关的消息。</p><p>发布/订阅模式的特点包括：</p><ul><li><strong>解耦性</strong>：发布者和订阅者之间是松耦合的，彼此不需要直接知道对方的存在。</li><li><strong>灵活性</strong>：发布者可以将消息发布到多个主题，订阅者可以订阅多个主题。</li><li><strong>扩展性</strong>：可以动态地添加新的发布者和订阅者，扩展系统的功能和规模。</li></ul><h4 id="使用队列和发布-订阅模式的步骤"><a href="#使用队列和发布-订阅模式的步骤" class="headerlink" title="使用队列和发布/订阅模式的步骤"></a>使用队列和发布/订阅模式的步骤</h4><h5 id="1-创建消息队列"><a href="#1-创建消息队列" class="headerlink" title="1. 创建消息队列"></a>1. 创建消息队列</h5><ul><li><strong>选择消息队列系统</strong>：选择适合你的需求的消息队列系统，如RabbitMQ、Apache Kafka等。</li><li><strong>配置消息队列</strong>：创建消息队列，设置队列的属性和参数。</li></ul><h5 id="2-定义消息格式和主题"><a href="#2-定义消息格式和主题" class="headerlink" title="2. 定义消息格式和主题"></a>2. 定义消息格式和主题</h5><ul><li><strong>消息格式</strong>：定义消息的结构和内容，包括消息的字段和数据类型。</li><li><strong>主题</strong>：定义不同的主题，用于区分不同类型的消息。</li></ul><h5 id="3-发布消息"><a href="#3-发布消息" class="headerlink" title="3. 发布消息"></a>3. 发布消息</h5><ul><li><strong>创建发布者</strong>：创建发布者应用程序，连接到消息队列。</li><li><strong>选择主题</strong>：选择要发布的消息主题。</li><li><strong>构造消息</strong>：构造消息，填充消息的内容和字段。</li><li><strong>发布消息</strong>：将消息发布到消息队列的指定主题。</li></ul><h5 id="4-订阅消息"><a href="#4-订阅消息" class="headerlink" title="4. 订阅消息"></a>4. 订阅消息</h5><ul><li><strong>创建订阅者</strong>：创建订阅者应用程序，连接到消息队列。</li><li><strong>选择订阅的主题</strong>：选择要订阅的消息主题。</li><li><strong>接收消息</strong>：订阅者从消息队列接收与其订阅的主题相关的消息。</li><li><strong>处理消息</strong>：订阅者处理接收到的消息，执行相应的操作。</li></ul><h4 id="队列和消息收发的最佳实践"><a href="#队列和消息收发的最佳实践" class="headerlink" title="队列和消息收发的最佳实践"></a>队列和消息收发的最佳实践</h4><ul><li><strong>消息持久化</strong>：确保消息在发送和接收过程中的持久化存储，以防止消息丢失。</li><li><strong>消息确认机制</strong>：使用消息确认机制，确保消息在发送和接收之间的可靠传递。</li><li><strong>消息序列化</strong>：对消息进行序列化和反序列化，以便在不同的应用程序和平台之间进行通信。</li><li><strong>错误处理和重试</strong>：处理发送和接收消息过程中的错误，并实现适当的重试机制。</li><li><strong>监控和日志记录</strong>：监控消息队列的性能和可用性，并记录相关的日志信息。</li></ul><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>队列是一种先进先出的数据结构，常用于存储和管理元素。消息收发是一种在分布式系统中进行通信的模式，其中发布/订阅是常见的消息收发模式。使用队列和发布/订阅模式可以实现异步任务处理、消息传递和事件处理等功能</p><h3 id="无服务器技术和模式（例如，AWS-Fargate、AWS-Lambda）"><a href="#无服务器技术和模式（例如，AWS-Fargate、AWS-Lambda）" class="headerlink" title="无服务器技术和模式（例如，AWS Fargate、AWS Lambda）"></a>无服务器技术和模式（例如，AWS Fargate、AWS Lambda）</h3><ul><li><h4 id="无服务器技术和模式概述"><a href="#无服务器技术和模式概述" class="headerlink" title="无服务器技术和模式概述"></a>无服务器技术和模式概述</h4><p>无服务器技术是一种云计算模型，它使开发人员能够构建和运行应用程序，而无需关注底层的服务器管理和维护。无服务器模式基于事件驱动的架构，可以根据需要自动扩展和收缩资源，以满足应用程序的需求。AWS（亚马逊网络服务）提供了多种无服务器服务，其中包括AWS Fargate和AWS Lambda。</p><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>AWS Fargate是一种无服务器容器计算引擎，允许开发人员在无需管理服务器的情况下运行容器化的应用程序。它提供了一种简化的方式来部署和管理容器，使开发人员可以专注于应用程序的开发和部署，而无需关注底层的基础设施。</p><h5 id="主要特性和用途"><a href="#主要特性和用途" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无服务器容器</strong>：AWS Fargate允许开发人员以无服务器的方式运行容器，无需管理底层的服务器资源。</li><li><strong>按需计费</strong>：AWS Fargate按实际使用的资源进行计费，可以根据应用程序的需求自动扩展和收缩容器。</li><li><strong>与其他AWS服务集成</strong>：AWS Fargate可以与其他AWS服务集成，如Amazon ECS（Elastic Container Service）和Amazon ECR（Elastic Container Registry），以构建完整的容器解决方案。</li></ul><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建任务定义</strong>：定义容器的规格、映像和其他配置。</li><li><strong>创建集群</strong>：创建一个容器集群，用于托管和管理容器实例。</li><li><strong>启动任务</strong>：将任务定义部署到集群中，启动容器实例。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理容器实例，进行日志记录、扩展和更新等操作。</li></ol><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>AWS Lambda是一种无服务器计算服务，以事件驱动的方式运行代码。开发人员可以编写函数并将其上传到AWS Lambda，然后在需要时自动触发执行函数。AWS Lambda负责管理底层的计算资源，使开发人员可以专注于编写业务逻辑。</p><h5 id="主要特性和用途-1"><a href="#主要特性和用途-1" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无服务器计算</strong>：AWS Lambda以无服务器的方式运行代码，无需管理底层的服务器。</li><li><strong>按需计费</strong>：AWS Lambda按代码的实际执行时间和资源使用进行计费，没有持续运行的费用。</li><li><strong>自动扩展</strong>：AWS Lambda根据请求的数量和负载自动扩展和收缩资源。</li><li><strong>与其他AWS服务集成</strong>：AWS Lambda可以与其他AWS服务集成，如API网关、S3、DynamoDB等，以构建强大的无服务器应用程序。</li></ul><h5 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>编写函数</strong>：编写函数代码，处理特定的事件或请求。</li><li><strong>创建Lambda函数</strong>：使用AWS管理控制台或CLI工具创建Lambda函数，并上传函数代码。</li><li><strong>配置触发器</strong>：配置触发器，指定何时触发函数的执行，如API调用、定时任务或其他事件。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理Lambda函数，查看执行日志、设置权限和调整函数配置等操作。</li></ol><h4 id="无服务器技术的最佳实践"><a href="#无服务器技术的最佳实践" class="headerlink" title="无服务器技术的最佳实践"></a>无服务器技术的最佳实践</h4><ul><li><strong>函数拆分</strong>：将应用程序拆分为多个小型函数，以提高可维护性和扩展性。</li><li><strong>状态管理</strong>：避免在函数之间共享状态，使用无状态函数设计，将状态存储在外部服务中。</li><li><strong>日志和监控</strong>：记录函数的执行日志，并使用监控工具来监视函数的性能和可用性。</li><li><strong>安全性</strong>：实施适当的安全措施，如函数级别的访问控制、数据加密和网络安全配置。</li><li><strong>测试和部署</strong>：编写自动化测试用例，使用持续集成和部署工具来自动部署和更新函数。</li></ul><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>无服务器技术和模式使开发人员能够构建和运行应用程序，而无需关注底层的服务器管理和维护。AWS Fargate是一种无服务器容器计算引擎，允许无服务器地运行容器化的应用程序。AWS Lambda是一种无服务器计算服务，以事件驱动的方式运行代码。无服务器技术的最佳实践包括函数拆分、状态管理、日志和监控、安全性以及测试和部署。</p></li></ul><h3 id="具有相关特性的存储类型（例如，对象、文件、数据块）"><a href="#具有相关特性的存储类型（例如，对象、文件、数据块）" class="headerlink" title="具有相关特性的存储类型（例如，对象、文件、数据块）"></a>具有相关特性的存储类型（例如，对象、文件、数据块）</h3><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>对象存储是一种存储数据的方式，它以对象的形式存储数据和元数据，并提供简单的API来管理和访问数据。</p><h5 id="主要特性和用途-2"><a href="#主要特性和用途-2" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>无限扩展</strong>：对象存储可以存储大规模的数据，具有无限的扩展性。</li><li><strong>高可用性</strong>：对象存储通常具有高可用性，数据会自动在多个地理位置进行复制和冗余存储。</li><li><strong>持久性</strong>：对象存储数据通常是持久的，不容易丢失。</li><li><strong>适用于大文件和多媒体</strong>：对象存储适用于存储大型文件和多媒体内容，如图像、视频和音频文件。</li><li><strong>与其他服务集成</strong>：对象存储可以与其他服务集成，如CDN、数据分析和备份服务。</li></ul><h5 id="示例服务"><a href="#示例服务" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon S3</strong>：亚马逊简单存储服务（Amazon S3）是一种对象存储服务，用于在亚马逊云上存储和检索数据。它是一种高度可扩展、持久性强的存储解决方案，广泛用于各种应用程序和场景。</li></ul><h4 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h4><p>文件存储是一种存储数据的方式，它以文件的形式存储数据，并提供文件系统接口来管理和访问数据。</p><h5 id="主要特性和用途-3"><a href="#主要特性和用途-3" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>文件系统接口</strong>：文件存储提供类似于传统文件系统的接口，如读取、写入和删除文件。</li><li><strong>适用于结构化数据</strong>：文件存储适用于存储结构化的数据，如文本文件、配置文件和日志文件。</li><li><strong>共享访问</strong>：多个应用程序或用户可以共享访问文件存储中的数据。</li><li><strong>与现有应用程序兼容</strong>：文件存储可以与现有的应用程序和工具集成，无需进行大规模的代码更改。</li></ul><h5 id="示例服务-1"><a href="#示例服务-1" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon EFS</strong>：亚马逊弹性文件系统（Amazon EFS）是一种可扩展的、共享的文件存储服务，用于在亚马逊云上存储和访问文件数据。它提供标准文件系统接口，可以与多个EC2实例共享访问。</li></ul><h4 id="数据块存储"><a href="#数据块存储" class="headerlink" title="数据块存储"></a>数据块存储</h4><p>数据块存储是一种存储数据的方式，它将数据划分为固定大小的数据块，并使用唯一的标识符来管理和访问这些数据块。</p><h5 id="主要特性和用途-4"><a href="#主要特性和用途-4" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>低延迟</strong>：数据块存储通常具有低延迟的读写操作，适用于需要快速访问的应用程序。</li><li><strong>随机访问</strong>：可以随机访问数据块，而不需要读取整个文件或对象。</li><li><strong>适用于数据库和应用程序</strong>：数据块存储适用于存储数据库和应用程序的数据，如关系数据库和分布式文件系统。</li></ul><h5 id="示例服务-2"><a href="#示例服务-2" class="headerlink" title="示例服务"></a>示例服务</h5><ul><li><strong>Amazon EBS</strong>：亚马逊弹性块存储（Amazon EBS）是一种持久性块存储服务，用于在亚马逊云上附加和使用块级存储卷。它提供低延迟的随机访问，并可与EC2实例进行关联。</li></ul><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p>存储类型包括对象存储、文件存储和数据块存储。对象存储适用于存储大规模数据和多媒体内容，如Amazon S3。文件存储适用于结构化数据和共享访问，如Amazon EFS。数据块存储适用于低延迟和随机访问的应用程序，如Amazon EBS。选择适当的存储类型取决于应用程序的需求和数据的特性。</p><h3 id="容器编排（例如，Amazon-Elastic-Container-Service-Amazon-ECS-、Amazon-Elastic-Kubernetes-Service-Amazon-EKS-）"><a href="#容器编排（例如，Amazon-Elastic-Container-Service-Amazon-ECS-、Amazon-Elastic-Kubernetes-Service-Amazon-EKS-）" class="headerlink" title="容器编排（例如，Amazon Elastic Container Service [Amazon ECS]、Amazon Elastic Kubernetes Service [Amazon EKS]）"></a>容器编排（例如，Amazon Elastic Container Service [Amazon ECS]、Amazon Elastic Kubernetes Service [Amazon EKS]）</h3><h4 id="容器编排概述"><a href="#容器编排概述" class="headerlink" title="容器编排概述"></a>容器编排概述</h4><p>容器编排是一种管理和调度容器化应用程序的技术，它可以帮助开发人员自动化容器的部署、扩展和管理。容器编排工具提供了一种简化的方式来定义、组织和运行容器，以便应用程序能够高效地运行在分布式环境中。AWS（亚马逊网络服务）提供了多种容器编排服务，其中包括Amazon Elastic Container Service（Amazon ECS）和Amazon Elastic Kubernetes Service（Amazon EKS）。</p><h4 id="Amazon-Elastic-Container-Service（Amazon-ECS）"><a href="#Amazon-Elastic-Container-Service（Amazon-ECS）" class="headerlink" title="Amazon Elastic Container Service（Amazon ECS）"></a>Amazon Elastic Container Service（Amazon ECS）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>Amazon Elastic Container Service（Amazon ECS）是一种高度可扩展的容器编排服务，用于在AWS云上运行和管理容器化应用程序。它提供了一种简单的方式来部署、运行和扩展容器，同时具备高可用性和可靠性。</p><h5 id="主要特性和用途-5"><a href="#主要特性和用途-5" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>托管容器</strong>：Amazon ECS允许开发人员将容器化的应用程序部署到托管的集群中，无需关注底层的基础设施。</li><li><strong>自动扩展</strong>：Amazon ECS可以根据应用程序的负载自动扩展和收缩容器实例，以确保应用程序的性能和可用性。</li><li><strong>与其他AWS服务集成</strong>：Amazon ECS可以与其他AWS服务集成，如Amazon EC2（Elastic Compute Cloud）、Amazon S3（Simple Storage Service）和Amazon VPC（Virtual Private Cloud），以构建完整的应用程序解决方案。</li><li><strong>任务定义和服务</strong>：通过任务定义和服务，可以定义容器的规格、映像和其他配置，并确保容器的持续运行和自动恢复。</li></ul><h5 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建集群</strong>：创建一个Amazon ECS集群，用于托管和管理容器实例。</li><li><strong>定义任务</strong>：创建一个任务定义，定义容器的规格、映像和其他配置。</li><li><strong>启动任务</strong>：使用任务定义创建一个任务，并将其部署到集群中，启动容器实例。</li><li><strong>创建服务</strong>：创建一个服务，指定任务的副本数和负载均衡策略，以确保容器的持续运行和自动恢复。</li><li><strong>监控和管理</strong>：使用AWS管理控制台或CLI工具来监控和管理容器实例和服务，进行日志记录、扩展和更新等操作。</li></ol><h4 id="Amazon-Elastic-Kubernetes-Service（Amazon-EKS）"><a href="#Amazon-Elastic-Kubernetes-Service（Amazon-EKS）" class="headerlink" title="Amazon Elastic Kubernetes Service（Amazon EKS）"></a>Amazon Elastic Kubernetes Service（Amazon EKS）</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>Amazon Elastic Kubernetes Service（Amazon EKS）是一种托管的Kubernetes服务，用于在AWS云上运行和管理Kubernetes容器编排平台。它提供了一个高度可扩展、安全和可靠的方式来部署和管理容器化应用程序。</p><h5 id="主要特性和用途-6"><a href="#主要特性和用途-6" class="headerlink" title="主要特性和用途"></a>主要特性和用途</h5><ul><li><strong>托管Kubernetes集群</strong>：Amazon EKS提供了一个托管的Kubernetes控制平面，负责管理和调度容器化应用程序。</li><li><strong>自动扩展</strong>：Amazon EKS可以根据应用程序的负载自动扩展和收缩Kubernetes节点，以满足应用程序的需求。</li><li><strong>与其他AWS服务集成</strong>：Amazon EKS可以与其他AWS服务集成，如Amazon EC2、Amazon S3和Amazon VPC，以构建强大的容器化应用程序解决方案。</li><li><strong>Kubernetes生态系统</strong>：Amazon EKS与Kubernetes生态系统紧密集成，可以使用Kubernetes的丰富功能和工具来部署和管理应用程序。</li></ul><h5 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol><li><strong>创建集群</strong>：创建一个Amazon EKS集群，该集群将作为Kubernetes控制平面的托管环境。</li><li><strong>配置kubectl</strong>：配置kubectl命令行工具，以便与Amazon EKS集群进行通信。</li><li><strong>部署应用程序</strong>：使用Kubernetes清单文件定义和部署应用程序的Pod、服务和其他资源。</li><li><strong>扩展和管理</strong>：使用kubectl命令行工具或Kubernetes仪表板来扩展和管理应用程序，进行水平扩展、滚动更新和故障恢复等操作。</li><li><strong>监控和日志</strong>：使用Kubernetes的监控和日志工具，如Prometheus和Elasticsearch，来监控和记录应用程序的性能和日志。</li></ol><h4 id="容器编排的最佳实践"><a href="#容器编排的最佳实践" class="headerlink" title="容器编排的最佳实践"></a>容器编排的最佳实践</h4><ul><li><p><strong>声明式清单</strong>：使用声明式的清单文件来定义和部署应用程序，以便实现可重复、可维护和可扩展的部署。</p></li><li><p><strong>自动化部署</strong>：使用持续集成和持续部署（CI/CD）工具来自动化应用程序的</p></li><li><p>部署过程，包括构建、测试、部署和监控等环节，以提高开发和交付效率。</p><ul><li><strong>服务发现和负载均衡</strong>：使用容器编排工具提供的服务发现和负载均衡功能，以实现容器之间的通信和流量分发。</li><li><strong>弹性扩展</strong>：根据应用程序的负载情况，使用自动扩展功能来动态调整容器实例的数量，以满足需求并节省资源。</li><li><strong>安全性</strong>：实施适当的安全措施，如访问控制、网络隔离和容器映像的安全扫描，以保护容器化应用程序的安全性。</li><li><strong>日志和监控</strong>：使用日志和监控工具来收集、分析和可视化容器化应用程序的日志和性能指标，以便快速发现和解决问题。</li><li><strong>持续改进</strong>：不断优化容器编排的流程和架构，通过监控和分析数据来改进应用程序的性能、可靠性和可扩展性。</li></ul><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p>容器编排是一种管理和调度容器化应用程序的技术，可以帮助开发人员自动化容器的部署、扩展和管理。AWS提供了多种容器编排服务，包括Amazon ECS和Amazon EKS。Amazon ECS是一种高度可扩展的容器编排服务，用于在AWS云上运行和管理容器化应用程序。Amazon EKS是一种托管的Kubernetes服务，用于在AWS云上运行和管理Kubernetes容器编排平台。容器编排的最佳实践包括使用声明式清单、自动化部署、服务发现和负载均衡、弹性扩展、安全性、日志和监控以及持续改进。</p></li></ul><h3 id="何时使用只读副本"><a href="#何时使用只读副本" class="headerlink" title="何时使用只读副本"></a>何时使用只读副本</h3><h4 id="只读副本概述"><a href="#只读副本概述" class="headerlink" title="只读副本概述"></a>只读副本概述</h4><p>只读副本是数据库系统中的一种常见技术，它允许在主数据库的基础上创建一个副本，并将该副本配置为只读模式。只读副本用于提供读取性能的扩展、高可用性和冗余备份。在某些情况下，只读副本可以提供更好的性能和可用性，同时减轻主数据库的负载。</p><h4 id="何时使用只读副本-1"><a href="#何时使用只读副本-1" class="headerlink" title="何时使用只读副本"></a>何时使用只读副本</h4><p>以下是一些适合使用只读副本的情况：</p><h5 id="1-读取密集型工作负载"><a href="#1-读取密集型工作负载" class="headerlink" title="1. 读取密集型工作负载"></a>1. 读取密集型工作负载</h5><p>如果应用程序有大量的读取操作，而写入操作较少，可以考虑使用只读副本来分担主数据库的读取负载。只读副本可以处理读取请求，从而提高整体性能和响应时间。</p><h5 id="2-高可用性和容错"><a href="#2-高可用性和容错" class="headerlink" title="2. 高可用性和容错"></a>2. 高可用性和容错</h5><p>只读副本可以提供高可用性和容错能力。当主数据库发生故障或不可用时，只读副本可以继续提供读取服务，确保应用程序的连续性。这对于对可用性要求较高的关键业务非常重要。</p><h5 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3. 负载均衡"></a>3. 负载均衡</h5><p>通过将读取请求分发到多个只读副本，可以实现负载均衡，从而提高整体系统的性能和吞吐量。只读副本可以根据负载情况自动处理读取请求，减轻主数据库的负载。</p><h5 id="4-数据分析和报告"><a href="#4-数据分析和报告" class="headerlink" title="4. 数据分析和报告"></a>4. 数据分析和报告</h5><p>如果需要对数据库中的数据进行复杂的分析和报告，可以使用只读副本来执行这些任务，而不会对主数据库的性能产生负面影响。只读副本可以专门用于数据分析，提供更高的性能和资源。</p><h5 id="5-备份和恢复"><a href="#5-备份和恢复" class="headerlink" title="5. 备份和恢复"></a>5. 备份和恢复</h5><p>只读副本可以作为主数据库的冗余备份。通过定期将主数据库的数据复制到只读副本，可以确保在主数据库发生故障或数据损坏时能够快速恢复数据。</p><h4 id="部署只读副本的步骤"><a href="#部署只读副本的步骤" class="headerlink" title="部署只读副本的步骤"></a>部署只读副本的步骤</h4><p>以下是部署只读副本的一般步骤：</p><ol><li><p><strong>创建只读副本</strong>：在主数据库的基础上创建一个副本，并将其配置为只读模式。这可以通过数据库管理工具或数据库系统提供的命令来完成。</p></li><li><p><strong>配置复制</strong>：配置主数据库和只读副本之间的数据复制机制。这可以使用数据库系统提供的复制功能，如MySQL的主从复制或PostgreSQL的流复制。</p></li><li><p><strong>连接和路由</strong>：确保应用程序能够连接到只读副本并发送读取请求。这可能涉及到调整应用程序的数据库连接字符串或配置负载均衡器来路由读取请求到只读副本。</p></li><li><p><strong>监控和维护</strong>：监控只读副本的状态和性能，确保它正常工作并与主数据库保持同步。定期进行维护操作，如备份和更新，以保持只读副本的可用性和数据完整性。</p></li></ol><h4 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ul><li><p><strong>数据一致性</strong>：只读副本是通过复制主数据库的数据来实现的，因此在进行读取操作时，可能会存在一定的延迟，导致读取到的数据可能不是最新的。在应用程序中要注意处理这种数据一致性的情况。</p></li><li><p><strong>负载均衡策略</strong>：根据应用程序的读取负载情况选择合适的负载均衡策略，如轮询、最少连接等，以确保读取请求能够均衡地分发到只读副本。</p></li><li><p><strong>监控和警报</strong>：建立监控和警报系统，及时检测只读副本的状态和性能问题。监控指标可以包括副本延迟、同步状态、负载情况等。</p></li><li><p><strong>定期测试和维护</strong>：定期进行测试和维护操作，如故障切换测试、备份恢复测试和软件更新。这可以帮助确保只读副本的可用性和数据完整性。</p></li></ul><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p>只读副本是一种常见的数据库技术，用于提供读取性能的扩展、高可用性和冗余备份。适合使用只读副本的情况包括读取密集型工作负载、高可用性和容错、负载均衡、数据分析和报告以及备份和恢复。部署只读副本的步骤包括创建副本、配置复制、连接和路由以及监控和维护。在使用只读副本时，需要注意数据一致性、负载均衡策略、监控和警报以及定期测试和维护等注意事项和最佳实践。</p><h3 id="工作流编排（例如，AWS-Step-Functions）"><a href="#工作流编排（例如，AWS-Step-Functions）" class="headerlink" title="工作流编排（例如，AWS Step Functions）"></a>工作流编排（例如，AWS Step Functions）</h3><h4 id="工作流编排概述"><a href="#工作流编排概述" class="headerlink" title="工作流编排概述"></a>工作流编排概述</h4><p>工作流编排是一种将多个任务和步骤组织起来，按照特定的顺序和条件执行的技术。它可以帮助简化复杂的业务逻辑和流程，并提供可靠的执行和错误处理机制。AWS Step Functions是亚马逊云服务（AWS）提供的一项工作流编排服务，它使开发人员能够轻松地构建、部署和管理具有复杂业务逻辑的工作流应用程序。</p><h4 id="何时使用工作流编排"><a href="#何时使用工作流编排" class="headerlink" title="何时使用工作流编排"></a>何时使用工作流编排</h4><p>以下是一些适合使用工作流编排的情况：</p><h5 id="1-复杂的业务逻辑"><a href="#1-复杂的业务逻辑" class="headerlink" title="1. 复杂的业务逻辑"></a>1. 复杂的业务逻辑</h5><p>如果应用程序的业务逻辑涉及多个步骤和条件，且这些步骤需要按照特定的顺序执行，那么使用工作流编排可以帮助组织和管理这些步骤，使业务逻辑更易于理解和维护。</p><h5 id="2-异步和分布式任务"><a href="#2-异步和分布式任务" class="headerlink" title="2. 异步和分布式任务"></a>2. 异步和分布式任务</h5><p>当应用程序需要执行异步和分布式任务时，工作流编排可以帮助协调和管理这些任务的执行顺序和依赖关系。工作流编排可以处理任务的并行执行、等待和超时等复杂情况。</p><h5 id="3-错误处理和重试"><a href="#3-错误处理和重试" class="headerlink" title="3. 错误处理和重试"></a>3. 错误处理和重试</h5><p>工作流编排提供了强大的错误处理和重试机制。当任务执行失败时，工作流编排可以根据配置的错误处理策略进行相应的处理，如重试、错误通知或执行备用步骤。</p><h5 id="4-可视化和监控"><a href="#4-可视化和监控" class="headerlink" title="4. 可视化和监控"></a>4. 可视化和监控</h5><p>工作流编排通常提供可视化界面，用于可视化工作流的结构和执行状态。这可以帮助开发人员和运维团队更好地理解和监控工作流的执行情况，及时发现和解决问题。</p><h4 id="使用-AWS-Step-Functions-的步骤"><a href="#使用-AWS-Step-Functions-的步骤" class="headerlink" title="使用 AWS Step Functions 的步骤"></a>使用 AWS Step Functions 的步骤</h4><p>以下是使用AWS Step Functions进行工作流编排的一般步骤：</p><ol><li><p><strong>定义状态机</strong>：使用AWS Step Functions提供的定义语言（如Amazon States Language）来定义工作流的状态机。状态机由一系列状态和状态转换组成，每个状态代表一个任务或步骤。</p></li><li><p><strong>配置输入和输出</strong>：为工作流定义输入和输出参数，以便任务之间可以传递数据。输入参数可以是工作流的初始输入，输出参数可以是工作流的最终结果。</p></li><li><p><strong>定义状态转换</strong>：为每个状态定义状态转换条件和动作。状态转换条件可以是成功或失败的条件，动作可以是执行任务、等待、重试或跳转到其他状态。</p></li><li><p><strong>部署和执行</strong>：将定义好的状态机部署到AWS Step Functions，并通过API或控制台触发工作流的执行。工作流将按照定义的状态机和转换逻辑执行任务。</p></li><li><p><strong>监控和调试</strong>：使用AWS Step Functions提供的监控和日志功能来监控工作流的执行情况。可以查看工作流的状态、执行时间和错误信息，以及进行调试和故障排除。</p></li></ol><h4 id="注意事项和最佳实践-1"><a href="#注意事项和最佳实践-1" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ul><li><p><strong>模块化设计</strong>：将工作流分解为较小的任务和步骤，并通过模块化的方式设计状态机。这样可以提高工作流的可维护性和重用性。</p></li><li><p><strong>错误处理和重试策略</strong>：定义适当的错误处理和重试策略，以处理任务执行失败的情况。可以配置重试次数、重试间隔和备用步骤等。</p></li><li><p><strong>保持状态的幂等性</strong>：确保工作流中的任务和步骤具有幂等性，即多次执行不会产生不一致的结果。这样可以避免由于重试导致的数据重复或不一致性。</p></li><li><p><strong>监控和警报</strong>：建立监控和警报系统，及时检测工作流的执行状态和错误情况。可以使用AWS CloudWatch等服务来监控工作流的指标和日志。</p></li><li><p><strong>版本控制和回滚</strong>：对工作流的定义和配置进行版本控制，并确保可以回滚到之前的版本。这样可以方便地管理和维护工作流的变更和更新。</p></li></ul><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p>工作流编排是一种将多个任务和步骤组织起来、按照特定顺序和条件执行的技术。AWS Step Functions是一项强大的工作流编排服务，适用于复杂的业务逻辑、异步和分布式任务、错误处理和重试以及可视化和监控需求。使用AWS Step Functions的步骤包括定义状态机、配置输入和输出、定义状态转换、部署和执行以及监控和调试。在使用AWS Step Functions时，需要注意模块化设计、错误处理和重试策略、保持状态的幂等性、监控和警报以及版本控制和回滚等注意事项和最佳实践。</p><h2 id="设计高可用性架构和-或容错架构"><a href="#设计高可用性架构和-或容错架构" class="headerlink" title="设计高可用性架构和/或容错架构"></a>设计高可用性架构和/或容错架构</h2><h4 id="AWS全球基础设施"><a href="#AWS全球基础设施" class="headerlink" title="AWS全球基础设施"></a>AWS全球基础设施</h4><p>AWS全球基础设施包括多个地理区域和可用区。每个区域是一组数据中心，每个区域内的可用区则是更小的独立单元，可提供冗余和容错能力。例如，如果一个可用区出现故障，其他可用区仍能继续运行。Amazon Route 53是一种DNS服务，可以根据地理位置智能地路由用户到最近的区域。</p><h4 id="AWS-Managed-Services及其使用案例"><a href="#AWS-Managed-Services及其使用案例" class="headerlink" title="AWS Managed Services及其使用案例"></a>AWS Managed Services及其使用案例</h4><p>AWS Managed Services提供了许多托管服务，如Amazon Comprehend（一种自然语言处理服务）和Amazon Polly（一个文本转语音服务）。这些服务简化了管理任务，并提高了可用性。例如，使用Amazon Polly，你可以轻松将文本转换为语音输出，而无需深入了解语音合成技术。</p><h4 id="基本联网概念"><a href="#基本联网概念" class="headerlink" title="基本联网概念"></a>基本联网概念</h4><p>联网概念包括路由表、子网和网络ACLs等。路由表定义了网络流量如何从一个子网转移到另一个子网或外部网络。在AWS中，你可以设置路由表来指导网络流量的流向，以确保高效和安全的数据传输。</p><h4 id="灾难恢复策略"><a href="#灾难恢复策略" class="headerlink" title="灾难恢复策略"></a>灾难恢复策略</h4><p>灾难恢复策略包括备份和还原、长明灯（持续运行的最小资源）、热备用、双活故障转移等。这些策略通过定义RPO（恢复点目标）和RTO（恢复时间目标）来确保在发生灾难时数据和应用程序的快速恢复。例如，使用AWS的备份服务可以定期备份关键数据，以便在需要时迅速恢复。</p><h4 id="分布式设计模式"><a href="#分布式设计模式" class="headerlink" title="分布式设计模式"></a>分布式设计模式</h4><p>分布式设计模式涉及在多个服务器、区域或可用区中分布应用程序和数据，以提高可靠性和可用性。例如，可以在不同的AWS区域部署应用程序的副本，以防某个区域出现故障。</p><h4 id="故障转移策略"><a href="#故障转移策略" class="headerlink" title="故障转移策略"></a>故障转移策略</h4><p>故障转移策略包括自动检测故障并将流量重定向到健康的服务器或区域。例如，Amazon RDS的多可用区部署可以在主数据库故障时自动故障转移到备用数据库。</p><h4 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h4><p>不可变基础设施意味着一旦创建，资源（如服务器）就不会被更改。相反，任何更新都通过替换现有资源来实现。这减少了配置漂移和相关故障的可能性。</p><h4 id="负载均衡概念"><a href="#负载均衡概念" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h4><p>负载均衡器（如Application Load Balancer）可以在多个服务器之间分配流量，以优化性能和可用性。例如，如果一个服务器过载，负载均衡器可以将流量转移到其他较少负载的服务器。</p><h4 id="代理概念"><a href="#代理概念" class="headerlink" title="代理概念"></a>代理概念</h4><p>代理（如Amazon RDS Proxy）是一种数据库代理服务，它可以帮助管理数据库连接，提高可扩展性和可用性。它作为应用程序和数据库之间的中间层，优化连接。</p><h4 id="Service-Quotas和限流"><a href="#Service-Quotas和限流" class="headerlink" title="Service Quotas和限流"></a>Service Quotas和限流</h4><p>Service Quotas是AWS服务的使用限额。在设计容错架构时，重要的是要了解这些限额并相应地配置备用环境。限流可以帮助管理资源使用，防止系统过载。</p><h4 id="存储选项和特性"><a href="#存储选项和特性" class="headerlink" title="存储选项和特性"></a>存储选项和特性</h4><p>AWS提供多种存储选项，如EBS、S3和Glacier，每种都有不同的特</p><p>性，如持久性和复制。选择正确的存储解决方案对于确保数据的可用性和持久性至关重要。</p><h4 id="工作负载可见性"><a href="#工作负载可见性" class="headerlink" title="工作负载可见性"></a>工作负载可见性</h4><p>工具如AWS X-Ray可以提供工作负载的可见性，帮助识别和排除性能问题。它允许你跟踪请求在分布式系统中的路径，并识别瓶颈。</p><p>以上各点是设计高可用性和/或容错架构时需要掌握的关键知识点。每个点都是构建强大、可靠云基础设施的基石。</p><h2 id="确定高性能和-或可扩展的存储解决方案"><a href="#确定高性能和-或可扩展的存储解决方案" class="headerlink" title="确定高性能和/或可扩展的存储解决方案"></a>确定高性能和/或可扩展的存储解决方案</h2><h4 id="可满足业务要求的混合存储解决方案"><a href="#可满足业务要求的混合存储解决方案" class="headerlink" title="可满足业务要求的混合存储解决方案"></a>可满足业务要求的混合存储解决方案</h4><p>混合存储解决方案结合了本地存储和云存储的优势，以满足不同业务需求。例如，一个公司可能使用本地存储处理高速、低延迟的任务，同时使用云存储进行数据备份和灾难恢复。</p><ul><li><strong>本地存储</strong>: 快速访问，适用于处理大量实时数据。</li><li><strong>云存储</strong>: 可扩展性强，适合长期数据存储、共享和远程访问。</li></ul><p>案例：一个视频编辑公司可能在本地服务器上存储当前正在编辑的视频，以利用高速访问；同时，将已完成的项目存储在云中，以节省本地存储空间和便于客户访问。</p><h4 id="具有合适使用案例的存储服务"><a href="#具有合适使用案例的存储服务" class="headerlink" title="具有合适使用案例的存储服务"></a>具有合适使用案例的存储服务</h4><ul><li><strong>Amazon S3</strong>: 一种对象存储服务，适用于存储大量非结构化数据。例如，可以用于存储网站的静态文件、备份数据或大数据分析。</li><li><strong>Amazon Elastic File System (EFS)</strong>: 提供简单、可扩展的文件存储。适用于需要共享文件系统的应用，如内容管理系统或数据分析应用。</li><li><strong>Amazon Elastic Block Store (EBS)</strong>: 提供块存储，适用于需要持久化存储的情况，如数据库或企业级应用。</li></ul><p>案例：如果需要存储网站图像和视频，Amazon S3是理想选择；如果需要运行需要高吞吐量共享文件系统的应用，可以选择EFS；对于运行数据库，EBS更合适。</p><h4 id="具有相关特性的存储类型"><a href="#具有相关特性的存储类型" class="headerlink" title="具有相关特性的存储类型"></a>具有相关特性的存储类型</h4><ul><li><strong>对象存储</strong>: 如Amazon S3，适合存储非结构化数据。特点是可扩展性高，成本效益好。</li><li><strong>文件存储</strong>: 如Amazon EFS，适合需要共享访问的场景。</li><li><strong>数据块存储</strong>: 如Amazon EBS，适合需要高性能、低延迟的应用，如数据库。</li></ul><p>案例：一个电子健康记录系统可能使用文件存储来存储和共享病历，同时使用数据块存储来支持其数据库。</p><h4 id="技能一：确定可满足性能要求的存储服务和配置"><a href="#技能一：确定可满足性能要求的存储服务和配置" class="headerlink" title="技能一：确定可满足性能要求的存储服务和配置"></a>技能一：确定可满足性能要求的存储服务和配置</h4><p>分析业务需求，确定数据访问模式、吞吐量需求和延迟敏感度。例如，对于高频读写的数据库，需要选择低延迟、高吞吐量的存储解决方案，如Amazon EBS的高性能配置。</p><p>案例：一家金融服务公司可能需要使用高性能的EBS配置来支持其高速交易系统。</p><h4 id="技能二：确定可扩展以适应未来需求的存储服务"><a href="#技能二：确定可扩展以适应未来需求的存储服务" class="headerlink" title="技能二：确定可扩展以适应未来需求的存储服务"></a>技能二：确定可扩展以适应未来需求的存储服务</h4><p>评估业务增长和数据增长预期，选择可扩展性强的存储解决方案。例如，Amazon S3在对象存储方面提供几乎无限的扩展性，适合长期数据增长。</p><p>案例：随着用户基数的增长，一款社交媒体应用可能需要不断扩大其存储容量，因此选择S3作为其图片和视频存储的理想选择。<br>确定高性能数据库解决方案时，需要考虑多个方面。我将逐一讲解以下知识点，并尽量使用通俗易懂的例子来阐述。</p><h2 id="确定高性能数据库解决方案。"><a href="#确定高性能数据库解决方案。" class="headerlink" title="确定高性能数据库解决方案。"></a>确定高性能数据库解决方案。</h2><h3 id="AWS-全球基础设施"><a href="#AWS-全球基础设施" class="headerlink" title="AWS 全球基础设施"></a>AWS 全球基础设施</h3><p>AWS（亚马逊网络服务）提供了一个全球性的基础设施，包括多个地理位置分布的区域和可用区。每个AWS区域是一个独立的地理区域，每个区域内又包含多个物理上分离的、冗余连接的数据中心，这些被称为可用区。例如，如果您的用户主要在中国，选择靠近中国的亚马逊数据中心可以减少延迟，提高服务的响应速度。</p><h3 id="缓存策略和服务"><a href="#缓存策略和服务" class="headerlink" title="缓存策略和服务"></a>缓存策略和服务</h3><p>Amazon ElastiCache 是一个广泛使用的缓存服务，它支持常见的缓存策略，如Redis和Memcached。通过使用ElastiCache，可以将频繁访问的数据存储在内存中，从而快速响应读取请求，减轻数据库的负担。例如，一个电商网站可以将热销商品的信息存储在ElastiCache中，以便快速响应用户的查询请求。</p><h3 id="数据访问模式"><a href="#数据访问模式" class="headerlink" title="数据访问模式"></a>数据访问模式</h3><p>数据访问模式主要分为读取密集型和写入密集型。读取密集型的应用，如新闻网站，主要面向大量的读取操作，而写入密集型的应用，如社交媒体的评论系统，则面临着大量的数据写入操作。根据应用的访问模式，选择合适的数据库类型和配置是非常重要的。</p><h3 id="数据库容量规划"><a href="#数据库容量规划" class="headerlink" title="数据库容量规划"></a>数据库容量规划</h3><p>数据库容量规划包括容量单位、实例类型和预置IOPS（输入/输出操作每秒）。这需要根据应用程序的需求来定制，例如一个需要处理大量事务的金融系统可能需要高IOPS的数据库配置。预置IOPS是一种性能模式，它可以保证在高负载下提供一致的I/O性能。</p><h3 id="数据库连接和代理"><a href="#数据库连接和代理" class="headerlink" title="数据库连接和代理"></a>数据库连接和代理</h3><p>数据库连接管理是数据库性能的关键因素之一。过多的数据库连接会消耗大量资源，而连接池技术可以有效地管理这些连接。数据库代理如Amazon RDS Proxy可以帮助管理和缩放数据库连接，提高应用程序的可扩展性和弹性。</p><h3 id="数据库引擎的适用案例"><a href="#数据库引擎的适用案例" class="headerlink" title="数据库引擎的适用案例"></a>数据库引擎的适用案例</h3><p>不同的数据库引擎适合不同的使用场景。例如，对于需要高度可靠性和一致性的银行系统，适合使用传统的关系型数据库，如MySQL或PostgreSQL。对于需要高速数据分析和实时处理的大数据应用，非关系型数据库如Amazon DynamoDB可能更合适。</p><h3 id="数据库复制"><a href="#数据库复制" class="headerlink" title="数据库复制"></a>数据库复制</h3><p>数据库复制是指在多个数据库之间同步数据，以提高数据的可用性和灾难恢复能力。例如，只读副本可以用于负载均衡和备份，如果主数据库发生故障，可以快速切换到副本上继续提供服务。</p><h3 id="数据库类型和服务"><a href="#数据库类型和服务" class="headerlink" title="数据库类型和服务"></a>数据库类型和服务</h3><p>数据库可以分为关系型和非关系型两大类。关系型数据库，如MySQL，适合于结构化数据和复杂查询；而非关系型数据库，如MongoDB，适合于非结构化数据和快速的读写操作。无服务器的关系数据库（如Amazon Aurora Serverless）和内存中的非关系数据库（如Redis）提供了不同的性能和扩展性选项，适合于不同的应用场景。</p><p>确定高性能和可扩展的网络架构，以及掌握相关知识点，是确保网络系统可靠、高效的关键。以下是对您提到的各个知识点的详细解释：</p><h2 id="确定高性能的数据摄取和转换解决方案。"><a href="#确定高性能的数据摄取和转换解决方案。" class="headerlink" title="确定高性能的数据摄取和转换解决方案。"></a>确定高性能的数据摄取和转换解决方案。</h2><h3 id="边缘联网服务及其使用案例"><a href="#边缘联网服务及其使用案例" class="headerlink" title="边缘联网服务及其使用案例"></a>边缘联网服务及其使用案例</h3><p>边缘联网服务允许数据更靠近用户处理，从而减少延迟和提高性能。例如，Amazon CloudFront 是一个内容分发网络（CDN）服务，它缓存数据至全球分布的节点，使得用户可以快速访问数据。AWS Global Accelerator 则通过优化路径，加速用户到 AWS 应用程序的访问。</p><p><strong>举例：</strong><br>一个视频流媒体公司使用 Amazon CloudFront 来分发内容。当用户请求视频时，他们会从最近的边缘位置获取数据，而不是从远端的数据中心，从而减少了加载时间。</p><h3 id="设计网络架构"><a href="#设计网络架构" class="headerlink" title="设计网络架构"></a>设计网络架构</h3><p>网络架构设计是指定义网络的结构和组件，如子网、路由和IP地址等。合理设计可以提高网络的安全性、可扩展性和性能。</p><p><strong>举例：</strong><br>在AWS中，您可以创建多个子网，将网络划分为不同的部分，每部分可以有不同的安全级别和路由策略。例如，公共子网可用于托管需要外部访问的资源，如Web服务器，而私有子网则用于数据库。</p><h3 id="负载均衡概念-1"><a href="#负载均衡概念-1" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h3><p>负载均衡是一种技术，用于在多个服务器之间分配网络或应用程序流量。Application Load Balancer (ALB) 是 AWS 提供的一种负载均衡器，专门用于HTTP和HTTPS流量，它可以根据请求内容将流量路由至不同的后端。</p><p><strong>举例：</strong><br>一个网站可以使用 ALB 来分配流量至多个服务器，确保没有单一服务器过载。ALB 可以根据用户请求的URL或请求头来决定将流量路由至哪个服务器。</p><h3 id="网络连接选项"><a href="#网络连接选项" class="headerlink" title="网络连接选项"></a>网络连接选项</h3><p>AWS 提供多种网络连接选项，包括 VPN、Direct Connect 和 AWS PrivateLink，以适应不同的连接需求。</p><ul><li><strong>AWS VPN</strong> 允许您安全地连接您的本地网络到 AWS。</li><li><strong>Direct Connect</strong> 提供了一种私有的、高速的网络连接，直接连接您的数据中心和 AWS。</li><li><strong>AWS PrivateLink</strong> 提供了一种安全的连接方式，允许您通过私有网络访问 AWS 服务。</li></ul><p><strong>举例：</strong><br>企业可以使用 AWS Direct Connect 在其数据中心和 AWS 之间建立专用网络连接，以提高网络传输速度并降低网络成本。</p><h3 id="确定高性能的数据摄取和转换解决方案"><a href="#确定高性能的数据摄取和转换解决方案" class="headerlink" title="确定高性能的数据摄取和转换解决方案"></a>确定高性能的数据摄取和转换解决方案</h3><h4 id="数据分析和可视化服务"><a href="#数据分析和可视化服务" class="headerlink" title="数据分析和可视化服务"></a>数据分析和可视化服务</h4><h5 id="示例：Amazon-Athena-和-AWS-Lake-Formation"><a href="#示例：Amazon-Athena-和-AWS-Lake-Formation" class="headerlink" title="示例：Amazon Athena 和 AWS Lake Formation"></a>示例：Amazon Athena 和 AWS Lake Formation</h5><ul><li><strong>Amazon Athena</strong> 是一种基于 SQL 的服务，允许用户直接在 Amazon S3 上分析数据。适用场景包括对大量未处理的日志文件进行即席查询和分析。</li><li><strong>AWS Lake Formation</strong> 用于构建、保护和管理数据湖。它简化了数据收集、存储、清洁和安全控制的过程。例如，企业可以使用 Lake Formation 快速设置数据湖，集成各种数据源。</li></ul><h4 id="数据摄取模式"><a href="#数据摄取模式" class="headerlink" title="数据摄取模式"></a>数据摄取模式</h4><h5 id="示例：频率"><a href="#示例：频率" class="headerlink" title="示例：频率"></a>示例：频率</h5><ul><li><strong>频率</strong> 指数据摄取发生的频繁程度，比如实时、每日或每周。例如，一个电子商务网站可能会实时摄取交易数据，而一个月度财务报告可能只需要每月摄取数据。</li></ul><h4 id="数据传输服务"><a href="#数据传输服务" class="headerlink" title="数据传输服务"></a>数据传输服务</h4><h5 id="示例：AWS-DataSync-和-AWS-Storage-Gateway"><a href="#示例：AWS-DataSync-和-AWS-Storage-Gateway" class="headerlink" title="示例：AWS DataSync 和 AWS Storage Gateway"></a>示例：AWS DataSync 和 AWS Storage Gateway</h5><ul><li><strong>AWS DataSync</strong> 可用于快速、简单、安全地移动大量数据。适合于将本地数据迁移到 AWS 或在 AWS 服务之间同步数据。</li><li><strong>AWS Storage Gateway</strong> 是一种混合存储服务，允许本地环境与 AWS 云存储服务无缝集成。适用于需要定期备份本地数据到云的场景。</li></ul><h4 id="数据转换服务"><a href="#数据转换服务" class="headerlink" title="数据转换服务"></a>数据转换服务</h4><h5 id="示例：AWS-Glue"><a href="#示例：AWS-Glue" class="headerlink" title="示例：AWS Glue"></a>示例：AWS Glue</h5><ul><li><strong>AWS Glue</strong> 是一种完全托管的 ETL (提取、转换、加载) 服务。例如，可以使用 AWS Glue 自动化地将来自不同源的数据格式化、清洁，并准备用于分析。</li></ul><h4 id="对摄取接入点的安全访问"><a href="#对摄取接入点的安全访问" class="headerlink" title="对摄取接入点的安全访问"></a>对摄取接入点的安全访问</h4><ul><li>确保数据在摄取过程中的安全性至关重要。例如，使用加密和身份验证机制来保护数据的完整性和机密性。</li></ul><h4 id="满足业务要求所需的规模和速度"><a href="#满足业务要求所需的规模和速度" class="headerlink" title="满足业务要求所需的规模和速度"></a>满足业务要求所需的规模和速度</h4><ul><li>根据业务需求选择合适的数据处理能力和传输速度。例如，处理大量实时数据流可能需要更高的处理速度和计算资源。</li></ul><h4 id="流式传输数据服务"><a href="#流式传输数据服务" class="headerlink" title="流式传输数据服务"></a>流式传输数据服务</h4><h5 id="示例：Amazon-Kinesis"><a href="#示例：Amazon-Kinesis" class="headerlink" title="示例：Amazon Kinesis"></a>示例：Amazon Kinesis</h5><ul><li><strong>Amazon Kinesis</strong> 提供实时数据处理能力。适用于需要实时监控和分析的场景，如社交媒体数据流或实时游戏数据分析。</li></ul><p>以上每个服务和概念都是构建高性能数据摄取和转换解决方案的重要部分。通过理解这些服务的适用场景和特点，可以更好地设计和实施数据处理策略，以满足特定业务需求。</p><h2 id="设计成本优化型存储解决方案"><a href="#设计成本优化型存储解决方案" class="headerlink" title="设计成本优化型存储解决方案"></a>设计成本优化型存储解决方案</h2><h4 id="访问选项"><a href="#访问选项" class="headerlink" title="访问选项"></a>访问选项</h4><h5 id="示例：S3-存储桶的申请方付款"><a href="#示例：S3-存储桶的申请方付款" class="headerlink" title="示例：S3 存储桶的申请方付款"></a>示例：S3 存储桶的申请方付款</h5><ul><li>在 Amazon S3 中，可以配置存储桶以启用“申请方付款”模式。这意味着数据访问费用由访问者承担，而不是存储桶的拥有者。适用于公共数据集的共享场景。</li></ul><h4 id="AWS-成本管理服务功能"><a href="#AWS-成本管理服务功能" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><h5 id="示例：成本分配标签和多账户账单"><a href="#示例：成本分配标签和多账户账单" class="headerlink" title="示例：成本分配标签和多账户账单"></a>示例：成本分配标签和多账户账单</h5><ul><li><strong>成本分配标签</strong> 允许用户按项目、部门等对 AWS 资源的成本进行分类和跟踪。</li><li><strong>多账户账单</strong> 功能使组织能够将多个 AWS 账户的成本和使用情况集中到一个账单中，简化财务管理。</li></ul><h4 id="AWS-成本管理工具"><a href="#AWS-成本管理工具" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><h5 id="示例：AWS-Cost-Explorer、AWS-Budgets"><a href="#示例：AWS-Cost-Explorer、AWS-Budgets" class="headerlink" title="示例：AWS Cost Explorer、AWS Budgets"></a>示例：AWS Cost Explorer、AWS Budgets</h5><ul><li><strong>AWS Cost Explorer</strong> 用于分析和可视化 AWS 花费和使用情况数据。</li><li><strong>AWS Budgets</strong> 允许用户设置预算，以监控服务的使用情况和成本。</li></ul><h4 id="AWS-存储服务"><a href="#AWS-存储服务" class="headerlink" title="AWS 存储服务"></a>AWS 存储服务</h4><h5 id="示例：Amazon-FSx、Amazon-EFS、Amazon-S3、Amazon-EBS"><a href="#示例：Amazon-FSx、Amazon-EFS、Amazon-S3、Amazon-EBS" class="headerlink" title="示例：Amazon FSx、Amazon EFS、Amazon S3、Amazon EBS"></a>示例：Amazon FSx、Amazon EFS、Amazon S3、Amazon EBS</h5><ul><li><strong>Amazon FSx</strong> 提供完全托管的 Windows 文件服务器。</li><li><strong>Amazon EFS</strong> 为 Linux 实例提供简单、可扩展的文件存储。</li><li><strong>Amazon S3</strong> 是高度可扩展的对象存储服务。</li><li><strong>Amazon EBS</strong> 提供块存储卷，用于与 EC2 实例一起使用。</li></ul><h4 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h4><ul><li>定期备份数据，确保在灾难发生时可恢复。可利用 AWS Backup 等服务自动化此过程。</li></ul><h4 id="数据块存储选项"><a href="#数据块存储选项" class="headerlink" title="数据块存储选项"></a>数据块存储选项</h4><h5 id="示例：HDD-卷类型和-SSD-卷类型"><a href="#示例：HDD-卷类型和-SSD-卷类型" class="headerlink" title="示例：HDD 卷类型和 SSD 卷类型"></a>示例：HDD 卷类型和 SSD 卷类型</h5><ul><li><strong>HDD 卷类型</strong> 适用于频繁访问不太集中的数据。</li><li><strong>SSD 卷类型</strong> 适合于高吞吐量和低延迟的需求。</li></ul><h4 id="数据生命周期"><a href="#数据生命周期" class="headerlink" title="数据生命周期"></a>数据生命周期</h4><ul><li>使用数据生命周期管理策略自动将老旧数据转移到更经济的存储类别。</li></ul><h4 id="混合存储选项"><a href="#混合存储选项" class="headerlink" title="混合存储选项"></a>混合存储选项</h4><h5 id="示例：DataSync、Transfer-Family、Storage-Gateway"><a href="#示例：DataSync、Transfer-Family、Storage-Gateway" class="headerlink" title="示例：DataSync、Transfer Family、Storage Gateway"></a>示例：DataSync、Transfer Family、Storage Gateway</h5><ul><li><strong>DataSync</strong> 自动化数据转移。</li><li><strong>Transfer Family</strong> 管理文件传输。</li><li><strong>Storage Gateway</strong> 连接本地和云存储。</li></ul><h4 id="存储访问模式"><a href="#存储访问模式" class="headerlink" title="存储访问模式"></a>存储访问模式</h4><ul><li>分析数据的访问模式，选择最适合的存储类型，如频繁访问或偶尔访问。</li></ul><h4 id="存储分层"><a href="#存储分层" class="headerlink" title="存储分层"></a>存储分层</h4><h5 id="示例：对象存储的冷分层"><a href="#示例：对象存储的冷分层" class="headerlink" title="示例：对象存储的冷分层"></a>示例：对象存储的冷分层</h5><ul><li>对象存储的冷分层适用于不常访问的数据，比如 Amazon S3 的 Glacier。</li></ul><h4 id="存储类型的相关特性"><a href="#存储类型的相关特性" class="headerlink" title="存储类型的相关特性"></a>存储类型的相关特性</h4><h5 id="示例：对象、文件、数据块存储"><a href="#示例：对象、文件、数据块存储" class="headerlink" title="示例：对象、文件、数据块存储"></a>示例：对象、文件、数据块存储</h5><ul><li><strong>对象存储</strong>：适用于大量非结构化数据。</li><li><strong>文件存储</strong>：适用于需要共享文件系统的场景。</li><li><strong>数据块存储</strong>：适用于数据库和其他需要持久存储的应用。</li></ul><h2 id="设计成本优化型计算解决方案"><a href="#设计成本优化型计算解决方案" class="headerlink" title="设计成本优化型计算解决方案"></a>设计成本优化型计算解决方案</h2><p>当设计成本优化型计算解决方案时，需要考虑多个方面，包括AWS成本管理服务、全球基础设施、购买选项、计算策略等。以下是这些主要知识点的详细解释和实例。</p><h4 id="AWS-成本管理服务功能-1"><a href="#AWS-成本管理服务功能-1" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><ul><li><strong>成本分配标签</strong>：允许你标记AWS资源，以便跟踪成本。例如，你可以为不同的部门或项目标记不同的资源，从而更容易地追踪和管理这些成本。</li><li><strong>多账户账单</strong>：如果你管理多个AWS账户，这个功能可以帮助你集中查看和管理这些账户的费用。它能够让你从总体上把握成本，便于进行成本优化。</li></ul><h4 id="具有合适使用案例的-AWS-成本管理工具"><a href="#具有合适使用案例的-AWS-成本管理工具" class="headerlink" title="具有合适使用案例的 AWS 成本管理工具"></a>具有合适使用案例的 AWS 成本管理工具</h4><ul><li><strong>Cost Explorer</strong>：用于可视化和理解AWS花费和使用情况。例如，你可以使用它来查看过去几个月的消费趋势，预测未来的费用。</li><li><strong>AWS Budgets</strong>：允许你设定预算和警报，以便在费用或使用量超出预设的阈值时收到通知。</li><li><strong>AWS 成本和使用情况报告</strong>：提供详细的成本和使用数据，方便你深入分析成本。</li></ul><h4 id="AWS-全球基础设施-1"><a href="#AWS-全球基础设施-1" class="headerlink" title="AWS 全球基础设施"></a>AWS 全球基础设施</h4><ul><li><strong>可用区</strong>：AWS在特定区域内的多个独立数据中心。通过在不同的可用区部署应用，可以提高可靠性和可用性。</li><li><strong>AWS 区域</strong>：AWS全球的地理区域，每个区域包含多个可用区。选择距离用户较近的区域可以减少延迟，可能还能降低数据传输费用。</li></ul><h4 id="AWS-购买选项"><a href="#AWS-购买选项" class="headerlink" title="AWS 购买选项"></a>AWS 购买选项</h4><ul><li><strong>Spot 实例</strong>：以市场定价购买的实例，适合于可以容忍中断的灵活和非关键任务。通常比按需实例便宜很多。</li><li><strong>预留实例</strong>：提前预订的实例，适合长期稳定的需求，价格低于按需实例。</li><li><strong>Savings Plans</strong>：为一致的使用量提供更低的价格，适用于长期稳定的使用。</li></ul><h4 id="分布式计算策略"><a href="#分布式计算策略" class="headerlink" title="分布式计算策略"></a>分布式计算策略</h4><ul><li><strong>边缘处理</strong>：在离数据来源更近的地方进行数据处理，如使用AWS Lambda@Edge在边缘位置运行代码，减少延迟，优化性能。</li></ul><h4 id="混合计算选项"><a href="#混合计算选项" class="headerlink" title="混合计算选项"></a>混合计算选项</h4><ul><li><strong>AWS Outposts</strong>：将AWS服务、基础设施和操作模型带到几乎任何数据中心、共同位置空间或云环境。</li><li><strong>AWS Snowball Edge</strong>：物理设备，用于数据传输和边缘计算，适合大量数据迁移和离线处理。</li></ul><h4 id="实例类型、系列和大小"><a href="#实例类型、系列和大小" class="headerlink" title="实例类型、系列和大小"></a>实例类型、系列和大小</h4><ul><li><strong>内存优化型</strong>：适合内存密集型应用，如大型数据库。</li><li><strong>计算优化型</strong>：适合计算密集型任务，如高性能计算。</li><li><strong>虚拟化</strong>：提供虚拟服务器，适合多种用途。</li></ul><h4 id="优化计算利用率"><a href="#优化计算利用率" class="headerlink" title="优化计算利用率"></a>优化计算利用率</h4><ul><li><strong>容器</strong>：通过容器技术（如Docker），可以更高效地使用资源，提高应用的部署速度和可移植性。</li><li><strong>无服务器计算</strong>：如AWS Lambda，按需自动扩展，只为实际使用的资源付费。</li><li><strong>微服务</strong>：将应用拆分为小型、独立的服务，可以独立</li></ul><h2 id="设计成本优化型数据库解决方案"><a href="#设计成本优化型数据库解决方案" class="headerlink" title="设计成本优化型数据库解决方案"></a>设计成本优化型数据库解决方案</h2><p>在设计成本优化型数据库解决方案时，考虑以下关键知识点非常重要：</p><h4 id="AWS-成本管理服务功能-2"><a href="#AWS-成本管理服务功能-2" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><p>AWS 提供多种成本管理工具，帮助您理解、控制和优化 AWS 资源的成本。</p><ul><li><strong>成本分配标签</strong>：允许您将自定义标签分配给 AWS 资源，以便对成本进行更详细的跟踪。例如，您可以为不同的部门或项目分配标签，以跟踪每个部门或项目的资源使用情况和成本。</li><li><strong>多账户账单</strong>：如果您有多个 AWS 账户，可以使用此功能来合并账单。这有助于简化账单管理并获得整体成本视图。</li></ul><h4 id="AWS-成本管理工具-1"><a href="#AWS-成本管理工具-1" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><ul><li><strong>Cost Explorer</strong>：一个强大的工具，用于可视化和分析您的 AWS 贴费数据。您可以查看历史数据，预测未来开支，以及识别成本趋势。</li><li><strong>AWS Budgets</strong>：允许您设置预算以控制成本。您可以为 AWS 成本、使用量、保留实例覆盖率等设置预算。</li><li><strong>AWS 成本和使用情况报告</strong>：提供详细的成本和使用数据报告，支持将数据导出到 Amazon S3，方便进行深入分析。</li></ul><h4 id="缓存策略-2"><a href="#缓存策略-2" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>缓存可以显著减少数据库的负载，降低成本。例如，使用 Amazon ElastiCache 来缓存常用数据，减少对数据库的直接访问次数。</p><h4 id="数据留存策略"><a href="#数据留存策略" class="headerlink" title="数据留存策略"></a>数据留存策略</h4><p>合理的数据留存策略可以减少不必要的存储成本。例如，使用 Amazon S3 的生命周期策略自动转移或删除旧数据。</p><h4 id="数据库容量规划-1"><a href="#数据库容量规划-1" class="headerlink" title="数据库容量规划"></a>数据库容量规划</h4><ul><li><strong>容量单位</strong>：合理规划数据库容量可以避免资源浪费。例如，根据业务需求选择合适的 Amazon RDS 实例类型和大小。</li></ul><h4 id="数据库连接和代理-1"><a href="#数据库连接和代理-1" class="headerlink" title="数据库连接和代理"></a>数据库连接和代理</h4><ul><li>使用 Amazon RDS Proxy 可以有效管理数据库连接，减少不必要的资源开销。</li></ul><h4 id="数据库引擎的合适使用案例"><a href="#数据库引擎的合适使用案例" class="headerlink" title="数据库引擎的合适使用案例"></a>数据库引擎的合适使用案例</h4><ul><li><strong>异构迁移</strong>：例如，从 Oracle 迁移到 Amazon Aurora。</li><li><strong>同构迁移</strong>：例如，从一个 MySQL 数据库迁移到另一个 MySQL 数据库。</li></ul><h4 id="数据库复制-1"><a href="#数据库复制-1" class="headerlink" title="数据库复制"></a>数据库复制</h4><ul><li><strong>只读副本</strong>：例如，使用 Amazon RDS for MySQL 的只读副本来分担读取负载，从而提高性能和可靠性。</li></ul><h4 id="数据库类型和服务-1"><a href="#数据库类型和服务-1" class="headerlink" title="数据库类型和服务"></a>数据库类型和服务</h4><ul><li><strong>关系数据库与非关系数据库</strong>：选择适合您数据模式的数据库类型。例如，结构化数据使用 Amazon RDS，非结构化数据使用 Amazon DynamoDB。</li><li><strong>Aurora 与 DynamoDB 的比较</strong>：Aurora 适用于需要高性能事务处理的场景，而 DynamoDB 适用于需要高度可扩展、低延迟的 NoSQL 解决方案。</li></ul><h3 id="设计成本优化型网络架构"><a href="#设计成本优化型网络架构" class="headerlink" title="设计成本优化型网络架构"></a>设计成本优化型网络架构</h3><h4 id="AWS-成本管理服务功能-3"><a href="#AWS-成本管理服务功能-3" class="headerlink" title="AWS 成本管理服务功能"></a>AWS 成本管理服务功能</h4><p>AWS成本管理服务提供了多种工具和功能，帮助用户监控、管理和优化他们在AWS上的支出和使用情况。这包括：</p><ul><li><p><strong>成本分配标签</strong>：它们允许用户通过添加标签来组织资源，以便更容易地追踪成本和使用情况。例如，你可以为不同的项目或部门设置标签，以便更容易地分配成本。</p></li><li><p><strong>多账户账单</strong>：对于拥有多个AWS账户的组织来说，多账户账单功能可以帮助它们更好地理解和管理各个账户的开销。</p></li></ul><h4 id="AWS-成本管理工具-2"><a href="#AWS-成本管理工具-2" class="headerlink" title="AWS 成本管理工具"></a>AWS 成本管理工具</h4><ul><li><p><strong>Cost Explorer</strong>：这是一个可视化工具，用户可以通过它查看和分析他们的AWS成本和使用情况数据。例如，你可以使用Cost Explorer来查看过去几个月的支出趋势，或者分析特定服务的成本。</p></li><li><p><strong>AWS Budgets</strong>：这个工具允许用户设置预算并接收警报，以便在成本或使用量超出预定阈值时得到通知。</p></li><li><p><strong>AWS 成本和使用情况报告</strong>：这是一种更高级的工具，它提供关于AWS使用情况和成本的详细报告。用户可以用它来进行深入的成本分析。</p></li></ul><h4 id="负载均衡概念-2"><a href="#负载均衡概念-2" class="headerlink" title="负载均衡概念"></a>负载均衡概念</h4><ul><li><strong>Application Load Balancer</strong>：这是一种用于分配进入应用程序的流量的负载均衡器。例如，如果你有一个高流量的网站，使用Application Load Balancer可以帮助分散流量，提高应用程序的可用性和效率。</li></ul><h4 id="NAT-网关"><a href="#NAT-网关" class="headerlink" title="NAT 网关"></a>NAT 网关</h4><ul><li><strong>NAT实例与NAT网关成本比较</strong>：NAT实例是一种基于EC2的解决方案，而NAT网关是AWS提供的托管服务。通常，NAT网关比NAT实例更易于管理且可扩展性更好，但可能在某些情况下成本更高。</li></ul><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><ul><li><strong>私有线路、专用线路、VPN</strong>：这些都是连接到AWS的不同方法。私有线路（如AWS Direct Connect）提供了一种直接连接到AWS的方式，可以降低网络成本，提高带宽效率。专用线路适用于需要高安全性的连接。VPN提供了一种通过互联网安全连接到AWS的方式。</li></ul><h4 id="网络路由、拓扑和对等连接"><a href="#网络路由、拓扑和对等连接" class="headerlink" title="网络路由、拓扑和对等连接"></a>网络路由、拓扑和对等连接</h4><ul><li><strong>AWS Transit Gateway和VPC对等连接</strong>：这些服务允许不同的VPC之间以及VPC和本地网络之间的通信。例如，使用Transit Gateway可以更容易地管理大规模的网络拓扑，而VPC对等连接允许两个VPC之间直接通信。</li></ul><h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><ul><li><strong>DNS</strong>：域名系统（DNS）是网络上的一项关键服务，用于将域名转换为IP地址。在AWS中，Amazon Route 53提供了强大的DNS服务，支持成本优化和高可用性。</li></ul><p>通过这些知识点的掌握，你可以更好地设计和管理一个成本效益高、性能优化的AWS网络架构。</p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Basic/Study-Note/"/>
    
    
    <category term="SAA" scheme="https://kalyan-zitiu.github.io/tags/SAA/"/>
    
  </entry>
  
  <entry>
    <title>Conspectus for SAA</title>
    <link href="https://kalyan-zitiu.github.io/2023/12/24/saa%E6%A6%82%E5%BF%B5/"/>
    <id>https://kalyan-zitiu.github.io/2023/12/24/saa%E6%A6%82%E5%BF%B5/</id>
    <published>2023-12-24T12:00:00.000Z</published>
    <updated>2024-01-07T04:56:06.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Elastic-Load-Balancing（弹性负载均衡）"><a href="#Elastic-Load-Balancing（弹性负载均衡）" class="headerlink" title="Elastic Load Balancing（弹性负载均衡）"></a>Elastic Load Balancing（弹性负载均衡）</h3><p> 是一种自动分配进入应用程序的网络流量的服务。它可以确保负载均匀分布在多个服务器上，从而提高应用程序的可用性和容错能力。Elastic Load Balancing支持三种主要类型的负载均衡器：</p><ol><li><strong>应用程序负载均衡器（Application Load Balancer）</strong>：适用于HTTP和HTTPS流量，提供高级路由功能，可以基于内容将流量路由到不同的服务。</li><li><strong>网络负载均衡器（Network Load Balancer）</strong>：适用于TCP流量，特别适合处理高性能、低延迟的网络传输。网络负载均衡器能够在数毫秒内自动响应流量变化。</li><li><strong>经典负载均衡器（Classic Load Balancer）</strong>：提供基本的负载均衡功能，适用于应用程序和网络层面的负载均衡。</li></ol><p>Elastic Load Balancing可以集成到AWS的其他服务中，如Auto Scaling（自动扩展服务），以确保应用程序在不同的负载条件下均能稳定运行。通过Elastic Load Balancing，可以自动检测不健康的实例，并将流量重新分配到健康的实例上，从而保证应用程序的高可用性。</p><h3 id="Auto-Scaling（自动扩展）"><a href="#Auto-Scaling（自动扩展）" class="headerlink" title="Auto Scaling（自动扩展）"></a>Auto Scaling（自动扩展）</h3><p>是一种云计算服务，用于自动调整计算资源的数量以满足应用程序的需求。这种服务通常与云计算平台（如AWS、Azure或Google Cloud）结合使用。Auto Scaling的主要特点和优点包括：</p><ol><li><strong>动态扩展和缩减</strong>：根据预定义的指标（如CPU使用率、网络流量或自定义指标），自动增加或减少服务器实例的数量。这确保了在需求增加时提供足够的资源，而在需求减少时减少不必要的开支。</li><li><strong>成本效益</strong>：通过仅在需要时添加资源，并在不需要时移除资源，Auto Scaling有助于优化成本，因为用户只需为实际使用的资源付费。</li><li><strong>高可用性和容错性</strong>：通过跨多个地理区域或可用区自动分配资源，Auto Scaling可以提高应用程序的可用性和抗故障能力。</li><li><strong>预测性扩展</strong>：某些自动扩展服务还提供基于预测分析的扩展，这意味着它们可以根据历史数据和趋势分析来预测需求，并相应地调整资源。</li><li><strong>与负载均衡器集成</strong>：Auto Scaling通常与负载均衡器（如Elastic Load Balancing）集成，以确保新添加的实例可以接收到流量，并且流量在所有实例之间均匀分配。</li></ol><p>Auto Scaling适用于需要根据流量或其他指标动态调整资源的应用程序，例如电子商务网站、大数据分析应用程序和在线游戏服务器。通过自动扩展，这些应用程序可以在负载高峰期间保持性能，并在低峰期间减少资源浪费。</p><h3 id="Amazon-CloudFront"><a href="#Amazon-CloudFront" class="headerlink" title="Amazon CloudFront"></a>Amazon CloudFront</h3><p>是由亚马逊网络服务（AWS）提供的内容分发网络（CDN）服务。它帮助以低延迟和高传输速度向用户提供内容，如网页、视频、图像和其他静态和动态文件。CloudFront通过在全球范围内的边缘位置缓存内容，使内容更接近最终用户，从而减少内容传输的距离和时间。</p><p>在设置和配置Amazon CloudFront时，您有几个选项和参数可以考虑。以下是一些关键设置：</p><p>源：</p><p>源类型：指定您内容的源，可以是AWS资源（例如S3存储桶、EC2实例）或自定义源（例如HTTP服务器）。<br>源协议策略：选择CloudFront与源之间通信时使用的协议，可以是HTTP或HTTPS。<br>分发设置：</p><p>价格级别：选择决定用于传送内容的边缘位置数量的价格级别（边缘位置越多，成本越高但性能更好）。<br>替代域名（CNAME）：指定要与CloudFront分发关联的任何自定义域名。<br>SSL证书：选择用于安全连接的SSL证书（您可以使用AWS证书管理器来管理SSL证书）。<br>默认根对象：定义当用户访问分发的根URL时要提供的默认文件。<br>缓存行为设置：</p><p>路径模式：定义匹配特定路径或模式的规则<br>这些只是Amazon CloudFront的一些关键设置，具体选择的设置取决于您的应用程序要求和分发的预期行为。建议查阅AWS文档以获取关于每个参数及其影响的详细信息。</p><h3 id="AWS-Glacier"><a href="#AWS-Glacier" class="headerlink" title="AWS Glacier"></a>AWS Glacier</h3><p>是亚马逊网络服务（AWS）提供的一种低成本、长期存储服务。它旨在为需要长期保存数据的场景提供可靠的、安全的存储解决方案。Glacier适用于备份、归档和长期数据保留等用途。</p><p>以下是AWS Glacier的一些关键特点和概念：</p><ol><li><p>存储类别：AWS Glacier提供了三种存储类别：标准存储（Standard）、大容量存储（Bulk）和快速存储（Expedited）。每种存储类别具有不同的定价和可用性。标准存储适用于大多数场景，而大容量存储和快速存储适用于需要快速检索数据的特定用例。</p></li><li><p>存储桶和存档：在AWS Glacier中，数据存储在称为存储桶（Vault）的容器中。每个存储桶可以包含多个存档（Archive），每个存档代表一个文件或对象。存档可以是任意大小，最大支持40TB。</p></li><li><p>数据上传和检索：您可以使用AWS Glacier提供的API或AWS管理控制台将数据上传到存储桶中。上传的数据被分割成多个部分，并进行压缩和加密，然后存储在AWS的数据中心中。对于大容量存储和快速存储，数据可以更快地检索出来。数据检索请求可以是实时的（快速存储）或延迟几个小时（大容量存储）。</p></li><li><p>数据保留和可用性：AWS Glacier被设计为长期存储解决方案，数据的可用性相对较低。数据检索请求可能需要几个小时才能完成，因此不适合需要实时访问的数据。但是，AWS Glacier提供了数据可靠性保证，并采取了多重复制和数据校验等措施来确保数据的安全性和完整性。</p></li><li><p>定价：AWS Glacier的定价基于存储的数据量、数据上传和检索的操作次数以及存储的时间长度。不同的存储类别和数据检索速度会影响定价。您可以参考AWS Glacier的定价页面或使用AWS计算器来估算使用该服务的成本。</p></li></ol><p>AWS Glacier提供了一种经济高效的长期数据存储解决方案，适用于需要将数据安全地保存多年的场景。它与其他AWS服务（如Amazon S3和Amazon Glacier Deep Archive）相互集成，为用户提供了灵活的存储和数据管理选项。</p><h3 id="AWS-Elastic-Transcoder"><a href="#AWS-Elastic-Transcoder" class="headerlink" title="AWS Elastic Transcoder"></a>AWS Elastic Transcoder</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一项云视频转码服务。它可以帮助用户将视频文件转换成不同的格式，以适应不同的设备和平台，比如移动设备、电视、互联网流媒体等等。以下是一些关于 AWS Elastic Transcoder 的关键信息：</p><ol><li><p><strong>视频转码：</strong> Elastic Transcoder 可以将输入的视频文件转码成多种输出格式，包括不同的分辨率、编码和容器格式。这有助于确保视频在不同设备上的流畅播放。</p></li><li><p><strong>自动缩放：</strong> 它能够自动调整输出视频的分辨率和比特率，以适应不同的终端设备和带宽条件。</p></li><li><p><strong>预设模板：</strong> Elastic Transcoder 提供了多种预设模板，可用于快速配置输出参数，用户可以选择适合其需求的预设，也可以自定义设置。</p></li><li><p><strong>工作流程：</strong> 用户可以创建自定义工作流程，将多个转码任务组合在一起，以实现复杂的视频处理需求。</p></li><li><p><strong>云服务：</strong> Elastic Transcoder 是一项托管的云服务，用户无需关心基础设施维护和扩展，只需支付按用量计费。</p></li><li><p><strong>集成性：</strong> 它可以与其他 AWS 服务和云存储服务（如Amazon S3）集成，使视频转码和存储变得更加简单。</p></li></ol><p>AWS Elastic Transcoder 是一个强大的工具，适用于需要处理和分发视频内容的各种应用，包括媒体流媒体、在线教育、广告等。通过使用它，您可以确保您的视频在不同的设备上以最佳质量进行播放。</p><h3 id="AWS-简单通知服务（Simple-Notification-Service，SNS）"><a href="#AWS-简单通知服务（Simple-Notification-Service，SNS）" class="headerlink" title="AWS 简单通知服务（Simple Notification Service，SNS）"></a>AWS 简单通知服务（Simple Notification Service，SNS）</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一项托管的通知服务，用于构建分布式、可扩展的应用程序和微服务架构。以下是关于 AWS SNS 的关键信息：</p><ol><li><p><strong>消息发布和订阅：</strong> SNS 允许开发人员将消息发布到主题（Topic），然后允许订阅者通过不同的通信协议接收这些消息。订阅者可以是应用程序、服务器、移动设备或终端用户。</p></li><li><p><strong>多通信协议支持：</strong> SNS 支持多种通信协议，包括电子邮件、短信、HTTP、HTTPS、Lambda、SQS（简单队列服务）等。这意味着您可以以多种方式将消息传递给订阅者，以适应不同的用例。</p></li><li><p><strong>消息筛选：</strong> SNS 支持消息筛选功能，让订阅者可以只接收与他们关心的主题相关的消息，这可以降低不必要的消息传递。</p></li><li><p><strong>可扩展性：</strong> SNS 可以轻松扩展以处理大量的消息和订阅者。它是高可用的，可以确保消息的可靠传递。</p></li><li><p><strong>事件驱动架构：</strong> SNS 可以作为事件驱动架构的一部分，将通知消息传递给触发器（例如 AWS Lambda 函数），从而实现自动化和响应式应用程序。</p></li><li><p><strong>安全性：</strong> SNS 提供身份验证和授权机制，以确保消息的安全传递，并可以与 AWS Identity and Access Management（IAM）集成，以控制对 SNS 主题的访问权限。</p></li></ol><p>AWS SNS 可以用于各种用例，包括应用程序提醒、监控和警报、社交媒体分享、移动应用程序通知等。它是构建具有高度可扩展性和弹性的分布式应用程序的有力工具，有助于将消息和通知传递到目标接收者，无论是人还是应用程序。</p><h3 id="AWS-Simple-Queue-Service（SQS）"><a href="#AWS-Simple-Queue-Service（SQS）" class="headerlink" title="AWS Simple Queue Service（SQS）"></a>AWS Simple Queue Service（SQS）</h3><p>是亚马逊网络服务（AWS）提供的一种完全托管的消息队列服务。它允许应用程序在分布式系统中进行异步通信，并解耦发送者和接收者之间的关系。SQS可用于构建可靠的、可扩展的应用程序，处理大量消息并保证消息的可靠传递。</p><p>以下是AWS Simple Queue Service的一些关键特点和概念：</p><ol><li><p>消息队列：SQS使用消息队列来存储和传递消息。消息队列是一种中间件，可以存储消息并按照先进先出（FIFO）的顺序将其传递给消费者。</p></li><li><p>队列类型：SQS提供两种类型的队列：标准队列和先进先出（FIFO）队列。标准队列提供高吞吐量和最少一次交付保证，但消息的顺序不是严格保证的。FIFO队列提供严格的消息顺序保证，但吞吐量略低。</p></li><li><p>消息传递：应用程序可以使用SQS API将消息发送到队列中，并使用API接收消息。消息可以是任意大小，最大支持256KB。发送者和接收者可以是不同的应用程序，甚至可以跨越不同的系统和云服务。</p></li><li><p>可靠性和可伸缩性：SQS提供高度可靠的消息传递，确保消息不会丢失。它还具有自动伸缩的能力，可以根据负载的变化自动调整吞吐量。</p></li><li><p>可见性超时：当消费者接收到消息后，消息将在一段时间内不可见，称为可见性超时。在此期间，消费者可以处理消息，但其他消费者无法看到该消息。如果消费者在处理消息时发生故障或未能删除消息，消息将重新变为可见状态，供其他消费者处理。</p></li><li><p>消息保留：SQS可以保留消息，即使消息被消费者接收和处理，也可以在队列中保留一段时间。这对于需要重放或重新处理消息的场景非常有用。</p></li><li><p>延迟队列：SQS还支持延迟队列，可以将消息延迟发送到队列中。这对于需要在一定时间后执行某些操作的应用程序非常有用。</p></li></ol><p>AWS Simple Queue Service提供了一种可靠、高可用的消息队列服务，适用于构建分布式系统、异步通信和处理大量消息的场景。它与其他AWS服务（如AWS Lambda、Amazon EC2和Amazon SNS）集成，提供了灵活的消息传递选项和可扩展性。</p><h3 id="DynamoDB-表（DynamoDB-table）"><a href="#DynamoDB-表（DynamoDB-table）" class="headerlink" title="DynamoDB 表（DynamoDB table）"></a>DynamoDB 表（DynamoDB table）</h3><p>是亚马逊 Web 服务（Amazon Web Services，AWS）提供的一种全托管的 NoSQL 数据库服务，用于存储和检索数据。以下是关于 DynamoDB 表的关键信息：</p><ol><li><p><strong>分布式和托管：</strong> DynamoDB 表是一种完全托管的数据库服务，它自动处理底层硬件和分布式数据库的运维工作，使开发人员可以专注于数据建模和应用程序逻辑。</p></li><li><p><strong>键值存储：</strong> DynamoDB 是一种键值存储数据库，每个表都有一个主键，可以是单一属性或组合属性。这使得数据的检索和查询非常快速。</p></li><li><p><strong>无模式和灵活：</strong> DynamoDB 是无模式的数据库，这意味着您可以在同一表中存储不同结构的数据，而不需要预定义模式。这使得 DynamoDB 适用于多样化的数据。</p></li><li><p><strong>自动缩放：</strong> DynamoDB 具有自动扩展和缩小的能力，根据负载的变化自动调整读取和写入容量单元，以确保高性能和低延迟。</p></li><li><p><strong>多区域复制：</strong> 您可以配置 DynamoDB 表以进行多区域复制，以增加数据的可用性和容错性。这使得数据在多个 AWS 区域之间进行复制和同步。</p></li><li><p><strong>安全性：</strong> DynamoDB 提供了身份和访问管理（IAM）集成，以控制对表的访问权限。您可以定义细粒度的权限策略，以确保数据的安全性。</p></li><li><p><strong>高可用性：</strong> DynamoDB 具有高可用性和持久性，保证数据的可靠性和持久性。</p></li><li><p><strong>全局二级索引：</strong> 您可以创建全局二级索引，以支持不同于主键的查询需求，这使得检索数据更加灵活。</p></li></ol><p>DynamoDB 表通常用于构建具有大规模、低延迟读取和写入需求的应用程序，如电子商务平台、游戏分数排名、用户配置文件存储等。它是一种强大的数据库服务，可以适应各种用例，并提供高度的可扩展性和性能。</p><h3 id="EBS（Elastic-Block-Store）"><a href="#EBS（Elastic-Block-Store）" class="headerlink" title="EBS（Elastic Block Store）"></a>EBS（Elastic Block Store）</h3><p>是亚马逊网络服务（AWS）提供的一种持久性块存储服务，用于在云中运行的虚拟机实例（如Amazon EC2实例）上存储数据。EBS 提供了可靠、高性能和可扩展的块级存储解决方案，允许用户创建、附加、备份和恢复数据卷。</p><p>以下是 EBS 的一些关键特点和功能：</p><ol><li><p>持久性存储：EBS 提供持久性存储，确保数据在实例终止或发生故障时不会丢失。数据存储在 EBS 卷上，并且持久保存在亚马逊的后端存储系统中。</p></li><li><p>高性能：EBS 提供低延迟和高吞吐量的性能，适用于各种工作负载，包括数据库、文件存储和应用程序数据。</p></li><li><p>可扩展性：用户可以根据需要创建和调整 EBS 卷的容量，无需中断实例。EBS 卷的大小可以从几GB到16TB不等。</p></li><li><p>快照备份：EBS 允许用户创建卷的快照备份，以便在需要时进行数据恢复或创建新的卷。快照是卷的点-in-time 副本，可以用作数据备份、复制和迁移。</p></li><li><p>多种卷类型：EBS 提供多种卷类型，以满足不同的性能和成本需求。其中包括：SSD（固态硬盘）卷类型（如 gp2、io1、io2）和 HDD（硬盘驱动器）卷类型（如 st1、sc1）。</p></li><li><p>可靠性和可用性：EBS 提供了数据冗余和故障转移功能，以确保数据的可靠性和可用性。EBS 卷的数据会在多个存储设备上进行复制，以提供高可靠性。</p></li><li><p>集成性：EBS 与其他 AWS 服务集成紧密，例如 Amazon EC2、Amazon RDS（关系型数据库服务）和 Amazon EMR（弹性 MapReduce 服务），使用户可以轻松地将 EBS 用于各种应用场景。</p></li></ol><p>通过使用 EBS，用户可以在 AWS 上创建和管理持久性存储卷，为云中的应用程序提供可靠的数据存储解决方案。EBS 提供了高性能、可扩展性和数据保护功能，使用户能够根据需要灵活地管理和使用存储资源。</p><h4 id="EBS-提供不同类型的存储选项"><a href="#EBS-提供不同类型的存储选项" class="headerlink" title="(EBS) 提供不同类型的存储选项"></a>(EBS) 提供不同类型的存储选项</h4><p>Amazon Elastic Block Store (EBS) 提供不同类型的存储选项，每种类型都针对特定的使用案例和性能需求设计。以下是四种主要类型的 EBS 卷的概述：</p><p>EBS Provisioned IOPS SSD (io1/io2): 这种类型的 EBS 卷专为 I/O 密集型的事务型工作负载设计，如数据库应用程序。它们提供高性能的 SSD 支持，并允许用户预设 IOPS（每秒输入/输出操作次数），以满足高吞吐量和低延迟的需求。对于需要持续高 IOPS 的应用，如大型关系型数据库或高频交易系统，这是理想的选择。</p><p>EBS General Purpose SSD (gp2/gp3): 这是一种通用的 SSD 卷，适用于广泛的工作负载。它们提供了良好的性能和价格比，对 IOPS 有基本的需求，但不像 io1/io2 那样高。这种卷适合用于系统引导盘、虚拟桌面环境、中小型数据库和开发/测试环境。</p><p>EBS Cold HDD (sc1): 这种硬盘驱动器 (HDD) 卷提供了较低的存储成本，并适用于低频访问的数据。它们是为需要较大存储容量但不频繁访问数据的应用程序设计的，如备份、数据仓库和冷数据存储。</p><p>EBS Throughput Optimized HDD (st1): 这是另一种 HDD 类型的卷，专为吞吐量密集型的工作负载设计，如大数据、数据仓库、日志处理和大型数据集的批量处理。st1 卷提供高吞吐量性能，适用于频繁读写的大数据集。</p><p>选择哪种类型的 EBS 卷取决于您的具体应用需求，包括性能、成本和存储容量的考虑。例如，对于高性能数据库，可能会选择 Provisioned IOPS SSD，而对于成本敏感且访问频率较低的数据存储，则可能选择 Cold HDD 或 Throughput Optimized HDD。</p><h3 id="EFS（Elastic-File-System）"><a href="#EFS（Elastic-File-System）" class="headerlink" title="EFS（Elastic File System）"></a>EFS（Elastic File System）</h3><p>是亚马逊网络服务（AWS）提供的一种托管的弹性文件存储服务，可用于在云中运行的应用程序和服务。它提供了一个简单、可扩展和高性能的文件系统，可以与多个 Amazon EC2 实例共享数据，并且可以在不同的可用区域之间复制和备份数据。</p><p>以下是 EFS 的一些关键特点和功能：</p><ol><li><p>共享文件系统：EFS 允许多个 Amazon EC2 实例同时访问和共享相同的文件系统。这使得多个实例可以同时读取和写入相同的文件，方便了分布式应用程序和共享存储需求的实现。</p></li><li><p>自动扩展：EFS 可以根据需要自动扩展存储容量和性能，无需中断实例。它可以根据文件系统的使用情况自动调整存储容量，并提供高吞吐量和低延迟的性能。</p></li><li><p>可靠性和耐用性：EFS 提供了高度可靠和耐用的文件存储解决方案。数据在多个可用区域进行复制，以提供高可用性和数据冗余。此外，EFS 还支持自动的文件系统级别的备份和恢复功能。</p></li><li><p>安全性和权限控制：EFS 提供了细粒度的权限控制，允许用户对文件和目录设置访问权限。用户可以使用 AWS Identity and Access Management（IAM）来管理对文件系统的访问，并通过文件系统级别的加密来保护数据的安全性。</p></li><li><p>高性能：EFS 提供了低延迟和高吞吐量的性能，适用于各种工作负载，包括大规模并发访问和大型文件的读写操作。</p></li><li><p>跨可用区域复制：EFS 支持在不同的 AWS 区域之间进行文件系统的复制和备份，以提供更高的可用性和灾备能力。</p></li><li><p>集成性：EFS 与其他 AWS 服务集成紧密，例如 Amazon EC2、Amazon ECS（容器服务）和 AWS Lambda（无服务器计算服务），使用户可以轻松地将 EFS 用于各种应用场景。</p></li></ol><p>通过使用 EFS，用户可以轻松地创建和管理共享的弹性文件系统，为云中的应用程序提供可靠和高性能的文件存储解决方案。EFS 提供了自动扩展、高可用性和安全性等功能，使用户能够轻松地实现多实例共享数据和分布式应用程序的需求。</p><h3 id="ElastiCache"><a href="#ElastiCache" class="headerlink" title="ElastiCache"></a>ElastiCache</h3><p> 是亚马逊网络服务（AWS）提供的一种托管的内存缓存服务，旨在提高应用程序的性能和可扩展性。它支持两种流行的开源内存缓存引擎：Redis 和 Memcached。</p><p>以下是 ElastiCache 的一些关键特点和功能：</p><ol><li><p>高性能缓存：ElastiCache 提供了快速、低延迟的内存缓存服务，可以显著提高应用程序的读取性能。通过将常用的数据存储在内存中，应用程序可以更快地检索数据，减轻后端数据库的负载。</p></li><li><p>托管服务：ElastiCache 是一种完全托管的服务，AWS 负责管理缓存集群的设置、维护和监控。这样，用户无需关心硬件和软件的细节，可以专注于应用程序的开发和性能优化。</p></li><li><p>可扩展性：ElastiCache 允许用户根据需要扩展缓存集群的规模，以适应不断增长的数据和流量。用户可以根据应用程序的需求增加或减少节点数，以实现水平扩展和高可用性。</p></li><li><p>Redis 和 Memcached 支持：ElastiCache 支持两种主流的开源内存缓存引擎：Redis 和 Memcached。用户可以根据自己的需求选择适合的引擎。Redis 提供了更丰富的功能，例如数据持久化、复制和发布/订阅，而 Memcached 则提供了简单高效的缓存功能。</p></li><li><p>自动故障转移和恢复：ElastiCache 提供自动故障转移功能，当缓存节点发生故障时，会自动将请求路由到可用节点，以保证高可用性和持续的服务。</p></li><li><p>安全性和权限控制：ElastiCache 提供了多层次的安全性和权限控制机制。用户可以使用 AWS Identity and Access Management（IAM）来管理对 ElastiCache 的访问权限，并通过网络隔离和访问控制列表（ACL）来保护缓存集群的安全性。</p></li><li><p>监控和日志记录：ElastiCache 提供了丰富的监控和日志记录功能，用户可以实时监控缓存集群的性能指标、运行状况和事件。此外，ElastiCache 还与 AWS CloudWatch 和 AWS CloudTrail 集成，以便进行更全面的监控和日志分析。</p></li></ol><p>通过使用 ElastiCache，用户可以轻松地添加和管理高性能的内存缓存层，提高应用程序的响应速度和可伸缩性。ElastiCache 提供了托管服务、可扩展性、安全性和监控等功能，使用户能够轻松地构建和管理缓存集群，以满足不同应用程序的需求。</p><h3 id="ECS（Elastic-Container-Service）"><a href="#ECS（Elastic-Container-Service）" class="headerlink" title="ECS（Elastic Container Service）"></a>ECS（Elastic Container Service）</h3><p>是亚马逊网络服务（AWS）提供的一种托管容器编排服务，用于在云中运行和管理容器化应用程序。它支持 Docker 容器，并提供了一种简单而高效的方式来部署、运行和扩展容器化应用程序。</p><p>以下是 ECS 的一些关键特点和功能：</p><ol><li><p>容器编排：ECS 提供了一种灵活的容器编排机制，可以方便地部署和管理容器化应用程序。它允许用户定义任务（Task）和服务（Service），并自动处理容器的调度、启动、停止和扩展。</p></li><li><p>容器集群：ECS 使用容器集群（Cluster）作为容器化应用程序的运行环境。用户可以创建和管理多个集群，每个集群可以包含多个 EC2 实例或 Fargate 任务（无需 EC2 实例）。集群提供了资源管理、负载均衡和容器调度等功能。</p></li><li><p>弹性扩展：ECS 允许根据应用程序的需求自动扩展容器实例。用户可以定义自动扩展策略，根据 CPU 使用率、内存使用率或其他指标来动态调整容器实例数量，以满足流量和负载的变化。</p></li><li><p>任务定义：ECS 使用任务定义（Task Definition）来描述容器化应用程序的配置和要求。任务定义包括容器映像、资源限制、网络设置和存储卷等信息。通过任务定义，用户可以定义应用程序的结构和配置，并将其部署到容器集群中。</p></li><li><p>服务调度：ECS 提供了服务调度功能，可以确保容器实例持续运行和可用。服务定义了要运行的任务数量、负载均衡设置和健康检查规则等。ECS 会自动监视容器实例的健康状态，并根据需要启动、停止或替换容器实例，以保持服务的可用性。</p></li><li><p>与其他 AWS 服务集成：ECS 与其他 AWS 服务集成紧密，例如 Elastic Load Balancing、Amazon VPC、AWS IAM 和 AWS CloudFormation 等。这使得用户可以轻松地将 ECS 与其他服务结合使用，构建完整的应用程序架构。</p></li><li><p>支持 Fargate：ECS 提供了 Fargate 托管模式，允许用户无需管理 EC2 实例即可运行容器。Fargate 提供了一种无服务器的容器执行环境，用户只需定义任务和服务，而无需关心底层基础设施。</p></li></ol><p>通过使用 ECS，用户可以轻松地部署、运行和扩展容器化应用程序。ECS 提供了容器编排、弹性扩展、服务调度和与其他 AWS 服务的集成等功能，使用户能够以高效和可靠的方式管理容器化应用程序，并实现弹性和可伸缩的部署。</p><h3 id="AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景："><a href="#AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景：" class="headerlink" title="AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景："></a>AWS（亚马逊网络服务）提供了多种存储服务，每种服务都有其独特的特点和应用场景。以下是一些常用的AWS存储服务及其特点和应用场景：</h3><ol><li><p>**Amazon Simple Storage Service (S3)**：</p><ul><li>特点：高度可扩展的对象存储服务，提供99.999999999%的持久性，支持存储任意大小的数据。</li><li>应用场景：适用于存储网站内容、备份、归档、大数据分析等。</li></ul></li><li><p>**Amazon Elastic Block Store (EBS)**：</p><ul><li>特点：为EC2实例提供块级存储卷，支持频繁的读写操作，可实现持久存储。</li><li>应用场景：适合于需要持久、低延迟存储的场景，如数据库、文件系统等。</li></ul></li><li><p>**Amazon Elastic File System (EFS)**：</p><ul><li>特点：提供简单、可扩展的文件存储服务，可同时供多个EC2实例访问。</li><li>应用场景：适用于需要共享文件存储的应用，如内容管理、数据共享等。</li></ul></li><li><p><strong>Amazon Glacier</strong>：</p><ul><li>特点：低成本的长期备份和归档服务，检索时间可能从几分钟到几小时不等。</li><li>应用场景：适合长期数据归档，如法规遵从、数字保存等。</li></ul></li><li><p><strong>AWS Storage Gateway</strong>：</p><ul><li>特点：连接本地环境与AWS云存储的混合存储服务，支持文件、块及磁带数据。</li><li>应用场景：适用于需要将本地存储环境与云端集成的场景。</li></ul></li><li><p><strong>Amazon DynamoDB</strong>：</p><ul><li>特点：快速、可扩展的NoSQL数据库服务，支持键值和文档数据模型。</li><li>应用场景：适用于需要高性能、灵活的数据库解决方案的应用，如移动应用、Web应用等。</li></ul></li><li><p>**Amazon Relational Database Service (RDS)**：</p><ul><li>特点：简化的关系数据库服务，支持包括MySQL、PostgreSQL、Oracle等在内的多种数据库引擎。</li><li>应用场景：适用于需要传统关系数据库的应用，如企业应用、ERP系统等。</li></ul></li></ol><p>每种服务都有其优势和局限性，选择合适的存储服务需要根据具体的应用需求、成本考虑以及性能要求来决定。</p><h3 id="AWS-Key-Management-Service（KMS）"><a href="#AWS-Key-Management-Service（KMS）" class="headerlink" title="AWS Key Management Service（KMS）"></a>AWS Key Management Service（KMS）</h3><p>是亚马逊网络服务（AWS）提供的一种托管密钥管理服务，用于创建和控制加密密钥，以保护数据的安全性。KMS 可以帮助用户轻松地生成、存储、使用和管理加密密钥，以加密和解密数据，并确保数据在存储和传输过程中的保密性。</p><p>以下是 AWS Key Management Service 的一些关键特点和功能：</p><ol><li><p>密钥生成和管理：KMS 提供了简单的 API 和控制台界面，用于生成和管理加密密钥。用户可以创建自己的主密钥（Customer Master Key，CMK）或使用 AWS 托管的主密钥。KMS 还提供了密钥轮换、禁用和删除等功能，以确保密钥的安全性和可管理性。</p></li><li><p>数据加密和解密：KMS 可以用于加密和解密数据。用户可以使用 KMS 提供的 API 或 AWS SDK 来对数据进行加密，然后在需要时使用相同的密钥进行解密。KMS 支持多种加密算法和模式，包括对称密钥加密和非对称密钥加密。</p></li><li><p>密钥策略和访问控制：KMS 允许用户定义密钥策略来控制谁可以使用密钥进行加密和解密操作。用户可以为每个密钥指定访问权限，并使用 AWS Identity and Access Management（IAM）来管理和控制对密钥的访问。</p></li><li><p>审计和监控：KMS 提供了审计日志和监控功能，用于跟踪密钥的使用情况和操作历史。用户可以通过 AWS CloudTrail 来获取密钥的操作日志，并使用 AWS CloudWatch 来监控密钥的使用情况和性能。</p></li><li><p>集成和扩展性：KMS 可以与其他 AWS 服务和应用程序集成，以提供端到端的数据加密解决方案。例如，可以将 KMS 与 Amazon S3、Amazon EBS、Amazon RDS 等服务结合使用，以实现对数据的加密保护。</p></li></ol><p>通过使用 AWS Key Management Service，用户可以轻松地生成、存储和管理加密密钥，以保护数据的安全性。KMS 提供了密钥生成和管理、数据加密和解密、密钥策略和访问控制、审计和监控等功能，为用户提供了一种可靠和安全的密钥管理解决方案。</p><h3 id="Amazon-Kinesis-Data-Streams"><a href="#Amazon-Kinesis-Data-Streams" class="headerlink" title="Amazon Kinesis Data Streams"></a>Amazon Kinesis Data Streams</h3><p>是亚马逊网络服务（AWS）提供的一种实时数据流平台，用于收集、处理和分析大规模实时数据流。它能够处理和存储来自数千个数据源的大量数据，并使用户能够实时处理和分析这些数据，以获得有关数据的实时洞察。</p><p>以下是 Amazon Kinesis Data Streams 的一些关键特点和功能：</p><ol><li><p>数据收集：Kinesis Data Streams 可以接收来自各种数据源（如应用程序、传感器、日志文件等）的大规模实时数据流。数据以流的形式发送到 Kinesis Data Streams，并按照时间顺序进行排序和存储。</p></li><li><p>实时数据处理：Kinesis Data Streams 允许用户实时处理数据流。用户可以使用 AWS Lambda、Amazon Kinesis Data Analytics、自定义应用程序等方式对数据进行实时处理和转换。这使用户能够即时响应数据流中的事件和模式，并执行实时计算、过滤、聚合等操作。</p></li><li><p>数据持久化和存储：Kinesis Data Streams 提供持久化的数据存储，可以在一段时间内保留数据流中的数据。用户可以根据需要配置数据保留期限，并随时访问和检索存储的数据。</p></li><li><p>可伸缩性和高可用性：Kinesis Data Streams 具有高度可伸缩和高可用的特性。它可以处理大量的并发数据流，并自动分配和扩展资源以适应数据流的需求。此外，Kinesis Data Streams 在多个 AWS 区域内提供冗余和容错，以确保数据的持续可用性和可靠性。</p></li><li><p>数据安全和访问控制：Kinesis Data Streams 提供多层数据安全和访问控制机制。用户可以使用 AWS Identity and Access Management（IAM）来管理对数据流的访问权限，并使用数据加密和传输加密等功能来保护数据的安全性。</p></li><li><p>与其他 AWS 服务的集成：Kinesis Data Streams 可以与其他 AWS 服务集成，以构建端到端的实时数据处理和分析解决方案。例如，可以将 Kinesis Data Streams 与 Amazon Kinesis Data Firehose、Amazon Kinesis Data Analytics、Amazon S3、Amazon Redshift 等服务结合使用，实现数据的收集、处理、存储和分析。</p></li></ol><p>通过使用 Amazon Kinesis Data Streams，用户可以轻松地处理和分析大规模实时数据流。它提供了数据收集、实时数据处理、数据持久化和存储、可伸缩性和高可用性、数据安全和访问控制等功能，为用户构建实时数据处理和分析的强大平台。</p><h3 id="ENI代表Elastic-Network-Interface（弹性网络接口）"><a href="#ENI代表Elastic-Network-Interface（弹性网络接口）" class="headerlink" title="ENI代表Elastic Network Interface（弹性网络接口）"></a>ENI代表Elastic Network Interface（弹性网络接口）</h3><p>是亚马逊网络服务（AWS）提供的一种虚拟网络接口，用于连接Amazon Elastic Compute Cloud（EC2）实例与虚拟私有云（VPC）之间的网络。</p><p>每个EC2实例可以附加一个或多个ENI，每个ENI都有自己的私有IP地址、MAC地址和安全组。ENI可以用于实现高级网络配置和功能，例如创建多个网络接口、实现高可用性和负载均衡、实现虚拟专用网络（VPC）间的流量转发等。</p><p>以下是ENI的一些关键特点和功能：</p><ol><li><p>网络连接：ENI允许EC2实例连接到VPC中的子网，并通过子网的路由表与其他资源进行通信。每个ENI都有一个私有IP地址，可以用于内部通信和与其他资源交互。</p></li><li><p>多个IP地址：每个ENI可以分配一个或多个IP地址，这些地址可以是IPv4地址或IPv6地址。这使得EC2实例能够处理多个网络流量和服务。</p></li><li><p>安全组：每个ENI都可以与一个或多个安全组相关联，用于控制入站和出站的网络流量。安全组是一种虚拟防火墙，可以定义允许或拒绝的网络流量规则。</p></li><li><p>弹性IP地址：ENI可以与弹性IP地址（Elastic IP）相关联，使EC2实例的IP地址保持不变。这对于需要固定公网IP地址的应用程序或服务非常有用。</p></li><li><p>高可用性和负载均衡：通过将多个ENI附加到EC2实例上，可以实现高可用性和负载均衡。这样，即使一个ENI或实例发生故障，仍然可以继续提供服务。</p></li><li><p>虚拟专用网络（VPC）间的流量转发：ENI还可以用于在不同的VPC之间转发流量。这可以通过在两个VPC之间创建一个带有ENI的转发实例来实现。</p></li></ol><p>通过使用ENI，用户可以实现更灵活和高级的网络配置，以满足特定的应用程序需求。ENI提供了网络连接、多个IP地址、安全组、弹性IP地址、高可用性和负载均衡等功能，为用户提供了强大的网络管理和控制能力。</p><h3 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h3><p>代表Elastic IP（弹性IP），是亚马逊网络服务（AWS）提供的一种静态公网IP地址。Elastic IP地址是与AWS账户相关联的IP地址，可以动态地映射到用户的云资源（如EC2实例、NAT网关等），并保持不变，即使资源被停止、重新启动或迁移。</p><p>以下是Elastic IP的一些关键特点和功能：</p><ol><li><p>固定公网IP地址：Elastic IP提供了一个固定的公网IP地址，用户可以将其分配给EC2实例、NAT网关或其他支持公网访问的AWS资源。这使得用户可以通过固定的IP地址访问其云资源，而不受资源启动、停止或重新分配的影响。</p></li><li><p>弹性和可靠性：Elastic IP是弹性和可靠的，可以在需要时轻松地将其映射到不同的云资源。用户可以根据需要将Elastic IP从一个实例或资源解绑，并绑定到另一个实例或资源上，而无需更改与该IP地址相关联的应用程序或服务。</p></li><li><p>公网访问：通过将Elastic IP地址分配给EC2实例或其他支持公网访问的资源，用户可以通过公网访问这些资源。这对于需要对外提供服务或需要远程访问资源的应用程序非常有用。</p></li><li><p>网络地址转换（NAT）：Elastic IP还可以与网络地址转换（NAT）网关相关联，用于实现私有子网中EC2实例的出站互联网访问。NAT网关使用Elastic IP地址作为源IP地址，将私有子网中的流量转发到公网。</p></li><li><p>费用和配额：Elastic IP地址在使用期间会产生费用。AWS为每个账户提供了一定数量的免费Elastic IP地址配额，超出配额的部分将会收取费用。用户可以根据需要管理和分配Elastic IP地址。</p></li></ol><p>通过使用Elastic IP，用户可以获得固定的公网IP地址，并将其分配给需要公网访问的云资源。Elastic IP具有弹性和可靠性，可以轻松映射到不同的资源，同时还可以与NAT网关一起使用实现私有子网中的出站互联网访问。</p><h3 id="AWS-CloudTrail-和-Amazon-CloudWatch-都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别："><a href="#AWS-CloudTrail-和-Amazon-CloudWatch-都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别：" class="headerlink" title="AWS CloudTrail 和 Amazon CloudWatch 都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别："></a>AWS CloudTrail 和 Amazon CloudWatch 都是AWS提供的监控服务，但它们的功能和用途有所不同。下面是两者的主要区别：</h3><ol><li><p><strong>功能焦点</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：主要用于记录和监控AWS账户中的API调用和相关事件。CloudTrail提供了一个记录谁在何时对AWS资源执行了什么操作的详细历史。这些信息对于安全分析、资源变更追踪、和合规审计非常重要。</li><li><strong>Amazon CloudWatch</strong>：专注于监控AWS资源和应用程序的运行状况。CloudWatch可以收集和跟踪指标，设置和管理告警，自动反应系统的变化。它用于实时监控应用程序的性能和运行状况。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：用于安全和合规审计。例如，追踪特定用户在特定时间进行的操作，审计资源的配置历史和变更，或者检测不寻常的活动，以识别安全威胁。</li><li><strong>Amazon CloudWatch</strong>：用于性能监控和管理。例如，监控EC2实例的CPU和网络使用情况，设置基于特定阈值的警报（如内存使用率过高），或自动扩展资源以应对负载变化。</li></ul></li><li><p><strong>数据类型</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：主要记录API调用和相关事件的日志，包括调用者身份、调用时间、请求参数以及响应元素等。</li><li><strong>Amazon CloudWatch</strong>：主要收集指标数据，如CPU利用率、磁盘读写、网络流量等。同时，CloudWatch Logs可以收集、监控和存储日志文件。</li></ul></li><li><p><strong>数据保留</strong>：</p><ul><li><strong>AWS CloudTrail</strong>：默认情况下，CloudTrail事件日志在S3中保留无限期，但是可以根据需要配置保留策略。</li><li><strong>Amazon CloudWatch</strong>：指标数据的默认保留期限不同（从3小时到15个月不等），而日志数据的保留期限是可以配置的，从永久保存到自动删除都可以。</li></ul></li></ol><p>总结来说，CloudTrail更偏向于安全和合规的日志记录，而CloudWatch则侧重于性能监控和实时数据分析。两者通常结合使用，以提供全面的资源监控和事件记录功能。</p><h3 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h3><p>Amazon Athena 是一种交互式查询服务，使您能够使用标准 SQL 轻松分析存储在 Amazon S3 中的数据。没有需设置复杂的数据仓库或管理基础设施。</p><h3 id="AWS-Data-Exchange"><a href="#AWS-Data-Exchange" class="headerlink" title="AWS Data Exchange"></a>AWS Data Exchange</h3><p>AWS Data Exchange 允许客户在 AWS 云中轻松查找、订阅和使用第三方数据。这种服务简化了数据许可和交换过程。</p><h3 id="AWS-Data-Pipeline"><a href="#AWS-Data-Pipeline" class="headerlink" title="AWS Data Pipeline"></a>AWS Data Pipeline</h3><p>AWS Data Pipeline 是一种云服务，用于自动化数据移动和转换过程。它可以帮助你轻松地将数据从一个地方移动和处理到另一个地方。</p><h3 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h3><p>Amazon EMR 是一种托管的群集平台，可处理大量数据集并运行大数据分析作业。它支持多种大数据框架，如 Apache Hadoop 和 Apache Spark。</p><h3 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h3><p>AWS Glue 是一种完全托管的提取、转换和加载（ETL）服务，用于准备和加载数据。它自动发现和分类数据，使得数据集成更加容易。</p><h3 id="Amazon-Kinesis"><a href="#Amazon-Kinesis" class="headerlink" title="Amazon Kinesis"></a>Amazon Kinesis</h3><p>Amazon Kinesis 使您能够在实时地收集、处理和分析视频和数据流。这对于实时应用程序和数据分析非常重要。</p><h3 id="AWS-Lake-Formation"><a href="#AWS-Lake-Formation" class="headerlink" title="AWS Lake Formation"></a>AWS Lake Formation</h3><p>AWS Lake Formation 是一种服务，用于建立、安全地管理和共享数据湖。它简化了数据湖的设置和管理。</p><h3 id="Amazon-Managed-Streaming-for-Apache-Kafka-Amazon-MSK"><a href="#Amazon-Managed-Streaming-for-Apache-Kafka-Amazon-MSK" class="headerlink" title="Amazon Managed Streaming for Apache Kafka (Amazon MSK)"></a>Amazon Managed Streaming for Apache Kafka (Amazon MSK)</h3><p>Amazon MSK 是一种完全托管的 Apache Kafka 服务，使您能够构建和运行应用程序，这些应用程序可处理来自多个数据源的流数据。</p><h3 id="Amazon-OpenSearch-Service"><a href="#Amazon-OpenSearch-Service" class="headerlink" title="Amazon OpenSearch Service"></a>Amazon OpenSearch Service</h3><p>Amazon OpenSearch Service（原名Amazon Elasticsearch Service）提供了在 AWS 上运行 OpenSearch（一种流行的开源搜索和分析引擎）的能力。</p><h3 id="Amazon-QuickSight"><a href="#Amazon-QuickSight" class="headerlink" title="Amazon QuickSight"></a>Amazon QuickSight</h3><p>Amazon QuickSight 是一种快速、易用的商业智能服务，用于从您的数据中构建可视化效果，并提供洞察力。</p><h3 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h3><p>Amazon Redshift 是一种快速、可扩展的数据仓库服务，使您能够分析所有数据使用标准 SQL 和现有的商业智能工具。</p><h3 id="应用程序集成"><a href="#应用程序集成" class="headerlink" title="应用程序集成"></a>应用程序集成</h3><h4 id="Amazon-AppFlow"><a href="#Amazon-AppFlow" class="headerlink" title="Amazon AppFlow"></a>Amazon AppFlow</h4><p>Amazon AppFlow 是一种集成服务，使您能够在 AWS 和 SaaS 应用程序（如 Salesforce、ServiceNow 和 Slack）之间轻松传输数据。</p><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><p>AWS AppSync 是一种完全托管的服务，用于开发 GraphQL API，实现应用程序数据的即时同步。</p><h4 id="Amazon-EventBridge"><a href="#Amazon-EventBridge" class="headerlink" title="Amazon EventBridge"></a>Amazon EventBridge</h4><p>Amazon EventBridge 是一种服务器事件总线服务，它使应用程序能够与来自 AWS 服务、自定义应用程序和 SaaS 应用程序的事件进行交互。</p><h4 id="Amazon-MQ"><a href="#Amazon-MQ" class="headerlink" title="Amazon MQ"></a>Amazon MQ</h4><p>Amazon MQ 是一种托管的消息代理服务，适用于 ActiveMQ 和 RabbitMQ，使您能夠建立通信系统，轻松地在应用程序之间发送和接收消息。</p><h4 id="Amazon-Simple-Notification-Service-Amazon-SNS"><a href="#Amazon-Simple-Notification-Service-Amazon-SNS" class="headerlink" title="Amazon Simple Notification Service (Amazon SNS)"></a>Amazon Simple Notification Service (Amazon SNS)</h4><p>Amazon SNS 是一种完全托管的发布/订阅消息通知服务，您可以用它来分离微服务、分布式系统和服务器。</p><h4 id="Amazon-Simple-Queue-Service-Amazon-SQS"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS)"></a>Amazon Simple Queue Service (Amazon SQS)</h4><p>Amazon SQS 提供了托管的消息队列服务，以便您可以通过解耦和扩展微服务、分布式系统和服务器应用程序来传输任何量的数据。</p><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><p>AWS Step Functions 是一种服务，用于在 AWS 上协调各种服务的组件。它使得创建和管理复杂工作流程变得容易。</p><h3 id="AWS-成本管理"><a href="#AWS-成本管理" class="headerlink" title="AWS 成本管理"></a>AWS 成本管理</h3><h4 id="AWS-Budgets"><a href="#AWS-Budgets" class="headerlink" title="AWS Budgets"></a>AWS Budgets</h4><p>AWS Budgets 允许您设置自定义的预算，以便跟踪您的成本和使用情况。</p><h4 id="AWS-成本和使用情况报告"><a href="#AWS-成本和使用情况报告" class="headerlink" title="AWS 成本和使用情况报告"></a>AWS 成本和使用情况报告</h4><p>这项服务提供了有关您的 AWS 成本</p><p>和使用情况的详细报告，帮助您更好地了解和管理 AWS 费用。</p><h4 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h4><p>AWS Cost Explorer 是一种分析工具，用于可视化和理解 AWS 花费和使用情况数据。</p><h4 id="Savings-Plans"><a href="#Savings-Plans" class="headerlink" title="Savings Plans"></a>Savings Plans</h4><p>Savings Plans 是一种灵活的定价模型，提供对特定 AWS 服务的显著折扣，换取一定时间内的使用承诺。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><p>AWS Batch 允许您运行大规模的批处理作业，自动地在 AWS 的云计算资源上。</p><h4 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h4><p>Amazon Elastic Compute Cloud (Amazon EC2) 提供了可伸缩的计算容量。这使您可以快速启动和管理虚拟服务器。</p><h4 id="Amazon-EC2-Auto-Scaling"><a href="#Amazon-EC2-Auto-Scaling" class="headerlink" title="Amazon EC2 Auto Scaling"></a>Amazon EC2 Auto Scaling</h4><p>Amazon EC2 Auto Scaling 帮助您确保具有正确数量的 Amazon EC2 实例来处理应用程序的负载。</p><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><p>AWS Elastic Beanstalk 是一种易于使用的服务，用于部署和扩展 Web 应用程序和服务。</p><h4 id="AWS-Outposts"><a href="#AWS-Outposts" class="headerlink" title="AWS Outposts"></a>AWS Outposts</h4><p>AWS Outposts 是一种完全托管的服务，将 AWS 基础设施、服务、API 和工具扩展到几乎任何数据中心、共同托管空间或本地设施。</p><h4 id="AWS-Serverless-Application-Repository"><a href="#AWS-Serverless-Application-Repository" class="headerlink" title="AWS Serverless Application Repository"></a>AWS Serverless Application Repository</h4><p>AWS Serverless Application Repository 是一种管理和部署无服务器应用程序的平台。</p><h4 id="VMware-Cloud-on-AWS"><a href="#VMware-Cloud-on-AWS" class="headerlink" title="VMware Cloud on AWS"></a>VMware Cloud on AWS</h4><p>VMware Cloud on AWS 是一个集成的云服务，使您能够在 AWS 云上运行基于 VMware 的环境。</p><h4 id="AWS-Wavelength"><a href="#AWS-Wavelength" class="headerlink" title="AWS Wavelength"></a>AWS Wavelength</h4><p>AWS Wavelength 将 AWS 服务扩展到移动和边缘设备，使开发人员能够构建提供超低延迟应用程序的应用程序。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="Amazon-ECS-Anywhere"><a href="#Amazon-ECS-Anywhere" class="headerlink" title="Amazon ECS Anywhere"></a>Amazon ECS Anywhere</h4><p>Amazon ECS Anywhere 允许您在任何基础设施上运行 Amazon ECS，包括您自己的数据中心。</p><h4 id="Amazon-EKS-Anywhere"><a href="#Amazon-EKS-Anywhere" class="headerlink" title="Amazon EKS Anywhere"></a>Amazon EKS Anywhere</h4><p>Amazon EKS Anywhere 提供了一种在您自己的基础设施上运行 Amazon EKS 的方式。</p><h4 id="Amazon-EKS-Distro"><a href="#Amazon-EKS-Distro" class="headerlink" title="Amazon EKS Distro"></a>Amazon EKS Distro</h4><p>Amazon EKS Distro 是一个 Kubernetes 分发版，您可以在任何环境中运行它，包括您自己的数据中心。</p><h4 id="Amazon-Elastic-Container-Registry-Amazon-ECR"><a href="#Amazon-Elastic-Container-Registry-Amazon-ECR" class="headerlink" title="Amazon Elastic Container Registry (Amazon ECR)"></a>Amazon Elastic Container Registry (Amazon ECR)</h4><p>Amazon ECR 是一种完全托管的 Docker 容器注册服务，使开发人员可以轻松存储、管理和部署 Docker 容器映像。</p><h4 id="Amazon-Elastic-Container-Service-Amazon-ECS"><a href="#Amazon-Elastic-Container-Service-Amazon-ECS" class="headerlink" title="Amazon Elastic Container Service (Amazon ECS)"></a>Amazon Elastic Container Service (Amazon ECS)</h4><p>Amazon ECS 是一种高度可扩展的、高性能的容器管理服务，支持 Docker 容器。</p><h4 id="Amazon-Elastic-Kubernetes-Service-Amazon-EKS"><a href="#Amazon-Elastic-Kubernetes-Service-Amazon-EKS" class="headerlink" title="Amazon Elastic Kubernetes Service (Amazon EKS)"></a>Amazon Elastic Kubernetes Service (Amazon EKS)</h4><p>Amazon EKS 是一种托管服务，使您可以在 AWS 上轻松运行 Kubernetes。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h4><p>Amazon Aurora 是一种兼容 MySQL 和 PostgreSQL 的关系数据库，它结合了商业数据库的性能和可用性以及开源数据库的成本效益。</p><h4 id="Amazon-Aurora-Serverless"><a href="#Amazon-Aurora-Serverless" class="headerlink" title="Amazon Aurora Serverless"></a>Amazon Aurora Serverless</h4><p>Amazon Aurora Serverless 是一种自动缩放的 Aurora 数据库版本，适用于不需要持续数据库连接的应用程序。</p><h4 id="Amazon-DocumentDB（兼容-MongoDB）"><a href="#Amazon-DocumentDB（兼容-MongoDB）" class="headerlink" title="Amazon DocumentDB（兼容 MongoDB）"></a>Amazon DocumentDB（兼容 MongoDB）</h4><p>Amazon DocumentDB 是一种文档数据库服务，与 MongoDB 兼容，为 JSON 数据提供持久性存储。</p><h4 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h4><p>Amazon DynamoDB 是一种快速和灵活的 NoSQL 数据库服务，适用于所有需要一致的、单毫秒级延迟的应用程序。</p><h4 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h4><p>Amazon ElastiCache 是一种缓存服务，支持 Redis 和 Memcached。它用于提升数据库和应用程序的性能。</p><h4 id="Amazon-Keyspaces（适用于-Apache-Cassandra）"><a href="#Amazon-Keyspaces（适用于-Apache-Cassandra）" class="headerlink" title="Amazon Keyspaces（适用于 Apache Cassandra）"></a>Amazon Keyspaces（适用于 Apache Cassandra）</h4><p>Amazon Keyspaces 是一种可扩展、高可用性和托管的 Apache Cassandra 兼容数据库服务。</p><p>!</p><p>ChatGPT</p><h2 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h2><p>Amazon Neptune 是一种完全托管的图数据库服务，专门设计用于存储和导航连接数据。它支持广泛的图查询语言，如Gremlin和SPARQL，使其适用于构建高效的关系网络应用程序，如社交网络、推荐引擎或知识图谱。</p><h2 id="Amazon-Quantum-Ledger-Database-Amazon-QLDB"><a href="#Amazon-Quantum-Ledger-Database-Amazon-QLDB" class="headerlink" title="Amazon Quantum Ledger Database (Amazon QLDB)"></a>Amazon Quantum Ledger Database (Amazon QLDB)</h2><p>Amazon QLDB 是一个完全托管的账本数据库，提供一个透明、可验证且不可篡改的交易日志记录功能。它旨在为需要记录和跟踪数据变更历史的应用程序提供高性能和易于使用的数据结构。</p><h2 id="Amazon-RDS"><a href="#Amazon-RDS" class="headerlink" title="Amazon RDS"></a>Amazon RDS</h2><p>Amazon RDS（Relational Database Service）是一个托管型SQL数据库服务，支持多种数据库引擎，如MySQL、PostgreSQL、Oracle和SQL Server。它简化了数据库设置、运维和扩展工作，同时提供高可用性和安全性。</p><h2 id="Amazon-Redshift-1"><a href="#Amazon-Redshift-1" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p>Amazon Redshift 是一种完全托管的、基于列的数据仓库服务，它允许用户通过SQL查询大规模数据集。它特别适合用于数据仓库和大数据分析任务。</p><h2 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h2><p>AWS X-Ray 是一种服务，帮助开发人员分析和调试在AWS环境中运行的应用程序。它提供了一个详细的视图，显示应用程序如何在分布式系统中执行，帮助识别和解决性能瓶颈和错误。</p><h2 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h2><p>AWS Amplify 是一套工具和服务，可帮助前端开发人员更快地构建全栈应用程序。它提供了一系列功能，包括认证、API、数据库和文件存储，以及与React、Angular、Vue和其他JavaScript框架的集成。</p><h2 id="Amazon-API-Gateway"><a href="#Amazon-API-Gateway" class="headerlink" title="Amazon API Gateway"></a>Amazon API Gateway</h2><p>Amazon API Gateway 是一项托管服务，使开发人员可以轻松地创建、发布、维护、监控和保护API。它处理所有的API托管任务，包括流量管理、授权和访问控制、监控以及API版本管理。</p><h2 id="AWS-Device-Farm"><a href="#AWS-Device-Farm" class="headerlink" title="AWS Device Farm"></a>AWS Device Farm</h2><p>AWS Device Farm 是一种应用测试服务，允许开发人员在多种真实设备上测试他们的Web和移动应用程序。它提供了一个云端平台，用于测试应用程序的功能性和性能，确保在多种设备和操作系统上都能正常运行。</p><h2 id="Amazon-Pinpoint"><a href="#Amazon-Pinpoint" class="headerlink" title="Amazon Pinpoint"></a>Amazon Pinpoint</h2><p>Amazon Pinpoint 是一种灵活的、用户参与服务，旨在帮助公司通过电子邮件、短信、推送通知等渠道有效地与客户沟通。它支持客户参与分析和营销活动的自动化。</p><h2 id="Amazon-Comprehend"><a href="#Amazon-Comprehend" class="headerlink" title="Amazon Comprehend"></a>Amazon Comprehend</h2><p>Amazon Comprehend 是一种基于自然语言处理（NLP）的服务，可以识别文本中的语言、提取关键短语、地点、人名、品牌、情绪等。它广泛用于文本分析和数据挖掘。</p><h2 id="Amazon-Forecast"><a href="#Amazon-Forecast" class="headerlink" title="Amazon Forecast"></a>Amazon Forecast</h2><p>Amazon Forecast 是一种基于机器学习的预测服务，它可以根据历史数据预测未来趋势。这种服务适用于库存规划、资源需求预测、金融市场分析等场景。</p><h2 id="Amazon-Fraud-Detector"><a href="#Amazon-Fraud-Detector" class="headerlink" title="Amazon Fraud Detector"></a>Amazon Fraud Detector</h2><p>Amazon Fraud Detector 是一种基于机器学习和大量欺诈数据集的服务，用于检测在线活动中的欺诈行为。它可以帮助企业识别潜在的欺诈交易和异常活动。</p><h2 id="Amazon-Kendra"><a href="#Amazon-Kendra" class="headerlink" title="Amazon Kendra"></a>Amazon Kendra</h2><p>Amazon Kendra 是一种高度精准的企业级搜索服务，使用机器学习提供更自然的搜索体验。它能够理解复杂的用户查询，提供高相关性的搜索结果。</p><h2 id="Amazon-Lex"><a href="#Amazon-Lex" class="headerlink" title="Amazon Lex"></a>Amazon Lex</h2><p>Amazon Lex 是一种服务，使开发人员能够构建能与用户自然交流的对话界面。它是构建聊天机器人的主要工具，可以集成到各种应用程序和服务中。</p><h2 id="Amazon-Polly"><a href="#Amazon-Polly" class="headerlink" title="Amazon Polly"></a>Amazon Polly</h2><p>Amazon Polly 是一种文本转语音服务，它使用高级深度学习技术将文本转换成自然听起来的语音。它支持多种语言和声音，适用于创建各种语音应用程序。</p><h2 id="Amazon-Rekognition"><a href="#Amazon-Rekognition" class="headerlink" title="Amazon Rekognition"></a>Amazon Rekognition</h2><p>Amazon Rekognition 是一种图像和视频分析服务，它使用机器学习模型识别图像和视频中的对象、场景、人脸等。它广泛用于媒体分析、安全监控等领域。</p><h2 id="Amazon-SageMaker"><a href="#Amazon-SageMaker" class="headerlink" title="Amazon SageMaker"></a>Amazon SageMaker</h2><p>Amazon SageMaker 是一个全面的机器学习服务，它帮助数据科学家和开发人员快速构建、训练和部署机器学习模型。它提供了一系列工具来简化机器学习工作流程。</p><h2 id="Amazon-Textract"><a href="#Amazon-Textract" class="headerlink" title="Amazon Textract"></a>Amazon Textract</h2><p>Amazon Textract 是一种文档分析服务，它可以自动提取PDF、图像和扫描文档中的文本、表格和表单数据。它可以用于自动化文档处理任务。</p><h2 id="Amazon-Transcribe"><a href="#Amazon-Transcribe" class="headerlink" title="Amazon Transcribe"></a>Amazon Transcribe</h2><p>Amazon Transcribe 是一个自动语音识别服务，它可以将音频和视频文件中的语音转换为文本。它支持多种语言和方言，适用于生成字幕、转录会议记录等。</p><h2 id="Amazon-Translate"><a href="#Amazon-Translate" class="headerlink" title="Amazon Translate"></a>Amazon Translate</h2><p>Amazon Translate 是一种神经机器翻译服务，它提供快速、高质量的语言翻译。它支持多种语言，可以用于网站、应用程序和内容的本地化。</p><h2 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h2><p>AWS Auto Scaling 是一种服务，帮助您自动调整AWS资源的数量，以满足应用程序的需求。它可以根据预定的条件和指标自动增加或减少资源，确保性能和成本效率。</p><h2 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h2><p>AWS CloudFormation 是一种服务，使开发人员可以使用代码来定义和部署AWS资源。它可以自动化和简化资源管理，确保基础设施的一致性和重复性。</p><h2 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h2><p>AWS CloudTrail 是一项服务，用于记录AWS账户的API调用和相关事件。这些日志可以用于安全分析、资源变更追踪和合规性审计。</p><h2 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h2><p>是 Amazon Web Services（AWS）提供的一项监控服务，主要用于对在 AWS 上运行的应用程序和资源进行监控和管理。CloudWatch 提供了多种功能，使您能够收集和跟踪指标、收集和监控日志文件，以及设置警报。下面是 CloudWatch 的一些主要功能和应用：</p><p>指标收集与监控：CloudWatch 可以收集如 CPU 使用率、网络使用量、磁盘读写次数等各种指标。这些指标可用于监控 AWS 资源（如 EC2 实例、Amazon RDS 数据库实例等）的性能。</p><p>日志管理：CloudWatch Logs 服务允许您监控、存储和访问日志文件。您可以使用 CloudWatch Logs 来监控应用程序的日志，这对于诊断问题和维护应用程序运行状况非常有用。</p><p>警报：CloudWatch Alarms 可以让您在某个指标达到预设阈值时得到通知。警报可以用于实时监控应用程序和资源的状态，并在问题出现时及时做出响应。</p><p>自动化反应：结合 AWS 自动化工具（如 AWS Lambda 或 Auto Scaling），当特定指标达到某个值时，CloudWatch 可以触发自动化动作，例如启动或停止实例。</p><p>自定义指标与仪表板：您还可以发布自定义指标到 CloudWatch，并使用 CloudWatch Dashboards 创建可视化的数据面板，这有助于您更直观地理解和分析数据。</p><p>集成与扩展性：CloudWatch 与其他 AWS 服务紧密集成，例如 AWS Identity and Access Management (IAM)、Amazon S3、Amazon EC2 等，支持广泛的应用场景。</p><h2 id="AWS-Command-Line-Interface-AWS-CLI"><a href="#AWS-Command-Line-Interface-AWS-CLI" class="headerlink" title="AWS Command Line Interface (AWS CLI)"></a>AWS Command Line Interface (AWS CLI)</h2><p>AWS Command Line Interface (CLI) 是一个工具，允许开发人员通过命令行界面管理AWS服务。它提供了一种简便的方式来访问AWS的广泛服务。</p><h2 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h2><p>AWS Compute Optimizer 是一种工具，它使用机器学习来推荐适合您工作负载的AWS资源配置。它旨在优化性能和成本效率。</p><h2 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h2><p>AWS Config 是一种服务，用于评估、审计和评估AWS资源的配置。它可以帮助确保资源符合公司政策和合规性要求。</p><h2 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h2><p>AWS Control Tower 是一种管理服务，提供了一个中央仪表板来监控和管理多个AWS账户。它提供了一种简化的方式来建立和维护安全的、合规的多账户环境。</p><h2 id="AWS-Health-Dashboard"><a href="#AWS-Health-Dashboard" class="headerlink" title="AWS Health Dashboard"></a>AWS Health Dashboard</h2><p>AWS Health Dashboard 提供了有关 AWS 服务健康状况的实时信息。它提供了服务中断和维护事件的通知，帮助用户及时了解和应对潜在的服务影响。</p><h2 id="AWS-License-Manager"><a href="#AWS-License-Manager" class="headerlink" title="AWS License Manager"></a>AWS License Manager</h2><p>AWS License Manager 使用户能够管理软件许可证的使用情况。它有助于用户遵守许可证规定，避免超出许可证的约束，从而降低合规风险。</p><h2 id="Amazon-Managed-Grafana"><a href="#Amazon-Managed-Grafana" class="headerlink" title="Amazon Managed Grafana"></a>Amazon Managed Grafana</h2><p>Amazon Managed Grafana 是一种开源分析和可视化平台，由 AWS 管理。用户可以使用它来监控和分析其AWS环境中的数据。</p><h2 id="Amazon-Managed-Service-for-Prometheus"><a href="#Amazon-Managed-Service-for-Prometheus" class="headerlink" title="Amazon Managed Service for Prometheus"></a>Amazon Managed Service for Prometheus</h2><p>这是一种完全托管的服务，它兼容开源 Prometheus，用于监控和警报。它专门用于容器化和微服务架构的监控。</p><h2 id="AWS-管理控制台"><a href="#AWS-管理控制台" class="headerlink" title="AWS 管理控制台"></a>AWS 管理控制台</h2><p>AWS管理控制台是一个基于网页的界面，用于管理AWS账户和运行的服务。它提供了一个用户友好的界面，用于访问和管理AWS资源。</p><h2 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h2><p>AWS Organizations 允许用户以集中的方式管理和治理其多个AWS账户。它支持账户分组、策略设置和成本报告等功能。</p><h2 id="AWS-Proton"><a href="#AWS-Proton" class="headerlink" title="AWS Proton"></a>AWS Proton</h2><p>AWS Proton 是一种完全托管的应用交付服务，用于自动化和管理服务器和无服务器应用程序的部署。</p><h2 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h2><p>AWS Service Catalog 允许组织创建和管理可授权给用户使用的预定义的IT服务和产品目录。</p><h2 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h2><p>AWS Systems Manager 提供了一套集成工具，用于自动化和管理AWS环境。这包括资源配置、监控和自动化任务执行等。</p><h2 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h2><p>AWS Trusted Advisor 是一种在线工具，提供了对AWS环境的最佳实践建议。它涉及成本优化、性能、安全和容错能力。</p><h2 id="AWS-Well-Architected-Tool"><a href="#AWS-Well-Architected-Tool" class="headerlink" title="AWS Well-Architected Tool"></a>AWS Well-Architected Tool</h2><p>这是一种帮助用户检查其AWS工作负载是否符合最佳实践的工具。它提供了指导和建议，以优化工作负载。</p><h2 id="媒体服务"><a href="#媒体服务" class="headerlink" title="媒体服务"></a>媒体服务</h2><h3 id="Amazon-Elastic-Transcoder"><a href="#Amazon-Elastic-Transcoder" class="headerlink" title="Amazon Elastic Transcoder"></a>Amazon Elastic Transcoder</h3><p>这是一种媒体转码服务，用于将音视频文件转换成不同的格式，以便在各种设备和平台上播放。</p><h3 id="Amazon-Kinesis-Video-Streams"><a href="#Amazon-Kinesis-Video-Streams" class="headerlink" title="Amazon Kinesis Video Streams"></a>Amazon Kinesis Video Streams</h3><p>该服务允许用户安全地将视频流连接到AWS用于分析和其他处理。</p><h2 id="迁移和传输"><a href="#迁移和传输" class="headerlink" title="迁移和传输"></a>迁移和传输</h2><h3 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h3><p>此服务帮助企业快速准确地了解其IT基础设施，以便更有效地规划迁移。</p><h3 id="AWS-Application-Migration-Service"><a href="#AWS-Application-Migration-Service" class="headerlink" title="AWS Application Migration Service"></a>AWS Application Migration Service</h3><p>这是一种自动化迁移服务，可简化应用程序的迁移过程，从而加速迁移和降低成本。</p><h3 id="AWS-Database-Migration-Service-AWS-DMS"><a href="#AWS-Database-Migration-Service-AWS-DMS" class="headerlink" title="AWS Database Migration Service (AWS DMS)"></a>AWS Database Migration Service (AWS DMS)</h3><p>AWS DMS 支持不同数据库之间的迁移，包括跨平台迁移，同时最小化停机时间。</p><h3 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h3><p>DataSync 是一个数据迁移工具，用于快速、安全地移动大量数据到和从AWS。</p><h3 id="AWS-Migration-Hub"><a href="#AWS-Migration-Hub" class="headerlink" title="AWS Migration Hub"></a>AWS Migration Hub</h3><p>AWS Migration Hub 提供了一个中心位置来跟踪和管理整个迁移过程。</p><h3 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h3><p>这包括一系列物理设备，用于大数据量的迁移，以及边缘计算和存储。</p><h3 id="AWS-Transfer-Family"><a href="#AWS-Transfer-Family" class="headerlink" title="AWS Transfer Family"></a>AWS Transfer Family</h3><p>提供安全、全面的文件传输服务，支持标准协议，如SFTP、FTPS和FTP。</p><h2 id="联网和内容分发"><a href="#联网和内容分发" class="headerlink" title="联网和内容分发"></a>联网和内容分发</h2><h3 id="AWS-Client-VPN"><a href="#AWS-Client-VPN" class="headerlink" title="AWS Client VPN"></a>AWS Client VPN</h3><p>这是一种托管的VPN服务，可为用户提供安全的远程访问。</p><h3 id="Amazon-CloudFront-1"><a href="#Amazon-CloudFront-1" class="headerlink" title="Amazon CloudFront"></a>Amazon CloudFront</h3><p>CloudFront 是一种全球内容分发网络(CDN)服务，它加速了网站和其他web内容的分发。</p><h3 id="AWS-Direct-Connect"><a href="#AWS-Direct-Connect" class="headerlink" title="AWS Direct Connect"></a>AWS Direct Connect</h3><p>通过 Direct Connect，用户可以在AWS和自己的数据中心之间建立私有网络连接。</p><h3 id="弹性负载均衡（ELB）"><a href="#弹性负载均衡（ELB）" class="headerlink" title="弹性负载均衡（ELB）"></a>弹性负载均衡（ELB）</h3><p>ELB 自动分发进入的应用程序流量，提高应用的可用性和容错能力。</p><h3 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h3><p>这是一种服务，可以提高用户向全球用户提供应用程序的性能。</p><h3 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h3><p>PrivateLink 提供了一种安全的连接方式，将AWS服务和VPC、本地网络连接起来。</p><h3 id="Amazon-Route-53"><a href="#Amazon-Route-53" class="headerlink" title="Amazon Route 53"></a>Amazon Route 53</h3><p>这是一种可扩展的云DNS服务，用于域名解析和路由互联网流量。</p><h3 id="AWS-Site-to-Site-VPN"><a href="#AWS-Site-to-Site-VPN" class="headerlink" title="AWS Site-to-Site VPN"></a>AWS Site-to-Site VPN</h3><p>通过 Site-to-Site VPN，用户可以将本地网络安全地连接到AWS VPC。</p><h3 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h3><p>Transit Gateway 简化了网络架构，允许不同的VPC和本地网络通过单一网关连接。</p><h3 id="Amazon-VPC"><a href="#Amazon-VPC" class="headerlink" title="Amazon VPC"></a>Amazon VPC</h3><p>Amazon VPC 允许用户在AWS云中启动AWS资源，提供了可控的网络环境。</p><h2 id="安全性、身份与合规性"><a href="#安全性、身份与合规性" class="headerlink" title="安全性、身份与合规性"></a>安全性、身份与合规性</h2><h3 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h3><p>这是一个资源门户，提供有关AWS合规性和安全性文档的访问。</p><h3 id="AWS-Audit-Manager"><a href="#AWS-Audit-Manager" class="headerlink" title="AWS Audit Manager"></a>AWS Audit Manager</h3><p>Audit Manager 帮助用户自动化合规性审计过程，简化了审计工作。</p><h3 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h3><p>ACM 用于轻松创建、管理和部署SSL/TLS证书，保障网站和应用的安全。</p><h3 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h3><p>CloudHSM 提供了硬件安全模块(HSM)设备，以增强数据加密和密钥管理的安全性。</p><h3 id="Amazon-Cognito"><a href="#Amazon-Cognito" class="headerlink" title="Amazon Cognito"></a>Amazon Cognito</h3><p>Cognito 提供用户身份和数据同步服务，支持移动和网络应用程序的用户认证。</p><h3 id="Amazon-Detective"><a href="#Amazon-Detective" class="headerlink" title="Amazon Detective"></a>Amazon Detective</h3><p>Amazon Detective 是一种分析服务，用于调查和识别安全问题和可疑活动。</p><h3 id="AWS-Directory-Service"><a href="#AWS-Directory-Service" class="headerlink" title="AWS Directory Service"></a>AWS Directory Service</h3><p>这个服务为AWS资源提供了Microsoft Active Directory (AD)的实现。</p><h3 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h3><p>Firewall Manager 简化了AWS账户内防火墙规则的管理和维护。</p><h3 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h3><p>GuardDuty 是一种智能威胁检测服务，保护AWS账户和工作负载免受恶意活动。</p><h3 id="AWS-IAM-Identity-Center-AWS-Single-Sign-On"><a href="#AWS-IAM-Identity-Center-AWS-Single-Sign-On" class="headerlink" title="AWS IAM Identity Center (AWS Single Sign-On)"></a>AWS IAM Identity Center (AWS Single Sign-On)</h3><p>提供单点登录(SSO)服务，使用户可以方便地访问AWS和第三方应用程序。</p><h3 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h3><p>IAM 允许用户管理对AWS服务和资源的访问权限。</p><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><p>Inspector 是一种自动化安全评估服务，帮助改善应用程序的安全性和合规性。</p><h3 id="AWS-Key-Management-Service-AWS-KMS"><a href="#AWS-Key-Management-Service-AWS-KMS" class="headerlink" title="AWS Key Management Service (AWS KMS)"></a>AWS Key Management Service (AWS KMS)</h3><p>KMS 提供了创建和控制加密密钥的能力，用于加密数据。</p><h3 id="Amazon-Macie"><a href="#Amazon-Macie" class="headerlink" title="Amazon Macie"></a>Amazon Macie</h3><p>Macie 使用机器学习和模式匹配来识别和保护敏感数据。</p><h3 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h3><p>这是一种防火墙服务，用于保护VPC网络。</p><h3 id="AWS-Resource-Access-Manager-AWS-RAM"><a href="#AWS-Resource-Access-Manager-AWS-RAM" class="headerlink" title="AWS Resource Access Manager (AWS RAM)"></a>AWS Resource Access Manager (AWS RAM)</h3><p>RAM 允许用户共享AWS资源，实现跨账户资源共享。</p><h3 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h3><p>Secrets Manager 用于管理、检索和轮换数据库凭证、API密钥和其他机密。</p><h3 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h3><p>Security Hub 提供了一个集中的安全和合规性视图，跨多个AWS服务聚合安全性数据。</p><h3 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h3><p>Shield 是一种DDoS保护服务，保护AWS资源免受DDoS攻击。</p><h3 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h3><p>AWS WAF (Web Application Firewall) 是一种帮助保护 Web 应用程序或 API 免受网络攻击的服务。它可以过滤、监控和控制传入和传出的 HTTP(S) 流量。AWS WAF 提供了自定义的规则集，可以用来阻止常见的网络攻击，如 SQL 注入和跨站脚本 (XSS)。</p><h3 id="无服务器服务"><a href="#无服务器服务" class="headerlink" title="无服务器服务"></a>无服务器服务</h3><h4 id="AWS-AppSync-1"><a href="#AWS-AppSync-1" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><p>AWS AppSync 是一种托管的 GraphQL 服务，用于构建 API，使应用程序能够安全地访问、操纵和组合来自一个或多个数据源的数据。它支持实时数据同步和离线数据访问，适用于构建复杂的数据驱动应用程序。</p><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><p>AWS Fargate 是一种无服务器计算引擎，用于 Amazon ECS 和 EKS，让用户无需管理服务器即可运行容器。Fargate 自动管理容器的扩展和基础设施，使得容器化应用程序的部署和管理更加简便。</p><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><p>AWS Lambda 是一种事件驱动的计算服务，可运行代码以响应事件并自动管理计算资源。Lambda 可以用于构建各种应用程序和后端服务，只需上传代码，Lambda 即可为其分配资源并运行。</p><h3 id="存储服务"><a href="#存储服务" class="headerlink" title="存储服务"></a>存储服务</h3><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><p>AWS Backup 是一种集中式备份服务，可用于跨 AWS 服务备份数据。它提供了自动化的解决方案，用于备份 AWS 云中的数据，以及跨多个服务的备份管理和监控。</p><h4 id="Amazon-Elastic-Block-Store-Amazon-EBS"><a href="#Amazon-Elastic-Block-Store-Amazon-EBS" class="headerlink" title="Amazon Elastic Block Store (Amazon EBS)"></a>Amazon Elastic Block Store (Amazon EBS)</h4><p>Amazon EBS 提供高性能块存储，适用于 Amazon EC2 实例。EBS 卷用于持久存储，适用于数据库、文件系统等场景，提供高吞吐量和低延迟。</p><h4 id="Amazon-Elastic-File-System-Amazon-EFS"><a href="#Amazon-Elastic-File-System-Amazon-EFS" class="headerlink" title="Amazon Elastic File System (Amazon EFS)"></a>Amazon Elastic File System (Amazon EFS)</h4><p>Amazon EFS 提供了一种简单、可扩展的文件存储，适用于 Linux-based 的 Amazon EC2 实例。EFS 可以用于多种应用程序，支持高并发和高吞吐量。</p><h4 id="Amazon-FSx"><a href="#Amazon-FSx" class="headerlink" title="Amazon FSx"></a>Amazon FSx</h4><p>Amazon FSx 提供了多种完全托管的文件系统选项，包括适用于 Windows 文件服务器和 Lustre。FSx 为特定的工作负载和应用程序提供了优化的文件存储。</p><h4 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h4><p>Amazon S3 (Simple Storage Service) 是一种对象存储服务，提供了高度可扩展、持久、安全和低成本的存储解决方案。它广泛用于数据备份、存档、大数据分析等。</p><h4 id="Amazon-S3-Glacier"><a href="#Amazon-S3-Glacier" class="headerlink" title="Amazon S3 Glacier"></a>Amazon S3 Glacier</h4><p>Amazon S3 Glacier 是一种低成本的存储服务，用于数据归档和长期备份。提供了高耐久性的存储，但访问时间较长，适合不经常访问的数据。</p><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><p>是一种混合云存储服务，它允许您在本地环境和 AWS 云之间无缝地连接。这项服务主要用于数据备份、存档、灾难恢复和移动数据到 AWS 云。它支持三种不同类型的网关：文件网关、卷网关和磁带网关，每种都有其特定的用途。</p><ol><li><strong>文件网关</strong>：允许您将文件存储在 Amazon S3 中，同时保持本地存储的访问方式。它支持 NFS 和 SMB 协议，适用于文件共享、数据湖和备份。</li><li><strong>卷网关</strong>：提供两种模式，存储卷和缓存卷。存储卷模式将您的数据存储在 AWS 云中，同时保留本地的一个副本。缓存卷模式则将您的主数据集保留在 AWS 云中，只缓存经常访问的数据。</li><li><strong>磁带网关</strong>：用于替代物理磁带基础设施，将磁带存储虚拟化。您可以使用它来备份数据并将其存储在 AWS 云中，同时保持与现有磁带备份应用程序的兼容性。</li></ol><p>AWS Storage Gateway 通过这些功能，帮助企业实现云存储的优势，同时减少对本地存储资源的需求。它的主要优点包括成本效率、灵活的存储选项、简化的数据管理和提高的数据安全性。</p><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>是一种用于确定各种用户或系统进程是否有权访问特定资源的方式。它是计算机安全和网络管理中常用的概念。ACL 通常用于文件系统、数据库、网络设备等，以控制对文件、目录、数据库记录、网络连接等的访问权限。</p><p>一个 ACL 包含一系列的访问控制条目（ACEs）。每个 ACE 指定了一个主体（可以是用户、用户组、或系统进程）和该主体对于特定对象的访问权限。这些权限可以包括读取、写入、执行等操作。</p><p>例如，在文件系统中，一个 ACL 可以指定某个用户可以读取一个文件，但不能修改它。在网络环境中，ACL 可以用来控制哪些IP地址可以访问网络中的特定设备。</p><p>ACL 的主要作用包括：</p><p>保护敏感数据：通过限制对敏感信息的访问，来保护数据的安全性和隐私。</p><p>最小权限原则：确保用户和进程只有完成其任务所必需的最小权限，以减少潜在的安全风险。</p><p>权限管理：提供一种灵活的方式来指定和管理不同用户和用户组对资源的访问权限。</p><p>审计和合规性：通过记录和监控对资源的访问尝试，帮助组织遵守法规要求，并进行安全审计。</p><p>不同的系统和应用可能会有不同的 ACL 实现方式，但它们的核心目的都是为了保护资源不被未授权访问，并确保资源的安全和完整性。</p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="Study Note" scheme="https://kalyan-zitiu.github.io/categories/Basic/Study-Note/"/>
    
    
    <category term="SAA" scheme="https://kalyan-zitiu.github.io/tags/SAA/"/>
    
  </entry>
  
</feed>
