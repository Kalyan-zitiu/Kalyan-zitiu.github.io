<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kalyan的小书房</title>
  <icon>https://www.gravatar.com/avatar/26add54e467101c6779c59a0ed4ee504</icon>
  <subtitle>Kalyan is working hard</subtitle>
  <link href="https://kalyan-zitiu.github.io/atom.xml" rel="self"/>
  
  <link href="https://kalyan-zitiu.github.io/"/>
  <updated>2024-07-30T06:48:06.012Z</updated>
  <id>https://kalyan-zitiu.github.io/</id>
  
  <author>
    <name>Kalyan</name>
    <email>3148862192@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于containerd的kubernetes集群建设</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/26/%E5%9F%BA%E4%BA%8Econtainerd%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4%E5%BB%BA%E8%AE%BE/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/26/%E5%9F%BA%E4%BA%8Econtainerd%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4%E5%BB%BA%E8%AE%BE/</id>
    <published>2024-07-26T01:40:58.000Z</published>
    <updated>2024-07-30T06:48:06.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="节点资源规划（仅学习）"><a href="#节点资源规划（仅学习）" class="headerlink" title="节点资源规划（仅学习）"></a>节点资源规划（仅学习）</h3><p>资源规划：一个master，两个work（非测试不建议这种模式，无高可用）<br>master： 16c,32g,200G,200G(空)<br>work : 16c,32g,200G,200G(空)</p><h3 id="选择安装工具"><a href="#选择安装工具" class="headerlink" title="选择安装工具"></a>选择安装工具</h3><ol><li>首先DNS更正223.5.5.5，223.6.6.6</li><li>选择后国内清华源的K8s软件库：</li></ol><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/kubernetes/">https://mirrors.tuna.tsinghua.edu.cn/help/kubernetes/</a></li></ul><ol start="3"><li>选择containerd运行时</li><li>安装ipvs</li></ol><p>个人理解：环境主要在三节点上有kubelet，kubectl，主节点多一个初始化的kubeadm。然后主节点用kubeadm进行初始化主节点，然后进行containerd运行时进行组件的拉取和运行。组成一个集群。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>各种安装过程我们跳过哈,然后我们深度聊一聊一些环境的设置</p><h4 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h4><h5 id="内核参数调整"><a href="#内核参数调整" class="headerlink" title="内核参数调整"></a>内核参数调整</h5><h6 id="什么是内核参数呢，会影响什么"><a href="#什么是内核参数呢，会影响什么" class="headerlink" title="什么是内核参数呢，会影响什么"></a>什么是内核参数呢，会影响什么</h6><p>内核参数是配置Linux内核行为的设置。这些参数控制系统的各种功能，如内存管理、网络设置、文件系统行为等。内核参数通常通过/etc/sysctl.conf文件进行配置，并通过sysctl命令加载和应用。常用的内核参数请看<br><a href="https://blog.zitiu.top/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/">Linux从核心到边缘 | Kalyan的小书房 (zitiu.top)</a></p><h6 id="需要调整的内核参数"><a href="#需要调整的内核参数" class="headerlink" title="需要调整的内核参数"></a>需要调整的内核参数</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">0</span>  <span class="comment"># 减少swap分区使用</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward</span> <span class="string">=</span> <span class="number">1</span> <span class="comment"># 允许linux内核将网络流量从一个网络接口转发到另一个网络接口</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables=1</span> <span class="comment"># 启用 bridge-nf-call-iptables</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span> <span class="comment"># 启用 IP 转发</span></span><br></pre></td></tr></table></figure><p>这里通常会有一个问题，当你sysctl -p采用的时候可能会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl: cannot <span class="built_in">stat</span> /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory</span><br><span class="line">sysctl: cannot <span class="built_in">stat</span> /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</span><br></pre></td></tr></table></figure><p>这个时候你可以</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用 bridge-nf-call-iptables</span></span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"><span class="built_in">echo</span> 1 | sudo <span class="built_in">tee</span> /proc/sys/net/bridge/bridge-nf-call-iptables</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-iptables=1&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 IP 转发</span></span><br><span class="line"><span class="built_in">echo</span> 1 | sudo <span class="built_in">tee</span> /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward=1&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p>最后进行微调</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个文件，将需要的内核模块写入其中，以便在系统启动时自动加载这些模块</span></span><br><span class="line"><span class="built_in">tee</span> /etc/modules-load.d/k8s.conf &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># netfilter 模块，允许 iptables 检查桥接流量</span></span><br><span class="line">br_netfilter</span><br><span class="line"><span class="comment"># containerd 文件系统支持</span></span><br><span class="line">overlay</span><br><span class="line"><span class="comment"># IPVS (IP Virtual Server) 模块，用于负载均衡</span></span><br><span class="line">ip_vs</span><br><span class="line"><span class="comment"># 轮叫调度算法</span></span><br><span class="line">ip_vs_rr</span><br><span class="line"><span class="comment"># 加权轮叫调度算法</span></span><br><span class="line">ip_vs_wrr</span><br><span class="line"><span class="comment"># 源地址散列调度算法</span></span><br><span class="line">ip_vs_sh</span><br><span class="line"><span class="comment"># 连接跟踪模块，用于跟踪网络连接状态</span></span><br><span class="line">nf_conntrack</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录以存放模块加载脚本</span></span><br><span class="line"><span class="built_in">mkdir</span> -vp /etc/modules.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个脚本文件，立即加载所需的内核模块</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/modules.d/k8s.modules &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string"># 允许 iptables 检查桥接流量</span></span><br><span class="line"><span class="string">modprobe -- br_netfilter</span></span><br><span class="line"><span class="string"># containerd 文件系统支持</span></span><br><span class="line"><span class="string">modprobe -- overlay</span></span><br><span class="line"><span class="string"># IPVS 模块，用于负载均衡</span></span><br><span class="line"><span class="string">modprobe -- ip_vs</span></span><br><span class="line"><span class="string"># 轮叫调度算法</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_rr</span></span><br><span class="line"><span class="string"># 加权轮叫调度算法</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_wrr</span></span><br><span class="line"><span class="string"># 源地址散列调度算法</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_sh</span></span><br><span class="line"><span class="string"># 连接跟踪模块，用于跟踪网络连接状态</span></span><br><span class="line"><span class="string">modprobe -- nf_conntrack</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给脚本文件赋予执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> 755 /etc/modules.d/k8s.modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本，立即加载所需的内核模块</span></span><br><span class="line">bash /etc/modules.d/k8s.modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证内核模块是否加载成功，查看加载的模块列表中是否包含 ip_vs 和 nf_conntrack 模块</span></span><br><span class="line">lsmod | grep -e ip_vs -e nf_conntrack</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用 sysctl 配置，确保所有内核参数设置立即生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启系统，确保所有配置在系统重启后自动生效</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h5 id="什么是swap分区-为什么要删除"><a href="#什么是swap分区-为什么要删除" class="headerlink" title="什么是swap分区,为什么要删除."></a>什么是swap分区,为什么要删除.</h5><ul><li>你可以把swap分区简单理解成是为了分担RAM的负担的这么一个作用,你可以想象一下你有一个书桌,你工作的时候,为了快速获取资料,你会在书桌上堆满书本,这个时候swap就像书架一样,在书架取书会有点慢,但是你起码有位置放书.</li></ul><ul><li><p>那么为什么我们要在kubernetes中要删除呢,继续刚刚的比喻,现在一个研究馆内,有很多书桌(节点),管理人员(k8s调度器)会根据每个人的书桌的容量进行任务的合理分配.如果启动了书架(swap),管理人员可能不知道,你书桌上的实际容量,要是书桌(RAM)把大量资源放到了书架(swap)上,管理人员(调度器)看你的书桌(RAM)空闲,把大量的资源工作丢给你,可能会导致书桌(RAM)的坍塌</p></li><li><p>一句话:k8s调度器无法知道swap分区里面的情况.</p></li></ul><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><p>这个就不说了,主要是为了更好的后续node以及pod会有自己的网络体系,为了适配关掉最好.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">disable</span> &amp;&amp; systemctl <span class="built_in">disable</span> ufw</span><br><span class="line">swapoff -a &amp;&amp; sed -i <span class="string">&#x27;s|^/swap.img|#/swap.ing|g&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><h5 id="containerd设置-配置runtime-endpoint"><a href="#containerd设置-配置runtime-endpoint" class="headerlink" title="containerd设置-配置runtime-endpoint"></a>containerd设置-配置runtime-endpoint</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># containerd - 运行时设置,这一步不能出错</span></span><br><span class="line">crictl config runtime-endpoint /run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>要是出现无法连接的情况就检查三个地方</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否有/etc/containerd/config.toml 用于配置管理containerd容器运行时守护进程的行为。</span></span><br><span class="line"><span class="built_in">mkdir</span> -vp /etc/containerd/</span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 将配置文件中所有出现的 k8s.gcr.io 替换为 registry.cn-hangzhou.aliyuncs.com/google_containers</span></span><br><span class="line">sed -i <span class="string">&quot;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g&quot;</span>  /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 这里有点问题，需要提前把SystemdCgroup = false删除掉，否则会有重复定义的错误。</span></span><br><span class="line">sed -i <span class="string">&#x27;/containerd.runtimes.runc.options/a\ \ \ \ \ \ \ \ \ \ \ \ SystemdCgroup = true&#x27;</span> /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 修改版</span></span><br><span class="line">CONFIG_FILE=<span class="string">&quot;/etc/containerd/config.toml&quot;</span>; grep -q <span class="string">&#x27;SystemdCgroup&#x27;</span> <span class="string">&quot;<span class="variable">$CONFIG_FILE</span>&quot;</span> &amp;&amp; sed -i <span class="string">&#x27;s/SystemdCgroup =.*/SystemdCgroup = true/&#x27;</span> <span class="string">&quot;<span class="variable">$CONFIG_FILE</span>&quot;</span> || sed -i <span class="string">&#x27;/containerd.runtimes.runc.options/a\ \ \ \ \ \ \ \ \ \ \ \ SystemdCgroup = true&#x27;</span> <span class="string">&quot;<span class="variable">$CONFIG_FILE</span>&quot;</span></span><br><span class="line"><span class="comment"># 将配置文件中所有出现的 https://registry-1.docker.io 替换为 https://xlx9erfu.mirror.aliyuncs.com。</span></span><br><span class="line">sed -i <span class="string">&quot;s#https://registry-1.docker.io#https://xlx9erfu.mirror.aliyuncs.com#g&quot;</span>  /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 是否有/etc/crictl.yaml</span></span><br><span class="line">runtime-endpoint: <span class="string">&quot;unix:///run/containerd/containerd.sock&quot;</span></span><br><span class="line">image-endpoint: <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">timeout</span>: 0</span><br><span class="line">debug: <span class="literal">false</span></span><br><span class="line">pull-image-on-create: <span class="literal">false</span></span><br><span class="line">disable-pull-on-run: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否有/run/containerd/containerd.sock</span></span><br></pre></td></tr></table></figure><h3 id="初始化主节点"><a href="#初始化主节点" class="headerlink" title="初始化主节点"></a>初始化主节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产配置模板，自己把imageRepository改成自己加速的镜像源。</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm.yaml</span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line">kubeadm init --config=kubeadm.yaml --v=5</span><br><span class="line"><span class="comment"># 查看镜像列表</span></span><br><span class="line">kubeadm config images list</span><br><span class="line"><span class="comment"># 然后进行拉取</span></span><br><span class="line">crictl pull</span><br></pre></td></tr></table></figure><p>ps:一定要仔细配置kubeadm。</p><p>要是containerd有问题的话，修改过config.toml，记得restart一下然后记得</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm reset -f --cri-socket unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>ps:修改镜像源后记得修改一下containerd里面的pause的镜像源。</p><p>给个样板在这里：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- <span class="built_in">groups</span>:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 10.70.49.131 <span class="comment"># 必填</span></span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///run/containerd/containerd.sock <span class="comment">#最好加上unix://</span></span><br><span class="line">  imagePullPolicy: IfNotPresent <span class="comment"># 可以忽略镜像拉取，后续可以手动拉</span></span><br><span class="line">  name: masternode-1 <span class="comment"># 必填</span></span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: <span class="comment"># dns有点ex，注意镜像源</span></span><br><span class="line">  <span class="built_in">type</span>: CoreDNS</span><br><span class="line">  imageRepository: k8s.m.daocloud.io/coredns</span><br><span class="line">  imageTag: v1.10.1</span><br><span class="line">etcd:</span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: k8s.m.daocloud.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs <span class="comment"># 开启ipvs模式</span></span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://docs.projectcalico.org/v3.18/manifests/calico.yaml</span><br></pre></td></tr></table></figure><p>然后自己配置一下</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240730105948262.png" alt="image-20240730105948262"></p><p>然后apply一下。等待跑起来</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240730143740906.png" alt="image-20240730143740906"></p><p>哪个拉不起来就去对应的controlby，或者直接deploy上修改image。然后正常来说的话就基本node全部ready</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240730143852876.png" alt="image-20240730143852876"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;h3 id=&quot;节点资源规划（仅学习）&quot;&gt;&lt;a href=&quot;#节点资源规划（仅学习）&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://kalyan-zitiu.github.io/categories/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="https://kalyan-zitiu.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes存储</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/25/Kubernetes%E5%AD%98%E5%82%A8/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/25/Kubernetes%E5%AD%98%E5%82%A8/</id>
    <published>2024-07-25T03:06:19.000Z</published>
    <updated>2024-07-25T03:58:08.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>  解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod Spec 中。</p><h3 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h3><p>  是 Kubernetes 中一种特殊类型的账户，用于在集群内为 Pod 提供身份验证和授权。它主要用于管理集群内的 API 请求以及访问控制，是一种较为安全和高效的认证方式。</p><h4 id="功能与作用"><a href="#功能与作用" class="headerlink" title="功能与作用"></a>功能与作用</h4><ol><li><p><strong>身份验证</strong><br>Service Account 为 Pod 提供唯一的身份标识，使得集群内的服务可以识别并验证该 Pod 的身份。</p></li><li><p><strong>权限控制</strong><br>通过绑定 Role 或 ClusterRole，Service Account 可以被赋予特定的权限，以便对 Kubernetes API 进行访问和操作。这种精细化的权限控制可以有效提升集群的安全性。</p></li><li><p><strong>隔离</strong><br>不同的 Pod 可以使用不同的 Service Account，从而在权限和资源访问方面实现隔离，避免不必要的权限扩散。</p></li></ol><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li><p><strong>创建 Service Account</strong><br>创建一个 Service Account 时，Kubernetes 会自动生成一个与之相关的 Secret，其中包含用于身份验证的 token。</p></li><li><p><strong>将 Service Account 关联到 Pod</strong><br>在 Pod 定义中，可以指定使用某个 Service Account。Kubernetes 会将关联的 token 注入到该 Pod 中，以便 Pod 在需要时使用。</p></li><li><p><strong>访问控制</strong><br>Service Account 可以与 Role 或 ClusterRole 绑定，确定其可以执行哪些操作。RoleBinding 或 ClusterRoleBinding 用于将 Service Account 与具体的权限关联起来。</p></li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个创建 Service Account 并在 Pod 中使用的示例：</p><h5 id="创建-Service-Account"><a href="#创建-Service-Account" class="headerlink" title="创建 Service Account"></a>创建 Service Account</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-account</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure><h5 id="创建-Role-和-RoleBinding"><a href="#创建-Role-和-RoleBinding" class="headerlink" title="创建 Role 和 RoleBinding"></a>创建 Role 和 RoleBinding</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-account</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><h5 id="在-Pod-中使用-Service-Account"><a href="#在-Pod-中使用-Service-Account" class="headerlink" title="在 Pod 中使用 Service Account"></a>在 Pod 中使用 Service Account</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">my-service-account</span>  <span class="comment"># 指定使用的 Service Account</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-image</span></span><br></pre></td></tr></table></figure><h3 id="Qpaque"><a href="#Qpaque" class="headerlink" title="Qpaque"></a>Qpaque</h3><p>Opaque 类型的数据是一个 map 类型，要求 value 是 base64 编码格式：</p><h4 id="Map-结构"><a href="#Map-结构" class="headerlink" title="Map 结构"></a>Map 结构</h4><p>Opaque 类型的数据使用 map 结构，这意味着数据以键值对的形式存储。每个键是一个唯一的字符串标识符，对应的值是实际的数据内容。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo -n &quot;admin&quot; | base64</span><br><span class="line">YWRtaW4=</span><br><span class="line">$ echo -n &quot;1f2d1e2e67df&quot; | base64</span><br><span class="line">MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure><p>然后创建secrets.yml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">   name: mysecret</span><br><span class="line"><span class="built_in">type</span>: Qpaque</span><br><span class="line">data:</span><br><span class="line">  password: MWYyZDFlMmU2N2Rm</span><br><span class="line">  username: YWRtaW4=</span><br></pre></td></tr></table></figure><p>创建后可以用Volume或者环境变量方式来使用。</p><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    name: db  <span class="comment"># 为 Pod 添加标签，便于识别和选择</span></span><br><span class="line">  name: db    <span class="comment"># Pod 的名称</span></span><br><span class="line">spec:</span><br><span class="line">  volumes:  <span class="comment"># 定义 Pod 使用的卷</span></span><br><span class="line">  - name: secrets  <span class="comment"># 卷的名称，可以在 containers 中引用</span></span><br><span class="line">    secret:  </span><br><span class="line">      secretName: mysecret  <span class="comment"># 引用 Kubernetes 中的 Secret 资源，名称为 mysecret</span></span><br><span class="line">  containers:  <span class="comment"># 定义 Pod 中的容器</span></span><br><span class="line">  - image: gcr.io/my_project_id/pg:v1  <span class="comment"># 容器使用的镜像，来自指定的镜像仓库</span></span><br><span class="line">    name: db  <span class="comment"># 容器的名称</span></span><br><span class="line">    volumeMounts:  <span class="comment"># 将定义的卷挂载到容器中</span></span><br><span class="line">    - name: secrets  <span class="comment"># 指定挂载的卷名称，需要与上面 volumes 定义的名称一致</span></span><br><span class="line">      mountPath: <span class="string">&quot;/etc/secrets&quot;</span>  <span class="comment"># 卷挂载到容器中的路径</span></span><br><span class="line">      readOnly: <span class="literal">true</span>  <span class="comment"># 将卷设置为只读，防止容器修改 Secret</span></span><br><span class="line">    ports:</span><br><span class="line">    - name: <span class="built_in">cp</span>  <span class="comment"># 端口的名称</span></span><br><span class="line">      containerPort: 5432  <span class="comment"># 容器内部的端口号，数据库服务的默认端口</span></span><br><span class="line">      hostPort: 5432  <span class="comment"># 主机上的端口号，映射到容器的 5432 端口</span></span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1  <span class="comment"># 指定 Kubernetes API 的版本</span></span><br><span class="line">kind: Deployment  <span class="comment"># 指定资源类型为 Deployment</span></span><br><span class="line">metadata:</span><br><span class="line">  name: wordpress-deployment  <span class="comment"># Deployment 的名称</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: 2  <span class="comment"># 指定副本数量，即将创建两个 Pod</span></span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: RollingUpdate  <span class="comment"># 使用滚动更新策略，逐步更新 Pods</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: wordpress  <span class="comment"># 添加标签，用于选择和管理 Pods</span></span><br><span class="line">        visualize: <span class="string">&quot;true&quot;</span>  <span class="comment"># 额外的标签，用于标识和可视化</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: <span class="string">&quot;wordpress&quot;</span>  <span class="comment"># 容器的名称</span></span><br><span class="line">        image: <span class="string">&quot;wordpress&quot;</span>  <span class="comment"># 容器使用的镜像</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80  <span class="comment"># 容器内部的端口号，WordPress 的默认 HTTP 端口</span></span><br><span class="line">        <span class="built_in">env</span>:  <span class="comment"># 定义环境变量</span></span><br><span class="line">        - name: WORDPRESS_DB_USER  <span class="comment"># 环境变量名称</span></span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: mysecret  <span class="comment"># 引用的 Secret 名称</span></span><br><span class="line">              key: username  <span class="comment"># Secret 中的键，用于获取对应的值</span></span><br><span class="line">        - name: WORDPRESS_DB_PASSWORD  <span class="comment"># 环境变量名称</span></span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: mysecret  <span class="comment"># 引用的 Secret 名称</span></span><br><span class="line">              key: password  <span class="comment"># Secret 中的键，用于获取对应的值</span></span><br></pre></td></tr></table></figure><h3 id="kubernetes-io-dockerconfigjson"><a href="#kubernetes-io-dockerconfigjson" class="headerlink" title="kubernetes.io/dockerconfigjson"></a>kubernetes.io/dockerconfigjson</h3><p><code>dockerconfigjson</code> 是一种 Secret 类型，用于存储 Docker 镜像仓库的认证信息。它主要用于配置私有 Docker 仓库的访问权限，使得 Kubernetes 可以拉取私有仓库中的镜像。</p><h4 id="创建-Docker-认证文件"><a href="#创建-Docker-认证文件" class="headerlink" title="创建 Docker 认证文件"></a>创建 Docker 认证文件</h4><p>首先，使用 Docker CLI 登录到私有镜像仓库。这个操作会生成一个包含认证信息的配置文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login &lt;your-private-registry&gt;</span><br></pre></td></tr></table></figure><p>此命令会提示你输入用户名和密码，并在你的主目录下生成一个 <code>~/.docker/config.json</code> 文件。这个文件包含 Docker 客户端的认证信息。</p><h4 id="查看-config-json-内容"><a href="#查看-config-json-内容" class="headerlink" title="查看 config.json 内容"></a>查看 <code>config.json</code> 内容</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;auths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;https://index.docker.io/v1/&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c3VwZXJzZWNyZXRwYXNzd29yZA==&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;HttpHeaders&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;User-Agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Docker-Client/19.03.12 (linux)&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="创建-Kubernetes-Secret"><a href="#创建-Kubernetes-Secret" class="headerlink" title="创建 Kubernetes Secret"></a>创建 Kubernetes Secret</h4><p>将 <code>config.json</code> 文件内容编码成 base64 格式，并创建一个 Secret。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic my-docker-registry-secret \</span><br><span class="line">    --from-file=.dockerconfigjson=/path/to/your/.docker/config.json \</span><br><span class="line">    --<span class="built_in">type</span>=kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure><h4 id="手动创建-Kubernetes-Secret"><a href="#手动创建-Kubernetes-Secret" class="headerlink" title="手动创建 Kubernetes Secret"></a>手动创建 Kubernetes Secret</h4><p>你也可以手动创建 <code>dockerconfigjson</code> 类型的 Secret。首先，获取 <code>config.json</code> 文件内容并进行 base64 编码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.docker/config.json | <span class="built_in">base64</span> -w 0</span><br></pre></td></tr></table></figure><p>将输出的 base64 编码结果放入一个 YAML 文件中：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-docker-registry-secret</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.dockerconfigjson:</span> <span class="string">&lt;base64-encoded-config.json&gt;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/dockerconfigjson</span></span><br></pre></td></tr></table></figure><h4 id="在-Pod-中使用-Secret"><a href="#在-Pod-中使用-Secret" class="headerlink" title="在 Pod 中使用 Secret"></a>在 Pod 中使用 Secret</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mycontainer</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&lt;your-private-registry&gt;/&lt;your-image&gt;:&lt;tag&gt;</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-docker-registry-secret</span></span><br></pre></td></tr></table></figure><h4 id="在-Deployment-中使用-Secret"><a href="#在-Deployment-中使用-Secret" class="headerlink" title="在 Deployment 中使用 Secret"></a>在 Deployment 中使用 Secret</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mycontainer</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&lt;your-private-registry&gt;/&lt;your-image&gt;:&lt;tag&gt;</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-docker-registry-secret</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Secret&quot;&gt;&lt;a href=&quot;#Secret&quot; class=&quot;headerlink&quot; title=&quot;Secret&quot;&gt;&lt;/a&gt;Secret&lt;/h2&gt;&lt;p&gt;  解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod Spec</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>排错杂记（pod error）</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/24/%E6%8E%92%E9%9A%9C%E6%97%A5%E5%BF%97%EF%BC%88updating%EF%BC%89/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/24/%E6%8E%92%E9%9A%9C%E6%97%A5%E5%BF%97%EF%BC%88updating%EF%BC%89/</id>
    <published>2024-07-24T02:44:28.000Z</published>
    <updated>2024-07-24T08:28:41.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="尝试排错"><a href="#尝试排错" class="headerlink" title="尝试排错"></a>尝试排错</h3><p>起因是拉起某个pod的时候持续不断的错误边拉边寄，显示的不是image问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104653156.png" alt="image-20240724104653156"></p><p>尝试describe一下，发现调度，拉取，创建，启动似乎都正常</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104802500.png" alt="image-20240724104802500"></p><p>这个时候就得去看日志kubectl log一下，</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104835975.png" alt="image-20240724104835975"></p><p>？？？timeout？？？kubectl 正常能get不至于访问不到api，api是包正常的。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724104918625.png" alt="image-20240724104918625"></p><p>那就是网络问题，先看一下插件，插件也正常。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105000612.png" alt="image-20240724105000612"></p><p>再看DNS，似乎有点问题，丢了master3的conredns？？？</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105033529.png" alt="image-20240724105033529"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105351232.png" alt="image-20240724105351232"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724105355465.png" alt="image-20240724105355465"></p><p>但是查询后这个pod的是属于master1的pod所以不是dns的问题，缺一个的问题后面再解决。<br>按着尝试手动再吃连接api服务器,草pod fail了，所以用不了，先标记</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it kcollie-pre-hook-install-crds-bdb4g -n kcollie-system -- /bin/sh</span><br><span class="line">curl -k https://10.233.0.1:433</span><br></pre></td></tr></table></figure><p>再check一下kube-system的pod</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724110135451.png" alt="image-20240724110135451"></p><p>md草了，有屎啊，节点二怎么就timeout了，相继的节点一三也爆屎了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724111053894.png" alt="image-20240724111053894"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724111922571.png" alt="image-20240724111922571"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724112010432.png" alt="image-20240724112010432"></p><p>看一下节点情况，感觉可以rollout整个kube-system，完蛋，怎么查个pod状态，查到整个kube崩了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724112656575.png" alt="image-20240724112656575"></p><p>直接rollout所有</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启所有 Deployments</span></span><br><span class="line"><span class="keyword">for</span> deployment <span class="keyword">in</span> $(kubectl get deployments -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart deployment <span class="variable">$deployment</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 StatefulSets</span></span><br><span class="line"><span class="keyword">for</span> statefulset <span class="keyword">in</span> $(kubectl get statefulsets -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart statefulset <span class="variable">$statefulset</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 DaemonSets</span></span><br><span class="line"><span class="keyword">for</span> daemonset <span class="keyword">in</span> $(kubectl get daemonsets -n kube-system -o jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  kubectl rollout restart daemonset <span class="variable">$daemonset</span> -n kube-system</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总算是起来了，然后有一个node还是not ready，估计是node3的某些pod还没好，但是报错还是</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724125055556.png" alt="image-20240724125055556"></p><p>不懂，node1的apiserver明明好好的，coredns也没问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240724130355768.png" alt="image-20240724130355768"></p><p>又死了，草啊啊啊啊啊啊啊啊啊啊。节点不知道为什么十分的不稳定，似乎不断崩溃重启，直接停机加内存。</p><p>估计上面的Error是不怎么影响的。。。。。。。。重启然后就没事了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;尝试排错&quot;&gt;&lt;a href=&quot;#尝试排错&quot; class=&quot;headerlink&quot; title=&quot;尝试排错&quot;&gt;&lt;/a&gt;尝试排错&lt;/h3&gt;&lt;p&gt;起因是拉起某个pod的时候持续不断的错误边拉边寄，显示的不是image问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    <category term="杂记" scheme="https://kalyan-zitiu.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="https://kalyan-zitiu.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kind基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/24/Kind/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/24/Kind/</id>
    <published>2024-07-24T01:58:31.000Z</published>
    <updated>2024-07-24T08:22:58.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KIND（Kubernetes-IN-Docker）"><a href="#KIND（Kubernetes-IN-Docker）" class="headerlink" title="KIND（Kubernetes IN Docker）"></a>KIND（Kubernetes IN Docker）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>KIND，全称“Kubernetes IN Docker”，是一个开源工具，用于在本地开发和测试 Kubernetes 集群。KIND 允许在 Docker 容器中运行 Kubernetes 集群，从而便于开发者快速创建和销毁 Kubernetes 集群，提升开发效率。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>在使用 KIND 之前，你需要确保以下软件已经正确安装：<br>Docker<br>kubectl<br>确保 Docker 已经启动，并且你的用户在 docker 组中，以便能够运行 Docker 命令而无需 sudo。</p><h4 id="安装-KIND"><a href="#安装-KIND" class="headerlink" title="安装 KIND"></a>安装 KIND</h4><p>在 Linux 环境中，可以通过以下命令获取和安装 KIND：</p><p>curl -Lo ./kind <a href="https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64">https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64</a><br>chmod +x ./kind<br>sudo mv ./kind /usr/local/bin/kind</p><h4 id="检查安装"><a href="#检查安装" class="headerlink" title="检查安装"></a>检查安装</h4><p>验证 KIND 是否安装成功：</p><p>kind –version<br>你应该看到类似 kind v0.11.1 的输出。</p><h3 id="创建-Kubernetes-集群"><a href="#创建-Kubernetes-集群" class="headerlink" title="创建 Kubernetes 集群"></a>创建 Kubernetes 集群</h3><h4 id="简单创建一个集群"><a href="#简单创建一个集群" class="headerlink" title="简单创建一个集群"></a>简单创建一个集群</h4><p>使用以下命令创建一个默认的 Kubernetes 集群：</p><p>kind create cluster<br>成功创建后，你会看到与集群相关的信息输出。</p><h4 id="自定义配置创建集群"><a href="#自定义配置创建集群" class="headerlink" title="自定义配置创建集群"></a>自定义配置创建集群</h4><p>为了更具定制化，可以使用 YAML 文件：</p><p>创建 kind-config.yaml 文件：</p><p>kind: Cluster<br>apiVersion: kind.x-k8s.io/v1alpha4<br>nodes:</p><ul><li>role: control-plane</li><li>role: worker</li><li>role: worker<br>使用以下命令创建集群：</li></ul><p>kind create cluster –config kind-config.yaml</p><h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><p>验证集群状态：</p><p>kubectl cluster-info –context kind-kind</p><h3 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h3><h4 id="部署应用到-KIND-集群"><a href="#部署应用到-KIND-集群" class="headerlink" title="部署应用到 KIND 集群"></a>部署应用到 KIND 集群</h4><p>创建一个名为 nginx-deployment.yaml 的文件：</p><p>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nginx-deployment<br>spec:<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx:1.14.2<br>        ports:<br>        - containerPort: 80<br>使用 kubectl 部署：</p><p>kubectl apply -f nginx-deployment.yaml</p><h4 id="验证部署"><a href="#验证部署" class="headerlink" title="验证部署"></a>验证部署</h4><p>查看部署的状态：</p><p>kubectl get deployments<br>查看 Pods 状态：</p><p>kubectl get pods</p><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><p>创建一个名为 nginx-service.yaml 的文件：</p><p>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: nginx-service<br>spec:<br>  selector:<br>    app: nginx<br>  ports:</p><ul><li>protocol: TCP<br>port: 80<br>targetPort: 80<br>type: LoadBalancer<br>使用 kubectl 暴露服务：</li></ul><p>kubectl apply -f nginx-service.yaml</p><h3 id="KIND的应用场景和作用"><a href="#KIND的应用场景和作用" class="headerlink" title="KIND的应用场景和作用"></a>KIND的应用场景和作用</h3><h4 id="开发和测试环境"><a href="#开发和测试环境" class="headerlink" title="开发和测试环境"></a>开发和测试环境</h4><p>在本地开发和测试 Kubernetes 应用，KIND 的特性让开发者可以快速创建和删除集群，大大提高了开发效率。</p><h4 id="CI-CD管道"><a href="#CI-CD管道" class="headerlink" title="CI/CD管道"></a>CI/CD管道</h4><p>在 CI/CD 管道中，KIND 可以在每次代码变更时快速创建一个新的 Kubernetes 集群用于测试，确保代码的稳定性和一致性。</p><h4 id="学习和培训"><a href="#学习和培训" class="headerlink" title="学习和培训"></a>学习和培训</h4><p>KIND 非常适合用于学习和培训，可以在本地快速搭建 Kubernetes 环境，使学习者掌握 Kubernetes 基本操作和概念。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>KIND 是基于 Docker 容器的，因此某些 Kubernetes 高级功能可能不完全支持。<br>偶尔你可能需要手动清理 Docker 容器和网络设置，特别是在多次创建和删除集群后。<br>不建议在生产环境中使用 KIND，它更适用于开发和测试用途。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>KIND 是一个非常方便的工具，可以帮助我们在本地快速搭建和管理 Kubernetes 集群。无论是开发测试、CI/CD 还是学习培训，KIND 都能发挥其巨大的作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KIND（Kubernetes-IN-Docker）&quot;&gt;&lt;a href=&quot;#KIND（Kubernetes-IN-Docker）&quot; class=&quot;headerlink&quot; title=&quot;KIND（Kubernetes IN Docker）&quot;&gt;&lt;/a&gt;KIND（Kub</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/23/Prometheus%E5%9F%BA%E7%A1%80/</id>
    <published>2024-07-23T08:10:02.000Z</published>
    <updated>2024-07-23T08:10:28.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>一个开源的监控和告警系统</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="多维数据模型"><a href="#多维数据模型" class="headerlink" title="多维数据模型"></a>多维数据模型</h4><ul><li>使用时间序列数据，每个序列有一个度量指标（metricname）和一组键值对（labels）标识，这样可以灵活对同一类进行细分。<h5 id="度量指标"><a href="#度量指标" class="headerlink" title="度量指标"></a>度量指标</h5></li><li>counter：计数器，用于记录累计值，例如请求次数。</li><li>gauge：测量值，可增可减，例如当前内存使用量。</li><li>histogram：直方图，用于记录值分布，例如请求延迟。</li><li>summary：摘要，用于统计分位数和总和，例如响应时间的分位数。</li></ul><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ul><li>一组键值对，用于对时间序列进行细分和区分。例如，监控一个 HTTP 请求的计数器可以通过标签区分不同的请求路径和状态码</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;200&quot;</span>&#125;</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, <span class="built_in">status</span>=<span class="string">&quot;500&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们有一个 Web 服务，它记录了每个请求的数量和响应时间。我们可以定义以下指标：</p><ol><li>记录请求数量的计数器：<ul><li>Metric Name: <code>http_requests_total</code></li><li>Labels: <code>method</code>, <code>handler</code>, <code>status</code></li></ul></li><li>记录响应时间的直方图：<ul><li>Metric Name: <code>http_request_duration_seconds</code></li><li>Labels: <code>method</code>, <code>handler</code></li></ul></li></ol><p>每次有新的请求进来，计数器和直方图都会更新。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;200&quot;</span>&#125; 1234</span><br><span class="line">http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, status=<span class="string">&quot;500&quot;</span>&#125; 56</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.1&quot;</span>&#125; 5</span><br><span class="line">http_request_duration_seconds_bucket&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/api/v1&quot;</span>, le=<span class="string">&quot;0.5&quot;</span>&#125; 50</span><br></pre></td></tr></table></figure><h4 id="支持PromQL"><a href="#支持PromQL" class="headerlink" title="支持PromQL"></a>支持PromQL</h4><p>查询所有 POST 请求的数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;method=&quot;POST&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询 <code>/api/v1</code> 接口的所有请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;handler=&quot;/api/v1&quot;&#125;)</span><br></pre></td></tr></table></figure><p>查询状态码为 200 的请求数量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promql</span><br><span class="line">复制代码</span><br><span class="line">sum(http_requests_total&#123;status=&quot;200&quot;&#125;)</span><br></pre></td></tr></table></figure><h5 id="优化使用标签"><a href="#优化使用标签" class="headerlink" title="优化使用标签"></a>优化使用标签</h5><ul><li><strong>标签数目不要过多</strong>：过多的标签会导致时间序列爆炸，影响性能。</li><li><strong>标签值尽量稳定</strong>：标签值变化太频繁会增加存储和查询负担。</li><li><strong>合理设计标签</strong>：确保标签的选择能够满足查询需求，同时不过度细化。</li></ul><h4 id="时间序列数据库"><a href="#时间序列数据库" class="headerlink" title="时间序列数据库"></a>时间序列数据库</h4><h5 id="TSDB-Prometheus自带时序数据库"><a href="#TSDB-Prometheus自带时序数据库" class="headerlink" title="TSDB Prometheus自带时序数据库"></a>TSDB Prometheus自带时序数据库</h5><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><p>高效写入：Prometheus 的 TSDB 能够每秒写入数百万个样本，适合高频数据采集。<br>高效查询：针对时间序列数据优化的查询性能。<br>数据压缩：使用差分编码和 Gorilla 压缩算法减少存储空间。<br>局部存储：数据默认存储在本地磁盘上，可以通过远程存储扩展。</p><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>样本 (Sample)：包含一个时间戳和一个值。<br>时间序列 (Time Series)：由一个度量名和一组标签唯一标识的一组样本。<br>块 (Block)：TSDB 中的数据以块的形式存储，每个块通常覆盖 2 小时的数据。<br>WAL (Write-Ahead Log)：在写入到块之前，数据先写入 WAL，以确保数据持久化。</p><h6 id="数据存储和管理"><a href="#数据存储和管理" class="headerlink" title="数据存储和管理"></a>数据存储和管理</h6><ol><li>数据存储路径：默认存储路径为 /var/lib/prometheus，可以在 Prometheus 配置文件中通过 storage.tsdb.path 参数修改。</li><li>数据保留策略：默认保留 15 天的数据，可以通过 –storage.tsdb.retention.time 参数设置。</li><li>数据压缩和删除：Prometheus 会自动压缩和删除过期数据。<h4 id="独立抓取模型："><a href="#独立抓取模型：" class="headerlink" title="独立抓取模型："></a>独立抓取模型：</h4></li></ol><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol><li><strong>Scrape</strong>：Prometheus 从目标处获取监控数据的过程。</li><li><strong>Target</strong>：被监控的对象，可以是服务器、应用程序、数据库等。</li><li><strong>Job</strong>：一组相似目标的集合。</li><li><strong>Exporter</strong>：用于将目标的数据暴露给 Prometheus 的组件，通常是 HTTP 端点</li></ol><h5 id="配置文件’prometheus-yml’"><a href="#配置文件’prometheus-yml’" class="headerlink" title="配置文件’prometheus.yml’"></a>配置文件’prometheus.yml’</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s     <span class="comment"># 每15秒抓取一次数据</span></span><br><span class="line">  evaluation_interval: 15s <span class="comment"># 每15秒评估一次规则</span></span><br></pre></td></tr></table></figure><h6 id="抓取配置"><a href="#抓取配置" class="headerlink" title="抓取配置"></a>抓取配置</h6><p>抓取配置定义了 Prometheus 如何发现和抓取目标数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br></pre></td></tr></table></figure><h6 id="动态服务发现"><a href="#动态服务发现" class="headerlink" title="动态服务发现"></a>动态服务发现</h6><p>Prometheus 支持多种服务发现机制，允许动态发现目标。例如，可以使用 Kubernetes、Consul、Etcd 等进行服务发现。</p><p>####### Exporter<br>Exporter 是将监控数据暴露给 Prometheus 的组件，不同的应用和系统有不同的 Exporter。例如：</p><ul><li>Node Exporter：用于监控操作系统的资源使用情况。</li><li>Blackbox Exporter：用于进行探测和检查（如 HTTP、HTTPS、TCP）。</li><li>MySQL Exporter：用于监控 MySQL 数据库。</li></ul><h4 id="多种数据支持："><a href="#多种数据支持：" class="headerlink" title="多种数据支持："></a>多种数据支持：</h4><p>支持包括通过导出器（exporters）收集第三方系统的数据，支持服务发现（Service Discovery），如 Kubernetes、Consul、Etcd 等</p><h4 id="告警："><a href="#告警：" class="headerlink" title="告警："></a>告警：</h4><p>内置了 Alertmanager，用于处理告警通知和管理告警规则。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol><li>Prometheus Server：<br>存储：使用基于时间序列数据库（TSDB）的本地存储来存储监控数据。<br>抓取（Scrape）：定期从目标端点（如应用程序、数据库等）拉取指标数据。<br>PromQL 查询引擎：允许用户通过 PromQL 查询存储的数据。</li><li>数据导出器（Exporters）：<br>节点导出器（Node Exporter）：收集系统级别的指标，如 CPU、内存、磁盘使用等。<br>应用程序导出器：如 MySQL Exporter、Redis Exporter，专门用于从特定应用中收集指标。</li><li>服务发现（Service Discovery）：<br>支持多种服务发现机制，如 Kubernetes、Consul、DNS 等，自动发现并监控动态变化的服务和主机。</li><li>Alertmanager：<br>告警规则：定义告警规则，当满足条件时触发告警。<br>告警通知：管理告警的路由和发送，支持多种通知方式，如电子邮件、Slack、PagerDuty 等。<br>告警抑制和分组：可以配置告警抑制规则和告警分组，避免告警风暴。</li><li>Pushgateway：<br>用于接收临时性任务（如批处理任务）的指标数据，这些任务无法被 Prometheus 定期拉取。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>配置和服务发现：通过配置文件或服务发现机制，Prometheus 确定需要监控的目标。</li><li>抓取数据：Prometheus 定期从目标端点拉取指标数据。</li><li>存储数据：将拉取到的指标数据存储在本地的时间序列数据库中。</li><li>查询和可视化：通过 PromQL 查询数据，结合 Grafana 等可视化工具展示监控结果。</li><li>告警处理：根据定义的告警规则，Prometheus 触发告警并通过 Alertmanager 发送通知。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prometheus&quot;&gt;&lt;a href=&quot;#Prometheus&quot; class=&quot;headerlink&quot; title=&quot;Prometheus&quot;&gt;&lt;/a&gt;Prometheus&lt;/h2&gt;&lt;p&gt;一个开源的监控和告警系统&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://kalyan-zitiu.github.io/categories/kubernetes/"/>
    
    
    <category term="Prometheus" scheme="https://kalyan-zitiu.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>简单ansible操作</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/22/%E7%AE%80%E5%8D%95ansible%E6%93%8D%E4%BD%9C/</id>
    <published>2024-07-22T06:59:35.000Z</published>
    <updated>2024-07-22T07:00:01.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><p>用于配置管理、应用程序部署、任务自动化</p><h3 id="ansible主机清单"><a href="#ansible主机清单" class="headerlink" title="ansible主机清单"></a>ansible主机清单</h3><h4 id="定义组"><a href="#定义组" class="headerlink" title="定义组"></a>定义组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[webservers] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dbserver] <span class="comment"># 定义组</span></span><br><span class="line">xxx.xxx.com</span><br><span class="line">xxx.xxx.com</span><br><span class="line"></span><br><span class="line">[dce5_nodes]</span><br><span class="line">10.70.49.17[2:4]</span><br><span class="line"></span><br><span class="line">[all:vars] <span class="comment"># 定义全局变量适用于全部主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 用户名，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_user: guest2admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible SSH 密码，用于连接到目标主机</span></span><br><span class="line">ansible_ssh_pass: @<span class="built_in">users</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ansible 使用的 Python 解释器路径</span></span><br><span class="line">ansible_python_interpreter: /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接的通用参数，这里指定了加密算法为 AES-256-CBC</span></span><br><span class="line">ansible_ssh_common_args: -c aes256-cbc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Ansible 连接到主机的方式，这里使用 SSH</span></span><br><span class="line">ansible_connection: ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权操作时使用的密码（例如切换到 root 用户时的密码）</span></span><br><span class="line">ansible_become_password: root@root@su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权方法，这里使用 su 命令切换用户</span></span><br><span class="line">ansible_become_method: su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权执行命令，这里指定了使用 sudo su - 命令来切换到超级用户</span></span><br><span class="line">ansible_become_exe: sudo su -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以组别变量</span></span><br><span class="line">[webserver:vars]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h3><ol><li><p><strong>Ping 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure><p>通过 Ping 模块测试所有主机是否可达。</p></li><li><p><strong>Shell 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;uptime&#x27;</span></span><br></pre></td></tr></table></figure><p>在所有主机上执行 <code>uptime</code> 命令。</p></li><li><p><strong>Command 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&#x27;ls /tmp&#x27;</span></span><br></pre></td></tr></table></figure><p>使用 <code>command</code> 模块列出 <code>/tmp</code> 目录下的文件。</p></li><li><p><strong>Copy 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">&#x27;src=/path/to/source dest=/path/to/destination&#x27;</span></span><br></pre></td></tr></table></figure><p>将本地文件复制到远程主机。</p></li><li><p><strong>File 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m file -a <span class="string">&#x27;path=/tmp/testfile state=touch&#x27;</span></span><br></pre></td></tr></table></figure><p>在远程主机上创建一个空文件。</p></li><li><p><strong>Service 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m service -a <span class="string">&#x27;name=httpd state=started&#x27;</span></span><br></pre></td></tr></table></figure><p>启动所有主机上的 httpd 服务。</p></li><li><p><strong>User 模块</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m user -a <span class="string">&#x27;name=johndoe state=present&#x27;</span></span><br></pre></td></tr></table></figure><p>创建一个名为 <code>johndoe</code> 的用户。</p></li></ol><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><code>-i &lt;inventory&gt;</code>：指定主机清单文件。例如 <code>-i hosts</code>。</li><li><code>--list-hosts</code>：列出将运行任务的主机。</li><li><code>-l &lt;subset&gt;</code>：指定要执行任务的主机子集。例如 <code>-l webservers</code>。</li><li><code>-u &lt;user&gt;</code>：指定远程主机用户。例如 <code>-u root</code>。</li><li><code>-k</code>：提示输入 SSH 密码。</li><li><code>--ask-become-pass</code>：提示输入 sudo 密码。</li><li><code>-e &lt;extra_vars&gt;</code>：传递额外变量。例如 <code>-e &quot;var1=value1 var2=value2&quot;</code>。</li></ul><h3 id="示例详解"><a href="#示例详解" class="headerlink" title="示例详解"></a>示例详解</h3><ol><li><p><strong>列出主机</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all --list-hosts</span><br></pre></td></tr></table></figure><p>列出所有在清单中的主机。</p></li><li><p><strong>指定用户和密码执行命令</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;df -h&#x27;</span> -u root -k</span><br></pre></td></tr></table></figure><p>使用 root 用户执行 <code>df -h</code> 命令，并提示输入密码。</p></li><li><p><strong>传递额外变量</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;echo &#123;&#123; var_name &#125;&#125;&#x27;</span> -e <span class="string">&#x27;var_name=HelloWorld&#x27;</span></span><br></pre></td></tr></table></figure><p>传递变量 <code>var_name</code>，并在命令中使用。</p></li></ol><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ol><li><p><strong>使用标签</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">&#x27;systemctl restart httpd&#x27;</span> --tags <span class="string">&quot;restart&quot;</span></span><br></pre></td></tr></table></figure><p>使用标签来组织和执行特定的任务。</p></li><li><p><strong>检查主机连通性</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible all -m ping -i inventory/hosts</span><br></pre></td></tr></table></figure><p>使用指定的主机清单文件检查连通性。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h2&gt;&lt;p&gt;用于配置管理、应用程序部署、任务自动化&lt;/p&gt;
&lt;h3 id=&quot;ansible主机清单&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="ansible" scheme="https://kalyan-zitiu.github.io/categories/ansible/"/>
    
    
    <category term="ansible" scheme="https://kalyan-zitiu.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes服务网格</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/22/Kubernetes%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</id>
    <published>2024-07-22T03:31:12.000Z</published>
    <updated>2024-07-22T03:35:22.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kubernetes服务网格"><a href="#kubernetes服务网格" class="headerlink" title="kubernetes服务网格"></a>kubernetes服务网格</h2><p>是一种架构，为了解决服务和服务之间的通信。</p><h3 id="服务网格接口（打算理解）"><a href="#服务网格接口（打算理解）" class="headerlink" title="服务网格接口（打算理解）"></a>服务网格接口（打算理解）</h3><h4 id="SMI"><a href="#SMI" class="headerlink" title="SMI"></a>SMI</h4><p>  用于定义服务网格标准化接口的规范，旨在提供一个通用的接口，让不同的服务网格实现可以互操作。SMI的主要目的是简化服务网格的使用和集成，使用户可以使用统一的API管理不同的服务网格实现，如Istio、Linkerd、Consul Connect等。</p><h4 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h4><p>  是Kubernetes中的一种机制，用于扩展Kubernetes API，使用户可以定义自己的资源类型。通过CRD，用户可以创建自定义资源（CR），这些资源可以与Kubernetes内置资源（如Pod、Service）一样进行管理和操作。</p><h3 id="数据平面代理"><a href="#数据平面代理" class="headerlink" title="数据平面代理"></a>数据平面代理</h3><p>负责处理和管理服务间流量的代理组件。</p><p>核心职责:<br>流量转发：代理组件负责接收、转发和负载均衡服务之间的流量。这包括 HTTP、gRPC、TCP 等多种协议。<br>服务发现：代理可以自动发现 Kubernetes 中的服务，根据服务的配置进行相应的流量路由。<br>流量管理：包括流量控制、重试策略、断路器、故障注入等功能，以保证服务间通信的可靠性和稳定性。<br>安全：提供 mTLS（双向 TLS）加密来确保服务间通信的安全性，支持认证和授权策略。<br>监控和可观测性：代理会收集并上报各种流量指标和日志，帮助管理员监控和诊断服务间的通信问题。</p><h4 id="数据平面架构"><a href="#数据平面架构" class="headerlink" title="数据平面架构"></a>数据平面架构</h4><h5 id="代理附件"><a href="#代理附件" class="headerlink" title="代理附件"></a>代理附件</h5><p>一般部署在工作负载的pod上，后续会拦截进出服务的所有通信，但是在一些升级上，代理附件不能保证在不重建Pod的条件下进行升级</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112524609.png" alt="image-20240722112524609"></p><h5 id="代理节点"><a href="#代理节点" class="headerlink" title="代理节点"></a>代理节点</h5><p>由代理节点来处理运行服务的所有流量。但是会存在很大的网络瓶颈。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722112926402.png" alt="image-20240722112926402"></p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>  一个高性能的开源边缘和服务代理，主要用于微服务架构中的通信管理</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722102428515.png" alt="image-20240722102428515"></p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><h6 id="API网关："><a href="#API网关：" class="headerlink" title="API网关："></a>API网关：</h6><p>Envoy可以作为API网关，处理外部请求并将其路由到内部服务，同时提供认证、限流、缓存等功能。</p><h6 id="边车代理："><a href="#边车代理：" class="headerlink" title="边车代理："></a>边车代理：</h6><ul><li>是一种设计模式，在这种模式下，一个代理程序（如Envoy）被部署在每个服务实例的旁边，这样每个服务实例都有一个独立的代理来处理进出流量。</li><li>在服务网格架构中，Envoy通常以边车代理的形式部署在每个服务实例旁，拦截和处理所有入站和出站流量。</li><li>边车注入是将边车代理自动注入到服务实例的Pod中，以便在微服务架构中实现服务网格功能的过程。分为手动与自动，自动注入似乎能够用istio来进行自动注入。</li><li>Sidecar 模式：Envoy 通常以 sidecar 容器的形式部署在每个微服务 Pod 内，与应用容器共享网络命名空间。所有进出微服务的流量都会通过 Envoy 代理。</li></ul><h6 id="中介层代理："><a href="#中介层代理：" class="headerlink" title="中介层代理："></a>中介层代理：</h6><p>Envoy可以部署在不同的服务层之间，作为中介层代理，处理跨服务的流量和策略管理。</p><h5 id="模块化架构"><a href="#模块化架构" class="headerlink" title="模块化架构"></a>模块化架构</h5><p>Listener：<br>作用：Listener是Envoy用于监听网络端口的组件，负责接受客户端的连接请求。每个Listener都绑定到一个特定的IP地址和端口，并根据配置将流量传递给相应的处理模块。<br>配置：Listener的配置包括监听的地址和端口、使用的协议（如HTTP、TCP）、以及关联的过滤器链。</p><p>Filter：<br>作用：Filter是Envoy用于处理请求和响应的中间处理模块。Filter可以用于修改请求、添加日志、执行身份验证、路由选择等。Envoy的Filter分为多种类型，包括网络过滤器、HTTP过滤器和TCP过滤器。<br>类型：<br>网络过滤器：处理TCP连接层面的流量，如TLS终止、连接限速等。<br>HTTP过滤器：处理HTTP请求和响应，如修改头部信息、执行认证和授权、负载均衡等。<br>TCP过滤器：处理TCP层流量，如TCP代理、流量镜像等。</p><p>Cluster：<br>作用：Cluster是Envoy用于表示一组上游服务实例的组件。Cluster负责服务发现、负载均衡、健康检查等。每个Cluster包含多个主机（即上游服务实例），并定义了如何将流量分配到这些主机上。<br>配置：Cluster的配置包括服务发现类型（静态、DNS、EDS等）、负载均衡策略（如轮询、随机、加权轮询等）、健康检查配置等。</p><p>Route：<br>作用：Route组件定义了Envoy如何将请求路由到不同的Cluster。Route规则基于请求的属性（如路径、头部信息、方法等）来决定具体的路由目标。<br>配置：Route的配置包括匹配规则、路由目标Cluster、重试策略、超时设置等。</p><p>Admin：<br>作用：Admin组件提供了管理和监控Envoy的接口。通过Admin接口，用户可以查看Envoy的运行状态、统计信息、配置详情，并进行管理操作。<br>配置：Admin接口通常通过HTTP API暴露，可以在Envoy配置中指定Admin的监听地址和端口。</p><h5 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h5><p>配置管理<br>Envoy的配置管理可以通过静态文件配置，也可以通过动态配置API（xDS）实现。xDS（Envoy Dynamic Configuration API）包括以下几个部分：<br>ADS（Aggregated Discovery Service）：聚合配置服务，统一管理其他xDS服务。<br>CDS（Cluster Discovery Service）：动态管理Cluster的配置。<br>EDS（Endpoint Discovery Service）：动态管理Cluster中上游服务实例的配置。<br>LDS（Listener Discovery Service）：动态管理Listener的配置。<br>RDS（Route Discovery Service）：动态管理路由配置。<br>SDS（Secret Discovery Service）：动态管理密钥和证书。</p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>负责管理和协调数据平面代理</p><p>配置管理：提供统一的配置接口，管理服务网格中所有代理的配置，包括路由规则、负载均衡策略、故障恢复策略等。<br>服务发现：集成服务发现机制，实时感知集群中服务的变化，并通知数据平面代理更新其配置。<br>安全管理：实现服务间的认证和授权，管理 TLS 证书的分发和轮换，确保服务间通信的安全性。<br>流量管理：提供流量路由、灰度发布、A/B 测试等高级流量控制功能，帮助开发和运维人员灵活管理服务间的流量。<br>可观测性：收集和聚合数据平面代理的监控指标、日志和分布式追踪数据，提供全局的可观测性视图，帮助排查和诊断问题。</p><h4 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h4><p>istiod为基于envoy的服务网络提供控制平面，他包括三个核心组件，Galley，Pilot，Citidel</p><p>Pilot：一个Envoy的配置服务器，实现 xDS API，并将配置流向与应用程序一起运行的Envoy代理。</p><p>Citadel：负责网格内的证书管理，建立服务器身份和相互TLS。</p><p>Galley：与外部系统互动，Kubernetes等。</p><h4 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h4><p>用于在 Kubernetes 集群中实现动态配置和策略控制的关键组件。 Istio 中的主要用途包括服务网格控制、资源变更管理和策略执行等。</p><ul><li>自动注入 Sidecar 容器:Istio 使用一个变异（Mutating）Webhook 自动将 Envoy 代理（Sidecar）注入到新创建的 Kubernetes Pod 中。这个过程确保每个服务都能被 Istio 管理和监控。当你为集群启用了自动注入，Webhook 会拦截 Pod 创建请求，在 Pod 完成调度之前往其定义中添加 Envoy 容器以及必要的配置信息。</li><li>配置验证（Validating Webhook）:验证（Validating）Webhook 用于在新的 Istio 配置资源（如 VirtualService、DestinationRule 等）创建或更新时执行验证过程，确保这些配置符合要求，避免因错误配置导致服务故障。这个 Webhook 会在配置提交到 etcd 之前进行执行，起到一个“守门人”的作用，阻止不符合标准的配置生效。</li><li>动态配置和策略控制:Webhook 还可以用于执行动态配置和策略决策。例如，通过 Webhook，可以向运行时注入配置参数或更新策略以应对瞬时需求或安全要求。</li></ul><h4 id="通过iptable达到工作负载通过Envoy发送流量。"><a href="#通过iptable达到工作负载通过Envoy发送流量。" class="headerlink" title="通过iptable达到工作负载通过Envoy发送流量。"></a>通过iptable达到工作负载通过Envoy发送流量。</h4><p>Istio的iptables规则是通过init-containner来进行安装，拦截pod网络流量路由到Envoy。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240722111557580.png" alt="image-20240722111557580"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="string">”argS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">istio-iptables</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--envoy-port</span> <span class="comment">#捕获出站的所有流量，并且发送到Envoy这个端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15001&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--inbound-capture-port</span> <span class="comment">#捕获入站的所有流量，并且发送Envoy这个端口1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;15006&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">--proxy-uid</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;1337”</span></span><br><span class="line"><span class="string">- --istio-inbound-interception-mode</span></span><br><span class="line"><span class="string">- REDIRECT</span></span><br><span class="line"><span class="string">--istio-service-cidr </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">--istio-inbound-ports </span></span><br><span class="line"><span class="string">- &#x27;*&#x27;</span></span><br><span class="line"><span class="string">- --istio-local-exclude-ports</span></span><br><span class="line"><span class="string">- 15090,15021,15020</span></span><br><span class="line"><span class="string">image: docker.io/istio/proxyv2:1.6.7</span></span><br><span class="line"><span class="string">imagePullPolicy: Always</span></span><br><span class="line"><span class="string">name: istio-init</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kubernetes服务网格&quot;&gt;&lt;a href=&quot;#kubernetes服务网格&quot; class=&quot;headerlink&quot; title=&quot;kubernetes服务网格&quot;&gt;&lt;/a&gt;kubernetes服务网格&lt;/h2&gt;&lt;p&gt;是一种架构，为了解决服务和服务之间的通信。&lt;</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes ingress基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/19/Kubernetes_ingress/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/19/Kubernetes_ingress/</id>
    <published>2024-07-19T01:21:03.000Z</published>
    <updated>2024-07-19T08:02:55.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><p>  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，可以简单的理解为一个外包，现在在互联网上很多的流量都使用了TLS/SSL协议继续加密，但是这也会增加服务器的负担，因此SSL终止可以理解成<code>外包</code>一个机器处理这个问题。一般这个外包工作会给到负载均衡器和反向代理。</p><h3 id="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"><a href="#为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？" class="headerlink" title="为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？"></a>为什么需要ingress的存在，Service不是已经提供了流量路由的功能了吗？</h3><ul><li>好像就是因为service不够用:dog:所以才有了ingress的存在，而且似乎ingress在处理HTTP和HTTPS流量的能力上十分出色。</li><li>除此之外ingress跳脱到应用层进行负载和流量路由的功能，大大减少统一访问策略和路由规则:boom:</li><li>而且ingress似乎为每一个集群提供了单一入口，流量能够精准投送。:fish:</li></ul><h3 id="ingress-配置冲突"><a href="#ingress-配置冲突" class="headerlink" title="ingress 配置冲突"></a>ingress 配置冲突</h3><p>不同团队或租户尝试使用相同的域名来暴露他们的应用程序时，可能会发生的问题。简单来说，就是两个团队都想用同一个域名，比如<code>app.bearcanoe.com</code>，来让外界访问他们的应用程序。这会导致冲突，因为Ingress控制器（管理这些网络流量的组件）不明确如何处理这种情况</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>准入控制器：在配置被应用到集群之前，验证并确保域名的唯一性。可以使用开放策略代理（OPA）来实现这个功能。</li><li>Contour Ingress 控制器：使用HTTPProxy自定义资源，创建一个根HTTPProxy资源，分配给特定团队。这种方法将域名管理集中化，避免冲突。</li></ol><h3 id="Ingress控制器"><a href="#Ingress控制器" class="headerlink" title="Ingress控制器"></a>Ingress控制器</h3><p>是用来实现Ingress资源定义的路由规则和流量管理的组件，以Pod的形式存在运行，负责解析Ingress资源，配置底层反向代理或负载均衡以处理HTTP和HTTPS流量 。</p><ol><li>解析 Ingress 资源：Ingress 控制器会监视 :eye: Kubernetes API，解析和处理定义在 Ingress 资源中的路由规则和配置。</li><li>配置反向代理/负载均衡器：根据解析到的 Ingress 规则，Ingress 控制器会动态配置底层的反向代理（如 NGINX、HAProxy）或云 :cloud: 提供商的负载均衡器（如 AWS ELB、GCP Load Balancer）。</li><li>管理外部访问：Ingress 控制器 :control_knobs: 负责将外部请求路由到集群内相应的服务，管理 HTTP/HTTPS 流量的转发、负载均衡以及 SSL/TLS 终止等功能。</li><li>支持高级特性：许多 Ingress 控制器支持高级功能，如基于 Cookie 的会话保持、限速、访问控制和基于 IP 的访问限制等。</li></ol><h3 id="流量模式"><a href="#流量模式" class="headerlink" title="流量模式"></a>流量模式</h3><h4 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h4><p>:question:什么是HTTP代理呢，想象一下你需要借一本书，但是这本书在一个封闭的空间内，你不能够直接自己拿到，这个时候你就需要一个中间人来帮你去借。这个时候这个中间人就可以理解成代理人。就是当客户进行一个HTTP请求，这个请求会通过代理服务器转发到目标服务器。反向代理也是这么理解，目标服务器的资源通过代理服务器传输出去。</p><p>:boy:ingress处理HTTP流量很简单，就是通过host头进行路由转发</p><h4 id="HTTPS代理"><a href="#HTTPS代理" class="headerlink" title="HTTPS代理"></a>HTTPS代理</h4><p>:question:HTTPS流量处理的有些特别，ingress在获取流量的时候进行SSL终止，然后建立新的HTTP请求进行转发。</p><p>但是特殊情况为了安全起见。ingress也会进行SSL终止之后再进行TLS加密与后端pod建立连接。</p><h4 id="OCI-3-4层代理"><a href="#OCI-3-4层代理" class="headerlink" title="OCI 3/4层代理"></a>OCI 3/4层代理</h4><p>:calendar:不懂往后点再研究…….</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="control-knobs-nginx-ingress-controller"><a href="#control-knobs-nginx-ingress-controller" class="headerlink" title=":control_knobs:nginx ingress controller"></a>:control_knobs:nginx ingress controller</h4><p>常用于HTTP和反向代理</p><ul><li>支持SSL/TLS终止</li><li>基于主机名和路径的路由</li><li>支持URL重写和重定向</li></ul><h4 id="control-knobs-Istio-ingress-Gateway"><a href="#control-knobs-Istio-ingress-Gateway" class="headerlink" title=":control_knobs:Istio ingress Gateway"></a>:control_knobs:Istio ingress Gateway</h4><p>Istio Ingress Gateway 是 Istio 服务网格中的一个组件，专门用于管理进入服务网格的外部 HTTP 和 HTTPS 流量。与传统的 Kubernetes Ingress 不同，Istio Ingress Gateway 提供了更多的高级流量管理和安全功能，如细粒度的流量控制、策略管理和监控。</p><h5 id="Istio-Ingress-Gateway-组件"><a href="#Istio-Ingress-Gateway-组件" class="headerlink" title="Istio Ingress Gateway 组件"></a>Istio Ingress Gateway 组件</h5><ol><li>:door: Gateway：定义哪些外部流量可以进入服务网格，以及如何路由这些流量。</li><li>VirtualService：定义流量的具体路由规则，可以包含多种匹配条件和路由行为。</li></ol><h4 id="control-knobs-HAProxy-Ingress"><a href="#control-knobs-HAProxy-Ingress" class="headerlink" title=":control_knobs: HAProxy Ingress"></a>:control_knobs: HAProxy Ingress</h4><p>高性能和高级路由功能，路由灵活，低延迟，负载均衡算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ingress&quot;&gt;&lt;a href=&quot;#ingress&quot; class=&quot;headerlink&quot; title=&quot;ingress&quot;&gt;&lt;/a&gt;ingress&lt;/h2&gt;&lt;p&gt;  我的理解简单就是处理外部流量，和按规则把流量指向指定服务，以及提供SSL终止。什么是SSL终止，</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes服务基础</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/17/Kubernetes%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-07-17T05:26:24.000Z</published>
    <updated>2024-07-17T07:34:53.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes服务基础"><a href="#Kubernetes服务基础" class="headerlink" title="Kubernetes服务基础"></a>Kubernetes服务基础</h1><h2 id="o打"><a href="#o打" class="headerlink" title="o打"></a>o打</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl get svc &lt;svc-name&gt;</span><br><span class="line">kubectl describe svc &lt;svc-name&gt;</span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">kubectl expose deployment &lt;d-name&gt; --port&lt;port&gt; --target-port=&lt;target-port&gt;</span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">kubectl get endpoints &lt;svc-name&gt;：查看服务端点</span><br><span class="line">kubectl port-forward svc/&lt;svc-name&gt;&lt;local-port&gt;:&lt;svc-port&gt;:本地端口转发服务端口</span><br></pre></td></tr></table></figure><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h3><ul><li>ClusterIP: 分配一个集群内部的ip地址，使得服务只能集群内部访问</li><li>NodePort: 在每个节点上分配一个端口，是的可以外部访问服务</li><li>LoadBalancer: 使用负载均衡来暴露服务，让服务加入后端池</li><li>ExternalName: 通过返回的CNAME记录来映射另一个外部的DNS名称</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717132825010.png" alt="image-20240717132825010"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240717145241179.png" alt="image-20240717145241179"></p><h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>用于定义一组Pod的逻辑集合，并且可以通过一个稳定的IP地址和端口进行访问。<code>ClusterIP</code>服务类型会在集群内部分配一个虚拟IP地址，这个IP地址只能在集群内部访问，不能从外部直接访问。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ClusterIP</code>类型的Service时，Kubernetes会为这个Service分配一个虚拟IP地址（Cluster IP）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>内部负载均衡</strong>: 当集群内的其他Pod或服务通过Cluster IP访问这个Service时，Kubernetes会自动将请求负载均衡到后端的Pod上。</li></ol><h5 id="yaml参考"><a href="#yaml参考" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: 855d96b0-c9e8-4ef2-afe5-bdb86e21adc3</span><br><span class="line">  resourceVersion: <span class="string">&#x27;194&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-12T07:36:07Z&#x27;</span></span><br><span class="line">  labels:</span><br><span class="line">    component: apiserver</span><br><span class="line">    provider: kubernetes</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: https</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 6443</span><br><span class="line">  clusterIP: 10.233.0.1</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.0.1</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>NodePort</code>类型的Service时，Kubernetes会在每个节点上分配一个端口（范围通常是30000-32767）。</li><li><strong>选择器（Selector）</strong>: Service通过标签选择器（Label Selector）来选择一组Pod，这些Pod将成为这个Service的后端。</li><li><strong>Endpoints</strong>: Kubernetes会自动创建一个Endpoints对象，记录所有符合选择器条件的Pod的IP地址和端口。</li><li><strong>节点端口（NodePort）</strong>: Kubernetes会在每个节点上开放一个指定的端口，并将这个端口的流量转发到Service的Cluster IP，然后再负载均衡到后端的Pod上。</li></ol><h4 id="yaml参考-1"><a href="#yaml参考-1" class="headerlink" title="yaml参考"></a>yaml参考</h4><h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>ps：这里的LoadBalancer和云上的不同，是为了解决nodeport不清晰问题。</p><h5 id="外部流量策略"><a href="#外部流量策略" class="headerlink" title="外部流量策略"></a>外部流量策略</h5><ol><li>cluster</li></ol><ul><li>把流量分配给所有集群中所有节点的可用实例上</li><li>能够做到全局分配和高利用，但是可能会造成比较高的延迟</li><li>场景：适合需要整体稳定可用的</li></ul><ol start="2"><li>local</li></ol><ul><li>优先把流量分给同一节点或同一区域的可用实例上</li><li>能够低延迟访问服务，本地优先</li><li>场景：适合游戏或者视频流媒体</li></ul><h5 id="yaml参考-2"><a href="#yaml参考-2" class="headerlink" title="yaml参考"></a>yaml参考</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: loadbalancer-01</span><br><span class="line">  namespace: default</span><br><span class="line">  uid: c4093644-e423-4737-94e1-8fd92606933d</span><br><span class="line">  resourceVersion: <span class="string">&#x27;3774606&#x27;</span></span><br><span class="line">  creationTimestamp: <span class="string">&#x27;2024-07-16T03:04:31Z&#x27;</span></span><br><span class="line">  annotations:</span><br><span class="line">    kpanda.io/alias-name: loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: tcp-loadbalaner</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 8081</span><br><span class="line">      targetPort: 8081</span><br><span class="line">      nodePort: 30683</span><br><span class="line">  selector:</span><br><span class="line">    app: baize-notebook-ssh</span><br><span class="line">  clusterIP: 10.233.59.228</span><br><span class="line">  clusterIPs:</span><br><span class="line">    - 10.233.59.228</span><br><span class="line">  <span class="built_in">type</span>: LoadBalancer</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  allocateLoadBalancerNodePorts: <span class="literal">true</span></span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h4><h5 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><strong>定义Service</strong>: 当你创建一个<code>ExternalName</code>类型的Service时，你需要指定一个外部的DNS名称。</li><li><strong>DNS解析</strong>: Kubernetes的DNS服务会为这个Service创建一个CNAME记录，将Service名称解析为指定的外部DNS名称。</li><li><strong>访问外部服务</strong>: 集群内的Pod可以通过Service名称访问外部的服务，Kubernetes的DNS服务会将这个名称解析为外部的DNS名称</li></ol><h5 id="yaml参考-3"><a href="#yaml参考-3" class="headerlink" title="yaml参考"></a>yaml参考</h5><p>不许参考，懒得cv了都基本一样就其他字段和type不同。</p>]]></content>
    
    
    <summary type="html">了解服务以及服务网格的作用</summary>
    
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://kalyan-zitiu.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux文件</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E6%96%87%E4%BB%B6/</id>
    <published>2024-07-10T03:47:16.000Z</published>
    <updated>2024-07-10T05:44:03.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h3><h4 id="1-lsof-List-Open-Files"><a href="#1-lsof-List-Open-Files" class="headerlink" title="1. lsof (List Open Files)"></a>1. lsof (List Open Files)</h4><p><code>lsof</code>命令用于列出当前系统中已打开的文件。它可以显示哪个进程正在使用哪个文件，并提供有关这些文件的详细信息。这个命令在排查文件占用、删除不成功或挂载卸载问题时非常有用。</p><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof [选项] [文件]</span><br></pre></td></tr></table></figure><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-u</code>：显示指定用户打开的文件。</li><li><code>-p</code>：显示指定进程ID打开的文件。</li><li><code>+D</code>：递归显示指定目录下的所有打开文件。</li><li><code>-i</code>：显示与网络相关的文件（例如端口使用情况）。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>列出所有打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>查看用户<code>user</code>打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u user</span><br></pre></td></tr></table></figure><p>显示进程ID为1234的进程打开的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure><h4 id="2-cp-Copy-Files"><a href="#2-cp-Copy-Files" class="headerlink" title="2. cp (Copy Files)"></a>2. cp (Copy Files)</h4><p><code>cp</code>命令用于复制文件和目录。</p><h5 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-r</code>：递归复制目录及其内容。</li><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时复制。</li><li><code>-p</code>：保留源文件的属性。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>复制文件<code>file1</code>到<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> file1 file2</span><br></pre></td></tr></table></figure><p>递归复制目录<code>dir1</code>到<code>dir2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r dir1 dir2</span><br></pre></td></tr></table></figure><h4 id="3-mv-Move-Rename-Files"><a href="#3-mv-Move-Rename-Files" class="headerlink" title="3. mv (Move/Rename Files)"></a>3. mv (Move/Rename Files)</h4><p><code>mv</code>命令用于移动或重命名文件和目录。</p><h5 id="基本语法：-2"><a href="#基本语法：-2" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-i</code>：覆盖文件前提示确认。</li><li><code>-u</code>：只在源文件比目标文件新或目标文件不存在时移动。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>重命名文件<code>file1</code>为<code>file2</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 file2</span><br></pre></td></tr></table></figure><p>移动文件<code>file1</code>到目录<code>dir1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 dir1/</span><br></pre></td></tr></table></figure><h4 id="4-ln-Link-Files"><a href="#4-ln-Link-Files" class="headerlink" title="4. ln (Link Files)"></a>4. ln (Link Files)</h4><p><code>ln</code>命令用于创建硬链接或符号链接（软链接）。</p><h5 id="基本语法：-3"><a href="#基本语法：-3" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [选项] 目标文件 链接文件</span><br></pre></td></tr></table></figure><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><ul><li><code>-s</code>：创建符号链接。</li><li><code>-f</code>：覆盖已有的链接文件。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><p>创建文件<code>file1</code>的硬链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><p>创建文件<code>file1</code>的符号链接<code>link1</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file1 link1</span><br></pre></td></tr></table></figure><p>在Linux系统中，建立文件链接（Link）是非常有用的，它提供了多种文件管理和使用的灵活性。文件链接主要分为两种类型：硬链接（Hard Link）和符号链接（Symbolic Link，也称为软链接）。以下是建立链接的原因和它们的用途：</p><h5 id="硬链接（Hard-Link）"><a href="#硬链接（Hard-Link）" class="headerlink" title="硬链接（Hard Link）"></a>硬链接（Hard Link）</h5><p>硬链接是对文件的直接引用。每个硬链接都指向文件的相同物理数据块，因此它们是完全等价的。</p><h6 id="建立硬链接的原因："><a href="#建立硬链接的原因：" class="headerlink" title="建立硬链接的原因："></a>建立硬链接的原因：</h6><ol><li><strong>冗余与备份</strong>：硬链接允许在不同位置访问同一文件内容，可以在不同目录中保持文件的多个访问点，从而提高冗余度，避免文件意外删除。</li><li><strong>节省空间</strong>：硬链接不会占用额外的存储空间，因为它们只是指向同一个物理数据块。</li><li><strong>一致性</strong>：硬链接确保文件的多个实例始终保持同步。对其中一个硬链接的修改会影响所有其他硬链接，因为它们指向相同的数据块。</li></ol><h6 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 link1</span><br></pre></td></tr></table></figure><h5 id="符号链接（Symbolic-Link-Soft-Link）"><a href="#符号链接（Symbolic-Link-Soft-Link）" class="headerlink" title="符号链接（Symbolic Link / Soft Link）"></a>符号链接（Symbolic Link / Soft Link）</h5><p>符号链接是指向另一个文件路径的引用。它们类似于快捷方式，包含了目标文件或目录的路径。</p><h6 id="建立符号链接的原因："><a href="#建立符号链接的原因：" class="headerlink" title="建立符号链接的原因："></a>建立符号链接的原因：</h6><ol><li><strong>灵活性</strong>：符号链接可以跨文件系统边界创建，而硬链接只能在同一文件系统内使用。它们可以指向目录或文件。</li><li><strong>便捷访问</strong>：通过符号链接，用户可以创建对常用文件或目录的快捷访问点，简化路径的输入和操作。</li><li><strong>组织结构</strong>：符号链接可以帮助组织文件系统，使某些文件或目录在多个位置都能方便地访问，而不需要复制实际数据。</li><li><strong>共享资源</strong>：在多用户环境中，符号链接可以用于共享公共资源，例如库文件、配置文件等，而不必在每个用户目录中复制一份。</li></ol><h6 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/original /path/to/symlink</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux文件管理&quot;&gt;&lt;a href=&quot;#Linux文件管理&quot; class=&quot;headerlink&quot; title=&quot;Linux文件管理&quot;&gt;&lt;/a&gt;Linux文件管理&lt;/h3&gt;&lt;h4 id=&quot;1-lsof-List-Open-Files&quot;&gt;&lt;a href=&quot;#1-l</summary>
      
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="file" scheme="https://kalyan-zitiu.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux网络</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/10/%E8%A7%A3%E6%9E%90Linux%E7%BD%91%E7%BB%9C/</id>
    <published>2024-07-10T01:39:02.000Z</published>
    <updated>2024-07-10T03:39:24.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-tcpdump"><a href="#1-tcpdump" class="headerlink" title="1. tcpdump"></a>1. <code>tcpdump</code></h3><p><code>tcpdump</code> 是一个网络抓包工具，可以捕获并分析网络流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上的所有数据包。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.1.1</span><br></pre></td></tr></table></figure><p>捕获与特定主机 <code>192.168.1.1</code> 相关的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure><p>捕获接口 <code>eth0</code> 上所有通过端口 <code>80</code> 的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -w capture.pcap</span><br></pre></td></tr></table></figure><p>将捕获的数据包保存到文件 <code>capture.pcap</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r capture.pcap</span><br></pre></td></tr></table></figure><p>读取并分析 <code>capture.pcap</code> 文件中的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#x27;</span></span><br></pre></td></tr></table></figure><p>捕获所有带有 SYN 或 ACK 标志的 TCP 包。</p><h3 id="2-lsof"><a href="#2-lsof" class="headerlink" title="2. lsof"></a>2. <code>lsof</code></h3><p><code>lsof</code> 显示系统中打开的文件，常用于查看打开的网络连接。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p>显示所有打开的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><p>显示所有使用端口 <code>80</code> 的网络连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -p &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>显示特定进程 <code>&lt;PID&gt;</code> 打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -u &lt;username&gt;</span><br></pre></td></tr></table></figure><p>显示特定用户打开的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof /path/to/file</span><br></pre></td></tr></table></figure><p>显示哪个进程打开了指定文件。</p><h3 id="3-net-tools"><a href="#3-net-tools" class="headerlink" title="3. net-tools"></a>3. <code>net-tools</code></h3><p><code>net-tools</code> 包含 <code>ifconfig</code>、<code>netstat</code> 等工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure><p>显示接口 <code>eth0</code> 的配置信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p>显示所有活动的网络连接及其状态。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.100 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>配置接口 <code>eth0</code> 的 IP 地址和子网掩码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p>显示路由表信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><p>显示网络接口统计信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -plnt</span><br></pre></td></tr></table></figure><p>显示所有监听的 TCP 端口及其关联的进程。</p><h3 id="4-iproute2"><a href="#4-iproute2" class="headerlink" title="4. iproute2"></a>4. <code>iproute2</code></h3><p><code>iproute2</code> 是 <code>net-tools</code> 的替代品，提供 <code>ip</code> 命令。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show</span><br></pre></td></tr></table></figure><p>显示所有网络接口。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>显示所有接口的 IP 地址信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add 192.168.1.100/24 dev eth0</span><br></pre></td></tr></table></figure><p>为接口 <code>eth0</code> 添加 IP 地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure><p>启用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add default via 192.168.1.1</span><br></pre></td></tr></table></figure><p>设置默认网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down</span><br></pre></td></tr></table></figure><p>禁用接口 <code>eth0</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip rule add from 192.168.1.0/24 table 1</span><br></pre></td></tr></table></figure><p>添加路由规则，使来自 <code>192.168.1.0/24</code> 的流量使用路由表 <code>1</code>。</p><h3 id="5-NetworkManager"><a href="#5-NetworkManager" class="headerlink" title="5. NetworkManager"></a>5. <code>NetworkManager</code></h3><p><code>NetworkManager</code> 是管理网络配置的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>交互命令窗口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device status</span><br></pre></td></tr></table></figure><p>查看当前设备的连接状态。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure><p>列出所有已保存的网络连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>列出可用的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi connect SSID password PASSWORD</span><br></pre></td></tr></table></figure><p>连接到指定的 Wi-Fi 网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add <span class="built_in">type</span> ethernet ifname eth0 con-name my-eth0</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>my-eth0</code> 的以太网连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con modify my-eth0 ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1</span><br></pre></td></tr></table></figure><p>修改连接 <code>my-eth0</code> 的 IP 地址和网关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con up my-eth0</span><br></pre></td></tr></table></figure><p>启用连接 <code>my-eth0</code>。</p><h3 id="6-firewalld"><a href="#6-firewalld" class="headerlink" title="6. firewalld"></a>6. <code>firewalld</code></h3><p><code>firewalld</code> 提供动态的防火墙管理工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p>启动 <code>firewalld</code> 服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><p>查看当前活动的区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>列出当前区域的所有规则。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久打开端口 <code>80</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>重新加载防火墙配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br></pre></td></tr></table></figure><p>将 <code>http</code> 服务添加到 <code>public</code> 区域。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>永久关闭端口 <code>80</code>。</p><h3 id="7-iptables"><a href="#7-iptables" class="headerlink" title="7. iptables"></a>7. <code>iptables</code></h3><p><code>iptables</code> 是 Linux 内核中的包过滤工具。</p><h4 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h4><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/1343683-20190523094912972-1910501182.png" alt="img"></p><p>iptables 是 Linux 系统中用于配置网络地址转换（NAT）、包过滤和包修改规则的工具。iptables 使用四个表和五个链来处理数据包。以下是对四个表和五个链的详细解释：</p><h5 id="四个表（Tables）"><a href="#四个表（Tables）" class="headerlink" title="四个表（Tables）"></a>四个表（Tables）</h5><ol><li><p><strong>filter 表</strong>：</p><ul><li><strong>用途</strong>：这是默认的表，用于网络包过滤。</li><li><strong>链</strong>：包含 INPUT、FORWARD 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有进入本地网络接口的流量</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许所有从本地网络接口发出的流量</span></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝所有从外部到达本机的流量</span></span><br><span class="line">iptables -A INPUT -i eth0 -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>nat 表</strong>：</p><ul><li><strong>用途</strong>：用于网络地址转换（NAT），比如源 NAT（SNAT）和目标 NAT（DNAT）。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将外部访问的80端口重定向到内部服务器的8080端口</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将发往外部的流量的源IP地址更改为指定的IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mangle 表</strong>：</p><ul><li><strong>用途</strong>：用于修改 IP 包头信息，如 TOS、TTL 等。</li><li><strong>链</strong>：包含 PREROUTING、OUTPUT、INPUT、FORWARD 和 POSTROUTING 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改流经本机的包的TTL值</span></span><br><span class="line">iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 128</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>raw 表</strong>：</p><ul><li><strong>用途</strong>：用于在连接跟踪（conntrack）机制之前对数据包进行处理。</li><li><strong>链</strong>：包含 PREROUTING 和 OUTPUT 链。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标记流经本机的包，以不进行连接跟踪</span></span><br><span class="line">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="五个链（Chains）"><a href="#五个链（Chains）" class="headerlink" title="五个链（Chains）"></a>五个链（Chains）</h5><ol><li><p><strong>INPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理入站流量，即目标为本机的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拒绝所有到达本机的入站流量</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>FORWARD 链</strong>：</p><ul><li><strong>用途</strong>：处理转发流量，即通过本机路由的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有通过本机的转发流量</span></span><br><span class="line">iptables -A FORWARD -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>OUTPUT 链</strong>：</p><ul><li><strong>用途</strong>：处理出站流量，即从本机发出的数据包。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许所有从本机发出的出站流量</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>PREROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之前处理入站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之前修改入站包的目的IP地址</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>POSTROUTING 链</strong>：</p><ul><li><strong>用途</strong>：在路由决策之后处理出站流量，用于 nat 和 mangle 表。</li><li><strong>示例规则</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在路由之后修改出站包的源IP地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 1.2.3.4</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure><p>列出所有当前规则。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有进入的 TCP 连接通过端口 <code>80</code>。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.1 -j DROP</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p icmp -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有 ICMP 出站流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>保存当前规则到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-restore &lt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>从文件恢复规则。</p><h3 id="8-nftables"><a href="#8-nftables" class="headerlink" title="8. nftables"></a>8. <code>nftables</code></h3><p>NFTables 是一个用于包过滤、网络地址转换 (NAT) 和流量控制的框架。它替代了 iptables、ip6tables、arptables 和 ebtables。NFTables 的配置文件通常使用简单的脚本语言来定义规则。以下是 NFTables 的表、链和规则的基本结构和语法。</p><h4 id="一、基础结构"><a href="#一、基础结构" class="headerlink" title="一、基础结构"></a>一、基础结构</h4><ol><li><p><strong>表（table）</strong></p><ul><li>表是规则集的容器。每张表可以包含多个链。</li></ul></li><li><p><strong>链（chain）</strong></p><ul><li>链是规则的有序列表。链可以是内置的（如 <code>input</code>、<code>output</code>、<code>forward</code>）或用户定义的。</li></ul></li><li><p><strong>规则（rule）</strong></p><ul><li>规则定义了特定条件下应执行的动作。</li></ul></li></ol><h4 id="二、表、链和规则的语法"><a href="#二、表、链和规则的语法" class="headerlink" title="二、表、链和规则的语法"></a>二、表、链和规则的语法</h4><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;family&gt;</code>: 地址族，常见的有 <code>ip</code>（IPv4）、<code>ip6</code>（IPv6）、<code>inet</code>（支持 IPv4 和 IPv6）、<code>arp</code>（ARP）、<code>bridge</code>（网桥）。</li><li><code>&lt;table_name&gt;</code>: 表的名称。</li></ul></li><li><p><strong>删除表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete table &lt;family&gt; &lt;table_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出现有表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list tables</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &#123; type &lt;type&gt; hook &lt;hook&gt; priority &lt;priority&gt;; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;type&gt;</code>: 链的类型，可以是 <code>filter</code>、<code>nat</code> 等。</li><li><code>&lt;hook&gt;</code>: 钩子点，可以是 <code>input</code>、<code>output</code>、<code>forward</code>、<code>prerouting</code>、<code>postrouting</code> 等。</li><li><code>&lt;priority&gt;</code>: 优先级。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; type filter hook input priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; &lt;expression&gt; &lt;action&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;expression&gt;</code>: 匹配条件，例如 <code>ip saddr 192.168.1.1</code>。</li><li><code>&lt;action&gt;</code>: 动作，例如 <code>accept</code>、<code>drop</code>、<code>reject</code>、<code>log</code> 等。</li></ul><p> 例如：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure></li><li><p><strong>删除规则</strong><br> 可以通过规则句柄删除：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft delete rule &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt; handle &lt;handle_number&gt;</span><br></pre></td></tr></table></figure><p> 首先列出链中的规则以找到句柄：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list chain &lt;family&gt; &lt;table_name&gt; &lt;chain_name&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>列出规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h4><p>假设我们要创建一个简单的防火墙配置，允许入站 SSH 连接并拒绝所有其他入站流量。</p><ol><li><p><strong>创建表</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add table ip filter</span><br></pre></td></tr></table></figure></li><li><p><strong>创建链</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add chain ip filter input &#123; type filter hook input priority 0\; &#125;</span><br><span class="line">nft add chain ip filter forward &#123; type filter hook forward priority 0\; &#125;</span><br><span class="line">nft add chain ip filter output &#123; type filter hook output priority 0\; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加规则</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip protocol tcp tcp dport 22 accept</span><br><span class="line">nft add rule ip filter input drop</span><br></pre></td></tr></table></figure></li><li><p><strong>查看配置</strong></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure></li></ol><p>这样，我们就配置了一个简单的防火墙，允许入站 SSH 连接并拒绝所有其他入站流量。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>列出当前规则集。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>添加规则，允许通过端口 <code>80</code> 的 TCP 连接。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft delete rule ip filter input tcp dport 80 accept</span><br></pre></td></tr></table></figure><p>删除规则，阻止端口 <code>80</code> 的连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip filter input ip saddr 192.168.1.1 drop</span><br></pre></td></tr></table></figure><p>丢弃来自 <code>192.168.1.1</code> 的所有连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add table ip mytable</span><br></pre></td></tr></table></figure><p>添加一个名为 <code>mytable</code> 的表。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add chain ip mytable mychain &#123; <span class="built_in">type</span> filter hook input priority 0 \; &#125;</span><br></pre></td></tr></table></figure><p>在 <code>mytable</code> 表中添加一个名为 <code>mychain</code> 的链。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft add rule ip mytable mychain counter</span><br></pre></td></tr></table></figure><p>在 <code>mychain</code> 链中添加一个计数规则。</p><h3 id="9-curl"><a href="#9-curl" class="headerlink" title="9. curl"></a>9. <code>curl</code></h3><p><code>curl</code> 是用于传输数据的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I http://example.com</span><br></pre></td></tr></table></figure><p>获取 HTTP 响应头信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/api</span><br></pre></td></tr></table></figure><p>发送 POST 请求。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password http://example.com</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://example.com</span><br></pre></td></tr></table></figure><p>忽略 SSL 证书错误。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://example.com</span><br></pre></td></tr></table></figure><p>跟随重定向。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -C - -O http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><h3 id="10-wget"><a href="#10-wget" class="headerlink" title="10. wget"></a>10. <code>wget</code></h3><p><code>wget</code> 是另一个下载文件的命令行工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://example.com/file</span><br></pre></td></tr></table></figure><p>下载文件 <code>file</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q http://example.com/file</span><br></pre></td></tr></table></figure><p>静默模式下载文件，不输出任何信息。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./local http://example.com</span><br></pre></td></tr></table></figure><p>递归下载整个网站，并将文件保存到 <code>./local</code> 目录中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://example.com/file</span><br></pre></td></tr></table></figure><p>断点续传下载文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=100k http://example.com/file</span><br></pre></td></tr></table></figure><p>限制下载速度为 <code>100kB/s</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --user=username --password=password http://example.com/file</span><br></pre></td></tr></table></figure><p>使用基本身份验证下载文件。</p><h3 id="11-iptop"><a href="#11-iptop" class="headerlink" title="11. iptop"></a>11. <code>iptop</code></h3><p><code>iptop</code> 是一个实时显示网络流量的工具。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop</span><br></pre></td></tr></table></figure><p>启动 <code>iptop</code>，显示实时网络流量。</p><p><strong>高级用法：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -i eth0</span><br></pre></td></tr></table></figure><p>显示特定接口 <code>eth0</code> 的网络流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f src net 192.168.1.0/24</span><br></pre></td></tr></table></figure><p>显示来自特定子网 <code>192.168.1.0/24</code> 的流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptop -f dst port 80</span><br></pre></td></tr></table></figure><p>显示发送到端口 <code>80</code> 的流量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-tcpdump&quot;&gt;&lt;a href=&quot;#1-tcpdump&quot; class=&quot;headerlink&quot; title=&quot;1. tcpdump&quot;&gt;&lt;/a&gt;1. &lt;code&gt;tcpdump&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; 是一个网络抓</summary>
      
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="net" scheme="https://kalyan-zitiu.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>解析Linux磁盘</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/08/%E8%A7%A3%E6%9E%90Linux%E7%A3%81%E7%9B%98/</id>
    <published>2024-07-08T08:49:36.000Z</published>
    <updated>2024-07-09T07:35:51.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="磁盘方面"><a href="#磁盘方面" class="headerlink" title="磁盘方面"></a>磁盘方面</h3><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><h5 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h5><p>在linux系统中，磁盘分区是一种物理硬盘分割成多个逻辑部分的方法，每个分区可以独立地进行管理和使用通常会分为</p><ul><li>主分区：每个磁盘最多可以有四个主分区。需要更多地分区可以使用扩展分区。</li><li>扩展分区： 扩展分区本身不能直接用于存储数据，但可以包含多个逻辑分区。</li><li>逻辑分区： 位于扩展分区内地分区，可以超过四个限制。</li></ul><h5 id="分区职责"><a href="#分区职责" class="headerlink" title="分区职责"></a>分区职责</h5><ul><li>主分区：用于安装操作系统，存储数据，以及引导系统</li><li>扩展分区：是用于包含逻辑分区的一个容器，解决主分区的限制，创建多个逻辑分区</li><li>逻辑分区：可以用来存储操作系统，应用程序和数据。</li></ul><h5 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h5><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，包含系统中所有文件和目录的起点。</td></tr><tr><td><code>/bin</code></td><td>基本命令的二进制文件，如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等。</td></tr><tr><td><code>/boot</code></td><td>存放启动加载器相关的文件和内核文件。</td></tr><tr><td><code>/dev</code></td><td>设备文件目录，包含所有设备的接口文件（如硬盘、终端）。</td></tr><tr><td><code>/etc</code></td><td>配置文件目录，包含系统和应用程序的所有配置文件。</td></tr><tr><td><code>/home</code></td><td>用户家目录，每个用户都有一个单独的子目录，用于存放个人文件和配置。</td></tr><tr><td><code>/lib</code></td><td>系统库文件目录，包含基本系统库和内核模块。</td></tr><tr><td><code>/media</code></td><td>自动挂载的可移动媒体设备（如CD-ROM、USB驱动器）。</td></tr><tr><td><code>/mnt</code></td><td>临时挂载文件系统的挂载点。</td></tr><tr><td><code>/opt</code></td><td>可选软件包目录，用于安装附加的第三方应用程序。</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，提供系统和进程信息。</td></tr><tr><td><code>/root</code></td><td>超级用户（root）家目录。</td></tr><tr><td><code>/run</code></td><td>运行时数据，存放系统启动后产生的临时文件（如进程ID文件）。</td></tr><tr><td><code>/sbin</code></td><td>系统管理员命令的二进制文件，如 <code>fdisk</code>、<code>ifconfig</code> 等。</td></tr><tr><td><code>/srv</code></td><td>服务数据目录，存放特定服务的数据（如Web服务器文件）。</td></tr><tr><td><code>/sys</code></td><td>虚拟文件系统，提供内核设备和驱动程序信息。</td></tr><tr><td><code>/tmp</code></td><td>临时文件目录，存放临时文件，系统重启后可能会清空。</td></tr><tr><td><code>/usr</code></td><td>用户程序目录，包含二进制文件、库文件、文档等（如 <code>/usr/bin</code>、<code>/usr/lib</code>）。</td></tr><tr><td><code>/var</code></td><td>可变数据文件目录，存放日志文件、邮件、临时文件等（如 <code>/var/log</code>、<code>/var/mail</code>）。</td></tr></tbody></table><h4 id="MBR-Master-Boot-Record"><a href="#MBR-Master-Boot-Record" class="headerlink" title="MBR (Master Boot Record)"></a>MBR (Master Boot Record)</h4><ul><li>MBR是一种传统的磁盘分区表格式，它位于磁盘的第一个扇区。</li><li>MBR分区表最多支持4个主分区，如果需要更多分区，必须将其中一个主分区转换为扩展分区，再在扩展分区内创建逻辑分区。</li><li>由于使用32位地址，MBR最多支持2TB的磁盘。</li></ul><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>主引导记录 (Master Boot Record)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0）。</li><li>大小为512字节。</li></ul></li><li><p><strong>主引导代码 (Boot Code)</strong></p><ul><li>前446字节存储主引导代码，用于启动操作系统。</li></ul></li><li><p><strong>分区表 (Partition Table)</strong></p><ul><li>紧随其后64字节（每个分区条目16字节，共4个条目）。</li><li>描述最多四个主分区或一个扩展分区的起始位置和大小。</li></ul></li><li><p><strong>签名 (Signature)</strong></p><ul><li>最后2字节为磁盘签名（0x55AA），标志主引导记录的结束。</li></ul></li><li><p><strong>扩展分区</strong></p><ul><li>如果需要超过四个分区，可以创建一个扩展分区（Extended Partition）。</li><li>扩展分区包含一个扩展引导记录 (EBR)，每个逻辑分区包含一个EBR。</li></ul></li></ol><h4 id="GPT-GUID-Partition-Table"><a href="#GPT-GUID-Partition-Table" class="headerlink" title="GPT (GUID Partition Table)"></a>GPT (GUID Partition Table)</h4><ul><li>GPT是一种现代的磁盘分区表格式，取代了传统的MBR。</li><li>GPT使用64位地址，可以支持超过8ZB的磁盘容量。</li><li>GPT最多可以支持128个主分区，没有扩展分区的限制。</li><li>GPT分区表有冗余备份和CRC校验，提高了数据的安全性和可靠性。</li></ul><h5 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><ol><li><p><strong>保护性MBR (Protective MBR)</strong></p><ul><li>位于磁盘的第一个扇区（LBA 0），防止旧版工具误读GPT磁盘。</li></ul></li><li><p><strong>主GPT头 (Primary GPT Header)</strong></p><ul><li>位于LBA 1，描述GPT分区表的总体信息。</li><li>包含GPT版本、头部大小、CRC32校验和等。</li></ul></li><li><p><strong>主分区表 (Primary Partition Table)</strong></p><ul><li>紧随其后，从LBA 2开始，一般占用32个扇区。</li><li>每个分区条目128字节，通常最多支持128个分区条目。</li></ul></li><li><p><strong>分区条目 (Partition Entries)</strong></p><ul><li>每个条目描述一个分区的GUID、类型GUID、起始LBA、结束LBA、属性标志等。</li></ul></li><li><p><strong>用户分区</strong></p><ul><li>从主分区表结束位置开始，存储实际的数据和文件系统。</li></ul></li><li><p><strong>备份分区表 (Backup Partition Table)</strong></p><ul><li>位于磁盘末尾，用于恢复主GPT头和分区表。</li></ul></li><li><p><strong>备份GPT头 (Backup GPT Header)</strong></p><ul><li>位于磁盘倒数第二个扇区，记录备份分区表的信息。</li></ul></li></ol><h4 id="Legacy-BIOS-引导"><a href="#Legacy-BIOS-引导" class="headerlink" title="Legacy / BIOS 引导"></a>Legacy / BIOS 引导</h4><p>Legacy/BIOS（Basic Input/Output System）引导是一种传统的计算机启动模式。它是PC兼容系统的早期固件接口，负责初始化硬件并引导操作系统。以下是详细的说明：</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol><li><p><strong>电源自检（POST）</strong>:</p><ul><li>计算机启动时，BIOS首先进行电源自检（Power-On Self-Test），检查和初始化系统硬件，如内存、CPU、硬盘和外设。</li><li>如果POST过程中检测到错误，BIOS会通过蜂鸣声或屏幕错误信息提示用户。</li></ul></li><li><p><strong>查找引导设备</strong>:</p><ul><li>POST完成后，BIOS会根据预设的引导顺序查找可启动设备（如硬盘、光盘、U盘等）。</li><li>引导顺序通常可以在BIOS设置界面中配置。</li></ul></li><li><p><strong>加载引导扇区</strong>:</p><ul><li>一旦找到一个可引导的设备，BIOS会读取该设备的主引导记录（MBR，Master Boot Record），这通常是设备的第一个扇区（512字节）。</li><li>MBR包含了启动加载程序的初始部分以及分区表信息。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>BIOS将控制权交给MBR中的引导加载程序。这个程序进一步加载操作系统或更多的引导代码（例如，GRUB、LILO等引导加载程序）。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序最终加载操作系统内核，并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="特点和限制"><a href="#特点和限制" class="headerlink" title="特点和限制"></a>特点和限制</h5><ul><li><strong>地址空间限制</strong>: BIOS模式只能使用传统的32位地址模式，无法利用超过4GB的内存空间。</li><li><strong>MBR分区限制</strong>: MBR分区表限制最大支持4个主分区，每个分区最大只能是2TB。</li><li><strong>兼容性</strong>: 由于其长期存在，BIOS模式具有广泛的硬件和软件兼容性。</li></ul><h5 id="设置和配置"><a href="#设置和配置" class="headerlink" title="设置和配置"></a>设置和配置</h5><ul><li><strong>进入BIOS设置</strong>: 通常通过在启动时按下特定的键（如F2、Del、Esc）进入BIOS设置界面。</li><li><strong>配置引导顺序</strong>: 在BIOS设置界面中，用户可以配置引导设备的优先级。</li><li><strong>启用/禁用设备</strong>: 可以在BIOS中启用或禁用某些硬件设备，以优化系统性能或解决兼容性问题。</li></ul><h4 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h4><p>UEFI（统一可扩展固件接口）是一种现代固件接口，用于替代传统的BIOS。它提供更强大的功能和更灵活的引导方式。以下是详细的UEFI启动流程和相关设置的教学：</p><h5 id="UEFI-启动流程"><a href="#UEFI-启动流程" class="headerlink" title="UEFI 启动流程"></a>UEFI 启动流程</h5><ol><li><p><strong>电源开启和硬件初始化</strong>:</p><ul><li>计算机启动时，UEFI固件首先进行硬件初始化和电源自检（POST，Power-On Self-Test）。</li><li>检查CPU、内存、存储设备和外设，确保它们工作正常。</li></ul></li><li><p><strong>进入UEFI固件界面</strong>:</p><ul><li>在启动过程中，用户可以按特定的键（如F2、Del、Esc）进入UEFI固件设置界面。</li></ul></li><li><p><strong>查找EFI系统分区（ESP）</strong>:</p><ul><li>UEFI固件会查找包含EFI系统分区（ESP）的存储设备。ESP是一个特殊的分区，用于存储EFI引导加载程序和相关文件。</li><li>ESP通常格式化为FAT32文件系统，并且标记为“EFI System Partition”。</li></ul></li><li><p><strong>加载EFI引导加载程序</strong>:</p><ul><li>在ESP中，UEFI固件查找引导加载程序文件，通常位于 <code>\EFI\Boot\bootx64.efi</code>（对于64位系统）。</li><li>用户可以在UEFI设置中指定特定的引导加载程序路径或更改引导顺序。</li></ul></li><li><p><strong>执行引导加载程序</strong>:</p><ul><li>UEFI将控制权交给引导加载程序。这个程序进一步加载操作系统的引导程序或内核。</li><li>常见的引导加载程序包括Windows Boot Manager、GRUB、Clover等。</li></ul></li><li><p><strong>启动操作系统</strong>:</p><ul><li>引导加载程序加载操作系统内核并将控制权交给它，操作系统开始初始化并进入用户模式。</li></ul></li></ol><h5 id="设置和配置UEFI"><a href="#设置和配置UEFI" class="headerlink" title="设置和配置UEFI"></a>设置和配置UEFI</h5><ol><li><p><strong>进入UEFI设置界面</strong>:</p><ul><li>重启计算机，在启动过程中按下特定的键（如F2、Del、Esc）进入UEFI设置界面。</li><li>不同品牌的主板可能有不同的按键，具体请参考主板或计算机手册。</li></ul></li><li><p><strong>配置引导顺序</strong>:</p><ul><li>在UEFI设置界面中，找到“Boot”或“启动”选项卡。</li><li>配置引导设备的优先级，将希望首先引导的设备设置为第一优先级。</li><li>如果需要从特定的EFI引导文件启动，可以手动指定路径。</li></ul></li><li><p><strong>启用/禁用设备</strong>:</p><ul><li>在“Advanced”或“高级”选项卡中，可以启用或禁用某些硬件设备。</li><li>例如，启用/禁用USB端口、网卡、SATA接口等。</li></ul></li><li><p><strong>安全启动（Secure Boot）</strong>:</p><ul><li>安全启动是一项UEFI功能，用于防止加载未签名或未经授权的操作系统引导程序。</li><li>在“Security”或“安全”选项卡中，可以启用或禁用安全启动。</li><li>如果需要安装非官方签名的操作系统，可能需要暂时禁用安全启动。</li></ul></li><li><p><strong>保存和退出</strong>:</p><ul><li>完成设置后，选择“Save &amp; Exit”或“保存并退出”选项。</li><li>保存设置后，系统将重新启动并应用新的设置。</li></ul></li></ol><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p><code>sar</code>（System Activity Reporter）是一个强大的工具，用于在Linux系统上收集、报告和保存系统活动信息。它可以提供有关系统性能的详细数据，包括CPU、内存、网络、磁盘I/O等多个方面。<code>sar</code>命令通常与<code>sysstat</code>软件包一起使用。下面是如何使用<code>sar</code>命令来监控磁盘活动的步骤：</p><h5 id="安装sysstat包"><a href="#安装sysstat包" class="headerlink" title="安装sysstat包"></a>安装sysstat包</h5><p>在大多数Linux发行版中，可以通过包管理器安装<code>sysstat</code>包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于基于Debian的系统（如Ubuntu）</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于基于RHEL的系统（如CentOS）</span></span><br><span class="line">sudo yum install sysstat</span><br></pre></td></tr></table></figure><h5 id="启用和配置sysstat"><a href="#启用和配置sysstat" class="headerlink" title="启用和配置sysstat"></a>启用和配置sysstat</h5><p>安装完成后，确保<code>sysstat</code>服务已启用并正在运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用sysstat服务</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sysstat</span><br><span class="line">sudo systemctl start sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置sysstat以启用数据收集</span></span><br><span class="line">sudo nano /etc/default/sysstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ENABLED=&quot;false&quot;修改为ENABLED=&quot;true&quot;</span></span><br><span class="line">ENABLED=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存并退出编辑器</span></span><br></pre></td></tr></table></figure><h5 id="使用sar监控磁盘I-O"><a href="#使用sar监控磁盘I-O" class="headerlink" title="使用sar监控磁盘I/O"></a>使用sar监控磁盘I/O</h5><p><code>sar</code>可以通过<code>-d</code>选项来监控磁盘I/O活动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实时监控磁盘I/O，每1秒报告一次，共报告10次</span></span><br><span class="line">sar -d 1 10</span><br></pre></td></tr></table></figure><h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><ul><li><code>-d</code>：报告磁盘I/O统计信息。</li><li><code>-p</code>：将设备名称从设备编号翻译为设备名称。</li><li><code>-r</code>：报告内存和交换空间使用情况。</li><li><code>-n</code>：报告网络统计信息（如<code>-n DEV</code>报告网络接口统计信息）。</li><li><code>-u</code>：报告CPU使用情况。</li></ul><h5 id="查看历史数据"><a href="#查看历史数据" class="headerlink" title="查看历史数据"></a>查看历史数据</h5><p><code>sar</code>命令可以查看过去的系统性能数据，这些数据通常保存在<code>/var/log/sa/</code>目录中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定日期的磁盘I/O活动（例如2024年7月5日）</span></span><br><span class="line">sar -d -f /var/log/sa/sa05</span><br></pre></td></tr></table></figure><h5 id="示例输出解读"><a href="#示例输出解读" class="headerlink" title="示例输出解读"></a>示例输出解读</h5><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709151241420.png" alt="image-20240709151241420"></p><p>以下是<code>sar -d</code>命令的示例输出及其含义：</p><ul><li><code>tps</code>：每秒传输数（读+写）。</li><li><code>rd_sec/s</code>：每秒读取的扇区数。</li><li><code>wr_sec/s</code>：每秒写入的扇区数。</li><li><code>avgrq-sz</code>：平均请求大小（扇区）。</li><li><code>avgqu-sz</code>：平均请求队列长度。</li><li><code>await</code>：每个I/O操作的平均等待时间（毫秒）。</li><li><code>svctm</code>：每个I/O操作的平均服务时间（毫秒）。</li><li><code>%util</code>：设备的I/O使用百分比。</li></ul><p>使用<code>sar</code>工具可以帮助系统管理员深入了解系统性能瓶颈并进行相应的优化。</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID（Redundant Array of Independent Disks，即独立磁盘冗余阵列）是一种将多个物理硬盘驱动器组合成一个逻辑单元的存储技术。其主要目的是提高数据存储的性能、容量和可靠性。RAID技术通过不同的配置（称为RAID级别）来实现这些目标。以下是几种常见的RAID级别：</p><ol><li><p><strong>RAID 0</strong>：</p><ul><li><strong>条带化（Striping）</strong>：数据在多个磁盘上分割并并行写入。</li><li><strong>优点</strong>：提高读写速度。</li><li><strong>缺点</strong>：没有冗余，任何一个磁盘故障都会导致数据丢失。</li></ul></li><li><p><strong>RAID 1</strong>：</p><ul><li><strong>镜像（Mirroring）</strong>：每个数据块都在两个或多个磁盘上复制。</li><li><strong>优点</strong>：提供高冗余，数据安全性高。</li><li><strong>缺点</strong>：磁盘利用率低（50%），只使用了一半的存储容量。</li></ul></li><li><p><strong>RAID 5</strong>：</p><ul><li><strong>分布式奇偶校验（Distributed Parity）</strong>：数据和奇偶校验信息分布在所有磁盘上。</li><li><strong>优点</strong>：平衡了性能、容量和数据安全性，至少需要3个磁盘。</li><li><strong>缺点</strong>：写操作较慢，因为需要计算和写入奇偶校验数据。</li></ul></li><li><p><strong>RAID 6</strong>：</p><ul><li><strong>双奇偶校验（Double Parity）</strong>：类似RAID 5，但有两组奇偶校验数据，容忍两块磁盘同时故障。</li><li><strong>优点</strong>：更高的数据安全性。</li><li><strong>缺点</strong>：写操作更慢，磁盘利用率较低。</li></ul></li><li><p><strong>RAID 10（或1+0）</strong>：</p><ul><li><strong>条带化和镜像结合</strong>：先进行镜像，再进行条带化。</li><li><strong>优点</strong>：结合了RAID 0和RAID 1的优点，高性能和高冗余。</li><li><strong>缺点</strong>：需要较多的磁盘，成本较高。</li></ul></li><li><p><strong>RAID 50（或5+0）</strong>：</p><ul><li><strong>条带化和分布式奇偶校验结合</strong>：将RAID 5阵列条带化。</li><li><strong>优点</strong>：提高了性能和冗余，适合大规模存储需求。</li><li><strong>缺点</strong>：复杂度增加，需要更多磁盘。</li></ul></li></ol><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 MBR 分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>m</td><td>显示帮助菜单</td><td>显示所有可用命令的列表和简要说明。</td></tr><tr><td>p</td><td>显示当前分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>n</td><td>添加一个新分区</td><td>根据提示选择主分区或逻辑分区，并设置分区的开始和结束位置。</td></tr><tr><td>d</td><td>删除一个分区</td><td>选择要删除的分区编号。</td></tr><tr><td>l</td><td>列出已知分区类型</td><td>显示支持的所有分区类型代码和说明。</td></tr><tr><td>t</td><td>更改一个分区的系统ID</td><td>选择分区后，输入新的类型代码。</td></tr><tr><td>a</td><td>切换启动标志</td><td>设置或取消某个分区的启动标志（使其可引导）。</td></tr><tr><td>w</td><td>写入分区表并退出</td><td>将对分区所做的更改写入磁盘，并退出fdisk。</td></tr><tr><td>q</td><td>不保存更改并退出</td><td>退出fdisk而不保存对分区表的任何更改。</td></tr></tbody></table><h5 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h5><ol><li>输入<code>n</code>创建新分区。</li><li>选择分区类型（主分区<code>p</code>或逻辑分区<code>e</code>）。</li><li>指定分区号（例如<code>1</code>）。</li><li>指定分区的起始扇区和结束扇区。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h5><ol><li>输入<code>p</code>查看当前分区表。</li><li>输入<code>d</code>删除分区。</li><li>输入要删除的分区编号（例如<code>1</code>）。</li><li>输入<code>w</code>保存并退出。</li></ol><h5 id="更改分区类型"><a href="#更改分区类型" class="headerlink" title="更改分区类型"></a>更改分区类型</h5><ol><li>输入<code>t</code>更改分区类型。</li><li>输入分区编号（例如<code>1</code>）。</li><li>输入新的类型代码（例如<code>83</code>用于Linux分区）。</li><li>输入<code>w</code>保存并退出。</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709125834777.png" alt="image-20240709125834777"></p><h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><p>fdisk 是用于操作磁盘分区的工具，适用于 GPT分区表。</p><table><thead><tr><th>命令</th><th>描述</th><th>使用说明</th></tr></thead><tbody><tr><td>mklabel</td><td>创建新的磁盘标签（分区表）</td><td>格式：<code>mklabel &lt;label&gt;</code>，其中<code>label</code>可以是<code>gpt</code>、<code>msdos</code>等。</td></tr><tr><td>mkpart</td><td>创建新分区</td><td>格式：<code>mkpart &lt;part-type&gt; &lt;fs-type&gt; &lt;start&gt; &lt;end&gt;</code>，例如<code>mkpart primary ext4 1MiB 500MiB</code>。</td></tr><tr><td>rm</td><td>删除分区</td><td>格式：<code>rm &lt;number&gt;</code>，其中<code>number</code>是分区编号。</td></tr><tr><td>print</td><td>显示分区表</td><td>列出指定磁盘上的所有分区信息。</td></tr><tr><td>name</td><td>给分区命名</td><td>格式：<code>name &lt;number&gt; &lt;name&gt;</code>，给指定编号的分区命名。</td></tr><tr><td>set</td><td>设置分区标志</td><td>格式：`set <number> <flag> &lt;on</td></tr><tr><td>resizepart</td><td>调整分区大小</td><td>格式：<code>resizepart &lt;number&gt; &lt;end&gt;</code>，将分区调整到新的结束位置。</td></tr><tr><td>move</td><td>移动分区</td><td>格式：<code>move &lt;number&gt; &lt;start&gt; &lt;end&gt;</code>，移动分区到新的位置。</td></tr><tr><td>mkfs</td><td>创建文件系统</td><td>格式：<code>mkfs &lt;number&gt; &lt;fs-type&gt;</code>，例如<code>mkfs 1 ext4</code>。</td></tr><tr><td>align-check</td><td>检查分区对齐</td><td>格式：<code>align-check &lt;opt&gt; &lt;number&gt;</code>，例如<code>align-check optimal 1</code>。</td></tr><tr><td>rescue</td><td>尝试恢复丢失的分区</td><td>格式：<code>rescue &lt;start&gt; &lt;end&gt;</code>，尝试在指定范围内恢复分区。</td></tr><tr><td>quit</td><td>退出parted</td><td>退出parted交互模式。</td></tr><tr><td>unit</td><td>设置显示单位</td><td>格式：<code>unit &lt;unit&gt;</code>，其中<code>unit</code>可以是<code>s</code>(扇区)、<code>MB</code>、<code>GB</code>等。</td></tr></tbody></table><h5 id="启动parted"><a href="#启动parted" class="headerlink" title="启动parted"></a>启动parted</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo parted /dev/sdb</span><br></pre></td></tr></table></figure><h5 id="创建新的分区表（GPT）"><a href="#创建新的分区表（GPT）" class="headerlink" title="创建新的分区表（GPT）"></a>创建新的分区表（GPT）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br></pre></td></tr></table></figure><h5 id="创建新分区-1"><a href="#创建新分区-1" class="headerlink" title="创建新分区"></a>创建新分区</h5><p>创建一个从1MiB开始，500MiB结束的主分区，文件系统类型为ext4：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br></pre></td></tr></table></figure><h5 id="删除分区-1"><a href="#删除分区-1" class="headerlink" title="删除分区"></a>删除分区</h5><p>删除刚才创建的第一个分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">rm</span> 1</span><br></pre></td></tr></table></figure><h5 id="调整分区大小"><a href="#调整分区大小" class="headerlink" title="调整分区大小"></a>调整分区大小</h5><p>假设重新创建了一个分区，现在调整其大小到1000MiB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary ext4 1MiB 500MiB</span><br><span class="line">(parted) resizepart 1 1000MiB</span><br></pre></td></tr></table></figure><h5 id="设置分区标志"><a href="#设置分区标志" class="headerlink" title="设置分区标志"></a>设置分区标志</h5><p>设置第一个分区的启动标志：</p><p>可设置的标识有：</p><p><code>boot</code>：引导分区</p><p><code>esp</code>：EFI系统分区（通常用于UEFI引导）</p><p><code>lvm</code>：逻辑卷管理</p><p><code>raid</code>：RAID分区</p><p><code>swap</code>：交换分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">set</span> &lt;分区编号&gt; &lt;标识&gt; on</span><br></pre></td></tr></table></figure><h5 id="显示分区表"><a href="#显示分区表" class="headerlink" title="显示分区表"></a>显示分区表</h5><p>显示当前的分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h5 id="给分区命名"><a href="#给分区命名" class="headerlink" title="给分区命名"></a>给分区命名</h5><p>给第一个分区命名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) name 1 my_partition</span><br></pre></td></tr></table></figure><h5 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h5><p>在第一个分区上创建ext4文件系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) mkfs 1 ext4</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><ol><li><p><strong>ext4</strong>：</p><ul><li>目前最广泛使用的Linux文件系统，ext4具有良好的性能、稳定性和兼容性，支持大文件和大容量存储，适用于大多数应用场景。</li></ul></li><li><p><strong>XFS</strong>：</p><ul><li>XFS是一个高性能的日志文件系统，擅长处理大文件和高并发环境，常用于需要高性能和可扩展性的服务器和存储系统。</li></ul></li><li><p><strong>Btrfs</strong>：</p><ul><li>Btrfs（B-tree FS）支持快照、压缩、多设备存储池、在线文件系统检查和修复等高级功能，适用于需要高级数据管理和灵活性的环境。</li></ul></li><li><p>**ZFS on Linux (ZoL)**：</p><ul><li>ZFS具有高度的数据完整性、快照和复制等高级特性，适用于高存储要求的环境，如服务器和大型存储系统。</li></ul></li></ol><h5 id="检查分区对齐"><a href="#检查分区对齐" class="headerlink" title="检查分区对齐"></a>检查分区对齐</h5><p>检查第一个分区的对齐情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) align-check optimal 1</span><br></pre></td></tr></table></figure><h5 id="尝试恢复丢失的分区"><a href="#尝试恢复丢失的分区" class="headerlink" title="尝试恢复丢失的分区"></a>尝试恢复丢失的分区</h5><p>假设分区丢失，尝试在指定范围内恢复分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) rescue 1MiB 1000MiB</span><br></pre></td></tr></table></figure><h5 id="退出parted"><a href="#退出parted" class="headerlink" title="退出parted"></a>退出parted</h5><p>退出parted：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(parted) quit</span><br></pre></td></tr></table></figure><h5 id="验证操作"><a href="#验证操作" class="headerlink" title="验证操作"></a>验证操作</h5><p>为了验证这些操作，可以使用<code>lsblk</code>或<code>fdisk -l</code>来查看分区表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsblk</span><br><span class="line">sudo fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure><p>系统中没有parted工具，可以通过以下命令安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install parted  <span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo yum install parted      <span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo dnf install parted      <span class="comment"># Fedora</span></span><br></pre></td></tr></table></figure><h4 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h4><p>LVM 是一种逻辑卷管理器，允许对硬盘和其他存储设备进行灵活的分区管理。</p><p>ps: 逻辑卷是由LVM创建和管理的虚拟存储单元，可以跨越多个物理磁盘或分区。逻辑卷是建立在物理卷之上，物理卷可以是整个磁盘分区或RAID设备。</p><h5 id="为什么要用到LVM"><a href="#为什么要用到LVM" class="headerlink" title="为什么要用到LVM"></a>为什么要用到LVM</h5><p>有工具就是因为有需求，传统的分区因为固定分区大小，需要停机调整分区，影响服务可用。所以需要用到LVM，在线扩展逻辑卷的大小无需停机，只需要添加新的物理硬盘到卷组（VG）中，然后扩展逻辑卷（LV）大小。除此之外，还能够快速创建备份，不需要传统的长时间锁定数据库，还能够整合多个磁盘设备成为一个存储池，能够在数据迁移阶段，避免长时间停机。</p><h5 id="怎么查看逻辑卷"><a href="#怎么查看逻辑卷" class="headerlink" title="怎么查看逻辑卷"></a>怎么查看逻辑卷</h5><h6 id="了解大概的可用块设备"><a href="#了解大概的可用块设备" class="headerlink" title="了解大概的可用块设备"></a>了解大概的可用块设备</h6><p>这张图片显示了<code>lsblk</code>命令的输出，列出了系统中的所有块设备及其挂载点。以下是对这张图片的详细描述：</p><ol><li><p><strong>loop设备</strong>：</p><ul><li><strong>loop0</strong>: 111.9M, 类型为loop，挂载在<code>/snap/lxd/24322</code></li><li><strong>loop1</strong>: 87M, 类型为loop，挂载在<code>/snap/lxd/28373</code></li><li><strong>loop2</strong>: 53.3M, 类型为loop，挂载在<code>/snap/snapd/19457</code></li><li><strong>loop3</strong>: 38.8M, 类型为loop，挂载在<code>/snap/core20/1974</code></li><li><strong>loop4</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2318</code></li><li><strong>loop5</strong>: 63.9M, 类型为loop，挂载在<code>/snap/core20/2456</code></li></ul></li><li><p><strong>物理磁盘</strong>：</p><ul><li><p>sda</p><p>: 25G, 类型为disk</p><ul><li><strong>sda1</strong>: 1M, 类型为part，没有挂载点（这可能是BIOS引导分区或其他用途的特殊分区）</li><li><strong>sda2</strong>: 2G, 类型为part，挂载在<code>/boot</code></li><li><strong>sda3</strong>: 23G, 类型为part，没有挂载点（这可能是LVM物理卷）</li></ul></li></ul></li><li><p><strong>逻辑卷管理器（LVM）</strong>：</p><ul><li><strong>ubuntu–vg-ubuntu–lv</strong>: 12.5G, 类型为lvm，挂载在<code>/</code></li></ul></li><li><p><strong>光驱设备</strong>：</p><ul><li><strong>sr0</strong>: 2G, 类型为rom，没有挂载点</li></ul></li><li></li></ol><ul><li><p><strong>loop设备</strong>：这些是虚拟设备，通常用于挂载磁盘映像文件。</p></li><li><p>sda</p><p>：这是系统中的一个物理磁盘，包含三个分区（sda1, sda2, sda3）。</p><ul><li><strong>sda1</strong>：非常小，只有1M，通常用于系统引导或其他特殊用途。</li><li><strong>sda2</strong>：挂载在<code>/boot</code>，通常用于存放启动加载程序和内核。</li><li><strong>sda3</strong>：较大，为23G，可能用于LVM管理。</li></ul></li><li><p><strong>LVM逻辑卷</strong>：<code>ubuntu--vg-ubuntu--lv</code>是一个逻辑卷，挂载在根目录<code>/</code>。这表示LVM在管理这个分区的存储。</p></li><li><p><strong>光驱设备（sr0）</strong>：显示为2G，未挂载。</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709110545123.png" alt="image-20240709110545123"></p><h6 id="扩展逻辑卷大概步骤"><a href="#扩展逻辑卷大概步骤" class="headerlink" title="扩展逻辑卷大概步骤"></a>扩展逻辑卷大概步骤</h6><ol><li>添加新物理硬盘</li><li>将新的物理硬盘初始化为物理卷(PV)</li><li>将PV添加到现在的卷组VG</li><li>扩展逻辑卷LV的大小</li></ol><ul><li><strong>示例</strong>: 创建一个逻辑卷</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建物理卷</span></span><br><span class="line">pvcreate /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建卷组</span></span><br><span class="line">vgcreate myvg /dev/sdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建逻辑卷</span></span><br><span class="line">lvcreate -L 10G -n mylv myvg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化逻辑卷</span></span><br><span class="line">mkfs.ext4 /dev/myvg/mylv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载点</span></span><br><span class="line">mkdir /mnt/kalyantest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载载目录上（ps：一个逻辑卷只能挂载一个目录）</span></span><br><span class="line">mount /mnt/kalyantest</span><br></pre></td></tr></table></figure><h6 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h6><p>创建lvm分区以及扩容</p><ol><li>首先增加物理盘<br><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114035255.png" alt="image-20240709114035255"></li><li>然后查询存储块</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114244596.png" alt="image-20240709114244596"></p><ol start="3"><li>为物理盘建立分区</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709114615916.png" alt="image-20240709114615916"></p><ol start="4"><li>创建PV，VG，LV</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115109564.png" alt="image-20240709115109564"></p><ol start="5"><li>格式化lv<pre><code>![image-20240709115309348](https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115309348.png)</code></pre></li><li>创建挂载目录（也可挂载在你想挂载的地方），并进行挂载(ps:记得修改etc/fstab文件，不然重启会丢失mount点)</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240709115612877.png" alt="image-20240709115612877"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;磁盘方面&quot;&gt;&lt;a href=&quot;#磁盘方面&quot; class=&quot;headerlink&quot; title=&quot;磁盘方面&quot;&gt;&lt;/a&gt;磁盘方面&lt;/h3&gt;&lt;h4 id=&quot;磁盘分区&quot;&gt;&lt;a href=&quot;#磁盘分区&quot; class=&quot;headerlink&quot; title=&quot;磁盘分区&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="linux" scheme="https://kalyan-zitiu.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://kalyan-zitiu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Blog脚本编写</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/07/%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2024-07-07T03:03:50.000Z</published>
    <updated>2024-07-07T03:34:02.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺好的，公司的前辈们挺有趣的，而且感觉在这里努力下去会有收获的感觉。回到正题，因为运维实习的原因，在正式上岗工作之前都会有一段培训，所以写博客的机会就变多了，因为我的博客框架原因，我每次写博客都需要处理一下页头的一些参数，而且需要用git进行仓库上传，这些重复的工作有点繁琐，所以打算写两个脚本来处理一下。</p><h2 id="页头处理"><a href="#页头处理" class="headerlink" title="页头处理"></a>页头处理</h2><p> 我的页头格式是这样的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707111114634.png" alt="image-20240707111114634"></p><h3 id="模块确定"><a href="#模块确定" class="headerlink" title="模块确定"></a>模块确定</h3><p>基本涉及到一些题目，时间，分类，标签，图片，作者之类的，有时候还会涉及到是否加密等。所以第一时间需要考虑的是，这个脚本需要能够获取时间，其次要能够快捷输入题目，标签以及分类和用的图片序号，所以需要GUI，然后还需要能够处理文件系统。故基本能够确定三个模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime  <span class="comment"># 导入datetime模块，用于处理日期和时间</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  <span class="comment"># 从pathlib导入Path，用于处理文件系统路径</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 导入tkinter，用于创建GUI应用程序</span></span><br></pre></td></tr></table></figure><h3 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h3><p>然后就可以开始写专门用来生成头部的函数，根据一些页头的结构和格式，进行编写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_markdown_header</span>(<span class="params">title, categories, tags, wallpaper_index</span>):</span><br><span class="line">    now = datetime.datetime.now()  <span class="comment"># 获取当前日期和时间</span></span><br><span class="line">    date_str = now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="comment"># 将日期和时间格式化为字符串</span></span><br><span class="line">    author = <span class="string">&quot;Kalyan&quot;</span>  <span class="comment"># 作者名称</span></span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的类别项字符串</span></span><br><span class="line">    categories_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;cat.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> cat <span class="keyword">in</span> categories.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 创建一个格式化为Markdown的标签项字符串</span></span><br><span class="line">    tags_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;- <span class="subst">&#123;tag.strip()&#125;</span>&quot;</span> <span class="keyword">for</span> tag <span class="keyword">in</span> tags.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment"># 使用提供的信息构建完整的Markdown头部</span></span><br><span class="line">    markdown_header = <span class="string">f&quot;&quot;&quot;---</span></span><br><span class="line"><span class="string">title: <span class="subst">&#123;title&#125;</span></span></span><br><span class="line"><span class="string">date: <span class="subst">&#123;date_str&#125;</span></span></span><br><span class="line"><span class="string">categories:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;categories_str&#125;</span></span></span><br><span class="line"><span class="string">tags:</span></span><br><span class="line"><span class="string"><span class="subst">&#123;tags_str&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">description: </span></span><br><span class="line"><span class="string">top_img: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">cover: /img/WallPaper (<span class="subst">&#123;wallpaper_index&#125;</span>).jpg</span></span><br><span class="line"><span class="string">copyright_author: <span class="subst">&#123;author&#125;</span></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> markdown_header  <span class="comment"># 返回构建的Markdown头部</span></span><br></pre></td></tr></table></figure><h3 id="GUI事件处理"><a href="#GUI事件处理" class="headerlink" title="GUI事件处理"></a>GUI事件处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理GUI中提交按钮点击的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_submit</span>():</span><br><span class="line">    title = title_entry.get()  <span class="comment"># 从文本输入小部件获取标题</span></span><br><span class="line">    categories = categories_entry.get()  <span class="comment"># 从文本输入小部件获取类别</span></span><br><span class="line">    tags = tags_entry.get()  <span class="comment"># 从文本输入小部件获取标签</span></span><br><span class="line">    wallpaper_index = wallpaper_entry.get()  <span class="comment"># 从文本输入小部件获取壁纸序号</span></span><br><span class="line">    header = generate_markdown_header(title, categories, tags, wallpaper_index)  <span class="comment"># 生成Markdown头部</span></span><br><span class="line">    desktop = Path.home() / <span class="string">&#x27;Desktop&#x27;</span>  <span class="comment"># 获取桌面路径</span></span><br><span class="line">    file_name = title.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;_&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.md&quot;</span>  <span class="comment"># 创建文件名</span></span><br><span class="line">    full_path = desktop / file_name  <span class="comment"># 完整的文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(full_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 打开文件进行写入</span></span><br><span class="line">        f.write(header)  <span class="comment"># 写入Markdown头部</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件已保存在桌面: <span class="subst">&#123;full_path&#125;</span>&quot;</span>)  <span class="comment"># 打印文件保存位置</span></span><br><span class="line"></span><br><span class="line">    root.destroy()  <span class="comment"># 关闭GUI</span></span><br></pre></td></tr></table></figure><h3 id="窗口UI调整"><a href="#窗口UI调整" class="headerlink" title="窗口UI调整"></a>窗口UI调整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = tk.Tk()</span><br><span class="line">root.title(<span class="string">&quot;文章信息输入&quot;</span>)  <span class="comment"># 设置窗口标题</span></span><br><span class="line">root.geometry(<span class="string">&quot;400x200&quot;</span>)  <span class="comment"># 设置窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并放置各种标签和输入框</span></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;文章标题:&quot;</span>).pack()</span><br><span class="line">title_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">title_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;分类（用逗号分隔）-&quot;</span>).pack()</span><br><span class="line">categories_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">categories_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;标签（用逗号分隔）:&quot;</span>).pack()</span><br><span class="line">tags_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">tags_entry.pack()</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=<span class="string">&quot;壁纸序号:&quot;</span>).pack()</span><br><span class="line">wallpaper_entry = tk.Entry(root, width=<span class="number">50</span>)</span><br><span class="line">wallpaper_entry.pack()</span><br><span class="line"></span><br><span class="line">submit_button = tk.Button(root, text=<span class="string">&quot;提交&quot;</span>, command=on_submit)  <span class="comment"># 创建提交按钮</span></span><br><span class="line">submit_button.pack()</span><br><span class="line"></span><br><span class="line">root.mainloop()  <span class="comment"># 启动GUI事件循环</span></span><br></pre></td></tr></table></figure><p>以上搞定，然后就是打包创建可执行文件就好了。感觉还不错。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112220421.png" alt="image-20240707112220421"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112235909.png" alt="image-20240707112235909"></p><h2 id="上传处理"><a href="#上传处理" class="headerlink" title="上传处理"></a>上传处理</h2><p>这次并用不上写python脚本，只需要用批处理就好了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240707112640400.png" alt="image-20240707112640400"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近来深圳上班了，这座城市给我的感觉就是有的伸不开身子的感觉，到处都很拥挤，人挤，楼挤，路挤，生活节奏也很挤。来深圳第三天了，但是感觉还是挺</summary>
      
    
    
    
    <category term="python" scheme="https://kalyan-zitiu.github.io/categories/python/"/>
    
    
    <category term="脚本" scheme="https://kalyan-zitiu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>VMware vSphere</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/07/VMware%20vSphere/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/07/VMware%20vSphere/</id>
    <published>2024-07-07T03:01:04.000Z</published>
    <updated>2024-07-08T02:36:43.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是vmware官方开发的一套虚拟化平台</p><h2 id="能够干什么"><a href="#能够干什么" class="headerlink" title="能够干什么"></a>能够干什么</h2><ol><li>虚拟化：将物理服务器的资源分配给多个VM，提高硬件资源利用率，减少硬件成本。</li><li>集中管理：统一管理监控整个虚拟化环境，包括虚拟机，主机，网络和存储</li><li>高可用提供：能够自动重启故障的物理服务器，保持业务连续。</li><li>资源优化：提供分布式资源调度DRS功能，动态调整VM资源，性能和负载</li><li>安全：能够网络隔离，访问控制，数据加密</li><li>数据保护：提供快照和备份，支持快速恢复</li><li>自动化和编排，通过脚本和工具实现虚拟机的快速部署。</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="ESXi"><a href="#ESXi" class="headerlink" title="ESXi"></a>ESXi</h3><p>是VMware vSphere虚拟化平台的核心组件。它是一种小型的、专用的操作系统，直接安装在物理服务器上，用于运行和管理虚拟机（VM）。可以说有ESXi的OS的物理服务器就是宿主机Host。</p><h3 id="vSwitch"><a href="#vSwitch" class="headerlink" title="vSwitch"></a>vSwitch</h3><p>运行在VMware ESXi主机上的软件交换机，用于管理虚拟网络。它类似于物理交换机，但功能更灵活，能够在虚拟化环境中提供网络连接和管理。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>网络连接：提供VM之间的网络连接，以及虚拟机与外部物理网络的连接。</p></li><li><p>流量隔离和管理：通过VLAN（虚拟局域网）标签，vSwitch可以隔离和管理不同虚拟机的网络流量，提高网络安全性和性能。</p></li><li><p>网络适配器绑定：vSwitch支持将多个物理网络适配器（NIC）绑定在一起，提供冗余和负载均衡，提高网络的可用性和带宽。</p></li></ol><p>ps: NIC即网络接口卡，是计算机硬件组件，用于计算机与网络的连接。它通常以插卡形式存在，插入计算机主板的扩展槽中，也有集成在主板上的形式。</p><ol start="4"><li><p>流量整形：vSwitch能够对进出网络流量进行整形（Traffic Shaping），控制流量速率，确保网络性能的稳定性。</p></li><li><p>安全特性：vSwitch具备安全特性，如防止MAC地址欺骗和IP地址欺骗，提升虚拟网络的安全性。 </p></li></ol><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="标准虚拟交换机（vSS）"><a href="#标准虚拟交换机（vSS）" class="headerlink" title="标准虚拟交换机（vSS）"></a>标准虚拟交换机（vSS）</h5><ul><li>独立管理：每台ESXi主机上的vSS独立管理，不同主机上的vSS配置相互独立</li><li>本地主机管理：配置和管理通过ESXi主机的Host Client或vSphere Clinet进行。</li><li>手动配置：手动为每个ESXi主机上分别配置，配置工作量大。</li><li>适用小型环境：适合规模较小或独立的环境，网络配置相对简单<br>ps：缺乏跨主机的集中管理和高级网络功能。</li></ul><h5 id="分布式虚拟交换机（vDS）"><a href="#分布式虚拟交换机（vDS）" class="headerlink" title="分布式虚拟交换机（vDS）"></a>分布式虚拟交换机（vDS）</h5><ul><li>集中管理：能够跨多个ESXi主机统一配置管理</li><li>视图统一：提供网络配置视图，简化大规模环境中的网络管理。</li><li>集中配置：可以在vCenter Server中一次性配置和管理所有相关ESXi主机上的网络设备</li><li>适用于大环境：适合规模大，复杂的，网络配置需求高的。</li></ul><p>ps：拥有比较高级的功能，入Private VLAN，网络IO控制（NetIOC），分布式端口镜像（Port Mirroring）/简化迁移能够网络配置一起迁移，无需重新配置。</p><h5 id="VLAN-和Private-VALN"><a href="#VLAN-和Private-VALN" class="headerlink" title="VLAN 和Private VALN"></a>VLAN 和Private VALN</h5><ol><li>VLAN: </li></ol><ul><li>主要通过交换机端口配置，将交换机端口分到不同的VLAN中。每个VLAN都有唯一的VLAN ID</li><li>设备之间通信得在同一VLAN进行，不同VLAN之间通信需要通过三层设备（如路由器，三层交换机）</li></ul><ol start="2"><li>Private VLAN</li></ol><ul><li>进一步细分VLAN内部的子VLAN，从而提供更精细的流量隔离和控制。</li><li>避免VLAN ID的浪费，适合大规模网络环境。</li></ul><h6 id="Private实现"><a href="#Private实现" class="headerlink" title="Private实现"></a>Private实现</h6><ol><li>Private VLAN将一个VLAN划分为主VLAN（Primary VLAN）和子VLAN（Secondary VLAN）。子VLAN又分为两种类型：Isolated VLAN和Community VLAN。</li></ol><ul><li>Primary VLAN：主VLAN，包含所有的Secondary VLAN。</li><li>Isolated VLAN：隔离VLAN，主机只能与Promiscuous端口通信，不能与其他任何端口通信。</li><li>Community VLAN：社区VLAN，主机可以与同一个Community VLAN内的其他主机和Promiscuous端口通信，但不能与其他Community VLAN或Isolated VLAN内的主机通信。</li><li>Promiscuous端口：可以与所有子VLAN内的端口通信，通常用于连接网关或路由器等设备。</li></ul><h5 id="vDS和vSS的区别"><a href="#vDS和vSS的区别" class="headerlink" title="vDS和vSS的区别"></a>vDS和vSS的区别</h5><p>管理上，vSS独立管理（每个ESXi独立配置），vDS集中管理（跨多个ESXi主机统一配置）<br>功能上，vSS网络配置简单，vDS提供高级网络功能。</p><h3 id="Datastore"><a href="#Datastore" class="headerlink" title="Datastore"></a>Datastore</h3><ul><li>Datastore是一个逻辑存储单元，由ESXi主机创建和管理。</li><li>它可以基于不同类型的物理存储，如本地硬盘、NFS共享、iSCSI目标和SAN存储。</li><li>Datastore用于存储虚拟机的虚拟磁盘文件（.vmdk）、配置文件（.vmx）、ISO映像文件以及其他虚拟机相关的数据。</li></ul><h4 id="数据存储类型及其特点"><a href="#数据存储类型及其特点" class="headerlink" title="数据存储类型及其特点"></a>数据存储类型及其特点</h4><ol><li>本地</li></ol><ul><li>直接连接单个ESXi主机的存储设备，SATA，SAS，SSD硬盘</li></ul><ol start="2"><li>SAN（Storage Area Network）</li></ol><ul><li>高性能，低延迟的存储网络，通常使用光纤通道或iSCSI协议连接</li><li>提供集中管理和共享存储</li></ul><ol start="3"><li>NAS（Network Attached Storage）</li></ol><ul><li>通过标准网络协议（IFS或SMB）访问存储设备</li><li>适用于文件级存储需求</li></ul><ol start="4"><li>vSAN（Virtual SAN）</li></ol><ul><li>VM的分布式存储解决方案，集群中所有ESXi主机的本地存储集合成一个逻辑数据存储。</li><li>提供高性能，可扩展共享存储，支持高可用性。</li></ul><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><ul><li>VMFS： 块存储，如SAN和本地存储。</li><li>NFS：网络附加存储如NAS。</li><li>vSAN:分布式存储解决方案。</li></ul><h3 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h3><p>用于管理和分配计算资源（如CPU和内存）。</p><h4 id="资源池的关键特性"><a href="#资源池的关键特性" class="headerlink" title="资源池的关键特性"></a>资源池的关键特性</h4><ol><li><strong>资源分配</strong>：<ul><li><strong>预留（Reservation）</strong>：确保虚拟机或资源池可以使用的最小资源量。预留的资源保证在所有者需要时始终可用。</li><li><strong>限制（Limit）</strong>：资源池或虚拟机可以使用的最大资源量。限制防止单个实体使用过多资源，影响其他实体的性能。</li><li><strong>份额（Shares）</strong>：定义资源争用时的相对优先级。份额是一个权重，用于确定在资源紧张时各个虚拟机或资源池的优先级。</li></ul></li><li><strong>灵活的资源管理</strong>：<ul><li>动态调整资源：管理员可以在不影响虚拟机运行的情况下动态调整资源池的配置。</li><li>自动化资源分配：配合VMware的DRS（分布式资源调度），可以自动平衡资源池之间的负载。</li></ul></li><li><strong>资源池的层次结构</strong>：<ul><li><strong>根资源池（Root Resource Pool）</strong>：默认存在于每个主机或集群中，是最顶层的资源池。</li><li><strong>子资源池（Child Resource Pool）</strong>：创建在根资源池或其他资源池下，形成树状结构。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;是vmware官方开发的一套虚拟化平台&lt;/p&gt;
&lt;h2 id=&quot;能够干什么&quot;&gt;&lt;a href=&quot;#能够干什么&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="VMware" scheme="https://kalyan-zitiu.github.io/categories/VMware/"/>
    
    
    <category term="虚拟化" scheme="https://kalyan-zitiu.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CNI</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/05/CNI/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/05/CNI/</id>
    <published>2024-07-05T01:51:24.000Z</published>
    <updated>2024-07-05T03:01:35.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>定义容器运行时，如何配置网络接口，以便容器可以网络通信。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ul><li>关注网络连接和网络解除连接</li><li>支持各种不同的网络配置要求</li><li>通过各种不同的网络解决方案解决网络配置。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>当一个Pod被创建时，k8s调用CNI插件来为pod配置网络，通常包括分配IP地址，设置网络路由和创建网络接口等任务。CNI插件负责把pod连接到一个预先的环境，保证pod之间的网络通信。</p><h2 id="常见的-CNI-插件："><a href="#常见的-CNI-插件：" class="headerlink" title="常见的 CNI 插件："></a>常见的 CNI 插件：</h2><ul><li><strong>Calico</strong>：提供高性能的网络和网络策略，支持跨主机的网络隔离。</li><li><strong>Flannel</strong>：简单易用，主要用于创建一个覆盖网络，允许 Pod 跨节点通信。</li><li><strong>Weave Net</strong>：提供一个强大的网络和网络策略，支持自动发现和网络隔离。</li><li><strong>Cilium</strong>：使用 BPF（Berkeley Packet Filter）来提供网络安全、策略执行和负载均衡功能。</li></ul><h3 id="1-Calico"><a href="#1-Calico" class="headerlink" title="1. Calico"></a>1. <strong>Calico</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>高性能</strong>：Calico 使用 BGP（边界网关协议）进行路由，避免了封装和解封装的开销，从而提供高性能的网络连接。</li><li><strong>网络策略</strong>：Calico 提供强大的网络策略功能，允许用户定义细粒度的访问控制规则。</li><li><strong>可扩展性</strong>：适用于大规模集群，能够处理成千上万的节点和 Pod。</li><li><strong>安全性</strong>：支持网络隔离和加密，确保数据在传输过程中安全。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>大规模生产环境</strong>：由于其高性能和可扩展性，Calico 非常适合大规模生产环境。</li><li><strong>需要严格网络策略的环境</strong>：如果需要细粒度的网络访问控制和安全策略，Calico 是一个理想的选择。</li></ul><h3 id="2-Flannel"><a href="#2-Flannel" class="headerlink" title="2. Flannel"></a>2. <strong>Flannel</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>简单易用</strong>：Flannel 设计简单，易于部署和管理。</li><li><strong>覆盖网络</strong>：主要提供覆盖网络，使用 UDP、VXLAN 或 host-gw 模式来封装跨主机的容器流量。</li><li><strong>轻量级</strong>：适合中小规模的集群，不需要复杂的配置。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>中小规模集群</strong>：由于其简单性和轻量级特性，Flannel 适用于中小规模的 Kubernetes 集群。</li><li><strong>快速部署</strong>：如果需要快速部署一个 Kubernetes 集群，Flannel 是一个不错的选择。</li></ul><h3 id="3-Weave-Net"><a href="#3-Weave-Net" class="headerlink" title="3. Weave Net"></a>3. <strong>Weave Net</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>自发现网络</strong>：Weave Net 能够自动发现和管理网络配置，简化了网络管理。</li><li><strong>网络加密</strong>：支持网络流量加密，确保数据在传输过程中的安全性。</li><li><strong>多云支持</strong>：能够跨多个云提供商和本地数据中心创建统一的网络。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>多云环境</strong>：Weave Net 非常适合需要跨多个云提供商和本地数据中心的环境。</li><li><strong>需要网络加密的环境</strong>：如果需要确保网络流量的安全性，Weave Net 是一个理想的选择。</li></ul><h3 id="4-Cilium"><a href="#4-Cilium" class="headerlink" title="4. Cilium"></a>4. <strong>Cilium</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>基于 BPF</strong>：Cilium 使用 Linux 内核的 BPF 技术来实现高性能和可扩展的网络功能。</li><li><strong>Layer 7 支持</strong>：支持 HTTP/HTTPS、gRPC 等 Layer 7 协议的负载均衡和安全策略。</li><li><strong>可见性和监控</strong>：提供丰富的网络可见性和监控功能，帮助用户了解网络流量和性能。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要高级网络功能的环境</strong>：Cilium 非常适合需要高级网络功能和安全策略的环境。</li><li><strong>微服务架构</strong>：由于其对 Layer 7 协议的支持，Cilium 非常适合微服务架构。</li></ul><h3 id="5-Canal"><a href="#5-Canal" class="headerlink" title="5. Canal"></a>5. <strong>Canal</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>结合了 Flannel 和 Calico</strong>：Canal 将 Flannel 的简单性和 Calico 的网络策略功能结合在一起。</li><li><strong>灵活性</strong>：提供了 Flannel 的覆盖网络和 Calico 的网络策略，适用于多种场景。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要简单网络和策略控制的环境</strong>：Canal 适用于需要简单网络配置和基本网络策略控制的环境。</li><li><strong>中小规模集群</strong>：由于其灵活性和简单性，Canal 适用于中小规模的 Kubernetes 集群。</li></ul><h3 id="6-Kube-Router"><a href="#6-Kube-Router" class="headerlink" title="6. Kube-Router"></a>6. <strong>Kube-Router</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>综合功能</strong>：Kube-Router 提供网络路由、网络策略和服务代理功能。</li><li><strong>高性能</strong>：使用 BGP 进行路由，提供高性能的网络连接。</li><li><strong>易于部署</strong>：集成了多个网络功能，简化了部署和管理。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>需要综合网络功能的环境</strong>：Kube-Router 适用于需要综合网络功能（如路由、策略和服务代理）的环境。</li><li><strong>高性能需求</strong>：由于其高性能特性，Kube-Router 适用于对网络性能有较高要求的环境。</li></ul><h3 id="7-Multus"><a href="#7-Multus" class="headerlink" title="7. Multus"></a>7. <strong>Multus</strong></h3><p><strong>特点</strong>:</p><ul><li><strong>多网络支持</strong>：Multus 允许一个 Pod 连接到多个网络，支持多种 CNI 插件的组合使用。</li><li><strong>灵活性</strong>：提供了极大的灵活性，适用于复杂的网络需求。</li></ul><p><strong>使用场景</strong>:</p><ul><li><strong>复杂网络需求</strong>：Multus 适用于需要多个网络接口和复杂网络配置的环境。</li><li><strong>多 CNI 插件组合</strong>：如果需要同时使用多个 CNI 插件，Multus 是一个理想的选择。</li></ul>]]></content>
    
    
    <summary type="html">容器网络接口</summary>
    
    
    
    <category term="K8s" scheme="https://kalyan-zitiu.github.io/categories/K8s/"/>
    
    <category term="CNI" scheme="https://kalyan-zitiu.github.io/categories/K8s/CNI/"/>
    
    
    <category term="Kubernets" scheme="https://kalyan-zitiu.github.io/tags/Kubernets/"/>
    
  </entry>
  
  <entry>
    <title>CRI容器运行时接口</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/04/CRI/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/04/CRI/</id>
    <published>2024-07-04T08:22:37.000Z</published>
    <updated>2024-07-22T01:26:10.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRI-容器运行时接口"><a href="#CRI-容器运行时接口" class="headerlink" title="CRI (容器运行时接口)"></a>CRI (容器运行时接口)</h1><p>了解CRI之前，我们先了解一下什么是RPC</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  一种常用的通信机制，运行程序调用位于远程计算机上的行数或方法，就像调用本地对象一眼。RPC抽象了底层的网络通信细节，使得开发者可以更加专注与业务逻辑的开发，不必过多担心网络相关性的复杂性。</p><h3 id="RPC工作原理"><a href="#RPC工作原理" class="headerlink" title="RPC工作原理"></a>RPC工作原理</h3><h4 id="客户端调用过程"><a href="#客户端调用过程" class="headerlink" title="客户端调用过程"></a>客户端调用过程</h4><ol><li>客户端程序调用一个本地的存根（stub）函数，这个存根代表远程函数</li><li>存根将函数调用的参数打包成一个消息，通过网络发送给服务端</li><li>客户端等待服务端响应</li></ol><h4 id="服务端处理过程"><a href="#服务端处理过程" class="headerlink" title="服务端处理过程"></a>服务端处理过程</h4><ol><li>服务器收到消息，解包得到调用参数。</li><li>服务端调用本地实际函数，执行必要的处理。</li><li>处理完毕后，服务端将结果打包并发送回客户端。<h4 id="客户端接收过程"><a href="#客户端接收过程" class="headerlink" title="客户端接收过程"></a>客户端接收过程</h4></li><li>客户端存根收到响应消息，解包得到结果</li><li>客户端的调用像本地执行一样，得到从远程服务器返回的结果。</li></ol><h3 id="RPC特点"><a href="#RPC特点" class="headerlink" title="RPC特点"></a>RPC特点</h3><ul><li>封装:隐藏网络通信细节，开发者无需直接处理socket编程或其他通信协议细节</li><li>同步:默认同步，即客户端调用一个远程方法时候，回阻塞知道得到结果，尽管如此，许多现代RPC框架支持异步调用。</li><li>透明:</li></ul><h3 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h3><ul><li><p>Finagle：一个构建高并发，分布式系统的异步RPC库，用Scala语言编写，但可以与其他JVM语言一起使用，适合用于高扩展，弹性和容错（异步编程模型，有效地处理大量并发请求，不会阻塞线程，支持多种协议，内置负载均衡）</p></li><li><p>gRPC：由Google开发，基于HTTP/2协议，支持多种语言，能够提供高性能的通信。gRPC使用Protocol Buffers作为其接口定义语言和消息序列化格式。</p></li><li><p>Apache Thrift：由Facebook开发，支持跨语言服务的开发，使用自定义的IDL (Interface Definition Language) 来定义数据类型和服务接口。</p></li><li><p>JSON-RPC和XML-RPC：这些是较轻量级的RPC实现，使用JSON和XML格式分别进行数据序列化，易于与Web技术集成。</p></li></ul><h3 id="RPC应用场景"><a href="#RPC应用场景" class="headerlink" title="RPC应用场景"></a>RPC应用场景</h3><ul><li><p>微服务架构：在微服务架构中，各个服务组件常常需要进行网络通信，RPC提供了一种高效的方式来实现服务间的调用。</p></li><li><p>分布式计算：在需要多个节点共同完成计算任务的场景中，RPC可以用来协调各个节点之间的工作。</p></li></ul><p>让我再在了解CRI之前，先清楚什么是容器的执行以及生命周期</p><h2 id="容器执行和生命周期"><a href="#容器执行和生命周期" class="headerlink" title="容器执行和生命周期"></a>容器执行和生命周期</h2><p>容器的执行和生命周期是指容器从创建到终止的整个过程，涉及到创建，启动，运行，停止和删除。</p><ul><li>创建（Pre-production/Planning）：<br>就像电影制作前的筹备阶段，需要确定剧本、演员、场地等。在 Kubernetes 中，创建容器涉及配置容器的环境，如定义容器的镜像、资源限制（CPU、内存）、网络设置等。</li><li>启动（Production/Shooting）：<br>类似于电影开始拍摄。容器的启动阶段是指实际上将容器镜像运行起来。在这个阶段，容器内部的应用开始执行其预定任务，比如启动一个 Web 服务器、数据库服务等。</li><li>运行（Release/Screening）：<br>就像电影的放映过程。容器成功启动后，它会进入运行状态。在这个阶段，容器内的应用对外提供服务，如处理网络请求、执行数据处理等。</li><li>停止（Ending）：<br>类似于电影放映结束。当容器需要更新或不再需要时，它会被停止。停止容器通常意味着停止容器内部的应用进程。</li><li>删除（Post-production/Cleanup）：<br>就像电影拍摄后的清理阶段。在容器的生命周期的最后阶段，容器会被彻底删除，包括其在节点上的所有数据。这确保了不会留下无用的资源或数据。</li></ul><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>允许用户在容器的特殊阶段进行自定义操作。</p><h4 id="PostStart"><a href="#PostStart" class="headerlink" title="PostStart"></a>PostStart</h4><p><code>PostSrart</code>是在容器创建并启动后立即执行的钩子，这个钩子的执行时间是容器入口命令开始执行之后，但是并不保证是容器的应用程序完全启动之后再再执行。</p><p>ps：若是PostStart钩子启动失败，那么容器不会被杀死或者重启，钩子启动失败的记录会写入日志中。</p><h4 id="PreStop"><a href="#PreStop" class="headerlink" title="PreStop"></a>PreStop</h4><p><code>PreStop</code>是容器被终止钱执行的钩子。当k8s需要停止容器时，首先调用PreStop钩子，然后才会执行容器的终止过程。经常用于优雅的关闭应用程序，保存状态，执行清理任务。</p><p>ps：钩子是会延迟容器的终止过程的，因为k8s会等待钩子执行完成后才会发送SIGTERM信号停止容器。</p><h2 id="CRI是什么"><a href="#CRI是什么" class="headerlink" title="CRI是什么"></a>CRI是什么</h2><p>简单理解的话可以理解成一个适配器，就是为了管理不同容器运行时进行交互的一套标准接口。主要的作用是为了解决k8s直接依赖特定容器运行时的问题。主要是启动停止容器，拉取容器镜像，查询容器状态，管理容器生命周期。</p><ol><li>统一接口是通过RPC内gRPC框架实现的。</li><li>解耦合，完成了k8s与docker直接集成的紧密耦合关系。</li><li>可以让开发者通过自我需求或喜爱来选择合适的容器进行时。</li></ol><h3 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h3><ul><li>首先是使用了能够适应高并发低延迟的通信的HTTP/2，再头部压缩和多路复用请求等高效传输机制。</li><li>gRPC支持双向流，允许服务器和客户端再长连接中实时发送和接受消息。</li></ul><p>只有了解这么多了，gRPC还有很多有用的功能，适用场景也比较广，可能日后碰上这种场景后再继续了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRI-容器运行时接口&quot;&gt;&lt;a href=&quot;#CRI-容器运行时接口&quot; class=&quot;headerlink&quot; title=&quot;CRI (容器运行时接口)&quot;&gt;&lt;/a&gt;CRI (容器运行时接口)&lt;/h1&gt;&lt;p&gt;了解CRI之前，我们先了解一下什么是RPC&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="K8s" scheme="https://kalyan-zitiu.github.io/categories/K8s/"/>
    
    <category term="CRI" scheme="https://kalyan-zitiu.github.io/categories/K8s/CRI/"/>
    
    
    <category term="CRI" scheme="https://kalyan-zitiu.github.io/tags/CRI/"/>
    
  </entry>
  
  <entry>
    <title>Linux从核心到边缘</title>
    <link href="https://kalyan-zitiu.github.io/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kalyan-zitiu.github.io/2024/07/01/linux%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-01T15:42:37.000Z</published>
    <updated>2024-07-26T06:21:05.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux从核心到边缘"><a href="#Linux从核心到边缘" class="headerlink" title="Linux从核心到边缘"></a>Linux从核心到边缘</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>  今天有面试一家专注云原生产品的企业，有问到一个问题，就是你还有用过其他的Linux发行版吗，突然顿时觉得很惭愧，而且有一些基础的Linux问题居然发现我忘记了没有回答出来。而且仔细思考了一下，确实在大学期间仅仅只了解过Ubuntu偏向新手和私人开发的linux发行版，而且在命令上似乎只是停留在一些基础的操作（甚至有一些基础命令还忘记了），并没有深入的了解过Linux的内核。而且今天面试官说了一句话，就是从需求出发的科技探索更有利于我们进步。有的时候确实会把某些技术当作工具，但事实上确实是工具，作为一名希望在IT行业继续深耕的我，似乎越来越缺乏对技术美的欣赏，在大学没有多少生活压力的时期最应该体验这种美感的时候，却好像被一些<strong>保姆级</strong>教学一步步蒙蔽了眼睛。结果虽然出来了，但是可能对过程保留不多的记忆或者理解。只能说有时候学习的结果并不重要，重要的是一些有容错的过程。</p><h2 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h2><ul><li>内核类似一个资源的管理程序，负载资源调度到需要的系统进程，我看有些理解可以把内核理解成一个库，有了一组面向系统命令，系统调用应用程序来说，就像调用普通函数一样。其实内核也可以理解成一个桥梁，能够练习硬件和上层应用点的桥梁。一涉及到底层的东西就越来越抽象，还是能够用一些比喻理解比较好。</li><li><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/3435502-20240507214431792-1257148225.png" alt="img"></li></ul><h2 id="内核的角色"><a href="#内核的角色" class="headerlink" title="内核的角色"></a>内核的角色</h2><ul><li>内核是管理计算机的硬件资源的重要角色，就比如CPU，内存，存储设备和输入输出的设别。</li><li>内核主要威威上层提供了抽象的操作接口，让我们不需要关心硬件的细节。</li><li>内核维护不同程序和用户之间的安全界限，确保学习通的稳定和安全。</li></ul><h2 id="常见的内核参数"><a href="#常见的内核参数" class="headerlink" title="常见的内核参数"></a>常见的内核参数</h2><table><thead><tr><th>参数</th><th>说明</th><th>示例值</th></tr></thead><tbody><tr><td><strong>内存管理相关参数</strong></td><td></td><td></td></tr><tr><td>vm.swappiness</td><td>控制内核将进程内存交换到交换分区的倾向</td><td>10</td></tr><tr><td>vm.dirty_ratio</td><td>系统内存中可写缓存占总内存的百分比，超过该值将触发写回磁盘</td><td>20</td></tr><tr><td>vm.overcommit_memory</td><td>控制内存分配策略，0表示启用内存过量使用检查，1表示允许过量使用，2表示严格模式</td><td>1</td></tr><tr><td>vm.min_free_kbytes</td><td>系统保持的最小空闲内存量，防止内存完全用完导致系统崩溃</td><td></td></tr><tr><td><strong>网络相关参数</strong></td><td></td><td></td></tr><tr><td>net.ipv4.ip_forward</td><td>启用或禁用IP转发</td><td>1</td></tr><tr><td>net.ipv4.conf.all.rp_filter</td><td>启用反向路径过滤，防止IP欺骗攻击</td><td></td></tr><tr><td>net.ipv4.tcp_syncookies</td><td>启用SYN cookies，防止SYN泛洪攻击</td><td>1</td></tr><tr><td>net.core.somaxconn</td><td>定义系统中每个端口最大的监听队列长度</td><td>1024</td></tr><tr><td>net.ipv4.tcp_max_syn_backlog</td><td>控制TCP协议栈中SYN请求的最大队列长度</td><td></td></tr><tr><td><strong>文件系统相关参数</strong></td><td></td><td></td></tr><tr><td>fs.file-max</td><td>系统级别的文件句柄数量限制</td><td>100000</td></tr><tr><td>fs.inotify.max_user_watches</td><td>单个用户可以创建的inotify监视数量</td><td>524288</td></tr><tr><td>fs.aio-max-nr</td><td>系统级别的异步I/O请求最大数量</td><td></td></tr><tr><td><strong>安全相关参数</strong></td><td></td><td></td></tr><tr><td>kernel.randomize_va_space</td><td>控制地址空间布局随机化（ASLR），提高系统安全性</td><td>2</td></tr><tr><td>kernel.sysrq</td><td>控制SysRq键的功能，提供低级别的系统控制和调试功能</td><td>0</td></tr><tr><td>kernel.panic</td><td>设置内核崩溃后重新启动系统的时间（秒）</td><td>10</td></tr><tr><td><strong>调度器相关参数</strong></td><td></td><td></td></tr><tr><td>kernel.sched_migration_cost_ns</td><td>定义任务迁移的代价，用于调度器的决策</td><td>500000</td></tr><tr><td>kernel.sched_min_granularity_ns</td><td>定义调度器分配时间片的最小粒度</td><td>1000000</td></tr></tbody></table><h2 id="内核的主要组成部分"><a href="#内核的主要组成部分" class="headerlink" title="内核的主要组成部分"></a>内核的主要组成部分</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程调度："><a href="#进程调度：" class="headerlink" title="进程调度："></a>进程调度：</h4><ul><li>Linux内核使用多种调度算法，决定那个进程获得CPU时间，确保各个进程公平使用CPU资源。<h4 id="进程同步："><a href="#进程同步：" class="headerlink" title="进程同步："></a>进程同步：</h4></li><li>内核提供了多种机制，处理进程或线程之间的同步，防止数据争抢，确保线程安全。</li></ul><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul><li>支持多种进程间通信IPC方法，包括信号，管道，消息队列，共享内存和套接字。</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>虚拟内存：程序使用比实际物理内存更多的地址空间，通过使用分页/分段来实现</li><li>内存分配：内核提供多级分配框架，包括页分配器，slab分配器（说实话有够抽象的。）</li><li>交换空间：当物理内存不足时，内核可以将内存页移动到磁盘上的交换控件，以来释放内存。<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3></li><li>支持ext4，XFS，Btrfs，NFS和更多，以适应不同的存储需求和性能特点。</li><li>虚拟文件系统，VFS提供一个统一接口来访问不同文件系统</li><li>文件操作，内核提供系统调用，open，read，write，close。<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3></li><li>字符设备和块设备：Linux区分字符设备，键盘鼠标和块设备硬盘驱动器。</li><li>模块化驱动：Linux支持动态加载和卸载设备驱动模块，这允许不重启系统的情况下添加或更新驱动程序。<h3 id="网络栈"><a href="#网络栈" class="headerlink" title="网络栈"></a>网络栈</h3></li><li>协议实现：内核实现了各种网络协议，IP，TCP，UDP和ICMP</li><li>网络接口：通过网络接口与各种网络硬件进行交互，如以太网卡，无限适配</li><li>网络数据处理：内核处理数据包路由，转发，过滤，支持高级网络功能，如虚拟网络，网络安全规则等。</li></ul><h2 id="linux防火墙"><a href="#linux防火墙" class="headerlink" title="linux防火墙"></a>linux防火墙</h2><ul><li>防火墙系统主要基于iptable，以及比较新的nftables系统，运行管理员配置规则，控制进出网络接口的数据包。</li></ul><ol><li>iptables是一个广泛使用防火墙工具，使用一组表来组织规则，每个表包含多个链，链中包含具体规则，主要有 filter默认表，nat网络地址转换（处理进出接口的地址和端口转换），mangle用来修改数据包的内容，raw配置免除连接跟踪机制的数据包。</li></ol><h2 id="APT包管理"><a href="#APT包管理" class="headerlink" title="APT包管理"></a>APT包管理</h2><ul><li>使用的是.deb包格式，通过apt源来管理和安装软件包。</li><li>一般是使用的linux发行版有Ubuntu，Debian，Linux Mint等</li></ul><h3 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h3><p>  一般可以通过编辑/etc/apt/sourcer.list文件或者在sources.list.d目录下面，创建一个新的源。然后通过更新apt索引的方式。deb标识这是一个二进制的源，一般都会需要导入公钥，验证软件包的真实性，APT使用的是PGP签名，如果你源头是签名的，你需要的导入并信任该公钥，通常，源提供者会提供公钥和相应的导入命令。一般都是会直接把源echo进去，比较快捷。</p><h4 id="sources-list文件结构"><a href="#sources-list文件结构" class="headerlink" title="sources.list文件结构"></a>sources.list文件结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type uri suite &#123;component&#125;</span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ focal main restricted</span><br></pre></td></tr></table></figure><ul><li>type:源的类型，通常是 <code>deb</code> 用于二进制包，或 <code>deb-src</code> 用于源代码包</li><li>uri:源的URI</li><li>suite:发行版的代号,buster,bullseye,focal,bionic</li><li>component:可选，指定源中的区域或分区 </li></ul><h2 id="YUM-DNF包管理"><a href="#YUM-DNF包管理" class="headerlink" title="YUM,DNF包管理"></a>YUM,DNF包管理</h2><ul><li>基于RPM的Linux发行版，使用.repo文件来定义软件仓库。</li><li>一般是使用的linux发行版有Fedora，CentOS和RHEL等</li></ul><h3 id="添加源-1"><a href="#添加源-1" class="headerlink" title="添加源"></a>添加源</h3><p>一般添加源可以创建一个新的文件或者编辑指定现有文件，这个和apt包管理的添源方式类似。但是他们的文件结构格式大不相同</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仓库的唯一标识符。这个ID在 .repo 文件中必须是唯一的</span></span><br><span class="line"><span class="section">[docker-ce-stable]</span></span><br><span class="line"><span class="comment"># 仓库的描述性名称</span></span><br><span class="line"><span class="attr">name</span>=Docker CE Stable - <span class="variable">$basearch</span> </span><br><span class="line"><span class="comment"># 仓库的基本URL，指向包含RPM包的目录</span></span><br><span class="line"><span class="attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="number">7</span>/<span class="variable">$basearch</span>/stable</span><br><span class="line"><span class="comment"># 定是否启用该仓库。设置为 1 表示启用，0 表示禁用</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指定是否检查GPG签名。设置为 1 表示启用GPG签名检查</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 指向GPG公钥文件的路径，用于验证包的签名。</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br></pre></td></tr></table></figure><h3 id="更新方式也和apt管理不同"><a href="#更新方式也和apt管理不同" class="headerlink" title="更新方式也和apt管理不同"></a>更新方式也和apt管理不同</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum(dnf) makecache fast</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里为止，我依然觉得我还是不够了解Linux内核，总感觉没有想象的那么简单。可能过几天忙过了可以开始了解和学习一下KVM可能那里会给我一些答案。希望自己也能开始重新拾取对知识的渴望和动力吧。</p>]]></content>
    
    
    <summary type="html">一次对Linux的探讨以及自我端正</summary>
    
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://kalyan-zitiu.github.io/tags/Linux/"/>
    
    <category term="内核" scheme="https://kalyan-zitiu.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>简易高弹性B/S架构</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/12/%E7%AE%80%E6%98%93%E9%AB%98%E5%BC%B9%E6%80%A7BS%E6%9E%B6%E6%9E%84/</id>
    <published>2024-04-12T12:00:00.000Z</published>
    <updated>2024-06-24T07:59:40.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VPC架构设计"><a href="#VPC架构设计" class="headerlink" title="VPC架构设计"></a><strong>VPC架构设计</strong></h3><p>一个虚拟私有云（VPC）的结构，名称为“MyVPC”。该VPC包含4个子网，分布在两个可用区（us-east-1a和us-east-1b）中。其中，us-east-1a包含PublicSubnet1和PrivateSubnet1，us-east-1b包含PublicSubnet2和PrivateSubnet2。此外，该VPC还配置了两个路由表：PrivateRouteTable和PublicRouteTable，其中一个路由表的ID为“rtb-08c231d3d0fbbf2c2”。最后，图中显示了两个网络设备：MyInternetGateway和MyNatGateway。这些组件共同构成了一个典型的VPC架构，用于管理和控制网络流量的路由和访问。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154008942.png" alt="image-20240624154008942"></p><h3 id="B-S架构设计"><a href="#B-S架构设计" class="headerlink" title="B/S架构设计"></a><strong>B/S架构设计</strong></h3><p>这幅图展示了一个详细的虚拟私有云（VPC）架构，包含多个AWS组件和服务。该架构包括一个名为”MyVPC”的VPC，内部包含多个子网（如PublicSubnetA、PublicSubnetB、PrivateSubnetA、PrivateSubnetB）和路由表（如PublicRouteTable、PrivateRouteTable）。此外，还配置了网络ACL（如PublicNetworkACL、PrivateNetworkACL）来控制子网的入站和出站流量。网络设备方面，包含一个InternetGateway用于公共子网的互联网访问，以及一个NATGateway和其对应的弹性IP用于私有子网的互联网访问。安全组（如PublicInstanceSecurityGroup、PrivateInstanceSecurityGroup）用于实例的流量控制。实例部分，包括PublicInstanceA、PublicInstanceB、PrivateInstanceA、PrivateInstanceB等。</p><p>该架构使用堡垒机来登录实例，VPC通过CloudFormation模板构建，并基于CloudWatch指标实现自动扩展（AutoScaling）。会话状态保存在DynamoDB中，数据库缓存使用Amazon<br>ElastiCache for<br>Redis。此外，还使用消息队列SQS来处理消息。这些组件通过复杂的连接关系，构成了一个集成的、高度可扩展和可靠的网络架构，用于管理和控制流量的路由、访问和安全性，适用于在云环境中部署和管理各种应用和服务。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154015927.png" alt="image-20240624154015927"></p><h3 id="Auto-Scaling组配置"><a href="#Auto-Scaling组配置" class="headerlink" title="Auto Scaling组配置"></a><strong>Auto Scaling组配置</strong></h3><p>定义了一个自动扩展启动配置（Launch<br>Configuration），指定了使用的AMI镜像、实例类型、安全组、用户数据等信息，确保新实例能够按照指定的配置启动并运行。接着创建了一个自动扩展组（Auto<br>Scaling<br>Group），设置了VPC子网、启动配置、最小和最大实例数量、目标组等参数，以便根据负载情况自动调整实例数量。同时，配置了CloudWatch告警监控CPU利用率高低，当CPU利用率超过或低于阈值时，会触发相应的扩展或缩容策略。具体而言，定义了两个告警，分别用于CPU利用率超过70%和低于30%时的自动扩展和缩容操作。此外，还设置了扩展和缩容策略，包括调整实例数量、冷却时间等参数，以确保系统能够根据负载情况自动调整实例数量，实现自动化弹性扩展和收缩。整体而言，这个配置文件实现了一个基于CPU利用率的自动扩展机制，能够根据实际负载情况动态调整实例数量，提高系统的</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154021722.png" alt="image-20240624154021722"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154027789.png" alt="image-20240624154027789"></p><h3 id="ALB配置"><a href="#ALB配置" class="headerlink" title="ALB配置"></a><strong>ALB配置</strong></h3><p>这个应用负载均衡器（ALB）在你的架构中担任了至关重要的角色，确保了应用的高效运行和用户体验的优化。具体来说，ALB将进入的应用程序流量智能地分配到多个目标（如EC2实例），平衡了负载并防止了单点故障，从而保证了系统的高可用性和可扩展性。通过定期进行健康检查，ALB确保只有健康的实例接收流量，如果某个实例出现故障，它会自动将流量重定向到其他健康的实例，提高了应用的可靠性。</p><p>此外，ALB支持基于内容的路由功能，可以根据请求的URL路径、HTTP头、查询字符串等，将流量路由到不同的目标组，使得你可以更灵活地管理流量，比如将静态内容和动态内容分开处理，从而优化资源使用。ALB还可以与AWS的安全服务（如AWS<br>WAF和ACM）集成，提供强大的安全防护，支持SSL/TLS终止，确保传输层的安全，同时简化了证书管理。通过与Auto<br>Scaling集成，ALB可以根据流量负载自动增加或减少目标实例的数量，确保了应用能够应对流量高峰，同时优化了成本。ALB还与CloudWatch无缝集成，提供详细的监控和日志记录功能，让你可以实时监控流量模式、请求响应时间等关键指标，快速识别和解决潜在问题。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154059526.png" alt="image-20240624154059526"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154041177.png" alt="image-20240624154035908"></p><h3 id="通过CloudFormation进行快速实施过程"><a href="#通过CloudFormation进行快速实施过程" class="headerlink" title="通过CloudFormation进行快速实施过程"></a><strong>通过CloudFormation进行快速实施过程</strong></h3><p>首先，通过CloudFormation创建一个VPC和多个子网，配置Internet网关和NAT网关以实现公共和私有网络的连接。然后设置安全组并启动Bastion主机作为跳板机。接着，配置目标组和创建应用负载均衡器，设置监听器以将流量引导到后端实例。定义启动配置并基于此配置创建自动伸缩组，实现根据负载情况动态调整实例数量。继续创建RDS子网组和部署RDS实例，确保数据库服务的高可用性和持久性。创建DynamoDB表以存储非结构化数据，实现快速读写和扩展性。配置ElastiCache子网组并部署ElastiCache集群，提供高性能的缓存服务，加速数据访问。最后，创建SQS队列用于处理消息队列，确保应用程序之间的异步通信。在完成上述步骤后，获取关键资源的信息，包括Bastion主机的公有IP地址用于远程访问，负载均衡器的DNS名称用于访问应用程序，RDS实例的终端节点用于数据库连接，DynamoDB表名用于数据存储，Redis缓存的终端节点用于快速数据缓存，以及SQS队列的URL用于消息处理。这样可以确保整个架构的部署和运行顺利进行。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154107810.png" alt="image-20240624154107810"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154125600.png" alt="image-20240624154125600"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154118431.png" alt="image-20240624154114091"></p><h3 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a><strong>遇到的问题与解决方案</strong></h3><p>权限问题：如果遇到权限不足的问题，确保使用的IAM用户或角色具有必要的权限，比如创建VPC、子网、EC2实例、RDS实例等权限。</p><p>资源限制问题：如果遇到资源限制（如EC2实例配额不足），可以通过联系AWS支持来提升配额。</p><p>网络配置问题：确保VPC和子网的CIDR块配置正确，避免重叠。确保安全组规则配置正确，允许所需的入站和出站流量。</p><p>模板语法错误：使用AWS<br>CloudFormation的模板验证工具来检查模板语法是否正确。</p><h3 id="测试方案与结果"><a href="#测试方案与结果" class="headerlink" title="测试方案与结果"></a><strong>测试方案与结果</strong></h3><h4 id="基于CloudWatch的AutoScaling"><a href="#基于CloudWatch的AutoScaling" class="headerlink" title="基于CloudWatch的AutoScaling"></a><strong>基于CloudWatch的AutoScaling</strong></h4><p>CloudWatch的Auto<br>Scaling是一种动态调整计算资源以匹配应用需求的机制，通过监控关键指标（如CPU利用率）来触发扩展或缩减操作。CloudWatch会收集和监控这些指标，并基于设定的阈值触发警报。当警报触发时，Auto<br>Scaling组会根据预定义的策略自动增加或减少EC2实例的数量。例如，当CPU利用率超过某个阈值时，Auto<br>Scaling会增加实例数量以处理高负载；当CPU利用率低于阈值时，Auto<br>Scaling会减少实例数量以节约成本。通过这种方式，Auto<br>Scaling确保了应用程序的高可用性和性能，同时优化了资源使用和成本效益。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154158215.png" alt="image-20240624154158215"></p><h4 id="DynamoDB保存会话状态"><a href="#DynamoDB保存会话状态" class="headerlink" title="DynamoDB保存会话状态"></a><strong>DynamoDB保存会话状态</strong></h4><p>在Web应用中，会话（Session） 是在用户与服务器之间的交互过程中维持状态的一种方式。HTTP协议本身是无状态的，这意味着每个请求都是独立的，服务器默认不会记住前一个请求的信息。会话状态技术允许服务器记住用户的状态信息（如用户是否已登录、用户的偏好设置等），这对于创建交互式Web应用是必要的。DynamoDB作为会话存储的后端，帮助Web应用维护用户的状态，提供连贯的用户体验，并且能够在用户数量激增时保持高性能和可靠性。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154209751.png" alt="image-20240624154209751"></p><h4 id="使用消息队列SQS"><a href="#使用消息队列SQS" class="headerlink" title="使用消息队列SQS"></a><strong>使用消息队列SQS</strong></h4><p>使用AWS<br>SDK（例如Python的Boto3）向队列发送消息。首先，确保你已安装Boto3并配置了AWS凭证。接收消息也很简单。使用同样的SQS客户端，你可以从队列中拉取消息。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154216362.png" alt="image-20240624154216362"></p><h4 id="使用ElastiCache-for-Redis数据库缓存"><a href="#使用ElastiCache-for-Redis数据库缓存" class="headerlink" title="使用ElastiCache for Redis数据库缓存"></a><strong>使用ElastiCache for Redis数据库缓存</strong></h4><p>ElastiCache for Redis 是一种由 AWS<br>托管的内存缓存服务，通过在内存中存储数据，提供极低的延迟和高吞吐量的数据访问能力，适用于实时分析、会话存储和排行榜等应用场景。它支持水平和垂直扩展，可以根据应用需求动态调整节点数量和实例规格，确保在流量高峰期依然高效运行。通过多可用区部署和自动故障转移功能，ElastiCache<br>for Redis<br>提供了高可用性和数据持久性，确保在节点故障时数据不丢失并迅速恢复。此外，ElastiCache<br>for Redis 是完全托管的服务，AWS<br>负责基础设施管理、软件更新、安全补丁和备份恢复，简化了管理工作，使开发者可以专注于应用开发。它还支持VPC、子网、安全组和加密功能，确保数据传输和存储的安全性。总之，ElastiCache<br>for Redis<br>提供了一个高效、可靠和安全的缓存解决方案，显著提升了数据访问速度和系统响应能力，简化了缓存管理和运维工作，使开发者能够专注于核心业务逻辑的开发。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154224745.png" alt="image-20240624154224745"></p><h4 id="实例与数据库连接"><a href="#实例与数据库连接" class="headerlink" title="实例与数据库连接"></a><strong>实例与数据库连接</strong></h4><p>为了使EC2实例与RDS实例互联，需要创建并配置两个安全组，一个用于EC2实例，另一个用于RDS实例。然后在RDS实例的安全组中添加入站规则，允许从EC2实例的安全组IP地址范围通过数据库端口（如3306）进行访问。最后，在EC2实例中配置数据库客户端，使用RDS实例的端点和端口号进行连接，从而实现网络通信与数据库操作。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154229517.png" alt="image-20240624154229517"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154234077.png" alt="image-20240624154234077"></p><h4 id="用CloudFormation进行VPC内容创建"><a href="#用CloudFormation进行VPC内容创建" class="headerlink" title="用CloudFormation进行VPC内容创建"></a><strong>用CloudFormation进行VPC内容创建</strong></h4><p>使用CloudFormation进行VPC创建可以自动化管理和部署完整网络架构。通过编写CloudFormation模板，可以创建一个VPC，设置其CIDR块，配置公共和私有子网，创建并连接Internet网关和NAT网关，并配置路由表和关联。这样不仅提高了部署效率，还减少了人为配置错误，确保网络架构的可重复性和一致性。例如，模板中配置了一个CIDR为10.0.0.0/16的VPC，包含两个公共子网和两个私有子网，并分别配置了路由表和NAT网关，以保证私有子网具有访问外部网络的能力。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">AWSTemplateFormatVersion:</span> <span class="string">&#x27;2010-09-09&#x27;</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">AWS</span> <span class="string">CloudFormation</span> <span class="string">Template</span> <span class="string">for</span> <span class="string">B/S</span> <span class="string">Architecture</span> <span class="string">with</span> <span class="string">VPC,</span> <span class="string">Subnets,</span> <span class="string">RDS,</span> <span class="string">EC2,</span> <span class="string">Auto</span> <span class="string">Scaling,</span> <span class="string">DynamoDB,</span> <span class="string">ElastiCache,</span> <span class="string">and</span> <span class="string">SQS</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Resources:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">MyVPC:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPC</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">EnableDnsSupport:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">EnableDnsHostnames:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyVPC</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1a</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Subnet</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">CidrBlock:</span> <span class="number">10.0</span><span class="number">.3</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">MapPublicIpOnLaunch:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">AvailabilityZone:</span> <span class="string">us-east-1b</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateSubnet2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">InternetGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::InternetGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyInternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">GatewayAttachment:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::VPCGatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">InternetGatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGatewayEIP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::EIP</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Domain:</span> <span class="string">vpc</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGatewayEIP</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">NatGateway:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::NatGateway</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">AllocationId:</span> <span class="type">!GetAtt</span> <span class="string">NatGatewayEIP.AllocationId</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyNatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPublicRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">DependsOn:</span> <span class="string">GatewayAttachment</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">GatewayId:</span> <span class="type">!Ref</span> <span class="string">InternetGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PublicSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PublicRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateRouteTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::RouteTable</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">DefaultPrivateRoute:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Route</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line">      <span class="attr">DestinationCidrBlock:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">NatGatewayId:</span> <span class="type">!Ref</span> <span class="string">NatGateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet1RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">PrivateSubnet2RouteTableAssociation:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SubnetRouteTableAssociation</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">RouteTableId:</span> <span class="type">!Ref</span> <span class="string">PrivateRouteTable</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">WebServerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">HTTP,</span> <span class="string">RDP,</span> <span class="string">and</span> <span class="string">SSH</span> <span class="string">access</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">SSH</span> <span class="string">access</span> <span class="string">to</span> <span class="string">bastion</span> <span class="string">host</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">3389</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">BastionHostInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::Instance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">SubnetId:</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">BastionHostSecurityGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">BastionHostInstance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Load Balancer Security Group</span></span><br><span class="line">  <span class="attr">LoadBalancerSecurityGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::EC2::SecurityGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">GroupDescription:</span> <span class="string">Enable</span> <span class="string">access</span> <span class="string">to</span> <span class="string">Load</span> <span class="string">Balancer</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">SecurityGroupIngress:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">IpProtocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="attr">FromPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">ToPort:</span> <span class="number">5555</span></span><br><span class="line">          <span class="attr">CidrIp:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Application Load Balancer</span></span><br><span class="line">  <span class="attr">ApplicationLoadBalancer:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::LoadBalancer</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Name:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Subnets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PublicSubnet2</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">LoadBalancerSecurityGroup</span></span><br><span class="line">      <span class="attr">Scheme:</span> <span class="string">internet-facing</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyApplicationLoadBalancer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Target Group for Load Balancer</span></span><br><span class="line">  <span class="attr">TargetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">TargetGroupTwo:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::TargetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VpcId:</span> <span class="type">!Ref</span> <span class="string">MyVPC</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">TargetType:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">HealthCheckProtocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">HealthCheckPort:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">HealthCheckPath:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">HealthCheckIntervalSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">HealthCheckTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">HealthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">UnhealthyThresholdCount:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyTargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Listener for Load Balancer</span></span><br><span class="line">  <span class="attr">LoadBalancerListenerHTTP:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">LoadBalancerListenerCustomPort:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElasticLoadBalancingV2::Listener</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">LoadBalancerArn:</span> <span class="type">!Ref</span> <span class="string">ApplicationLoadBalancer</span></span><br><span class="line">      <span class="attr">Protocol:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">5555</span></span><br><span class="line">      <span class="attr">DefaultActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Type:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">TargetGroupArn:</span> <span class="type">!Ref</span> <span class="string">TargetGroupTwo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Auto Scaling Launch Configuration</span></span><br><span class="line">  <span class="attr">LaunchConfiguration:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::LaunchConfiguration</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">ImageId:</span> <span class="string">ami-00beae93a2d981137</span></span><br><span class="line">      <span class="attr">InstanceType:</span> <span class="string">t2.micro</span></span><br><span class="line">      <span class="attr">KeyName:</span> <span class="string">keytest</span></span><br><span class="line">      <span class="attr">SecurityGroups:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">UserData:</span></span><br><span class="line">        <span class="attr">Fn::Base64:</span> <span class="type">!Sub</span> <span class="string">|</span></span><br><span class="line"><span class="string">          #!/bin/bash</span></span><br><span class="line"><span class="string">          yum update -y</span></span><br><span class="line"><span class="string">          yum install -y httpd nodejs unzip</span></span><br><span class="line"><span class="string">          systemctl start httpd</span></span><br><span class="line"><span class="string">          systemctl enable httpd</span></span><br><span class="line"><span class="string">          cd /var/www/html</span></span><br><span class="line"><span class="string">          aws s3 cp s3://myawsbucketkalyanzitiu/mysqlViewer.zip</span></span><br><span class="line"><span class="string">          unzip mysqlViewer.zip</span></span><br><span class="line"><span class="string">          rm mysqlViewer.zip</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          node /var/www/html/start.js &amp;</span></span><br><span class="line"><span class="string">          /opt/aws/bin/cfn-signal -e $? --stack $&#123;AWS::StackName&#125; --resource AutoScalingGroup --region $&#123;AWS::Region&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="comment"># Auto Scaling Group</span></span><br><span class="line">  <span class="attr">AutoScalingGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::AutoScalingGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">VPCZoneIdentifier:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">LaunchConfigurationName:</span> <span class="type">!Ref</span> <span class="string">LaunchConfiguration</span></span><br><span class="line">      <span class="attr">MinSize:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">MaxSize:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">DesiredCapacity:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">TargetGroupARNs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">TargetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyAutoScalingGroup</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Environment</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">Production</span></span><br><span class="line">          <span class="attr">PropagateAtLaunch:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># CloudWatch Alarm for Auto Scaling</span></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmHigh:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale up if CPU &gt; 70% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">70</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">GreaterThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleUpPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">CPUUtilizationAlarmLow:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::CloudWatch::Alarm</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AlarmDescription:</span> <span class="string">&quot;Scale down if CPU &lt; 30% for 5 minutes&quot;</span></span><br><span class="line">      <span class="attr">Namespace:</span> <span class="string">AWS/EC2</span></span><br><span class="line">      <span class="attr">MetricName:</span> <span class="string">CPUUtilization</span></span><br><span class="line">      <span class="attr">Dimensions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">AutoScalingGroupName</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">Statistic:</span> <span class="string">Average</span></span><br><span class="line">      <span class="attr">Period:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">EvaluationPeriods:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Threshold:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">ComparisonOperator:</span> <span class="string">LessThanThreshold</span></span><br><span class="line">      <span class="attr">AlarmActions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Ref:</span> <span class="string">ScaleDownPolicy</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scaling Policies</span></span><br><span class="line">  <span class="attr">ScaleUpPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ScaleDownPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::AutoScaling::ScalingPolicy</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">AutoScalingGroupName:</span> <span class="type">!Ref</span> <span class="string">AutoScalingGroup</span></span><br><span class="line">      <span class="attr">PolicyType:</span> <span class="string">SimpleScaling</span></span><br><span class="line">      <span class="attr">AdjustmentType:</span> <span class="string">ChangeInCapacity</span></span><br><span class="line">      <span class="attr">ScalingAdjustment:</span> <span class="number">-1</span></span><br><span class="line">      <span class="attr">Cooldown:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DynamoDB Table</span></span><br><span class="line">  <span class="attr">DynamoDBTable:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::DynamoDB::Table</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TableName:</span> <span class="string">SessionTable</span></span><br><span class="line">      <span class="attr">AttributeDefinitions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">AttributeType:</span> <span class="string">S</span></span><br><span class="line">      <span class="attr">KeySchema:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">AttributeName:</span> <span class="string">SessionId</span></span><br><span class="line">          <span class="attr">KeyType:</span> <span class="string">HASH</span></span><br><span class="line">      <span class="attr">ProvisionedThroughput:</span></span><br><span class="line">        <span class="attr">ReadCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">WriteCapacityUnits:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">SessionTable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ElastiCache for Redis</span></span><br><span class="line">  <span class="attr">RedisCacheCluster:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::CacheCluster</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">CacheNodeType:</span> <span class="string">cache.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">NumCacheNodes:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">VpcSecurityGroupIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">WebServerSecurityGroup</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">RedisCacheCluster</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">RedisSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::ElastiCache::SubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Description:</span> <span class="string">&quot;Subnet group for Redis cache&quot;</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">CacheSubnetGroupName:</span> <span class="string">RedisSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># SQS Queue</span></span><br><span class="line">  <span class="attr">SQSQueue:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::SQS::Queue</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">QueueName:</span> <span class="string">MyQueue</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MySQSQueue</span></span><br><span class="line">          </span><br><span class="line">  <span class="attr">MyDBSubnetGroup:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBSubnetGroup</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBSubnetGroupDescription:</span> <span class="string">My</span> <span class="string">DB</span> <span class="string">Subnet</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">SubnetIds:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="type">!Ref</span> <span class="string">PrivateSubnet2</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RDS Instance for Multi-AZ Deployment</span></span><br><span class="line">  <span class="attr">DBInstance:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::RDS::DBInstance</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">DBName:</span> <span class="string">MyDatabase</span></span><br><span class="line">      <span class="attr">AllocatedStorage:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">DBInstanceClass:</span> <span class="string">db.t3.micro</span></span><br><span class="line">      <span class="attr">Engine:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MasterUsername:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">MasterUserPassword:</span> <span class="string">admin123</span></span><br><span class="line">      <span class="attr">VPCSecurityGroups:</span> []</span><br><span class="line">      <span class="attr">DBSubnetGroupName:</span> <span class="type">!Ref</span> <span class="string">MyDBSubnetGroup</span></span><br><span class="line">      <span class="attr">MultiAZ:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">Tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">Key:</span> <span class="string">Name</span></span><br><span class="line">          <span class="attr">Value:</span> <span class="string">MyRDSInstance</span></span><br><span class="line">    <span class="attr">DeletionPolicy:</span> <span class="string">Snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Outputs:</span></span><br><span class="line">  <span class="attr">DBInstanceEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the RDS instance&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">DBInstance.Endpoint.Address</span></span><br><span class="line">  <span class="attr">BastionHostPublicIp:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The public IP address of the bastion host&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">BastionHostInstance.PublicIp</span></span><br><span class="line">  <span class="attr">LoadBalancerDNSName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The DNS name of the Application Load Balancer&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">ApplicationLoadBalancer.DNSName</span></span><br><span class="line">  <span class="attr">DynamoDBTableName:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The name of the DynamoDB table&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">DynamoDBTable</span> </span><br><span class="line">  <span class="attr">RedisCacheEndpoint:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The endpoint of the Redis cache cluster&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!GetAtt</span> <span class="string">RedisCacheCluster.RedisEndpoint.Address</span></span><br><span class="line">  <span class="attr">SQSQueueURL:</span></span><br><span class="line">    <span class="attr">Description:</span> <span class="string">&quot;The URL of the SQS queue&quot;</span></span><br><span class="line">    <span class="attr">Value:</span> <span class="type">!Ref</span> <span class="string">SQSQueue</span></span><br></pre></td></tr></table></figure><h4 id="使用堡垒机登录实例"><a href="#使用堡垒机登录实例" class="headerlink" title="使用堡垒机登录实例"></a><strong>使用堡垒机登录实例</strong></h4><p>首先，通过SSH连接到堡垒机，以便安全地访问私有子网内的Web实例。登录堡垒机后，利用存储在堡垒机上的SSH密钥登录私有子网内的Web实例进行部署操作。有时使用密钥登录可能会显示“权限被拒绝”的错误，这通常是由于密钥文件权限设置不正确导致的。此时，可以通过运行chmod<br>400<br>path_to_your_private_key命令重新设置密钥文件权限，确保只有当前用户可以读取该文件，从而解决登录被拒绝的问题。通过这种方式，能够安全有效地管理和部署私有子网内的实例。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154256449.png" alt="image-20240624154256449"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154303065.png" alt="image-20240624154303065"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154308929.png" alt="image-20240624154308929"></p><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a><strong>性能评估</strong></h3><h4 id="负载均衡测试"><a href="#负载均衡测试" class="headerlink" title="负载均衡测试"></a><strong>负载均衡测试</strong></h4><p>通过性能监控对实例进行分流，显示不同ip型号的实例</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154334381.png" alt="image-20240624154334381"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154338428.png" alt="image-20240624154338428"></p><h4 id="数据库性能测试"><a href="#数据库性能测试" class="headerlink" title="数据库性能测试"></a><strong>数据库性能测试</strong></h4><p>显示了数据库性能测试中的几个关键指标，包括剩余存储空间、读写操作次数（IOPS）、网络接收与发送吞吐量等。图中显示在测试初期读写操作和网络传输活动较高，随后逐渐趋于平稳，表明数据库在高负载初期经过密集活动后恢复到稳定状态。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154345250.png" alt="image-20240624154345250"></p><h4 id="自动伸缩功能测试"><a href="#自动伸缩功能测试" class="headerlink" title="自动伸缩功能测试"></a><strong>自动伸缩功能测试</strong></h4><p>进行自动伸缩功能测试时，首先配置一个Auto<br>Scaling组，并设置其最小实例数为2，最大实例数为3。此外，创建缩放策略，当CPU利用率低于30%时减少实例数量，当CPU利用率高于70%时增加实例数量。启动测试后，可以观察到，当负载增加时，Auto<br>Scaling组中的实例数量从2个自动扩展到3个，而在负载减小时，实例数量则会减少回2个。这种自动调整实例数量的功能确保了应用在高负载时有足够的资源，同时在低负载时节省资源成本。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154404728.png" alt="image-20240624154404728"></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20240624154356696.png" alt="image-20240624154351414"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154414919.png" alt="image-20240624154414919"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154424766.png" alt="image-20240624154424766"></p><h4 id="项目部署效果测试"><a href="#项目部署效果测试" class="headerlink" title="项目部署效果测试"></a><strong>项目部署效果测试</strong></h4><p>项目架构部署在AWS云平台上，使用包含两个可用区的VPC，配置有公有和私有子网，互联网网关和NAT网关。核心部分是通过配置在互联网网关内的应用程序负载均衡器和Auto<br>Scaling组，实现Web实例的自动扩展，并将这些实例分布在两个可用区内。同时，RDS数据库配置了主备实例，确保数据的高可用性和可靠性。安全组进一步管理网络安全，确保系统的高可用性和灵活扩展性。</p><p>当负载均衡器正常运行时，提示项目成功启动。您可以通过访问以下URL连接到数据库并查看Web项目：</p><p><a href="http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/">http://myapplicationloadbalancer-608454718.us-east-1.elb.amazonaws.com:5555/</a></p><p>这将能够直接访问部署在AWS上的Web应用，并与底层的数据库实例交互，确保应用的可靠运行和性能优化。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154510878.png" alt="image-20240624154510878"></p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240624154514651.png" alt="image-20240624154514651"></p>]]></content>
    
    
    <summary type="html">AWS Certified Solutions Architect - Associate</summary>
    
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/categories/Basic/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/Basic/AWS/"/>
    
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>EKS概述</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/10/%E7%9E%8E%E7%8E%A9EKS/</id>
    <published>2024-04-10T12:00:00.000Z</published>
    <updated>2024-06-30T10:38:07.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EKS"><a href="#EKS" class="headerlink" title="EKS"></a>EKS</h1><p>学校给的AWS沙盒快过期了，剩下几十🔪也不想浪费，突然发现居然有给EKS的权限，想到前几天自建K8S集群的经历，虽然可以熟悉集群流程，但是倘若在生产环境下，还是有安全高可用的托管平台舒服。</p><h2 id="架构结构"><a href="#架构结构" class="headerlink" title="架构结构"></a>架构结构</h2><p>学习一个东西，肯定是先了解概念以及大概的结构，由大入微，最重要的是要不断实践和尝试，通过实际操作来加深对该工具或技术的理解。</p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>首先是k8s，一个开源容器编排平台，源于Google的Borg。主要就是能够多平台进行自动化调度，修复，扩展，服务发现和负载，存储编排等重要功能。</p><p><img src="https://github.com/ben1234560/k8s_PaaS/raw/master/assets/1582188308711.png" alt="1582188308711"></p><h4 id="经典七大件"><a href="#经典七大件" class="headerlink" title="经典七大件"></a>经典七大件</h4><ol><li><p><strong>kube-apiserver</strong>：Kubernetes API服务器，提供了Kubernetes集群的API接口，负责接收和处理来自用户、控制器和其他组件的请求。</p></li><li><p><strong>kube-controller-manager</strong>：Kubernetes控制器管理器，包含多个控制器，负责监控集群状态并根据预定义的控制器逻辑进行调整，确保集群中的资源达到预期状态。</p></li><li><p><strong>kube-scheduler</strong>：Kubernetes调度器，负责根据Pod的调度策略（如资源需求、亲和性、反亲和性等）选择合适的Node节点来运行Pod。</p></li><li><p><strong>kubelet</strong>：每个Node节点上运行的Kubernetes代理，负责管理Node节点上的Pod和容器，与kube-apiserver通信，执行Pod的生命周期管理和监控。</p></li><li><p><strong>kube-proxy</strong>：Kubernetes网络代理，负责为Pod提供网络代理和负载均衡功能，实现Pod之间和Pod与外部网络的通信。</p></li><li><p><strong>etcd</strong>：分布式键值存储系统，用于存储Kubernetes集群的所有配置数据、状态信息和元数据，保证集群的一致性和可靠性。</p></li><li><p><strong>Container Runtime</strong>：容器运行时，负责在Node节点上创建和管理容器，常见的容器运行时包括Docker、containerd、CRI-O等。</p></li></ol><h3 id="EKS-1"><a href="#EKS-1" class="headerlink" title="EKS"></a>EKS</h3><p>EKS能够简化云上K8S的复杂性，提供一个高可用安全的控制平台，主要还可以集成其他服务，比如IAM、VPC、CloudWatch、ELB等。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630155419294.png" alt="image-20240630155419294"></p><p>上面的一个架构图，也是能够很清晰的看出来EKS Conrtol Plane成为了管理k8集群的核心组件，然后通过网络负载均衡余kubectl通信。咋一看好像中间少了API Server，scheduler，controller-manager这些组件，但是估计是由在集成在EKS Control里面的，而且相比于自建k8s集群的一个vpc内，这里却分为了两个VPC一个是管理的VPC，另一个是节点的VPC。这应该是属于一种网络隔离方法。可能是为了集群的稳定。其次就是责任分离了。然后工作节点的服务通过ELB来进行负载均衡给用户。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>首先配置eks集群</li><li>创建一个或多个工作节点</li><li>选择工具。并且连接到EKS</li><li>在pod上部署应用程序</li></ol><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630165310994.png" alt="image-20240630165310994"></p><h2 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h2><p>不得不说是真的方便，还能够同时集成多个插件和统一的管理。可惜了，后面有一些操作，权限不够用不了。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630183047481.png" alt="image-20240630183047481"></p>]]></content>
    
    
    <summary type="html">瞎玩EKS</summary>
    
    
    
    <category term="EKS" scheme="https://kalyan-zitiu.github.io/categories/EKS/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/EKS/K8S/"/>
    
    <category term="AWS" scheme="https://kalyan-zitiu.github.io/categories/EKS/K8S/AWS/"/>
    
    
    <category term="Academy" scheme="https://kalyan-zitiu.github.io/tags/Academy/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker部署Kubernetes</title>
    <link href="https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/"/>
    <id>https://kalyan-zitiu.github.io/2024/04/08/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2Kubernetes/</id>
    <published>2024-04-08T06:00:00.000Z</published>
    <updated>2024-06-30T05:34:01.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Docker部署Kubernetes"><a href="#基于Docker部署Kubernetes" class="headerlink" title="基于Docker部署Kubernetes"></a>基于Docker部署Kubernetes</h1><h2 id="学习环境架构搭建"><a href="#学习环境架构搭建" class="headerlink" title="学习环境架构搭建"></a>学习环境架构搭建</h2><h3 id="创建VPC"><a href="#创建VPC" class="headerlink" title="创建VPC"></a>创建VPC</h3><p>在AWS创建一个拥有一个子网的VPC</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629213836702.png" alt="image-20240629213836702"></p><h3 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h3><p>安全组为了方便最好把ssh的22端口以及Kubernetes API服务的端口6443设置为入站规则。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214700104.png" alt="image-20240629214700104"></p><h3 id="启动模板创建"><a href="#启动模板创建" class="headerlink" title="启动模板创建"></a>启动模板创建</h3><p>根据最小配置。</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240629214828795.png" alt="image-20240629214828795"></p><p>编写用户数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新系统软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Docker</span></span><br><span class="line">apt-get install -y docker.io</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Kubernetes官方APT软件仓库的密钥和仓库</span></span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新APT索引并安装kubelet, kubeadm和kubectl</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Swap（Kubernetes不支持运行在启用了Swap的机器上）</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>问题来了，当我试图用用户数据来做启动后的自动安装配置，由于Ubuntu版本命令已经不用apt-key了，所以在实例启动后并没有得到相应的环境，不过没有问题。</p><h2 id="Master主节点"><a href="#Master主节点" class="headerlink" title="Master主节点"></a>Master主节点</h2><h3 id="配置主节点环境以及准备初始化主节点"><a href="#配置主节点环境以及准备初始化主节点" class="headerlink" title="配置主节点环境以及准备初始化主节点"></a>配置主节点环境以及准备初始化主节点</h3><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. <strong>安装docker</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新本地的包索引数据库，这样在安装新软件时能获取到最新的软件包。</span></span><br><span class="line">sudo apt-get update </span><br><span class="line"><span class="comment"># 安装Docker。docker.io是Ubuntu官方仓库中Docker的软件包名称，-y参数表示自动同意安装过程中的询问。</span></span><br><span class="line">sudo apt-get install docker.io -y</span><br><span class="line"><span class="comment"># 启动Docker服务，并设置为开机自启动。</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><h3 id="2-关闭Swap"><a href="#2-关闭Swap" class="headerlink" title="2.关闭Swap"></a><strong>2.关闭Swap</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用swap（交换空间）。Kubernetes要求禁用swap，因为需要严格的资源控制和隔离，swap存在可能会影响性能和调度决策。</span></span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><h3 id="3-安装-cri-dockerd"><a href="#3-安装-cri-dockerd" class="headerlink" title="3.安装 cri-dockerd"></a>3.安装 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br><span class="line"><span class="comment"># cri-dockerd是一个桥接组件，允许Kubernetes通过CRI（容器运行时接口）与Docker交互。</span></span><br><span class="line">dpkg -i cri-dockerd_0.3.4.3-0.ubuntu-jammy_amd64.deb</span><br></pre></td></tr></table></figure><ul><li></li></ul><h3 id="4-启动并配置开机启动-cri-dockerd"><a href="#4-启动并配置开机启动-cri-dockerd" class="headerlink" title="4.启动并配置开机启动 cri-dockerd"></a>4.启动并配置开机启动 cri-dockerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now cri-docker.socket</span><br></pre></td></tr></table></figure><ul><li>这些命令设置<code>cri-docker</code>服务和socket的启动和开机自启动，确保Kubernetes可以正确与Docker通信。</li></ul><h3 id="5-安装-kubeadm、kubelet、kubectl"><a href="#5-安装-kubeadm、kubelet、kubectl" class="headerlink" title="5.安装 kubeadm、kubelet、kubectl"></a>5.安装 kubeadm、kubelet、kubectl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装网络传输和证书相关的工具，为后续下载和验证Kubernetes包做准备。</span></span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载并安装Kubernetes的GPG密钥，用于验证后续安装包的完整性。</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加Kubernetes的软件源，以便安装kubeadm、kubelet和kubectl。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] http://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><ul><li>测试拉取，然后查看需要的images</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630104435917.png" alt="image-20240630104435917"></p><ul><li>拉取镜像</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.27.4</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/etcd:3.5.7-0</span><br><span class="line">sudo docker pull registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630111103161.png" alt="image-20240630111103161"></p><h4 id="第一次尝试初始化"><a href="#第一次尝试初始化" class="headerlink" title="第一次尝试初始化"></a>第一次尝试初始化</h4><p>粗心大意,podSubnet没有注意大小写</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630113034682.png" alt="image-20240630113034682"></p><h4 id="第二次尝试初始化"><a href="#第二次尝试初始化" class="headerlink" title="第二次尝试初始化"></a>第二次尝试初始化</h4><p>需要reset一下kubeeadm</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们用的是docker</span></span><br><span class="line">sudo kubeadm reset -f --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630114542529.png" alt="image-20240630114542529"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>出现了两个问题,总的来说就是权限问题和连接问题.</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115125908.png" alt="image-20240630115125908"></p><h5 id="权限问题解决"><a href="#权限问题解决" class="headerlink" title="权限问题解决"></a>权限问题解决</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> ubuntu:ubuntu /etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>解决完权限问题后,连接问题也解决了</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630115354437.png" alt="image-20240630115354437"></p><p> 经过一定的搜寻和思考,</p><ul><li>运行上述命令后，你实际上是在改变 <code>/etc/kubernetes/admin.conf</code> 文件的所有权，将其从 <code>root</code> 用户和组更改为 <code>ubuntu</code> 用户和组。这样做的直接结果是，普通用户 <code>ubuntu</code> 现在有权限读取这个文件。</li><li>在k8s中集群中,<code>admin.conf</code> 文件包含了连接到集群的 K8s API 服务器的必要凭证和连接信息。这包括 API 服务器的地址、端口、使用的证书等。当你以 <code>ubuntu</code> 用户身份运行 <code>kubectl</code> 命令时，<code>kubectl</code> 会尝试读取这个配置文件来获取连接到 K8s 集群的必要信息。</li></ul><h4 id="先观察一下kubelet日志"><a href="#先观察一下kubelet日志" class="headerlink" title="先观察一下kubelet日志"></a>先观察一下kubelet日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl -u kubelet -f</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630120005623.png" alt="image-20240630120005623"></p><h4 id="再看一眼pod的日志"><a href="#再看一眼pod的日志" class="headerlink" title="再看一眼pod的日志"></a>再看一眼pod的日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定namespace;</span></span><br><span class="line">sudo kubectl logs coredns-5dd5756b68-jd25s --namespace=kube-system</span><br></pre></td></tr></table></figure><p>这种情况,大概率是网络上的,问题,经过查找需要安装一些网络插件</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630121445618.png" alt="image-20240630121445618"></p><h4 id="安装部署-Calico-网络插件"><a href="#安装部署-Calico-网络插件" class="headerlink" title="安装部署 Calico 网络插件"></a>安装部署 Calico 网络插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure><h2 id="Node-节点加入集群"><a href="#Node-节点加入集群" class="headerlink" title="Node 节点加入集群"></a>Node 节点加入集群</h2><h3 id="先在master节点查看加入命令"><a href="#先在master节点查看加入命令" class="headerlink" title="先在master节点查看加入命令"></a>先在master节点查看加入命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入命令,并指定cri-socket</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.0.1.237:6443 --token a69ewm.uvje3ei8zhox3xar --discovery-token-ca-cert-hash sha256:64db0e4e2ddc13e1a06390ac6b90b4f38a965fdc7cbfd2e3baa80a668e7cd74d --cri-socket unix:///run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><h3 id="为了node节点加入必备组件"><a href="#为了node节点加入必备组件" class="headerlink" title="为了node节点加入必备组件"></a>为了node节点加入必备组件</h3><p>成功后会显示</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630124600952.png" alt="image-20240630124600952"></p><p>然后主节点查看加入集群的节点</p><p><img src="https://gcore.jsdelivr.net/gh/Kalyan-zitiu/TyporaIMG/img/image-20240630125420559.png" alt="image-20240630125420559"></p><p>ps:如果报couldn’t get current server API group list: Get “<a href="http://localhost:8080/api?timeout=32s&quot;">http://localhost:8080/api?timeout=32s&quot;</a>: dial tcp 127.0.0.1:8080: connect: connection refused的话，大概率是终端断连导致之前export的环境变量失效了，可以在/etc/environment文件中加入KUBECONFIG=”/etc/kubernetes/admin.conf”以使环境变量永久生效</p>]]></content>
    
    
    <summary type="html">基于Docker部署Kubernetes</summary>
    
    
    
    <category term="docker" scheme="https://kalyan-zitiu.github.io/categories/docker/"/>
    
    <category term="K8S" scheme="https://kalyan-zitiu.github.io/categories/docker/K8S/"/>
    
    
    <category term="Basic" scheme="https://kalyan-zitiu.github.io/tags/Basic/"/>
    
  </entry>
  
</feed>
